Interrupt Vectors
    00000 940C 0276 JMP	__start|__text_start
    0003C 940C 37C1 JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    00276 EFCF      LDI	R28,0xFF
    00277 E1D0      LDI	R29,0x10
    00278 BFCD      OUT	0x3D,R28
    00279 BFDE      OUT	0x3E,R29
    0027A 51CE      SUBI	R28,0x1E
    0027B 40D0      SBCI	R29,0
    0027C EA0A      LDI	R16,0xAA
    0027D 8308      ST	Y,R16
    0027E 2400      CLR	R0
    0027F E1EC      LDI	R30,0x1C
    00280 E0F5      LDI	R31,5
    00281 E018      LDI	R17,0x8
    00282 30E3      CPI	R30,3
    00283 07F1      CPC	R31,R17
    00284 F011      BEQ	0x0287
    00285 9201      ST	Z+,R0
    00286 CFFB      RJMP	0x0282
    00287 8300      ST	Z,R16
    00288 EDE0      LDI	R30,0xD0
    00289 E0F0      LDI	R31,0
    0028A E0A0      LDI	R26,0
    0028B E0B1      LDI	R27,1
    0028C E014      LDI	R17,4
    0028D E000      LDI	R16,0
    0028E BF0B      OUT	0x3B,R16
    0028F 3EEC      CPI	R30,0xEC
    00290 07F1      CPC	R31,R17
    00291 F021      BEQ	0x0296
    00292 95C8      LPM
    00293 9631      ADIW	R30,1
    00294 920D      ST	X+,R0
    00295 CFF9      RJMP	0x028F
    00296 940E 2467 CALL	_main
_exit:
    00298 CFFF      RJMP	_exit
_disk_initialize:
  state                --> R20
  drv                  --> R10
    00299 92AA      ST	-Y,R10
    0029A 934A      ST	-Y,R20
    0029B 2EA0      MOV	R10,R16
FILE: D:\LQD\software\master\software_src\diskio.c
(0001) 
(0002) 
(0003) /*-----------------------------------------------------------------------*/
(0004) /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
(0005) /*-----------------------------------------------------------------------*/
(0006) /* This is a stub disk I/O module that acts as front end of the existing */
(0007) /* disk I/O modules and attach it to FatFs module with common interface. */
(0008) /*-----------------------------------------------------------------------*/
(0009) 
(0010) #include "diskio.h"
(0011) #include "sd.h"
(0012) 
(0013) 
(0014) /*-----------------------------------------------------------------------*/
(0015) /* Correspondence between physical drive number and physical drive.      */
(0016) /* Note that Tiny-FatFs supports only single drive and always            */
(0017)                                       
(0018) 
(0019) ////////////////////////////
(0020) /*
(0021)    struct tm {
(0022)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0023)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0024) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0025) 	int tm_mday;  // 日 day of the month, 1 to 31
(0026) 	int tm_mon;   // 月 months since January, 0 to 11
(0027) 	int tm_year;  // 年 years since 1900
(0028) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0029) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0030)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0031)  	};
(0032) */
(0033) /*-----------------------------------------------------------------------*/
(0034) /* Inidialize a Drive                                                    */
(0035) 
(0036) DSTATUS disk_initialize ( 
(0037) BYTE drv				/* Physical drive nmuber (0..) */
(0038) )
(0039) {
(0040)     unsigned char state;
(0041) 
(0042)     if(drv)
    0029C 20AA      TST	R10
    0029D F011      BEQ	0x02A0
(0043)     {
(0044)         return STA_NOINIT;  //仅支持磁盘0的操作
    0029E E001      LDI	R16,1
    0029F C00C      RJMP	0x02AC
(0045)     }
(0046) 
(0047)     state = SD_Init();
    002A0 940E 2B76 CALL	_SD_Init
    002A2 2F40      MOV	R20,R16
(0048)     if(state == STA_NODISK)
    002A3 3002      CPI	R16,2
    002A4 F411      BNE	0x02A7
(0049)     {
(0050)         return STA_NODISK;
    002A5 E002      LDI	R16,2
    002A6 C005      RJMP	0x02AC
(0051)     }
(0052)     else if(state != 0)
    002A7 2344      TST	R20
    002A8 F011      BEQ	0x02AB
(0053)     {
(0054)         return STA_NOINIT;  //其他错误：初始化失败
    002A9 E001      LDI	R16,1
    002AA C001      RJMP	0x02AC
(0055)     }
(0056)     else
(0057)     {
(0058)         return 0;           //初始化成功
    002AB 2700      CLR	R16
    002AC 9149      LD	R20,Y+
    002AD 90A9      LD	R10,Y+
    002AE 9508      RET
(0059)     }
(0060) }
(0061) 
(0062) 
(0063) 
(0064) /*-----------------------------------------------------------------------*/
(0065) /* Return Disk Status                                                    */
(0066) 
(0067) DSTATUS disk_status (
(0068) 	BYTE drv		/* Physical drive nmuber (0..) */
(0069) )
(0070) {
(0071)     if(drv)
_disk_status:
  drv                  --> R16
    002AF 2300      TST	R16
    002B0 F011      BEQ	0x02B3
(0072)     {
(0073)         return STA_NOINIT;  //仅支持磁盘0操作
    002B1 E001      LDI	R16,1
    002B2 C001      RJMP	0x02B4
(0074)     }
(0075)     return 0;
    002B3 2700      CLR	R16
    002B4 9508      RET
_disk_read:
  res                  --> R10
  count                --> R20
  sector               --> Y,+10
  buff                 --> R12
  drv                  --> R14
    002B5 940E 416D CALL	push_xgset30FC
    002B7 0169      MOVW	R12,R18
    002B8 2EE0      MOV	R14,R16
    002B9 9722      SBIW	R28,2
    002BA 854E      LDD	R20,Y+14
(0076) }
(0077) 
(0078) 
(0079) 
(0080) /*-----------------------------------------------------------------------*/
(0081) /* Read Sector(s)                                                        */
(0082) 
(0083) DRESULT disk_read (
(0084) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0085) 	BYTE *buff,		/* Data buffer to store read data */
(0086) 	DWORD sector,	/* Sector address (LBA) */
(0087) 	BYTE count		/* Number of sectors to read (1..255) */
(0088) )
(0089) {
(0090) 	unsigned char res=0;
    002BB 24AA      CLR	R10
(0091)     if (drv || !count)
    002BC 20EE      TST	R14
    002BD F411      BNE	0x02C0
    002BE 2344      TST	R20
    002BF F411      BNE	0x02C2
(0092)     {    
(0093)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002C0 E004      LDI	R16,4
    002C1 C010      RJMP	0x02D2
(0094)     }
(0095) 
(0096)     if(count==1)            //1个sector的读操作      
    002C2 3041      CPI	R20,1
    002C3 F449      BNE	0x02CD
(0097)     {                                                
(0098)         res = SD_Read_Sector(sector, buff);      
    002C4 82D9      STD	Y+1,R13
    002C5 82C8      ST	Y,R12
    002C6 850A      LDD	R16,Y+10
    002C7 851B      LDD	R17,Y+11
    002C8 852C      LDD	R18,Y+12
    002C9 853D      LDD	R19,Y+13
    002CA 940E 2C5C CALL	_SD_Read_Sector
    002CC 2EA0      MOV	R10,R16
(0099)     }                                                                                                 
(0100) 
(0101)     //处理返回值，将SD_driver.c的返回值转成ff.c的返回值
(0102)     if(res == 0x00)
    002CD 20AA      TST	R10
    002CE F411      BNE	0x02D1
(0103)     {
(0104)         return RES_OK;
    002CF 2700      CLR	R16
    002D0 C001      RJMP	0x02D2
(0105)     }
(0106)     else
(0107)     {
(0108)         return RES_ERROR;
    002D1 E001      LDI	R16,1
    002D2 9622      ADIW	R28,2
    002D3 940C 4157 JMP	pop_xgset30FC
_disk_write:
  count                --> R12
  sector               --> Y,+8
  buff                 --> R10
  drv                  --> R14
    002D5 940E 416F CALL	push_xgset00FC
    002D7 0159      MOVW	R10,R18
    002D8 2EE0      MOV	R14,R16
    002D9 9722      SBIW	R28,2
    002DA 84CC      LDD	R12,Y+12
(0109)     }
(0110) }
(0111) 
(0112) 
(0113) 
(0114) /*-----------------------------------------------------------------------*/
(0115) /* Write Sector(s)                                                       */
(0116) 
(0117) #if _READONLY == 0
(0118) DRESULT disk_write (
(0119) 	BYTE drv,			/* Physical drive nmuber (0..) */
(0120) 	BYTE *buff,	        /* Data to be written */
(0121) 	DWORD sector,		/* Sector address (LBA) */
(0122) 	BYTE count			/* Number of sectors to write (1..255) */
(0123) )
(0124) {
(0125)     if (drv || !count)
    002DB 20EE      TST	R14
    002DC F411      BNE	0x02DF
    002DD 20CC      TST	R12
    002DE F411      BNE	0x02E1
(0126)     {    
(0127)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002DF E004      LDI	R16,4
    002E0 C009      RJMP	0x02EA
(0128)     }   
(0129)    // 读写操作
(0130)     SD_Write_Sector(sector,buff);
    002E1 82B9      STD	Y+1,R11
    002E2 82A8      ST	Y,R10
    002E3 8508      LDD	R16,Y+8
    002E4 8519      LDD	R17,Y+9
    002E5 852A      LDD	R18,Y+10
    002E6 853B      LDD	R19,Y+11
    002E7 940E 2BD6 CALL	_SD_Write_Sector
(0131) 	  
(0132)     return RES_OK;
    002E9 2700      CLR	R16
    002EA 9622      ADIW	R28,2
    002EB 940C 4150 JMP	pop_xgset00FC
_disk_ioctl:
  buff                 --> Y,+4
  ctrl                 --> Y,+2
  drv                  --> Y,+0
    002ED 940E 4026 CALL	push_arg4
(0133) }
(0134) #endif /* _READONLY */
(0135) 
(0136) 
(0137) 
(0138) /*-----------------------------------------------------------------------*/
(0139) /* Miscellaneous Functions                                               */
(0140) DRESULT disk_ioctl (
(0141) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0142) 	BYTE ctrl,		/* Control code */
(0143) 	void *buff		/* Buffer to send/receive control data */
(0144) )
(0145) {
(0146)  	drv=drv;
(0147) 	ctrl=ctrl;
(0148) 	buff=buff;
(0149) 	return 0;
    002EF 2700      CLR	R16
    002F0 9624      ADIW	R28,4
    002F1 9508      RET
(0150) }
(0151) DWORD get_fattime (void)
(0152) {
(0153) 
(0154)   return 1950466005;
_get_fattime:
    002F2 ED05      LDI	R16,0xD5
    002F3 EB1F      LDI	R17,0xBF
    002F4 E421      LDI	R18,0x41
    002F5 E734      LDI	R19,0x74
    002F6 9508      RET
ff.c:mem_cpy:
  s                    --> R12
  d                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    002F7 940E 4198 CALL	push_xgset303C
    002F9 814E      LDD	R20,Y+6
    002FA 815F      LDD	R21,Y+7
FILE: D:\LQD\software\master\software_src\ff.c
(0001) /*----------------------------------------------------------------------------/
(0002) /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
(0003) /-----------------------------------------------------------------------------/
(0004) / FatFs module is a generic FAT file system module for small embedded systems.
(0005) / This is a free software that opened for education, research and commercial
(0006) / developments under license policy of following terms.
(0007) /
(0008) /  Copyright (C) 2011, ChaN, all right reserved.
(0009) /
(0010) / * The FatFs module is a free software and there is NO WARRANTY.
(0011) / * No restriction on use. You can use, modify and redistribute it for
(0012) /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
(0013) / * Redistributions of source code must retain the above copyright notice.
(0014) /
(0015) /-----------------------------------------------------------------------------/
(0016) / Feb 26,'06 R0.00  Prototype.
(0017) /
(0018) / Apr 29,'06 R0.01  First stable version.
(0019) /
(0020) / Jun 01,'06 R0.02  Added FAT12 support.
(0021) /                   Removed unbuffered mode.
(0022) /                   Fixed a problem on small (<32M) partition.
(0023) / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
(0024) /
(0025) / Sep 22,'06 R0.03  Added f_rename().
(0026) /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
(0027) / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
(0028) /                   Fixed f_mkdir() creates incorrect directory on FAT32.
(0029) /
(0030) / Feb 04,'07 R0.04  Supported multiple drive system.
(0031) /                   Changed some interfaces for multiple drive system.
(0032) /                   Changed f_mountdrv() to f_mount().
(0033) /                   Added f_mkfs().
(0034) / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
(0035) /                   Added a capability of extending file size to f_lseek().
(0036) /                   Added minimization level 3.
(0037) /                   Fixed an endian sensitive code in f_mkfs().
(0038) / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
(0039) /                   Added FSInfo support.
(0040) /                   Fixed DBCS name can result FR_INVALID_NAME.
(0041) /                   Fixed short seek (<= csize) collapses the file object.
(0042) /
(0043) / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
(0044) /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
(0045) /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
(0046) / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
(0047) /                   Fixed off by one error at FAT sub-type determination.
(0048) /                   Fixed btr in f_read() can be mistruncated.
(0049) /                   Fixed cached sector is not flushed when create and close without write.
(0050) /
(0051) / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
(0052) /                   Improved performance of f_lseek() on moving to the same or following cluster.
(0053) /
(0054) / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
(0055) /                   Added long file name feature.
(0056) /                   Added multiple code page feature.
(0057) /                   Added re-entrancy for multitask operation.
(0058) /                   Added auto cluster size selection to f_mkfs().
(0059) /                   Added rewind option to f_readdir().
(0060) /                   Changed result code of critical errors.
(0061) /                   Renamed string functions to avoid name collision.
(0062) / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
(0063) /                   Added multiple sector size feature.
(0064) / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
(0065) /                   Fixed wrong cache control in f_lseek().
(0066) /                   Added relative path feature.
(0067) /                   Added f_chdir() and f_chdrive().
(0068) /                   Added proper case conversion to extended char.
(0069) / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
(0070) /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
(0071) /                   Fixed name matching error on the 13 char boundary.
(0072) /                   Added a configuration option, _LFN_UNICODE.
(0073) /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
(0074) /
(0075) / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
(0076) /                   Added file lock feature. (_FS_SHARE)
(0077) /                   Added fast seek feature. (_USE_FASTSEEK)
(0078) /                   Changed some types on the API, XCHAR->TCHAR.
(0079) /                   Changed fname member in the FILINFO structure on Unicode cfg.
(0080) /                   String functions support UTF-8 encoding files on Unicode cfg.
(0081) / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
(0082) /                   Added sector erase feature. (_USE_ERASE)
(0083) /                   Moved file lock semaphore table from fs object to the bss.
(0084) /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
(0085) /                   Fixed f_mkfs() creates wrong FAT32 volume.
(0086) / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
(0087) /                   f_lseek() reports required table size on creating CLMP.
(0088) /                   Extended format syntax of f_printf function.
(0089) /                   Ignores duplicated directory separators in given path names.
(0090) /
(0091) / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
(0092) /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
(0093) /---------------------------------------------------------------------------*/
(0094) 
(0095) #include "ff.h"			/* FatFs configurations and declarations */
(0096) #include "diskio.h"		/* Declarations of low level disk I/O functions */
(0097) #include <string.h>
(0098) 
(0099) /*--------------------------------------------------------------------------
(0100) 
(0101)    Module Private Definitions
(0102) 
(0103) ---------------------------------------------------------------------------*/
(0104) 
(0105) #if _FATFS != 6502	/* Revision ID */
(0106) #error Wrong include file (ff.h).
(0107) #endif
(0108) 
(0109) 
(0110) /* Definitions on sector size */
(0111) #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
(0112) #error Wrong sector size.
(0113) #endif
(0114) #if _MAX_SS != 512
(0115) #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
(0116) #else
(0117) #define	SS(fs)	512U			/* Fixed sector size */
(0118) #endif
(0119) 
(0120) 
(0121) /* Reentrancy related */
(0122) #if _FS_REENTRANT
(0123) #if _USE_LFN == 1
(0124) #error Static LFN work area must not be used in re-entrant configuration.
(0125) #endif
(0126) #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
(0127) #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
(0128) #else
(0129) #define	ENTER_FF(fs)
(0130) #define LEAVE_FF(fs, res)	return res
(0131) #endif
(0132) 
(0133) #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
(0134) 
(0135) 
(0136) /* File shareing feature */
(0137) #if _FS_SHARE
(0138) #if _FS_READONLY
(0139) #error _FS_SHARE must be 0 on read-only cfg.
(0140) #endif
(0141) typedef struct {
(0142) 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
(0143) 	DWORD clu;				/* File ID 2, directory */
(0144) 	WORD idx;				/* File ID 3, directory index */
(0145) 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
(0146) } FILESEM;
(0147) #endif
(0148) 
(0149) 
(0150) /* Misc definitions */
(0151) #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
(0152) #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
(0153) 
(0154) 
(0155) /* DBCS code ranges and SBCS extend char conversion table */
(0156) 
(0157) #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
(0158) #define _DF1S	0x81	/* DBC 1st byte range 1 start */
(0159) #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
(0160) #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
(0161) #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
(0162) #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
(0163) #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
(0164) #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
(0165) #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
(0166) 
(0167) #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
(0168) #define _DF1S	0x81
(0169) #define _DF1E	0xFE
(0170) #define _DS1S	0x40
(0171) #define _DS1E	0x7E
(0172) #define _DS2S	0x80
(0173) #define _DS2E	0xFE
(0174) 
(0175) #elif _CODE_PAGE == 949	/* Korean */
(0176) #define _DF1S	0x81
(0177) #define _DF1E	0xFE
(0178) #define _DS1S	0x41
(0179) #define _DS1E	0x5A
(0180) #define _DS2S	0x61
(0181) #define _DS2E	0x7A
(0182) #define _DS3S	0x81
(0183) #define _DS3E	0xFE
(0184) 
(0185) #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
(0186) #define _DF1S	0x81
(0187) #define _DF1E	0xFE
(0188) #define _DS1S	0x40
(0189) #define _DS1E	0x7E
(0190) #define _DS2S	0xA1
(0191) #define _DS2E	0xFE
(0192) 
(0193) #elif _CODE_PAGE == 437	/* U.S. (OEM) */
(0194) #define _DF1S	0
(0195) #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0196) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0197) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0198) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0199) 
(0200) #elif _CODE_PAGE == 720	/* Arabic (OEM) */
(0201) #define _DF1S	0
(0202) #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0203) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0204) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0205) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0206) 
(0207) #elif _CODE_PAGE == 737	/* Greek (OEM) */
(0208) #define _DF1S	0
(0209) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
(0210) 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0211) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0212) 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0213) 
(0214) #elif _CODE_PAGE == 775	/* Baltic (OEM) */
(0215) #define _DF1S	0
(0216) #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0217) 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0218) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0219) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0220) 
(0221) #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
(0222) #define _DF1S	0
(0223) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0224) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0225) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0226) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0227) 
(0228) #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
(0229) #define _DF1S	0
(0230) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
(0231) 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
(0232) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0233) 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
(0234) 
(0235) #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
(0236) #define _DF1S	0
(0237) #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
(0238) 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
(0239) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
(0240) 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
(0241) 
(0242) #elif _CODE_PAGE == 857	/* Turkish (OEM) */
(0243) #define _DF1S	0
(0244) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
(0245) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0246) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0247) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0248) 
(0249) #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
(0250) #define _DF1S	0
(0251) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0252) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0253) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0254) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0255) 
(0256) #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
(0257) #define _DF1S	0
(0258) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0259) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0260) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0261) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0262) 
(0263) #elif _CODE_PAGE == 866	/* Russian (OEM) */
(0264) #define _DF1S	0
(0265) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0266) 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0267) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0268) 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0269) 
(0270) #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
(0271) #define _DF1S	0
(0272) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0273) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0274) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0275) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0276) 
(0277) #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
(0278) #define _DF1S	0
(0279) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0280) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
(0281) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0282) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0283) 
(0284) #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
(0285) #define _DF1S	0
(0286) #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0287) 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
(0288) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0289) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
(0290) 
(0291) #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
(0292) #define _DF1S	0
(0293) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
(0294) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0295) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0296) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0297) 
(0298) #elif _CODE_PAGE == 1253 /* Greek (Windows) */
(0299) #define _DF1S	0
(0300) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0301) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0302) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
(0303) 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
(0304) 
(0305) #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
(0306) #define _DF1S	0
(0307) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0308) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0309) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0310) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0311) 
(0312) #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
(0313) #define _DF1S	0
(0314) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0315) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0316) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0317) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0318) 
(0319) #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
(0320) #define _DF1S	0
(0321) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0322) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0323) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0324) 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
(0325) 
(0326) #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
(0327) #define _DF1S	0
(0328) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0329) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
(0330) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0331) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0332) 
(0333) #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
(0334) #define _DF1S	0
(0335) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
(0336) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0337) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0338) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
(0339) 
(0340) #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
(0341) #if _USE_LFN
(0342) #error Cannot use LFN feature without valid code page.
(0343) #endif
(0344) #define _DF1S	0
(0345) 
(0346) #else
(0347) #error Unknown code page
(0348) 
(0349) #endif
(0350) 
(0351) 
(0352) /* Character code support macros */
(0353) #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
(0354) #define IsLower(c)	(((c)>='a')&&((c)<='z'))
(0355) #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
(0356) 
(0357) #if _DF1S		/* Code page is DBCS */
(0358) 
(0359) #ifdef _DF2S	/* Two 1st byte areas */
(0360) #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
(0361) #else			/* One 1st byte area */
(0362) #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
(0363) #endif
(0364) 
(0365) #ifdef _DS3S	/* Three 2nd byte areas */
(0366) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
(0367) #else			/* Two 2nd byte areas */
(0368) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
(0369) #endif
(0370) 
(0371) #else			/* Code page is SBCS */
(0372) 
(0373) #define IsDBCS1(c)	0
(0374) #define IsDBCS2(c)	0
(0375) 
(0376) #endif /* _DF1S */
(0377) 
(0378) 
(0379) /* Name status flags */
(0380) #define NS			11		/* Index of name status byte in fn[] */
(0381) #define NS_LOSS		0x01	/* Out of 8.3 format */
(0382) #define NS_LFN		0x02	/* Force to create LFN entry */
(0383) #define NS_LAST		0x04	/* Last segment */
(0384) #define NS_BODY		0x08	/* Lower case flag (body) */
(0385) #define NS_EXT		0x10	/* Lower case flag (ext) */
(0386) #define NS_DOT		0x20	/* Dot entry */
(0387) 
(0388) 
(0389) /* FAT sub-type boundaries */
(0390) /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
(0391) #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
(0392) #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
(0393) 
(0394) 
(0395) /* FatFs refers the members in the FAT structures as byte array instead of
(0396) / structure member because the structure is not binary compatible between
(0397) / different platforms */
(0398) 
(0399) #define BS_jmpBoot			0	/* Jump instruction (3) */
(0400) #define BS_OEMName			3	/* OEM name (8) */
(0401) #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
(0402) #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
(0403) #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
(0404) #define BPB_NumFATs			16	/* Number of FAT copies (1) */
(0405) #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
(0406) #define BPB_TotSec16		19	/* Volume size [sector] (2) */
(0407) #define BPB_Media			21	/* Media descriptor (1) */
(0408) #define BPB_FATSz16			22	/* FAT size [sector] (2) */
(0409) #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
(0410) #define BPB_NumHeads		26	/* Number of heads (2) */
(0411) #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
(0412) #define BPB_TotSec32		32	/* Volume size [sector] (4) */
(0413) #define BS_DrvNum			36	/* Physical drive number (2) */
(0414) #define BS_BootSig			38	/* Extended boot signature (1) */
(0415) #define BS_VolID			39	/* Volume serial number (4) */
(0416) #define BS_VolLab			43	/* Volume label (8) */
(0417) #define BS_FilSysType		54	/* File system type (1) */
(0418) #define BPB_FATSz32			36	/* FAT size [sector] (4) */
(0419) #define BPB_ExtFlags		40	/* Extended flags (2) */
(0420) #define BPB_FSVer			42	/* File system version (2) */
(0421) #define BPB_RootClus		44	/* Root dir first cluster (4) */
(0422) #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
(0423) #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
(0424) #define BS_DrvNum32			64	/* Physical drive number (2) */
(0425) #define BS_BootSig32		66	/* Extended boot signature (1) */
(0426) #define BS_VolID32			67	/* Volume serial number (4) */
(0427) #define BS_VolLab32			71	/* Volume label (8) */
(0428) #define BS_FilSysType32		82	/* File system type (1) */
(0429) #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
(0430) #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
(0431) #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
(0432) #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
(0433) #define MBR_Table			446	/* MBR: Partition table offset (2) */
(0434) #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
(0435) #define BS_55AA				510	/* Boot sector signature (2) */
(0436) 
(0437) #define	DIR_Name			0	/* Short file name (11) */
(0438) #define	DIR_Attr			11	/* Attribute (1) */
(0439) #define	DIR_NTres			12	/* NT flag (1) */
(0440) #define	DIR_CrtTime			14	/* Created time (2) */
(0441) #define	DIR_CrtDate			16	/* Created date (2) */
(0442) #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
(0443) #define	DIR_WrtTime			22	/* Modified time (2) */
(0444) #define	DIR_WrtDate			24	/* Modified date (2) */
(0445) #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
(0446) #define	DIR_FileSize		28	/* File size (4) */
(0447) #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
(0448) #define	LDIR_Attr			11	/* LFN attribute (1) */
(0449) #define	LDIR_Type			12	/* LFN type (1) */
(0450) #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
(0451) #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
(0452) #define	SZ_DIR				32		/* Size of a directory entry */
(0453) #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
(0454) #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
(0455) #define	NDDE				0x05	/* Replacement of a character collides with DDE */
(0456) 
(0457) 
(0458) /*------------------------------------------------------------*/
(0459) /* Module private work area                                   */
(0460) /*------------------------------------------------------------*/
(0461) /* Note that uninitialized variables with static duration are
(0462) /  zeroed/nulled at start-up. If not, the compiler or start-up
(0463) /  routine is out of ANSI-C standard.
(0464) */
(0465) 
(0466) #if _VOLUMES
(0467) static
(0468) FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
(0469) #else
(0470) #error Number of volumes must not be 0.
(0471) #endif
(0472) 
(0473) static
(0474) WORD Fsid;				/* File system mount ID */
(0475) 
(0476) #if _FS_RPATH
(0477) static
(0478) BYTE CurrVol;			/* Current drive */
(0479) #endif
(0480) 
(0481) #if _FS_SHARE
(0482) static
(0483) FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
(0484) #endif
(0485) 
(0486) #if _USE_LFN == 0			/* No LFN feature */
(0487) #define	DEF_NAMEBUF			BYTE sfn[12]
(0488) #define INIT_BUF(dobj)		(dobj).fn = sfn
(0489) #define	FREE_BUF()
(0490) 
(0491) #elif _USE_LFN == 1			/* LFN feature with static working buffer */
(0492) static WCHAR LfnBuf[_MAX_LFN+1];
(0493) #define	DEF_NAMEBUF			BYTE sfn[12]
(0494) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
(0495) #define	FREE_BUF()
(0496) 
(0497) #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
(0498) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
(0499) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
(0500) #define	FREE_BUF()
(0501) 
(0502) #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
(0503) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
(0504) #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
(0505) 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
(0506) 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
(0507) #define	FREE_BUF()			ff_memfree(lfn)
(0508) 
(0509) #else
(0510) #error Wrong LFN configuration.
(0511) #endif
(0512) 
(0513) 
(0514) 
(0515) 
(0516) /*--------------------------------------------------------------------------
(0517) 
(0518)    Module Private Functions
(0519) 
(0520) ---------------------------------------------------------------------------*/
(0521) 
(0522) 
(0523) /*-----------------------------------------------------------------------*/
(0524) /* String functions                                                      */
(0525) /*-----------------------------------------------------------------------*/
(0526) 
(0527) /* Copy memory to memory */
(0528) static
(0529) void mem_cpy (void* dst, const void* src, UINT cnt) {
(0530) 	BYTE *d = (BYTE*)dst;
    002FB 0158      MOVW	R10,R16
(0531) 	const BYTE *s = (const BYTE*)src;
    002FC 0169      MOVW	R12,R18
    002FD C006      RJMP	0x0304
(0532) 
(0533) #if _WORD_ACCESS == 1
(0534) 	while (cnt >= sizeof(int)) {
(0535) 		*(int*)d = *(int*)s;
(0536) 		d += sizeof(int); s += sizeof(int);
(0537) 		cnt -= sizeof(int);
(0538) 	}
(0539) #endif
(0540) 	while (cnt--)
(0541) 		*d++ = *s++;
    002FE 01F6      MOVW	R30,R12
    002FF 01D5      MOVW	R26,R10
    00300 9001      LD	R0,Z+
    00301 016F      MOVW	R12,R30
    00302 920D      ST	X+,R0
    00303 015D      MOVW	R10,R26
    00304 011A      MOVW	R2,R20
    00305 5041      SUBI	R20,1
    00306 4050      SBCI	R21,0
    00307 2022      TST	R2
    00308 F7A9      BNE	0x02FE
    00309 2033      TST	R3
    0030A F799      BNE	0x02FE
    0030B 940C 419F JMP	pop_xgset303C
ff.c:mem_set:
  d                    --> R10
  cnt                  --> R20
  val                  --> R18
  dst                  --> R16
    0030D 940E 4176 CALL	push_xgset300C
    0030F 814C      LDD	R20,Y+4
    00310 815D      LDD	R21,Y+5
(0542) }
(0543) 
(0544) /* Fill memory */
(0545) static
(0546) void mem_set (void* dst, int val, UINT cnt) {
(0547) 	BYTE *d = (BYTE*)dst;
    00311 0158      MOVW	R10,R16
    00312 C003      RJMP	0x0316
(0548) 
(0549) 	while (cnt--)
(0550) 		*d++ = (BYTE)val;
    00313 01F5      MOVW	R30,R10
    00314 9321      ST	Z+,R18
    00315 015F      MOVW	R10,R30
    00316 011A      MOVW	R2,R20
    00317 5041      SUBI	R20,1
    00318 4050      SBCI	R21,0
    00319 2022      TST	R2
    0031A F7C1      BNE	0x0313
    0031B 2033      TST	R3
    0031C F7B1      BNE	0x0313
    0031D 940C 417B JMP	pop_xgset300C
ff.c:mem_cmp:
  s                    --> R14
  d                    --> R12
  r                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    0031F 940E 416D CALL	push_xgset30FC
    00321 8548      LDD	R20,Y+8
    00322 8559      LDD	R21,Y+9
(0551) }
(0552) 
(0553) /* Compare memory to memory */
(0554) static
(0555) int mem_cmp (const void* dst, const void* src, UINT cnt) {
(0556) 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    00323 0168      MOVW	R12,R16
    00324 0179      MOVW	R14,R18
(0557) 	int r = 0;
    00325 24AA      CLR	R10
    00326 24BB      CLR	R11
(0558) 
(0559) 	while (cnt-- && (r = *d++ - *s++) == 0) ;
    00327 011A      MOVW	R2,R20
    00328 5041      SUBI	R20,1
    00329 4050      SBCI	R21,0
    0032A 2022      TST	R2
    0032B F411      BNE	0x032E
    0032C 2033      TST	R3
    0032D F079      BEQ	0x033D
    0032E 01F7      MOVW	R30,R14
    0032F 9021      LD	R2,Z+
    00330 017F      MOVW	R14,R30
    00331 2433      CLR	R3
    00332 01F6      MOVW	R30,R12
    00333 9041      LD	R4,Z+
    00334 016F      MOVW	R12,R30
    00335 2455      CLR	R5
    00336 1842      SUB	R4,R2
    00337 0853      SBC	R5,R3
    00338 0152      MOVW	R10,R4
    00339 20AA      TST	R10
    0033A F411      BNE	0x033D
    0033B 20BB      TST	R11
    0033C F351      BEQ	0x0327
(0560) 	return r;
    0033D 0185      MOVW	R16,R10
    0033E 940C 4157 JMP	pop_xgset30FC
(0561) }
(0562) 
(0563) /* Check if chr is contained in the string */
(0564) static
(0565) int chk_chr (const char* str, int chr) {
ff.c:chk_chr:
  chr                  --> R18
  str                  --> R16
    00340 C002      RJMP	0x0343
(0566) 	while (*str && *str != chr) str++;
    00341 5F0F      SUBI	R16,0xFF
    00342 4F1F      SBCI	R17,0xFF
    00343 01F8      MOVW	R30,R16
    00344 8020      LD	R2,Z
    00345 2433      CLR	R3
    00346 2022      TST	R2
    00347 F021      BEQ	0x034C
    00348 2433      CLR	R3
    00349 1622      CP	R2,R18
    0034A 0633      CPC	R3,R19
    0034B F7A9      BNE	0x0341
(0567) 	return *str;
    0034C 01F8      MOVW	R30,R16
    0034D 8100      LD	R16,Z
    0034E 2711      CLR	R17
    0034F 9508      RET
ff.c:move_window:
  nf                   --> R10
  wsect                --> Y,+5
  sector               --> Y,+13
  fs                   --> R20
    00350 933A      ST	-Y,R19
    00351 932A      ST	-Y,R18
    00352 940E 4176 CALL	push_xgset300C
    00354 01A8      MOVW	R20,R16
    00355 9729      SBIW	R28,0x9
(0568) }
(0569) 
(0570) 
(0571) 
(0572) /*-----------------------------------------------------------------------*/
(0573) /* Request/Release grant to access the volume                            */
(0574) /*-----------------------------------------------------------------------*/
(0575) #if _FS_REENTRANT
(0576) 
(0577) static
(0578) int lock_fs (
(0579) 	FATFS *fs		/* File system object */
(0580) )
(0581) {
(0582) 	return ff_req_grant(fs->sobj);
(0583) }
(0584) 
(0585) 
(0586) static
(0587) void unlock_fs (
(0588) 	FATFS *fs,		/* File system object */
(0589) 	FRESULT res		/* Result code to be returned */
(0590) )
(0591) {
(0592) 	if (res != FR_NOT_ENABLED &&
(0593) 		res != FR_INVALID_DRIVE &&
(0594) 		res != FR_INVALID_OBJECT &&
(0595) 		res != FR_TIMEOUT) {
(0596) 		ff_rel_grant(fs->sobj);
(0597) 	}
(0598) }
(0599) #endif
(0600) 
(0601) 
(0602) 
(0603) /*-----------------------------------------------------------------------*/
(0604) /* File shareing control functions                                       */
(0605) /*-----------------------------------------------------------------------*/
(0606) #if _FS_SHARE
(0607) 
(0608) static
(0609) FRESULT chk_lock (	/* Check if the file can be accessed */
(0610) 	DIR* dj,		/* Directory object pointing the file to be checked */
(0611) 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
(0612) )
(0613) {
(0614) 	UINT i, be;
(0615) 
(0616) 	/* Search file semaphore table */
(0617) 	for (i = be = 0; i < _FS_SHARE; i++) {
(0618) 		if (Files[i].fs) {	/* Existing entry */
(0619) 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
(0620) 				Files[i].clu == dj->sclust &&
(0621) 				Files[i].idx == dj->index) break;
(0622) 		} else {			/* Blank entry */
(0623) 			be++;
(0624) 		}
(0625) 	}
(0626) 	if (i == _FS_SHARE)	/* The file is not opened */
(0627) 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
(0628) 
(0629) 	/* The file has been opened. Reject any open against writing file and all write mode open */
(0630) 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
(0631) }
(0632) 
(0633) 
(0634) static
(0635) int enq_lock (void)	/* Check if an entry is available for a new file */
(0636) {
(0637) 	UINT i;
(0638) 
(0639) 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0640) 	return (i == _FS_SHARE) ? 0 : 1;
(0641) }
(0642) 
(0643) 
(0644) static
(0645) UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
(0646) 	DIR* dj,	/* Directory object pointing the file to register or increment */
(0647) 	int acc		/* Desired access mode (0:Read, !0:Write) */
(0648) )
(0649) {
(0650) 	UINT i;
(0651) 
(0652) 
(0653) 	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
(0654) 		if (Files[i].fs == dj->fs &&
(0655) 			Files[i].clu == dj->sclust &&
(0656) 			Files[i].idx == dj->index) break;
(0657) 	}
(0658) 
(0659) 	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
(0660) 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0661) 		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
(0662) 		Files[i].fs = dj->fs;
(0663) 		Files[i].clu = dj->sclust;
(0664) 		Files[i].idx = dj->index;
(0665) 		Files[i].ctr = 0;
(0666) 	}
(0667) 
(0668) 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
(0669) 
(0670) 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
(0671) 
(0672) 	return i + 1;
(0673) }
(0674) 
(0675) 
(0676) static
(0677) FRESULT dec_lock (	/* Decrement file open counter */
(0678) 	UINT i			/* Semaphore index */
(0679) )
(0680) {
(0681) 	WORD n;
(0682) 	FRESULT res;
(0683) 
(0684) 
(0685) 	if (--i < _FS_SHARE) {
(0686) 		n = Files[i].ctr;
(0687) 		if (n == 0x100) n = 0;
(0688) 		if (n) n--;
(0689) 		Files[i].ctr = n;
(0690) 		if (!n) Files[i].fs = 0;
(0691) 		res = FR_OK;
(0692) 	} else {
(0693) 		res = FR_INT_ERR;
(0694) 	}
(0695) 	return res;
(0696) }
(0697) 
(0698) 
(0699) static
(0700) void clear_lock (	/* Clear lock entries of the volume */
(0701) 	FATFS *fs
(0702) )
(0703) {
(0704) 	UINT i;
(0705) 
(0706) 	for (i = 0; i < _FS_SHARE; i++) {
(0707) 		if (Files[i].fs == fs) Files[i].fs = 0;
(0708) 	}
(0709) }
(0710) #endif
(0711) 
(0712) 
(0713) 
(0714) /*-----------------------------------------------------------------------*/
(0715) /* Change window offset                                                  */
(0716) /*-----------------------------------------------------------------------*/
(0717) 
(0718) static
(0719) FRESULT move_window (
(0720) 	FATFS *fs,		/* File system object */
(0721) 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
(0722) )					/* Move to zero only writes back dirty window */
(0723) {
(0724) 	DWORD wsect;
(0725) 
(0726) 
(0727) 	wsect = fs->winsect;
    00356 01FA      MOVW	R30,R20
    00357 96BA      ADIW	R30,0x2A
    00358 8020      LD	R2,Z
    00359 8031      LDD	R3,Z+1
    0035A 8042      LDD	R4,Z+2
    0035B 8053      LDD	R5,Z+3
    0035C 822D      STD	Y+5,R2
    0035D 823E      STD	Y+6,R3
    0035E 824F      STD	Y+7,R4
    0035F 8658      STD	Y+8,R5
(0728) 	if (wsect != sector) {	/* Changed current window */
    00360 842D      LDD	R2,Y+13
    00361 843E      LDD	R3,Y+14
    00362 844F      LDD	R4,Y+15
    00363 8858      LDD	R5,Y+16
    00364 806D      LDD	R6,Y+5
    00365 807E      LDD	R7,Y+6
    00366 808F      LDD	R8,Y+7
    00367 8498      LDD	R9,Y+8
    00368 1462      CP	R6,R2
    00369 0473      CPC	R7,R3
    0036A 0484      CPC	R8,R4
    0036B 0495      CPC	R9,R5
    0036C F409      BNE	0x036E
    0036D C07E      RJMP	0x03EC
(0729) #if !_FS_READONLY
(0730) 		if (fs->wflag) {	/* Write back dirty window if needed */
    0036E 01FA      MOVW	R30,R20
    0036F 8024      LDD	R2,Z+4
    00370 2022      TST	R2
    00371 F409      BNE	0x0373
    00372 C055      RJMP	0x03C8
(0731) 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    00373 E081      LDI	R24,1
    00374 838C      STD	Y+4,R24
    00375 0113      MOVW	R2,R6
    00376 0124      MOVW	R4,R8
    00377 8228      ST	Y,R2
    00378 8239      STD	Y+1,R3
    00379 824A      STD	Y+2,R4
    0037A 825B      STD	Y+3,R5
    0037B 019A      MOVW	R18,R20
    0037C 5D22      SUBI	R18,0xD2
    0037D 4F3F      SBCI	R19,0xFF
    0037E 8101      LDD	R16,Z+1
    0037F 940E 02D5 CALL	_disk_write
    00381 2300      TST	R16
    00382 F011      BEQ	0x0385
(0732) 				return FR_DISK_ERR;
    00383 E001      LDI	R16,1
    00384 C068      RJMP	0x03ED
(0733) 			fs->wflag = 0;
    00385 2422      CLR	R2
    00386 01FA      MOVW	R30,R20
    00387 8224      STD	Z+4,R2
(0734) 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    00388 8C22      LDD	R2,Z+26
    00389 8C33      LDD	R3,Z+27
    0038A 8C44      LDD	R4,Z+28
    0038B 8C55      LDD	R5,Z+29
    0038C 967E      ADIW	R30,0x1E
    0038D 8060      LD	R6,Z
    0038E 8071      LDD	R7,Z+1
    0038F 8082      LDD	R8,Z+2
    00390 8093      LDD	R9,Z+3
    00391 0C62      ADD	R6,R2
    00392 1C73      ADC	R7,R3
    00393 1C84      ADC	R8,R4
    00394 1C95      ADC	R9,R5
    00395 802D      LDD	R2,Y+5
    00396 803E      LDD	R3,Y+6
    00397 804F      LDD	R4,Y+7
    00398 8458      LDD	R5,Y+8
    00399 1426      CP	R2,R6
    0039A 0437      CPC	R3,R7
    0039B 0448      CPC	R4,R8
    0039C 0459      CPC	R5,R9
    0039D F550      BCC	0x03C8
(0735) 				BYTE nf;
(0736) 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    0039E 01FA      MOVW	R30,R20
    0039F 80A3      LDD	R10,Z+3
    003A0 C024      RJMP	0x03C5
(0737) 					wsect += fs->fsize;
    003A1 01FA      MOVW	R30,R20
    003A2 967A      ADIW	R30,0x1A
    003A3 8020      LD	R2,Z
    003A4 8031      LDD	R3,Z+1
    003A5 8042      LDD	R4,Z+2
    003A6 8053      LDD	R5,Z+3
    003A7 806D      LDD	R6,Y+5
    003A8 807E      LDD	R7,Y+6
    003A9 808F      LDD	R8,Y+7
    003AA 8498      LDD	R9,Y+8
    003AB 0C62      ADD	R6,R2
    003AC 1C73      ADC	R7,R3
    003AD 1C84      ADC	R8,R4
    003AE 1C95      ADC	R9,R5
    003AF 826D      STD	Y+5,R6
    003B0 827E      STD	Y+6,R7
    003B1 828F      STD	Y+7,R8
    003B2 8698      STD	Y+8,R9
(0738) 					disk_write(fs->drv, fs->win, wsect, 1);
    003B3 E081      LDI	R24,1
    003B4 838C      STD	Y+4,R24
    003B5 802D      LDD	R2,Y+5
    003B6 803E      LDD	R3,Y+6
    003B7 804F      LDD	R4,Y+7
    003B8 8458      LDD	R5,Y+8
    003B9 8228      ST	Y,R2
    003BA 8239      STD	Y+1,R3
    003BB 824A      STD	Y+2,R4
    003BC 825B      STD	Y+3,R5
    003BD 019A      MOVW	R18,R20
    003BE 5D22      SUBI	R18,0xD2
    003BF 4F3F      SBCI	R19,0xFF
    003C0 01FA      MOVW	R30,R20
    003C1 8101      LDD	R16,Z+1
    003C2 940E 02D5 CALL	_disk_write
    003C4 94AA      DEC	R10
    003C5 E081      LDI	R24,1
    003C6 158A      CP	R24,R10
    003C7 F2C8      BCS	0x03A1
(0739) 				}
(0740) 			}
(0741) 		}
(0742) #endif
(0743) 		if (sector) {
    003C8 842D      LDD	R2,Y+13
    003C9 843E      LDD	R3,Y+14
    003CA 844F      LDD	R4,Y+15
    003CB 8858      LDD	R5,Y+16
    003CC 9488      BCLR	0
    003CD 2022      TST	R2
    003CE 0432      CPC	R3,R2
    003CF 0442      CPC	R4,R2
    003D0 0452      CPC	R5,R2
    003D1 F0D1      BEQ	0x03EC
(0744) 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    003D2 E081      LDI	R24,1
    003D3 838C      STD	Y+4,R24
    003D4 8228      ST	Y,R2
    003D5 8239      STD	Y+1,R3
    003D6 824A      STD	Y+2,R4
    003D7 825B      STD	Y+3,R5
    003D8 019A      MOVW	R18,R20
    003D9 5D22      SUBI	R18,0xD2
    003DA 4F3F      SBCI	R19,0xFF
    003DB 01FA      MOVW	R30,R20
    003DC 8101      LDD	R16,Z+1
    003DD 940E 02B5 CALL	_disk_read
    003DF 2300      TST	R16
    003E0 F011      BEQ	0x03E3
(0745) 				return FR_DISK_ERR;
    003E1 E001      LDI	R16,1
    003E2 C00A      RJMP	0x03ED
(0746) 			fs->winsect = sector;
    003E3 842D      LDD	R2,Y+13
    003E4 843E      LDD	R3,Y+14
    003E5 844F      LDD	R4,Y+15
    003E6 8858      LDD	R5,Y+16
    003E7 01FA      MOVW	R30,R20
    003E8 A622      STD	Z+42,R2
    003E9 A633      STD	Z+43,R3
    003EA A644      STD	Z+44,R4
    003EB A655      STD	Z+45,R5
(0747) 		}
(0748) 	}
(0749) 
(0750) 	return FR_OK;
    003EC 2700      CLR	R16
    003ED 9629      ADIW	R28,0x9
    003EE 940E 417B CALL	pop_xgset300C
    003F0 9622      ADIW	R28,2
    003F1 9508      RET
ff.c:sync:
  res                  --> R20
  fs                   --> R22
    003F2 940E 4180 CALL	push_xgsetF000
    003F4 01B8      MOVW	R22,R16
    003F5 9725      SBIW	R28,5
(0751) }
(0752) 
(0753) 
(0754) 
(0755) 
(0756) /*-----------------------------------------------------------------------*/
(0757) /* Clean-up cached data                                                  */
(0758) /*-----------------------------------------------------------------------*/
(0759) #if !_FS_READONLY
(0760) static
(0761) FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
(0762) 	FATFS *fs	/* File system object */
(0763) )
(0764) {
(0765) 	FRESULT res;
(0766) 
(0767) 
(0768) 	res = move_window(fs, 0);
    003F6 E080      LDI	R24,0
    003F7 E090      LDI	R25,0
    003F8 E0A0      LDI	R26,0
    003F9 E0B0      LDI	R27,0
    003FA 83A8      ST	Y,R26
    003FB 83B9      STD	Y+1,R27
    003FC 019C      MOVW	R18,R24
    003FD 018B      MOVW	R16,R22
    003FE DF51      RCALL	ff.c:move_window
    003FF 2F40      MOV	R20,R16
(0769) 	if (res == FR_OK) {
    00400 2300      TST	R16
    00401 F009      BEQ	0x0403
    00402 C0C0      RJMP	0x04C3
(0770) 		/* Update FSInfo sector if needed */
(0771) 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    00403 01FB      MOVW	R30,R22
    00404 8180      LD	R24,Z
    00405 3083      CPI	R24,3
    00406 F009      BEQ	0x0408
    00407 C0AC      RJMP	0x04B4
    00408 8025      LDD	R2,Z+5
    00409 2022      TST	R2
    0040A F409      BNE	0x040C
    0040B C0A8      RJMP	0x04B4
(0772) 			fs->winsect = 0;
    0040C 96BA      ADIW	R30,0x2A
    0040D E080      LDI	R24,0
    0040E 8380      ST	Z,R24
    0040F 8381      STD	Z+1,R24
    00410 8382      STD	Z+2,R24
    00411 8383      STD	Z+3,R24
(0773) 			/* Create FSInfo structure */
(0774) 			mem_set(fs->win, 0, 512);
    00412 E080      LDI	R24,0
    00413 E092      LDI	R25,2
    00414 8399      STD	Y+1,R25
    00415 8388      ST	Y,R24
    00416 2722      CLR	R18
    00417 2733      CLR	R19
    00418 018B      MOVW	R16,R22
    00419 5D02      SUBI	R16,0xD2
    0041A 4F1F      SBCI	R17,0xFF
    0041B DEF1      RCALL	ff.c:mem_set
(0775) 			ST_WORD(fs->win+BS_55AA, 0xAA55);
    0041C E585      LDI	R24,0x55
    0041D 01FB      MOVW	R30,R22
    0041E 5DE4      SUBI	R30,0xD4
    0041F 4FFD      SBCI	R31,0xFD
    00420 8380      ST	Z,R24
    00421 52EC      SUBI	R30,0x2C
    00422 40F2      SBCI	R31,2
    00423 EA8A      LDI	R24,0xAA
    00424 5DE3      SUBI	R30,0xD3
    00425 4FFD      SBCI	R31,0xFD
    00426 8380      ST	Z,R24
    00427 52ED      SUBI	R30,0x2D
    00428 40F2      SBCI	R31,2
(0776) 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    00429 E582      LDI	R24,0x52
    0042A A786      STD	Z+46,R24
    0042B A787      STD	Z+47,R24
    0042C E681      LDI	R24,0x61
    0042D AB80      STD	Z+48,R24
    0042E E481      LDI	R24,0x41
    0042F AB81      STD	Z+49,R24
(0777) 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    00430 E782      LDI	R24,0x72
    00431 5EEE      SUBI	R30,0xEE
    00432 4FFD      SBCI	R31,0xFD
    00433 8380      ST	Z,R24
    00434 51E2      SUBI	R30,0x12
    00435 40F2      SBCI	R31,2
    00436 5EED      SUBI	R30,0xED
    00437 4FFD      SBCI	R31,0xFD
    00438 8380      ST	Z,R24
    00439 51E3      SUBI	R30,0x13
    0043A 40F2      SBCI	R31,2
    0043B E481      LDI	R24,0x41
    0043C 5EEC      SUBI	R30,0xEC
    0043D 4FFD      SBCI	R31,0xFD
    0043E 8380      ST	Z,R24
    0043F 51E4      SUBI	R30,0x14
    00440 40F2      SBCI	R31,2
    00441 E681      LDI	R24,0x61
    00442 5EEB      SUBI	R30,0xEB
    00443 4FFD      SBCI	R31,0xFD
    00444 8380      ST	Z,R24
    00445 51E5      SUBI	R30,0x15
    00446 40F2      SBCI	R31,2
(0778) 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    00447 8426      LDD	R2,Z+14
    00448 8437      LDD	R3,Z+15
    00449 8840      LDD	R4,Z+16
    0044A 8851      LDD	R5,Z+17
    0044B 5EEA      SUBI	R30,0xEA
    0044C 4FFD      SBCI	R31,0xFD
    0044D 8220      ST	Z,R2
    0044E 51E6      SUBI	R30,0x16
    0044F 40F2      SBCI	R31,2
    00450 8426      LDD	R2,Z+14
    00451 8437      LDD	R3,Z+15
    00452 2C23      MOV	R2,R3
    00453 2433      CLR	R3
    00454 5EE9      SUBI	R30,0xE9
    00455 4FFD      SBCI	R31,0xFD
    00456 8220      ST	Z,R2
    00457 51E7      SUBI	R30,0x17
    00458 40F2      SBCI	R31,2
    00459 8426      LDD	R2,Z+14
    0045A 8437      LDD	R3,Z+15
    0045B 8840      LDD	R4,Z+16
    0045C 8851      LDD	R5,Z+17
    0045D 0112      MOVW	R2,R4
    0045E 2444      CLR	R4
    0045F 2455      CLR	R5
    00460 5EE8      SUBI	R30,0xE8
    00461 4FFD      SBCI	R31,0xFD
    00462 8220      ST	Z,R2
    00463 51E8      SUBI	R30,0x18
    00464 40F2      SBCI	R31,2
    00465 E188      LDI	R24,0x18
    00466 E090      LDI	R25,0
    00467 8506      LDD	R16,Z+14
    00468 8517      LDD	R17,Z+15
    00469 8920      LDD	R18,Z+16
    0046A 8931      LDD	R19,Z+17
    0046B 938A      ST	-Y,R24
    0046C 940E 4206 CALL	lsr32
    0046E 01FB      MOVW	R30,R22
    0046F 5EE7      SUBI	R30,0xE7
    00470 4FFD      SBCI	R31,0xFD
    00471 8300      ST	Z,R16
    00472 51E9      SUBI	R30,0x19
    00473 40F2      SBCI	R31,2
(0779) 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    00474 8422      LDD	R2,Z+10
    00475 8433      LDD	R3,Z+11
    00476 8444      LDD	R4,Z+12
    00477 8455      LDD	R5,Z+13
    00478 5EE6      SUBI	R30,0xE6
    00479 4FFD      SBCI	R31,0xFD
    0047A 8220      ST	Z,R2
    0047B 51EA      SUBI	R30,0x1A
    0047C 40F2      SBCI	R31,2
    0047D 8422      LDD	R2,Z+10
    0047E 8433      LDD	R3,Z+11
    0047F 2C23      MOV	R2,R3
    00480 2433      CLR	R3
    00481 5EE5      SUBI	R30,0xE5
    00482 4FFD      SBCI	R31,0xFD
    00483 8220      ST	Z,R2
    00484 51EB      SUBI	R30,0x1B
    00485 40F2      SBCI	R31,2
    00486 8422      LDD	R2,Z+10
    00487 8433      LDD	R3,Z+11
    00488 8444      LDD	R4,Z+12
    00489 8455      LDD	R5,Z+13
    0048A 0112      MOVW	R2,R4
    0048B 2444      CLR	R4
    0048C 2455      CLR	R5
    0048D 5EE4      SUBI	R30,0xE4
    0048E 4FFD      SBCI	R31,0xFD
    0048F 8220      ST	Z,R2
    00490 51EC      SUBI	R30,0x1C
    00491 40F2      SBCI	R31,2
    00492 E188      LDI	R24,0x18
    00493 E090      LDI	R25,0
    00494 8502      LDD	R16,Z+10
    00495 8513      LDD	R17,Z+11
    00496 8524      LDD	R18,Z+12
    00497 8535      LDD	R19,Z+13
    00498 938A      ST	-Y,R24
    00499 940E 4206 CALL	lsr32
    0049B 01FB      MOVW	R30,R22
    0049C 5EE3      SUBI	R30,0xE3
    0049D 4FFD      SBCI	R31,0xFD
    0049E 8300      ST	Z,R16
    0049F 51ED      SUBI	R30,0x1D
    004A0 40F2      SBCI	R31,2
(0780) 			/* Write it into the FSInfo sector */
(0781) 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    004A1 E081      LDI	R24,1
    004A2 838C      STD	Y+4,R24
    004A3 8822      LDD	R2,Z+18
    004A4 8833      LDD	R3,Z+19
    004A5 8844      LDD	R4,Z+20
    004A6 8855      LDD	R5,Z+21
    004A7 8228      ST	Y,R2
    004A8 8239      STD	Y+1,R3
    004A9 824A      STD	Y+2,R4
    004AA 825B      STD	Y+3,R5
    004AB 019F      MOVW	R18,R30
    004AC 5D22      SUBI	R18,0xD2
    004AD 4F3F      SBCI	R19,0xFF
    004AE 8101      LDD	R16,Z+1
    004AF 940E 02D5 CALL	_disk_write
(0782) 			fs->fsi_flag = 0;
    004B1 2422      CLR	R2
    004B2 01FB      MOVW	R30,R22
    004B3 8225      STD	Z+5,R2
(0783) 		}
(0784) 		/* Make sure that no pending write process in the physical drive */
(0785) 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    004B4 2422      CLR	R2
    004B5 2433      CLR	R3
    004B6 8239      STD	Y+1,R3
    004B7 8228      ST	Y,R2
    004B8 2722      CLR	R18
    004B9 2733      CLR	R19
    004BA 01FB      MOVW	R30,R22
    004BB 8101      LDD	R16,Z+1
    004BC 2711      CLR	R17
    004BD 940E 02ED CALL	_disk_ioctl
    004BF 3000      CPI	R16,0
    004C0 0701      CPC	R16,R17
    004C1 F009      BEQ	0x04C3
(0786) 			res = FR_DISK_ERR;
    004C2 E041      LDI	R20,1
(0787) 	}
(0788) 
(0789) 	return res;
    004C3 2F04      MOV	R16,R20
    004C4 9625      ADIW	R28,5
    004C5 940C 4185 JMP	pop_xgsetF000
_clust2sect:
  clst                 --> Y,+6
  fs                   --> R10
    004C7 933A      ST	-Y,R19
    004C8 932A      ST	-Y,R18
    004C9 940E 418A CALL	push_xgsetF00C
    004CB 0158      MOVW	R10,R16
(0790) }
(0791) #endif
(0792) 
(0793) 
(0794) 
(0795) 
(0796) /*-----------------------------------------------------------------------*/
(0797) /* Get sector# from cluster#                                             */
(0798) /*-----------------------------------------------------------------------*/
(0799) 
(0800) 
(0801) DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
(0802) 	FATFS *fs,		/* File system object */
(0803) 	DWORD clst		/* Cluster# to be converted */
(0804) )
(0805) {
(0806) 	clst -= 2;
    004CC E042      LDI	R20,2
    004CD E050      LDI	R21,0
    004CE E060      LDI	R22,0
    004CF E070      LDI	R23,0
    004D0 802E      LDD	R2,Y+6
    004D1 803F      LDD	R3,Y+7
    004D2 8448      LDD	R4,Y+8
    004D3 8459      LDD	R5,Y+9
    004D4 1A24      SUB	R2,R20
    004D5 0A35      SBC	R3,R21
    004D6 0A46      SBC	R4,R22
    004D7 0A57      SBC	R5,R23
    004D8 822E      STD	Y+6,R2
    004D9 823F      STD	Y+7,R3
    004DA 8648      STD	Y+8,R4
    004DB 8659      STD	Y+9,R5
(0807) 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    004DC E042      LDI	R20,2
    004DD E050      LDI	R21,0
    004DE E060      LDI	R22,0
    004DF E070      LDI	R23,0
    004E0 01F5      MOVW	R30,R10
    004E1 9676      ADIW	R30,0x16
    004E2 8020      LD	R2,Z
    004E3 8031      LDD	R3,Z+1
    004E4 8042      LDD	R4,Z+2
    004E5 8053      LDD	R5,Z+3
    004E6 1A24      SUB	R2,R20
    004E7 0A35      SBC	R3,R21
    004E8 0A46      SBC	R4,R22
    004E9 0A57      SBC	R5,R23
    004EA 806E      LDD	R6,Y+6
    004EB 807F      LDD	R7,Y+7
    004EC 8488      LDD	R8,Y+8
    004ED 8499      LDD	R9,Y+9
    004EE 1462      CP	R6,R2
    004EF 0473      CPC	R7,R3
    004F0 0484      CPC	R8,R4
    004F1 0495      CPC	R9,R5
    004F2 F028      BCS	0x04F8
    004F3 E000      LDI	R16,0
    004F4 E010      LDI	R17,0
    004F5 E020      LDI	R18,0
    004F6 E030      LDI	R19,0
    004F7 C01D      RJMP	0x0515
(0808) 	return clst * fs->csize + fs->database;
    004F8 01F5      MOVW	R30,R10
    004F9 9632      ADIW	R30,2
    004FA 8020      LD	R2,Z
    004FB 2433      CLR	R3
    004FC 2444      CLR	R4
    004FD 2455      CLR	R5
    004FE 810E      LDD	R16,Y+6
    004FF 811F      LDD	R17,Y+7
    00500 8528      LDD	R18,Y+8
    00501 8539      LDD	R19,Y+9
    00502 925A      ST	-Y,R5
    00503 924A      ST	-Y,R4
    00504 923A      ST	-Y,R3
    00505 922A      ST	-Y,R2
    00506 940E 4117 CALL	empy32u|empy32s
    00508 0118      MOVW	R2,R16
    00509 0129      MOVW	R4,R18
    0050A 01F5      MOVW	R30,R10
    0050B A066      LDD	R6,Z+38
    0050C A077      LDD	R7,Z+39
    0050D A480      LDD	R8,Z+40
    0050E A491      LDD	R9,Z+41
    0050F 0C26      ADD	R2,R6
    00510 1C37      ADC	R3,R7
    00511 1C48      ADC	R4,R8
    00512 1C59      ADC	R5,R9
    00513 0181      MOVW	R16,R2
    00514 0192      MOVW	R18,R4
    00515 940E 4191 CALL	pop_xgsetF00C
    00517 9622      ADIW	R28,2
    00518 9508      RET
_get_fat:
  wc                   --> R14
  p                    --> R10
  bc                   --> R10
  clst                 --> Y,+12
  fs                   --> R12
    00519 933A      ST	-Y,R19
    0051A 932A      ST	-Y,R18
    0051B 940E 416B CALL	push_xgsetF0FC
    0051D 0168      MOVW	R12,R16
    0051E 9722      SBIW	R28,2
(0809) }
(0810) 
(0811) 
(0812) 
(0813) 
(0814) /*-----------------------------------------------------------------------*/
(0815) /* FAT access - Read value of a FAT entry                                */
(0816) /*-----------------------------------------------------------------------*/
(0817) 
(0818) 
(0819) DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
(0820) 	FATFS *fs,	/* File system object */
(0821) 	DWORD clst	/* Cluster# to get the link information */
(0822) )
(0823) {
(0824) 	UINT wc, bc;
(0825) 	BYTE *p;
(0826) 
(0827) 
(0828) 	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    0051F E042      LDI	R20,2
    00520 E050      LDI	R21,0
    00521 E060      LDI	R22,0
    00522 E070      LDI	R23,0
    00523 842C      LDD	R2,Y+12
    00524 843D      LDD	R3,Y+13
    00525 844E      LDD	R4,Y+14
    00526 845F      LDD	R5,Y+15
    00527 1624      CP	R2,R20
    00528 0635      CPC	R3,R21
    00529 0646      CPC	R4,R22
    0052A 0657      CPC	R5,R23
    0052B F078      BCS	0x053B
    0052C 01F6      MOVW	R30,R12
    0052D 9676      ADIW	R30,0x16
    0052E 8020      LD	R2,Z
    0052F 8031      LDD	R3,Z+1
    00530 8042      LDD	R4,Z+2
    00531 8053      LDD	R5,Z+3
    00532 846C      LDD	R6,Y+12
    00533 847D      LDD	R7,Y+13
    00534 848E      LDD	R8,Y+14
    00535 849F      LDD	R9,Y+15
    00536 1462      CP	R6,R2
    00537 0473      CPC	R7,R3
    00538 0484      CPC	R8,R4
    00539 0495      CPC	R9,R5
    0053A F028      BCS	0x0540
(0829) 		return 1;
    0053B E001      LDI	R16,1
    0053C E010      LDI	R17,0
    0053D E020      LDI	R18,0
    0053E E030      LDI	R19,0
    0053F C124      RJMP	0x0664
(0830) 
(0831) 	switch (fs->fs_type) {
    00540 01F6      MOVW	R30,R12
    00541 80A0      LD	R10,Z
    00542 24BB      CLR	R11
    00543 01C5      MOVW	R24,R10
    00544 3081      CPI	R24,1
    00545 E0E0      LDI	R30,0
    00546 079E      CPC	R25,R30
    00547 F059      BEQ	0x0553
    00548 3082      CPI	R24,2
    00549 E0E0      LDI	R30,0
    0054A 079E      CPC	R25,R30
    0054B F409      BNE	0x054D
    0054C C06F      RJMP	0x05BC
    0054D 3083      CPI	R24,3
    0054E E0E0      LDI	R30,0
    0054F 079E      CPC	R25,R30
    00550 F409      BNE	0x0552
    00551 C0A6      RJMP	0x05F8
    00552 C10D      RJMP	0x0660
(0832) 	case FS_FAT12 :
(0833) 		bc = (UINT)clst; bc += bc / 2;
    00553 84AC      LDD	R10,Y+12
    00554 84BD      LDD	R11,Y+13
    00555 0115      MOVW	R2,R10
    00556 9436      LSR	R3
    00557 9427      ROR	R2
    00558 0CA2      ADD	R10,R2
    00559 1CB3      ADC	R11,R3
(0834) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    0055A E029      LDI	R18,0x9
    0055B E030      LDI	R19,0
    0055C 0185      MOVW	R16,R10
    0055D 940E 41FF CALL	lsr16
    0055F 0118      MOVW	R2,R16
    00560 2444      CLR	R4
    00561 2455      CLR	R5
    00562 01F6      MOVW	R30,R12
    00563 8C66      LDD	R6,Z+30
    00564 8C77      LDD	R7,Z+31
    00565 A080      LDD	R8,Z+32
    00566 A091      LDD	R9,Z+33
    00567 0C62      ADD	R6,R2
    00568 1C73      ADC	R7,R3
    00569 1C84      ADC	R8,R4
    0056A 1C95      ADC	R9,R5
    0056B 8288      ST	Y,R8
    0056C 8299      STD	Y+1,R9
    0056D 0193      MOVW	R18,R6
    0056E 018F      MOVW	R16,R30
    0056F DDE0      RCALL	ff.c:move_window
    00570 2300      TST	R16
    00571 F009      BEQ	0x0573
    00572 C0ED      RJMP	0x0660
(0835) 		wc = fs->win[bc % SS(fs)]; bc++;
    00573 01C6      MOVW	R24,R12
    00574 968E      ADIW	R24,0x2E
    00575 01F5      MOVW	R30,R10
    00576 70F1      ANDI	R31,1
    00577 0FE8      ADD	R30,R24
    00578 1FF9      ADC	R31,R25
    00579 80E0      LD	R14,Z
    0057A 24FF      CLR	R15
    0057B 01C5      MOVW	R24,R10
    0057C 9601      ADIW	R24,1
    0057D 015C      MOVW	R10,R24
(0836) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    0057E E029      LDI	R18,0x9
    0057F E030      LDI	R19,0
    00580 018C      MOVW	R16,R24
    00581 940E 41FF CALL	lsr16
    00583 0118      MOVW	R2,R16
    00584 2444      CLR	R4
    00585 2455      CLR	R5
    00586 01F6      MOVW	R30,R12
    00587 8C66      LDD	R6,Z+30
    00588 8C77      LDD	R7,Z+31
    00589 A080      LDD	R8,Z+32
    0058A A091      LDD	R9,Z+33
    0058B 0C62      ADD	R6,R2
    0058C 1C73      ADC	R7,R3
    0058D 1C84      ADC	R8,R4
    0058E 1C95      ADC	R9,R5
    0058F 8288      ST	Y,R8
    00590 8299      STD	Y+1,R9
    00591 0193      MOVW	R18,R6
    00592 018F      MOVW	R16,R30
    00593 DDBC      RCALL	ff.c:move_window
    00594 2300      TST	R16
    00595 F009      BEQ	0x0597
    00596 C0C9      RJMP	0x0660
(0837) 		wc |= fs->win[bc % SS(fs)] << 8;
    00597 01C6      MOVW	R24,R12
    00598 968E      ADIW	R24,0x2E
    00599 01F5      MOVW	R30,R10
    0059A 70F1      ANDI	R31,1
    0059B 0FE8      ADD	R30,R24
    0059C 1FF9      ADC	R31,R25
    0059D 8020      LD	R2,Z
    0059E 2433      CLR	R3
    0059F 2C32      MOV	R3,R2
    005A0 2422      CLR	R2
    005A1 28E2      OR	R14,R2
    005A2 28F3      OR	R15,R3
(0838) 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    005A3 842C      LDD	R2,Y+12
    005A4 843D      LDD	R3,Y+13
    005A5 844E      LDD	R4,Y+14
    005A6 845F      LDD	R5,Y+15
    005A7 2DE2      MOV	R30,R2
    005A8 70E1      ANDI	R30,1
    005A9 F051      BEQ	0x05B4
    005AA 0157      MOVW	R10,R14
    005AB 94B6      LSR	R11
    005AC 94A7      ROR	R10
    005AD 94B6      LSR	R11
    005AE 94A7      ROR	R10
    005AF 94B6      LSR	R11
    005B0 94A7      ROR	R10
    005B1 94B6      LSR	R11
    005B2 94A7      ROR	R10
    005B3 C003      RJMP	0x05B7
    005B4 01C7      MOVW	R24,R14
    005B5 709F      ANDI	R25,0xF
    005B6 015C      MOVW	R10,R24
    005B7 0185      MOVW	R16,R10
    005B8 0196      MOVW	R18,R12
    005B9 2722      CLR	R18
    005BA 2733      CLR	R19
    005BB C0A8      RJMP	0x0664
(0839) 
(0840) 	case FS_FAT16 :
(0841) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    005BC E088      LDI	R24,0x8
    005BD E090      LDI	R25,0
    005BE 850C      LDD	R16,Y+12
    005BF 851D      LDD	R17,Y+13
    005C0 852E      LDD	R18,Y+14
    005C1 853F      LDD	R19,Y+15
    005C2 938A      ST	-Y,R24
    005C3 940E 4206 CALL	lsr32
    005C5 01F6      MOVW	R30,R12
    005C6 8C26      LDD	R2,Z+30
    005C7 8C37      LDD	R3,Z+31
    005C8 A040      LDD	R4,Z+32
    005C9 A051      LDD	R5,Z+33
    005CA 0E20      ADD	R2,R16
    005CB 1E31      ADC	R3,R17
    005CC 1E42      ADC	R4,R18
    005CD 1E53      ADC	R5,R19
    005CE 8248      ST	Y,R4
    005CF 8259      STD	Y+1,R5
    005D0 0191      MOVW	R18,R2
    005D1 018F      MOVW	R16,R30
    005D2 DD7D      RCALL	ff.c:move_window
    005D3 2EA0      MOV	R10,R16
    005D4 2300      TST	R16
    005D5 F009      BEQ	0x05D7
    005D6 C089      RJMP	0x0660
(0842) 		p = &fs->win[clst * 2 % SS(fs)];
    005D7 EF4F      LDI	R20,0xFF
    005D8 E051      LDI	R21,1
    005D9 E060      LDI	R22,0
    005DA E070      LDI	R23,0
    005DB 842C      LDD	R2,Y+12
    005DC 843D      LDD	R3,Y+13
    005DD 844E      LDD	R4,Y+14
    005DE 845F      LDD	R5,Y+15
    005DF 0C22      LSL	R2
    005E0 1C33      ROL	R3
    005E1 1C44      ROL	R4
    005E2 1C55      ROL	R5
    005E3 2224      AND	R2,R20
    005E4 2235      AND	R3,R21
    005E5 2246      AND	R4,R22
    005E6 2257      AND	R5,R23
    005E7 0151      MOVW	R10,R2
    005E8 01C6      MOVW	R24,R12
    005E9 968E      ADIW	R24,0x2E
    005EA 0EA8      ADD	R10,R24
    005EB 1EB9      ADC	R11,R25
(0843) 		return LD_WORD(p);
    005EC 01F5      MOVW	R30,R10
    005ED 8020      LD	R2,Z
    005EE 2433      CLR	R3
    005EF 8101      LDD	R16,Z+1
    005F0 2711      CLR	R17
    005F1 2F10      MOV	R17,R16
    005F2 2700      CLR	R16
    005F3 2902      OR	R16,R2
    005F4 2913      OR	R17,R3
    005F5 2722      CLR	R18
    005F6 2733      CLR	R19
    005F7 C06C      RJMP	0x0664
(0844) 
(0845) 	case FS_FAT32 :
(0846) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    005F8 E087      LDI	R24,7
    005F9 E090      LDI	R25,0
    005FA 850C      LDD	R16,Y+12
    005FB 851D      LDD	R17,Y+13
    005FC 852E      LDD	R18,Y+14
    005FD 853F      LDD	R19,Y+15
    005FE 938A      ST	-Y,R24
    005FF 940E 4206 CALL	lsr32
    00601 01F6      MOVW	R30,R12
    00602 8C26      LDD	R2,Z+30
    00603 8C37      LDD	R3,Z+31
    00604 A040      LDD	R4,Z+32
    00605 A051      LDD	R5,Z+33
    00606 0E20      ADD	R2,R16
    00607 1E31      ADC	R3,R17
    00608 1E42      ADC	R4,R18
    00609 1E53      ADC	R5,R19
    0060A 8248      ST	Y,R4
    0060B 8259      STD	Y+1,R5
    0060C 0191      MOVW	R18,R2
    0060D 018F      MOVW	R16,R30
    0060E DD41      RCALL	ff.c:move_window
    0060F 2EE0      MOV	R14,R16
    00610 2300      TST	R16
    00611 F009      BEQ	0x0613
    00612 C04D      RJMP	0x0660
(0847) 		p = &fs->win[clst * 4 % SS(fs)];
    00613 E082      LDI	R24,2
    00614 E090      LDI	R25,0
    00615 850C      LDD	R16,Y+12
    00616 851D      LDD	R17,Y+13
    00617 852E      LDD	R18,Y+14
    00618 853F      LDD	R19,Y+15
    00619 938A      ST	-Y,R24
    0061A 940E 41ED CALL	lsl32
    0061C 0118      MOVW	R2,R16
    0061D 0129      MOVW	R4,R18
    0061E EF4F      LDI	R20,0xFF
    0061F E051      LDI	R21,1
    00620 E060      LDI	R22,0
    00621 E070      LDI	R23,0
    00622 2224      AND	R2,R20
    00623 2235      AND	R3,R21
    00624 2246      AND	R4,R22
    00625 2257      AND	R5,R23
    00626 0151      MOVW	R10,R2
    00627 01C6      MOVW	R24,R12
    00628 968E      ADIW	R24,0x2E
    00629 0EA8      ADD	R10,R24
    0062A 1EB9      ADC	R11,R25
(0848) 		return LD_DWORD(p) & 0x0FFFFFFF;
    0062B E188      LDI	R24,0x18
    0062C E090      LDI	R25,0
    0062D 01F5      MOVW	R30,R10
    0062E 8103      LDD	R16,Z+3
    0062F 2711      CLR	R17
    00630 2722      CLR	R18
    00631 2733      CLR	R19
    00632 938A      ST	-Y,R24
    00633 940E 41ED CALL	lsl32
    00635 0118      MOVW	R2,R16
    00636 0129      MOVW	R4,R18
    00637 01F5      MOVW	R30,R10
    00638 8062      LDD	R6,Z+2
    00639 2477      CLR	R7
    0063A 2488      CLR	R8
    0063B 2499      CLR	R9
    0063C 0143      MOVW	R8,R6
    0063D 2466      CLR	R6
    0063E 2477      CLR	R7
    0063F 2826      OR	R2,R6
    00640 2837      OR	R3,R7
    00641 2848      OR	R4,R8
    00642 2859      OR	R5,R9
    00643 8061      LDD	R6,Z+1
    00644 2477      CLR	R7
    00645 2C76      MOV	R7,R6
    00646 2466      CLR	R6
    00647 2488      CLR	R8
    00648 2499      CLR	R9
    00649 2826      OR	R2,R6
    0064A 2837      OR	R3,R7
    0064B 2848      OR	R4,R8
    0064C 2859      OR	R5,R9
    0064D 8060      LD	R6,Z
    0064E 2477      CLR	R7
    0064F 2488      CLR	R8
    00650 2499      CLR	R9
    00651 2826      OR	R2,R6
    00652 2837      OR	R3,R7
    00653 2848      OR	R4,R8
    00654 2859      OR	R5,R9
    00655 EF4F      LDI	R20,0xFF
    00656 EF5F      LDI	R21,0xFF
    00657 EF6F      LDI	R22,0xFF
    00658 E07F      LDI	R23,0xF
    00659 2224      AND	R2,R20
    0065A 2235      AND	R3,R21
    0065B 2246      AND	R4,R22
    0065C 2257      AND	R5,R23
    0065D 0181      MOVW	R16,R2
    0065E 0192      MOVW	R18,R4
    0065F C004      RJMP	0x0664
(0849) 	}
(0850) 
(0851) 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    00660 EF0F      LDI	R16,0xFF
    00661 EF1F      LDI	R17,0xFF
    00662 EF2F      LDI	R18,0xFF
    00663 EF3F      LDI	R19,0xFF
    00664 9622      ADIW	R28,2
    00665 940E 4160 CALL	pop_xgsetF0FC
    00667 9622      ADIW	R28,2
    00668 9508      RET
_put_fat:
  bc                   --> R12
  p                    --> R14
  res                  --> Y,+2
  val                  --> Y,+19
  clst                 --> Y,+15
  fs                   --> Y,+13
    00669 940E 4026 CALL	push_arg4
    0066B 940E 416B CALL	push_xgsetF0FC
    0066D 9723      SBIW	R28,3
(0852) }
(0853) 
(0854) 
(0855) 
(0856) 
(0857) /*-----------------------------------------------------------------------*/
(0858) /* FAT access - Change value of a FAT entry                              */
(0859) /*-----------------------------------------------------------------------*/
(0860) #if !_FS_READONLY
(0861) 
(0862) FRESULT put_fat (
(0863) 	FATFS *fs,	/* File system object */
(0864) 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
(0865) 	DWORD val	/* New value to mark the cluster */
(0866) )
(0867) {
(0868) 	UINT bc;
(0869) 	BYTE *p;
(0870) 	FRESULT res;
(0871) 
(0872) 
(0873) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    0066E E042      LDI	R20,2
    0066F E050      LDI	R21,0
    00670 E060      LDI	R22,0
    00671 E070      LDI	R23,0
    00672 842F      LDD	R2,Y+15
    00673 8838      LDD	R3,Y+16
    00674 8849      LDD	R4,Y+17
    00675 885A      LDD	R5,Y+18
    00676 1624      CP	R2,R20
    00677 0635      CPC	R3,R21
    00678 0646      CPC	R4,R22
    00679 0657      CPC	R5,R23
    0067A F080      BCS	0x068B
    0067B 85ED      LDD	R30,Y+13
    0067C 85FE      LDD	R31,Y+14
    0067D 9676      ADIW	R30,0x16
    0067E 8020      LD	R2,Z
    0067F 8031      LDD	R3,Z+1
    00680 8042      LDD	R4,Z+2
    00681 8053      LDD	R5,Z+3
    00682 846F      LDD	R6,Y+15
    00683 8878      LDD	R7,Y+16
    00684 8889      LDD	R8,Y+17
    00685 889A      LDD	R9,Y+18
    00686 1462      CP	R6,R2
    00687 0473      CPC	R7,R3
    00688 0484      CPC	R8,R4
    00689 0495      CPC	R9,R5
    0068A F018      BCS	0x068E
(0874) 		res = FR_INT_ERR;
    0068B E082      LDI	R24,2
    0068C 838A      STD	Y+2,R24
(0875) 
(0876) 	} else {
    0068D C194      RJMP	0x0822
(0877) 		switch (fs->fs_type) {
    0068E 85ED      LDD	R30,Y+13
    0068F 85FE      LDD	R31,Y+14
    00690 80A0      LD	R10,Z
    00691 24BB      CLR	R11
    00692 01C5      MOVW	R24,R10
    00693 3081      CPI	R24,1
    00694 E0E0      LDI	R30,0
    00695 079E      CPC	R25,R30
    00696 F059      BEQ	0x06A2
    00697 3082      CPI	R24,2
    00698 E0E0      LDI	R30,0
    00699 079E      CPC	R25,R30
    0069A F409      BNE	0x069C
    0069B C0B0      RJMP	0x074C
    0069C 3083      CPI	R24,3
    0069D E0E0      LDI	R30,0
    0069E 079E      CPC	R25,R30
    0069F F409      BNE	0x06A1
    006A0 C0E7      RJMP	0x0788
    006A1 C17A      RJMP	0x081C
(0878) 		case FS_FAT12 :
(0879) 			bc = clst; bc += bc / 2;
    006A2 84CF      LDD	R12,Y+15
    006A3 88D8      LDD	R13,Y+16
    006A4 0116      MOVW	R2,R12
    006A5 9436      LSR	R3
    006A6 9427      ROR	R2
    006A7 0CC2      ADD	R12,R2
    006A8 1CD3      ADC	R13,R3
(0880) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006A9 E029      LDI	R18,0x9
    006AA E030      LDI	R19,0
    006AB 0186      MOVW	R16,R12
    006AC 940E 41FF CALL	lsr16
    006AE 0118      MOVW	R2,R16
    006AF 2444      CLR	R4
    006B0 2455      CLR	R5
    006B1 85ED      LDD	R30,Y+13
    006B2 85FE      LDD	R31,Y+14
    006B3 8C66      LDD	R6,Z+30
    006B4 8C77      LDD	R7,Z+31
    006B5 A080      LDD	R8,Z+32
    006B6 A091      LDD	R9,Z+33
    006B7 0C62      ADD	R6,R2
    006B8 1C73      ADC	R7,R3
    006B9 1C84      ADC	R8,R4
    006BA 1C95      ADC	R9,R5
    006BB 8288      ST	Y,R8
    006BC 8299      STD	Y+1,R9
    006BD 0193      MOVW	R18,R6
    006BE 018F      MOVW	R16,R30
    006BF DC90      RCALL	ff.c:move_window
    006C0 830A      STD	Y+2,R16
(0881) 			if (res != FR_OK) break;
    006C1 2E00      MOV	R0,R16
    006C2 2300      TST	R16
    006C3 F009      BEQ	0x06C5
    006C4 C159      RJMP	0x081E
(0882) 			p = &fs->win[bc % SS(fs)];
    006C5 858D      LDD	R24,Y+13
    006C6 859E      LDD	R25,Y+14
    006C7 968E      ADIW	R24,0x2E
    006C8 01F6      MOVW	R30,R12
    006C9 70F1      ANDI	R31,1
    006CA 017F      MOVW	R14,R30
    006CB 0EE8      ADD	R14,R24
    006CC 1EF9      ADC	R15,R25
(0883) 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    006CD 842F      LDD	R2,Y+15
    006CE 8838      LDD	R3,Y+16
    006CF 8849      LDD	R4,Y+17
    006D0 885A      LDD	R5,Y+18
    006D1 93EF      PUSH	R30
    006D2 2DE2      MOV	R30,R2
    006D3 70E1      ANDI	R30,1
    006D4 91EF      POP	R30
    006D5 F0B1      BEQ	0x06EC
    006D6 882B      LDD	R2,Y+19
    006D7 883C      LDD	R3,Y+20
    006D8 884D      LDD	R4,Y+21
    006D9 885E      LDD	R5,Y+22
    006DA 2433      CLR	R3
    006DB 0C22      LSL	R2
    006DC 1C33      ROL	R3
    006DD 0C22      LSL	R2
    006DE 1C33      ROL	R3
    006DF 0C22      LSL	R2
    006E0 1C33      ROL	R3
    006E1 0C22      LSL	R2
    006E2 1C33      ROL	R3
    006E3 01F7      MOVW	R30,R14
    006E4 8180      LD	R24,Z
    006E5 2799      CLR	R25
    006E6 708F      ANDI	R24,0xF
    006E7 7090      ANDI	R25,0
    006E8 015C      MOVW	R10,R24
    006E9 28A2      OR	R10,R2
    006EA 28B3      OR	R11,R3
    006EB C006      RJMP	0x06F2
    006EC 882B      LDD	R2,Y+19
    006ED 883C      LDD	R3,Y+20
    006EE 884D      LDD	R4,Y+21
    006EF 885E      LDD	R5,Y+22
    006F0 2CA2      MOV	R10,R2
    006F1 24BB      CLR	R11
    006F2 01F7      MOVW	R30,R14
    006F3 82A0      ST	Z,R10
(0884) 			bc++;
    006F4 01C6      MOVW	R24,R12
    006F5 9601      ADIW	R24,1
    006F6 016C      MOVW	R12,R24
(0885) 			fs->wflag = 1;
    006F7 E081      LDI	R24,1
    006F8 85ED      LDD	R30,Y+13
    006F9 85FE      LDD	R31,Y+14
    006FA 8384      STD	Z+4,R24
(0886) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006FB E029      LDI	R18,0x9
    006FC E030      LDI	R19,0
    006FD 0186      MOVW	R16,R12
    006FE 940E 41FF CALL	lsr16
    00700 0118      MOVW	R2,R16
    00701 2444      CLR	R4
    00702 2455      CLR	R5
    00703 85ED      LDD	R30,Y+13
    00704 85FE      LDD	R31,Y+14
    00705 8C66      LDD	R6,Z+30
    00706 8C77      LDD	R7,Z+31
    00707 A080      LDD	R8,Z+32
    00708 A091      LDD	R9,Z+33
    00709 0C62      ADD	R6,R2
    0070A 1C73      ADC	R7,R3
    0070B 1C84      ADC	R8,R4
    0070C 1C95      ADC	R9,R5
    0070D 8288      ST	Y,R8
    0070E 8299      STD	Y+1,R9
    0070F 0193      MOVW	R18,R6
    00710 018F      MOVW	R16,R30
    00711 DC3E      RCALL	ff.c:move_window
    00712 830A      STD	Y+2,R16
(0887) 			if (res != FR_OK) break;
    00713 2E00      MOV	R0,R16
    00714 2300      TST	R16
    00715 F009      BEQ	0x0717
    00716 C107      RJMP	0x081E
(0888) 			p = &fs->win[bc % SS(fs)];
    00717 858D      LDD	R24,Y+13
    00718 859E      LDD	R25,Y+14
    00719 968E      ADIW	R24,0x2E
    0071A 01F6      MOVW	R30,R12
    0071B 70F1      ANDI	R31,1
    0071C 017F      MOVW	R14,R30
    0071D 0EE8      ADD	R14,R24
    0071E 1EF9      ADC	R15,R25
(0889) 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    0071F 842F      LDD	R2,Y+15
    00720 8838      LDD	R3,Y+16
    00721 8849      LDD	R4,Y+17
    00722 885A      LDD	R5,Y+18
    00723 93EF      PUSH	R30
    00724 2DE2      MOV	R30,R2
    00725 70E1      ANDI	R30,1
    00726 91EF      POP	R30
    00727 F061      BEQ	0x0734
    00728 E084      LDI	R24,4
    00729 E090      LDI	R25,0
    0072A 890B      LDD	R16,Y+19
    0072B 891C      LDD	R17,Y+20
    0072C 892D      LDD	R18,Y+21
    0072D 893E      LDD	R19,Y+22
    0072E 938A      ST	-Y,R24
    0072F 940E 4206 CALL	lsr32
    00731 2EC0      MOV	R12,R16
    00732 24DD      CLR	R13
    00733 C015      RJMP	0x0749
    00734 E088      LDI	R24,0x8
    00735 E090      LDI	R25,0
    00736 890B      LDD	R16,Y+19
    00737 891C      LDD	R17,Y+20
    00738 892D      LDD	R18,Y+21
    00739 893E      LDD	R19,Y+22
    0073A 938A      ST	-Y,R24
    0073B 940E 4206 CALL	lsr32
    0073D 2F80      MOV	R24,R16
    0073E 2799      CLR	R25
    0073F 708F      ANDI	R24,0xF
    00740 7090      ANDI	R25,0
    00741 01F7      MOVW	R30,R14
    00742 81E0      LD	R30,Z
    00743 27FF      CLR	R31
    00744 7FE0      ANDI	R30,0xF0
    00745 70F0      ANDI	R31,0
    00746 016F      MOVW	R12,R30
    00747 2AC8      OR	R12,R24
    00748 2AD9      OR	R13,R25
    00749 01F7      MOVW	R30,R14
    0074A 82C0      ST	Z,R12
(0890) 			break;
    0074B C0D2      RJMP	0x081E
(0891) 
(0892) 		case FS_FAT16 :
(0893) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    0074C E088      LDI	R24,0x8
    0074D E090      LDI	R25,0
    0074E 850F      LDD	R16,Y+15
    0074F 8918      LDD	R17,Y+16
    00750 8929      LDD	R18,Y+17
    00751 893A      LDD	R19,Y+18
    00752 938A      ST	-Y,R24
    00753 940E 4206 CALL	lsr32
    00755 85ED      LDD	R30,Y+13
    00756 85FE      LDD	R31,Y+14
    00757 8C26      LDD	R2,Z+30
    00758 8C37      LDD	R3,Z+31
    00759 A040      LDD	R4,Z+32
    0075A A051      LDD	R5,Z+33
    0075B 0E20      ADD	R2,R16
    0075C 1E31      ADC	R3,R17
    0075D 1E42      ADC	R4,R18
    0075E 1E53      ADC	R5,R19
    0075F 8248      ST	Y,R4
    00760 8259      STD	Y+1,R5
    00761 0191      MOVW	R18,R2
    00762 018F      MOVW	R16,R30
    00763 DBEC      RCALL	ff.c:move_window
    00764 2EC0      MOV	R12,R16
    00765 82CA      STD	Y+2,R12
(0894) 			if (res != FR_OK) break;
    00766 2C0C      MOV	R0,R12
    00767 2300      TST	R16
    00768 F009      BEQ	0x076A
    00769 C0B4      RJMP	0x081E
(0895) 			p = &fs->win[clst * 2 % SS(fs)];
    0076A EF4F      LDI	R20,0xFF
    0076B E051      LDI	R21,1
    0076C E060      LDI	R22,0
    0076D E070      LDI	R23,0
    0076E 842F      LDD	R2,Y+15
    0076F 8838      LDD	R3,Y+16
    00770 8849      LDD	R4,Y+17
    00771 885A      LDD	R5,Y+18
    00772 0C22      LSL	R2
    00773 1C33      ROL	R3
    00774 1C44      ROL	R4
    00775 1C55      ROL	R5
    00776 2224      AND	R2,R20
    00777 2235      AND	R3,R21
    00778 2246      AND	R4,R22
    00779 2257      AND	R5,R23
    0077A 0171      MOVW	R14,R2
    0077B 858D      LDD	R24,Y+13
    0077C 859E      LDD	R25,Y+14
    0077D 968E      ADIW	R24,0x2E
    0077E 0EE8      ADD	R14,R24
    0077F 1EF9      ADC	R15,R25
(0896) 			ST_WORD(p, (WORD)val);
    00780 882B      LDD	R2,Y+19
    00781 883C      LDD	R3,Y+20
    00782 01F7      MOVW	R30,R14
    00783 8220      ST	Z,R2
    00784 2C23      MOV	R2,R3
    00785 2433      CLR	R3
    00786 8221      STD	Z+1,R2
(0897) 			break;
    00787 C096      RJMP	0x081E
(0898) 
(0899) 		case FS_FAT32 :
(0900) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    00788 E087      LDI	R24,7
    00789 E090      LDI	R25,0
    0078A 850F      LDD	R16,Y+15
    0078B 8918      LDD	R17,Y+16
    0078C 8929      LDD	R18,Y+17
    0078D 893A      LDD	R19,Y+18
    0078E 938A      ST	-Y,R24
    0078F 940E 4206 CALL	lsr32
    00791 85ED      LDD	R30,Y+13
    00792 85FE      LDD	R31,Y+14
    00793 8C26      LDD	R2,Z+30
    00794 8C37      LDD	R3,Z+31
    00795 A040      LDD	R4,Z+32
    00796 A051      LDD	R5,Z+33
    00797 0E20      ADD	R2,R16
    00798 1E31      ADC	R3,R17
    00799 1E42      ADC	R4,R18
    0079A 1E53      ADC	R5,R19
    0079B 8248      ST	Y,R4
    0079C 8259      STD	Y+1,R5
    0079D 0191      MOVW	R18,R2
    0079E 018F      MOVW	R16,R30
    0079F DBB0      RCALL	ff.c:move_window
    007A0 2EC0      MOV	R12,R16
    007A1 82CA      STD	Y+2,R12
(0901) 			if (res != FR_OK) break;
    007A2 2C0C      MOV	R0,R12
    007A3 2300      TST	R16
    007A4 F009      BEQ	0x07A6
    007A5 C078      RJMP	0x081E
(0902) 			p = &fs->win[clst * 4 % SS(fs)];
    007A6 E082      LDI	R24,2
    007A7 E090      LDI	R25,0
    007A8 850F      LDD	R16,Y+15
    007A9 8918      LDD	R17,Y+16
    007AA 8929      LDD	R18,Y+17
    007AB 893A      LDD	R19,Y+18
    007AC 938A      ST	-Y,R24
    007AD 940E 41ED CALL	lsl32
    007AF 0118      MOVW	R2,R16
    007B0 0129      MOVW	R4,R18
    007B1 EF4F      LDI	R20,0xFF
    007B2 E051      LDI	R21,1
    007B3 E060      LDI	R22,0
    007B4 E070      LDI	R23,0
    007B5 2224      AND	R2,R20
    007B6 2235      AND	R3,R21
    007B7 2246      AND	R4,R22
    007B8 2257      AND	R5,R23
    007B9 0171      MOVW	R14,R2
    007BA 858D      LDD	R24,Y+13
    007BB 859E      LDD	R25,Y+14
    007BC 968E      ADIW	R24,0x2E
    007BD 0EE8      ADD	R14,R24
    007BE 1EF9      ADC	R15,R25
(0903) 			val |= LD_DWORD(p) & 0xF0000000;
    007BF E188      LDI	R24,0x18
    007C0 E090      LDI	R25,0
    007C1 01F7      MOVW	R30,R14
    007C2 8103      LDD	R16,Z+3
    007C3 2711      CLR	R17
    007C4 2722      CLR	R18
    007C5 2733      CLR	R19
    007C6 938A      ST	-Y,R24
    007C7 940E 41ED CALL	lsl32
    007C9 0118      MOVW	R2,R16
    007CA 0129      MOVW	R4,R18
    007CB 01F7      MOVW	R30,R14
    007CC 8062      LDD	R6,Z+2
    007CD 2477      CLR	R7
    007CE 2488      CLR	R8
    007CF 2499      CLR	R9
    007D0 0143      MOVW	R8,R6
    007D1 2466      CLR	R6
    007D2 2477      CLR	R7
    007D3 2826      OR	R2,R6
    007D4 2837      OR	R3,R7
    007D5 2848      OR	R4,R8
    007D6 2859      OR	R5,R9
    007D7 8061      LDD	R6,Z+1
    007D8 2477      CLR	R7
    007D9 2C76      MOV	R7,R6
    007DA 2466      CLR	R6
    007DB 2488      CLR	R8
    007DC 2499      CLR	R9
    007DD 2826      OR	R2,R6
    007DE 2837      OR	R3,R7
    007DF 2848      OR	R4,R8
    007E0 2859      OR	R5,R9
    007E1 8060      LD	R6,Z
    007E2 2477      CLR	R7
    007E3 2488      CLR	R8
    007E4 2499      CLR	R9
    007E5 2826      OR	R2,R6
    007E6 2837      OR	R3,R7
    007E7 2848      OR	R4,R8
    007E8 2859      OR	R5,R9
    007E9 E040      LDI	R20,0
    007EA E050      LDI	R21,0
    007EB E060      LDI	R22,0
    007EC EF70      LDI	R23,0xF0
    007ED 2224      AND	R2,R20
    007EE 2235      AND	R3,R21
    007EF 2246      AND	R4,R22
    007F0 2257      AND	R5,R23
    007F1 886B      LDD	R6,Y+19
    007F2 887C      LDD	R7,Y+20
    007F3 888D      LDD	R8,Y+21
    007F4 889E      LDD	R9,Y+22
    007F5 2862      OR	R6,R2
    007F6 2873      OR	R7,R3
    007F7 2884      OR	R8,R4
    007F8 2895      OR	R9,R5
    007F9 8A6B      STD	Y+19,R6
    007FA 8A7C      STD	Y+20,R7
    007FB 8A8D      STD	Y+21,R8
    007FC 8A9E      STD	Y+22,R9
(0904) 			ST_DWORD(p, val);
    007FD 882B      LDD	R2,Y+19
    007FE 883C      LDD	R3,Y+20
    007FF 884D      LDD	R4,Y+21
    00800 885E      LDD	R5,Y+22
    00801 8220      ST	Z,R2
    00802 2C23      MOV	R2,R3
    00803 2433      CLR	R3
    00804 9631      ADIW	R30,1
    00805 8220      ST	Z,R2
    00806 882B      LDD	R2,Y+19
    00807 883C      LDD	R3,Y+20
    00808 884D      LDD	R4,Y+21
    00809 885E      LDD	R5,Y+22
    0080A 0112      MOVW	R2,R4
    0080B 2444      CLR	R4
    0080C 2455      CLR	R5
    0080D 01F7      MOVW	R30,R14
    0080E 9632      ADIW	R30,2
    0080F 8220      ST	Z,R2
    00810 E188      LDI	R24,0x18
    00811 E090      LDI	R25,0
    00812 890B      LDD	R16,Y+19
    00813 891C      LDD	R17,Y+20
    00814 892D      LDD	R18,Y+21
    00815 893E      LDD	R19,Y+22
    00816 938A      ST	-Y,R24
    00817 940E 4206 CALL	lsr32
    00819 01F7      MOVW	R30,R14
    0081A 8303      STD	Z+3,R16
(0905) 			break;
    0081B C002      RJMP	0x081E
(0906) 
(0907) 		default :
(0908) 			res = FR_INT_ERR;
    0081C E082      LDI	R24,2
    0081D 838A      STD	Y+2,R24
(0909) 		}
(0910) 		fs->wflag = 1;
    0081E E081      LDI	R24,1
    0081F 85ED      LDD	R30,Y+13
    00820 85FE      LDD	R31,Y+14
    00821 8384      STD	Z+4,R24
(0911) 	}
(0912) 
(0913) 	return res;
    00822 810A      LDD	R16,Y+2
    00823 9623      ADIW	R28,3
    00824 940E 4160 CALL	pop_xgsetF0FC
    00826 9624      ADIW	R28,4
    00827 9508      RET
ff.c:remove_chain:
  res                  --> R10
  nxt                  --> Y,+6
  clst                 --> Y,+18
  fs                   --> R12
    00828 933A      ST	-Y,R19
    00829 932A      ST	-Y,R18
    0082A 940E 41A6 CALL	push_xgsetF03C
    0082C 0168      MOVW	R12,R16
    0082D 972A      SBIW	R28,0xA
(0914) }
(0915) #endif /* !_FS_READONLY */
(0916) 
(0917) 
(0918) 
(0919) 
(0920) /*-----------------------------------------------------------------------*/
(0921) /* FAT handling - Remove a cluster chain                                 */
(0922) /*-----------------------------------------------------------------------*/
(0923) #if !_FS_READONLY
(0924) static
(0925) FRESULT remove_chain (
(0926) 	FATFS *fs,			/* File system object */
(0927) 	DWORD clst			/* Cluster# to remove a chain from */
(0928) )
(0929) {
(0930) 	FRESULT res;
(0931) 	DWORD nxt;
(0932) #if _USE_ERASE
(0933) 	DWORD scl = clst, ecl = clst, resion[2];
(0934) #endif
(0935) 
(0936) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    0082E E042      LDI	R20,2
    0082F E050      LDI	R21,0
    00830 E060      LDI	R22,0
    00831 E070      LDI	R23,0
    00832 882A      LDD	R2,Y+18
    00833 883B      LDD	R3,Y+19
    00834 884C      LDD	R4,Y+20
    00835 885D      LDD	R5,Y+21
    00836 1624      CP	R2,R20
    00837 0635      CPC	R3,R21
    00838 0646      CPC	R4,R22
    00839 0657      CPC	R5,R23
    0083A F078      BCS	0x084A
    0083B 01F6      MOVW	R30,R12
    0083C 9676      ADIW	R30,0x16
    0083D 8020      LD	R2,Z
    0083E 8031      LDD	R3,Z+1
    0083F 8042      LDD	R4,Z+2
    00840 8053      LDD	R5,Z+3
    00841 886A      LDD	R6,Y+18
    00842 887B      LDD	R7,Y+19
    00843 888C      LDD	R8,Y+20
    00844 889D      LDD	R9,Y+21
    00845 1462      CP	R6,R2
    00846 0473      CPC	R7,R3
    00847 0484      CPC	R8,R4
    00848 0495      CPC	R9,R5
    00849 F018      BCS	0x084D
(0937) 		res = FR_INT_ERR;
    0084A E082      LDI	R24,2
    0084B 2EA8      MOV	R10,R24
(0938) 
(0939) 	} else {
    0084C C088      RJMP	0x08D5
(0940) 		res = FR_OK;
    0084D 24AA      CLR	R10
    0084E C076      RJMP	0x08C5
(0941) 		while (clst < fs->n_fatent) {			/* Not a last link? */
(0942) 			nxt = get_fat(fs, clst);			/* Get cluster status */
    0084F 882A      LDD	R2,Y+18
    00850 883B      LDD	R3,Y+19
    00851 884C      LDD	R4,Y+20
    00852 885D      LDD	R5,Y+21
    00853 8248      ST	Y,R4
    00854 8259      STD	Y+1,R5
    00855 0191      MOVW	R18,R2
    00856 0186      MOVW	R16,R12
    00857 DCC1      RCALL	_get_fat
    00858 830E      STD	Y+6,R16
    00859 831F      STD	Y+7,R17
    0085A 8728      STD	Y+8,R18
    0085B 8739      STD	Y+9,R19
(0943) 			if (nxt == 0) break;				/* Empty cluster? */
    0085C 802E      LDD	R2,Y+6
    0085D 803F      LDD	R3,Y+7
    0085E 8448      LDD	R4,Y+8
    0085F 8459      LDD	R5,Y+9
    00860 9488      BCLR	0
    00861 2022      TST	R2
    00862 0432      CPC	R3,R2
    00863 0442      CPC	R4,R2
    00864 0452      CPC	R5,R2
    00865 F409      BNE	0x0867
    00866 C06E      RJMP	0x08D5
(0944) 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    00867 E041      LDI	R20,1
    00868 E050      LDI	R21,0
    00869 E060      LDI	R22,0
    0086A E070      LDI	R23,0
    0086B 802E      LDD	R2,Y+6
    0086C 803F      LDD	R3,Y+7
    0086D 8448      LDD	R4,Y+8
    0086E 8459      LDD	R5,Y+9
    0086F 1624      CP	R2,R20
    00870 0635      CPC	R3,R21
    00871 0646      CPC	R4,R22
    00872 0657      CPC	R5,R23
    00873 F419      BNE	0x0877
    00874 E082      LDI	R24,2
    00875 2EA8      MOV	R10,R24
    00876 C05E      RJMP	0x08D5
(0945) 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    00877 EF4F      LDI	R20,0xFF
    00878 EF5F      LDI	R21,0xFF
    00879 EF6F      LDI	R22,0xFF
    0087A EF7F      LDI	R23,0xFF
    0087B 802E      LDD	R2,Y+6
    0087C 803F      LDD	R3,Y+7
    0087D 8448      LDD	R4,Y+8
    0087E 8459      LDD	R5,Y+9
    0087F 1624      CP	R2,R20
    00880 0635      CPC	R3,R21
    00881 0646      CPC	R4,R22
    00882 0657      CPC	R5,R23
    00883 F419      BNE	0x0887
    00884 24AA      CLR	R10
    00885 94A3      INC	R10
    00886 C04E      RJMP	0x08D5
(0946) 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    00887 E080      LDI	R24,0
    00888 838A      STD	Y+2,R24
    00889 838B      STD	Y+3,R24
    0088A 838C      STD	Y+4,R24
    0088B 838D      STD	Y+5,R24
    0088C 882A      LDD	R2,Y+18
    0088D 883B      LDD	R3,Y+19
    0088E 884C      LDD	R4,Y+20
    0088F 885D      LDD	R5,Y+21
    00890 8248      ST	Y,R4
    00891 8259      STD	Y+1,R5
    00892 0191      MOVW	R18,R2
    00893 0186      MOVW	R16,R12
    00894 DDD4      RCALL	_put_fat
    00895 2EA0      MOV	R10,R16
(0947) 			if (res != FR_OK) break;
    00896 2300      TST	R16
    00897 F009      BEQ	0x0899
    00898 C03C      RJMP	0x08D5
(0948) 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    00899 EF4F      LDI	R20,0xFF
    0089A EF5F      LDI	R21,0xFF
    0089B EF6F      LDI	R22,0xFF
    0089C EF7F      LDI	R23,0xFF
    0089D 01F6      MOVW	R30,R12
    0089E 8426      LDD	R2,Z+14
    0089F 8437      LDD	R3,Z+15
    008A0 8840      LDD	R4,Z+16
    008A1 8851      LDD	R5,Z+17
    008A2 1624      CP	R2,R20
    008A3 0635      CPC	R3,R21
    008A4 0646      CPC	R4,R22
    008A5 0657      CPC	R5,R23
    008A6 F0B1      BEQ	0x08BD
(0949) 				fs->free_clust++;
    008A7 01CF      MOVW	R24,R30
    008A8 960E      ADIW	R24,0xE
    008A9 E041      LDI	R20,1
    008AA E050      LDI	R21,0
    008AB E060      LDI	R22,0
    008AC E070      LDI	R23,0
    008AD 01FC      MOVW	R30,R24
    008AE 8020      LD	R2,Z
    008AF 8031      LDD	R3,Z+1
    008B0 8042      LDD	R4,Z+2
    008B1 8053      LDD	R5,Z+3
    008B2 0E24      ADD	R2,R20
    008B3 1E35      ADC	R3,R21
    008B4 1E46      ADC	R4,R22
    008B5 1E57      ADC	R5,R23
    008B6 8220      ST	Z,R2
    008B7 8231      STD	Z+1,R3
    008B8 8242      STD	Z+2,R4
    008B9 8253      STD	Z+3,R5
(0950) 				fs->fsi_flag = 1;
    008BA E081      LDI	R24,1
    008BB 01F6      MOVW	R30,R12
    008BC 8385      STD	Z+5,R24
(0951) 			}
(0952) #if _USE_ERASE
(0953) 			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
(0954) 				ecl = nxt;
(0955) 			} else {				/* End of contiguous clusters */ 
(0956) 				resion[0] = clust2sect(fs, scl);					/* Start sector */
(0957) 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
(0958) 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
(0959) 				scl = ecl = nxt;
(0960) 			}
(0961) #endif
(0962) 			clst = nxt;	/* Next cluster */
    008BD 802E      LDD	R2,Y+6
    008BE 803F      LDD	R3,Y+7
    008BF 8448      LDD	R4,Y+8
    008C0 8459      LDD	R5,Y+9
    008C1 8A2A      STD	Y+18,R2
    008C2 8A3B      STD	Y+19,R3
    008C3 8A4C      STD	Y+20,R4
    008C4 8A5D      STD	Y+21,R5
    008C5 01F6      MOVW	R30,R12
    008C6 9676      ADIW	R30,0x16
    008C7 8020      LD	R2,Z
    008C8 8031      LDD	R3,Z+1
    008C9 8042      LDD	R4,Z+2
    008CA 8053      LDD	R5,Z+3
    008CB 886A      LDD	R6,Y+18
    008CC 887B      LDD	R7,Y+19
    008CD 888C      LDD	R8,Y+20
    008CE 889D      LDD	R9,Y+21
    008CF 1462      CP	R6,R2
    008D0 0473      CPC	R7,R3
    008D1 0484      CPC	R8,R4
    008D2 0495      CPC	R9,R5
    008D3 F408      BCC	0x08D5
    008D4 CF7A      RJMP	0x084F
(0963) 		}
(0964) 	}
(0965) 
(0966) 	return res;
    008D5 2D0A      MOV	R16,R10
    008D6 962A      ADIW	R28,0xA
    008D7 940E 41AF CALL	pop_xgsetF03C
    008D9 9622      ADIW	R28,2
    008DA 9508      RET
ff.c:create_chain:
  res                  --> R10
  scl                  --> Y,+14
  cs                   --> Y,+10
  ncl                  --> Y,+6
  clst                 --> Y,+32
  fs                   --> R12
    008DB 933A      ST	-Y,R19
    008DC 932A      ST	-Y,R18
    008DD 940E 416B CALL	push_xgsetF0FC
    008DF 0168      MOVW	R12,R16
    008E0 9766      SBIW	R28,0x16
(0967) }
(0968) #endif
(0969) 
(0970) 
(0971) 
(0972) 
(0973) /*-----------------------------------------------------------------------*/
(0974) /* FAT handling - Stretch or Create a cluster chain                      */
(0975) /*-----------------------------------------------------------------------*/
(0976) #if !_FS_READONLY
(0977) static
(0978) DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
(0979) 	FATFS *fs,			/* File system object */
(0980) 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
(0981) )
(0982) {
(0983) 	DWORD cs, ncl, scl;
(0984) 	FRESULT res;
(0985) 
(0986) 
(0987) 	if (clst == 0) {		/* Create a new chain */
    008E1 A028      LDD	R2,Y+32
    008E2 A039      LDD	R3,Y+33
    008E3 A04A      LDD	R4,Y+34
    008E4 A05B      LDD	R5,Y+35
    008E5 9488      BCLR	0
    008E6 2022      TST	R2
    008E7 0432      CPC	R3,R2
    008E8 0442      CPC	R4,R2
    008E9 0452      CPC	R5,R2
    008EA F559      BNE	0x0916
(0988) 		scl = fs->last_clust;			/* Get suggested start point */
    008EB 01F6      MOVW	R30,R12
    008EC 963A      ADIW	R30,0xA
    008ED 8020      LD	R2,Z
    008EE 8031      LDD	R3,Z+1
    008EF 8042      LDD	R4,Z+2
    008F0 8053      LDD	R5,Z+3
    008F1 862E      STD	Y+14,R2
    008F2 863F      STD	Y+15,R3
    008F3 8A48      STD	Y+16,R4
    008F4 8A59      STD	Y+17,R5
(0989) 		if (!scl || scl >= fs->n_fatent) scl = 1;
    008F5 842E      LDD	R2,Y+14
    008F6 843F      LDD	R3,Y+15
    008F7 8848      LDD	R4,Y+16
    008F8 8859      LDD	R5,Y+17
    008F9 9488      BCLR	0
    008FA 2022      TST	R2
    008FB 0432      CPC	R3,R2
    008FC 0442      CPC	R4,R2
    008FD 0452      CPC	R5,R2
    008FE F081      BEQ	0x090F
    008FF 01F6      MOVW	R30,R12
    00900 9676      ADIW	R30,0x16
    00901 8020      LD	R2,Z
    00902 8031      LDD	R3,Z+1
    00903 8042      LDD	R4,Z+2
    00904 8053      LDD	R5,Z+3
    00905 846E      LDD	R6,Y+14
    00906 847F      LDD	R7,Y+15
    00907 8888      LDD	R8,Y+16
    00908 8899      LDD	R9,Y+17
    00909 1462      CP	R6,R2
    0090A 0473      CPC	R7,R3
    0090B 0484      CPC	R8,R4
    0090C 0495      CPC	R9,R5
    0090D F408      BCC	0x090F
    0090E C040      RJMP	0x094F
    0090F E081      LDI	R24,1
    00910 878E      STD	Y+14,R24
    00911 E080      LDI	R24,0
    00912 878F      STD	Y+15,R24
    00913 8B88      STD	Y+16,R24
    00914 8B89      STD	Y+17,R24
(0990) 	}
    00915 C039      RJMP	0x094F
(0991) 	else {					/* Stretch the current chain */
(0992) 		cs = get_fat(fs, clst);			/* Check the cluster status */
    00916 A028      LDD	R2,Y+32
    00917 A039      LDD	R3,Y+33
    00918 A04A      LDD	R4,Y+34
    00919 A05B      LDD	R5,Y+35
    0091A 8248      ST	Y,R4
    0091B 8259      STD	Y+1,R5
    0091C 0191      MOVW	R18,R2
    0091D 0186      MOVW	R16,R12
    0091E DBFA      RCALL	_get_fat
    0091F 870A      STD	Y+10,R16
    00920 871B      STD	Y+11,R17
    00921 872C      STD	Y+12,R18
    00922 873D      STD	Y+13,R19
(0993) 		if (cs < 2) return 1;			/* It is an invalid cluster */
    00923 E042      LDI	R20,2
    00924 E050      LDI	R21,0
    00925 E060      LDI	R22,0
    00926 E070      LDI	R23,0
    00927 842A      LDD	R2,Y+10
    00928 843B      LDD	R3,Y+11
    00929 844C      LDD	R4,Y+12
    0092A 845D      LDD	R5,Y+13
    0092B 1624      CP	R2,R20
    0092C 0635      CPC	R3,R21
    0092D 0646      CPC	R4,R22
    0092E 0657      CPC	R5,R23
    0092F F428      BCC	0x0935
    00930 E001      LDI	R16,1
    00931 E010      LDI	R17,0
    00932 E020      LDI	R18,0
    00933 E030      LDI	R19,0
    00934 C119      RJMP	0x0A4E
(0994) 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    00935 01F6      MOVW	R30,R12
    00936 9676      ADIW	R30,0x16
    00937 8020      LD	R2,Z
    00938 8031      LDD	R3,Z+1
    00939 8042      LDD	R4,Z+2
    0093A 8053      LDD	R5,Z+3
    0093B 846A      LDD	R6,Y+10
    0093C 847B      LDD	R7,Y+11
    0093D 848C      LDD	R8,Y+12
    0093E 849D      LDD	R9,Y+13
    0093F 1462      CP	R6,R2
    00940 0473      CPC	R7,R3
    00941 0484      CPC	R8,R4
    00942 0495      CPC	R9,R5
    00943 F418      BCC	0x0947
    00944 0183      MOVW	R16,R6
    00945 0194      MOVW	R18,R8
    00946 C107      RJMP	0x0A4E
(0995) 		scl = clst;
    00947 A028      LDD	R2,Y+32
    00948 A039      LDD	R3,Y+33
    00949 A04A      LDD	R4,Y+34
    0094A A05B      LDD	R5,Y+35
    0094B 862E      STD	Y+14,R2
    0094C 863F      STD	Y+15,R3
    0094D 8A48      STD	Y+16,R4
    0094E 8A59      STD	Y+17,R5
(0996) 	}
(0997) 
(0998) 	ncl = scl;				/* Start cluster */
    0094F 842E      LDD	R2,Y+14
    00950 843F      LDD	R3,Y+15
    00951 8848      LDD	R4,Y+16
    00952 8859      LDD	R5,Y+17
    00953 822E      STD	Y+6,R2
    00954 823F      STD	Y+7,R3
    00955 8648      STD	Y+8,R4
    00956 8659      STD	Y+9,R5
(0999) 	for (;;) {
(1000) 		ncl++;							/* Next cluster */
    00957 E041      LDI	R20,1
    00958 E050      LDI	R21,0
    00959 E060      LDI	R22,0
    0095A E070      LDI	R23,0
    0095B 802E      LDD	R2,Y+6
    0095C 803F      LDD	R3,Y+7
    0095D 8448      LDD	R4,Y+8
    0095E 8459      LDD	R5,Y+9
    0095F 0E24      ADD	R2,R20
    00960 1E35      ADC	R3,R21
    00961 1E46      ADC	R4,R22
    00962 1E57      ADC	R5,R23
    00963 822E      STD	Y+6,R2
    00964 823F      STD	Y+7,R3
    00965 8648      STD	Y+8,R4
    00966 8659      STD	Y+9,R5
(1001) 		if (ncl >= fs->n_fatent) {		/* Wrap around */
    00967 01F6      MOVW	R30,R12
    00968 9676      ADIW	R30,0x16
    00969 8020      LD	R2,Z
    0096A 8031      LDD	R3,Z+1
    0096B 8042      LDD	R4,Z+2
    0096C 8053      LDD	R5,Z+3
    0096D 806E      LDD	R6,Y+6
    0096E 807F      LDD	R7,Y+7
    0096F 8488      LDD	R8,Y+8
    00970 8499      LDD	R9,Y+9
    00971 1462      CP	R6,R2
    00972 0473      CPC	R7,R3
    00973 0484      CPC	R8,R4
    00974 0495      CPC	R9,R5
    00975 F0C0      BCS	0x098E
(1002) 			ncl = 2;
    00976 E082      LDI	R24,2
    00977 838E      STD	Y+6,R24
    00978 E080      LDI	R24,0
    00979 838F      STD	Y+7,R24
    0097A 8788      STD	Y+8,R24
    0097B 8789      STD	Y+9,R24
(1003) 			if (ncl > scl) return 0;	/* No free cluster */
    0097C 842E      LDD	R2,Y+14
    0097D 843F      LDD	R3,Y+15
    0097E 8848      LDD	R4,Y+16
    0097F 8859      LDD	R5,Y+17
    00980 806E      LDD	R6,Y+6
    00981 807F      LDD	R7,Y+7
    00982 8488      LDD	R8,Y+8
    00983 8499      LDD	R9,Y+9
    00984 1426      CP	R2,R6
    00985 0437      CPC	R3,R7
    00986 0448      CPC	R4,R8
    00987 0459      CPC	R5,R9
    00988 F428      BCC	0x098E
    00989 E000      LDI	R16,0
    0098A E010      LDI	R17,0
    0098B E020      LDI	R18,0
    0098C E030      LDI	R19,0
    0098D C0C0      RJMP	0x0A4E
(1004) 		}
(1005) 		cs = get_fat(fs, ncl);			/* Get the cluster status */
    0098E 802E      LDD	R2,Y+6
    0098F 803F      LDD	R3,Y+7
    00990 8448      LDD	R4,Y+8
    00991 8459      LDD	R5,Y+9
    00992 8248      ST	Y,R4
    00993 8259      STD	Y+1,R5
    00994 0191      MOVW	R18,R2
    00995 0186      MOVW	R16,R12
    00996 DB82      RCALL	_get_fat
    00997 870A      STD	Y+10,R16
    00998 871B      STD	Y+11,R17
    00999 872C      STD	Y+12,R18
    0099A 873D      STD	Y+13,R19
(1006) 		if (cs == 0) break;				/* Found a free cluster */
    0099B 842A      LDD	R2,Y+10
    0099C 843B      LDD	R3,Y+11
    0099D 844C      LDD	R4,Y+12
    0099E 845D      LDD	R5,Y+13
    0099F 9488      BCLR	0
    009A0 2022      TST	R2
    009A1 0432      CPC	R3,R2
    009A2 0442      CPC	R4,R2
    009A3 0452      CPC	R5,R2
    009A4 F409      BNE	0x09A6
    009A5 C02E      RJMP	0x09D4
(1007) 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    009A6 EF4F      LDI	R20,0xFF
    009A7 EF5F      LDI	R21,0xFF
    009A8 EF6F      LDI	R22,0xFF
    009A9 EF7F      LDI	R23,0xFF
    009AA 842A      LDD	R2,Y+10
    009AB 843B      LDD	R3,Y+11
    009AC 844C      LDD	R4,Y+12
    009AD 845D      LDD	R5,Y+13
    009AE 1624      CP	R2,R20
    009AF 0635      CPC	R3,R21
    009B0 0646      CPC	R4,R22
    009B1 0657      CPC	R5,R23
    009B2 F049      BEQ	0x09BC
    009B3 E041      LDI	R20,1
    009B4 E050      LDI	R21,0
    009B5 E060      LDI	R22,0
    009B6 E070      LDI	R23,0
    009B7 1624      CP	R2,R20
    009B8 0635      CPC	R3,R21
    009B9 0646      CPC	R4,R22
    009BA 0657      CPC	R5,R23
    009BB F429      BNE	0x09C1
(1008) 			return cs;
    009BC 850A      LDD	R16,Y+10
    009BD 851B      LDD	R17,Y+11
    009BE 852C      LDD	R18,Y+12
    009BF 853D      LDD	R19,Y+13
    009C0 C08D      RJMP	0x0A4E
(1009) 		if (ncl == scl) return 0;		/* No free cluster */
    009C1 842E      LDD	R2,Y+14
    009C2 843F      LDD	R3,Y+15
    009C3 8848      LDD	R4,Y+16
    009C4 8859      LDD	R5,Y+17
    009C5 806E      LDD	R6,Y+6
    009C6 807F      LDD	R7,Y+7
    009C7 8488      LDD	R8,Y+8
    009C8 8499      LDD	R9,Y+9
    009C9 1462      CP	R6,R2
    009CA 0473      CPC	R7,R3
    009CB 0484      CPC	R8,R4
    009CC 0495      CPC	R9,R5
    009CD F009      BEQ	0x09CF
    009CE CF88      RJMP	0x0957
    009CF E000      LDI	R16,0
    009D0 E010      LDI	R17,0
    009D1 E020      LDI	R18,0
    009D2 E030      LDI	R19,0
    009D3 C07A      RJMP	0x0A4E
(1010) 	}
(1011) 
(1012) 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    009D4 EF8F      LDI	R24,0xFF
    009D5 838A      STD	Y+2,R24
    009D6 838B      STD	Y+3,R24
    009D7 838C      STD	Y+4,R24
    009D8 E08F      LDI	R24,0xF
    009D9 838D      STD	Y+5,R24
    009DA 802E      LDD	R2,Y+6
    009DB 803F      LDD	R3,Y+7
    009DC 8448      LDD	R4,Y+8
    009DD 8459      LDD	R5,Y+9
    009DE 8248      ST	Y,R4
    009DF 8259      STD	Y+1,R5
    009E0 0191      MOVW	R18,R2
    009E1 0186      MOVW	R16,R12
    009E2 DC86      RCALL	_put_fat
    009E3 2EA0      MOV	R10,R16
(1013) 	if (res == FR_OK && clst != 0) {
    009E4 2300      TST	R16
    009E5 F4E1      BNE	0x0A02
    009E6 A028      LDD	R2,Y+32
    009E7 A039      LDD	R3,Y+33
    009E8 A04A      LDD	R4,Y+34
    009E9 A05B      LDD	R5,Y+35
    009EA 9488      BCLR	0
    009EB 2022      TST	R2
    009EC 0432      CPC	R3,R2
    009ED 0442      CPC	R4,R2
    009EE 0452      CPC	R5,R2
    009EF F091      BEQ	0x0A02
(1014) 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    009F0 802E      LDD	R2,Y+6
    009F1 803F      LDD	R3,Y+7
    009F2 8448      LDD	R4,Y+8
    009F3 8459      LDD	R5,Y+9
    009F4 822A      STD	Y+2,R2
    009F5 823B      STD	Y+3,R3
    009F6 824C      STD	Y+4,R4
    009F7 825D      STD	Y+5,R5
    009F8 A028      LDD	R2,Y+32
    009F9 A039      LDD	R3,Y+33
    009FA A04A      LDD	R4,Y+34
    009FB A05B      LDD	R5,Y+35
    009FC 8248      ST	Y,R4
    009FD 8259      STD	Y+1,R5
    009FE 0191      MOVW	R18,R2
    009FF 0186      MOVW	R16,R12
    00A00 DC68      RCALL	_put_fat
    00A01 2EA0      MOV	R10,R16
(1015) 	}
(1016) 	if (res == FR_OK) {
    00A02 20AA      TST	R10
    00A03 F009      BEQ	0x0A05
    00A04 C02E      RJMP	0x0A33
(1017) 		fs->last_clust = ncl;			/* Update FSINFO */
    00A05 802E      LDD	R2,Y+6
    00A06 803F      LDD	R3,Y+7
    00A07 8448      LDD	R4,Y+8
    00A08 8459      LDD	R5,Y+9
    00A09 01F6      MOVW	R30,R12
    00A0A 8622      STD	Z+10,R2
    00A0B 8633      STD	Z+11,R3
    00A0C 8644      STD	Z+12,R4
    00A0D 8655      STD	Z+13,R5
(1018) 		if (fs->free_clust != 0xFFFFFFFF) {
    00A0E EF4F      LDI	R20,0xFF
    00A0F EF5F      LDI	R21,0xFF
    00A10 EF6F      LDI	R22,0xFF
    00A11 EF7F      LDI	R23,0xFF
    00A12 8426      LDD	R2,Z+14
    00A13 8437      LDD	R3,Z+15
    00A14 8840      LDD	R4,Z+16
    00A15 8851      LDD	R5,Z+17
    00A16 1624      CP	R2,R20
    00A17 0635      CPC	R3,R21
    00A18 0646      CPC	R4,R22
    00A19 0657      CPC	R5,R23
    00A1A F179      BEQ	0x0A4A
(1019) 			fs->free_clust--;
    00A1B 01CF      MOVW	R24,R30
    00A1C 960E      ADIW	R24,0xE
    00A1D 017C      MOVW	R14,R24
    00A1E E041      LDI	R20,1
    00A1F E050      LDI	R21,0
    00A20 E060      LDI	R22,0
    00A21 E070      LDI	R23,0
    00A22 01FC      MOVW	R30,R24
    00A23 8020      LD	R2,Z
    00A24 8031      LDD	R3,Z+1
    00A25 8042      LDD	R4,Z+2
    00A26 8053      LDD	R5,Z+3
    00A27 1A24      SUB	R2,R20
    00A28 0A35      SBC	R3,R21
    00A29 0A46      SBC	R4,R22
    00A2A 0A57      SBC	R5,R23
    00A2B 8220      ST	Z,R2
    00A2C 8231      STD	Z+1,R3
    00A2D 8242      STD	Z+2,R4
    00A2E 8253      STD	Z+3,R5
(1020) 			fs->fsi_flag = 1;
    00A2F E081      LDI	R24,1
    00A30 01F6      MOVW	R30,R12
    00A31 8385      STD	Z+5,R24
(1021) 		}
(1022) 	} else {
    00A32 C017      RJMP	0x0A4A
(1023) 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    00A33 2D8A      MOV	R24,R10
    00A34 3081      CPI	R24,1
    00A35 F431      BNE	0x0A3C
    00A36 EF8F      LDI	R24,0xFF
    00A37 8B8A      STD	Y+18,R24
    00A38 8B8B      STD	Y+19,R24
    00A39 8B8C      STD	Y+20,R24
    00A3A 8B8D      STD	Y+21,R24
    00A3B C006      RJMP	0x0A42
    00A3C E081      LDI	R24,1
    00A3D 8B8A      STD	Y+18,R24
    00A3E E080      LDI	R24,0
    00A3F 8B8B      STD	Y+19,R24
    00A40 8B8C      STD	Y+20,R24
    00A41 8B8D      STD	Y+21,R24
    00A42 882A      LDD	R2,Y+18
    00A43 883B      LDD	R3,Y+19
    00A44 884C      LDD	R4,Y+20
    00A45 885D      LDD	R5,Y+21
    00A46 822E      STD	Y+6,R2
    00A47 823F      STD	Y+7,R3
    00A48 8648      STD	Y+8,R4
    00A49 8659      STD	Y+9,R5
(1024) 	}
(1025) 
(1026) 	return ncl;		/* Return new cluster number or error code */
    00A4A 810E      LDD	R16,Y+6
    00A4B 811F      LDD	R17,Y+7
    00A4C 8528      LDD	R18,Y+8
    00A4D 8539      LDD	R19,Y+9
    00A4E 9666      ADIW	R28,0x16
    00A4F 940E 4160 CALL	pop_xgsetF0FC
    00A51 9622      ADIW	R28,2
    00A52 9508      RET
ff.c:clmt_clust:
  tbl                  --> R10
  cl                   --> Y,+4
  ncl                  --> Y,+0
  ofs                  --> Y,+12
  fp                   --> R12
    00A53 933A      ST	-Y,R19
    00A54 932A      ST	-Y,R18
    00A55 940E 4171 CALL	push_xgset003C
    00A57 0168      MOVW	R12,R16
    00A58 9728      SBIW	R28,0x8
(1027) }
(1028) #endif /* !_FS_READONLY */
(1029) 
(1030) 
(1031) 
(1032) /*-----------------------------------------------------------------------*/
(1033) /* FAT handling - Convert offset into cluster with link map table        */
(1034) /*-----------------------------------------------------------------------*/
(1035) 
(1036) #if _USE_FASTSEEK
(1037) static
(1038) DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
(1039) 	FIL* fp,		/* Pointer to the file object */
(1040) 	DWORD ofs		/* File offset to be converted to cluster# */
(1041) )
(1042) {
(1043) 	DWORD cl, ncl, *tbl;
(1044) 
(1045) 
(1046) 	tbl = fp->cltbl + 1;	/* Top of CLMT */
    00A59 01F6      MOVW	R30,R12
    00A5A 96B0      ADIW	R30,0x20
    00A5B 8180      LD	R24,Z
    00A5C 8191      LDD	R25,Z+1
    00A5D 9604      ADIW	R24,4
    00A5E 015C      MOVW	R10,R24
(1047) 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
    00A5F E089      LDI	R24,0x9
    00A60 E090      LDI	R25,0
    00A61 850C      LDD	R16,Y+12
    00A62 851D      LDD	R17,Y+13
    00A63 852E      LDD	R18,Y+14
    00A64 853F      LDD	R19,Y+15
    00A65 938A      ST	-Y,R24
    00A66 940E 4206 CALL	lsr32
    00A68 01F6      MOVW	R30,R12
    00A69 93AF      PUSH	R26
    00A6A 93BF      PUSH	R27
    00A6B 81A0      LD	R26,Z
    00A6C 81B1      LDD	R27,Z+1
    00A6D 01FD      MOVW	R30,R26
    00A6E 91BF      POP	R27
    00A6F 91AF      POP	R26
    00A70 9632      ADIW	R30,2
    00A71 8020      LD	R2,Z
    00A72 2433      CLR	R3
    00A73 2444      CLR	R4
    00A74 2455      CLR	R5
    00A75 925A      ST	-Y,R5
    00A76 924A      ST	-Y,R4
    00A77 923A      ST	-Y,R3
    00A78 922A      ST	-Y,R2
    00A79 940E 4071 CALL	div32u
    00A7B 830C      STD	Y+4,R16
    00A7C 831D      STD	Y+5,R17
    00A7D 832E      STD	Y+6,R18
    00A7E 833F      STD	Y+7,R19
(1048) 	for (;;) {
(1049) 		ncl = *tbl++;			/* Number of cluters in the fragment */
    00A7F 01F5      MOVW	R30,R10
    00A80 9021      LD	R2,Z+
    00A81 9031      LD	R3,Z+
    00A82 9041      LD	R4,Z+
    00A83 9051      LD	R5,Z+
    00A84 015F      MOVW	R10,R30
    00A85 8228      ST	Y,R2
    00A86 8239      STD	Y+1,R3
    00A87 824A      STD	Y+2,R4
    00A88 825B      STD	Y+3,R5
(1050) 		if (!ncl) return 0;		/* End of table? (error) */
    00A89 8028      LD	R2,Y
    00A8A 8039      LDD	R3,Y+1
    00A8B 804A      LDD	R4,Y+2
    00A8C 805B      LDD	R5,Y+3
    00A8D 9488      BCLR	0
    00A8E 2022      TST	R2
    00A8F 0432      CPC	R3,R2
    00A90 0442      CPC	R4,R2
    00A91 0452      CPC	R5,R2
    00A92 F429      BNE	0x0A98
    00A93 E000      LDI	R16,0
    00A94 E010      LDI	R17,0
    00A95 E020      LDI	R18,0
    00A96 E030      LDI	R19,0
    00A97 C02F      RJMP	0x0AC7
(1051) 		if (cl < ncl) break;	/* In this fragment? */
    00A98 8028      LD	R2,Y
    00A99 8039      LDD	R3,Y+1
    00A9A 804A      LDD	R4,Y+2
    00A9B 805B      LDD	R5,Y+3
    00A9C 806C      LDD	R6,Y+4
    00A9D 807D      LDD	R7,Y+5
    00A9E 808E      LDD	R8,Y+6
    00A9F 809F      LDD	R9,Y+7
    00AA0 1462      CP	R6,R2
    00AA1 0473      CPC	R7,R3
    00AA2 0484      CPC	R8,R4
    00AA3 0495      CPC	R9,R5
    00AA4 F408      BCC	0x0AA6
    00AA5 C014      RJMP	0x0ABA
(1052) 		cl -= ncl; tbl++;		/* Next fragment */
    00AA6 8028      LD	R2,Y
    00AA7 8039      LDD	R3,Y+1
    00AA8 804A      LDD	R4,Y+2
    00AA9 805B      LDD	R5,Y+3
    00AAA 806C      LDD	R6,Y+4
    00AAB 807D      LDD	R7,Y+5
    00AAC 808E      LDD	R8,Y+6
    00AAD 809F      LDD	R9,Y+7
    00AAE 1862      SUB	R6,R2
    00AAF 0873      SBC	R7,R3
    00AB0 0884      SBC	R8,R4
    00AB1 0895      SBC	R9,R5
    00AB2 826C      STD	Y+4,R6
    00AB3 827D      STD	Y+5,R7
    00AB4 828E      STD	Y+6,R8
    00AB5 829F      STD	Y+7,R9
    00AB6 01C5      MOVW	R24,R10
    00AB7 9604      ADIW	R24,4
    00AB8 015C      MOVW	R10,R24
    00AB9 CFC5      RJMP	0x0A7F
(1053) 	}
(1054) 	return cl + *tbl;	/* Return the cluster number */
    00ABA 01F5      MOVW	R30,R10
    00ABB 8020      LD	R2,Z
    00ABC 8031      LDD	R3,Z+1
    00ABD 8042      LDD	R4,Z+2
    00ABE 8053      LDD	R5,Z+3
    00ABF 810C      LDD	R16,Y+4
    00AC0 811D      LDD	R17,Y+5
    00AC1 812E      LDD	R18,Y+6
    00AC2 813F      LDD	R19,Y+7
    00AC3 0D02      ADD	R16,R2
    00AC4 1D13      ADC	R17,R3
    00AC5 1D24      ADC	R18,R4
    00AC6 1D35      ADC	R19,R5
    00AC7 9628      ADIW	R28,0x8
    00AC8 940E 414B CALL	pop_xgset003C
    00ACA 9622      ADIW	R28,2
    00ACB 9508      RET
ff.c:dir_sdi:
  ic                   --> R14
  clst                 --> Y,+2
  idx                  --> R12
  dj                   --> R10
    00ACC 940E 416B CALL	push_xgsetF0FC
    00ACE 0169      MOVW	R12,R18
    00ACF 0158      MOVW	R10,R16
    00AD0 9726      SBIW	R28,6
(1055) }
(1056) #endif	/* _USE_FASTSEEK */
(1057) 
(1058) 
(1059) 
(1060) /*-----------------------------------------------------------------------*/
(1061) /* Directory handling - Set directory index                              */
(1062) /*-----------------------------------------------------------------------*/
(1063) 
(1064) static
(1065) FRESULT dir_sdi (
(1066) 	DIR *dj,		/* Pointer to directory object */
(1067) 	WORD idx		/* Directory index number */
(1068) )
(1069) {
(1070) 	DWORD clst;
(1071) 	WORD ic;
(1072) 
(1073) 
(1074) 	dj->index = idx;
    00AD1 01F5      MOVW	R30,R10
    00AD2 82D5      STD	Z+5,R13
    00AD3 82C4      STD	Z+4,R12
(1075) 	clst = dj->sclust;
    00AD4 9636      ADIW	R30,6
    00AD5 8020      LD	R2,Z
    00AD6 8031      LDD	R3,Z+1
    00AD7 8042      LDD	R4,Z+2
    00AD8 8053      LDD	R5,Z+3
    00AD9 822A      STD	Y+2,R2
    00ADA 823B      STD	Y+3,R3
    00ADB 824C      STD	Y+4,R4
    00ADC 825D      STD	Y+5,R5
(1076) 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    00ADD E041      LDI	R20,1
    00ADE E050      LDI	R21,0
    00ADF E060      LDI	R22,0
    00AE0 E070      LDI	R23,0
    00AE1 802A      LDD	R2,Y+2
    00AE2 803B      LDD	R3,Y+3
    00AE3 804C      LDD	R4,Y+4
    00AE4 805D      LDD	R5,Y+5
    00AE5 1624      CP	R2,R20
    00AE6 0635      CPC	R3,R21
    00AE7 0646      CPC	R4,R22
    00AE8 0657      CPC	R5,R23
    00AE9 F089      BEQ	0x0AFB
    00AEA 01F5      MOVW	R30,R10
    00AEB 81A0      LD	R26,Z
    00AEC 81B1      LDD	R27,Z+1
    00AED 9656      ADIW	R26,0x16
    00AEE 902D      LD	R2,X+
    00AEF 903D      LD	R3,X+
    00AF0 904D      LD	R4,X+
    00AF1 905C      LD	R5,X
    00AF2 806A      LDD	R6,Y+2
    00AF3 807B      LDD	R7,Y+3
    00AF4 808C      LDD	R8,Y+4
    00AF5 809D      LDD	R9,Y+5
    00AF6 1462      CP	R6,R2
    00AF7 0473      CPC	R7,R3
    00AF8 0484      CPC	R8,R4
    00AF9 0495      CPC	R9,R5
    00AFA F010      BCS	0x0AFD
(1077) 		return FR_INT_ERR;
    00AFB E002      LDI	R16,2
    00AFC C0D6      RJMP	0x0BD3
(1078) 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    00AFD 802A      LDD	R2,Y+2
    00AFE 803B      LDD	R3,Y+3
    00AFF 804C      LDD	R4,Y+4
    00B00 805D      LDD	R5,Y+5
    00B01 9488      BCLR	0
    00B02 2022      TST	R2
    00B03 0432      CPC	R3,R2
    00B04 0442      CPC	R4,R2
    00B05 0452      CPC	R5,R2
    00B06 F479      BNE	0x0B16
    00B07 01F5      MOVW	R30,R10
    00B08 81A0      LD	R26,Z
    00B09 81B1      LDD	R27,Z+1
    00B0A 918C      LD	R24,X
    00B0B 3083      CPI	R24,3
    00B0C F449      BNE	0x0B16
(1079) 		clst = dj->fs->dirbase;
    00B0D 9692      ADIW	R26,0x22
    00B0E 902D      LD	R2,X+
    00B0F 903D      LD	R3,X+
    00B10 904D      LD	R4,X+
    00B11 905C      LD	R5,X
    00B12 822A      STD	Y+2,R2
    00B13 823B      STD	Y+3,R3
    00B14 824C      STD	Y+4,R4
    00B15 825D      STD	Y+5,R5
(1080) 
(1081) 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    00B16 802A      LDD	R2,Y+2
    00B17 803B      LDD	R3,Y+3
    00B18 804C      LDD	R4,Y+4
    00B19 805D      LDD	R5,Y+5
    00B1A 9488      BCLR	0
    00B1B 2022      TST	R2
    00B1C 0432      CPC	R3,R2
    00B1D 0442      CPC	R4,R2
    00B1E 0452      CPC	R5,R2
    00B1F F009      BEQ	0x0B21
    00B20 C02B      RJMP	0x0B4C
(1082) 		dj->clust = clst;
    00B21 01F5      MOVW	R30,R10
    00B22 8622      STD	Z+10,R2
    00B23 8633      STD	Z+11,R3
    00B24 8644      STD	Z+12,R4
    00B25 8655      STD	Z+13,R5
(1083) 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    00B26 81A0      LD	R26,Z
    00B27 81B1      LDD	R27,Z+1
    00B28 9618      ADIW	R26,0x8
    00B29 902D      LD	R2,X+
    00B2A 903C      LD	R3,X
    00B2B 14C2      CP	R12,R2
    00B2C 04D3      CPC	R13,R3
    00B2D F010      BCS	0x0B30
(1084) 			return FR_INT_ERR;
    00B2E E002      LDI	R16,2
    00B2F C0A3      RJMP	0x0BD3
(1085) 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B30 0116      MOVW	R2,R12
    00B31 9436      LSR	R3
    00B32 9427      ROR	R2
    00B33 9436      LSR	R3
    00B34 9427      ROR	R2
    00B35 9436      LSR	R3
    00B36 9427      ROR	R2
    00B37 9436      LSR	R3
    00B38 9427      ROR	R2
    00B39 2444      CLR	R4
    00B3A 2455      CLR	R5
    00B3B 01F5      MOVW	R30,R10
    00B3C 81A0      LD	R26,Z
    00B3D 81B1      LDD	R27,Z+1
    00B3E 9692      ADIW	R26,0x22
    00B3F 906D      LD	R6,X+
    00B40 907D      LD	R7,X+
    00B41 908D      LD	R8,X+
    00B42 909C      LD	R9,X
    00B43 0C62      ADD	R6,R2
    00B44 1C73      ADC	R7,R3
    00B45 1C84      ADC	R8,R4
    00B46 1C95      ADC	R9,R5
    00B47 8666      STD	Z+14,R6
    00B48 8677      STD	Z+15,R7
    00B49 8A80      STD	Z+16,R8
    00B4A 8A91      STD	Z+17,R9
(1086) 	}
    00B4B C076      RJMP	0x0BC2
(1087) 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
(1088) 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    00B4C 01F5      MOVW	R30,R10
    00B4D 93AF      PUSH	R26
    00B4E 93BF      PUSH	R27
    00B4F 81A0      LD	R26,Z
    00B50 81B1      LDD	R27,Z+1
    00B51 01FD      MOVW	R30,R26
    00B52 91BF      POP	R27
    00B53 91AF      POP	R26
    00B54 8022      LDD	R2,Z+2
    00B55 E180      LDI	R24,0x10
    00B56 9D82      MUL	R24,R2
    00B57 0170      MOVW	R14,R0
    00B58 C040      RJMP	0x0B99
(1089) 		while (idx >= ic) {	/* Follow cluster chain */
(1090) 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    00B59 802A      LDD	R2,Y+2
    00B5A 803B      LDD	R3,Y+3
    00B5B 804C      LDD	R4,Y+4
    00B5C 805D      LDD	R5,Y+5
    00B5D 8248      ST	Y,R4
    00B5E 8259      STD	Y+1,R5
    00B5F 0191      MOVW	R18,R2
    00B60 01F5      MOVW	R30,R10
    00B61 8100      LD	R16,Z
    00B62 8111      LDD	R17,Z+1
    00B63 D9B5      RCALL	_get_fat
    00B64 830A      STD	Y+2,R16
    00B65 831B      STD	Y+3,R17
    00B66 832C      STD	Y+4,R18
    00B67 833D      STD	Y+5,R19
(1091) 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    00B68 EF4F      LDI	R20,0xFF
    00B69 EF5F      LDI	R21,0xFF
    00B6A EF6F      LDI	R22,0xFF
    00B6B EF7F      LDI	R23,0xFF
    00B6C 802A      LDD	R2,Y+2
    00B6D 803B      LDD	R3,Y+3
    00B6E 804C      LDD	R4,Y+4
    00B6F 805D      LDD	R5,Y+5
    00B70 1624      CP	R2,R20
    00B71 0635      CPC	R3,R21
    00B72 0646      CPC	R4,R22
    00B73 0657      CPC	R5,R23
    00B74 F411      BNE	0x0B77
    00B75 E001      LDI	R16,1
    00B76 C05C      RJMP	0x0BD3
(1092) 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    00B77 E042      LDI	R20,2
    00B78 E050      LDI	R21,0
    00B79 E060      LDI	R22,0
    00B7A E070      LDI	R23,0
    00B7B 802A      LDD	R2,Y+2
    00B7C 803B      LDD	R3,Y+3
    00B7D 804C      LDD	R4,Y+4
    00B7E 805D      LDD	R5,Y+5
    00B7F 1624      CP	R2,R20
    00B80 0635      CPC	R3,R21
    00B81 0646      CPC	R4,R22
    00B82 0657      CPC	R5,R23
    00B83 F088      BCS	0x0B95
    00B84 01F5      MOVW	R30,R10
    00B85 81A0      LD	R26,Z
    00B86 81B1      LDD	R27,Z+1
    00B87 9656      ADIW	R26,0x16
    00B88 902D      LD	R2,X+
    00B89 903D      LD	R3,X+
    00B8A 904D      LD	R4,X+
    00B8B 905C      LD	R5,X
    00B8C 806A      LDD	R6,Y+2
    00B8D 807B      LDD	R7,Y+3
    00B8E 808C      LDD	R8,Y+4
    00B8F 809D      LDD	R9,Y+5
    00B90 1462      CP	R6,R2
    00B91 0473      CPC	R7,R3
    00B92 0484      CPC	R8,R4
    00B93 0495      CPC	R9,R5
    00B94 F010      BCS	0x0B97
(1093) 				return FR_INT_ERR;
    00B95 E002      LDI	R16,2
    00B96 C03C      RJMP	0x0BD3
(1094) 			idx -= ic;
    00B97 18CE      SUB	R12,R14
    00B98 08DF      SBC	R13,R15
    00B99 14CE      CP	R12,R14
    00B9A 04DF      CPC	R13,R15
    00B9B F008      BCS	0x0B9D
    00B9C CFBC      RJMP	0x0B59
(1095) 		}
(1096) 		dj->clust = clst;
    00B9D 802A      LDD	R2,Y+2
    00B9E 803B      LDD	R3,Y+3
    00B9F 804C      LDD	R4,Y+4
    00BA0 805D      LDD	R5,Y+5
    00BA1 01F5      MOVW	R30,R10
    00BA2 8622      STD	Z+10,R2
    00BA3 8633      STD	Z+11,R3
    00BA4 8644      STD	Z+12,R4
    00BA5 8655      STD	Z+13,R5
(1097) 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00BA6 8248      ST	Y,R4
    00BA7 8259      STD	Y+1,R5
    00BA8 0191      MOVW	R18,R2
    00BA9 8100      LD	R16,Z
    00BAA 8111      LDD	R17,Z+1
    00BAB D91B      RCALL	_clust2sect
    00BAC 0116      MOVW	R2,R12
    00BAD 9436      LSR	R3
    00BAE 9427      ROR	R2
    00BAF 9436      LSR	R3
    00BB0 9427      ROR	R2
    00BB1 9436      LSR	R3
    00BB2 9427      ROR	R2
    00BB3 9436      LSR	R3
    00BB4 9427      ROR	R2
    00BB5 2444      CLR	R4
    00BB6 2455      CLR	R5
    00BB7 0138      MOVW	R6,R16
    00BB8 0149      MOVW	R8,R18
    00BB9 0C62      ADD	R6,R2
    00BBA 1C73      ADC	R7,R3
    00BBB 1C84      ADC	R8,R4
    00BBC 1C95      ADC	R9,R5
    00BBD 01F5      MOVW	R30,R10
    00BBE 8666      STD	Z+14,R6
    00BBF 8677      STD	Z+15,R7
    00BC0 8A80      STD	Z+16,R8
    00BC1 8A91      STD	Z+17,R9
(1098) 	}
(1099) 
(1100) 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    00BC2 0196      MOVW	R18,R12
    00BC3 702F      ANDI	R18,0xF
    00BC4 7030      ANDI	R19,0
    00BC5 E200      LDI	R16,0x20
    00BC6 E010      LDI	R17,0
    00BC7 940E 4107 CALL	empy16s
    00BC9 0118      MOVW	R2,R16
    00BCA 01F5      MOVW	R30,R10
    00BCB 8180      LD	R24,Z
    00BCC 8191      LDD	R25,Z+1
    00BCD 968E      ADIW	R24,0x2E
    00BCE 0E28      ADD	R2,R24
    00BCF 1E39      ADC	R3,R25
    00BD0 8A33      STD	Z+19,R3
    00BD1 8A22      STD	Z+18,R2
(1101) 
(1102) 	return FR_OK;	/* Seek succeeded */
    00BD2 2700      CLR	R16
    00BD3 9626      ADIW	R28,6
    00BD4 940C 4160 JMP	pop_xgsetF0FC
ff.c:dir_next:
  c                    --> R10
  clst                 --> Y,+2
  i                    --> R12
  stretch              --> R10
  dj                   --> Y,+16
    00BD6 940E 4026 CALL	push_arg4
    00BD8 940E 416B CALL	push_xgsetF0FC
    00BDA 0159      MOVW	R10,R18
    00BDB 9726      SBIW	R28,6
(1103) }
(1104) 
(1105) 
(1106) 
(1107) 
(1108) /*-----------------------------------------------------------------------*/
(1109) /* Directory handling - Move directory index next                        */
(1110) /*-----------------------------------------------------------------------*/
(1111) 
(1112) static
(1113) FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
(1114) 	DIR *dj,		/* Pointer to directory object */
(1115) 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
(1116) )
(1117) {
(1118) 	DWORD clst;
(1119) 	WORD i;
(1120) 
(1121) 
(1122) 	stretch = stretch;		/* To suppress warning on read-only cfg. */
(1123) 	i = dj->index + 1;
    00BDC 89E8      LDD	R30,Y+16
    00BDD 89F9      LDD	R31,Y+17
    00BDE 8184      LDD	R24,Z+4
    00BDF 8195      LDD	R25,Z+5
    00BE0 9601      ADIW	R24,1
    00BE1 016C      MOVW	R12,R24
(1124) 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    00BE2 3080      CPI	R24,0
    00BE3 0789      CPC	R24,R25
    00BE4 F059      BEQ	0x0BF0
    00BE5 963E      ADIW	R30,0xE
    00BE6 8020      LD	R2,Z
    00BE7 8031      LDD	R3,Z+1
    00BE8 8042      LDD	R4,Z+2
    00BE9 8053      LDD	R5,Z+3
    00BEA 9488      BCLR	0
    00BEB 2022      TST	R2
    00BEC 0432      CPC	R3,R2
    00BED 0442      CPC	R4,R2
    00BEE 0452      CPC	R5,R2
    00BEF F411      BNE	0x0BF2
(1125) 		return FR_NO_FILE;
    00BF0 E004      LDI	R16,4
    00BF1 C18D      RJMP	0x0D7F
(1126) 
(1127) 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    00BF2 01C6      MOVW	R24,R12
    00BF3 708F      ANDI	R24,0xF
    00BF4 7090      ANDI	R25,0
    00BF5 3080      CPI	R24,0
    00BF6 0789      CPC	R24,R25
    00BF7 F009      BEQ	0x0BF9
    00BF8 C170      RJMP	0x0D69
(1128) 		dj->sect++;					/* Next sector */
    00BF9 8988      LDD	R24,Y+16
    00BFA 8999      LDD	R25,Y+17
    00BFB 960E      ADIW	R24,0xE
    00BFC E041      LDI	R20,1
    00BFD E050      LDI	R21,0
    00BFE E060      LDI	R22,0
    00BFF E070      LDI	R23,0
    00C00 01FC      MOVW	R30,R24
    00C01 8020      LD	R2,Z
    00C02 8031      LDD	R3,Z+1
    00C03 8042      LDD	R4,Z+2
    00C04 8053      LDD	R5,Z+3
    00C05 0E24      ADD	R2,R20
    00C06 1E35      ADC	R3,R21
    00C07 1E46      ADC	R4,R22
    00C08 1E57      ADC	R5,R23
    00C09 8220      ST	Z,R2
    00C0A 8231      STD	Z+1,R3
    00C0B 8242      STD	Z+2,R4
    00C0C 8253      STD	Z+3,R5
(1129) 
(1130) 		if (dj->clust == 0) {	/* Static table */
    00C0D 89E8      LDD	R30,Y+16
    00C0E 89F9      LDD	R31,Y+17
    00C0F 963A      ADIW	R30,0xA
    00C10 8020      LD	R2,Z
    00C11 8031      LDD	R3,Z+1
    00C12 8042      LDD	R4,Z+2
    00C13 8053      LDD	R5,Z+3
    00C14 9488      BCLR	0
    00C15 2022      TST	R2
    00C16 0432      CPC	R3,R2
    00C17 0442      CPC	R4,R2
    00C18 0452      CPC	R5,R2
    00C19 F469      BNE	0x0C27
(1131) 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    00C1A 89E8      LDD	R30,Y+16
    00C1B 89F9      LDD	R31,Y+17
    00C1C 81A0      LD	R26,Z
    00C1D 81B1      LDD	R27,Z+1
    00C1E 9618      ADIW	R26,0x8
    00C1F 902D      LD	R2,X+
    00C20 903C      LD	R3,X
    00C21 14C2      CP	R12,R2
    00C22 04D3      CPC	R13,R3
    00C23 F408      BCC	0x0C25
    00C24 C144      RJMP	0x0D69
(1132) 				return FR_NO_FILE;
    00C25 E004      LDI	R16,4
    00C26 C158      RJMP	0x0D7F
(1133) 		}
(1134) 		else {					/* Dynamic table */
(1135) 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    00C27 89E8      LDD	R30,Y+16
    00C28 89F9      LDD	R31,Y+17
    00C29 93AF      PUSH	R26
    00C2A 93BF      PUSH	R27
    00C2B 81A0      LD	R26,Z
    00C2C 81B1      LDD	R27,Z+1
    00C2D 01FD      MOVW	R30,R26
    00C2E 91BF      POP	R27
    00C2F 91AF      POP	R26
    00C30 8182      LDD	R24,Z+2
    00C31 2799      CLR	R25
    00C32 9701      SBIW	R24,1
    00C33 0116      MOVW	R2,R12
    00C34 9436      LSR	R3
    00C35 9427      ROR	R2
    00C36 9436      LSR	R3
    00C37 9427      ROR	R2
    00C38 9436      LSR	R3
    00C39 9427      ROR	R2
    00C3A 9436      LSR	R3
    00C3B 9427      ROR	R2
    00C3C 2228      AND	R2,R24
    00C3D 2239      AND	R3,R25
    00C3E 2022      TST	R2
    00C3F F009      BEQ	0x0C41
    00C40 C128      RJMP	0x0D69
    00C41 2033      TST	R3
    00C42 F009      BEQ	0x0C44
    00C43 C125      RJMP	0x0D69
(1136) 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    00C44 89E8      LDD	R30,Y+16
    00C45 89F9      LDD	R31,Y+17
    00C46 8422      LDD	R2,Z+10
    00C47 8433      LDD	R3,Z+11
    00C48 8444      LDD	R4,Z+12
    00C49 8455      LDD	R5,Z+13
    00C4A 8248      ST	Y,R4
    00C4B 8259      STD	Y+1,R5
    00C4C 0191      MOVW	R18,R2
    00C4D 8100      LD	R16,Z
    00C4E 8111      LDD	R17,Z+1
    00C4F D8C9      RCALL	_get_fat
    00C50 830A      STD	Y+2,R16
    00C51 831B      STD	Y+3,R17
    00C52 832C      STD	Y+4,R18
    00C53 833D      STD	Y+5,R19
(1137) 				if (clst <= 1) return FR_INT_ERR;
    00C54 E041      LDI	R20,1
    00C55 E050      LDI	R21,0
    00C56 E060      LDI	R22,0
    00C57 E070      LDI	R23,0
    00C58 802A      LDD	R2,Y+2
    00C59 803B      LDD	R3,Y+3
    00C5A 804C      LDD	R4,Y+4
    00C5B 805D      LDD	R5,Y+5
    00C5C 1542      CP	R20,R2
    00C5D 0553      CPC	R21,R3
    00C5E 0564      CPC	R22,R4
    00C5F 0575      CPC	R23,R5
    00C60 F010      BCS	0x0C63
    00C61 E002      LDI	R16,2
    00C62 C11C      RJMP	0x0D7F
(1138) 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C63 EF4F      LDI	R20,0xFF
    00C64 EF5F      LDI	R21,0xFF
    00C65 EF6F      LDI	R22,0xFF
    00C66 EF7F      LDI	R23,0xFF
    00C67 802A      LDD	R2,Y+2
    00C68 803B      LDD	R3,Y+3
    00C69 804C      LDD	R4,Y+4
    00C6A 805D      LDD	R5,Y+5
    00C6B 1624      CP	R2,R20
    00C6C 0635      CPC	R3,R21
    00C6D 0646      CPC	R4,R22
    00C6E 0657      CPC	R5,R23
    00C6F F411      BNE	0x0C72
    00C70 E001      LDI	R16,1
    00C71 C10D      RJMP	0x0D7F
(1139) 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    00C72 89E8      LDD	R30,Y+16
    00C73 89F9      LDD	R31,Y+17
    00C74 81A0      LD	R26,Z
    00C75 81B1      LDD	R27,Z+1
    00C76 9656      ADIW	R26,0x16
    00C77 902D      LD	R2,X+
    00C78 903D      LD	R3,X+
    00C79 904D      LD	R4,X+
    00C7A 905C      LD	R5,X
    00C7B 806A      LDD	R6,Y+2
    00C7C 807B      LDD	R7,Y+3
    00C7D 808C      LDD	R8,Y+4
    00C7E 809D      LDD	R9,Y+5
    00C7F 1462      CP	R6,R2
    00C80 0473      CPC	R7,R3
    00C81 0484      CPC	R8,R4
    00C82 0495      CPC	R9,R5
    00C83 F408      BCC	0x0C85
    00C84 C0CD      RJMP	0x0D52
(1140) #if !_FS_READONLY
(1141) 					BYTE c;
(1142) 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    00C85 20AA      TST	R10
    00C86 F421      BNE	0x0C8B
    00C87 20BB      TST	R11
    00C88 F411      BNE	0x0C8B
    00C89 E004      LDI	R16,4
    00C8A C0F4      RJMP	0x0D7F
(1143) 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    00C8B 89E8      LDD	R30,Y+16
    00C8C 89F9      LDD	R31,Y+17
    00C8D 8422      LDD	R2,Z+10
    00C8E 8433      LDD	R3,Z+11
    00C8F 8444      LDD	R4,Z+12
    00C90 8455      LDD	R5,Z+13
    00C91 8248      ST	Y,R4
    00C92 8259      STD	Y+1,R5
    00C93 0191      MOVW	R18,R2
    00C94 8100      LD	R16,Z
    00C95 8111      LDD	R17,Z+1
    00C96 DC44      RCALL	ff.c:create_chain
    00C97 830A      STD	Y+2,R16
    00C98 831B      STD	Y+3,R17
    00C99 832C      STD	Y+4,R18
    00C9A 833D      STD	Y+5,R19
(1144) 					if (clst == 0) return FR_DENIED;			/* No free cluster */
    00C9B 802A      LDD	R2,Y+2
    00C9C 803B      LDD	R3,Y+3
    00C9D 804C      LDD	R4,Y+4
    00C9E 805D      LDD	R5,Y+5
    00C9F 9488      BCLR	0
    00CA0 2022      TST	R2
    00CA1 0432      CPC	R3,R2
    00CA2 0442      CPC	R4,R2
    00CA3 0452      CPC	R5,R2
    00CA4 F411      BNE	0x0CA7
    00CA5 E007      LDI	R16,7
    00CA6 C0D8      RJMP	0x0D7F
(1145) 					if (clst == 1) return FR_INT_ERR;
    00CA7 E041      LDI	R20,1
    00CA8 E050      LDI	R21,0
    00CA9 E060      LDI	R22,0
    00CAA E070      LDI	R23,0
    00CAB 802A      LDD	R2,Y+2
    00CAC 803B      LDD	R3,Y+3
    00CAD 804C      LDD	R4,Y+4
    00CAE 805D      LDD	R5,Y+5
    00CAF 1624      CP	R2,R20
    00CB0 0635      CPC	R3,R21
    00CB1 0646      CPC	R4,R22
    00CB2 0657      CPC	R5,R23
    00CB3 F411      BNE	0x0CB6
    00CB4 E002      LDI	R16,2
    00CB5 C0C9      RJMP	0x0D7F
(1146) 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00CB6 EF4F      LDI	R20,0xFF
    00CB7 EF5F      LDI	R21,0xFF
    00CB8 EF6F      LDI	R22,0xFF
    00CB9 EF7F      LDI	R23,0xFF
    00CBA 802A      LDD	R2,Y+2
    00CBB 803B      LDD	R3,Y+3
    00CBC 804C      LDD	R4,Y+4
    00CBD 805D      LDD	R5,Y+5
    00CBE 1624      CP	R2,R20
    00CBF 0635      CPC	R3,R21
    00CC0 0646      CPC	R4,R22
    00CC1 0657      CPC	R5,R23
    00CC2 F411      BNE	0x0CC5
    00CC3 E001      LDI	R16,1
    00CC4 C0BA      RJMP	0x0D7F
(1147) 					/* Clean-up stretched table */
(1148) 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    00CC5 E040      LDI	R20,0
    00CC6 E050      LDI	R21,0
    00CC7 E060      LDI	R22,0
    00CC8 E070      LDI	R23,0
    00CC9 8368      ST	Y,R22
    00CCA 8379      STD	Y+1,R23
    00CCB 019A      MOVW	R18,R20
    00CCC 89E8      LDD	R30,Y+16
    00CCD 89F9      LDD	R31,Y+17
    00CCE 8100      LD	R16,Z
    00CCF 8111      LDD	R17,Z+1
    00CD0 940E 0350 CALL	ff.c:move_window
    00CD2 2300      TST	R16
    00CD3 F011      BEQ	0x0CD6
    00CD4 E001      LDI	R16,1
    00CD5 C0A9      RJMP	0x0D7F
(1149) 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    00CD6 E080      LDI	R24,0
    00CD7 E092      LDI	R25,2
    00CD8 8399      STD	Y+1,R25
    00CD9 8388      ST	Y,R24
    00CDA 2722      CLR	R18
    00CDB 2733      CLR	R19
    00CDC 89E8      LDD	R30,Y+16
    00CDD 89F9      LDD	R31,Y+17
    00CDE 8100      LD	R16,Z
    00CDF 8111      LDD	R17,Z+1
    00CE0 5D02      SUBI	R16,0xD2
    00CE1 4F1F      SBCI	R17,0xFF
    00CE2 940E 030D CALL	ff.c:mem_set
(1150) 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    00CE4 802A      LDD	R2,Y+2
    00CE5 803B      LDD	R3,Y+3
    00CE6 804C      LDD	R4,Y+4
    00CE7 805D      LDD	R5,Y+5
    00CE8 8248      ST	Y,R4
    00CE9 8259      STD	Y+1,R5
    00CEA 0191      MOVW	R18,R2
    00CEB 89E8      LDD	R30,Y+16
    00CEC 89F9      LDD	R31,Y+17
    00CED 80A0      LD	R10,Z
    00CEE 80B1      LDD	R11,Z+1
    00CEF 0185      MOVW	R16,R10
    00CF0 940E 04C7 CALL	_clust2sect
    00CF2 01F5      MOVW	R30,R10
    00CF3 A702      STD	Z+42,R16
    00CF4 A713      STD	Z+43,R17
    00CF5 A724      STD	Z+44,R18
    00CF6 A735      STD	Z+45,R19
(1151) 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    00CF7 24AA      CLR	R10
    00CF8 C035      RJMP	0x0D2E
(1152) 						dj->fs->wflag = 1;
    00CF9 E081      LDI	R24,1
    00CFA 89E8      LDD	R30,Y+16
    00CFB 89F9      LDD	R31,Y+17
    00CFC 93AF      PUSH	R26
    00CFD 93BF      PUSH	R27
    00CFE 81A0      LD	R26,Z
    00CFF 81B1      LDD	R27,Z+1
    00D00 01FD      MOVW	R30,R26
    00D01 91BF      POP	R27
    00D02 91AF      POP	R26
    00D03 8384      STD	Z+4,R24
(1153) 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    00D04 E040      LDI	R20,0
    00D05 E050      LDI	R21,0
    00D06 E060      LDI	R22,0
    00D07 E070      LDI	R23,0
    00D08 8368      ST	Y,R22
    00D09 8379      STD	Y+1,R23
    00D0A 019A      MOVW	R18,R20
    00D0B 89E8      LDD	R30,Y+16
    00D0C 89F9      LDD	R31,Y+17
    00D0D 8100      LD	R16,Z
    00D0E 8111      LDD	R17,Z+1
    00D0F 940E 0350 CALL	ff.c:move_window
    00D11 2EE0      MOV	R14,R16
    00D12 2300      TST	R16
    00D13 F011      BEQ	0x0D16
    00D14 E001      LDI	R16,1
    00D15 C069      RJMP	0x0D7F
(1154) 						dj->fs->winsect++;
    00D16 89E8      LDD	R30,Y+16
    00D17 89F9      LDD	R31,Y+17
    00D18 8180      LD	R24,Z
    00D19 8191      LDD	R25,Z+1
    00D1A 968A      ADIW	R24,0x2A
    00D1B 017C      MOVW	R14,R24
    00D1C E041      LDI	R20,1
    00D1D E050      LDI	R21,0
    00D1E E060      LDI	R22,0
    00D1F E070      LDI	R23,0
    00D20 01FC      MOVW	R30,R24
    00D21 8020      LD	R2,Z
    00D22 8031      LDD	R3,Z+1
    00D23 8042      LDD	R4,Z+2
    00D24 8053      LDD	R5,Z+3
    00D25 0E24      ADD	R2,R20
    00D26 1E35      ADC	R3,R21
    00D27 1E46      ADC	R4,R22
    00D28 1E57      ADC	R5,R23
    00D29 8220      ST	Z,R2
    00D2A 8231      STD	Z+1,R3
    00D2B 8242      STD	Z+2,R4
    00D2C 8253      STD	Z+3,R5
    00D2D 94A3      INC	R10
    00D2E 89E8      LDD	R30,Y+16
    00D2F 89F9      LDD	R31,Y+17
    00D30 93AF      PUSH	R26
    00D31 93BF      PUSH	R27
    00D32 81A0      LD	R26,Z
    00D33 81B1      LDD	R27,Z+1
    00D34 01FD      MOVW	R30,R26
    00D35 91BF      POP	R27
    00D36 91AF      POP	R26
    00D37 8022      LDD	R2,Z+2
    00D38 14A2      CP	R10,R2
    00D39 F408      BCC	0x0D3B
    00D3A CFBE      RJMP	0x0CF9
(1155) 					}
(1156) 					dj->fs->winsect -= c;						/* Rewind window address */
    00D3B 89E8      LDD	R30,Y+16
    00D3C 89F9      LDD	R31,Y+17
    00D3D 8180      LD	R24,Z
    00D3E 8191      LDD	R25,Z+1
    00D3F 968A      ADIW	R24,0x2A
    00D40 017C      MOVW	R14,R24
    00D41 2C2A      MOV	R2,R10
    00D42 2433      CLR	R3
    00D43 2444      CLR	R4
    00D44 2455      CLR	R5
    00D45 01FC      MOVW	R30,R24
    00D46 8060      LD	R6,Z
    00D47 8071      LDD	R7,Z+1
    00D48 8082      LDD	R8,Z+2
    00D49 8093      LDD	R9,Z+3
    00D4A 1862      SUB	R6,R2
    00D4B 0873      SBC	R7,R3
    00D4C 0884      SBC	R8,R4
    00D4D 0895      SBC	R9,R5
    00D4E 8260      ST	Z,R6
    00D4F 8271      STD	Z+1,R7
    00D50 8282      STD	Z+2,R8
    00D51 8293      STD	Z+3,R9
(1157) #else
(1158) 					return FR_NO_FILE;			/* Report EOT */
(1159) #endif
(1160) 				}
(1161) 				dj->clust = clst;				/* Initialize data for new cluster */
    00D52 802A      LDD	R2,Y+2
    00D53 803B      LDD	R3,Y+3
    00D54 804C      LDD	R4,Y+4
    00D55 805D      LDD	R5,Y+5
    00D56 89E8      LDD	R30,Y+16
    00D57 89F9      LDD	R31,Y+17
    00D58 8622      STD	Z+10,R2
    00D59 8633      STD	Z+11,R3
    00D5A 8644      STD	Z+12,R4
    00D5B 8655      STD	Z+13,R5
(1162) 				dj->sect = clust2sect(dj->fs, clst);
    00D5C 8248      ST	Y,R4
    00D5D 8259      STD	Y+1,R5
    00D5E 0191      MOVW	R18,R2
    00D5F 8100      LD	R16,Z
    00D60 8111      LDD	R17,Z+1
    00D61 940E 04C7 CALL	_clust2sect
    00D63 89E8      LDD	R30,Y+16
    00D64 89F9      LDD	R31,Y+17
    00D65 8706      STD	Z+14,R16
    00D66 8717      STD	Z+15,R17
    00D67 8B20      STD	Z+16,R18
    00D68 8B31      STD	Z+17,R19
(1163) 			}
(1164) 		}
(1165) 	}
(1166) 
(1167) 	dj->index = i;
    00D69 89E8      LDD	R30,Y+16
    00D6A 89F9      LDD	R31,Y+17
    00D6B 82D5      STD	Z+5,R13
    00D6C 82C4      STD	Z+4,R12
(1168) 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    00D6D 0196      MOVW	R18,R12
    00D6E 702F      ANDI	R18,0xF
    00D6F 7030      ANDI	R19,0
    00D70 E200      LDI	R16,0x20
    00D71 E010      LDI	R17,0
    00D72 940E 4107 CALL	empy16s
    00D74 0118      MOVW	R2,R16
    00D75 89E8      LDD	R30,Y+16
    00D76 89F9      LDD	R31,Y+17
    00D77 8180      LD	R24,Z
    00D78 8191      LDD	R25,Z+1
    00D79 968E      ADIW	R24,0x2E
    00D7A 0E28      ADD	R2,R24
    00D7B 1E39      ADC	R3,R25
    00D7C 8A33      STD	Z+19,R3
    00D7D 8A22      STD	Z+18,R2
(1169) 
(1170) 	return FR_OK;
    00D7E 2700      CLR	R16
    00D7F 9626      ADIW	R28,6
    00D80 940E 4160 CALL	pop_xgsetF0FC
    00D82 9624      ADIW	R28,4
    00D83 9508      RET
ff.c:dir_find:
  c                    --> R12
  dir                  --> R10
  res                  --> R20
  dj                   --> R22
    00D84 940E 41A6 CALL	push_xgsetF03C
    00D86 01B8      MOVW	R22,R16
    00D87 9722      SBIW	R28,2
(1171) }
(1172) 
(1173) 
(1174) 
(1175) 
(1176) /*-----------------------------------------------------------------------*/
(1177) /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
(1178) /*-----------------------------------------------------------------------*/
(1179) #if _USE_LFN
(1180) static
(1181) const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
(1182) 
(1183) 
(1184) static
(1185) int cmp_lfn (			/* 1:Matched, 0:Not matched */
(1186) 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
(1187) 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
(1188) )
(1189) {
(1190) 	UINT i, s;
(1191) 	WCHAR wc, uc;
(1192) 
(1193) 
(1194) 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
(1195) 	s = 0; wc = 1;
(1196) 	do {
(1197) 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
(1198) 		if (wc) {	/* Last char has not been processed */
(1199) 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
(1200) 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
(1201) 				return 0;				/* Not matched */
(1202) 		} else {
(1203) 			if (uc != 0xFFFF) return 0;	/* Check filler */
(1204) 		}
(1205) 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
(1206) 
(1207) 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
(1208) 		return 0;
(1209) 
(1210) 	return 1;						/* The part of LFN matched */
(1211) }
(1212) 
(1213) 
(1214) 
(1215) static
(1216) int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
(1217) 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
(1218) 	BYTE *dir			/* Pointer to the directory entry */
(1219) )
(1220) {
(1221) 	UINT i, s;
(1222) 	WCHAR wc, uc;
(1223) 
(1224) 
(1225) 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
(1226) 
(1227) 	s = 0; wc = 1;
(1228) 	do {
(1229) 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
(1230) 		if (wc) {	/* Last char has not been processed */
(1231) 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
(1232) 			lfnbuf[i++] = wc = uc;			/* Store it */
(1233) 		} else {
(1234) 			if (uc != 0xFFFF) return 0;		/* Check filler */
(1235) 		}
(1236) 	} while (++s < 13);						/* Read all character in the entry */
(1237) 
(1238) 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
(1239) 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
(1240) 		lfnbuf[i] = 0;
(1241) 	}
(1242) 
(1243) 	return 1;
(1244) }
(1245) 
(1246) 
(1247) #if !_FS_READONLY
(1248) static
(1249) void fit_lfn (
(1250) 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
(1251) 	BYTE *dir,				/* Pointer to the directory entry */
(1252) 	BYTE ord,				/* LFN order (1-20) */
(1253) 	BYTE sum				/* SFN sum */
(1254) )
(1255) {
(1256) 	UINT i, s;
(1257) 	WCHAR wc;
(1258) 
(1259) 
(1260) 	dir[LDIR_Chksum] = sum;			/* Set check sum */
(1261) 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
(1262) 	dir[LDIR_Type] = 0;
(1263) 	ST_WORD(dir+LDIR_FstClusLO, 0);
(1264) 
(1265) 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
(1266) 	s = wc = 0;
(1267) 	do {
(1268) 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
(1269) 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
(1270) 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
(1271) 	} while (++s < 13);
(1272) 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
(1273) 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
(1274) }
(1275) 
(1276) #endif
(1277) #endif
(1278) 
(1279) 
(1280) 
(1281) /*-----------------------------------------------------------------------*/
(1282) /* Create numbered name                                                  */
(1283) /*-----------------------------------------------------------------------*/
(1284) #if _USE_LFN
(1285) void gen_numname (
(1286) 	BYTE *dst,			/* Pointer to generated SFN */
(1287) 	const BYTE *src,	/* Pointer to source SFN to be modified */
(1288) 	const WCHAR *lfn,	/* Pointer to LFN */
(1289) 	WORD seq			/* Sequence number */
(1290) )
(1291) {
(1292) 	BYTE ns[8], c;
(1293) 	UINT i, j;
(1294) 
(1295) 
(1296) 	mem_cpy(dst, src, 11);
(1297) 
(1298) 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
(1299) 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
(1300) 	}
(1301) 
(1302) 	/* itoa (hexdecimal) */
(1303) 	i = 7;
(1304) 	do {
(1305) 		c = (seq % 16) + '0';
(1306) 		if (c > '9') c += 7;
(1307) 		ns[i--] = c;
(1308) 		seq /= 16;
(1309) 	} while (seq);
(1310) 	ns[i] = '~';
(1311) 
(1312) 	/* Append the number */
(1313) 	for (j = 0; j < i && dst[j] != ' '; j++) {
(1314) 		if (IsDBCS1(dst[j])) {
(1315) 			if (j == i - 1) break;
(1316) 			j++;
(1317) 		}
(1318) 	}
(1319) 	do {
(1320) 		dst[j++] = (i < 8) ? ns[i++] : ' ';
(1321) 	} while (j < 8);
(1322) }
(1323) #endif
(1324) 
(1325) 
(1326) 
(1327) 
(1328) /*-----------------------------------------------------------------------*/
(1329) /* Calculate sum of an SFN                                               */
(1330) /*-----------------------------------------------------------------------*/
(1331) #if _USE_LFN
(1332) static
(1333) BYTE sum_sfn (
(1334) 	const BYTE *dir		/* Ptr to directory entry */
(1335) )
(1336) {
(1337) 	BYTE sum = 0;
(1338) 	UINT n = 11;
(1339) 
(1340) 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
(1341) 	return sum;
(1342) }
(1343) #endif
(1344) 
(1345) 
(1346) 
(1347) 
(1348) /*-----------------------------------------------------------------------*/
(1349) /* Directory handling - Find an object in the directory                  */
(1350) /*-----------------------------------------------------------------------*/
(1351) 
(1352) static
(1353) FRESULT dir_find (
(1354) 	DIR *dj			/* Pointer to the directory object linked to the file name */
(1355) )
(1356) {
(1357) 	FRESULT res;
(1358) 	BYTE c, *dir;
(1359) #if _USE_LFN
(1360) 	BYTE a, ord, sum;
(1361) #endif
(1362) 
(1363) 	res = dir_sdi(dj, 0);			/* Rewind directory object */
    00D88 2722      CLR	R18
    00D89 2733      CLR	R19
    00D8A 018B      MOVW	R16,R22
    00D8B DD40      RCALL	ff.c:dir_sdi
    00D8C 2F40      MOV	R20,R16
(1364) 	if (res != FR_OK) return res;
    00D8D 2300      TST	R16
    00D8E F009      BEQ	0x0D90
    00D8F C036      RJMP	0x0DC6
(1365) 
(1366) #if _USE_LFN
(1367) 	ord = sum = 0xFF;
(1368) #endif
(1369) 	do {
(1370) 		res = move_window(dj->fs, dj->sect);
    00D90 01FB      MOVW	R30,R22
    00D91 8426      LDD	R2,Z+14
    00D92 8437      LDD	R3,Z+15
    00D93 8840      LDD	R4,Z+16
    00D94 8851      LDD	R5,Z+17
    00D95 8248      ST	Y,R4
    00D96 8259      STD	Y+1,R5
    00D97 0191      MOVW	R18,R2
    00D98 8100      LD	R16,Z
    00D99 8111      LDD	R17,Z+1
    00D9A 940E 0350 CALL	ff.c:move_window
    00D9C 2F40      MOV	R20,R16
(1371) 		if (res != FR_OK) break;
    00D9D 2300      TST	R16
    00D9E F009      BEQ	0x0DA0
    00D9F C025      RJMP	0x0DC5
(1372) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00DA0 01FB      MOVW	R30,R22
    00DA1 88A2      LDD	R10,Z+18
    00DA2 88B3      LDD	R11,Z+19
(1373) 		c = dir[DIR_Name];
    00DA3 01F5      MOVW	R30,R10
    00DA4 80C0      LD	R12,Z
(1374) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00DA5 20CC      TST	R12
    00DA6 F411      BNE	0x0DA9
    00DA7 E044      LDI	R20,4
    00DA8 C01C      RJMP	0x0DC5
(1375) #if _USE_LFN	/* LFN configuration */
(1376) 		a = dir[DIR_Attr] & AM_MASK;
(1377) 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1378) 			ord = 0xFF;
(1379) 		} else {
(1380) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1381) 				if (dj->lfn) {
(1382) 					if (c & LLE) {		/* Is it start of LFN sequence? */
(1383) 						sum = dir[LDIR_Chksum];
(1384) 						c &= ~LLE; ord = c;	/* LFN start order */
(1385) 						dj->lfn_idx = dj->index;
(1386) 					}
(1387) 					/* Check validity of the LFN entry and compare it with given name */
(1388) 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1389) 				}
(1390) 			} else {					/* An SFN entry is found */
(1391) 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
(1392) 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
(1393) 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
(1394) 			}
(1395) 		}
(1396) #else		/* Non LFN configuration */
(1397) 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    00DA9 01F5      MOVW	R30,R10
    00DAA 8423      LDD	R2,Z+11
    00DAB FC23      SBRC	R2,3
    00DAC C00F      RJMP	0x0DBC
    00DAD E08B      LDI	R24,0xB
    00DAE E090      LDI	R25,0
    00DAF 8399      STD	Y+1,R25
    00DB0 8388      ST	Y,R24
    00DB1 01FB      MOVW	R30,R22
    00DB2 8924      LDD	R18,Z+20
    00DB3 8935      LDD	R19,Z+21
    00DB4 0185      MOVW	R16,R10
    00DB5 940E 031F CALL	ff.c:mem_cmp
    00DB7 0158      MOVW	R10,R16
    00DB8 3000      CPI	R16,0
    00DB9 0701      CPC	R16,R17
    00DBA F409      BNE	0x0DBC
(1398) 			break;
    00DBB C009      RJMP	0x0DC5
(1399) #endif
(1400) 		res = dir_next(dj, 0);		/* Next entry */
    00DBC 2722      CLR	R18
    00DBD 2733      CLR	R19
    00DBE 018B      MOVW	R16,R22
    00DBF DE16      RCALL	ff.c:dir_next
    00DC0 2EA0      MOV	R10,R16
    00DC1 2D4A      MOV	R20,R10
(1401) 	} while (res == FR_OK);
    00DC2 2344      TST	R20
    00DC3 F409      BNE	0x0DC5
    00DC4 CFCB      RJMP	0x0D90
(1402) 
(1403) 	return res;
    00DC5 2F04      MOV	R16,R20
    00DC6 9622      ADIW	R28,2
    00DC7 940C 41AF JMP	pop_xgsetF03C
ff.c:dir_read:
  dir                  --> R10
  c                    --> R12
  res                  --> R20
  dj                   --> R22
    00DC9 940E 41A6 CALL	push_xgsetF03C
    00DCB 01B8      MOVW	R22,R16
    00DCC 9722      SBIW	R28,2
(1404) }
(1405) 
(1406) 
(1407) 
(1408) 
(1409) /*-----------------------------------------------------------------------*/
(1410) /* Read an object from the directory                                     */
(1411) /*-----------------------------------------------------------------------*/
(1412) #if _FS_MINIMIZE <= 1
(1413) static
(1414) FRESULT dir_read (
(1415) 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
(1416) )
(1417) {
(1418) 	FRESULT res;
(1419) 	BYTE c, *dir;
(1420) #if _USE_LFN
(1421) 	BYTE a, ord = 0xFF, sum = 0xFF;
(1422) #endif
(1423) 
(1424) 	res = FR_NO_FILE;
    00DCD E044      LDI	R20,4
    00DCE C02B      RJMP	0x0DFA
(1425) 	while (dj->sect) {
(1426) 		res = move_window(dj->fs, dj->sect);
    00DCF 01FB      MOVW	R30,R22
    00DD0 8426      LDD	R2,Z+14
    00DD1 8437      LDD	R3,Z+15
    00DD2 8840      LDD	R4,Z+16
    00DD3 8851      LDD	R5,Z+17
    00DD4 8248      ST	Y,R4
    00DD5 8259      STD	Y+1,R5
    00DD6 0191      MOVW	R18,R2
    00DD7 8100      LD	R16,Z
    00DD8 8111      LDD	R17,Z+1
    00DD9 940E 0350 CALL	ff.c:move_window
    00DDB 2F40      MOV	R20,R16
(1427) 		if (res != FR_OK) break;
    00DDC 2300      TST	R16
    00DDD F009      BEQ	0x0DDF
    00DDE C028      RJMP	0x0E07
(1428) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00DDF 01FB      MOVW	R30,R22
    00DE0 88A2      LDD	R10,Z+18
    00DE1 88B3      LDD	R11,Z+19
(1429) 		c = dir[DIR_Name];
    00DE2 01F5      MOVW	R30,R10
    00DE3 80C0      LD	R12,Z
(1430) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00DE4 20CC      TST	R12
    00DE5 F411      BNE	0x0DE8
    00DE6 E044      LDI	R20,4
    00DE7 C01F      RJMP	0x0E07
(1431) #if _USE_LFN	/* LFN configuration */
(1432) 		a = dir[DIR_Attr] & AM_MASK;
(1433) 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1434) 			ord = 0xFF;
(1435) 		} else {
(1436) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1437) 				if (c & LLE) {			/* Is it start of LFN sequence? */
(1438) 					sum = dir[LDIR_Chksum];
(1439) 					c &= ~LLE; ord = c;
(1440) 					dj->lfn_idx = dj->index;
(1441) 				}
(1442) 				/* Check LFN validity and capture it */
(1443) 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1444) 			} else {					/* An SFN entry is found */
(1445) 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
(1446) 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
(1447) 				break;
(1448) 			}
(1449) 		}
(1450) #else		/* Non LFN configuration */
(1451) 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    00DE8 2D8C      MOV	R24,R12
    00DE9 3E85      CPI	R24,0xE5
    00DEA F039      BEQ	0x0DF2
    00DEB 328E      CPI	R24,0x2E
    00DEC F029      BEQ	0x0DF2
    00DED 01F5      MOVW	R30,R10
    00DEE 8423      LDD	R2,Z+11
    00DEF FC23      SBRC	R2,3
    00DF0 C001      RJMP	0x0DF2
(1452) 			break;
    00DF1 C015      RJMP	0x0E07
(1453) #endif
(1454) 		res = dir_next(dj, 0);				/* Next entry */
    00DF2 2722      CLR	R18
    00DF3 2733      CLR	R19
    00DF4 018B      MOVW	R16,R22
    00DF5 DDE0      RCALL	ff.c:dir_next
    00DF6 2F40      MOV	R20,R16
(1455) 		if (res != FR_OK) break;
    00DF7 2300      TST	R16
    00DF8 F009      BEQ	0x0DFA
    00DF9 C00D      RJMP	0x0E07
    00DFA 01FB      MOVW	R30,R22
    00DFB 963E      ADIW	R30,0xE
    00DFC 8020      LD	R2,Z
    00DFD 8031      LDD	R3,Z+1
    00DFE 8042      LDD	R4,Z+2
    00DFF 8053      LDD	R5,Z+3
    00E00 9488      BCLR	0
    00E01 2022      TST	R2
    00E02 0432      CPC	R3,R2
    00E03 0442      CPC	R4,R2
    00E04 0452      CPC	R5,R2
    00E05 F009      BEQ	0x0E07
    00E06 CFC8      RJMP	0x0DCF
(1456) 	}
(1457) 
(1458) 	if (res != FR_OK) dj->sect = 0;
    00E07 2344      TST	R20
    00E08 F039      BEQ	0x0E10
    00E09 01FB      MOVW	R30,R22
    00E0A 963E      ADIW	R30,0xE
    00E0B E080      LDI	R24,0
    00E0C 8380      ST	Z,R24
    00E0D 8381      STD	Z+1,R24
    00E0E 8382      STD	Z+2,R24
    00E0F 8383      STD	Z+3,R24
(1459) 
(1460) 	return res;
    00E10 2F04      MOV	R16,R20
    00E11 9622      ADIW	R28,2
    00E12 940C 41AF JMP	pop_xgsetF03C
ff.c:dir_register:
  dir                  --> R12
  c                    --> R22
  res                  --> R10
  dj                   --> R20
    00E14 940E 41A6 CALL	push_xgsetF03C
    00E16 01A8      MOVW	R20,R16
    00E17 9722      SBIW	R28,2
(1461) }
(1462) #endif
(1463) 
(1464) 
(1465) 
(1466) /*-----------------------------------------------------------------------*/
(1467) /* Register an object to the directory                                   */
(1468) /*-----------------------------------------------------------------------*/
(1469) #if !_FS_READONLY
(1470) static
(1471) FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
(1472) 	DIR *dj				/* Target directory with object name to be created */
(1473) )
(1474) {
(1475) 	FRESULT res;
(1476) 	BYTE c, *dir;
(1477) #if _USE_LFN	/* LFN configuration */
(1478) 	WORD n, ne, is;
(1479) 	BYTE sn[12], *fn, sum;
(1480) 	WCHAR *lfn;
(1481) 
(1482) 
(1483) 	fn = dj->fn; lfn = dj->lfn;
(1484) 	mem_cpy(sn, fn, 12);
(1485) 
(1486) 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
(1487) 		return FR_INVALID_NAME;
(1488) 
(1489) 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
(1490) 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
(1491) 		for (n = 1; n < 100; n++) {
(1492) 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
(1493) 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
(1494) 			if (res != FR_OK) break;
(1495) 		}
(1496) 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
(1497) 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
(1498) 		fn[NS] = sn[NS]; dj->lfn = lfn;
(1499) 	}
(1500) 
(1501) 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
(1502) 		for (ne = 0; lfn[ne]; ne++) ;
(1503) 		ne = (ne + 25) / 13;
(1504) 	} else {						/* Otherwise reserve only an SFN entry. */
(1505) 		ne = 1;
(1506) 	}
(1507) 
(1508) 	/* Reserve contiguous entries */
(1509) 	res = dir_sdi(dj, 0);
(1510) 	if (res != FR_OK) return res;
(1511) 	n = is = 0;
(1512) 	do {
(1513) 		res = move_window(dj->fs, dj->sect);
(1514) 		if (res != FR_OK) break;
(1515) 		c = *dj->dir;				/* Check the entry status */
(1516) 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
(1517) 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
(1518) 			if (++n == ne) break;	/* A contiguous entry that required count is found */
(1519) 		} else {
(1520) 			n = 0;					/* Not a blank entry. Restart to search */
(1521) 		}
(1522) 		res = dir_next(dj, 1);		/* Next entry with table stretch */
(1523) 	} while (res == FR_OK);
(1524) 
(1525) 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
(1526) 		res = dir_sdi(dj, is);
(1527) 		if (res == FR_OK) {
(1528) 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
(1529) 			ne--;
(1530) 			do {					/* Store LFN entries in bottom first */
(1531) 				res = move_window(dj->fs, dj->sect);
(1532) 				if (res != FR_OK) break;
(1533) 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
(1534) 				dj->fs->wflag = 1;
(1535) 				res = dir_next(dj, 0);	/* Next entry */
(1536) 			} while (res == FR_OK && --ne);
(1537) 		}
(1538) 	}
(1539) 
(1540) #else	/* Non LFN configuration */
(1541) 	res = dir_sdi(dj, 0);
    00E18 2722      CLR	R18
    00E19 2733      CLR	R19
    00E1A 018A      MOVW	R16,R20
    00E1B DCB0      RCALL	ff.c:dir_sdi
    00E1C 2EA0      MOV	R10,R16
(1542) 	if (res == FR_OK) {
    00E1D 2300      TST	R16
    00E1E F509      BNE	0x0E40
(1543) 		do {	/* Find a blank entry for the SFN */
(1544) 			res = move_window(dj->fs, dj->sect);
    00E1F 01FA      MOVW	R30,R20
    00E20 8426      LDD	R2,Z+14
    00E21 8437      LDD	R3,Z+15
    00E22 8840      LDD	R4,Z+16
    00E23 8851      LDD	R5,Z+17
    00E24 8248      ST	Y,R4
    00E25 8259      STD	Y+1,R5
    00E26 0191      MOVW	R18,R2
    00E27 8100      LD	R16,Z
    00E28 8111      LDD	R17,Z+1
    00E29 940E 0350 CALL	ff.c:move_window
    00E2B 2EA0      MOV	R10,R16
(1545) 			if (res != FR_OK) break;
    00E2C 2300      TST	R16
    00E2D F009      BEQ	0x0E2F
    00E2E C011      RJMP	0x0E40
(1546) 			c = *dj->dir;
    00E2F 01FA      MOVW	R30,R20
    00E30 89A2      LDD	R26,Z+18
    00E31 89B3      LDD	R27,Z+19
    00E32 916C      LD	R22,X
(1547) 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    00E33 3E65      CPI	R22,0xE5
    00E34 F011      BEQ	0x0E37
    00E35 2366      TST	R22
    00E36 F409      BNE	0x0E38
    00E37 C008      RJMP	0x0E40
(1548) 			res = dir_next(dj, 1);			/* Next entry with table stretch */
    00E38 E021      LDI	R18,1
    00E39 E030      LDI	R19,0
    00E3A 018A      MOVW	R16,R20
    00E3B DD9A      RCALL	ff.c:dir_next
    00E3C 2EC0      MOV	R12,R16
    00E3D 2CAC      MOV	R10,R12
(1549) 		} while (res == FR_OK);
    00E3E 20AA      TST	R10
    00E3F F2F9      BEQ	0x0E1F
(1550) 	}
(1551) #endif
(1552) 
(1553) 	if (res == FR_OK) {		/* Initialize the SFN entry */
    00E40 20AA      TST	R10
    00E41 F009      BEQ	0x0E43
    00E42 C030      RJMP	0x0E73
(1554) 		res = move_window(dj->fs, dj->sect);
    00E43 01FA      MOVW	R30,R20
    00E44 8426      LDD	R2,Z+14
    00E45 8437      LDD	R3,Z+15
    00E46 8840      LDD	R4,Z+16
    00E47 8851      LDD	R5,Z+17
    00E48 8248      ST	Y,R4
    00E49 8259      STD	Y+1,R5
    00E4A 0191      MOVW	R18,R2
    00E4B 8100      LD	R16,Z
    00E4C 8111      LDD	R17,Z+1
    00E4D 940E 0350 CALL	ff.c:move_window
    00E4F 2EC0      MOV	R12,R16
    00E50 2CAC      MOV	R10,R12
(1555) 		if (res == FR_OK) {
    00E51 2300      TST	R16
    00E52 F501      BNE	0x0E73
(1556) 			dir = dj->dir;
    00E53 01FA      MOVW	R30,R20
    00E54 88C2      LDD	R12,Z+18
    00E55 88D3      LDD	R13,Z+19
(1557) 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    00E56 E280      LDI	R24,0x20
    00E57 E090      LDI	R25,0
    00E58 8399      STD	Y+1,R25
    00E59 8388      ST	Y,R24
    00E5A 2722      CLR	R18
    00E5B 2733      CLR	R19
    00E5C 0186      MOVW	R16,R12
    00E5D 940E 030D CALL	ff.c:mem_set
(1558) 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    00E5F E08B      LDI	R24,0xB
    00E60 E090      LDI	R25,0
    00E61 8399      STD	Y+1,R25
    00E62 8388      ST	Y,R24
    00E63 01FA      MOVW	R30,R20
    00E64 8924      LDD	R18,Z+20
    00E65 8935      LDD	R19,Z+21
    00E66 0186      MOVW	R16,R12
    00E67 940E 02F7 CALL	ff.c:mem_cpy
(1559) #if _USE_LFN
(1560) 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
(1561) #endif
(1562) 			dj->fs->wflag = 1;
    00E69 E081      LDI	R24,1
    00E6A 01FA      MOVW	R30,R20
    00E6B 93AF      PUSH	R26
    00E6C 93BF      PUSH	R27
    00E6D 81A0      LD	R26,Z
    00E6E 81B1      LDD	R27,Z+1
    00E6F 01FD      MOVW	R30,R26
    00E70 91BF      POP	R27
    00E71 91AF      POP	R26
    00E72 8384      STD	Z+4,R24
(1563) 		}
(1564) 	}
(1565) 
(1566) 	return res;
    00E73 2D0A      MOV	R16,R10
    00E74 9622      ADIW	R28,2
    00E75 940C 41AF JMP	pop_xgsetF03C
ff.c:create_name:
  si                   --> R22
  b                    --> Y,+8
  sfn                  --> Y,+6
  ni                   --> R12
  d                    --> R10
  i                    --> Y,+4
  p                    --> Y,+2
  c                    --> R20
  path                 --> Y,+19
  dj                   --> R20
    00E77 933A      ST	-Y,R19
    00E78 932A      ST	-Y,R18
    00E79 940E 416B CALL	push_xgsetF0FC
    00E7B 01A8      MOVW	R20,R16
    00E7C 9729      SBIW	R28,0x9
(1567) }
(1568) #endif /* !_FS_READONLY */
(1569) 
(1570) 
(1571) 
(1572) 
(1573) /*-----------------------------------------------------------------------*/
(1574) /* Remove an object from the directory                                   */
(1575) /*-----------------------------------------------------------------------*/
(1576) #if !_FS_READONLY && !_FS_MINIMIZE
(1577) static
(1578) FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
(1579) 	DIR *dj				/* Directory object pointing the entry to be removed */
(1580) )
(1581) {
(1582) 	FRESULT res;
(1583) #if _USE_LFN	/* LFN configuration */
(1584) 	WORD i;
(1585) 
(1586) 	i = dj->index;	/* SFN index */
(1587) 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
(1588) 	if (res == FR_OK) {
(1589) 		do {
(1590) 			res = move_window(dj->fs, dj->sect);
(1591) 			if (res != FR_OK) break;
(1592) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1593) 			dj->fs->wflag = 1;
(1594) 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
(1595) 			res = dir_next(dj, 0);		/* Next entry */
(1596) 		} while (res == FR_OK);
(1597) 		if (res == FR_NO_FILE) res = FR_INT_ERR;
(1598) 	}
(1599) 
(1600) #else			/* Non LFN configuration */
(1601) 	res = dir_sdi(dj, dj->index);
(1602) 	if (res == FR_OK) {
(1603) 		res = move_window(dj->fs, dj->sect);
(1604) 		if (res == FR_OK) {
(1605) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1606) 			dj->fs->wflag = 1;
(1607) 		}
(1608) 	}
(1609) #endif
(1610) 
(1611) 	return res;
(1612) }
(1613) #endif /* !_FS_READONLY */
(1614) 
(1615) 
(1616) 
(1617) 
(1618) /*-----------------------------------------------------------------------*/
(1619) /* Pick a segment and create the object name in directory form           */
(1620) /*-----------------------------------------------------------------------*/
(1621) 
(1622) static
(1623) FRESULT create_name (
(1624) 	DIR *dj,			/* Pointer to the directory object */
(1625) 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
(1626) )
(1627) {
(1628) #ifdef _EXCVT
(1629) 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
(1630) #endif
(1631) 
(1632) #if _USE_LFN	/* LFN configuration */
(1633) 	BYTE b, cf;
(1634) 	WCHAR w, *lfn;
(1635) 	UINT i, ni, si, di;
(1636) 	const TCHAR *p;
(1637) 
(1638) 	/* Create LFN in Unicode */
(1639) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
(1640) 	lfn = dj->lfn;
(1641) 	si = di = 0;
(1642) 	for (;;) {
(1643) 		w = p[si++];					/* Get a character */
(1644) 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
(1645) 		if (di >= _MAX_LFN)				/* Reject too long name */
(1646) 			return FR_INVALID_NAME;
(1647) #if !_LFN_UNICODE
(1648) 		w &= 0xFF;
(1649) 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
(1650) 			b = (BYTE)p[si++];			/* Get 2nd byte */
(1651) 			if (!IsDBCS2(b))
(1652) 				return FR_INVALID_NAME;	/* Reject invalid sequence */
(1653) 			w = (w << 8) + b;			/* Create a DBC */
(1654) 		}
(1655) 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
(1656) 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
(1657) #endif
(1658) 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
(1659) 			return FR_INVALID_NAME;
(1660) 		lfn[di++] = w;					/* Store the Unicode char */
(1661) 	}
(1662) 	*path = &p[si];						/* Return pointer to the next segment */
(1663) 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
(1664) #if _FS_RPATH
(1665) 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
(1666) 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
(1667) 		lfn[di] = 0;
(1668) 		for (i = 0; i < 11; i++)
(1669) 			dj->fn[i] = (i < di) ? '.' : ' ';
(1670) 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
(1671) 		return FR_OK;
(1672) 	}
(1673) #endif
(1674) 	while (di) {						/* Strip trailing spaces and dots */
(1675) 		w = lfn[di-1];
(1676) 		if (w != ' ' && w != '.') break;
(1677) 		di--;
(1678) 	}
(1679) 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
(1680) 
(1681) 	lfn[di] = 0;						/* LFN is created */
(1682) 
(1683) 	/* Create SFN in directory form */
(1684) 	mem_set(dj->fn, ' ', 11);
(1685) 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
(1686) 	if (si) cf |= NS_LOSS | NS_LFN;
(1687) 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
(1688) 
(1689) 	b = i = 0; ni = 8;
(1690) 	for (;;) {
(1691) 		w = lfn[si++];					/* Get an LFN char */
(1692) 		if (!w) break;					/* Break on end of the LFN */
(1693) 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
(1694) 			cf |= NS_LOSS | NS_LFN; continue;
(1695) 		}
(1696) 
(1697) 		if (i >= ni || si == di) {		/* Extension or end of SFN */
(1698) 			if (ni == 11) {				/* Long extension */
(1699) 				cf |= NS_LOSS | NS_LFN; break;
(1700) 			}
(1701) 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
(1702) 			if (si > di) break;			/* No extension */
(1703) 			si = di; i = 8; ni = 11;	/* Enter extension section */
(1704) 			b <<= 2; continue;
(1705) 		}
(1706) 
(1707) 		if (w >= 0x80) {				/* Non ASCII char */
(1708) #ifdef _EXCVT
(1709) 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
(1710) 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
(1711) #else
(1712) 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
(1713) #endif
(1714) 			cf |= NS_LFN;				/* Force create LFN entry */
(1715) 		}
(1716) 
(1717) 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
(1718) 			if (i >= ni - 1) {
(1719) 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
(1720) 			}
(1721) 			dj->fn[i++] = (BYTE)(w >> 8);
(1722) 		} else {						/* Single byte char */
(1723) 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
(1724) 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
(1725) 			} else {
(1726) 				if (IsUpper(w)) {		/* ASCII large capital */
(1727) 					b |= 2;
(1728) 				} else {
(1729) 					if (IsLower(w)) {	/* ASCII small capital */
(1730) 						b |= 1; w -= 0x20;
(1731) 					}
(1732) 				}
(1733) 			}
(1734) 		}
(1735) 		dj->fn[i++] = (BYTE)w;
(1736) 	}
(1737) 
(1738) 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
(1739) 
(1740) 	if (ni == 8) b <<= 2;
(1741) 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
(1742) 		cf |= NS_LFN;
(1743) 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
(1744) 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
(1745) 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
(1746) 	}
(1747) 
(1748) 	dj->fn[NS] = cf;	/* SFN is created */
(1749) 
(1750) 	return FR_OK;
(1751) 
(1752) 
(1753) #else	/* Non-LFN configuration */
(1754) 	BYTE b, c, d, *sfn;
(1755) 	UINT ni, si, i;
(1756) 	const char *p;
(1757) 
(1758) 	/* Create file name in directory form */
(1759) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    00E7D 89EB      LDD	R30,Y+19
    00E7E 89FC      LDD	R31,Y+20
    00E7F 8020      LD	R2,Z
    00E80 8031      LDD	R3,Z+1
    00E81 823B      STD	Y+3,R3
    00E82 822A      STD	Y+2,R2
    00E83 C005      RJMP	0x0E89
    00E84 818A      LDD	R24,Y+2
    00E85 819B      LDD	R25,Y+3
    00E86 9601      ADIW	R24,1
    00E87 839B      STD	Y+3,R25
    00E88 838A      STD	Y+2,R24
    00E89 81EA      LDD	R30,Y+2
    00E8A 81FB      LDD	R31,Y+3
    00E8B 8020      LD	R2,Z
    00E8C 2433      CLR	R3
    00E8D 2D82      MOV	R24,R2
    00E8E 328F      CPI	R24,0x2F
    00E8F F3A1      BEQ	0x0E84
    00E90 358C      CPI	R24,0x5C
    00E91 F391      BEQ	0x0E84
(1760) 	sfn = dj->fn;
    00E92 01FA      MOVW	R30,R20
    00E93 8824      LDD	R2,Z+20
    00E94 8835      LDD	R3,Z+21
    00E95 823F      STD	Y+7,R3
    00E96 822E      STD	Y+6,R2
(1761) 	mem_set(sfn, ' ', 11);
    00E97 E08B      LDI	R24,0xB
    00E98 E090      LDI	R25,0
    00E99 8399      STD	Y+1,R25
    00E9A 8388      ST	Y,R24
    00E9B E220      LDI	R18,0x20
    00E9C E030      LDI	R19,0
    00E9D 0181      MOVW	R16,R2
    00E9E 940E 030D CALL	ff.c:mem_set
(1762) 	si = i = b = 0; ni = 8;
    00EA0 2400      CLR	R0
    00EA1 8608      STD	Y+8,R0
    00EA2 2422      CLR	R2
    00EA3 2433      CLR	R3
    00EA4 823D      STD	Y+5,R3
    00EA5 822C      STD	Y+4,R2
    00EA6 01B1      MOVW	R22,R2
    00EA7 E088      LDI	R24,0x8
    00EA8 E090      LDI	R25,0
    00EA9 016C      MOVW	R12,R24
(1763) #if _FS_RPATH
(1764) 	if (p[si] == '.') { /* Is this a dot entry? */
(1765) 		for (;;) {
(1766) 			c = (BYTE)p[si++];
(1767) 			if (c != '.' || si >= 3) break;
(1768) 			sfn[i++] = c;
(1769) 		}
(1770) 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
(1771) 		*path = &p[si];									/* Return pointer to the next segment */
(1772) 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
(1773) 		return FR_OK;
(1774) 	}
(1775) #endif
(1776) 	for (;;) {
(1777) 		c = (BYTE)p[si++];
    00EAA 01AB      MOVW	R20,R22
    00EAB 5F6F      SUBI	R22,0xFF
    00EAC 4F7F      SBCI	R23,0xFF
    00EAD 01FA      MOVW	R30,R20
    00EAE 800A      LDD	R0,Y+2
    00EAF 801B      LDD	R1,Y+3
    00EB0 0DE0      ADD	R30,R0
    00EB1 1DF1      ADC	R31,R1
    00EB2 8140      LD	R20,Z
(1778) 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    00EB3 E280      LDI	R24,0x20
    00EB4 1784      CP	R24,R20
    00EB5 F420      BCC	0x0EBA
    00EB6 324F      CPI	R20,0x2F
    00EB7 F011      BEQ	0x0EBA
    00EB8 354C      CPI	R20,0x5C
    00EB9 F409      BNE	0x0EBB
    00EBA C087      RJMP	0x0F42
(1779) 		if (c == '.' || i >= ni) {
    00EBB 324E      CPI	R20,0x2E
    00EBC F029      BEQ	0x0EC2
    00EBD 800C      LDD	R0,Y+4
    00EBE 801D      LDD	R1,Y+5
    00EBF 140C      CP	R0,R12
    00EC0 041D      CPC	R1,R13
    00EC1 F0A0      BCS	0x0ED6
(1780) 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    00EC2 01C6      MOVW	R24,R12
    00EC3 3088      CPI	R24,0x8
    00EC4 E0E0      LDI	R30,0
    00EC5 079E      CPC	R25,R30
    00EC6 F411      BNE	0x0EC9
    00EC7 324E      CPI	R20,0x2E
    00EC8 F011      BEQ	0x0ECB
    00EC9 E006      LDI	R16,6
    00ECA C0AF      RJMP	0x0F7A
(1781) 			i = 8; ni = 11;
    00ECB E088      LDI	R24,0x8
    00ECC E090      LDI	R25,0
    00ECD 839D      STD	Y+5,R25
    00ECE 838C      STD	Y+4,R24
    00ECF E08B      LDI	R24,0xB
    00ED0 016C      MOVW	R12,R24
(1782) 			b <<= 2; continue;
    00ED1 8408      LDD	R0,Y+8
    00ED2 0C00      LSL	R0
    00ED3 0C00      LSL	R0
    00ED4 8608      STD	Y+8,R0
    00ED5 CFD4      RJMP	0x0EAA
(1783) 		}
(1784) 		if (c >= 0x80) {				/* Extended char? */
    00ED6 3840      CPI	R20,0x80
    00ED7 F018      BCS	0x0EDB
(1785) 			b |= 3;						/* Eliminate NT flag */
    00ED8 8588      LDD	R24,Y+8
    00ED9 6083      ORI	R24,3
    00EDA 8788      STD	Y+8,R24
(1786) #ifdef _EXCVT
(1787) 			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
(1788) #else
(1789) #if !_DF1S	/* ASCII only cfg */
(1790) 			return FR_INVALID_NAME;
(1791) #endif
(1792) #endif
(1793) 		}
(1794) 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    00EDB 3841      CPI	R20,0x81
    00EDC F408      BCC	0x0EDE
    00EDD C039      RJMP	0x0F17
    00EDE EF8E      LDI	R24,0xFE
    00EDF 1784      CP	R24,R20
    00EE0 F408      BCC	0x0EE2
    00EE1 C035      RJMP	0x0F17
(1795) 			d = (BYTE)p[si++];			/* Get 2nd byte */
    00EE2 015B      MOVW	R10,R22
    00EE3 5F6F      SUBI	R22,0xFF
    00EE4 4F7F      SBCI	R23,0xFF
    00EE5 01F5      MOVW	R30,R10
    00EE6 800A      LDD	R0,Y+2
    00EE7 801B      LDD	R1,Y+3
    00EE8 0DE0      ADD	R30,R0
    00EE9 1DF1      ADC	R31,R1
    00EEA 80A0      LD	R10,Z
(1796) 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    00EEB 2D8A      MOV	R24,R10
    00EEC 3480      CPI	R24,0x40
    00EED F018      BCS	0x0EF1
    00EEE E78E      LDI	R24,0x7E
    00EEF 158A      CP	R24,R10
    00EF0 F430      BCC	0x0EF7
    00EF1 2D8A      MOV	R24,R10
    00EF2 3880      CPI	R24,0x80
    00EF3 F050      BCS	0x0EFE
    00EF4 EF8E      LDI	R24,0xFE
    00EF5 158A      CP	R24,R10
    00EF6 F038      BCS	0x0EFE
    00EF7 01C6      MOVW	R24,R12
    00EF8 9701      SBIW	R24,1
    00EF9 800C      LDD	R0,Y+4
    00EFA 801D      LDD	R1,Y+5
    00EFB 1608      CP	R0,R24
    00EFC 0619      CPC	R1,R25
    00EFD F010      BCS	0x0F00
(1797) 				return FR_INVALID_NAME;
    00EFE E006      LDI	R16,6
    00EFF C07A      RJMP	0x0F7A
(1798) 			sfn[i++] = c;
    00F00 80EC      LDD	R14,Y+4
    00F01 80FD      LDD	R15,Y+5
    00F02 01C7      MOVW	R24,R14
    00F03 9601      ADIW	R24,1
    00F04 839D      STD	Y+5,R25
    00F05 838C      STD	Y+4,R24
    00F06 01F7      MOVW	R30,R14
    00F07 800E      LDD	R0,Y+6
    00F08 801F      LDD	R1,Y+7
    00F09 0DE0      ADD	R30,R0
    00F0A 1DF1      ADC	R31,R1
    00F0B 8340      ST	Z,R20
(1799) 			sfn[i++] = d;
    00F0C 017C      MOVW	R14,R24
    00F0D 9601      ADIW	R24,1
    00F0E 839D      STD	Y+5,R25
    00F0F 838C      STD	Y+4,R24
    00F10 01F7      MOVW	R30,R14
    00F11 800E      LDD	R0,Y+6
    00F12 801F      LDD	R1,Y+7
    00F13 0DE0      ADD	R30,R0
    00F14 1DF1      ADC	R31,R1
    00F15 82A0      ST	Z,R10
(1800) 		} else {						/* Single byte code */
    00F16 CF93      RJMP	0x0EAA
(1801) 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    00F17 2F24      MOV	R18,R20
    00F18 2733      CLR	R19
    00F19 E000      LDI	R16,0
    00F1A E011      LDI	R17,1
    00F1B 940E 0340 CALL	ff.c:chk_chr
    00F1D 0158      MOVW	R10,R16
    00F1E 3000      CPI	R16,0
    00F1F 0701      CPC	R16,R17
    00F20 F011      BEQ	0x0F23
(1802) 				return FR_INVALID_NAME;
    00F21 E006      LDI	R16,6
    00F22 C057      RJMP	0x0F7A
(1803) 			if (IsUpper(c)) {			/* ASCII large capital? */
    00F23 3441      CPI	R20,0x41
    00F24 F038      BCS	0x0F2C
    00F25 E58A      LDI	R24,0x5A
    00F26 1784      CP	R24,R20
    00F27 F020      BCS	0x0F2C
(1804) 				b |= 2;
    00F28 8588      LDD	R24,Y+8
    00F29 6082      ORI	R24,2
    00F2A 8788      STD	Y+8,R24
(1805) 			} else {
    00F2B C009      RJMP	0x0F35
(1806) 				if (IsLower(c)) {		/* ASCII small capital? */
    00F2C 3641      CPI	R20,0x61
    00F2D F038      BCS	0x0F35
    00F2E E78A      LDI	R24,0x7A
    00F2F 1784      CP	R24,R20
    00F30 F020      BCS	0x0F35
(1807) 					b |= 1; c -= 0x20;
    00F31 8588      LDD	R24,Y+8
    00F32 6081      ORI	R24,1
    00F33 8788      STD	Y+8,R24
    00F34 5240      SUBI	R20,0x20
(1808) 				}
(1809) 			}
(1810) 			sfn[i++] = c;
    00F35 80AC      LDD	R10,Y+4
    00F36 80BD      LDD	R11,Y+5
    00F37 01C5      MOVW	R24,R10
    00F38 9601      ADIW	R24,1
    00F39 839D      STD	Y+5,R25
    00F3A 838C      STD	Y+4,R24
    00F3B 01F5      MOVW	R30,R10
    00F3C 800E      LDD	R0,Y+6
    00F3D 801F      LDD	R1,Y+7
    00F3E 0DE0      ADD	R30,R0
    00F3F 1DF1      ADC	R31,R1
    00F40 8340      ST	Z,R20
    00F41 CF68      RJMP	0x0EAA
(1811) 		}
(1812) 	}
(1813) 	*path = &p[si];						/* Return pointer to the next segment */
    00F42 011B      MOVW	R2,R22
    00F43 800A      LDD	R0,Y+2
    00F44 801B      LDD	R1,Y+3
    00F45 0C20      ADD	R2,R0
    00F46 1C31      ADC	R3,R1
    00F47 89EB      LDD	R30,Y+19
    00F48 89FC      LDD	R31,Y+20
    00F49 8231      STD	Z+1,R3
    00F4A 8220      ST	Z,R2
(1814) 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    00F4B E280      LDI	R24,0x20
    00F4C 1784      CP	R24,R20
    00F4D F018      BCS	0x0F51
    00F4E E064      LDI	R22,4
    00F4F E070      LDI	R23,0
    00F50 C002      RJMP	0x0F53
    00F51 2766      CLR	R22
    00F52 2777      CLR	R23
    00F53 2F46      MOV	R20,R22
(1815) 
(1816) 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    00F54 800C      LDD	R0,Y+4
    00F55 801D      LDD	R1,Y+5
    00F56 2000      TST	R0
    00F57 F421      BNE	0x0F5C
    00F58 2011      TST	R1
    00F59 F411      BNE	0x0F5C
    00F5A E006      LDI	R16,6
    00F5B C01E      RJMP	0x0F7A
(1817) 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    00F5C 81EE      LDD	R30,Y+6
    00F5D 81FF      LDD	R31,Y+7
    00F5E 8180      LD	R24,Z
    00F5F 3E85      CPI	R24,0xE5
    00F60 F411      BNE	0x0F63
    00F61 E085      LDI	R24,5
    00F62 8380      ST	Z,R24
(1818) 
(1819) 	if (ni == 8) b <<= 2;
    00F63 01C6      MOVW	R24,R12
    00F64 3088      CPI	R24,0x8
    00F65 E0E0      LDI	R30,0
    00F66 079E      CPC	R25,R30
    00F67 F421      BNE	0x0F6C
    00F68 8408      LDD	R0,Y+8
    00F69 0C00      LSL	R0
    00F6A 0C00      LSL	R0
    00F6B 8608      STD	Y+8,R0
(1820) 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    00F6C 8588      LDD	R24,Y+8
    00F6D 7083      ANDI	R24,3
    00F6E 3081      CPI	R24,1
    00F6F F409      BNE	0x0F71
    00F70 6140      ORI	R20,0x10
(1821) 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    00F71 8588      LDD	R24,Y+8
    00F72 708C      ANDI	R24,0xC
    00F73 3084      CPI	R24,4
    00F74 F409      BNE	0x0F76
    00F75 6048      ORI	R20,0x8
(1822) 
(1823) 	sfn[NS] = c;		/* Store NT flag, File name is created */
    00F76 81EE      LDD	R30,Y+6
    00F77 81FF      LDD	R31,Y+7
    00F78 8743      STD	Z+11,R20
(1824) 
(1825) 	return FR_OK;
    00F79 2700      CLR	R16
    00F7A 9629      ADIW	R28,0x9
    00F7B 940E 4160 CALL	pop_xgsetF0FC
    00F7D 9622      ADIW	R28,2
    00F7E 9508      RET
ff.c:get_fileinfo:
  nt                   --> R12
  p                    --> R20
  dir                  --> R10
  i                    --> R12
  c                    --> R14
  fno                  --> R22
  dj                   --> R10
    00F7F 940E 416B CALL	push_xgsetF0FC
    00F81 01B9      MOVW	R22,R18
    00F82 0158      MOVW	R10,R16
(1826) #endif
(1827) }
(1828) 
(1829) 
(1830) 
(1831) 
(1832) /*-----------------------------------------------------------------------*/
(1833) /* Get file information from directory entry                             */
(1834) /*-----------------------------------------------------------------------*/
(1835) #if _FS_MINIMIZE <= 1
(1836) static
(1837) void get_fileinfo (		/* No return code */
(1838) 	DIR *dj,			/* Pointer to the directory object */
(1839) 	FILINFO *fno	 	/* Pointer to the file information to be filled */
(1840) )
(1841) {
(1842) 	UINT i;
(1843) 	BYTE nt, *dir;
(1844) 	TCHAR *p, c;
(1845) 
(1846) 
(1847) 	p = fno->fname;
    00F83 01AB      MOVW	R20,R22
    00F84 5F47      SUBI	R20,0xF7
    00F85 4F5F      SBCI	R21,0xFF
(1848) 	if (dj->sect) {
    00F86 01F5      MOVW	R30,R10
    00F87 963E      ADIW	R30,0xE
    00F88 8020      LD	R2,Z
    00F89 8031      LDD	R3,Z+1
    00F8A 8042      LDD	R4,Z+2
    00F8B 8053      LDD	R5,Z+3
    00F8C 9488      BCLR	0
    00F8D 2022      TST	R2
    00F8E 0432      CPC	R3,R2
    00F8F 0442      CPC	R4,R2
    00F90 0452      CPC	R5,R2
    00F91 F409      BNE	0x0F93
    00F92 C08A      RJMP	0x101D
(1849) 		dir = dj->dir;
    00F93 01F5      MOVW	R30,R10
    00F94 88A2      LDD	R10,Z+18
    00F95 88B3      LDD	R11,Z+19
(1850) 		nt = dir[DIR_NTres];		/* NT flag */
(1851) 		for (i = 0; i < 8; i++) {	/* Copy name body */
    00F96 24CC      CLR	R12
    00F97 24DD      CLR	R13
    00F98 C014      RJMP	0x0FAD
(1852) 			c = dir[i];
    00F99 01F6      MOVW	R30,R12
    00F9A 0DEA      ADD	R30,R10
    00F9B 1DFB      ADC	R31,R11
    00F9C 80E0      LD	R14,Z
(1853) 			if (c == ' ') break;
    00F9D 2D8E      MOV	R24,R14
    00F9E 3280      CPI	R24,0x20
    00F9F F409      BNE	0x0FA1
    00FA0 C011      RJMP	0x0FB2
(1854) 			if (c == NDDE) c = (TCHAR)DDE;
    00FA1 2D8E      MOV	R24,R14
    00FA2 3085      CPI	R24,5
    00FA3 F411      BNE	0x0FA6
    00FA4 EE85      LDI	R24,0xE5
    00FA5 2EE8      MOV	R14,R24
(1855) 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
    00FA6 C000      RJMP	0x0FA7
(1856) #if _LFN_UNICODE
(1857) 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
(1858) 				c = (c << 8) | dir[++i];
(1859) 			c = ff_convert(c, 1);
(1860) 			if (!c) c = '?';
(1861) #endif
(1862) 			*p++ = c;
    00FA7 01FA      MOVW	R30,R20
    00FA8 92E1      ST	Z+,R14
    00FA9 01AF      MOVW	R20,R30
    00FAA 01C6      MOVW	R24,R12
    00FAB 9601      ADIW	R24,1
    00FAC 016C      MOVW	R12,R24
    00FAD 01C6      MOVW	R24,R12
    00FAE 3088      CPI	R24,0x8
    00FAF E0E0      LDI	R30,0
    00FB0 079E      CPC	R25,R30
    00FB1 F338      BCS	0x0F99
(1863) 		}
(1864) 		if (dir[8] != ' ') {		/* Copy name extension */
    00FB2 01F5      MOVW	R30,R10
    00FB3 8580      LDD	R24,Z+8
    00FB4 3280      CPI	R24,0x20
    00FB5 F0E1      BEQ	0x0FD2
(1865) 			*p++ = '.';
    00FB6 E28E      LDI	R24,0x2E
    00FB7 01FA      MOVW	R30,R20
    00FB8 9381      ST	Z+,R24
    00FB9 01AF      MOVW	R20,R30
(1866) 			for (i = 8; i < 11; i++) {
    00FBA E088      LDI	R24,0x8
    00FBB E090      LDI	R25,0
    00FBC 016C      MOVW	R12,R24
    00FBD C00F      RJMP	0x0FCD
(1867) 				c = dir[i];
    00FBE 01F6      MOVW	R30,R12
    00FBF 0DEA      ADD	R30,R10
    00FC0 1DFB      ADC	R31,R11
    00FC1 80E0      LD	R14,Z
(1868) 				if (c == ' ') break;
    00FC2 2D8E      MOV	R24,R14
    00FC3 3280      CPI	R24,0x20
    00FC4 F409      BNE	0x0FC6
    00FC5 C00C      RJMP	0x0FD2
(1869) 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
    00FC6 C000      RJMP	0x0FC7
(1870) #if _LFN_UNICODE
(1871) 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
(1872) 					c = (c << 8) | dir[++i];
(1873) 				c = ff_convert(c, 1);
(1874) 				if (!c) c = '?';
(1875) #endif
(1876) 				*p++ = c;
    00FC7 01FA      MOVW	R30,R20
    00FC8 92E1      ST	Z+,R14
    00FC9 01AF      MOVW	R20,R30
    00FCA 01C6      MOVW	R24,R12
    00FCB 9601      ADIW	R24,1
    00FCC 016C      MOVW	R12,R24
    00FCD 01C6      MOVW	R24,R12
    00FCE 308B      CPI	R24,0xB
    00FCF E0E0      LDI	R30,0
    00FD0 079E      CPC	R25,R30
    00FD1 F360      BCS	0x0FBE
(1877) 			}
(1878) 		}
(1879) 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    00FD2 01F5      MOVW	R30,R10
    00FD3 8423      LDD	R2,Z+11
    00FD4 01FB      MOVW	R30,R22
    00FD5 8620      STD	Z+8,R2
(1880) 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    00FD6 E188      LDI	R24,0x18
    00FD7 E090      LDI	R25,0
    00FD8 01F5      MOVW	R30,R10
    00FD9 8D07      LDD	R16,Z+31
    00FDA 2711      CLR	R17
    00FDB 2722      CLR	R18
    00FDC 2733      CLR	R19
    00FDD 938A      ST	-Y,R24
    00FDE 940E 41ED CALL	lsl32
    00FE0 0118      MOVW	R2,R16
    00FE1 0129      MOVW	R4,R18
    00FE2 01F5      MOVW	R30,R10
    00FE3 8C66      LDD	R6,Z+30
    00FE4 2477      CLR	R7
    00FE5 2488      CLR	R8
    00FE6 2499      CLR	R9
    00FE7 0143      MOVW	R8,R6
    00FE8 2466      CLR	R6
    00FE9 2477      CLR	R7
    00FEA 2826      OR	R2,R6
    00FEB 2837      OR	R3,R7
    00FEC 2848      OR	R4,R8
    00FED 2859      OR	R5,R9
    00FEE 8C65      LDD	R6,Z+29
    00FEF 2477      CLR	R7
    00FF0 2C76      MOV	R7,R6
    00FF1 2466      CLR	R6
    00FF2 2488      CLR	R8
    00FF3 2499      CLR	R9
    00FF4 2826      OR	R2,R6
    00FF5 2837      OR	R3,R7
    00FF6 2848      OR	R4,R8
    00FF7 2859      OR	R5,R9
    00FF8 8C64      LDD	R6,Z+28
    00FF9 2477      CLR	R7
    00FFA 2488      CLR	R8
    00FFB 2499      CLR	R9
    00FFC 2826      OR	R2,R6
    00FFD 2837      OR	R3,R7
    00FFE 2848      OR	R4,R8
    00FFF 2859      OR	R5,R9
    01000 01FB      MOVW	R30,R22
    01001 8220      ST	Z,R2
    01002 8231      STD	Z+1,R3
    01003 8242      STD	Z+2,R4
    01004 8253      STD	Z+3,R5
(1881) 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    01005 01F5      MOVW	R30,R10
    01006 8C20      LDD	R2,Z+24
    01007 2433      CLR	R3
    01008 8C41      LDD	R4,Z+25
    01009 2455      CLR	R5
    0100A 2C54      MOV	R5,R4
    0100B 2444      CLR	R4
    0100C 2842      OR	R4,R2
    0100D 2853      OR	R5,R3
    0100E 01FB      MOVW	R30,R22
    0100F 8255      STD	Z+5,R5
    01010 8244      STD	Z+4,R4
(1882) 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    01011 01F5      MOVW	R30,R10
    01012 8826      LDD	R2,Z+22
    01013 2433      CLR	R3
    01014 8847      LDD	R4,Z+23
    01015 2455      CLR	R5
    01016 2C54      MOV	R5,R4
    01017 2444      CLR	R4
    01018 2842      OR	R4,R2
    01019 2853      OR	R5,R3
    0101A 01FB      MOVW	R30,R22
    0101B 8257      STD	Z+7,R5
    0101C 8246      STD	Z+6,R4
(1883) 	}
(1884) 	*p = 0;		/* Terminate SFN str by a \0 */
    0101D 2422      CLR	R2
    0101E 01FA      MOVW	R30,R20
    0101F 8220      ST	Z,R2
    01020 940C 4160 JMP	pop_xgsetF0FC
ff.c:follow_path:
  ns                   --> R10
  res                  --> R20
  dir                  --> R10
  path                 --> Y,+6
  dj                   --> R22
    01022 933A      ST	-Y,R19
    01023 932A      ST	-Y,R18
    01024 940E 418A CALL	push_xgsetF00C
    01026 01B8      MOVW	R22,R16
(1885) 
(1886) #if _USE_LFN
(1887) 	if (fno->lfname && fno->lfsize) {
(1888) 		TCHAR *tp = fno->lfname;
(1889) 		WCHAR w, *lfn;
(1890) 
(1891) 		i = 0;
(1892) 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
(1893) 			lfn = dj->lfn;
(1894) 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
(1895) #if !_LFN_UNICODE
(1896) 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
(1897) 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
(1898) 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
(1899) 					tp[i++] = (TCHAR)(w >> 8);
(1900) #endif
(1901) 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
(1902) 				tp[i++] = (TCHAR)w;
(1903) 			}
(1904) 		}
(1905) 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
(1906) 	}
(1907) #endif
(1908) }
(1909) #endif /* _FS_MINIMIZE <= 1 */
(1910) 
(1911) 
(1912) 
(1913) 
(1914) /*-----------------------------------------------------------------------*/
(1915) /* Follow a file path                                                    */
(1916) /*-----------------------------------------------------------------------*/
(1917) 
(1918) static
(1919) FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
(1920) 	DIR *dj,			/* Directory object to return last directory and found object */
(1921) 	const TCHAR *path	/* Full-path string to find a file or directory */
(1922) )
(1923) {
(1924) 	FRESULT res;
(1925) 	BYTE *dir, ns;
(1926) 
(1927) 
(1928) #if _FS_RPATH
(1929) 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
(1930) 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
(1931) 	} else {							/* No heading separator */
(1932) 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
(1933) 	}
(1934) #else
(1935) 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    01027 81EE      LDD	R30,Y+6
    01028 81FF      LDD	R31,Y+7
    01029 8020      LD	R2,Z
    0102A 2433      CLR	R3
    0102B 2D82      MOV	R24,R2
    0102C 328F      CPI	R24,0x2F
    0102D F011      BEQ	0x1030
    0102E 358C      CPI	R24,0x5C
    0102F F429      BNE	0x1035
(1936) 		path++;
    01030 818E      LDD	R24,Y+6
    01031 819F      LDD	R25,Y+7
    01032 9601      ADIW	R24,1
    01033 839F      STD	Y+7,R25
    01034 838E      STD	Y+6,R24
(1937) 	dj->sclust = 0;						/* Start from the root dir */
    01035 01FB      MOVW	R30,R22
    01036 9636      ADIW	R30,6
    01037 E080      LDI	R24,0
    01038 8380      ST	Z,R24
    01039 8381      STD	Z+1,R24
    0103A 8382      STD	Z+2,R24
    0103B 8383      STD	Z+3,R24
(1938) #endif
(1939) 
(1940) 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    0103C 81EE      LDD	R30,Y+6
    0103D 81FF      LDD	R31,Y+7
    0103E 8180      LD	R24,Z
    0103F 2799      CLR	R25
    01040 3280      CPI	R24,0x20
    01041 E0E0      LDI	R30,0
    01042 079E      CPC	R25,R30
    01043 F458      BCC	0x104F
(1941) 		res = dir_sdi(dj, 0);
    01044 2722      CLR	R18
    01045 2733      CLR	R19
    01046 018B      MOVW	R16,R22
    01047 DA84      RCALL	ff.c:dir_sdi
    01048 2F40      MOV	R20,R16
(1942) 		dj->dir = 0;
    01049 2422      CLR	R2
    0104A 2433      CLR	R3
    0104B 01FB      MOVW	R30,R22
    0104C 8A33      STD	Z+19,R3
    0104D 8A22      STD	Z+18,R2
(1943) 
(1944) 	} else {							/* Follow path */
    0104E C052      RJMP	0x10A1
(1945) 		for (;;) {
(1946) 			res = create_name(dj, &path);	/* Get a segment */
    0104F 019E      MOVW	R18,R28
    01050 5F2A      SUBI	R18,0xFA
    01051 4F3F      SBCI	R19,0xFF
    01052 018B      MOVW	R16,R22
    01053 DE23      RCALL	ff.c:create_name
    01054 2EA0      MOV	R10,R16
    01055 2D4A      MOV	R20,R10
(1947) 			if (res != FR_OK) break;
    01056 2300      TST	R16
    01057 F009      BEQ	0x1059
    01058 C048      RJMP	0x10A1
(1948) 			res = dir_find(dj);				/* Find it */
    01059 018B      MOVW	R16,R22
    0105A DD29      RCALL	ff.c:dir_find
    0105B 2EA0      MOV	R10,R16
    0105C 2D4A      MOV	R20,R10
(1949) 			ns = *(dj->fn+NS);
    0105D 01FB      MOVW	R30,R22
    0105E 93AF      PUSH	R26
    0105F 93BF      PUSH	R27
    01060 89A4      LDD	R26,Z+20
    01061 89B5      LDD	R27,Z+21
    01062 01FD      MOVW	R30,R26
    01063 91BF      POP	R27
    01064 91AF      POP	R26
    01065 84A3      LDD	R10,Z+11
(1950) 			if (res != FR_OK) {				/* Failed to find the object */
    01066 2300      TST	R16
    01067 F049      BEQ	0x1071
(1951) 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    01068 3004      CPI	R16,4
    01069 F009      BEQ	0x106B
    0106A C036      RJMP	0x10A1
(1952) 				/* Object not found */
(1953) 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    0106B C001      RJMP	0x106D
(1954) 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
(1955) 					res = FR_OK;
(1956) 					if (!(ns & NS_LAST)) continue;
    0106C CFE2      RJMP	0x104F
(1957) 				} else {							/* Could not find the object */
(1958) 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    0106D FCA2      SBRC	R10,2
    0106E C032      RJMP	0x10A1
    0106F E045      LDI	R20,5
(1959) 				}
(1960) 				break;
    01070 C030      RJMP	0x10A1
(1961) 			}
(1962) 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    01071 FEA2      SBRS	R10,2
    01072 C001      RJMP	0x1074
    01073 C02D      RJMP	0x10A1
(1963) 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    01074 01FB      MOVW	R30,R22
    01075 88A2      LDD	R10,Z+18
    01076 88B3      LDD	R11,Z+19
(1964) 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    01077 01F5      MOVW	R30,R10
    01078 8423      LDD	R2,Z+11
    01079 FC24      SBRC	R2,4
    0107A C002      RJMP	0x107D
(1965) 				res = FR_NO_PATH; break;
    0107B E045      LDI	R20,5
    0107C C024      RJMP	0x10A1
(1966) 			}
(1967) 			dj->sclust = LD_CLUST(dir);
    0107D 01F5      MOVW	R30,R10
    0107E 8C22      LDD	R2,Z+26
    0107F 2433      CLR	R3
    01080 8C43      LDD	R4,Z+27
    01081 2455      CLR	R5
    01082 2C54      MOV	R5,R4
    01083 2444      CLR	R4
    01084 2842      OR	R4,R2
    01085 2853      OR	R5,R3
    01086 0112      MOVW	R2,R4
    01087 2444      CLR	R4
    01088 2455      CLR	R5
    01089 8864      LDD	R6,Z+20
    0108A 2477      CLR	R7
    0108B 8885      LDD	R8,Z+21
    0108C 2499      CLR	R9
    0108D 2C98      MOV	R9,R8
    0108E 2488      CLR	R8
    0108F 2886      OR	R8,R6
    01090 2897      OR	R9,R7
    01091 0134      MOVW	R6,R8
    01092 2488      CLR	R8
    01093 2499      CLR	R9
    01094 0143      MOVW	R8,R6
    01095 2466      CLR	R6
    01096 2477      CLR	R7
    01097 2862      OR	R6,R2
    01098 2873      OR	R7,R3
    01099 2884      OR	R8,R4
    0109A 2895      OR	R9,R5
    0109B 01FB      MOVW	R30,R22
    0109C 8266      STD	Z+6,R6
    0109D 8277      STD	Z+7,R7
    0109E 8680      STD	Z+8,R8
    0109F 8691      STD	Z+9,R9
    010A0 CFAE      RJMP	0x104F
(1968) 		}
(1969) 	}
(1970) 
(1971) 	return res;
    010A1 2F04      MOV	R16,R20
    010A2 940E 4191 CALL	pop_xgsetF00C
    010A4 9622      ADIW	R28,2
    010A5 9508      RET
ff.c:check_fs:
  sect                 --> Y,+11
  fs                   --> R10
    010A6 933A      ST	-Y,R19
    010A7 932A      ST	-Y,R18
    010A8 940E 418A CALL	push_xgsetF00C
    010AA 0158      MOVW	R10,R16
    010AB 9725      SBIW	R28,5
(1972) }
(1973) 
(1974) 
(1975) 
(1976) 
(1977) /*-----------------------------------------------------------------------*/
(1978) /* Load a sector and check if it is an FAT Volume Boot Record            */
(1979) /*-----------------------------------------------------------------------*/
(1980) 
(1981) static
(1982) BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
(1983) 	FATFS *fs,	/* File system object */
(1984) 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
(1985) )
(1986) {
(1987) 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    010AC E081      LDI	R24,1
    010AD 838C      STD	Y+4,R24
    010AE 842B      LDD	R2,Y+11
    010AF 843C      LDD	R3,Y+12
    010B0 844D      LDD	R4,Y+13
    010B1 845E      LDD	R5,Y+14
    010B2 8228      ST	Y,R2
    010B3 8239      STD	Y+1,R3
    010B4 824A      STD	Y+2,R4
    010B5 825B      STD	Y+3,R5
    010B6 0195      MOVW	R18,R10
    010B7 5D22      SUBI	R18,0xD2
    010B8 4F3F      SBCI	R19,0xFF
    010B9 01F5      MOVW	R30,R10
    010BA 8101      LDD	R16,Z+1
    010BB 940E 02B5 CALL	_disk_read
    010BD 2300      TST	R16
    010BE F011      BEQ	0x10C1
(1988) 		return 3;
    010BF E003      LDI	R16,3
    010C0 C0A8      RJMP	0x1169
(1989) 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    010C1 01F5      MOVW	R30,R10
    010C2 5DE4      SUBI	R30,0xD4
    010C3 4FFD      SBCI	R31,0xFD
    010C4 8020      LD	R2,Z
    010C5 52EC      SUBI	R30,0x2C
    010C6 40F2      SBCI	R31,2
    010C7 2433      CLR	R3
    010C8 5DE3      SUBI	R30,0xD3
    010C9 4FFD      SBCI	R31,0xFD
    010CA 8180      LD	R24,Z
    010CB 2799      CLR	R25
    010CC 2F98      MOV	R25,R24
    010CD 2788      CLR	R24
    010CE 2982      OR	R24,R2
    010CF 2993      OR	R25,R3
    010D0 3585      CPI	R24,0x55
    010D1 EAEA      LDI	R30,0xAA
    010D2 079E      CPC	R25,R30
    010D3 F011      BEQ	0x10D6
(1990) 		return 2;
    010D4 E002      LDI	R16,2
    010D5 C093      RJMP	0x1169
(1991) 
(1992) 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    010D6 E188      LDI	R24,0x18
    010D7 E090      LDI	R25,0
    010D8 01F5      MOVW	R30,R10
    010D9 59E9      SUBI	R30,0x99
    010DA 4FFF      SBCI	R31,0xFF
    010DB 8100      LD	R16,Z
    010DC 2711      CLR	R17
    010DD 2722      CLR	R18
    010DE 2733      CLR	R19
    010DF 938A      ST	-Y,R24
    010E0 940E 41ED CALL	lsl32
    010E2 0118      MOVW	R2,R16
    010E3 0129      MOVW	R4,R18
    010E4 01F5      MOVW	R30,R10
    010E5 59EA      SUBI	R30,0x9A
    010E6 4FFF      SBCI	R31,0xFF
    010E7 8060      LD	R6,Z
    010E8 56E6      SUBI	R30,0x66
    010E9 40F0      SBCI	R31,0
    010EA 2477      CLR	R7
    010EB 2488      CLR	R8
    010EC 2499      CLR	R9
    010ED 0143      MOVW	R8,R6
    010EE 2466      CLR	R6
    010EF 2477      CLR	R7
    010F0 2826      OR	R2,R6
    010F1 2837      OR	R3,R7
    010F2 2848      OR	R4,R8
    010F3 2859      OR	R5,R9
    010F4 59EB      SUBI	R30,0x9B
    010F5 4FFF      SBCI	R31,0xFF
    010F6 8060      LD	R6,Z
    010F7 56E5      SUBI	R30,0x65
    010F8 40F0      SBCI	R31,0
    010F9 2477      CLR	R7
    010FA 2C76      MOV	R7,R6
    010FB 2466      CLR	R6
    010FC 2488      CLR	R8
    010FD 2499      CLR	R9
    010FE 2826      OR	R2,R6
    010FF 2837      OR	R3,R7
    01100 2848      OR	R4,R8
    01101 2859      OR	R5,R9
    01102 59EC      SUBI	R30,0x9C
    01103 4FFF      SBCI	R31,0xFF
    01104 8060      LD	R6,Z
    01105 2477      CLR	R7
    01106 2488      CLR	R8
    01107 2499      CLR	R9
    01108 2826      OR	R2,R6
    01109 2837      OR	R3,R7
    0110A 2848      OR	R4,R8
    0110B 2859      OR	R5,R9
    0110C EF4F      LDI	R20,0xFF
    0110D EF5F      LDI	R21,0xFF
    0110E EF6F      LDI	R22,0xFF
    0110F E070      LDI	R23,0
    01110 2224      AND	R2,R20
    01111 2235      AND	R3,R21
    01112 2246      AND	R4,R22
    01113 2257      AND	R5,R23
    01114 E446      LDI	R20,0x46
    01115 E451      LDI	R21,0x41
    01116 E564      LDI	R22,0x54
    01117 E070      LDI	R23,0
    01118 1624      CP	R2,R20
    01119 0635      CPC	R3,R21
    0111A 0646      CPC	R4,R22
    0111B 0657      CPC	R5,R23
    0111C F411      BNE	0x111F
(1993) 		return 0;
    0111D 2700      CLR	R16
    0111E C04A      RJMP	0x1169
(1994) 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    0111F E188      LDI	R24,0x18
    01120 E090      LDI	R25,0
    01121 01F5      MOVW	R30,R10
    01122 57ED      SUBI	R30,0x7D
    01123 4FFF      SBCI	R31,0xFF
    01124 8100      LD	R16,Z
    01125 2711      CLR	R17
    01126 2722      CLR	R18
    01127 2733      CLR	R19
    01128 938A      ST	-Y,R24
    01129 940E 41ED CALL	lsl32
    0112B 0118      MOVW	R2,R16
    0112C 0129      MOVW	R4,R18
    0112D 01F5      MOVW	R30,R10
    0112E 57EE      SUBI	R30,0x7E
    0112F 4FFF      SBCI	R31,0xFF
    01130 8060      LD	R6,Z
    01131 58E2      SUBI	R30,0x82
    01132 40F0      SBCI	R31,0
    01133 2477      CLR	R7
    01134 2488      CLR	R8
    01135 2499      CLR	R9
    01136 0143      MOVW	R8,R6
    01137 2466      CLR	R6
    01138 2477      CLR	R7
    01139 2826      OR	R2,R6
    0113A 2837      OR	R3,R7
    0113B 2848      OR	R4,R8
    0113C 2859      OR	R5,R9
    0113D 57EF      SUBI	R30,0x7F
    0113E 4FFF      SBCI	R31,0xFF
    0113F 8060      LD	R6,Z
    01140 58E1      SUBI	R30,0x81
    01141 40F0      SBCI	R31,0
    01142 2477      CLR	R7
    01143 2C76      MOV	R7,R6
    01144 2466      CLR	R6
    01145 2488      CLR	R8
    01146 2499      CLR	R9
    01147 2826      OR	R2,R6
    01148 2837      OR	R3,R7
    01149 2848      OR	R4,R8
    0114A 2859      OR	R5,R9
    0114B 58E0      SUBI	R30,0x80
    0114C 4FFF      SBCI	R31,0xFF
    0114D 8060      LD	R6,Z
    0114E 2477      CLR	R7
    0114F 2488      CLR	R8
    01150 2499      CLR	R9
    01151 2826      OR	R2,R6
    01152 2837      OR	R3,R7
    01153 2848      OR	R4,R8
    01154 2859      OR	R5,R9
    01155 EF4F      LDI	R20,0xFF
    01156 EF5F      LDI	R21,0xFF
    01157 EF6F      LDI	R22,0xFF
    01158 E070      LDI	R23,0
    01159 2224      AND	R2,R20
    0115A 2235      AND	R3,R21
    0115B 2246      AND	R4,R22
    0115C 2257      AND	R5,R23
    0115D E446      LDI	R20,0x46
    0115E E451      LDI	R21,0x41
    0115F E564      LDI	R22,0x54
    01160 E070      LDI	R23,0
    01161 1624      CP	R2,R20
    01162 0635      CPC	R3,R21
    01163 0646      CPC	R4,R22
    01164 0657      CPC	R5,R23
    01165 F411      BNE	0x1168
(1995) 		return 0;
    01166 2700      CLR	R16
    01167 C001      RJMP	0x1169
(1996) 
(1997) 	return 1;
    01168 E001      LDI	R16,1
    01169 9625      ADIW	R28,5
    0116A 940E 4191 CALL	pop_xgsetF00C
    0116C 9622      ADIW	R28,2
    0116D 9508      RET
ff.c:chk_mounted:
  pi                   --> R10
  szbfat               --> Y,+25
  tbl                  --> R10
  p                    --> R10
  nrsv                 --> R14
  sysect               --> Y,+21
  bsect                --> Y,+17
  stat                 --> R10
  tsect                --> Y,+13
  nclst                --> Y,+9
  vol                  --> R14
  fasize               --> Y,+5
  b                    --> R14
  fmt                  --> R12
  fs                   --> Y,+37
  chk_wp               --> Y,+51
  rfs                  --> Y,+49
  path                 --> R12
    0116E 933A      ST	-Y,R19
    0116F 932A      ST	-Y,R18
    01170 940E 416B CALL	push_xgsetF0FC
    01172 0168      MOVW	R12,R16
    01173 97A7      SBIW	R28,0x27
(1998) }
(1999) 
(2000) 
(2001) 
(2002) 
(2003) /*-----------------------------------------------------------------------*/
(2004) /* Check if the file system object is valid or not                       */
(2005) /*-----------------------------------------------------------------------*/
(2006) 
(2007) static
(2008) FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
(2009) 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
(2010) 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
(2011) 	BYTE chk_wp			/* !=0: Check media write protection for write access */
(2012) )
(2013) {
(2014) 	BYTE fmt, b, pi, *tbl;
(2015) 	UINT vol;
(2016) 	DSTATUS stat;
(2017) 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
(2018) 	WORD nrsv;
(2019) 	const TCHAR *p = *path;
    01174 01F6      MOVW	R30,R12
    01175 80A0      LD	R10,Z
    01176 80B1      LDD	R11,Z+1
(2020) 	FATFS *fs;
(2021) 
(2022) 	/* Get logical drive number from the path name */
(2023) 	vol = p[0] - '0';					/* Is there a drive number? */
    01177 01F5      MOVW	R30,R10
    01178 8180      LD	R24,Z
    01179 2799      CLR	R25
    0117A 97C0      SBIW	R24,0x30
    0117B 017C      MOVW	R14,R24
(2024) 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    0117C E089      LDI	R24,0x9
    0117D E090      LDI	R25,0
    0117E 158E      CP	R24,R14
    0117F 059F      CPC	R25,R15
    01180 F050      BCS	0x118B
    01181 8181      LDD	R24,Z+1
    01182 338A      CPI	R24,0x3A
    01183 F439      BNE	0x118B
(2025) 		p += 2; *path = p;				/* Return pointer to the path name */
    01184 01CF      MOVW	R24,R30
    01185 9602      ADIW	R24,2
    01186 015C      MOVW	R10,R24
    01187 01F6      MOVW	R30,R12
    01188 82B1      STD	Z+1,R11
    01189 82A0      ST	Z,R10
(2026) 	} else {							/* No drive number is given */
    0118A C002      RJMP	0x118D
(2027) #if _FS_RPATH
(2028) 		vol = CurrVol;					/* Use current drive */
(2029) #else
(2030) 		vol = 0;						/* Use drive 0 */
    0118B 24EE      CLR	R14
    0118C 24FF      CLR	R15
(2031) #endif
(2032) 	}
(2033) 
(2034) 	/* Check if the file system object is valid or not */
(2035) 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    0118D 01C7      MOVW	R24,R14
    0118E 3081      CPI	R24,1
    0118F E0E0      LDI	R30,0
    01190 079E      CPC	R25,R30
    01191 F010      BCS	0x1194
(2036) 		return FR_INVALID_DRIVE;
    01192 E00B      LDI	R16,0xB
    01193 C4CF      RJMP	0x1663
(2037) 	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    01194 E18E      LDI	R24,0x1E
    01195 E095      LDI	R25,5
    01196 01F7      MOVW	R30,R14
    01197 0FEE      LSL	R30
    01198 1FFF      ROL	R31
    01199 0FE8      ADD	R30,R24
    0119A 1FF9      ADC	R31,R25
    0119B 8020      LD	R2,Z
    0119C 8031      LDD	R3,Z+1
    0119D A23E      STD	Y+38,R3
    0119E A22D      STD	Y+37,R2
    0119F A9E9      LDD	R30,Y+49
    011A0 A9FA      LDD	R31,Y+50
    011A1 8231      STD	Z+1,R3
    011A2 8220      ST	Z,R2
(2038) 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    011A3 0101      MOVW	R0,R2
    011A4 2022      TST	R2
    011A5 F421      BNE	0x11AA
    011A6 2033      TST	R3
    011A7 F411      BNE	0x11AA
    011A8 E00C      LDI	R16,0xC
    011A9 C4B9      RJMP	0x1663
(2039) 
(2040) 	ENTER_FF(fs);						/* Lock file system */
(2041) 
(2042) 	if (fs->fs_type) {					/* If the logical drive has been mounted */
    011AA A1ED      LDD	R30,Y+37
    011AB A1FE      LDD	R31,Y+38
    011AC 8020      LD	R2,Z
    011AD 2022      TST	R2
    011AE F079      BEQ	0x11BE
(2043) 		stat = disk_status(fs->drv);
    011AF 8101      LDD	R16,Z+1
    011B0 940E 02AF CALL	_disk_status
    011B2 2EA0      MOV	R10,R16
(2044) 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    011B3 FD00      SBRC	R16,0
    011B4 C009      RJMP	0x11BE
(2045) 			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    011B5 A80B      LDD	R0,Y+51
    011B6 2000      TST	R0
    011B7 F021      BEQ	0x11BC
    011B8 FF02      SBRS	R16,2
    011B9 C002      RJMP	0x11BC
(2046) 				return FR_WRITE_PROTECTED;
    011BA E00A      LDI	R16,0xA
    011BB C4A7      RJMP	0x1663
(2047) 			return FR_OK;				/* The file system object is valid */
    011BC 2700      CLR	R16
    011BD C4A5      RJMP	0x1663
(2048) 		}
(2049) 	}
(2050) 
(2051) 	/* The file system object is not valid. */
(2052) 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
(2053) 
(2054) 	fs->fs_type = 0;					/* Clear the file system object */
    011BE 2422      CLR	R2
    011BF A1ED      LDD	R30,Y+37
    011C0 A1FE      LDD	R31,Y+38
    011C1 8220      ST	Z,R2
(2055) 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    011C2 82E1      STD	Z+1,R14
(2056) 	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    011C3 8101      LDD	R16,Z+1
    011C4 940E 0299 CALL	_disk_initialize
    011C6 2EE0      MOV	R14,R16
    011C7 2CAE      MOV	R10,R14
(2057) 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    011C8 FF00      SBRS	R16,0
    011C9 C002      RJMP	0x11CC
(2058) 		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    011CA E003      LDI	R16,3
    011CB C497      RJMP	0x1663
(2059) 	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    011CC A80B      LDD	R0,Y+51
    011CD 2000      TST	R0
    011CE F021      BEQ	0x11D3
    011CF FEA2      SBRS	R10,2
    011D0 C002      RJMP	0x11D3
(2060) 		return FR_WRITE_PROTECTED;
    011D1 E00A      LDI	R16,0xA
    011D2 C490      RJMP	0x1663
(2061) #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
(2062) 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
(2063) 		return FR_DISK_ERR;
(2064) #endif
(2065) 	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
(2066) 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    011D3 E080      LDI	R24,0
    011D4 8B89      STD	Y+17,R24
    011D5 8B8A      STD	Y+18,R24
    011D6 8B8B      STD	Y+19,R24
    011D7 8B8C      STD	Y+20,R24
    011D8 E040      LDI	R20,0
    011D9 E050      LDI	R21,0
    011DA E060      LDI	R22,0
    011DB E070      LDI	R23,0
    011DC 8368      ST	Y,R22
    011DD 8379      STD	Y+1,R23
    011DE 019A      MOVW	R18,R20
    011DF A10D      LDD	R16,Y+37
    011E0 A11E      LDD	R17,Y+38
    011E1 DEC4      RCALL	ff.c:check_fs
    011E2 2EA0      MOV	R10,R16
    011E3 2CCA      MOV	R12,R10
(2067) 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
    011E4 C000      RJMP	0x11E5
(2068) 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    011E5 2D8C      MOV	R24,R12
    011E6 3081      CPI	R24,1
    011E7 F009      BEQ	0x11E9
    011E8 C04C      RJMP	0x1235
(2069) 		/* Check the partition listed in the partition table */
(2070) 		pi = LD2PT(vol);
    011E9 24AA      CLR	R10
(2071) 		if (pi) pi--;
    011EA F009      BEQ	0x11EC
    011EB 94AA      DEC	R10
(2072) 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
    011EC E100      LDI	R16,0x10
    011ED 2D1A      MOV	R17,R10
    011EE 0301      MULSU	R16,R17
    011EF 0150      MOVW	R10,R0
    011F0 A18D      LDD	R24,Y+37
    011F1 A19E      LDD	R25,Y+38
    011F2 5184      SUBI	R24,0x14
    011F3 4F9E      SBCI	R25,0xFE
    011F4 0EA8      ADD	R10,R24
    011F5 1EB9      ADC	R11,R25
(2073) 		if (tbl[4]) {						/* Is the partition existing? */
    011F6 01F5      MOVW	R30,R10
    011F7 8024      LDD	R2,Z+4
    011F8 2022      TST	R2
    011F9 F409      BNE	0x11FB
    011FA C03A      RJMP	0x1235
(2074) 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    011FB E188      LDI	R24,0x18
    011FC E090      LDI	R25,0
    011FD 8503      LDD	R16,Z+11
    011FE 2711      CLR	R17
    011FF 2722      CLR	R18
    01200 2733      CLR	R19
    01201 938A      ST	-Y,R24
    01202 940E 41ED CALL	lsl32
    01204 0118      MOVW	R2,R16
    01205 0129      MOVW	R4,R18
    01206 01F5      MOVW	R30,R10
    01207 8462      LDD	R6,Z+10
    01208 2477      CLR	R7
    01209 2488      CLR	R8
    0120A 2499      CLR	R9
    0120B 0143      MOVW	R8,R6
    0120C 2466      CLR	R6
    0120D 2477      CLR	R7
    0120E 2826      OR	R2,R6
    0120F 2837      OR	R3,R7
    01210 2848      OR	R4,R8
    01211 2859      OR	R5,R9
    01212 8461      LDD	R6,Z+9
    01213 2477      CLR	R7
    01214 2C76      MOV	R7,R6
    01215 2466      CLR	R6
    01216 2488      CLR	R8
    01217 2499      CLR	R9
    01218 2826      OR	R2,R6
    01219 2837      OR	R3,R7
    0121A 2848      OR	R4,R8
    0121B 2859      OR	R5,R9
    0121C 9638      ADIW	R30,0x8
    0121D 8060      LD	R6,Z
    0121E 2477      CLR	R7
    0121F 2488      CLR	R8
    01220 2499      CLR	R9
    01221 2826      OR	R2,R6
    01222 2837      OR	R3,R7
    01223 2848      OR	R4,R8
    01224 2859      OR	R5,R9
    01225 8A29      STD	Y+17,R2
    01226 8A3A      STD	Y+18,R3
    01227 8A4B      STD	Y+19,R4
    01228 8A5C      STD	Y+20,R5
(2075) 			fmt = check_fs(fs, bsect);		/* Check the partition */
    01229 8829      LDD	R2,Y+17
    0122A 883A      LDD	R3,Y+18
    0122B 884B      LDD	R4,Y+19
    0122C 885C      LDD	R5,Y+20
    0122D 8248      ST	Y,R4
    0122E 8259      STD	Y+1,R5
    0122F 0191      MOVW	R18,R2
    01230 A10D      LDD	R16,Y+37
    01231 A11E      LDD	R17,Y+38
    01232 DE73      RCALL	ff.c:check_fs
    01233 2EA0      MOV	R10,R16
    01234 2CCA      MOV	R12,R10
(2076) 		}
(2077) 	}
(2078) 	if (fmt == 3) return FR_DISK_ERR;
    01235 2D8C      MOV	R24,R12
    01236 3083      CPI	R24,3
    01237 F411      BNE	0x123A
    01238 E001      LDI	R16,1
    01239 C429      RJMP	0x1663
(2079) 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    0123A 20CC      TST	R12
    0123B F011      BEQ	0x123E
    0123C E00D      LDI	R16,0xD
    0123D C425      RJMP	0x1663
(2080) 
(2081) 	/* An FAT volume is found. Following code initializes the file system object */
(2082) 
(2083) 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    0123E A1ED      LDD	R30,Y+37
    0123F A1FE      LDD	R31,Y+38
    01240 AC21      LDD	R2,Z+57
    01241 2433      CLR	R3
    01242 AD82      LDD	R24,Z+58
    01243 2799      CLR	R25
    01244 2F98      MOV	R25,R24
    01245 2788      CLR	R24
    01246 2982      OR	R24,R2
    01247 2993      OR	R25,R3
    01248 3080      CPI	R24,0
    01249 E0E2      LDI	R30,2
    0124A 079E      CPC	R25,R30
    0124B F011      BEQ	0x124E
(2084) 		return FR_NO_FILESYSTEM;
    0124C E00D      LDI	R16,0xD
    0124D C415      RJMP	0x1663
(2085) 
(2086) 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    0124E A1ED      LDD	R30,Y+37
    0124F A1FE      LDD	R31,Y+38
    01250 5BEC      SUBI	R30,0xBC
    01251 4FFF      SBCI	R31,0xFF
    01252 8020      LD	R2,Z
    01253 54E4      SUBI	R30,0x44
    01254 40F0      SBCI	R31,0
    01255 2433      CLR	R3
    01256 5BEB      SUBI	R30,0xBB
    01257 4FFF      SBCI	R31,0xFF
    01258 8040      LD	R4,Z
    01259 2455      CLR	R5
    0125A 2C54      MOV	R5,R4
    0125B 2444      CLR	R4
    0125C 2842      OR	R4,R2
    0125D 2853      OR	R5,R3
    0125E 0112      MOVW	R2,R4
    0125F 2444      CLR	R4
    01260 2455      CLR	R5
    01261 822D      STD	Y+5,R2
    01262 823E      STD	Y+6,R3
    01263 824F      STD	Y+7,R4
    01264 8658      STD	Y+8,R5
(2087) 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    01265 802D      LDD	R2,Y+5
    01266 803E      LDD	R3,Y+6
    01267 804F      LDD	R4,Y+7
    01268 8458      LDD	R5,Y+8
    01269 9488      BCLR	0
    0126A 2022      TST	R2
    0126B 0432      CPC	R3,R2
    0126C 0442      CPC	R4,R2
    0126D 0452      CPC	R5,R2
    0126E F009      BEQ	0x1270
    0126F C03C      RJMP	0x12AC
    01270 E188      LDI	R24,0x18
    01271 E090      LDI	R25,0
    01272 A1ED      LDD	R30,Y+37
    01273 A1FE      LDD	R31,Y+38
    01274 5AEB      SUBI	R30,0xAB
    01275 4FFF      SBCI	R31,0xFF
    01276 8100      LD	R16,Z
    01277 2711      CLR	R17
    01278 2722      CLR	R18
    01279 2733      CLR	R19
    0127A 938A      ST	-Y,R24
    0127B 940E 41ED CALL	lsl32
    0127D 0118      MOVW	R2,R16
    0127E 0129      MOVW	R4,R18
    0127F A1ED      LDD	R30,Y+37
    01280 A1FE      LDD	R31,Y+38
    01281 5AEC      SUBI	R30,0xAC
    01282 4FFF      SBCI	R31,0xFF
    01283 8060      LD	R6,Z
    01284 55E4      SUBI	R30,0x54
    01285 40F0      SBCI	R31,0
    01286 2477      CLR	R7
    01287 2488      CLR	R8
    01288 2499      CLR	R9
    01289 0143      MOVW	R8,R6
    0128A 2466      CLR	R6
    0128B 2477      CLR	R7
    0128C 2826      OR	R2,R6
    0128D 2837      OR	R3,R7
    0128E 2848      OR	R4,R8
    0128F 2859      OR	R5,R9
    01290 5AED      SUBI	R30,0xAD
    01291 4FFF      SBCI	R31,0xFF
    01292 8060      LD	R6,Z
    01293 55E3      SUBI	R30,0x53
    01294 40F0      SBCI	R31,0
    01295 2477      CLR	R7
    01296 2C76      MOV	R7,R6
    01297 2466      CLR	R6
    01298 2488      CLR	R8
    01299 2499      CLR	R9
    0129A 2826      OR	R2,R6
    0129B 2837      OR	R3,R7
    0129C 2848      OR	R4,R8
    0129D 2859      OR	R5,R9
    0129E 5AEE      SUBI	R30,0xAE
    0129F 4FFF      SBCI	R31,0xFF
    012A0 8060      LD	R6,Z
    012A1 2477      CLR	R7
    012A2 2488      CLR	R8
    012A3 2499      CLR	R9
    012A4 2826      OR	R2,R6
    012A5 2837      OR	R3,R7
    012A6 2848      OR	R4,R8
    012A7 2859      OR	R5,R9
    012A8 822D      STD	Y+5,R2
    012A9 823E      STD	Y+6,R3
    012AA 824F      STD	Y+7,R4
    012AB 8658      STD	Y+8,R5
(2088) 	fs->fsize = fasize;
    012AC 802D      LDD	R2,Y+5
    012AD 803E      LDD	R3,Y+6
    012AE 804F      LDD	R4,Y+7
    012AF 8458      LDD	R5,Y+8
    012B0 A1ED      LDD	R30,Y+37
    012B1 A1FE      LDD	R31,Y+38
    012B2 8E22      STD	Z+26,R2
    012B3 8E33      STD	Z+27,R3
    012B4 8E44      STD	Z+28,R4
    012B5 8E55      STD	Z+29,R5
(2089) 
(2090) 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    012B6 ACA6      LDD	R10,Z+62
    012B7 2CEA      MOV	R14,R10
    012B8 82A3      STD	Z+3,R10
(2091) 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    012B9 2D8E      MOV	R24,R14
    012BA 3081      CPI	R24,1
    012BB F021      BEQ	0x12C0
    012BC 3082      CPI	R24,2
    012BD F011      BEQ	0x12C0
    012BE E00D      LDI	R16,0xD
    012BF C3A3      RJMP	0x1663
(2092) 	fasize *= b;										/* Number of sectors for FAT area */
    012C0 2C2E      MOV	R2,R14
    012C1 2433      CLR	R3
    012C2 2444      CLR	R4
    012C3 2455      CLR	R5
    012C4 810D      LDD	R16,Y+5
    012C5 811E      LDD	R17,Y+6
    012C6 812F      LDD	R18,Y+7
    012C7 8538      LDD	R19,Y+8
    012C8 925A      ST	-Y,R5
    012C9 924A      ST	-Y,R4
    012CA 923A      ST	-Y,R3
    012CB 922A      ST	-Y,R2
    012CC 940E 4117 CALL	empy32u|empy32s
    012CE 830D      STD	Y+5,R16
    012CF 831E      STD	Y+6,R17
    012D0 832F      STD	Y+7,R18
    012D1 8738      STD	Y+8,R19
(2093) 
(2094) 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    012D2 A1ED      LDD	R30,Y+37
    012D3 A1FE      LDD	R31,Y+38
    012D4 ACA3      LDD	R10,Z+59
    012D5 2CEA      MOV	R14,R10
    012D6 82A2      STD	Z+2,R10
(2095) 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    012D7 20AA      TST	R10
    012D8 F029      BEQ	0x12DE
    012D9 2D8E      MOV	R24,R14
    012DA 5081      SUBI	R24,1
    012DB 2C2E      MOV	R2,R14
    012DC 2228      AND	R2,R24
    012DD F011      BEQ	0x12E0
    012DE E00D      LDI	R16,0xD
    012DF C383      RJMP	0x1663
(2096) 
(2097) 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    012E0 A1ED      LDD	R30,Y+37
    012E1 A1FE      LDD	R31,Y+38
    012E2 AC27      LDD	R2,Z+63
    012E3 2433      CLR	R3
    012E4 5CE0      SUBI	R30,0xC0
    012E5 4FFF      SBCI	R31,0xFF
    012E6 8040      LD	R4,Z
    012E7 54E0      SUBI	R30,0x40
    012E8 40F0      SBCI	R31,0
    012E9 2455      CLR	R5
    012EA 2C54      MOV	R5,R4
    012EB 2444      CLR	R4
    012EC 2842      OR	R4,R2
    012ED 2853      OR	R5,R3
    012EE 8651      STD	Z+9,R5
    012EF 8640      STD	Z+8,R4
(2098) 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    012F0 8580      LDD	R24,Z+8
    012F1 8591      LDD	R25,Z+9
    012F2 708F      ANDI	R24,0xF
    012F3 7090      ANDI	R25,0
    012F4 3080      CPI	R24,0
    012F5 0789      CPC	R24,R25
    012F6 F011      BEQ	0x12F9
    012F7 E00D      LDI	R16,0xD
    012F8 C36A      RJMP	0x1663
(2099) 
(2100) 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    012F9 A1ED      LDD	R30,Y+37
    012FA A1FE      LDD	R31,Y+38
    012FB 5BEF      SUBI	R30,0xBF
    012FC 4FFF      SBCI	R31,0xFF
    012FD 8020      LD	R2,Z
    012FE 54E1      SUBI	R30,0x41
    012FF 40F0      SBCI	R31,0
    01300 2433      CLR	R3
    01301 5BEE      SUBI	R30,0xBE
    01302 4FFF      SBCI	R31,0xFF
    01303 8040      LD	R4,Z
    01304 2455      CLR	R5
    01305 2C54      MOV	R5,R4
    01306 2444      CLR	R4
    01307 2842      OR	R4,R2
    01308 2853      OR	R5,R3
    01309 0112      MOVW	R2,R4
    0130A 2444      CLR	R4
    0130B 2455      CLR	R5
    0130C 862D      STD	Y+13,R2
    0130D 863E      STD	Y+14,R3
    0130E 864F      STD	Y+15,R4
    0130F 8A58      STD	Y+16,R5
(2101) 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    01310 842D      LDD	R2,Y+13
    01311 843E      LDD	R3,Y+14
    01312 844F      LDD	R4,Y+15
    01313 8858      LDD	R5,Y+16
    01314 9488      BCLR	0
    01315 2022      TST	R2
    01316 0432      CPC	R3,R2
    01317 0442      CPC	R4,R2
    01318 0452      CPC	R5,R2
    01319 F009      BEQ	0x131B
    0131A C03C      RJMP	0x1357
    0131B E188      LDI	R24,0x18
    0131C E090      LDI	R25,0
    0131D A1ED      LDD	R30,Y+37
    0131E A1FE      LDD	R31,Y+38
    0131F 5AEF      SUBI	R30,0xAF
    01320 4FFF      SBCI	R31,0xFF
    01321 8100      LD	R16,Z
    01322 2711      CLR	R17
    01323 2722      CLR	R18
    01324 2733      CLR	R19
    01325 938A      ST	-Y,R24
    01326 940E 41ED CALL	lsl32
    01328 0118      MOVW	R2,R16
    01329 0129      MOVW	R4,R18
    0132A A1ED      LDD	R30,Y+37
    0132B A1FE      LDD	R31,Y+38
    0132C 5BE0      SUBI	R30,0xB0
    0132D 4FFF      SBCI	R31,0xFF
    0132E 8060      LD	R6,Z
    0132F 55E0      SUBI	R30,0x50
    01330 40F0      SBCI	R31,0
    01331 2477      CLR	R7
    01332 2488      CLR	R8
    01333 2499      CLR	R9
    01334 0143      MOVW	R8,R6
    01335 2466      CLR	R6
    01336 2477      CLR	R7
    01337 2826      OR	R2,R6
    01338 2837      OR	R3,R7
    01339 2848      OR	R4,R8
    0133A 2859      OR	R5,R9
    0133B 5BE1      SUBI	R30,0xB1
    0133C 4FFF      SBCI	R31,0xFF
    0133D 8060      LD	R6,Z
    0133E 54EF      SUBI	R30,0x4F
    0133F 40F0      SBCI	R31,0
    01340 2477      CLR	R7
    01341 2C76      MOV	R7,R6
    01342 2466      CLR	R6
    01343 2488      CLR	R8
    01344 2499      CLR	R9
    01345 2826      OR	R2,R6
    01346 2837      OR	R3,R7
    01347 2848      OR	R4,R8
    01348 2859      OR	R5,R9
    01349 5BE2      SUBI	R30,0xB2
    0134A 4FFF      SBCI	R31,0xFF
    0134B 8060      LD	R6,Z
    0134C 2477      CLR	R7
    0134D 2488      CLR	R8
    0134E 2499      CLR	R9
    0134F 2826      OR	R2,R6
    01350 2837      OR	R3,R7
    01351 2848      OR	R4,R8
    01352 2859      OR	R5,R9
    01353 862D      STD	Y+13,R2
    01354 863E      STD	Y+14,R3
    01355 864F      STD	Y+15,R4
    01356 8A58      STD	Y+16,R5
(2102) 
(2103) 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    01357 A1ED      LDD	R30,Y+37
    01358 A1FE      LDD	R31,Y+38
    01359 AC24      LDD	R2,Z+60
    0135A 2433      CLR	R3
    0135B ACE5      LDD	R14,Z+61
    0135C 24FF      CLR	R15
    0135D 2CFE      MOV	R15,R14
    0135E 24EE      CLR	R14
    0135F 28E2      OR	R14,R2
    01360 28F3      OR	R15,R3
(2104) 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    01361 20EE      TST	R14
    01362 F421      BNE	0x1367
    01363 20FF      TST	R15
    01364 F411      BNE	0x1367
    01365 E00D      LDI	R16,0xD
    01366 C2FC      RJMP	0x1663
(2105) 
(2106) 	/* Determine the FAT sub type */
(2107) 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    01367 802D      LDD	R2,Y+5
    01368 803E      LDD	R3,Y+6
    01369 804F      LDD	R4,Y+7
    0136A 8458      LDD	R5,Y+8
    0136B 0137      MOVW	R6,R14
    0136C 2488      CLR	R8
    0136D 2499      CLR	R9
    0136E 0C62      ADD	R6,R2
    0136F 1C73      ADC	R7,R3
    01370 1C84      ADC	R8,R4
    01371 1C95      ADC	R9,R5
    01372 A1ED      LDD	R30,Y+37
    01373 A1FE      LDD	R31,Y+38
    01374 9638      ADIW	R30,0x8
    01375 8020      LD	R2,Z
    01376 8031      LDD	R3,Z+1
    01377 9436      LSR	R3
    01378 9427      ROR	R2
    01379 9436      LSR	R3
    0137A 9427      ROR	R2
    0137B 9436      LSR	R3
    0137C 9427      ROR	R2
    0137D 9436      LSR	R3
    0137E 9427      ROR	R2
    0137F 2444      CLR	R4
    01380 2455      CLR	R5
    01381 0C62      ADD	R6,R2
    01382 1C73      ADC	R7,R3
    01383 1C84      ADC	R8,R4
    01384 1C95      ADC	R9,R5
    01385 8A6D      STD	Y+21,R6
    01386 8A7E      STD	Y+22,R7
    01387 8A8F      STD	Y+23,R8
    01388 8E98      STD	Y+24,R9
(2108) 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    01389 882D      LDD	R2,Y+21
    0138A 883E      LDD	R3,Y+22
    0138B 884F      LDD	R4,Y+23
    0138C 8C58      LDD	R5,Y+24
    0138D 846D      LDD	R6,Y+13
    0138E 847E      LDD	R7,Y+14
    0138F 848F      LDD	R8,Y+15
    01390 8898      LDD	R9,Y+16
    01391 1462      CP	R6,R2
    01392 0473      CPC	R7,R3
    01393 0484      CPC	R8,R4
    01394 0495      CPC	R9,R5
    01395 F410      BCC	0x1398
    01396 E00D      LDI	R16,0xD
    01397 C2CB      RJMP	0x1663
(2109) 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    01398 882D      LDD	R2,Y+21
    01399 883E      LDD	R3,Y+22
    0139A 884F      LDD	R4,Y+23
    0139B 8C58      LDD	R5,Y+24
    0139C 850D      LDD	R16,Y+13
    0139D 851E      LDD	R17,Y+14
    0139E 852F      LDD	R18,Y+15
    0139F 8938      LDD	R19,Y+16
    013A0 1902      SUB	R16,R2
    013A1 0913      SBC	R17,R3
    013A2 0924      SBC	R18,R4
    013A3 0935      SBC	R19,R5
    013A4 A1ED      LDD	R30,Y+37
    013A5 A1FE      LDD	R31,Y+38
    013A6 9632      ADIW	R30,2
    013A7 8020      LD	R2,Z
    013A8 2433      CLR	R3
    013A9 2444      CLR	R4
    013AA 2455      CLR	R5
    013AB 925A      ST	-Y,R5
    013AC 924A      ST	-Y,R4
    013AD 923A      ST	-Y,R3
    013AE 922A      ST	-Y,R2
    013AF 940E 4071 CALL	div32u
    013B1 8709      STD	Y+9,R16
    013B2 871A      STD	Y+10,R17
    013B3 872B      STD	Y+11,R18
    013B4 873C      STD	Y+12,R19
(2110) 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    013B5 8429      LDD	R2,Y+9
    013B6 843A      LDD	R3,Y+10
    013B7 844B      LDD	R4,Y+11
    013B8 845C      LDD	R5,Y+12
    013B9 9488      BCLR	0
    013BA 2022      TST	R2
    013BB 0432      CPC	R3,R2
    013BC 0442      CPC	R4,R2
    013BD 0452      CPC	R5,R2
    013BE F411      BNE	0x13C1
    013BF E00D      LDI	R16,0xD
    013C0 C2A2      RJMP	0x1663
(2111) 	fmt = FS_FAT12;
    013C1 24CC      CLR	R12
    013C2 94C3      INC	R12
(2112) 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    013C3 EF46      LDI	R20,0xF6
    013C4 E05F      LDI	R21,0xF
    013C5 E060      LDI	R22,0
    013C6 E070      LDI	R23,0
    013C7 8429      LDD	R2,Y+9
    013C8 843A      LDD	R3,Y+10
    013C9 844B      LDD	R4,Y+11
    013CA 845C      LDD	R5,Y+12
    013CB 1624      CP	R2,R20
    013CC 0635      CPC	R3,R21
    013CD 0646      CPC	R4,R22
    013CE 0657      CPC	R5,R23
    013CF F010      BCS	0x13D2
    013D0 E082      LDI	R24,2
    013D1 2EC8      MOV	R12,R24
(2113) 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    013D2 EF46      LDI	R20,0xF6
    013D3 EF5F      LDI	R21,0xFF
    013D4 E060      LDI	R22,0
    013D5 E070      LDI	R23,0
    013D6 8429      LDD	R2,Y+9
    013D7 843A      LDD	R3,Y+10
    013D8 844B      LDD	R4,Y+11
    013D9 845C      LDD	R5,Y+12
    013DA 1624      CP	R2,R20
    013DB 0635      CPC	R3,R21
    013DC 0646      CPC	R4,R22
    013DD 0657      CPC	R5,R23
    013DE F010      BCS	0x13E1
    013DF E083      LDI	R24,3
    013E0 2EC8      MOV	R12,R24
(2114) 
(2115) 	/* Boundaries and Limits */
(2116) 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    013E1 E042      LDI	R20,2
    013E2 E050      LDI	R21,0
    013E3 E060      LDI	R22,0
    013E4 E070      LDI	R23,0
    013E5 8429      LDD	R2,Y+9
    013E6 843A      LDD	R3,Y+10
    013E7 844B      LDD	R4,Y+11
    013E8 845C      LDD	R5,Y+12
    013E9 0E24      ADD	R2,R20
    013EA 1E35      ADC	R3,R21
    013EB 1E46      ADC	R4,R22
    013EC 1E57      ADC	R5,R23
    013ED A1ED      LDD	R30,Y+37
    013EE A1FE      LDD	R31,Y+38
    013EF 9676      ADIW	R30,0x16
    013F0 8220      ST	Z,R2
    013F1 8231      STD	Z+1,R3
    013F2 8242      STD	Z+2,R4
    013F3 8253      STD	Z+3,R5
(2117) 	fs->database = bsect + sysect;						/* Data start sector */
    013F4 882D      LDD	R2,Y+21
    013F5 883E      LDD	R3,Y+22
    013F6 884F      LDD	R4,Y+23
    013F7 8C58      LDD	R5,Y+24
    013F8 8869      LDD	R6,Y+17
    013F9 887A      LDD	R7,Y+18
    013FA 888B      LDD	R8,Y+19
    013FB 889C      LDD	R9,Y+20
    013FC 0C62      ADD	R6,R2
    013FD 1C73      ADC	R7,R3
    013FE 1C84      ADC	R8,R4
    013FF 1C95      ADC	R9,R5
    01400 A1ED      LDD	R30,Y+37
    01401 A1FE      LDD	R31,Y+38
    01402 96B6      ADIW	R30,0x26
    01403 8260      ST	Z,R6
    01404 8271      STD	Z+1,R7
    01405 8282      STD	Z+2,R8
    01406 8293      STD	Z+3,R9
(2118) 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    01407 0117      MOVW	R2,R14
    01408 2444      CLR	R4
    01409 2455      CLR	R5
    0140A 8869      LDD	R6,Y+17
    0140B 887A      LDD	R7,Y+18
    0140C 888B      LDD	R8,Y+19
    0140D 889C      LDD	R9,Y+20
    0140E 0C62      ADD	R6,R2
    0140F 1C73      ADC	R7,R3
    01410 1C84      ADC	R8,R4
    01411 1C95      ADC	R9,R5
    01412 A1ED      LDD	R30,Y+37
    01413 A1FE      LDD	R31,Y+38
    01414 8E66      STD	Z+30,R6
    01415 8E77      STD	Z+31,R7
    01416 A280      STD	Z+32,R8
    01417 A291      STD	Z+33,R9
(2119) 	if (fmt == FS_FAT32) {
    01418 2D8C      MOV	R24,R12
    01419 3083      CPI	R24,3
    0141A F009      BEQ	0x141C
    0141B C055      RJMP	0x1471
(2120) 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    0141C 8420      LDD	R2,Z+8
    0141D 8431      LDD	R3,Z+9
    0141E 2022      TST	R2
    0141F F411      BNE	0x1422
    01420 2033      TST	R3
    01421 F011      BEQ	0x1424
    01422 E00D      LDI	R16,0xD
    01423 C23F      RJMP	0x1663
(2121) 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    01424 E188      LDI	R24,0x18
    01425 E090      LDI	R25,0
    01426 A1ED      LDD	R30,Y+37
    01427 A1FE      LDD	R31,Y+38
    01428 5AE3      SUBI	R30,0xA3
    01429 4FFF      SBCI	R31,0xFF
    0142A 8100      LD	R16,Z
    0142B 2711      CLR	R17
    0142C 2722      CLR	R18
    0142D 2733      CLR	R19
    0142E 938A      ST	-Y,R24
    0142F 940E 41ED CALL	lsl32
    01431 0118      MOVW	R2,R16
    01432 0129      MOVW	R4,R18
    01433 A1ED      LDD	R30,Y+37
    01434 A1FE      LDD	R31,Y+38
    01435 5AE4      SUBI	R30,0xA4
    01436 4FFF      SBCI	R31,0xFF
    01437 8060      LD	R6,Z
    01438 55EC      SUBI	R30,0x5C
    01439 40F0      SBCI	R31,0
    0143A 2477      CLR	R7
    0143B 2488      CLR	R8
    0143C 2499      CLR	R9
    0143D 0143      MOVW	R8,R6
    0143E 2466      CLR	R6
    0143F 2477      CLR	R7
    01440 2826      OR	R2,R6
    01441 2837      OR	R3,R7
    01442 2848      OR	R4,R8
    01443 2859      OR	R5,R9
    01444 5AE5      SUBI	R30,0xA5
    01445 4FFF      SBCI	R31,0xFF
    01446 8060      LD	R6,Z
    01447 55EB      SUBI	R30,0x5B
    01448 40F0      SBCI	R31,0
    01449 2477      CLR	R7
    0144A 2C76      MOV	R7,R6
    0144B 2466      CLR	R6
    0144C 2488      CLR	R8
    0144D 2499      CLR	R9
    0144E 2826      OR	R2,R6
    0144F 2837      OR	R3,R7
    01450 2848      OR	R4,R8
    01451 2859      OR	R5,R9
    01452 5AE6      SUBI	R30,0xA6
    01453 4FFF      SBCI	R31,0xFF
    01454 8060      LD	R6,Z
    01455 55EA      SUBI	R30,0x5A
    01456 40F0      SBCI	R31,0
    01457 2477      CLR	R7
    01458 2488      CLR	R8
    01459 2499      CLR	R9
    0145A 2826      OR	R2,R6
    0145B 2837      OR	R3,R7
    0145C 2848      OR	R4,R8
    0145D 2859      OR	R5,R9
    0145E A222      STD	Z+34,R2
    0145F A233      STD	Z+35,R3
    01460 A244      STD	Z+36,R4
    01461 A255      STD	Z+37,R5
(2122) 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    01462 E082      LDI	R24,2
    01463 E090      LDI	R25,0
    01464 9676      ADIW	R30,0x16
    01465 8100      LD	R16,Z
    01466 8111      LDD	R17,Z+1
    01467 8122      LDD	R18,Z+2
    01468 8133      LDD	R19,Z+3
    01469 938A      ST	-Y,R24
    0146A 940E 41ED CALL	lsl32
    0146C 8F09      STD	Y+25,R16
    0146D 8F1A      STD	Y+26,R17
    0146E 8F2B      STD	Y+27,R18
    0146F 8F3C      STD	Y+28,R19
(2123) 	} else {
    01470 C06A      RJMP	0x14DB
(2124) 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    01471 A1ED      LDD	R30,Y+37
    01472 A1FE      LDD	R31,Y+38
    01473 8420      LDD	R2,Z+8
    01474 8431      LDD	R3,Z+9
    01475 2022      TST	R2
    01476 F421      BNE	0x147B
    01477 2033      TST	R3
    01478 F411      BNE	0x147B
    01479 E00D      LDI	R16,0xD
    0147A C1E8      RJMP	0x1663
(2125) 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    0147B 802D      LDD	R2,Y+5
    0147C 803E      LDD	R3,Y+6
    0147D 804F      LDD	R4,Y+7
    0147E 8458      LDD	R5,Y+8
    0147F A1ED      LDD	R30,Y+37
    01480 A1FE      LDD	R31,Y+38
    01481 8C66      LDD	R6,Z+30
    01482 8C77      LDD	R7,Z+31
    01483 A080      LDD	R8,Z+32
    01484 A091      LDD	R9,Z+33
    01485 0C62      ADD	R6,R2
    01486 1C73      ADC	R7,R3
    01487 1C84      ADC	R8,R4
    01488 1C95      ADC	R9,R5
    01489 A262      STD	Z+34,R6
    0148A A273      STD	Z+35,R7
    0148B A284      STD	Z+36,R8
    0148C A295      STD	Z+37,R9
(2126) 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    0148D 2D8C      MOV	R24,R12
    0148E 3082      CPI	R24,2
    0148F F471      BNE	0x149E
    01490 9676      ADIW	R30,0x16
    01491 8020      LD	R2,Z
    01492 8031      LDD	R3,Z+1
    01493 8042      LDD	R4,Z+2
    01494 8053      LDD	R5,Z+3
    01495 0C22      LSL	R2
    01496 1C33      ROL	R3
    01497 1C44      ROL	R4
    01498 1C55      ROL	R5
    01499 8E2D      STD	Y+29,R2
    0149A 8E3E      STD	Y+30,R3
    0149B 8E4F      STD	Y+31,R4
    0149C A258      STD	Y+32,R5
    0149D C035      RJMP	0x14D3
    0149E A1ED      LDD	R30,Y+37
    0149F A1FE      LDD	R31,Y+38
    014A0 9676      ADIW	R30,0x16
    014A1 8020      LD	R2,Z
    014A2 8031      LDD	R3,Z+1
    014A3 8042      LDD	R4,Z+2
    014A4 8053      LDD	R5,Z+3
    014A5 A229      STD	Y+33,R2
    014A6 A23A      STD	Y+34,R3
    014A7 A24B      STD	Y+35,R4
    014A8 A25C      STD	Y+36,R5
    014A9 E041      LDI	R20,1
    014AA E050      LDI	R21,0
    014AB E060      LDI	R22,0
    014AC E070      LDI	R23,0
    014AD A029      LDD	R2,Y+33
    014AE A03A      LDD	R3,Y+34
    014AF A04B      LDD	R4,Y+35
    014B0 A05C      LDD	R5,Y+36
    014B1 2224      AND	R2,R20
    014B2 2235      AND	R3,R21
    014B3 2246      AND	R4,R22
    014B4 2257      AND	R5,R23
    014B5 A069      LDD	R6,Y+33
    014B6 A07A      LDD	R7,Y+34
    014B7 A08B      LDD	R8,Y+35
    014B8 A09C      LDD	R9,Y+36
    014B9 E043      LDI	R20,3
    014BA E050      LDI	R21,0
    014BB E060      LDI	R22,0
    014BC E070      LDI	R23,0
    014BD 929A      ST	-Y,R9
    014BE 928A      ST	-Y,R8
    014BF 927A      ST	-Y,R7
    014C0 926A      ST	-Y,R6
    014C1 018A      MOVW	R16,R20
    014C2 019B      MOVW	R18,R22
    014C3 940E 4117 CALL	empy32u|empy32s
    014C5 0138      MOVW	R6,R16
    014C6 0149      MOVW	R8,R18
    014C7 9496      LSR	R9
    014C8 9487      ROR	R8
    014C9 9477      ROR	R7
    014CA 9467      ROR	R6
    014CB 0C62      ADD	R6,R2
    014CC 1C73      ADC	R7,R3
    014CD 1C84      ADC	R8,R4
    014CE 1C95      ADC	R9,R5
    014CF 8E6D      STD	Y+29,R6
    014D0 8E7E      STD	Y+30,R7
    014D1 8E8F      STD	Y+31,R8
    014D2 A298      STD	Y+32,R9
    014D3 8C2D      LDD	R2,Y+29
    014D4 8C3E      LDD	R3,Y+30
    014D5 8C4F      LDD	R4,Y+31
    014D6 A058      LDD	R5,Y+32
    014D7 8E29      STD	Y+25,R2
    014D8 8E3A      STD	Y+26,R3
    014D9 8E4B      STD	Y+27,R4
    014DA 8E5C      STD	Y+28,R5
(2127) 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
(2128) 	}
(2129) 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    014DB EF4F      LDI	R20,0xFF
    014DC E051      LDI	R21,1
    014DD E060      LDI	R22,0
    014DE E070      LDI	R23,0
    014DF 8D09      LDD	R16,Y+25
    014E0 8D1A      LDD	R17,Y+26
    014E1 8D2B      LDD	R18,Y+27
    014E2 8D3C      LDD	R19,Y+28
    014E3 0F04      ADD	R16,R20
    014E4 1F15      ADC	R17,R21
    014E5 1F26      ADC	R18,R22
    014E6 1F37      ADC	R19,R23
    014E7 E089      LDI	R24,0x9
    014E8 E090      LDI	R25,0
    014E9 938A      ST	-Y,R24
    014EA 940E 4206 CALL	lsr32
    014EC A1ED      LDD	R30,Y+37
    014ED A1FE      LDD	R31,Y+38
    014EE 8C22      LDD	R2,Z+26
    014EF 8C33      LDD	R3,Z+27
    014F0 8C44      LDD	R4,Z+28
    014F1 8C55      LDD	R5,Z+29
    014F2 1620      CP	R2,R16
    014F3 0631      CPC	R3,R17
    014F4 0642      CPC	R4,R18
    014F5 0653      CPC	R5,R19
    014F6 F410      BCC	0x14F9
(2130) 		return FR_NO_FILESYSTEM;
    014F7 E00D      LDI	R16,0xD
    014F8 C16A      RJMP	0x1663
(2131) 
(2132) #if !_FS_READONLY
(2133) 	/* Initialize cluster allocation information */
(2134) 	fs->free_clust = 0xFFFFFFFF;
    014F9 A1ED      LDD	R30,Y+37
    014FA A1FE      LDD	R31,Y+38
    014FB 963E      ADIW	R30,0xE
    014FC EF8F      LDI	R24,0xFF
    014FD 8380      ST	Z,R24
    014FE 8381      STD	Z+1,R24
    014FF 8382      STD	Z+2,R24
    01500 8383      STD	Z+3,R24
(2135) 	fs->last_clust = 0;
    01501 A1ED      LDD	R30,Y+37
    01502 A1FE      LDD	R31,Y+38
    01503 963A      ADIW	R30,0xA
    01504 E080      LDI	R24,0
    01505 8380      ST	Z,R24
    01506 8381      STD	Z+1,R24
    01507 8382      STD	Z+2,R24
    01508 8383      STD	Z+3,R24
(2136) 
(2137) 	/* Get fsinfo if available */
(2138) 	if (fmt == FS_FAT32) {
    01509 2D8C      MOV	R24,R12
    0150A 3083      CPI	R24,3
    0150B F009      BEQ	0x150D
    0150C C13C      RJMP	0x1649
(2139) 	 	fs->fsi_flag = 0;
    0150D 2422      CLR	R2
    0150E A1ED      LDD	R30,Y+37
    0150F A1FE      LDD	R31,Y+38
    01510 8225      STD	Z+5,R2
(2140) 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    01511 5AE2      SUBI	R30,0xA2
    01512 4FFF      SBCI	R31,0xFF
    01513 8020      LD	R2,Z
    01514 55EE      SUBI	R30,0x5E
    01515 40F0      SBCI	R31,0
    01516 2433      CLR	R3
    01517 5AE1      SUBI	R30,0xA1
    01518 4FFF      SBCI	R31,0xFF
    01519 8040      LD	R4,Z
    0151A 2455      CLR	R5
    0151B 2C54      MOV	R5,R4
    0151C 2444      CLR	R4
    0151D 2842      OR	R4,R2
    0151E 2853      OR	R5,R3
    0151F 0112      MOVW	R2,R4
    01520 2444      CLR	R4
    01521 2455      CLR	R5
    01522 8869      LDD	R6,Y+17
    01523 887A      LDD	R7,Y+18
    01524 888B      LDD	R8,Y+19
    01525 889C      LDD	R9,Y+20
    01526 0C62      ADD	R6,R2
    01527 1C73      ADC	R7,R3
    01528 1C84      ADC	R8,R4
    01529 1C95      ADC	R9,R5
    0152A A1ED      LDD	R30,Y+37
    0152B A1FE      LDD	R31,Y+38
    0152C 8A62      STD	Z+18,R6
    0152D 8A73      STD	Z+19,R7
    0152E 8A84      STD	Z+20,R8
    0152F 8A95      STD	Z+21,R9
(2141) 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    01530 E081      LDI	R24,1
    01531 838C      STD	Y+4,R24
    01532 8822      LDD	R2,Z+18
    01533 8833      LDD	R3,Z+19
    01534 8844      LDD	R4,Z+20
    01535 8855      LDD	R5,Z+21
    01536 8228      ST	Y,R2
    01537 8239      STD	Y+1,R3
    01538 824A      STD	Y+2,R4
    01539 825B      STD	Y+3,R5
    0153A 019F      MOVW	R18,R30
    0153B 5D22      SUBI	R18,0xD2
    0153C 4F3F      SBCI	R19,0xFF
    0153D 8101      LDD	R16,Z+1
    0153E 940E 02B5 CALL	_disk_read
    01540 2EE0      MOV	R14,R16
    01541 2300      TST	R16
    01542 F009      BEQ	0x1544
    01543 C105      RJMP	0x1649
    01544 A1ED      LDD	R30,Y+37
    01545 A1FE      LDD	R31,Y+38
    01546 5DE4      SUBI	R30,0xD4
    01547 4FFD      SBCI	R31,0xFD
    01548 8020      LD	R2,Z
    01549 52EC      SUBI	R30,0x2C
    0154A 40F2      SBCI	R31,2
    0154B 2433      CLR	R3
    0154C 5DE3      SUBI	R30,0xD3
    0154D 4FFD      SBCI	R31,0xFD
    0154E 8180      LD	R24,Z
    0154F 52ED      SUBI	R30,0x2D
    01550 40F2      SBCI	R31,2
    01551 2799      CLR	R25
    01552 2F98      MOV	R25,R24
    01553 2788      CLR	R24
    01554 2982      OR	R24,R2
    01555 2993      OR	R25,R3
    01556 3585      CPI	R24,0x55
    01557 EAAA      LDI	R26,0xAA
    01558 079A      CPC	R25,R26
    01559 F009      BEQ	0x155B
    0155A C0EE      RJMP	0x1649
    0155B E188      LDI	R24,0x18
    0155C E090      LDI	R25,0
    0155D A901      LDD	R16,Z+49
    0155E 2711      CLR	R17
    0155F 2722      CLR	R18
    01560 2733      CLR	R19
    01561 938A      ST	-Y,R24
    01562 940E 41ED CALL	lsl32
    01564 0118      MOVW	R2,R16
    01565 0129      MOVW	R4,R18
    01566 A1ED      LDD	R30,Y+37
    01567 A1FE      LDD	R31,Y+38
    01568 A860      LDD	R6,Z+48
    01569 2477      CLR	R7
    0156A 2488      CLR	R8
    0156B 2499      CLR	R9
    0156C 0143      MOVW	R8,R6
    0156D 2466      CLR	R6
    0156E 2477      CLR	R7
    0156F 2826      OR	R2,R6
    01570 2837      OR	R3,R7
    01571 2848      OR	R4,R8
    01572 2859      OR	R5,R9
    01573 A467      LDD	R6,Z+47
    01574 2477      CLR	R7
    01575 2C76      MOV	R7,R6
    01576 2466      CLR	R6
    01577 2488      CLR	R8
    01578 2499      CLR	R9
    01579 2826      OR	R2,R6
    0157A 2837      OR	R3,R7
    0157B 2848      OR	R4,R8
    0157C 2859      OR	R5,R9
    0157D A466      LDD	R6,Z+46
    0157E 2477      CLR	R7
    0157F 2488      CLR	R8
    01580 2499      CLR	R9
    01581 2826      OR	R2,R6
    01582 2837      OR	R3,R7
    01583 2848      OR	R4,R8
    01584 2859      OR	R5,R9
    01585 E542      LDI	R20,0x52
    01586 E552      LDI	R21,0x52
    01587 E661      LDI	R22,0x61
    01588 E471      LDI	R23,0x41
    01589 1624      CP	R2,R20
    0158A 0635      CPC	R3,R21
    0158B 0646      CPC	R4,R22
    0158C 0657      CPC	R5,R23
    0158D F009      BEQ	0x158F
    0158E C0BA      RJMP	0x1649
    0158F E188      LDI	R24,0x18
    01590 E090      LDI	R25,0
    01591 5EEB      SUBI	R30,0xEB
    01592 4FFD      SBCI	R31,0xFD
    01593 8100      LD	R16,Z
    01594 2711      CLR	R17
    01595 2722      CLR	R18
    01596 2733      CLR	R19
    01597 938A      ST	-Y,R24
    01598 940E 41ED CALL	lsl32
    0159A 0118      MOVW	R2,R16
    0159B 0129      MOVW	R4,R18
    0159C A1ED      LDD	R30,Y+37
    0159D A1FE      LDD	R31,Y+38
    0159E 5EEC      SUBI	R30,0xEC
    0159F 4FFD      SBCI	R31,0xFD
    015A0 8060      LD	R6,Z
    015A1 51E4      SUBI	R30,0x14
    015A2 40F2      SBCI	R31,2
    015A3 2477      CLR	R7
    015A4 2488      CLR	R8
    015A5 2499      CLR	R9
    015A6 0143      MOVW	R8,R6
    015A7 2466      CLR	R6
    015A8 2477      CLR	R7
    015A9 2826      OR	R2,R6
    015AA 2837      OR	R3,R7
    015AB 2848      OR	R4,R8
    015AC 2859      OR	R5,R9
    015AD 5EED      SUBI	R30,0xED
    015AE 4FFD      SBCI	R31,0xFD
    015AF 8060      LD	R6,Z
    015B0 51E3      SUBI	R30,0x13
    015B1 40F2      SBCI	R31,2
    015B2 2477      CLR	R7
    015B3 2C76      MOV	R7,R6
    015B4 2466      CLR	R6
    015B5 2488      CLR	R8
    015B6 2499      CLR	R9
    015B7 2826      OR	R2,R6
    015B8 2837      OR	R3,R7
    015B9 2848      OR	R4,R8
    015BA 2859      OR	R5,R9
    015BB 5EEE      SUBI	R30,0xEE
    015BC 4FFD      SBCI	R31,0xFD
    015BD 8060      LD	R6,Z
    015BE 51E2      SUBI	R30,0x12
    015BF 40F2      SBCI	R31,2
    015C0 2477      CLR	R7
    015C1 2488      CLR	R8
    015C2 2499      CLR	R9
    015C3 2826      OR	R2,R6
    015C4 2837      OR	R3,R7
    015C5 2848      OR	R4,R8
    015C6 2859      OR	R5,R9
    015C7 E742      LDI	R20,0x72
    015C8 E752      LDI	R21,0x72
    015C9 E461      LDI	R22,0x41
    015CA E671      LDI	R23,0x61
    015CB 1624      CP	R2,R20
    015CC 0635      CPC	R3,R21
    015CD 0646      CPC	R4,R22
    015CE 0657      CPC	R5,R23
    015CF F009      BEQ	0x15D1
    015D0 C078      RJMP	0x1649
(2142) 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
(2143) 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
(2144) 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
(2145) 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    015D1 E188      LDI	R24,0x18
    015D2 E090      LDI	R25,0
    015D3 5EE3      SUBI	R30,0xE3
    015D4 4FFD      SBCI	R31,0xFD
    015D5 8100      LD	R16,Z
    015D6 2711      CLR	R17
    015D7 2722      CLR	R18
    015D8 2733      CLR	R19
    015D9 938A      ST	-Y,R24
    015DA 940E 41ED CALL	lsl32
    015DC 0118      MOVW	R2,R16
    015DD 0129      MOVW	R4,R18
    015DE A1ED      LDD	R30,Y+37
    015DF A1FE      LDD	R31,Y+38
    015E0 5EE4      SUBI	R30,0xE4
    015E1 4FFD      SBCI	R31,0xFD
    015E2 8060      LD	R6,Z
    015E3 51EC      SUBI	R30,0x1C
    015E4 40F2      SBCI	R31,2
    015E5 2477      CLR	R7
    015E6 2488      CLR	R8
    015E7 2499      CLR	R9
    015E8 0143      MOVW	R8,R6
    015E9 2466      CLR	R6
    015EA 2477      CLR	R7
    015EB 2826      OR	R2,R6
    015EC 2837      OR	R3,R7
    015ED 2848      OR	R4,R8
    015EE 2859      OR	R5,R9
    015EF 5EE5      SUBI	R30,0xE5
    015F0 4FFD      SBCI	R31,0xFD
    015F1 8060      LD	R6,Z
    015F2 51EB      SUBI	R30,0x1B
    015F3 40F2      SBCI	R31,2
    015F4 2477      CLR	R7
    015F5 2C76      MOV	R7,R6
    015F6 2466      CLR	R6
    015F7 2488      CLR	R8
    015F8 2499      CLR	R9
    015F9 2826      OR	R2,R6
    015FA 2837      OR	R3,R7
    015FB 2848      OR	R4,R8
    015FC 2859      OR	R5,R9
    015FD 5EE6      SUBI	R30,0xE6
    015FE 4FFD      SBCI	R31,0xFD
    015FF 8060      LD	R6,Z
    01600 51EA      SUBI	R30,0x1A
    01601 40F2      SBCI	R31,2
    01602 2477      CLR	R7
    01603 2488      CLR	R8
    01604 2499      CLR	R9
    01605 2826      OR	R2,R6
    01606 2837      OR	R3,R7
    01607 2848      OR	R4,R8
    01608 2859      OR	R5,R9
    01609 8622      STD	Z+10,R2
    0160A 8633      STD	Z+11,R3
    0160B 8644      STD	Z+12,R4
    0160C 8655      STD	Z+13,R5
(2146) 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    0160D E188      LDI	R24,0x18
    0160E E090      LDI	R25,0
    0160F 5EE7      SUBI	R30,0xE7
    01610 4FFD      SBCI	R31,0xFD
    01611 8100      LD	R16,Z
    01612 2711      CLR	R17
    01613 2722      CLR	R18
    01614 2733      CLR	R19
    01615 938A      ST	-Y,R24
    01616 940E 41ED CALL	lsl32
    01618 0118      MOVW	R2,R16
    01619 0129      MOVW	R4,R18
    0161A A1ED      LDD	R30,Y+37
    0161B A1FE      LDD	R31,Y+38
    0161C 5EE8      SUBI	R30,0xE8
    0161D 4FFD      SBCI	R31,0xFD
    0161E 8060      LD	R6,Z
    0161F 51E8      SUBI	R30,0x18
    01620 40F2      SBCI	R31,2
    01621 2477      CLR	R7
    01622 2488      CLR	R8
    01623 2499      CLR	R9
    01624 0143      MOVW	R8,R6
    01625 2466      CLR	R6
    01626 2477      CLR	R7
    01627 2826      OR	R2,R6
    01628 2837      OR	R3,R7
    01629 2848      OR	R4,R8
    0162A 2859      OR	R5,R9
    0162B 5EE9      SUBI	R30,0xE9
    0162C 4FFD      SBCI	R31,0xFD
    0162D 8060      LD	R6,Z
    0162E 51E7      SUBI	R30,0x17
    0162F 40F2      SBCI	R31,2
    01630 2477      CLR	R7
    01631 2C76      MOV	R7,R6
    01632 2466      CLR	R6
    01633 2488      CLR	R8
    01634 2499      CLR	R9
    01635 2826      OR	R2,R6
    01636 2837      OR	R3,R7
    01637 2848      OR	R4,R8
    01638 2859      OR	R5,R9
    01639 5EEA      SUBI	R30,0xEA
    0163A 4FFD      SBCI	R31,0xFD
    0163B 8060      LD	R6,Z
    0163C 51E6      SUBI	R30,0x16
    0163D 40F2      SBCI	R31,2
    0163E 2477      CLR	R7
    0163F 2488      CLR	R8
    01640 2499      CLR	R9
    01641 2826      OR	R2,R6
    01642 2837      OR	R3,R7
    01643 2848      OR	R4,R8
    01644 2859      OR	R5,R9
    01645 8626      STD	Z+14,R2
    01646 8637      STD	Z+15,R3
    01647 8A40      STD	Z+16,R4
    01648 8A51      STD	Z+17,R5
(2147) 		}
(2148) 	}
(2149) #endif
(2150) 	fs->fs_type = fmt;		/* FAT sub-type */
    01649 A1ED      LDD	R30,Y+37
    0164A A1FE      LDD	R31,Y+38
    0164B 82C0      ST	Z,R12
(2151) 	fs->id = ++Fsid;		/* File system mount ID */
    0164C 9180 051C LDS	R24,ff.c:Fsid
    0164E 9190 051D LDS	R25,ff.c:Fsid+1
    01650 9601      ADIW	R24,1
    01651 016C      MOVW	R12,R24
    01652 92D0 051D STS	ff.c:Fsid+1,R13
    01654 92C0 051C STS	ff.c:Fsid,R12
    01656 82D7      STD	Z+7,R13
    01657 82C6      STD	Z+6,R12
(2152) 	fs->winsect = 0;		/* Invalidate sector cache */
    01658 96BA      ADIW	R30,0x2A
    01659 E080      LDI	R24,0
    0165A 8380      ST	Z,R24
    0165B 8381      STD	Z+1,R24
    0165C 8382      STD	Z+2,R24
    0165D 8383      STD	Z+3,R24
(2153) 	fs->wflag = 0;
    0165E 2422      CLR	R2
    0165F A1ED      LDD	R30,Y+37
    01660 A1FE      LDD	R31,Y+38
    01661 8224      STD	Z+4,R2
(2154) #if _FS_RPATH
(2155) 	fs->cdir = 0;			/* Current directory (root dir) */
(2156) #endif
(2157) #if _FS_SHARE				/* Clear file lock semaphores */
(2158) 	clear_lock(fs);
(2159) #endif
(2160) 
(2161) 	return FR_OK;
    01662 2700      CLR	R16
    01663 96A7      ADIW	R28,0x27
    01664 940E 4160 CALL	pop_xgsetF0FC
    01666 9622      ADIW	R28,2
    01667 9508      RET
ff.c:validate:
  id                   --> R10
  fs                   --> R20
    01668 940E 4176 CALL	push_xgset300C
    0166A 0159      MOVW	R10,R18
    0166B 01A8      MOVW	R20,R16
(2162) }
(2163) 
(2164) 
(2165) 
(2166) 
(2167) /*-----------------------------------------------------------------------*/
(2168) /* Check if the file/dir object is valid or not                          */
(2169) /*-----------------------------------------------------------------------*/
(2170) 
(2171) static
(2172) FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
(2173) 	FATFS *fs,		/* Pointer to the file system object */
(2174) 	WORD id			/* Member id of the target object to be checked */
(2175) )
(2176) {
(2177) 	if (!fs || !fs->fs_type || fs->id != id)
    0166C 3040      CPI	R20,0
    0166D 0745      CPC	R20,R21
    0166E F049      BEQ	0x1678
    0166F 01FA      MOVW	R30,R20
    01670 8020      LD	R2,Z
    01671 2022      TST	R2
    01672 F029      BEQ	0x1678
    01673 8026      LDD	R2,Z+6
    01674 8037      LDD	R3,Z+7
    01675 142A      CP	R2,R10
    01676 043B      CPC	R3,R11
    01677 F011      BEQ	0x167A
(2178) 		return FR_INVALID_OBJECT;
    01678 E009      LDI	R16,0x9
    01679 C009      RJMP	0x1683
(2179) 
(2180) 	ENTER_FF(fs);		/* Lock file system */
(2181) 
(2182) 	if (disk_status(fs->drv) & STA_NOINIT)
    0167A 01FA      MOVW	R30,R20
    0167B 8101      LDD	R16,Z+1
    0167C 940E 02AF CALL	_disk_status
    0167E FF00      SBRS	R16,0
    0167F C002      RJMP	0x1682
(2183) 		return FR_NOT_READY;
    01680 E003      LDI	R16,3
    01681 C001      RJMP	0x1683
(2184) 
(2185) 	return FR_OK;
    01682 2700      CLR	R16
    01683 940C 417B JMP	pop_xgset300C
_f_mount:
  rfs                  --> R10
  fs                   --> R18
  vol                  --> R16
    01685 92AA      ST	-Y,R10
    01686 92BA      ST	-Y,R11
(2186) }
(2187) 
(2188) 
(2189) 
(2190) 
(2191) /*--------------------------------------------------------------------------
(2192) 
(2193)    Public Functions
(2194) 
(2195) --------------------------------------------------------------------------*/
(2196) 
(2197) 
(2198) 
(2199) /*-----------------------------------------------------------------------*/
(2200) /* Mount/Unmount a Logical Drive                                         */
(2201) /*-----------------------------------------------------------------------*/
(2202) 
(2203) FRESULT f_mount (
(2204) 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
(2205) 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
(2206) )
(2207) {
(2208) 	FATFS *rfs;
(2209) 
(2210) 
(2211) 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    01687 3001      CPI	R16,1
    01688 F010      BCS	0x168B
(2212) 		return FR_INVALID_DRIVE;
    01689 E00B      LDI	R16,0xB
    0168A C022      RJMP	0x16AD
(2213) 	rfs = FatFs[vol];			/* Get current fs object */
    0168B E18E      LDI	R24,0x1E
    0168C E095      LDI	R25,5
    0168D 2FE0      MOV	R30,R16
    0168E 27FF      CLR	R31
    0168F 0FEE      LSL	R30
    01690 1FFF      ROL	R31
    01691 0FE8      ADD	R30,R24
    01692 1FF9      ADC	R31,R25
    01693 80A0      LD	R10,Z
    01694 80B1      LDD	R11,Z+1
(2214) 
(2215) 	if (rfs) {
    01695 20AA      TST	R10
    01696 F411      BNE	0x1699
    01697 20BB      TST	R11
    01698 F019      BEQ	0x169C
(2216) #if _FS_SHARE
(2217) 		clear_lock(rfs);
(2218) #endif
(2219) #if _FS_REENTRANT				/* Discard sync object of the current volume */
(2220) 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
(2221) #endif
(2222) 		rfs->fs_type = 0;		/* Clear old fs object */
    01699 2422      CLR	R2
    0169A 01F5      MOVW	R30,R10
    0169B 8220      ST	Z,R2
(2223) 	}
(2224) 
(2225) 	if (fs) {
    0169C 3020      CPI	R18,0
    0169D 0723      CPC	R18,R19
    0169E F019      BEQ	0x16A2
(2226) 		fs->fs_type = 0;		/* Clear new fs object */
    0169F 2422      CLR	R2
    016A0 01F9      MOVW	R30,R18
    016A1 8220      ST	Z,R2
(2227) #if _FS_REENTRANT				/* Create sync object for the new volume */
(2228) 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
(2229) #endif
(2230) 	}
(2231) 	FatFs[vol] = fs;			/* Register new fs object */
    016A2 E18E      LDI	R24,0x1E
    016A3 E095      LDI	R25,5
    016A4 2FE0      MOV	R30,R16
    016A5 27FF      CLR	R31
    016A6 0FEE      LSL	R30
    016A7 1FFF      ROL	R31
    016A8 0FE8      ADD	R30,R24
    016A9 1FF9      ADC	R31,R25
    016AA 8331      STD	Z+1,R19
    016AB 8320      ST	Z,R18
(2232) 
(2233) 	return FR_OK;
    016AC 2700      CLR	R16
    016AD 90B9      LD	R11,Y+
    016AE 90A9      LD	R10,Y+
    016AF 9508      RET
_f_open:
  cl                   --> Y,+40
  dw                   --> Y,+36
  sfn                  --> Y,+24
  dj                   --> Y,+2
  res                  --> R10
  dir                  --> R14
  mode                 --> Y,+58
  path                 --> Y,+56
  fp                   --> Y,+54
    016B0 940E 4026 CALL	push_arg4
    016B2 940E 416B CALL	push_xgsetF0FC
    016B4 97AC      SBIW	R28,0x2C
(2234) }
(2235) 
(2236) 
(2237) 
(2238) 
(2239) /*-----------------------------------------------------------------------*/
(2240) /* Open or Create a File                                                 */
(2241) /*-----------------------------------------------------------------------*/
(2242) 
(2243) FRESULT f_open (
(2244) 	FIL *fp,			/* Pointer to the blank file object */
(2245) 	const TCHAR *path,	/* Pointer to the file name */
(2246) 	BYTE mode			/* Access mode and file open mode flags */
(2247) )
(2248) {
(2249) 	FRESULT res;
(2250) 	DIR dj;
(2251) 	BYTE *dir;
(2252) 	DEF_NAMEBUF;
(2253) 
(2254) 
(2255) 	fp->fs = 0;			/* Clear file object */
    016B5 2422      CLR	R2
    016B6 2433      CLR	R3
    016B7 A9EE      LDD	R30,Y+54
    016B8 A9FF      LDD	R31,Y+55
    016B9 8231      STD	Z+1,R3
    016BA 8220      ST	Z,R2
(2256) 
(2257) #if !_FS_READONLY
(2258) 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    016BB AD8A      LDD	R24,Y+58
    016BC 718F      ANDI	R24,0x1F
    016BD AF8A      STD	Y+58,R24
(2259) 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    016BE 2799      CLR	R25
    016BF 7F8E      ANDI	R24,0xFE
    016C0 8388      ST	Y,R24
    016C1 019E      MOVW	R18,R28
    016C2 5F2E      SUBI	R18,0xFE
    016C3 4F3F      SBCI	R19,0xFF
    016C4 018E      MOVW	R16,R28
    016C5 5C08      SUBI	R16,0xC8
    016C6 4F1F      SBCI	R17,0xFF
    016C7 DAA6      RCALL	ff.c:chk_mounted
    016C8 2EA0      MOV	R10,R16
(2260) #else
(2261) 	mode &= FA_READ;
(2262) 	res = chk_mounted(&path, &dj.fs, 0);
(2263) #endif
(2264) 	INIT_BUF(dj);
    016C9 01CE      MOVW	R24,R28
    016CA 9648      ADIW	R24,0x18
    016CB 8B9F      STD	Y+23,R25
    016CC 8B8E      STD	Y+22,R24
(2265) 	if (res == FR_OK)
    016CD 2300      TST	R16
    016CE F439      BNE	0x16D6
(2266) 		res = follow_path(&dj, path);	/* Follow the file path */
    016CF AD28      LDD	R18,Y+56
    016D0 AD39      LDD	R19,Y+57
    016D1 018E      MOVW	R16,R28
    016D2 5F0E      SUBI	R16,0xFE
    016D3 4F1F      SBCI	R17,0xFF
    016D4 D94D      RCALL	ff.c:follow_path
    016D5 2EA0      MOV	R10,R16
(2267) 	dir = dj.dir;
    016D6 88EC      LDD	R14,Y+20
    016D7 88FD      LDD	R15,Y+21
(2268) 
(2269) #if !_FS_READONLY	/* R/W configuration */
(2270) 	if (res == FR_OK) {
    016D8 20AA      TST	R10
    016D9 F431      BNE	0x16E0
(2271) 		if (!dir)	/* Current dir itself */
    016DA 20EE      TST	R14
    016DB F421      BNE	0x16E0
    016DC 20FF      TST	R15
    016DD F411      BNE	0x16E0
(2272) 			res = FR_INVALID_NAME;
    016DE E086      LDI	R24,6
    016DF 2EA8      MOV	R10,R24
(2273) #if _FS_SHARE
(2274) 		else
(2275) 			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2276) #endif
(2277) 	}
(2278) 	/* Create or Open a file */
(2279) 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    016E0 AD8A      LDD	R24,Y+58
    016E1 718C      ANDI	R24,0x1C
    016E2 F409      BNE	0x16E4
    016E3 C0C0      RJMP	0x17A4
(2280) 		DWORD dw, cl;
(2281) 
(2282) 		if (res != FR_OK) {					/* No file, create new */
    016E4 20AA      TST	R10
    016E5 F081      BEQ	0x16F6
(2283) 			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    016E6 2D8A      MOV	R24,R10
    016E7 3084      CPI	R24,4
    016E8 F439      BNE	0x16F0
(2284) #if _FS_SHARE
(2285) 				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
(2286) #else
(2287) 				res = dir_register(&dj);
    016E9 018E      MOVW	R16,R28
    016EA 5F0E      SUBI	R16,0xFE
    016EB 4F1F      SBCI	R17,0xFF
    016EC 940E 0E14 CALL	ff.c:dir_register
    016EE 2EC0      MOV	R12,R16
    016EF 2CAC      MOV	R10,R12
(2288) #endif
(2289) 			mode |= FA_CREATE_ALWAYS;		/* File is created */
    016F0 AD8A      LDD	R24,Y+58
    016F1 6088      ORI	R24,0x8
    016F2 AF8A      STD	Y+58,R24
(2290) 			dir = dj.dir;					/* New entry */
    016F3 88EC      LDD	R14,Y+20
    016F4 88FD      LDD	R15,Y+21
(2291) 		}
    016F5 C00C      RJMP	0x1702
(2292) 		else {								/* Any object is already existing */
(2293) 			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    016F6 01F7      MOVW	R30,R14
    016F7 8583      LDD	R24,Z+11
    016F8 7181      ANDI	R24,0x11
    016F9 F019      BEQ	0x16FD
(2294) 				res = FR_DENIED;
    016FA E087      LDI	R24,7
    016FB 2EA8      MOV	R10,R24
(2295) 			} else {
    016FC C005      RJMP	0x1702
(2296) 				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    016FD AC0A      LDD	R0,Y+58
    016FE FE02      SBRS	R0,2
    016FF C002      RJMP	0x1702
(2297) 					res = FR_EXIST;
    01700 E088      LDI	R24,0x8
    01701 2EA8      MOV	R10,R24
(2298) 			}
(2299) 		}
(2300) 		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    01702 20AA      TST	R10
    01703 F009      BEQ	0x1705
    01704 C0B1      RJMP	0x17B6
    01705 AC0A      LDD	R0,Y+58
    01706 FE03      SBRS	R0,3
    01707 C0AE      RJMP	0x17B6
(2301) 			dw = get_fattime();					/* Created time */
    01708 940E 02F2 CALL	_get_fattime
    0170A A30C      STD	Y+36,R16
    0170B A31D      STD	Y+37,R17
    0170C A32E      STD	Y+38,R18
    0170D A33F      STD	Y+39,R19
(2302) 			ST_DWORD(dir+DIR_CrtTime, dw);
    0170E A02C      LDD	R2,Y+36
    0170F A03D      LDD	R3,Y+37
    01710 A04E      LDD	R4,Y+38
    01711 A05F      LDD	R5,Y+39
    01712 01F7      MOVW	R30,R14
    01713 8626      STD	Z+14,R2
    01714 2C23      MOV	R2,R3
    01715 2433      CLR	R3
    01716 963F      ADIW	R30,0xF
    01717 8220      ST	Z,R2
    01718 A02C      LDD	R2,Y+36
    01719 A03D      LDD	R3,Y+37
    0171A A04E      LDD	R4,Y+38
    0171B A05F      LDD	R5,Y+39
    0171C 0112      MOVW	R2,R4
    0171D 2444      CLR	R4
    0171E 2455      CLR	R5
    0171F 01F7      MOVW	R30,R14
    01720 9670      ADIW	R30,0x10
    01721 8220      ST	Z,R2
    01722 E188      LDI	R24,0x18
    01723 E090      LDI	R25,0
    01724 A10C      LDD	R16,Y+36
    01725 A11D      LDD	R17,Y+37
    01726 A12E      LDD	R18,Y+38
    01727 A13F      LDD	R19,Y+39
    01728 938A      ST	-Y,R24
    01729 940E 4206 CALL	lsr32
    0172B 01F7      MOVW	R30,R14
    0172C 8B01      STD	Z+17,R16
(2303) 			dir[DIR_Attr] = 0;					/* Reset attribute */
    0172D 2422      CLR	R2
    0172E 8623      STD	Z+11,R2
(2304) 			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    0172F 8E24      STD	Z+28,R2
    01730 8E25      STD	Z+29,R2
    01731 8E26      STD	Z+30,R2
    01732 8E27      STD	Z+31,R2
(2305) 			cl = LD_CLUST(dir);					/* Get start cluster */
    01733 8C22      LDD	R2,Z+26
    01734 2433      CLR	R3
    01735 8C43      LDD	R4,Z+27
    01736 2455      CLR	R5
    01737 2C54      MOV	R5,R4
    01738 2444      CLR	R4
    01739 2842      OR	R4,R2
    0173A 2853      OR	R5,R3
    0173B 0112      MOVW	R2,R4
    0173C 2444      CLR	R4
    0173D 2455      CLR	R5
    0173E 8864      LDD	R6,Z+20
    0173F 2477      CLR	R7
    01740 9675      ADIW	R30,0x15
    01741 8080      LD	R8,Z
    01742 2499      CLR	R9
    01743 2C98      MOV	R9,R8
    01744 2488      CLR	R8
    01745 2886      OR	R8,R6
    01746 2897      OR	R9,R7
    01747 0134      MOVW	R6,R8
    01748 2488      CLR	R8
    01749 2499      CLR	R9
    0174A 0143      MOVW	R8,R6
    0174B 2466      CLR	R6
    0174C 2477      CLR	R7
    0174D 2862      OR	R6,R2
    0174E 2873      OR	R7,R3
    0174F 2884      OR	R8,R4
    01750 2895      OR	R9,R5
    01751 A668      STD	Y+40,R6
    01752 A679      STD	Y+41,R7
    01753 A68A      STD	Y+42,R8
    01754 A69B      STD	Y+43,R9
(2306) 			ST_CLUST(dir, 0);					/* cluster = 0 */
    01755 2422      CLR	R2
    01756 01F7      MOVW	R30,R14
    01757 8E22      STD	Z+26,R2
    01758 8E23      STD	Z+27,R2
    01759 8A24      STD	Z+20,R2
    0175A 8A25      STD	Z+21,R2
(2307) 			dj.fs->wflag = 1;
    0175B E081      LDI	R24,1
    0175C 81EA      LDD	R30,Y+2
    0175D 81FB      LDD	R31,Y+3
    0175E 9634      ADIW	R30,4
    0175F 8380      ST	Z,R24
(2308) 			if (cl) {							/* Remove the cluster chain if exist */
    01760 A428      LDD	R2,Y+40
    01761 A439      LDD	R3,Y+41
    01762 A44A      LDD	R4,Y+42
    01763 A45B      LDD	R5,Y+43
    01764 9488      BCLR	0
    01765 2022      TST	R2
    01766 0432      CPC	R3,R2
    01767 0442      CPC	R4,R2
    01768 0452      CPC	R5,R2
    01769 F409      BNE	0x176B
    0176A C04B      RJMP	0x17B6
(2309) 				dw = dj.fs->winsect;
    0176B 81EA      LDD	R30,Y+2
    0176C 81FB      LDD	R31,Y+3
    0176D A422      LDD	R2,Z+42
    0176E A433      LDD	R3,Z+43
    0176F A444      LDD	R4,Z+44
    01770 A455      LDD	R5,Z+45
    01771 A22C      STD	Y+36,R2
    01772 A23D      STD	Y+37,R3
    01773 A24E      STD	Y+38,R4
    01774 A25F      STD	Y+39,R5
(2310) 				res = remove_chain(dj.fs, cl);
    01775 A428      LDD	R2,Y+40
    01776 A439      LDD	R3,Y+41
    01777 A44A      LDD	R4,Y+42
    01778 A45B      LDD	R5,Y+43
    01779 8248      ST	Y,R4
    0177A 8259      STD	Y+1,R5
    0177B 0191      MOVW	R18,R2
    0177C 810A      LDD	R16,Y+2
    0177D 811B      LDD	R17,Y+3
    0177E 940E 0828 CALL	ff.c:remove_chain
    01780 2EC0      MOV	R12,R16
    01781 2CAC      MOV	R10,R12
(2311) 				if (res == FR_OK) {
    01782 2300      TST	R16
    01783 F591      BNE	0x17B6
(2312) 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    01784 E041      LDI	R20,1
    01785 E050      LDI	R21,0
    01786 E060      LDI	R22,0
    01787 E070      LDI	R23,0
    01788 A428      LDD	R2,Y+40
    01789 A439      LDD	R3,Y+41
    0178A A44A      LDD	R4,Y+42
    0178B A45B      LDD	R5,Y+43
    0178C 1A24      SUB	R2,R20
    0178D 0A35      SBC	R3,R21
    0178E 0A46      SBC	R4,R22
    0178F 0A57      SBC	R5,R23
    01790 81EA      LDD	R30,Y+2
    01791 81FB      LDD	R31,Y+3
    01792 8622      STD	Z+10,R2
    01793 8633      STD	Z+11,R3
    01794 8644      STD	Z+12,R4
    01795 8655      STD	Z+13,R5
(2313) 					res = move_window(dj.fs, dw);
    01796 A02C      LDD	R2,Y+36
    01797 A03D      LDD	R3,Y+37
    01798 A04E      LDD	R4,Y+38
    01799 A05F      LDD	R5,Y+39
    0179A 8248      ST	Y,R4
    0179B 8259      STD	Y+1,R5
    0179C 0191      MOVW	R18,R2
    0179D 810A      LDD	R16,Y+2
    0179E 811B      LDD	R17,Y+3
    0179F 940E 0350 CALL	ff.c:move_window
    017A1 2EC0      MOV	R12,R16
    017A2 2CAC      MOV	R10,R12
(2314) 				}
(2315) 			}
(2316) 		}
(2317) 	}
    017A3 C012      RJMP	0x17B6
(2318) 	else {	/* Open an existing file */
(2319) 		if (res == FR_OK) {						/* Follow succeeded */
    017A4 20AA      TST	R10
    017A5 F481      BNE	0x17B6
(2320) 			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    017A6 01F7      MOVW	R30,R14
    017A7 8423      LDD	R2,Z+11
    017A8 FE24      SBRS	R2,4
    017A9 C003      RJMP	0x17AD
(2321) 				res = FR_NO_FILE;
    017AA E084      LDI	R24,4
    017AB 2EA8      MOV	R10,R24
(2322) 			} else {
    017AC C009      RJMP	0x17B6
(2323) 				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    017AD AC0A      LDD	R0,Y+58
    017AE FE01      SBRS	R0,1
    017AF C006      RJMP	0x17B6
    017B0 01F7      MOVW	R30,R14
    017B1 8423      LDD	R2,Z+11
    017B2 FE20      SBRS	R2,0
    017B3 C002      RJMP	0x17B6
(2324) 					res = FR_DENIED;
    017B4 E087      LDI	R24,7
    017B5 2EA8      MOV	R10,R24
(2325) 			}
(2326) 		}
(2327) 	}
(2328) 	if (res == FR_OK) {
    017B6 20AA      TST	R10
    017B7 F4A1      BNE	0x17CC
(2329) 		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    017B8 AC0A      LDD	R0,Y+58
    017B9 FE03      SBRS	R0,3
    017BA C003      RJMP	0x17BE
(2330) 			mode |= FA__WRITTEN;
    017BB 2D80      MOV	R24,R0
    017BC 6280      ORI	R24,0x20
    017BD AF8A      STD	Y+58,R24
(2331) 		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    017BE 81EA      LDD	R30,Y+2
    017BF 81FB      LDD	R31,Y+3
    017C0 A422      LDD	R2,Z+42
    017C1 A433      LDD	R3,Z+43
    017C2 A444      LDD	R4,Z+44
    017C3 A455      LDD	R5,Z+45
    017C4 A9EE      LDD	R30,Y+54
    017C5 A9FF      LDD	R31,Y+55
    017C6 8E22      STD	Z+26,R2
    017C7 8E33      STD	Z+27,R3
    017C8 8E44      STD	Z+28,R4
    017C9 8E55      STD	Z+29,R5
(2332) 		fp->dir_ptr = dir;
    017CA 8EF7      STD	Z+31,R15
    017CB 8EE6      STD	Z+30,R14
(2333) #if _FS_SHARE
(2334) 		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2335) 		if (!fp->lockid) res = FR_INT_ERR;
(2336) #endif
(2337) 	}
(2338) 
(2339) #else				/* R/O configuration */
(2340) 	if (res == FR_OK) {					/* Follow succeeded */
(2341) 		if (!dir) {						/* Current dir itself */
(2342) 			res = FR_INVALID_NAME;
(2343) 		} else {
(2344) 			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
(2345) 				res = FR_NO_FILE;
(2346) 		}
(2347) 	}
(2348) #endif
(2349) 	FREE_BUF();
(2350) 
(2351) 	if (res == FR_OK) {
    017CC 20AA      TST	R10
    017CD F009      BEQ	0x17CF
    017CE C077      RJMP	0x1846
(2352) 		fp->flag = mode;					/* File access mode */
    017CF A9EE      LDD	R30,Y+54
    017D0 A9FF      LDD	R31,Y+55
    017D1 AC0A      LDD	R0,Y+58
    017D2 8204      STD	Z+4,R0
(2353) 		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    017D3 01F7      MOVW	R30,R14
    017D4 8C22      LDD	R2,Z+26
    017D5 2433      CLR	R3
    017D6 8C43      LDD	R4,Z+27
    017D7 2455      CLR	R5
    017D8 2C54      MOV	R5,R4
    017D9 2444      CLR	R4
    017DA 2842      OR	R4,R2
    017DB 2853      OR	R5,R3
    017DC 0112      MOVW	R2,R4
    017DD 2444      CLR	R4
    017DE 2455      CLR	R5
    017DF 8864      LDD	R6,Z+20
    017E0 2477      CLR	R7
    017E1 8885      LDD	R8,Z+21
    017E2 2499      CLR	R9
    017E3 2C98      MOV	R9,R8
    017E4 2488      CLR	R8
    017E5 2886      OR	R8,R6
    017E6 2897      OR	R9,R7
    017E7 0134      MOVW	R6,R8
    017E8 2488      CLR	R8
    017E9 2499      CLR	R9
    017EA 0143      MOVW	R8,R6
    017EB 2466      CLR	R6
    017EC 2477      CLR	R7
    017ED 2862      OR	R6,R2
    017EE 2873      OR	R7,R3
    017EF 2884      OR	R8,R4
    017F0 2895      OR	R9,R5
    017F1 A9EE      LDD	R30,Y+54
    017F2 A9FF      LDD	R31,Y+55
    017F3 8666      STD	Z+14,R6
    017F4 8677      STD	Z+15,R7
    017F5 8A80      STD	Z+16,R8
    017F6 8A91      STD	Z+17,R9
(2354) 		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    017F7 E188      LDI	R24,0x18
    017F8 E090      LDI	R25,0
    017F9 01F7      MOVW	R30,R14
    017FA 8D07      LDD	R16,Z+31
    017FB 2711      CLR	R17
    017FC 2722      CLR	R18
    017FD 2733      CLR	R19
    017FE 938A      ST	-Y,R24
    017FF 940E 41ED CALL	lsl32
    01801 0118      MOVW	R2,R16
    01802 0129      MOVW	R4,R18
    01803 01F7      MOVW	R30,R14
    01804 8C66      LDD	R6,Z+30
    01805 2477      CLR	R7
    01806 2488      CLR	R8
    01807 2499      CLR	R9
    01808 0143      MOVW	R8,R6
    01809 2466      CLR	R6
    0180A 2477      CLR	R7
    0180B 2826      OR	R2,R6
    0180C 2837      OR	R3,R7
    0180D 2848      OR	R4,R8
    0180E 2859      OR	R5,R9
    0180F 8C65      LDD	R6,Z+29
    01810 2477      CLR	R7
    01811 2C76      MOV	R7,R6
    01812 2466      CLR	R6
    01813 2488      CLR	R8
    01814 2499      CLR	R9
    01815 2826      OR	R2,R6
    01816 2837      OR	R3,R7
    01817 2848      OR	R4,R8
    01818 2859      OR	R5,R9
    01819 8C64      LDD	R6,Z+28
    0181A 2477      CLR	R7
    0181B 2488      CLR	R8
    0181C 2499      CLR	R9
    0181D 2826      OR	R2,R6
    0181E 2837      OR	R3,R7
    0181F 2848      OR	R4,R8
    01820 2859      OR	R5,R9
    01821 A9EE      LDD	R30,Y+54
    01822 A9FF      LDD	R31,Y+55
    01823 8622      STD	Z+10,R2
    01824 8633      STD	Z+11,R3
    01825 8644      STD	Z+12,R4
    01826 8655      STD	Z+13,R5
(2355) 		fp->fptr = 0;						/* File pointer */
    01827 9636      ADIW	R30,6
    01828 E080      LDI	R24,0
    01829 8380      ST	Z,R24
    0182A 8381      STD	Z+1,R24
    0182B 8382      STD	Z+2,R24
    0182C 8383      STD	Z+3,R24
(2356) 		fp->dsect = 0;
    0182D A9EE      LDD	R30,Y+54
    0182E A9FF      LDD	R31,Y+55
    0182F 9676      ADIW	R30,0x16
    01830 E080      LDI	R24,0
    01831 8380      ST	Z,R24
    01832 8381      STD	Z+1,R24
    01833 8382      STD	Z+2,R24
    01834 8383      STD	Z+3,R24
(2357) #if _USE_FASTSEEK
(2358) 		fp->cltbl = 0;						/* Normal seek mode */
    01835 2422      CLR	R2
    01836 2433      CLR	R3
    01837 A9EE      LDD	R30,Y+54
    01838 A9FF      LDD	R31,Y+55
    01839 A231      STD	Z+33,R3
    0183A A220      STD	Z+32,R2
(2359) #endif
(2360) 		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    0183B 802A      LDD	R2,Y+2
    0183C 803B      LDD	R3,Y+3
    0183D 8231      STD	Z+1,R3
    0183E 8220      ST	Z,R2
    0183F 01F1      MOVW	R30,R2
    01840 8026      LDD	R2,Z+6
    01841 8037      LDD	R3,Z+7
    01842 A9EE      LDD	R30,Y+54
    01843 A9FF      LDD	R31,Y+55
    01844 8233      STD	Z+3,R3
    01845 8222      STD	Z+2,R2
(2361) 	}
(2362) 
(2363) 	LEAVE_FF(dj.fs, res);
    01846 2D0A      MOV	R16,R10
    01847 96AC      ADIW	R28,0x2C
    01848 940E 4160 CALL	pop_xgsetF0FC
    0184A 9624      ADIW	R28,4
    0184B 9508      RET
_f_read:
  remain               --> Y,+13
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  rbuff                --> R14
  sect                 --> Y,+5
  rcnt                 --> R12
  br                   --> Y,+33
  btr                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    0184C 940E 4026 CALL	push_arg4
    0184E 940E 416B CALL	push_xgsetF0FC
    01850 0159      MOVW	R10,R18
    01851 9761      SBIW	R28,0x11
(2364) }
(2365) 
(2366) 
(2367) 
(2368) 
(2369) /*-----------------------------------------------------------------------*/
(2370) /* Read File                                                             */
(2371) /*-----------------------------------------------------------------------*/
(2372) 
(2373) FRESULT f_read (
(2374) 	FIL *fp, 		/* Pointer to the file object */
(2375) 	void *buff,		/* Pointer to data buffer */
(2376) 	UINT btr,		/* Number of bytes to read */
(2377) 	UINT *br		/* Pointer to number of bytes read */
(2378) )
(2379) {
(2380) 	FRESULT res;
(2381) 	DWORD clst, sect, remain;
(2382) 	UINT rcnt, cc;
(2383) 	BYTE csect, *rbuff = buff;
    01852 0175      MOVW	R14,R10
(2384) 
(2385) 	memset(buff,0,512);
    01853 E080      LDI	R24,0
    01854 E092      LDI	R25,2
    01855 8399      STD	Y+1,R25
    01856 8388      ST	Y,R24
    01857 2722      CLR	R18
    01858 2733      CLR	R19
    01859 0185      MOVW	R16,R10
    0185A 940E 4002 CALL	_memset
(2386) 
(2387) 	*br = 0;	/* Initialize byte counter */
    0185C 2422      CLR	R2
    0185D 2433      CLR	R3
    0185E A1E9      LDD	R30,Y+33
    0185F A1FA      LDD	R31,Y+34
    01860 8231      STD	Z+1,R3
    01861 8220      ST	Z,R2
(2388) 
(2389) 	res = validate(fp->fs, fp->id);				/* Check validity */
    01862 8DEB      LDD	R30,Y+27
    01863 8DFC      LDD	R31,Y+28
    01864 8122      LDD	R18,Z+2
    01865 8133      LDD	R19,Z+3
    01866 8100      LD	R16,Z
    01867 8111      LDD	R17,Z+1
    01868 DDFF      RCALL	ff.c:validate
    01869 2EA0      MOV	R10,R16
(2390) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    0186A 2300      TST	R16
    0186B F009      BEQ	0x186D
    0186C C245      RJMP	0x1AB2
(2391) 	if (fp->flag & FA__ERROR)					/* Aborted file? */
    0186D 8DEB      LDD	R30,Y+27
    0186E 8DFC      LDD	R31,Y+28
    0186F 8024      LDD	R2,Z+4
    01870 FE27      SBRS	R2,7
    01871 C002      RJMP	0x1874
(2392) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01872 E002      LDI	R16,2
    01873 C23E      RJMP	0x1AB2
(2393) 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    01874 8DEB      LDD	R30,Y+27
    01875 8DFC      LDD	R31,Y+28
    01876 8024      LDD	R2,Z+4
    01877 FC20      SBRC	R2,0
    01878 C002      RJMP	0x187B
(2394) 		LEAVE_FF(fp->fs, FR_DENIED);
    01879 E007      LDI	R16,7
    0187A C237      RJMP	0x1AB2
(2395) 	remain = fp->fsize - fp->fptr;
    0187B 8DEB      LDD	R30,Y+27
    0187C 8DFC      LDD	R31,Y+28
    0187D 8026      LDD	R2,Z+6
    0187E 8037      LDD	R3,Z+7
    0187F 8440      LDD	R4,Z+8
    01880 8451      LDD	R5,Z+9
    01881 963A      ADIW	R30,0xA
    01882 8060      LD	R6,Z
    01883 8071      LDD	R7,Z+1
    01884 8082      LDD	R8,Z+2
    01885 8093      LDD	R9,Z+3
    01886 1862      SUB	R6,R2
    01887 0873      SBC	R7,R3
    01888 0884      SBC	R8,R4
    01889 0895      SBC	R9,R5
    0188A 866D      STD	Y+13,R6
    0188B 867E      STD	Y+14,R7
    0188C 868F      STD	Y+15,R8
    0188D 8A98      STD	Y+16,R9
(2396) 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    0188E 842D      LDD	R2,Y+13
    0188F 843E      LDD	R3,Y+14
    01890 844F      LDD	R4,Y+15
    01891 8858      LDD	R5,Y+16
    01892 8C6F      LDD	R6,Y+31
    01893 A078      LDD	R7,Y+32
    01894 2488      CLR	R8
    01895 2499      CLR	R9
    01896 1426      CP	R2,R6
    01897 0437      CPC	R3,R7
    01898 0448      CPC	R4,R8
    01899 0459      CPC	R5,R9
    0189A F008      BCS	0x189C
    0189B C20D      RJMP	0x1AA9
    0189C A238      STD	Y+32,R3
    0189D 8E2F      STD	Y+31,R2
(2397) 
(2398) 	for ( ;  btr;								/* Repeat until all data read */
    0189E C20A      RJMP	0x1AA9
(2399) 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
(2400) 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    0189F EF4F      LDI	R20,0xFF
    018A0 E051      LDI	R21,1
    018A1 E060      LDI	R22,0
    018A2 E070      LDI	R23,0
    018A3 8DEB      LDD	R30,Y+27
    018A4 8DFC      LDD	R31,Y+28
    018A5 9636      ADIW	R30,6
    018A6 8020      LD	R2,Z
    018A7 8031      LDD	R3,Z+1
    018A8 8042      LDD	R4,Z+2
    018A9 8053      LDD	R5,Z+3
    018AA 2224      AND	R2,R20
    018AB 2235      AND	R3,R21
    018AC 2246      AND	R4,R22
    018AD 2257      AND	R5,R23
    018AE 9488      BCLR	0
    018AF 2022      TST	R2
    018B0 0432      CPC	R3,R2
    018B1 0442      CPC	R4,R2
    018B2 0452      CPC	R5,R2
    018B3 F009      BEQ	0x18B5
    018B4 C180      RJMP	0x1A35
(2401) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    018B5 E089      LDI	R24,0x9
    018B6 E090      LDI	R25,0
    018B7 8DEB      LDD	R30,Y+27
    018B8 8DFC      LDD	R31,Y+28
    018B9 8106      LDD	R16,Z+6
    018BA 8117      LDD	R17,Z+7
    018BB 8520      LDD	R18,Z+8
    018BC 8531      LDD	R19,Z+9
    018BD 938A      ST	-Y,R24
    018BE 940E 4206 CALL	lsr32
    018C0 0118      MOVW	R2,R16
    018C1 0129      MOVW	R4,R18
    018C2 8DEB      LDD	R30,Y+27
    018C3 8DFC      LDD	R31,Y+28
    018C4 93AF      PUSH	R26
    018C5 93BF      PUSH	R27
    018C6 81A0      LD	R26,Z
    018C7 81B1      LDD	R27,Z+1
    018C8 01FD      MOVW	R30,R26
    018C9 91BF      POP	R27
    018CA 91AF      POP	R26
    018CB 8182      LDD	R24,Z+2
    018CC 2799      CLR	R25
    018CD 9701      SBIW	R24,1
    018CE 013C      MOVW	R6,R24
    018CF 2488      CLR	R8
    018D0 FC77      SBRC	R7,7
    018D1 9480      COM	R8
    018D2 2499      CLR	R9
    018D3 FC87      SBRC	R8,7
    018D4 9490      COM	R9
    018D5 2026      AND	R2,R6
    018D6 2037      AND	R3,R7
    018D7 2048      AND	R4,R8
    018D8 2059      AND	R5,R9
    018D9 2CC2      MOV	R12,R2
(2402) 			if (!csect) {						/* On the cluster boundary? */
    018DA 2022      TST	R2
    018DB F009      BEQ	0x18DD
    018DC C078      RJMP	0x1955
(2403) 				if (fp->fptr == 0) {			/* On the top of the file? */
    018DD 8DEB      LDD	R30,Y+27
    018DE 8DFC      LDD	R31,Y+28
    018DF 9636      ADIW	R30,6
    018E0 8020      LD	R2,Z
    018E1 8031      LDD	R3,Z+1
    018E2 8042      LDD	R4,Z+2
    018E3 8053      LDD	R5,Z+3
    018E4 9488      BCLR	0
    018E5 2022      TST	R2
    018E6 0432      CPC	R3,R2
    018E7 0442      CPC	R4,R2
    018E8 0452      CPC	R5,R2
    018E9 F461      BNE	0x18F6
(2404) 					clst = fp->sclust;			/* Follow from the origin */
    018EA 8DEB      LDD	R30,Y+27
    018EB 8DFC      LDD	R31,Y+28
    018EC 963E      ADIW	R30,0xE
    018ED 8020      LD	R2,Z
    018EE 8031      LDD	R3,Z+1
    018EF 8042      LDD	R4,Z+2
    018F0 8053      LDD	R5,Z+3
    018F1 8629      STD	Y+9,R2
    018F2 863A      STD	Y+10,R3
    018F3 864B      STD	Y+11,R4
    018F4 865C      STD	Y+12,R5
(2405) 				} else {						/* Middle or end of the file */
    018F5 C028      RJMP	0x191E
(2406) #if _USE_FASTSEEK
(2407) 					if (fp->cltbl)
    018F6 8DEB      LDD	R30,Y+27
    018F7 8DFC      LDD	R31,Y+28
    018F8 A020      LDD	R2,Z+32
    018F9 A031      LDD	R3,Z+33
    018FA 2022      TST	R2
    018FB F411      BNE	0x18FE
    018FC 2033      TST	R3
    018FD F079      BEQ	0x190D
(2408) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    018FE 8026      LDD	R2,Z+6
    018FF 8037      LDD	R3,Z+7
    01900 8440      LDD	R4,Z+8
    01901 8451      LDD	R5,Z+9
    01902 8248      ST	Y,R4
    01903 8259      STD	Y+1,R5
    01904 0191      MOVW	R18,R2
    01905 018F      MOVW	R16,R30
    01906 940E 0A53 CALL	ff.c:clmt_clust
    01908 8709      STD	Y+9,R16
    01909 871A      STD	Y+10,R17
    0190A 872B      STD	Y+11,R18
    0190B 873C      STD	Y+12,R19
    0190C C011      RJMP	0x191E
(2409) 					else
(2410) #endif
(2411) 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    0190D 8DEB      LDD	R30,Y+27
    0190E 8DFC      LDD	R31,Y+28
    0190F 8822      LDD	R2,Z+18
    01910 8833      LDD	R3,Z+19
    01911 8844      LDD	R4,Z+20
    01912 8855      LDD	R5,Z+21
    01913 8248      ST	Y,R4
    01914 8259      STD	Y+1,R5
    01915 0191      MOVW	R18,R2
    01916 8100      LD	R16,Z
    01917 8111      LDD	R17,Z+1
    01918 940E 0519 CALL	_get_fat
    0191A 8709      STD	Y+9,R16
    0191B 871A      STD	Y+10,R17
    0191C 872B      STD	Y+11,R18
    0191D 873C      STD	Y+12,R19
(2412) 				}
(2413) 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    0191E E042      LDI	R20,2
    0191F E050      LDI	R21,0
    01920 E060      LDI	R22,0
    01921 E070      LDI	R23,0
    01922 8429      LDD	R2,Y+9
    01923 843A      LDD	R3,Y+10
    01924 844B      LDD	R4,Y+11
    01925 845C      LDD	R5,Y+12
    01926 1624      CP	R2,R20
    01927 0635      CPC	R3,R21
    01928 0646      CPC	R4,R22
    01929 0657      CPC	R5,R23
    0192A F448      BCC	0x1934
    0192B 8D8B      LDD	R24,Y+27
    0192C 8D9C      LDD	R25,Y+28
    0192D 9604      ADIW	R24,4
    0192E 01FC      MOVW	R30,R24
    0192F 8180      LD	R24,Z
    01930 6880      ORI	R24,0x80
    01931 8380      ST	Z,R24
    01932 E002      LDI	R16,2
    01933 C17E      RJMP	0x1AB2
(2414) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01934 EF4F      LDI	R20,0xFF
    01935 EF5F      LDI	R21,0xFF
    01936 EF6F      LDI	R22,0xFF
    01937 EF7F      LDI	R23,0xFF
    01938 8429      LDD	R2,Y+9
    01939 843A      LDD	R3,Y+10
    0193A 844B      LDD	R4,Y+11
    0193B 845C      LDD	R5,Y+12
    0193C 1624      CP	R2,R20
    0193D 0635      CPC	R3,R21
    0193E 0646      CPC	R4,R22
    0193F 0657      CPC	R5,R23
    01940 F451      BNE	0x194B
    01941 8D8B      LDD	R24,Y+27
    01942 8D9C      LDD	R25,Y+28
    01943 9604      ADIW	R24,4
    01944 015C      MOVW	R10,R24
    01945 01FC      MOVW	R30,R24
    01946 8180      LD	R24,Z
    01947 6880      ORI	R24,0x80
    01948 8380      ST	Z,R24
    01949 E001      LDI	R16,1
    0194A C167      RJMP	0x1AB2
(2415) 				fp->clust = clst;				/* Update current cluster */
    0194B 8429      LDD	R2,Y+9
    0194C 843A      LDD	R3,Y+10
    0194D 844B      LDD	R4,Y+11
    0194E 845C      LDD	R5,Y+12
    0194F 8DEB      LDD	R30,Y+27
    01950 8DFC      LDD	R31,Y+28
    01951 8A22      STD	Z+18,R2
    01952 8A33      STD	Z+19,R3
    01953 8A44      STD	Z+20,R4
    01954 8A55      STD	Z+21,R5
(2416) 			}
(2417) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01955 8DEB      LDD	R30,Y+27
    01956 8DFC      LDD	R31,Y+28
    01957 8822      LDD	R2,Z+18
    01958 8833      LDD	R3,Z+19
    01959 8844      LDD	R4,Z+20
    0195A 8855      LDD	R5,Z+21
    0195B 8248      ST	Y,R4
    0195C 8259      STD	Y+1,R5
    0195D 0191      MOVW	R18,R2
    0195E 8100      LD	R16,Z
    0195F 8111      LDD	R17,Z+1
    01960 940E 04C7 CALL	_clust2sect
    01962 830D      STD	Y+5,R16
    01963 831E      STD	Y+6,R17
    01964 832F      STD	Y+7,R18
    01965 8738      STD	Y+8,R19
(2418) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01966 802D      LDD	R2,Y+5
    01967 803E      LDD	R3,Y+6
    01968 804F      LDD	R4,Y+7
    01969 8458      LDD	R5,Y+8
    0196A 9488      BCLR	0
    0196B 2022      TST	R2
    0196C 0432      CPC	R3,R2
    0196D 0442      CPC	R4,R2
    0196E 0452      CPC	R5,R2
    0196F F451      BNE	0x197A
    01970 8D8B      LDD	R24,Y+27
    01971 8D9C      LDD	R25,Y+28
    01972 9604      ADIW	R24,4
    01973 015C      MOVW	R10,R24
    01974 01FC      MOVW	R30,R24
    01975 8180      LD	R24,Z
    01976 6880      ORI	R24,0x80
    01977 8380      ST	Z,R24
    01978 E002      LDI	R16,2
    01979 C138      RJMP	0x1AB2
(2419) 			sect += csect;
    0197A 2C2C      MOV	R2,R12
    0197B 2433      CLR	R3
    0197C 2444      CLR	R4
    0197D 2455      CLR	R5
    0197E 806D      LDD	R6,Y+5
    0197F 807E      LDD	R7,Y+6
    01980 808F      LDD	R8,Y+7
    01981 8498      LDD	R9,Y+8
    01982 0C62      ADD	R6,R2
    01983 1C73      ADC	R7,R3
    01984 1C84      ADC	R8,R4
    01985 1C95      ADC	R9,R5
    01986 826D      STD	Y+5,R6
    01987 827E      STD	Y+6,R7
    01988 828F      STD	Y+7,R8
    01989 8698      STD	Y+8,R9
(2420) 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    0198A E029      LDI	R18,0x9
    0198B E030      LDI	R19,0
    0198C 8D0F      LDD	R16,Y+31
    0198D A118      LDD	R17,Y+32
    0198E 940E 41FF CALL	lsr16
    01990 0158      MOVW	R10,R16
(2421) 			if (cc) {							/* Read maximum contiguous sectors directly */
    01991 3000      CPI	R16,0
    01992 0701      CPC	R16,R17
    01993 F409      BNE	0x1995
    01994 C096      RJMP	0x1A2B
(2422) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01995 2C2C      MOV	R2,R12
    01996 2433      CLR	R3
    01997 0E20      ADD	R2,R16
    01998 1E31      ADC	R3,R17
    01999 8DEB      LDD	R30,Y+27
    0199A 8DFC      LDD	R31,Y+28
    0199B 93AF      PUSH	R26
    0199C 93BF      PUSH	R27
    0199D 81A0      LD	R26,Z
    0199E 81B1      LDD	R27,Z+1
    0199F 01FD      MOVW	R30,R26
    019A0 91BF      POP	R27
    019A1 91AF      POP	R26
    019A2 8042      LDD	R4,Z+2
    019A3 2455      CLR	R5
    019A4 1442      CP	R4,R2
    019A5 0453      CPC	R5,R3
    019A6 F478      BCC	0x19B6
(2423) 					cc = fp->fs->csize - csect;
    019A7 2C2C      MOV	R2,R12
    019A8 2433      CLR	R3
    019A9 8DEB      LDD	R30,Y+27
    019AA 8DFC      LDD	R31,Y+28
    019AB 93AF      PUSH	R26
    019AC 93BF      PUSH	R27
    019AD 81A0      LD	R26,Z
    019AE 81B1      LDD	R27,Z+1
    019AF 01FD      MOVW	R30,R26
    019B0 91BF      POP	R27
    019B1 91AF      POP	R26
    019B2 80A2      LDD	R10,Z+2
    019B3 24BB      CLR	R11
    019B4 18A2      SUB	R10,R2
    019B5 08B3      SBC	R11,R3
(2424) 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    019B6 82AC      STD	Y+4,R10
    019B7 802D      LDD	R2,Y+5
    019B8 803E      LDD	R3,Y+6
    019B9 804F      LDD	R4,Y+7
    019BA 8458      LDD	R5,Y+8
    019BB 8228      ST	Y,R2
    019BC 8239      STD	Y+1,R3
    019BD 824A      STD	Y+2,R4
    019BE 825B      STD	Y+3,R5
    019BF 0197      MOVW	R18,R14
    019C0 8DEB      LDD	R30,Y+27
    019C1 8DFC      LDD	R31,Y+28
    019C2 93AF      PUSH	R26
    019C3 93BF      PUSH	R27
    019C4 81A0      LD	R26,Z
    019C5 81B1      LDD	R27,Z+1
    019C6 01FD      MOVW	R30,R26
    019C7 91BF      POP	R27
    019C8 91AF      POP	R26
    019C9 8101      LDD	R16,Z+1
    019CA 940E 02B5 CALL	_disk_read
    019CC 2EC0      MOV	R12,R16
    019CD 2300      TST	R16
    019CE F051      BEQ	0x19D9
(2425) 					ABORT(fp->fs, FR_DISK_ERR);
    019CF 8D8B      LDD	R24,Y+27
    019D0 8D9C      LDD	R25,Y+28
    019D1 9604      ADIW	R24,4
    019D2 016C      MOVW	R12,R24
    019D3 01FC      MOVW	R30,R24
    019D4 8180      LD	R24,Z
    019D5 6880      ORI	R24,0x80
    019D6 8380      ST	Z,R24
    019D7 E001      LDI	R16,1
    019D8 C0D9      RJMP	0x1AB2
(2426) #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
(2427) #if _FS_TINY
(2428) 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    019D9 8DEB      LDD	R30,Y+27
    019DA 8DFC      LDD	R31,Y+28
    019DB 80C0      LD	R12,Z
    019DC 80D1      LDD	R13,Z+1
    019DD 01F6      MOVW	R30,R12
    019DE 9634      ADIW	R30,4
    019DF 8020      LD	R2,Z
    019E0 2022      TST	R2
    019E1 F409      BNE	0x19E3
    019E2 C041      RJMP	0x1A24
    019E3 802D      LDD	R2,Y+5
    019E4 803E      LDD	R3,Y+6
    019E5 804F      LDD	R4,Y+7
    019E6 8458      LDD	R5,Y+8
    019E7 01F6      MOVW	R30,R12
    019E8 A462      LDD	R6,Z+42
    019E9 A473      LDD	R7,Z+43
    019EA A484      LDD	R8,Z+44
    019EB A495      LDD	R9,Z+45
    019EC 1862      SUB	R6,R2
    019ED 0873      SBC	R7,R3
    019EE 0884      SBC	R8,R4
    019EF 0895      SBC	R9,R5
    019F0 0115      MOVW	R2,R10
    019F1 2444      CLR	R4
    019F2 2455      CLR	R5
    019F3 1462      CP	R6,R2
    019F4 0473      CPC	R7,R3
    019F5 0484      CPC	R8,R4
    019F6 0495      CPC	R9,R5
    019F7 F560      BCC	0x1A24
(2429) 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
    019F8 E080      LDI	R24,0
    019F9 E092      LDI	R25,2
    019FA 8399      STD	Y+1,R25
    019FB 8388      ST	Y,R24
    019FC 8DEB      LDD	R30,Y+27
    019FD 8DFC      LDD	R31,Y+28
    019FE 80C0      LD	R12,Z
    019FF 80D1      LDD	R13,Z+1
    01A00 0196      MOVW	R18,R12
    01A01 5D22      SUBI	R18,0xD2
    01A02 4F3F      SBCI	R19,0xFF
    01A03 802D      LDD	R2,Y+5
    01A04 803E      LDD	R3,Y+6
    01A05 804F      LDD	R4,Y+7
    01A06 8458      LDD	R5,Y+8
    01A07 01F6      MOVW	R30,R12
    01A08 A462      LDD	R6,Z+42
    01A09 A473      LDD	R7,Z+43
    01A0A A484      LDD	R8,Z+44
    01A0B A495      LDD	R9,Z+45
    01A0C 1862      SUB	R6,R2
    01A0D 0873      SBC	R7,R3
    01A0E 0884      SBC	R8,R4
    01A0F 0895      SBC	R9,R5
    01A10 E040      LDI	R20,0
    01A11 E052      LDI	R21,2
    01A12 E060      LDI	R22,0
    01A13 E070      LDI	R23,0
    01A14 932F      PUSH	R18
    01A15 933F      PUSH	R19
    01A16 929A      ST	-Y,R9
    01A17 928A      ST	-Y,R8
    01A18 927A      ST	-Y,R7
    01A19 926A      ST	-Y,R6
    01A1A 018A      MOVW	R16,R20
    01A1B 019B      MOVW	R18,R22
    01A1C 940E 4117 CALL	empy32u|empy32s
    01A1E 913F      POP	R19
    01A1F 912F      POP	R18
    01A20 0D0E      ADD	R16,R14
    01A21 1D1F      ADC	R17,R15
    01A22 940E 02F7 CALL	ff.c:mem_cpy
(2430) #else
(2431) 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
(2432) 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
(2433) #endif
(2434) #endif
(2435) 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    01A24 E000      LDI	R16,0
    01A25 E012      LDI	R17,2
    01A26 0195      MOVW	R18,R10
    01A27 940E 4107 CALL	empy16s
    01A29 0168      MOVW	R12,R16
(2436) 				continue;
    01A2A C05A      RJMP	0x1A85
(2437) 			}
(2438) #if !_FS_TINY
(2439) 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
(2440) #if !_FS_READONLY
(2441) 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2442) 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2443) 						ABORT(fp->fs, FR_DISK_ERR);
(2444) 					fp->flag &= ~FA__DIRTY;
(2445) 				}
(2446) #endif
(2447) 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
(2448) 					ABORT(fp->fs, FR_DISK_ERR);
(2449) 			}
(2450) #endif
(2451) 			fp->dsect = sect;
    01A2B 802D      LDD	R2,Y+5
    01A2C 803E      LDD	R3,Y+6
    01A2D 804F      LDD	R4,Y+7
    01A2E 8458      LDD	R5,Y+8
    01A2F 8DEB      LDD	R30,Y+27
    01A30 8DFC      LDD	R31,Y+28
    01A31 8A26      STD	Z+22,R2
    01A32 8A37      STD	Z+23,R3
    01A33 8E40      STD	Z+24,R4
    01A34 8E51      STD	Z+25,R5
(2452) 		}
(2453) 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    01A35 EF4F      LDI	R20,0xFF
    01A36 E051      LDI	R21,1
    01A37 E060      LDI	R22,0
    01A38 E070      LDI	R23,0
    01A39 8DEB      LDD	R30,Y+27
    01A3A 8DFC      LDD	R31,Y+28
    01A3B 8026      LDD	R2,Z+6
    01A3C 8037      LDD	R3,Z+7
    01A3D 8440      LDD	R4,Z+8
    01A3E 8451      LDD	R5,Z+9
    01A3F 2224      AND	R2,R20
    01A40 2235      AND	R3,R21
    01A41 2246      AND	R4,R22
    01A42 2257      AND	R5,R23
    01A43 E040      LDI	R20,0
    01A44 E052      LDI	R21,2
    01A45 E060      LDI	R22,0
    01A46 E070      LDI	R23,0
    01A47 1942      SUB	R20,R2
    01A48 0953      SBC	R21,R3
    01A49 0964      SBC	R22,R4
    01A4A 0975      SBC	R23,R5
    01A4B 016A      MOVW	R12,R20
(2454) 		if (rcnt > btr) rcnt = btr;
    01A4C 8C0F      LDD	R0,Y+31
    01A4D A018      LDD	R1,Y+32
    01A4E 1604      CP	R0,R20
    01A4F 0615      CPC	R1,R21
    01A50 F408      BCC	0x1A52
    01A51 0160      MOVW	R12,R0
(2455) #if _FS_TINY
(2456) 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    01A52 8DEB      LDD	R30,Y+27
    01A53 8DFC      LDD	R31,Y+28
    01A54 8826      LDD	R2,Z+22
    01A55 8837      LDD	R3,Z+23
    01A56 8C40      LDD	R4,Z+24
    01A57 8C51      LDD	R5,Z+25
    01A58 8248      ST	Y,R4
    01A59 8259      STD	Y+1,R5
    01A5A 0191      MOVW	R18,R2
    01A5B 8100      LD	R16,Z
    01A5C 8111      LDD	R17,Z+1
    01A5D 940E 0350 CALL	ff.c:move_window
    01A5F 2EA0      MOV	R10,R16
    01A60 2300      TST	R16
    01A61 F051      BEQ	0x1A6C
(2457) 			ABORT(fp->fs, FR_DISK_ERR);
    01A62 8D8B      LDD	R24,Y+27
    01A63 8D9C      LDD	R25,Y+28
    01A64 9604      ADIW	R24,4
    01A65 015C      MOVW	R10,R24
    01A66 01FC      MOVW	R30,R24
    01A67 8180      LD	R24,Z
    01A68 6880      ORI	R24,0x80
    01A69 8380      ST	Z,R24
    01A6A E001      LDI	R16,1
    01A6B C046      RJMP	0x1AB2
(2458) 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    01A6C 82D9      STD	Y+1,R13
    01A6D 82C8      ST	Y,R12
    01A6E EF4F      LDI	R20,0xFF
    01A6F E051      LDI	R21,1
    01A70 E060      LDI	R22,0
    01A71 E070      LDI	R23,0
    01A72 8DEB      LDD	R30,Y+27
    01A73 8DFC      LDD	R31,Y+28
    01A74 8026      LDD	R2,Z+6
    01A75 8037      LDD	R3,Z+7
    01A76 8440      LDD	R4,Z+8
    01A77 8451      LDD	R5,Z+9
    01A78 2224      AND	R2,R20
    01A79 2235      AND	R3,R21
    01A7A 2246      AND	R4,R22
    01A7B 2257      AND	R5,R23
    01A7C 0191      MOVW	R18,R2
    01A7D 8180      LD	R24,Z
    01A7E 8191      LDD	R25,Z+1
    01A7F 968E      ADIW	R24,0x2E
    01A80 0F28      ADD	R18,R24
    01A81 1F39      ADC	R19,R25
    01A82 0187      MOVW	R16,R14
    01A83 940E 02F7 CALL	ff.c:mem_cpy
    01A85 0CEC      ADD	R14,R12
    01A86 1CFD      ADC	R15,R13
    01A87 8D8B      LDD	R24,Y+27
    01A88 8D9C      LDD	R25,Y+28
    01A89 9606      ADIW	R24,6
    01A8A 015C      MOVW	R10,R24
    01A8B 0116      MOVW	R2,R12
    01A8C 2444      CLR	R4
    01A8D 2455      CLR	R5
    01A8E 01FC      MOVW	R30,R24
    01A8F 8060      LD	R6,Z
    01A90 8071      LDD	R7,Z+1
    01A91 8082      LDD	R8,Z+2
    01A92 8093      LDD	R9,Z+3
    01A93 0C62      ADD	R6,R2
    01A94 1C73      ADC	R7,R3
    01A95 1C84      ADC	R8,R4
    01A96 1C95      ADC	R9,R5
    01A97 8260      ST	Z,R6
    01A98 8271      STD	Z+1,R7
    01A99 8282      STD	Z+2,R8
    01A9A 8293      STD	Z+3,R9
    01A9B A1E9      LDD	R30,Y+33
    01A9C A1FA      LDD	R31,Y+34
    01A9D 8020      LD	R2,Z
    01A9E 8031      LDD	R3,Z+1
    01A9F 0C2C      ADD	R2,R12
    01AA0 1C3D      ADC	R3,R13
    01AA1 8231      STD	Z+1,R3
    01AA2 8220      ST	Z,R2
    01AA3 8C0F      LDD	R0,Y+31
    01AA4 A018      LDD	R1,Y+32
    01AA5 180C      SUB	R0,R12
    01AA6 081D      SBC	R1,R13
    01AA7 A218      STD	Y+32,R1
    01AA8 8E0F      STD	Y+31,R0
    01AA9 8C0F      LDD	R0,Y+31
    01AAA A018      LDD	R1,Y+32
    01AAB 2000      TST	R0
    01AAC F009      BEQ	0x1AAE
    01AAD CDF1      RJMP	0x189F
    01AAE 2011      TST	R1
    01AAF F009      BEQ	0x1AB1
    01AB0 CDEE      RJMP	0x189F
(2459) #else
(2460) 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
(2461) #endif
(2462) 	}
(2463) 
(2464) 	LEAVE_FF(fp->fs, FR_OK);
    01AB1 2700      CLR	R16
    01AB2 9661      ADIW	R28,0x11
    01AB3 940E 4160 CALL	pop_xgsetF0FC
    01AB5 9624      ADIW	R28,4
    01AB6 9508      RET
_f_write:
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  wbuff                --> R14
  sect                 --> Y,+5
  wcnt                 --> R12
  bw                   --> Y,+33
  btw                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01AB7 940E 4026 CALL	push_arg4
    01AB9 940E 416B CALL	push_xgsetF0FC
    01ABB 0159      MOVW	R10,R18
    01ABC 9761      SBIW	R28,0x11
(2465) }
(2466) 
(2467) 
(2468) 
(2469) 
(2470) #if !_FS_READONLY
(2471) /*-----------------------------------------------------------------------*/
(2472) /* Write File                                                            */
(2473) /*-----------------------------------------------------------------------*/
(2474) 
(2475) FRESULT f_write (
(2476) 	FIL *fp,			/* Pointer to the file object */
(2477) 	const void *buff,	/* Pointer to the data to be written */
(2478) 	UINT btw,			/* Number of bytes to write */
(2479) 	UINT *bw			/* Pointer to number of bytes written */
(2480) )
(2481) {
(2482) 	FRESULT res;
(2483) 	DWORD clst, sect;
(2484) 	UINT wcnt, cc;
(2485) 	const BYTE *wbuff = buff;
    01ABD 0175      MOVW	R14,R10
(2486) 	BYTE csect;
(2487) 
(2488) 
(2489) 	*bw = 0;	/* Initialize byte counter */
    01ABE 2422      CLR	R2
    01ABF 2433      CLR	R3
    01AC0 A1E9      LDD	R30,Y+33
    01AC1 A1FA      LDD	R31,Y+34
    01AC2 8231      STD	Z+1,R3
    01AC3 8220      ST	Z,R2
(2490) 
(2491) 	res = validate(fp->fs, fp->id);			/* Check validity */
    01AC4 8DEB      LDD	R30,Y+27
    01AC5 8DFC      LDD	R31,Y+28
    01AC6 8122      LDD	R18,Z+2
    01AC7 8133      LDD	R19,Z+3
    01AC8 8100      LD	R16,Z
    01AC9 8111      LDD	R17,Z+1
    01ACA DB9D      RCALL	ff.c:validate
    01ACB 2EA0      MOV	R10,R16
(2492) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01ACC 2300      TST	R16
    01ACD F009      BEQ	0x1ACF
    01ACE C2FC      RJMP	0x1DCB
(2493) 	if (fp->flag & FA__ERROR)				/* Aborted file? */
    01ACF 8DEB      LDD	R30,Y+27
    01AD0 8DFC      LDD	R31,Y+28
    01AD1 8024      LDD	R2,Z+4
    01AD2 FE27      SBRS	R2,7
    01AD3 C002      RJMP	0x1AD6
(2494) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01AD4 E002      LDI	R16,2
    01AD5 C2F5      RJMP	0x1DCB
(2495) 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    01AD6 8DEB      LDD	R30,Y+27
    01AD7 8DFC      LDD	R31,Y+28
    01AD8 8024      LDD	R2,Z+4
    01AD9 FC21      SBRC	R2,1
    01ADA C002      RJMP	0x1ADD
(2496) 		LEAVE_FF(fp->fs, FR_DENIED);
    01ADB E007      LDI	R16,7
    01ADC C2EE      RJMP	0x1DCB
(2497) 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    01ADD 8DEB      LDD	R30,Y+27
    01ADE 8DFC      LDD	R31,Y+28
    01ADF 963A      ADIW	R30,0xA
    01AE0 8020      LD	R2,Z
    01AE1 8031      LDD	R3,Z+1
    01AE2 8042      LDD	R4,Z+2
    01AE3 8053      LDD	R5,Z+3
    01AE4 862D      STD	Y+13,R2
    01AE5 863E      STD	Y+14,R3
    01AE6 864F      STD	Y+15,R4
    01AE7 8A58      STD	Y+16,R5
    01AE8 8C2F      LDD	R2,Y+31
    01AE9 A038      LDD	R3,Y+32
    01AEA 2444      CLR	R4
    01AEB 2455      CLR	R5
    01AEC 846D      LDD	R6,Y+13
    01AED 847E      LDD	R7,Y+14
    01AEE 848F      LDD	R8,Y+15
    01AEF 8898      LDD	R9,Y+16
    01AF0 0C62      ADD	R6,R2
    01AF1 1C73      ADC	R7,R3
    01AF2 1C84      ADC	R8,R4
    01AF3 1C95      ADC	R9,R5
    01AF4 842D      LDD	R2,Y+13
    01AF5 843E      LDD	R3,Y+14
    01AF6 844F      LDD	R4,Y+15
    01AF7 8858      LDD	R5,Y+16
    01AF8 1462      CP	R6,R2
    01AF9 0473      CPC	R7,R3
    01AFA 0484      CPC	R8,R4
    01AFB 0495      CPC	R9,R5
    01AFC F008      BCS	0x1AFE
    01AFD C2A5      RJMP	0x1DA3
    01AFE 2400      CLR	R0
    01AFF 2411      CLR	R1
    01B00 A218      STD	Y+32,R1
    01B01 8E0F      STD	Y+31,R0
(2498) 
(2499) 	for ( ;  btw;							/* Repeat until all data written */
    01B02 C2A0      RJMP	0x1DA3
(2500) 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
(2501) 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    01B03 EF4F      LDI	R20,0xFF
    01B04 E051      LDI	R21,1
    01B05 E060      LDI	R22,0
    01B06 E070      LDI	R23,0
    01B07 8DEB      LDD	R30,Y+27
    01B08 8DFC      LDD	R31,Y+28
    01B09 9636      ADIW	R30,6
    01B0A 8020      LD	R2,Z
    01B0B 8031      LDD	R3,Z+1
    01B0C 8042      LDD	R4,Z+2
    01B0D 8053      LDD	R5,Z+3
    01B0E 2224      AND	R2,R20
    01B0F 2235      AND	R3,R21
    01B10 2246      AND	R4,R22
    01B11 2257      AND	R5,R23
    01B12 9488      BCLR	0
    01B13 2022      TST	R2
    01B14 0432      CPC	R3,R2
    01B15 0442      CPC	R4,R2
    01B16 0452      CPC	R5,R2
    01B17 F009      BEQ	0x1B19
    01B18 C20B      RJMP	0x1D24
(2502) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01B19 E089      LDI	R24,0x9
    01B1A E090      LDI	R25,0
    01B1B 8DEB      LDD	R30,Y+27
    01B1C 8DFC      LDD	R31,Y+28
    01B1D 8106      LDD	R16,Z+6
    01B1E 8117      LDD	R17,Z+7
    01B1F 8520      LDD	R18,Z+8
    01B20 8531      LDD	R19,Z+9
    01B21 938A      ST	-Y,R24
    01B22 940E 4206 CALL	lsr32
    01B24 0118      MOVW	R2,R16
    01B25 0129      MOVW	R4,R18
    01B26 8DEB      LDD	R30,Y+27
    01B27 8DFC      LDD	R31,Y+28
    01B28 93AF      PUSH	R26
    01B29 93BF      PUSH	R27
    01B2A 81A0      LD	R26,Z
    01B2B 81B1      LDD	R27,Z+1
    01B2C 01FD      MOVW	R30,R26
    01B2D 91BF      POP	R27
    01B2E 91AF      POP	R26
    01B2F 8182      LDD	R24,Z+2
    01B30 2799      CLR	R25
    01B31 9701      SBIW	R24,1
    01B32 013C      MOVW	R6,R24
    01B33 2488      CLR	R8
    01B34 FC77      SBRC	R7,7
    01B35 9480      COM	R8
    01B36 2499      CLR	R9
    01B37 FC87      SBRC	R8,7
    01B38 9490      COM	R9
    01B39 2026      AND	R2,R6
    01B3A 2037      AND	R3,R7
    01B3B 2048      AND	R4,R8
    01B3C 2059      AND	R5,R9
    01B3D 2CC2      MOV	R12,R2
(2503) 			if (!csect) {					/* On the cluster boundary? */
    01B3E 2022      TST	R2
    01B3F F009      BEQ	0x1B41
    01B40 C0A5      RJMP	0x1BE6
(2504) 				if (fp->fptr == 0) {		/* On the top of the file? */
    01B41 8DEB      LDD	R30,Y+27
    01B42 8DFC      LDD	R31,Y+28
    01B43 9636      ADIW	R30,6
    01B44 8020      LD	R2,Z
    01B45 8031      LDD	R3,Z+1
    01B46 8042      LDD	R4,Z+2
    01B47 8053      LDD	R5,Z+3
    01B48 9488      BCLR	0
    01B49 2022      TST	R2
    01B4A 0432      CPC	R3,R2
    01B4B 0442      CPC	R4,R2
    01B4C 0452      CPC	R5,R2
    01B4D F571      BNE	0x1B7C
(2505) 					clst = fp->sclust;		/* Follow from the origin */
    01B4E 8DEB      LDD	R30,Y+27
    01B4F 8DFC      LDD	R31,Y+28
    01B50 963E      ADIW	R30,0xE
    01B51 8020      LD	R2,Z
    01B52 8031      LDD	R3,Z+1
    01B53 8042      LDD	R4,Z+2
    01B54 8053      LDD	R5,Z+3
    01B55 8629      STD	Y+9,R2
    01B56 863A      STD	Y+10,R3
    01B57 864B      STD	Y+11,R4
    01B58 865C      STD	Y+12,R5
(2506) 					if (clst == 0)			/* When no cluster is allocated, */
    01B59 8429      LDD	R2,Y+9
    01B5A 843A      LDD	R3,Y+10
    01B5B 844B      LDD	R4,Y+11
    01B5C 845C      LDD	R5,Y+12
    01B5D 9488      BCLR	0
    01B5E 2022      TST	R2
    01B5F 0432      CPC	R3,R2
    01B60 0442      CPC	R4,R2
    01B61 0452      CPC	R5,R2
    01B62 F009      BEQ	0x1B64
    01B63 C040      RJMP	0x1BA4
(2507) 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    01B64 E040      LDI	R20,0
    01B65 E050      LDI	R21,0
    01B66 E060      LDI	R22,0
    01B67 E070      LDI	R23,0
    01B68 8368      ST	Y,R22
    01B69 8379      STD	Y+1,R23
    01B6A 019A      MOVW	R18,R20
    01B6B 8DEB      LDD	R30,Y+27
    01B6C 8DFC      LDD	R31,Y+28
    01B6D 8100      LD	R16,Z
    01B6E 8111      LDD	R17,Z+1
    01B6F 940E 08DB CALL	ff.c:create_chain
    01B71 8709      STD	Y+9,R16
    01B72 871A      STD	Y+10,R17
    01B73 872B      STD	Y+11,R18
    01B74 873C      STD	Y+12,R19
    01B75 8DEB      LDD	R30,Y+27
    01B76 8DFC      LDD	R31,Y+28
    01B77 8706      STD	Z+14,R16
    01B78 8717      STD	Z+15,R17
    01B79 8B20      STD	Z+16,R18
    01B7A 8B31      STD	Z+17,R19
(2508) 				} else {					/* Middle or end of the file */
    01B7B C028      RJMP	0x1BA4
(2509) #if _USE_FASTSEEK
(2510) 					if (fp->cltbl)
    01B7C 8DEB      LDD	R30,Y+27
    01B7D 8DFC      LDD	R31,Y+28
    01B7E A020      LDD	R2,Z+32
    01B7F A031      LDD	R3,Z+33
    01B80 2022      TST	R2
    01B81 F411      BNE	0x1B84
    01B82 2033      TST	R3
    01B83 F079      BEQ	0x1B93
(2511) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    01B84 8026      LDD	R2,Z+6
    01B85 8037      LDD	R3,Z+7
    01B86 8440      LDD	R4,Z+8
    01B87 8451      LDD	R5,Z+9
    01B88 8248      ST	Y,R4
    01B89 8259      STD	Y+1,R5
    01B8A 0191      MOVW	R18,R2
    01B8B 018F      MOVW	R16,R30
    01B8C 940E 0A53 CALL	ff.c:clmt_clust
    01B8E 8709      STD	Y+9,R16
    01B8F 871A      STD	Y+10,R17
    01B90 872B      STD	Y+11,R18
    01B91 873C      STD	Y+12,R19
    01B92 C011      RJMP	0x1BA4
(2512) 					else
(2513) #endif
(2514) 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    01B93 8DEB      LDD	R30,Y+27
    01B94 8DFC      LDD	R31,Y+28
    01B95 8822      LDD	R2,Z+18
    01B96 8833      LDD	R3,Z+19
    01B97 8844      LDD	R4,Z+20
    01B98 8855      LDD	R5,Z+21
    01B99 8248      ST	Y,R4
    01B9A 8259      STD	Y+1,R5
    01B9B 0191      MOVW	R18,R2
    01B9C 8100      LD	R16,Z
    01B9D 8111      LDD	R17,Z+1
    01B9E 940E 08DB CALL	ff.c:create_chain
    01BA0 8709      STD	Y+9,R16
    01BA1 871A      STD	Y+10,R17
    01BA2 872B      STD	Y+11,R18
    01BA3 873C      STD	Y+12,R19
(2515) 				}
(2516) 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    01BA4 8429      LDD	R2,Y+9
    01BA5 843A      LDD	R3,Y+10
    01BA6 844B      LDD	R4,Y+11
    01BA7 845C      LDD	R5,Y+12
    01BA8 9488      BCLR	0
    01BA9 2022      TST	R2
    01BAA 0432      CPC	R3,R2
    01BAB 0442      CPC	R4,R2
    01BAC 0452      CPC	R5,R2
    01BAD F409      BNE	0x1BAF
    01BAE C1FC      RJMP	0x1DAB
(2517) 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    01BAF E041      LDI	R20,1
    01BB0 E050      LDI	R21,0
    01BB1 E060      LDI	R22,0
    01BB2 E070      LDI	R23,0
    01BB3 8429      LDD	R2,Y+9
    01BB4 843A      LDD	R3,Y+10
    01BB5 844B      LDD	R4,Y+11
    01BB6 845C      LDD	R5,Y+12
    01BB7 1624      CP	R2,R20
    01BB8 0635      CPC	R3,R21
    01BB9 0646      CPC	R4,R22
    01BBA 0657      CPC	R5,R23
    01BBB F449      BNE	0x1BC5
    01BBC 8D8B      LDD	R24,Y+27
    01BBD 8D9C      LDD	R25,Y+28
    01BBE 9604      ADIW	R24,4
    01BBF 01FC      MOVW	R30,R24
    01BC0 8180      LD	R24,Z
    01BC1 6880      ORI	R24,0x80
    01BC2 8380      ST	Z,R24
    01BC3 E002      LDI	R16,2
    01BC4 C206      RJMP	0x1DCB
(2518) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01BC5 EF4F      LDI	R20,0xFF
    01BC6 EF5F      LDI	R21,0xFF
    01BC7 EF6F      LDI	R22,0xFF
    01BC8 EF7F      LDI	R23,0xFF
    01BC9 8429      LDD	R2,Y+9
    01BCA 843A      LDD	R3,Y+10
    01BCB 844B      LDD	R4,Y+11
    01BCC 845C      LDD	R5,Y+12
    01BCD 1624      CP	R2,R20
    01BCE 0635      CPC	R3,R21
    01BCF 0646      CPC	R4,R22
    01BD0 0657      CPC	R5,R23
    01BD1 F451      BNE	0x1BDC
    01BD2 8D8B      LDD	R24,Y+27
    01BD3 8D9C      LDD	R25,Y+28
    01BD4 9604      ADIW	R24,4
    01BD5 015C      MOVW	R10,R24
    01BD6 01FC      MOVW	R30,R24
    01BD7 8180      LD	R24,Z
    01BD8 6880      ORI	R24,0x80
    01BD9 8380      ST	Z,R24
    01BDA E001      LDI	R16,1
    01BDB C1EF      RJMP	0x1DCB
(2519) 				fp->clust = clst;			/* Update current cluster */
    01BDC 8429      LDD	R2,Y+9
    01BDD 843A      LDD	R3,Y+10
    01BDE 844B      LDD	R4,Y+11
    01BDF 845C      LDD	R5,Y+12
    01BE0 8DEB      LDD	R30,Y+27
    01BE1 8DFC      LDD	R31,Y+28
    01BE2 8A22      STD	Z+18,R2
    01BE3 8A33      STD	Z+19,R3
    01BE4 8A44      STD	Z+20,R4
    01BE5 8A55      STD	Z+21,R5
(2520) 			}
(2521) #if _FS_TINY
(2522) 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
    01BE6 8DEB      LDD	R30,Y+27
    01BE7 8DFC      LDD	R31,Y+28
    01BE8 80A0      LD	R10,Z
    01BE9 80B1      LDD	R11,Z+1
    01BEA 8826      LDD	R2,Z+22
    01BEB 8837      LDD	R3,Z+23
    01BEC 8C40      LDD	R4,Z+24
    01BED 8C51      LDD	R5,Z+25
    01BEE 01F5      MOVW	R30,R10
    01BEF A462      LDD	R6,Z+42
    01BF0 A473      LDD	R7,Z+43
    01BF1 A484      LDD	R8,Z+44
    01BF2 A495      LDD	R9,Z+45
    01BF3 1462      CP	R6,R2
    01BF4 0473      CPC	R7,R3
    01BF5 0484      CPC	R8,R4
    01BF6 0495      CPC	R9,R5
    01BF7 F4B9      BNE	0x1C0F
    01BF8 E040      LDI	R20,0
    01BF9 E050      LDI	R21,0
    01BFA E060      LDI	R22,0
    01BFB E070      LDI	R23,0
    01BFC 8368      ST	Y,R22
    01BFD 8379      STD	Y+1,R23
    01BFE 019A      MOVW	R18,R20
    01BFF 018F      MOVW	R16,R30
    01C00 940E 0350 CALL	ff.c:move_window
    01C02 2EA0      MOV	R10,R16
    01C03 2300      TST	R16
    01C04 F051      BEQ	0x1C0F
(2523) 				ABORT(fp->fs, FR_DISK_ERR);
    01C05 8D8B      LDD	R24,Y+27
    01C06 8D9C      LDD	R25,Y+28
    01C07 9604      ADIW	R24,4
    01C08 015C      MOVW	R10,R24
    01C09 01FC      MOVW	R30,R24
    01C0A 8180      LD	R24,Z
    01C0B 6880      ORI	R24,0x80
    01C0C 8380      ST	Z,R24
    01C0D E001      LDI	R16,1
    01C0E C1BC      RJMP	0x1DCB
(2524) #else
(2525) 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
(2526) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2527) 					ABORT(fp->fs, FR_DISK_ERR);
(2528) 				fp->flag &= ~FA__DIRTY;
(2529) 			}
(2530) #endif
(2531) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01C0F 8DEB      LDD	R30,Y+27
    01C10 8DFC      LDD	R31,Y+28
    01C11 8822      LDD	R2,Z+18
    01C12 8833      LDD	R3,Z+19
    01C13 8844      LDD	R4,Z+20
    01C14 8855      LDD	R5,Z+21
    01C15 8248      ST	Y,R4
    01C16 8259      STD	Y+1,R5
    01C17 0191      MOVW	R18,R2
    01C18 8100      LD	R16,Z
    01C19 8111      LDD	R17,Z+1
    01C1A 940E 04C7 CALL	_clust2sect
    01C1C 830D      STD	Y+5,R16
    01C1D 831E      STD	Y+6,R17
    01C1E 832F      STD	Y+7,R18
    01C1F 8738      STD	Y+8,R19
(2532) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01C20 802D      LDD	R2,Y+5
    01C21 803E      LDD	R3,Y+6
    01C22 804F      LDD	R4,Y+7
    01C23 8458      LDD	R5,Y+8
    01C24 9488      BCLR	0
    01C25 2022      TST	R2
    01C26 0432      CPC	R3,R2
    01C27 0442      CPC	R4,R2
    01C28 0452      CPC	R5,R2
    01C29 F451      BNE	0x1C34
    01C2A 8D8B      LDD	R24,Y+27
    01C2B 8D9C      LDD	R25,Y+28
    01C2C 9604      ADIW	R24,4
    01C2D 015C      MOVW	R10,R24
    01C2E 01FC      MOVW	R30,R24
    01C2F 8180      LD	R24,Z
    01C30 6880      ORI	R24,0x80
    01C31 8380      ST	Z,R24
    01C32 E002      LDI	R16,2
    01C33 C197      RJMP	0x1DCB
(2533) 			sect += csect;
    01C34 2C2C      MOV	R2,R12
    01C35 2433      CLR	R3
    01C36 2444      CLR	R4
    01C37 2455      CLR	R5
    01C38 806D      LDD	R6,Y+5
    01C39 807E      LDD	R7,Y+6
    01C3A 808F      LDD	R8,Y+7
    01C3B 8498      LDD	R9,Y+8
    01C3C 0C62      ADD	R6,R2
    01C3D 1C73      ADC	R7,R3
    01C3E 1C84      ADC	R8,R4
    01C3F 1C95      ADC	R9,R5
    01C40 826D      STD	Y+5,R6
    01C41 827E      STD	Y+6,R7
    01C42 828F      STD	Y+7,R8
    01C43 8698      STD	Y+8,R9
(2534) 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    01C44 E029      LDI	R18,0x9
    01C45 E030      LDI	R19,0
    01C46 8D0F      LDD	R16,Y+31
    01C47 A118      LDD	R17,Y+32
    01C48 940E 41FF CALL	lsr16
    01C4A 0158      MOVW	R10,R16
(2535) 			if (cc) {						/* Write maximum contiguous sectors directly */
    01C4B 3000      CPI	R16,0
    01C4C 0701      CPC	R16,R17
    01C4D F409      BNE	0x1C4F
    01C4E C097      RJMP	0x1CE6
(2536) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01C4F 2C2C      MOV	R2,R12
    01C50 2433      CLR	R3
    01C51 0E20      ADD	R2,R16
    01C52 1E31      ADC	R3,R17
    01C53 8DEB      LDD	R30,Y+27
    01C54 8DFC      LDD	R31,Y+28
    01C55 93AF      PUSH	R26
    01C56 93BF      PUSH	R27
    01C57 81A0      LD	R26,Z
    01C58 81B1      LDD	R27,Z+1
    01C59 01FD      MOVW	R30,R26
    01C5A 91BF      POP	R27
    01C5B 91AF      POP	R26
    01C5C 8042      LDD	R4,Z+2
    01C5D 2455      CLR	R5
    01C5E 1442      CP	R4,R2
    01C5F 0453      CPC	R5,R3
    01C60 F478      BCC	0x1C70
(2537) 					cc = fp->fs->csize - csect;
    01C61 2C2C      MOV	R2,R12
    01C62 2433      CLR	R3
    01C63 8DEB      LDD	R30,Y+27
    01C64 8DFC      LDD	R31,Y+28
    01C65 93AF      PUSH	R26
    01C66 93BF      PUSH	R27
    01C67 81A0      LD	R26,Z
    01C68 81B1      LDD	R27,Z+1
    01C69 01FD      MOVW	R30,R26
    01C6A 91BF      POP	R27
    01C6B 91AF      POP	R26
    01C6C 80A2      LDD	R10,Z+2
    01C6D 24BB      CLR	R11
    01C6E 18A2      SUB	R10,R2
    01C6F 08B3      SBC	R11,R3
(2538) 				if (disk_write(fp->fs->drv,(char*)wbuff, sect, (BYTE)cc) != RES_OK)
    01C70 82AC      STD	Y+4,R10
    01C71 802D      LDD	R2,Y+5
    01C72 803E      LDD	R3,Y+6
    01C73 804F      LDD	R4,Y+7
    01C74 8458      LDD	R5,Y+8
    01C75 8228      ST	Y,R2
    01C76 8239      STD	Y+1,R3
    01C77 824A      STD	Y+2,R4
    01C78 825B      STD	Y+3,R5
    01C79 0197      MOVW	R18,R14
    01C7A 8DEB      LDD	R30,Y+27
    01C7B 8DFC      LDD	R31,Y+28
    01C7C 93AF      PUSH	R26
    01C7D 93BF      PUSH	R27
    01C7E 81A0      LD	R26,Z
    01C7F 81B1      LDD	R27,Z+1
    01C80 01FD      MOVW	R30,R26
    01C81 91BF      POP	R27
    01C82 91AF      POP	R26
    01C83 8101      LDD	R16,Z+1
    01C84 940E 02D5 CALL	_disk_write
    01C86 2EC0      MOV	R12,R16
    01C87 2300      TST	R16
    01C88 F051      BEQ	0x1C93
(2539) 					ABORT(fp->fs, FR_DISK_ERR);
    01C89 8D8B      LDD	R24,Y+27
    01C8A 8D9C      LDD	R25,Y+28
    01C8B 9604      ADIW	R24,4
    01C8C 016C      MOVW	R12,R24
    01C8D 01FC      MOVW	R30,R24
    01C8E 8180      LD	R24,Z
    01C8F 6880      ORI	R24,0x80
    01C90 8380      ST	Z,R24
    01C91 E001      LDI	R16,1
    01C92 C138      RJMP	0x1DCB
(2540) #if _FS_TINY
(2541) 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
    01C93 802D      LDD	R2,Y+5
    01C94 803E      LDD	R3,Y+6
    01C95 804F      LDD	R4,Y+7
    01C96 8458      LDD	R5,Y+8
    01C97 8DEB      LDD	R30,Y+27
    01C98 8DFC      LDD	R31,Y+28
    01C99 81A0      LD	R26,Z
    01C9A 81B1      LDD	R27,Z+1
    01C9B 969A      ADIW	R26,0x2A
    01C9C 906D      LD	R6,X+
    01C9D 907D      LD	R7,X+
    01C9E 908D      LD	R8,X+
    01C9F 909C      LD	R9,X
    01CA0 1862      SUB	R6,R2
    01CA1 0873      SBC	R7,R3
    01CA2 0884      SBC	R8,R4
    01CA3 0895      SBC	R9,R5
    01CA4 0115      MOVW	R2,R10
    01CA5 2444      CLR	R4
    01CA6 2455      CLR	R5
    01CA7 1462      CP	R6,R2
    01CA8 0473      CPC	R7,R3
    01CA9 0484      CPC	R8,R4
    01CAA 0495      CPC	R9,R5
    01CAB F008      BCS	0x1CAD
    01CAC C032      RJMP	0x1CDF
(2542) 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
    01CAD E080      LDI	R24,0
    01CAE E092      LDI	R25,2
    01CAF 8399      STD	Y+1,R25
    01CB0 8388      ST	Y,R24
    01CB1 80C0      LD	R12,Z
    01CB2 80D1      LDD	R13,Z+1
    01CB3 802D      LDD	R2,Y+5
    01CB4 803E      LDD	R3,Y+6
    01CB5 804F      LDD	R4,Y+7
    01CB6 8458      LDD	R5,Y+8
    01CB7 01F6      MOVW	R30,R12
    01CB8 A462      LDD	R6,Z+42
    01CB9 A473      LDD	R7,Z+43
    01CBA A484      LDD	R8,Z+44
    01CBB A495      LDD	R9,Z+45
    01CBC 1862      SUB	R6,R2
    01CBD 0873      SBC	R7,R3
    01CBE 0884      SBC	R8,R4
    01CBF 0895      SBC	R9,R5
    01CC0 E040      LDI	R20,0
    01CC1 E052      LDI	R21,2
    01CC2 E060      LDI	R22,0
    01CC3 E070      LDI	R23,0
    01CC4 929A      ST	-Y,R9
    01CC5 928A      ST	-Y,R8
    01CC6 927A      ST	-Y,R7
    01CC7 926A      ST	-Y,R6
    01CC8 018A      MOVW	R16,R20
    01CC9 019B      MOVW	R18,R22
    01CCA 940E 4117 CALL	empy32u|empy32s
    01CCC 0198      MOVW	R18,R16
    01CCD 0D2E      ADD	R18,R14
    01CCE 1D3F      ADC	R19,R15
    01CCF 0186      MOVW	R16,R12
    01CD0 5D02      SUBI	R16,0xD2
    01CD1 4F1F      SBCI	R17,0xFF
    01CD2 940E 02F7 CALL	ff.c:mem_cpy
(2543) 					fp->fs->wflag = 0;
    01CD4 2422      CLR	R2
    01CD5 8DEB      LDD	R30,Y+27
    01CD6 8DFC      LDD	R31,Y+28
    01CD7 93AF      PUSH	R26
    01CD8 93BF      PUSH	R27
    01CD9 81A0      LD	R26,Z
    01CDA 81B1      LDD	R27,Z+1
    01CDB 01FD      MOVW	R30,R26
    01CDC 91BF      POP	R27
    01CDD 91AF      POP	R26
    01CDE 8224      STD	Z+4,R2
(2544) 				}
(2545) #else
(2546) 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
(2547) 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
(2548) 					fp->flag &= ~FA__DIRTY;
(2549) 				}
(2550) #endif
(2551) 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    01CDF E000      LDI	R16,0
    01CE0 E012      LDI	R17,2
    01CE1 0195      MOVW	R18,R10
    01CE2 940E 4107 CALL	empy16s
    01CE4 0168      MOVW	R12,R16
(2552) 				continue;
    01CE5 C099      RJMP	0x1D7F
(2553) 			}
(2554) #if _FS_TINY
(2555) 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
    01CE6 8DEB      LDD	R30,Y+27
    01CE7 8DFC      LDD	R31,Y+28
    01CE8 8422      LDD	R2,Z+10
    01CE9 8433      LDD	R3,Z+11
    01CEA 8444      LDD	R4,Z+12
    01CEB 8455      LDD	R5,Z+13
    01CEC 8066      LDD	R6,Z+6
    01CED 8077      LDD	R7,Z+7
    01CEE 8480      LDD	R8,Z+8
    01CEF 8491      LDD	R9,Z+9
    01CF0 1462      CP	R6,R2
    01CF1 0473      CPC	R7,R3
    01CF2 0484      CPC	R8,R4
    01CF3 0495      CPC	R9,R5
    01CF4 F128      BCS	0x1D1A
(2556) 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    01CF5 E040      LDI	R20,0
    01CF6 E050      LDI	R21,0
    01CF7 E060      LDI	R22,0
    01CF8 E070      LDI	R23,0
    01CF9 8368      ST	Y,R22
    01CFA 8379      STD	Y+1,R23
    01CFB 019A      MOVW	R18,R20
    01CFC 8100      LD	R16,Z
    01CFD 8111      LDD	R17,Z+1
    01CFE 940E 0350 CALL	ff.c:move_window
    01D00 2EA0      MOV	R10,R16
    01D01 2300      TST	R16
    01D02 F051      BEQ	0x1D0D
    01D03 8D8B      LDD	R24,Y+27
    01D04 8D9C      LDD	R25,Y+28
    01D05 9604      ADIW	R24,4
    01D06 015C      MOVW	R10,R24
    01D07 01FC      MOVW	R30,R24
    01D08 8180      LD	R24,Z
    01D09 6880      ORI	R24,0x80
    01D0A 8380      ST	Z,R24
    01D0B E001      LDI	R16,1
    01D0C C0BE      RJMP	0x1DCB
(2557) 				fp->fs->winsect = sect;
    01D0D 802D      LDD	R2,Y+5
    01D0E 803E      LDD	R3,Y+6
    01D0F 804F      LDD	R4,Y+7
    01D10 8458      LDD	R5,Y+8
    01D11 8DEB      LDD	R30,Y+27
    01D12 8DFC      LDD	R31,Y+28
    01D13 81A0      LD	R26,Z
    01D14 81B1      LDD	R27,Z+1
    01D15 969A      ADIW	R26,0x2A
    01D16 922D      ST	X+,R2
    01D17 923D      ST	X+,R3
    01D18 924D      ST	X+,R4
    01D19 925C      ST	X,R5
(2558) 			}
(2559) #else
(2560) 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
(2561) 				if (fp->fptr < fp->fsize &&
(2562) 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
(2563) 						ABORT(fp->fs, FR_DISK_ERR);
(2564) 			}
(2565) #endif
(2566) 			fp->dsect = sect;
    01D1A 802D      LDD	R2,Y+5
    01D1B 803E      LDD	R3,Y+6
    01D1C 804F      LDD	R4,Y+7
    01D1D 8458      LDD	R5,Y+8
    01D1E 8DEB      LDD	R30,Y+27
    01D1F 8DFC      LDD	R31,Y+28
    01D20 8A26      STD	Z+22,R2
    01D21 8A37      STD	Z+23,R3
    01D22 8E40      STD	Z+24,R4
    01D23 8E51      STD	Z+25,R5
(2567) 		}
(2568) 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    01D24 EF4F      LDI	R20,0xFF
    01D25 E051      LDI	R21,1
    01D26 E060      LDI	R22,0
    01D27 E070      LDI	R23,0
    01D28 8DEB      LDD	R30,Y+27
    01D29 8DFC      LDD	R31,Y+28
    01D2A 8026      LDD	R2,Z+6
    01D2B 8037      LDD	R3,Z+7
    01D2C 8440      LDD	R4,Z+8
    01D2D 8451      LDD	R5,Z+9
    01D2E 2224      AND	R2,R20
    01D2F 2235      AND	R3,R21
    01D30 2246      AND	R4,R22
    01D31 2257      AND	R5,R23
    01D32 E040      LDI	R20,0
    01D33 E052      LDI	R21,2
    01D34 E060      LDI	R22,0
    01D35 E070      LDI	R23,0
    01D36 1942      SUB	R20,R2
    01D37 0953      SBC	R21,R3
    01D38 0964      SBC	R22,R4
    01D39 0975      SBC	R23,R5
    01D3A 016A      MOVW	R12,R20
(2569) 		if (wcnt > btw) wcnt = btw;
    01D3B 8C0F      LDD	R0,Y+31
    01D3C A018      LDD	R1,Y+32
    01D3D 1604      CP	R0,R20
    01D3E 0615      CPC	R1,R21
    01D3F F408      BCC	0x1D41
    01D40 0160      MOVW	R12,R0
(2570) #if _FS_TINY
(2571) 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
    01D41 8DEB      LDD	R30,Y+27
    01D42 8DFC      LDD	R31,Y+28
    01D43 8826      LDD	R2,Z+22
    01D44 8837      LDD	R3,Z+23
    01D45 8C40      LDD	R4,Z+24
    01D46 8C51      LDD	R5,Z+25
    01D47 8248      ST	Y,R4
    01D48 8259      STD	Y+1,R5
    01D49 0191      MOVW	R18,R2
    01D4A 8100      LD	R16,Z
    01D4B 8111      LDD	R17,Z+1
    01D4C 940E 0350 CALL	ff.c:move_window
    01D4E 2EA0      MOV	R10,R16
    01D4F 2300      TST	R16
    01D50 F051      BEQ	0x1D5B
(2572) 			ABORT(fp->fs, FR_DISK_ERR);
    01D51 8D8B      LDD	R24,Y+27
    01D52 8D9C      LDD	R25,Y+28
    01D53 9604      ADIW	R24,4
    01D54 015C      MOVW	R10,R24
    01D55 01FC      MOVW	R30,R24
    01D56 8180      LD	R24,Z
    01D57 6880      ORI	R24,0x80
    01D58 8380      ST	Z,R24
    01D59 E001      LDI	R16,1
    01D5A C070      RJMP	0x1DCB
(2573) 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    01D5B 82D9      STD	Y+1,R13
    01D5C 82C8      ST	Y,R12
    01D5D 0197      MOVW	R18,R14
    01D5E EF4F      LDI	R20,0xFF
    01D5F E051      LDI	R21,1
    01D60 E060      LDI	R22,0
    01D61 E070      LDI	R23,0
    01D62 8DEB      LDD	R30,Y+27
    01D63 8DFC      LDD	R31,Y+28
    01D64 8026      LDD	R2,Z+6
    01D65 8037      LDD	R3,Z+7
    01D66 8440      LDD	R4,Z+8
    01D67 8451      LDD	R5,Z+9
    01D68 2224      AND	R2,R20
    01D69 2235      AND	R3,R21
    01D6A 2246      AND	R4,R22
    01D6B 2257      AND	R5,R23
    01D6C 0181      MOVW	R16,R2
    01D6D 8180      LD	R24,Z
    01D6E 8191      LDD	R25,Z+1
    01D6F 968E      ADIW	R24,0x2E
    01D70 0F08      ADD	R16,R24
    01D71 1F19      ADC	R17,R25
    01D72 940E 02F7 CALL	ff.c:mem_cpy
(2574) 		fp->fs->wflag = 1;
    01D74 E081      LDI	R24,1
    01D75 8DEB      LDD	R30,Y+27
    01D76 8DFC      LDD	R31,Y+28
    01D77 93AF      PUSH	R26
    01D78 93BF      PUSH	R27
    01D79 81A0      LD	R26,Z
    01D7A 81B1      LDD	R27,Z+1
    01D7B 01FD      MOVW	R30,R26
    01D7C 91BF      POP	R27
    01D7D 91AF      POP	R26
    01D7E 8384      STD	Z+4,R24
    01D7F 0CEC      ADD	R14,R12
    01D80 1CFD      ADC	R15,R13
    01D81 8D8B      LDD	R24,Y+27
    01D82 8D9C      LDD	R25,Y+28
    01D83 9606      ADIW	R24,6
    01D84 015C      MOVW	R10,R24
    01D85 0116      MOVW	R2,R12
    01D86 2444      CLR	R4
    01D87 2455      CLR	R5
    01D88 01FC      MOVW	R30,R24
    01D89 8060      LD	R6,Z
    01D8A 8071      LDD	R7,Z+1
    01D8B 8082      LDD	R8,Z+2
    01D8C 8093      LDD	R9,Z+3
    01D8D 0C62      ADD	R6,R2
    01D8E 1C73      ADC	R7,R3
    01D8F 1C84      ADC	R8,R4
    01D90 1C95      ADC	R9,R5
    01D91 8260      ST	Z,R6
    01D92 8271      STD	Z+1,R7
    01D93 8282      STD	Z+2,R8
    01D94 8293      STD	Z+3,R9
    01D95 A1E9      LDD	R30,Y+33
    01D96 A1FA      LDD	R31,Y+34
    01D97 8020      LD	R2,Z
    01D98 8031      LDD	R3,Z+1
    01D99 0C2C      ADD	R2,R12
    01D9A 1C3D      ADC	R3,R13
    01D9B 8231      STD	Z+1,R3
    01D9C 8220      ST	Z,R2
    01D9D 8C0F      LDD	R0,Y+31
    01D9E A018      LDD	R1,Y+32
    01D9F 180C      SUB	R0,R12
    01DA0 081D      SBC	R1,R13
    01DA1 A218      STD	Y+32,R1
    01DA2 8E0F      STD	Y+31,R0
    01DA3 8C0F      LDD	R0,Y+31
    01DA4 A018      LDD	R1,Y+32
    01DA5 2000      TST	R0
    01DA6 F009      BEQ	0x1DA8
    01DA7 CD5B      RJMP	0x1B03
    01DA8 2011      TST	R1
    01DA9 F009      BEQ	0x1DAB
    01DAA CD58      RJMP	0x1B03
(2575) #else
(2576) 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
(2577) 		fp->flag |= FA__DIRTY;
(2578) #endif
(2579) 	}
(2580) 
(2581) 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    01DAB 8DEB      LDD	R30,Y+27
    01DAC 8DFC      LDD	R31,Y+28
    01DAD 8422      LDD	R2,Z+10
    01DAE 8433      LDD	R3,Z+11
    01DAF 8444      LDD	R4,Z+12
    01DB0 8455      LDD	R5,Z+13
    01DB1 8066      LDD	R6,Z+6
    01DB2 8077      LDD	R7,Z+7
    01DB3 8480      LDD	R8,Z+8
    01DB4 8491      LDD	R9,Z+9
    01DB5 1426      CP	R2,R6
    01DB6 0437      CPC	R3,R7
    01DB7 0448      CPC	R4,R8
    01DB8 0459      CPC	R5,R9
    01DB9 F440      BCC	0x1DC2
    01DBA 8026      LDD	R2,Z+6
    01DBB 8037      LDD	R3,Z+7
    01DBC 8440      LDD	R4,Z+8
    01DBD 8451      LDD	R5,Z+9
    01DBE 8622      STD	Z+10,R2
    01DBF 8633      STD	Z+11,R3
    01DC0 8644      STD	Z+12,R4
    01DC1 8655      STD	Z+13,R5
(2582) 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    01DC2 8D8B      LDD	R24,Y+27
    01DC3 8D9C      LDD	R25,Y+28
    01DC4 9604      ADIW	R24,4
    01DC5 015C      MOVW	R10,R24
    01DC6 01FC      MOVW	R30,R24
    01DC7 8180      LD	R24,Z
    01DC8 6280      ORI	R24,0x20
    01DC9 8380      ST	Z,R24
(2583) 
(2584) 	LEAVE_FF(fp->fs, FR_OK);
    01DCA 2700      CLR	R16
    01DCB 9661      ADIW	R28,0x11
    01DCC 940E 4160 CALL	pop_xgsetF0FC
    01DCE 9624      ADIW	R28,4
    01DCF 9508      RET
_f_sync:
  tim                  --> Y,+2
  dir                  --> R22
  res                  --> R10
  fp                   --> R20
    01DD0 940E 41A6 CALL	push_xgsetF03C
    01DD2 01A8      MOVW	R20,R16
    01DD3 9726      SBIW	R28,6
(2585) }
(2586) 
(2587) 
(2588) 
(2589) 
(2590) /*-----------------------------------------------------------------------*/
(2591) /* Synchronize the File Object                                           */
(2592) /*-----------------------------------------------------------------------*/
(2593) 
(2594) FRESULT f_sync (
(2595) 	FIL *fp		/* Pointer to the file object */
(2596) )
(2597) {
(2598) 	FRESULT res;
(2599) 	DWORD tim;
(2600) 	BYTE *dir;
(2601) 
(2602) 
(2603) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01DD4 01FA      MOVW	R30,R20
    01DD5 8122      LDD	R18,Z+2
    01DD6 8133      LDD	R19,Z+3
    01DD7 8100      LD	R16,Z
    01DD8 8111      LDD	R17,Z+1
    01DD9 D88E      RCALL	ff.c:validate
    01DDA 2EA0      MOV	R10,R16
(2604) 	if (res == FR_OK) {
    01DDB 2300      TST	R16
    01DDC F009      BEQ	0x1DDE
    01DDD C09F      RJMP	0x1E7D
(2605) 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    01DDE 01FA      MOVW	R30,R20
    01DDF 8024      LDD	R2,Z+4
    01DE0 FE25      SBRS	R2,5
    01DE1 C09B      RJMP	0x1E7D
(2606) #if !_FS_TINY	/* Write-back dirty buffer */
(2607) 			if (fp->flag & FA__DIRTY) {
(2608) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2609) 					LEAVE_FF(fp->fs, FR_DISK_ERR);
(2610) 				fp->flag &= ~FA__DIRTY;
(2611) 			}
(2612) #endif
(2613) 			/* Update the directory entry */
(2614) 			res = move_window(fp->fs, fp->dir_sect);
    01DE2 8C22      LDD	R2,Z+26
    01DE3 8C33      LDD	R3,Z+27
    01DE4 8C44      LDD	R4,Z+28
    01DE5 8C55      LDD	R5,Z+29
    01DE6 8248      ST	Y,R4
    01DE7 8259      STD	Y+1,R5
    01DE8 0191      MOVW	R18,R2
    01DE9 8100      LD	R16,Z
    01DEA 8111      LDD	R17,Z+1
    01DEB 940E 0350 CALL	ff.c:move_window
    01DED 2EA0      MOV	R10,R16
(2615) 			if (res == FR_OK) {
    01DEE 2300      TST	R16
    01DEF F009      BEQ	0x1DF1
    01DF0 C08C      RJMP	0x1E7D
(2616) 				dir = fp->dir_ptr;
    01DF1 01FA      MOVW	R30,R20
    01DF2 8D66      LDD	R22,Z+30
    01DF3 8D77      LDD	R23,Z+31
(2617) 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    01DF4 01CB      MOVW	R24,R22
    01DF5 960B      ADIW	R24,0xB
    01DF6 01FC      MOVW	R30,R24
    01DF7 8180      LD	R24,Z
    01DF8 6280      ORI	R24,0x20
    01DF9 8380      ST	Z,R24
(2618) 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    01DFA 01FA      MOVW	R30,R20
    01DFB 8422      LDD	R2,Z+10
    01DFC 8433      LDD	R3,Z+11
    01DFD 8444      LDD	R4,Z+12
    01DFE 8455      LDD	R5,Z+13
    01DFF 01FB      MOVW	R30,R22
    01E00 8E24      STD	Z+28,R2
    01E01 01FA      MOVW	R30,R20
    01E02 8422      LDD	R2,Z+10
    01E03 8433      LDD	R3,Z+11
    01E04 2C23      MOV	R2,R3
    01E05 2433      CLR	R3
    01E06 01FB      MOVW	R30,R22
    01E07 8E25      STD	Z+29,R2
    01E08 01FA      MOVW	R30,R20
    01E09 8422      LDD	R2,Z+10
    01E0A 8433      LDD	R3,Z+11
    01E0B 8444      LDD	R4,Z+12
    01E0C 8455      LDD	R5,Z+13
    01E0D 0112      MOVW	R2,R4
    01E0E 2444      CLR	R4
    01E0F 2455      CLR	R5
    01E10 01FB      MOVW	R30,R22
    01E11 8E26      STD	Z+30,R2
    01E12 E188      LDI	R24,0x18
    01E13 E090      LDI	R25,0
    01E14 01FA      MOVW	R30,R20
    01E15 8502      LDD	R16,Z+10
    01E16 8513      LDD	R17,Z+11
    01E17 8524      LDD	R18,Z+12
    01E18 8535      LDD	R19,Z+13
    01E19 938A      ST	-Y,R24
    01E1A 940E 4206 CALL	lsr32
    01E1C 01FB      MOVW	R30,R22
    01E1D 8F07      STD	Z+31,R16
(2619) 				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    01E1E 01FA      MOVW	R30,R20
    01E1F 8426      LDD	R2,Z+14
    01E20 8437      LDD	R3,Z+15
    01E21 8840      LDD	R4,Z+16
    01E22 8851      LDD	R5,Z+17
    01E23 01FB      MOVW	R30,R22
    01E24 8E22      STD	Z+26,R2
    01E25 01FA      MOVW	R30,R20
    01E26 8426      LDD	R2,Z+14
    01E27 8437      LDD	R3,Z+15
    01E28 2C23      MOV	R2,R3
    01E29 2433      CLR	R3
    01E2A 01FB      MOVW	R30,R22
    01E2B 8E23      STD	Z+27,R2
    01E2C 01FA      MOVW	R30,R20
    01E2D 8426      LDD	R2,Z+14
    01E2E 8437      LDD	R3,Z+15
    01E2F 8840      LDD	R4,Z+16
    01E30 8851      LDD	R5,Z+17
    01E31 0112      MOVW	R2,R4
    01E32 2444      CLR	R4
    01E33 2455      CLR	R5
    01E34 01FB      MOVW	R30,R22
    01E35 8A24      STD	Z+20,R2
    01E36 01FA      MOVW	R30,R20
    01E37 8426      LDD	R2,Z+14
    01E38 8437      LDD	R3,Z+15
    01E39 8840      LDD	R4,Z+16
    01E3A 8851      LDD	R5,Z+17
    01E3B 0112      MOVW	R2,R4
    01E3C 2C23      MOV	R2,R3
    01E3D 2433      CLR	R3
    01E3E 01FB      MOVW	R30,R22
    01E3F 8A25      STD	Z+21,R2
(2620) 				tim = get_fattime();						/* Update updated time */
    01E40 940E 02F2 CALL	_get_fattime
    01E42 830A      STD	Y+2,R16
    01E43 831B      STD	Y+3,R17
    01E44 832C      STD	Y+4,R18
    01E45 833D      STD	Y+5,R19
(2621) 				ST_DWORD(dir+DIR_WrtTime, tim);
    01E46 802A      LDD	R2,Y+2
    01E47 803B      LDD	R3,Y+3
    01E48 804C      LDD	R4,Y+4
    01E49 805D      LDD	R5,Y+5
    01E4A 01FB      MOVW	R30,R22
    01E4B 8A26      STD	Z+22,R2
    01E4C 2C23      MOV	R2,R3
    01E4D 2433      CLR	R3
    01E4E 9677      ADIW	R30,0x17
    01E4F 8220      ST	Z,R2
    01E50 802A      LDD	R2,Y+2
    01E51 803B      LDD	R3,Y+3
    01E52 804C      LDD	R4,Y+4
    01E53 805D      LDD	R5,Y+5
    01E54 0112      MOVW	R2,R4
    01E55 2444      CLR	R4
    01E56 2455      CLR	R5
    01E57 01FB      MOVW	R30,R22
    01E58 9678      ADIW	R30,0x18
    01E59 8220      ST	Z,R2
    01E5A E188      LDI	R24,0x18
    01E5B E090      LDI	R25,0
    01E5C 810A      LDD	R16,Y+2
    01E5D 811B      LDD	R17,Y+3
    01E5E 812C      LDD	R18,Y+4
    01E5F 813D      LDD	R19,Y+5
    01E60 938A      ST	-Y,R24
    01E61 940E 4206 CALL	lsr32
    01E63 01FB      MOVW	R30,R22
    01E64 8F01      STD	Z+25,R16
(2622) 				fp->flag &= ~FA__WRITTEN;
    01E65 01BA      MOVW	R22,R20
    01E66 5F6C      SUBI	R22,0xFC
    01E67 4F7F      SBCI	R23,0xFF
    01E68 01FB      MOVW	R30,R22
    01E69 8180      LD	R24,Z
    01E6A 7D8F      ANDI	R24,0xDF
    01E6B 8380      ST	Z,R24
(2623) 				fp->fs->wflag = 1;
    01E6C E081      LDI	R24,1
    01E6D 01FA      MOVW	R30,R20
    01E6E 93AF      PUSH	R26
    01E6F 93BF      PUSH	R27
    01E70 81A0      LD	R26,Z
    01E71 81B1      LDD	R27,Z+1
    01E72 01FD      MOVW	R30,R26
    01E73 91BF      POP	R27
    01E74 91AF      POP	R26
    01E75 8384      STD	Z+4,R24
(2624) 				res = sync(fp->fs);
    01E76 01FA      MOVW	R30,R20
    01E77 8100      LD	R16,Z
    01E78 8111      LDD	R17,Z+1
    01E79 940E 03F2 CALL	ff.c:sync
    01E7B 2EC0      MOV	R12,R16
    01E7C 2CAC      MOV	R10,R12
(2625) 			}
(2626) 		}
(2627) 	}
(2628) 
(2629) 	LEAVE_FF(fp->fs, res);
    01E7D 2D0A      MOV	R16,R10
    01E7E 9626      ADIW	R28,6
    01E7F 940C 41AF JMP	pop_xgsetF03C
_f_close:
  res                  --> R10
  fp                   --> R12
    01E81 940E 4171 CALL	push_xgset003C
    01E83 0168      MOVW	R12,R16
(2630) }
(2631) 
(2632) #endif /* !_FS_READONLY */
(2633) 
(2634) 
(2635) 
(2636) 
(2637) /*-----------------------------------------------------------------------*/
(2638) /* Close File                                                            */
(2639) /*-----------------------------------------------------------------------*/
(2640) 
(2641) FRESULT f_close (
(2642) 	FIL *fp		/* Pointer to the file object to be closed */
(2643) )
(2644) {
(2645) 	FRESULT res;
(2646) 
(2647) #if _FS_READONLY
(2648) 	FATFS *fs = fp->fs;
(2649) 	res = validate(fs, fp->id);
(2650) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
(2651) 	LEAVE_FF(fs, res);
(2652) 
(2653) #else
(2654) 	res = f_sync(fp);		/* Flush cached data */
    01E84 0186      MOVW	R16,R12
    01E85 DF4A      RCALL	_f_sync
    01E86 2EA0      MOV	R10,R16
(2655) #if _FS_SHARE
(2656) 	if (res == FR_OK) {		/* Decrement open counter */
(2657) #if _FS_REENTRANT
(2658) 		res = validate(fp->fs, fp->id);
(2659) 		if (res == FR_OK) {
(2660) 			res = dec_lock(fp->lockid);	
(2661) 			unlock_fs(fp->fs, FR_OK);
(2662) 		}
(2663) #else
(2664) 		res = dec_lock(fp->lockid);
(2665) #endif
(2666) 	}
(2667) #endif
(2668) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    01E87 2300      TST	R16
    01E88 F429      BNE	0x1E8E
    01E89 2422      CLR	R2
    01E8A 2433      CLR	R3
    01E8B 01F6      MOVW	R30,R12
    01E8C 8231      STD	Z+1,R3
    01E8D 8220      ST	Z,R2
(2669) 	return res;
    01E8E 2D0A      MOV	R16,R10
    01E8F 940C 414B JMP	pop_xgset003C
_f_lseek:
  ifptr                --> Y,+14
  nsect                --> Y,+10
  bcs                  --> Y,+6
  clst                 --> Y,+2
  dsc                  --> Y,+26
  tlen                 --> Y,+22
  tbl                  --> R14
  tcl                  --> Y,+18
  ulen                 --> Y,+14
  ncl                  --> Y,+10
  pcl                  --> Y,+6
  cl                   --> Y,+2
  res                  --> R10
  ofs                  --> Y,+42
  fp                   --> Y,+40
    01E91 940E 4026 CALL	push_arg4
    01E93 940E 416B CALL	push_xgsetF0FC
    01E95 976E      SBIW	R28,0x1E
(2670) #endif
(2671) }
(2672) 
(2673) 
(2674) 
(2675) 
(2676) /*-----------------------------------------------------------------------*/
(2677) /* Current Drive/Directory Handlings                                     */
(2678) /*-----------------------------------------------------------------------*/
(2679) 
(2680) #if _FS_RPATH >= 1
(2681) 
(2682) FRESULT f_chdrive (
(2683) 	BYTE drv		/* Drive number */
(2684) )
(2685) {
(2686) 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
(2687) 
(2688) 	CurrVol = drv;
(2689) 
(2690) 	return FR_OK;
(2691) }
(2692) 
(2693) 
(2694) 
(2695) FRESULT f_chdir (
(2696) 	const TCHAR *path	/* Pointer to the directory path */
(2697) )
(2698) {
(2699) 	FRESULT res;
(2700) 	DIR dj;
(2701) 	DEF_NAMEBUF;
(2702) 
(2703) 
(2704) 	res = chk_mounted(&path, &dj.fs, 0);
(2705) 	if (res == FR_OK) {
(2706) 		INIT_BUF(dj);
(2707) 		res = follow_path(&dj, path);		/* Follow the path */
(2708) 		FREE_BUF();
(2709) 		if (res == FR_OK) {					/* Follow completed */
(2710) 			if (!dj.dir) {
(2711) 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
(2712) 			} else {
(2713) 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
(2714) 					dj.fs->cdir = LD_CLUST(dj.dir);
(2715) 				else
(2716) 					res = FR_NO_PATH;		/* Reached but a file */
(2717) 			}
(2718) 		}
(2719) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
(2720) 	}
(2721) 
(2722) 	LEAVE_FF(dj.fs, res);
(2723) }
(2724) 
(2725) 
(2726) #if _FS_RPATH >= 2
(2727) FRESULT f_getcwd (
(2728) 	TCHAR *path,	/* Pointer to the directory path */
(2729) 	UINT sz_path	/* Size of path */
(2730) )
(2731) {
(2732) 	FRESULT res;
(2733) 	DIR dj;
(2734) 	UINT i, n;
(2735) 	DWORD ccl;
(2736) 	TCHAR *tp;
(2737) 	FILINFO fno;
(2738) 	DEF_NAMEBUF;
(2739) 
(2740) 
(2741) 	*path = 0;
(2742) 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
(2743) 	if (res == FR_OK) {
(2744) 		INIT_BUF(dj);
(2745) 		i = sz_path;		/* Bottom of buffer (dir stack base) */
(2746) 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
(2747) 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
(2748) 			res = dir_sdi(&dj, 1);			/* Get parent dir */
(2749) 			if (res != FR_OK) break;
(2750) 			res = dir_read(&dj);
(2751) 			if (res != FR_OK) break;
(2752) 			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
(2753) 			res = dir_sdi(&dj, 0);
(2754) 			if (res != FR_OK) break;
(2755) 			do {							/* Find the entry links to the child dir */
(2756) 				res = dir_read(&dj);
(2757) 				if (res != FR_OK) break;
(2758) 				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
(2759) 				res = dir_next(&dj, 0);	
(2760) 			} while (res == FR_OK);
(2761) 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
(2762) 			if (res != FR_OK) break;
(2763) #if _USE_LFN
(2764) 			fno.lfname = path;
(2765) 			fno.lfsize = i;
(2766) #endif
(2767) 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
(2768) 			tp = fno.fname;
(2769) 			if (_USE_LFN && *path) tp = path;
(2770) 			for (n = 0; tp[n]; n++) ;
(2771) 			if (i < n + 3) {
(2772) 				res = FR_NOT_ENOUGH_CORE; break;
(2773) 			}
(2774) 			while (n) path[--i] = tp[--n];
(2775) 			path[--i] = '/';
(2776) 		}
(2777) 		tp = path;
(2778) 		if (res == FR_OK) {
(2779) 			*tp++ = '0' + CurrVol;			/* Put drive number */
(2780) 			*tp++ = ':';
(2781) 			if (i == sz_path) {				/* Root-dir */
(2782) 				*tp++ = '/';
(2783) 			} else {						/* Sub-dir */
(2784) 				do		/* Add stacked path str */
(2785) 					*tp++ = path[i++];
(2786) 				while (i < sz_path);
(2787) 			}
(2788) 		}
(2789) 		*tp = 0;
(2790) 		FREE_BUF();
(2791) 	}
(2792) 
(2793) 	LEAVE_FF(dj.fs, res);
(2794) }
(2795) #endif /* _FS_RPATH >= 2 */
(2796) #endif /* _FS_RPATH >= 1 */
(2797) 
(2798) 
(2799) 
(2800) #if _FS_MINIMIZE <= 2
(2801) /*-----------------------------------------------------------------------*/
(2802) /* Seek File R/W Pointer                                                 */
(2803) /*-----------------------------------------------------------------------*/
(2804) 
(2805) FRESULT f_lseek (
(2806) 	FIL *fp,		/* Pointer to the file object */
(2807) 	DWORD ofs		/* File pointer from top of file */
(2808) )
(2809) {
(2810) 	FRESULT res;
(2811) 
(2812) 
(2813) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01E96 A5E8      LDD	R30,Y+40
    01E97 A5F9      LDD	R31,Y+41
    01E98 8122      LDD	R18,Z+2
    01E99 8133      LDD	R19,Z+3
    01E9A 8100      LD	R16,Z
    01E9B 8111      LDD	R17,Z+1
    01E9C 940E 1668 CALL	ff.c:validate
    01E9E 2EA0      MOV	R10,R16
(2814) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01E9F 2300      TST	R16
    01EA0 F009      BEQ	0x1EA2
    01EA1 C4A7      RJMP	0x2349
(2815) 	if (fp->flag & FA__ERROR)			/* Check abort flag */
    01EA2 A5E8      LDD	R30,Y+40
    01EA3 A5F9      LDD	R31,Y+41
    01EA4 8024      LDD	R2,Z+4
    01EA5 FE27      SBRS	R2,7
    01EA6 C002      RJMP	0x1EA9
(2816) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01EA7 E002      LDI	R16,2
    01EA8 C4A0      RJMP	0x2349
(2817) 
(2818) #if _USE_FASTSEEK
(2819) 	if (fp->cltbl) {	/* Fast seek */
    01EA9 A5E8      LDD	R30,Y+40
    01EAA A5F9      LDD	R31,Y+41
    01EAB 96B0      ADIW	R30,0x20
    01EAC 8020      LD	R2,Z
    01EAD 8031      LDD	R3,Z+1
    01EAE 2022      TST	R2
    01EAF F419      BNE	0x1EB3
    01EB0 2033      TST	R3
    01EB1 F409      BNE	0x1EB3
    01EB2 C1E3      RJMP	0x2096
(2820) 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
(2821) 
(2822) 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
    01EB3 EF4F      LDI	R20,0xFF
    01EB4 EF5F      LDI	R21,0xFF
    01EB5 EF6F      LDI	R22,0xFF
    01EB6 EF7F      LDI	R23,0xFF
    01EB7 A42A      LDD	R2,Y+42
    01EB8 A43B      LDD	R3,Y+43
    01EB9 A44C      LDD	R4,Y+44
    01EBA A45D      LDD	R5,Y+45
    01EBB 1624      CP	R2,R20
    01EBC 0635      CPC	R3,R21
    01EBD 0646      CPC	R4,R22
    01EBE 0657      CPC	R5,R23
    01EBF F009      BEQ	0x1EC1
    01EC0 C109      RJMP	0x1FCA
(2823) 			tbl = fp->cltbl;
    01EC1 A5E8      LDD	R30,Y+40
    01EC2 A5F9      LDD	R31,Y+41
    01EC3 A0E0      LDD	R14,Z+32
    01EC4 A0F1      LDD	R15,Z+33
(2824) 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
    01EC5 01F7      MOVW	R30,R14
    01EC6 9021      LD	R2,Z+
    01EC7 9031      LD	R3,Z+
    01EC8 9041      LD	R4,Z+
    01EC9 9051      LD	R5,Z+
    01ECA 017F      MOVW	R14,R30
    01ECB 8A2E      STD	Y+22,R2
    01ECC 8A3F      STD	Y+23,R3
    01ECD 8E48      STD	Y+24,R4
    01ECE 8E59      STD	Y+25,R5
    01ECF E082      LDI	R24,2
    01ED0 878E      STD	Y+14,R24
    01ED1 E080      LDI	R24,0
    01ED2 878F      STD	Y+15,R24
    01ED3 8B88      STD	Y+16,R24
    01ED4 8B89      STD	Y+17,R24
(2825) 			cl = fp->sclust;			/* Top of the chain */
    01ED5 A5E8      LDD	R30,Y+40
    01ED6 A5F9      LDD	R31,Y+41
    01ED7 963E      ADIW	R30,0xE
    01ED8 8020      LD	R2,Z
    01ED9 8031      LDD	R3,Z+1
    01EDA 8042      LDD	R4,Z+2
    01EDB 8053      LDD	R5,Z+3
    01EDC 822A      STD	Y+2,R2
    01EDD 823B      STD	Y+3,R3
    01EDE 824C      STD	Y+4,R4
    01EDF 825D      STD	Y+5,R5
(2826) 			if (cl) {
    01EE0 802A      LDD	R2,Y+2
    01EE1 803B      LDD	R3,Y+3
    01EE2 804C      LDD	R4,Y+4
    01EE3 805D      LDD	R5,Y+5
    01EE4 9488      BCLR	0
    01EE5 2022      TST	R2
    01EE6 0432      CPC	R3,R2
    01EE7 0442      CPC	R4,R2
    01EE8 0452      CPC	R5,R2
    01EE9 F409      BNE	0x1EEB
    01EEA C0BB      RJMP	0x1FA6
(2827) 				do {
(2828) 					/* Get a fragment */
(2829) 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
    01EEB 802A      LDD	R2,Y+2
    01EEC 803B      LDD	R3,Y+3
    01EED 804C      LDD	R4,Y+4
    01EEE 805D      LDD	R5,Y+5
    01EEF 8A2A      STD	Y+18,R2
    01EF0 8A3B      STD	Y+19,R3
    01EF1 8A4C      STD	Y+20,R4
    01EF2 8A5D      STD	Y+21,R5
    01EF3 E080      LDI	R24,0
    01EF4 878A      STD	Y+10,R24
    01EF5 878B      STD	Y+11,R24
    01EF6 878C      STD	Y+12,R24
    01EF7 878D      STD	Y+13,R24
    01EF8 E042      LDI	R20,2
    01EF9 E050      LDI	R21,0
    01EFA E060      LDI	R22,0
    01EFB E070      LDI	R23,0
    01EFC 842E      LDD	R2,Y+14
    01EFD 843F      LDD	R3,Y+15
    01EFE 8848      LDD	R4,Y+16
    01EFF 8859      LDD	R5,Y+17
    01F00 0E24      ADD	R2,R20
    01F01 1E35      ADC	R3,R21
    01F02 1E46      ADC	R4,R22
    01F03 1E57      ADC	R5,R23
    01F04 862E      STD	Y+14,R2
    01F05 863F      STD	Y+15,R3
    01F06 8A48      STD	Y+16,R4
    01F07 8A59      STD	Y+17,R5
(2830) 					do {
(2831) 						pcl = cl; ncl++;
    01F08 802A      LDD	R2,Y+2
    01F09 803B      LDD	R3,Y+3
    01F0A 804C      LDD	R4,Y+4
    01F0B 805D      LDD	R5,Y+5
    01F0C 822E      STD	Y+6,R2
    01F0D 823F      STD	Y+7,R3
    01F0E 8648      STD	Y+8,R4
    01F0F 8659      STD	Y+9,R5
    01F10 E041      LDI	R20,1
    01F11 E050      LDI	R21,0
    01F12 E060      LDI	R22,0
    01F13 E070      LDI	R23,0
    01F14 842A      LDD	R2,Y+10
    01F15 843B      LDD	R3,Y+11
    01F16 844C      LDD	R4,Y+12
    01F17 845D      LDD	R5,Y+13
    01F18 0E24      ADD	R2,R20
    01F19 1E35      ADC	R3,R21
    01F1A 1E46      ADC	R4,R22
    01F1B 1E57      ADC	R5,R23
    01F1C 862A      STD	Y+10,R2
    01F1D 863B      STD	Y+11,R3
    01F1E 864C      STD	Y+12,R4
    01F1F 865D      STD	Y+13,R5
(2832) 						cl = get_fat(fp->fs, cl);
    01F20 802A      LDD	R2,Y+2
    01F21 803B      LDD	R3,Y+3
    01F22 804C      LDD	R4,Y+4
    01F23 805D      LDD	R5,Y+5
    01F24 8248      ST	Y,R4
    01F25 8259      STD	Y+1,R5
    01F26 0191      MOVW	R18,R2
    01F27 A5E8      LDD	R30,Y+40
    01F28 A5F9      LDD	R31,Y+41
    01F29 8100      LD	R16,Z
    01F2A 8111      LDD	R17,Z+1
    01F2B 940E 0519 CALL	_get_fat
    01F2D 830A      STD	Y+2,R16
    01F2E 831B      STD	Y+3,R17
    01F2F 832C      STD	Y+4,R18
    01F30 833D      STD	Y+5,R19
(2833) 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
    01F31 E041      LDI	R20,1
    01F32 E050      LDI	R21,0
    01F33 E060      LDI	R22,0
    01F34 E070      LDI	R23,0
    01F35 802A      LDD	R2,Y+2
    01F36 803B      LDD	R3,Y+3
    01F37 804C      LDD	R4,Y+4
    01F38 805D      LDD	R5,Y+5
    01F39 1542      CP	R20,R2
    01F3A 0553      CPC	R21,R3
    01F3B 0564      CPC	R22,R4
    01F3C 0575      CPC	R23,R5
    01F3D F048      BCS	0x1F47
    01F3E A588      LDD	R24,Y+40
    01F3F A599      LDD	R25,Y+41
    01F40 9604      ADIW	R24,4
    01F41 01FC      MOVW	R30,R24
    01F42 8180      LD	R24,Z
    01F43 6880      ORI	R24,0x80
    01F44 8380      ST	Z,R24
    01F45 E002      LDI	R16,2
    01F46 C402      RJMP	0x2349
(2834) 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01F47 EF4F      LDI	R20,0xFF
    01F48 EF5F      LDI	R21,0xFF
    01F49 EF6F      LDI	R22,0xFF
    01F4A EF7F      LDI	R23,0xFF
    01F4B 802A      LDD	R2,Y+2
    01F4C 803B      LDD	R3,Y+3
    01F4D 804C      LDD	R4,Y+4
    01F4E 805D      LDD	R5,Y+5
    01F4F 1624      CP	R2,R20
    01F50 0635      CPC	R3,R21
    01F51 0646      CPC	R4,R22
    01F52 0657      CPC	R5,R23
    01F53 F451      BNE	0x1F5E
    01F54 A588      LDD	R24,Y+40
    01F55 A599      LDD	R25,Y+41
    01F56 9604      ADIW	R24,4
    01F57 016C      MOVW	R12,R24
    01F58 01FC      MOVW	R30,R24
    01F59 8180      LD	R24,Z
    01F5A 6880      ORI	R24,0x80
    01F5B 8380      ST	Z,R24
    01F5C E001      LDI	R16,1
    01F5D C3EB      RJMP	0x2349
(2835) 					} while (cl == pcl + 1);
    01F5E E041      LDI	R20,1
    01F5F E050      LDI	R21,0
    01F60 E060      LDI	R22,0
    01F61 E070      LDI	R23,0
    01F62 802E      LDD	R2,Y+6
    01F63 803F      LDD	R3,Y+7
    01F64 8448      LDD	R4,Y+8
    01F65 8459      LDD	R5,Y+9
    01F66 0E24      ADD	R2,R20
    01F67 1E35      ADC	R3,R21
    01F68 1E46      ADC	R4,R22
    01F69 1E57      ADC	R5,R23
    01F6A 806A      LDD	R6,Y+2
    01F6B 807B      LDD	R7,Y+3
    01F6C 808C      LDD	R8,Y+4
    01F6D 809D      LDD	R9,Y+5
    01F6E 1462      CP	R6,R2
    01F6F 0473      CPC	R7,R3
    01F70 0484      CPC	R8,R4
    01F71 0495      CPC	R9,R5
    01F72 F409      BNE	0x1F74
    01F73 CF94      RJMP	0x1F08
(2836) 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
    01F74 882E      LDD	R2,Y+22
    01F75 883F      LDD	R3,Y+23
    01F76 8C48      LDD	R4,Y+24
    01F77 8C59      LDD	R5,Y+25
    01F78 846E      LDD	R6,Y+14
    01F79 847F      LDD	R7,Y+15
    01F7A 8888      LDD	R8,Y+16
    01F7B 8899      LDD	R9,Y+17
    01F7C 1426      CP	R2,R6
    01F7D 0437      CPC	R3,R7
    01F7E 0448      CPC	R4,R8
    01F7F 0459      CPC	R5,R9
    01F80 F090      BCS	0x1F93
(2837) 						*tbl++ = ncl; *tbl++ = tcl;
    01F81 842A      LDD	R2,Y+10
    01F82 843B      LDD	R3,Y+11
    01F83 844C      LDD	R4,Y+12
    01F84 845D      LDD	R5,Y+13
    01F85 01F7      MOVW	R30,R14
    01F86 9221      ST	Z+,R2
    01F87 9231      ST	Z+,R3
    01F88 9241      ST	Z+,R4
    01F89 9251      ST	Z+,R5
    01F8A 882A      LDD	R2,Y+18
    01F8B 883B      LDD	R3,Y+19
    01F8C 884C      LDD	R4,Y+20
    01F8D 885D      LDD	R5,Y+21
    01F8E 9221      ST	Z+,R2
    01F8F 9231      ST	Z+,R3
    01F90 9241      ST	Z+,R4
    01F91 9251      ST	Z+,R5
    01F92 017F      MOVW	R14,R30
(2838) 					}
(2839) 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
    01F93 A5E8      LDD	R30,Y+40
    01F94 A5F9      LDD	R31,Y+41
    01F95 81A0      LD	R26,Z
    01F96 81B1      LDD	R27,Z+1
    01F97 9656      ADIW	R26,0x16
    01F98 902D      LD	R2,X+
    01F99 903D      LD	R3,X+
    01F9A 904D      LD	R4,X+
    01F9B 905C      LD	R5,X
    01F9C 806A      LDD	R6,Y+2
    01F9D 807B      LDD	R7,Y+3
    01F9E 808C      LDD	R8,Y+4
    01F9F 809D      LDD	R9,Y+5
    01FA0 1462      CP	R6,R2
    01FA1 0473      CPC	R7,R3
    01FA2 0484      CPC	R8,R4
    01FA3 0495      CPC	R9,R5
    01FA4 F408      BCC	0x1FA6
    01FA5 CF45      RJMP	0x1EEB
(2840) 			}
(2841) 			*fp->cltbl = ulen;	/* Number of items used */
    01FA6 842E      LDD	R2,Y+14
    01FA7 843F      LDD	R3,Y+15
    01FA8 8848      LDD	R4,Y+16
    01FA9 8859      LDD	R5,Y+17
    01FAA A5E8      LDD	R30,Y+40
    01FAB A5F9      LDD	R31,Y+41
    01FAC 96B0      ADIW	R30,0x20
    01FAD 81A0      LD	R26,Z
    01FAE 81B1      LDD	R27,Z+1
    01FAF 922D      ST	X+,R2
    01FB0 923D      ST	X+,R3
    01FB1 924D      ST	X+,R4
    01FB2 925C      ST	X,R5
(2842) 			if (ulen <= tlen)
    01FB3 882E      LDD	R2,Y+22
    01FB4 883F      LDD	R3,Y+23
    01FB5 8C48      LDD	R4,Y+24
    01FB6 8C59      LDD	R5,Y+25
    01FB7 846E      LDD	R6,Y+14
    01FB8 847F      LDD	R7,Y+15
    01FB9 8888      LDD	R8,Y+16
    01FBA 8899      LDD	R9,Y+17
    01FBB 1426      CP	R2,R6
    01FBC 0437      CPC	R3,R7
    01FBD 0448      CPC	R4,R8
    01FBE 0459      CPC	R5,R9
    01FBF F038      BCS	0x1FC7
(2843) 				*tbl = 0;		/* Terminate table */
    01FC0 01F7      MOVW	R30,R14
    01FC1 E080      LDI	R24,0
    01FC2 8380      ST	Z,R24
    01FC3 8381      STD	Z+1,R24
    01FC4 8382      STD	Z+2,R24
    01FC5 8383      STD	Z+3,R24
    01FC6 C381      RJMP	0x2348
(2844) 			else
(2845) 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
    01FC7 E181      LDI	R24,0x11
    01FC8 2EA8      MOV	R10,R24
(2846) 
(2847) 		} else {						/* Fast seek */
    01FC9 C37E      RJMP	0x2348
(2848) 			if (ofs > fp->fsize)		/* Clip offset at the file size */
    01FCA A5E8      LDD	R30,Y+40
    01FCB A5F9      LDD	R31,Y+41
    01FCC 963A      ADIW	R30,0xA
    01FCD 8020      LD	R2,Z
    01FCE 8031      LDD	R3,Z+1
    01FCF 8042      LDD	R4,Z+2
    01FD0 8053      LDD	R5,Z+3
    01FD1 A46A      LDD	R6,Y+42
    01FD2 A47B      LDD	R7,Y+43
    01FD3 A48C      LDD	R8,Y+44
    01FD4 A49D      LDD	R9,Y+45
    01FD5 1426      CP	R2,R6
    01FD6 0437      CPC	R3,R7
    01FD7 0448      CPC	R4,R8
    01FD8 0459      CPC	R5,R9
    01FD9 F458      BCC	0x1FE5
(2849) 				ofs = fp->fsize;
    01FDA A5E8      LDD	R30,Y+40
    01FDB A5F9      LDD	R31,Y+41
    01FDC 963A      ADIW	R30,0xA
    01FDD 8020      LD	R2,Z
    01FDE 8031      LDD	R3,Z+1
    01FDF 8042      LDD	R4,Z+2
    01FE0 8053      LDD	R5,Z+3
    01FE1 A62A      STD	Y+42,R2
    01FE2 A63B      STD	Y+43,R3
    01FE3 A64C      STD	Y+44,R4
    01FE4 A65D      STD	Y+45,R5
(2850) 			fp->fptr = ofs;				/* Set file pointer */
    01FE5 A42A      LDD	R2,Y+42
    01FE6 A43B      LDD	R3,Y+43
    01FE7 A44C      LDD	R4,Y+44
    01FE8 A45D      LDD	R5,Y+45
    01FE9 A5E8      LDD	R30,Y+40
    01FEA A5F9      LDD	R31,Y+41
    01FEB 9636      ADIW	R30,6
    01FEC 8220      ST	Z,R2
    01FED 8231      STD	Z+1,R3
    01FEE 8242      STD	Z+2,R4
    01FEF 8253      STD	Z+3,R5
(2851) 			if (ofs) {
    01FF0 9488      BCLR	0
    01FF1 2022      TST	R2
    01FF2 0432      CPC	R3,R2
    01FF3 0442      CPC	R4,R2
    01FF4 0452      CPC	R5,R2
    01FF5 F409      BNE	0x1FF7
    01FF6 C351      RJMP	0x2348
(2852) 				fp->clust = clmt_clust(fp, ofs - 1);
    01FF7 E041      LDI	R20,1
    01FF8 E050      LDI	R21,0
    01FF9 E060      LDI	R22,0
    01FFA E070      LDI	R23,0
    01FFB 1A24      SUB	R2,R20
    01FFC 0A35      SBC	R3,R21
    01FFD 0A46      SBC	R4,R22
    01FFE 0A57      SBC	R5,R23
    01FFF 8248      ST	Y,R4
    02000 8259      STD	Y+1,R5
    02001 0191      MOVW	R18,R2
    02002 A508      LDD	R16,Y+40
    02003 A519      LDD	R17,Y+41
    02004 940E 0A53 CALL	ff.c:clmt_clust
    02006 A5E8      LDD	R30,Y+40
    02007 A5F9      LDD	R31,Y+41
    02008 8B02      STD	Z+18,R16
    02009 8B13      STD	Z+19,R17
    0200A 8B24      STD	Z+20,R18
    0200B 8B35      STD	Z+21,R19
(2853) 				dsc = clust2sect(fp->fs, fp->clust);
    0200C 8822      LDD	R2,Z+18
    0200D 8833      LDD	R3,Z+19
    0200E 8844      LDD	R4,Z+20
    0200F 8855      LDD	R5,Z+21
    02010 8248      ST	Y,R4
    02011 8259      STD	Y+1,R5
    02012 0191      MOVW	R18,R2
    02013 8100      LD	R16,Z
    02014 8111      LDD	R17,Z+1
    02015 940E 04C7 CALL	_clust2sect
    02017 8F0A      STD	Y+26,R16
    02018 8F1B      STD	Y+27,R17
    02019 8F2C      STD	Y+28,R18
    0201A 8F3D      STD	Y+29,R19
(2854) 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
    0201B 8C2A      LDD	R2,Y+26
    0201C 8C3B      LDD	R3,Y+27
    0201D 8C4C      LDD	R4,Y+28
    0201E 8C5D      LDD	R5,Y+29
    0201F 9488      BCLR	0
    02020 2022      TST	R2
    02021 0432      CPC	R3,R2
    02022 0442      CPC	R4,R2
    02023 0452      CPC	R5,R2
    02024 F451      BNE	0x202F
    02025 A588      LDD	R24,Y+40
    02026 A599      LDD	R25,Y+41
    02027 9604      ADIW	R24,4
    02028 017C      MOVW	R14,R24
    02029 01FC      MOVW	R30,R24
    0202A 8180      LD	R24,Z
    0202B 6880      ORI	R24,0x80
    0202C 8380      ST	Z,R24
    0202D E002      LDI	R16,2
    0202E C31A      RJMP	0x2349
(2855) 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
    0202F E041      LDI	R20,1
    02030 E050      LDI	R21,0
    02031 E060      LDI	R22,0
    02032 E070      LDI	R23,0
    02033 A50A      LDD	R16,Y+42
    02034 A51B      LDD	R17,Y+43
    02035 A52C      LDD	R18,Y+44
    02036 A53D      LDD	R19,Y+45
    02037 1B04      SUB	R16,R20
    02038 0B15      SBC	R17,R21
    02039 0B26      SBC	R18,R22
    0203A 0B37      SBC	R19,R23
    0203B E089      LDI	R24,0x9
    0203C E090      LDI	R25,0
    0203D 938A      ST	-Y,R24
    0203E 940E 4206 CALL	lsr32
    02040 0118      MOVW	R2,R16
    02041 0129      MOVW	R4,R18
    02042 A5E8      LDD	R30,Y+40
    02043 A5F9      LDD	R31,Y+41
    02044 93AF      PUSH	R26
    02045 93BF      PUSH	R27
    02046 81A0      LD	R26,Z
    02047 81B1      LDD	R27,Z+1
    02048 01FD      MOVW	R30,R26
    02049 91BF      POP	R27
    0204A 91AF      POP	R26
    0204B 9632      ADIW	R30,2
    0204C 8180      LD	R24,Z
    0204D 2799      CLR	R25
    0204E 9701      SBIW	R24,1
    0204F 013C      MOVW	R6,R24
    02050 2488      CLR	R8
    02051 FC77      SBRC	R7,7
    02052 9480      COM	R8
    02053 2499      CLR	R9
    02054 FC87      SBRC	R8,7
    02055 9490      COM	R9
    02056 2026      AND	R2,R6
    02057 2037      AND	R3,R7
    02058 2048      AND	R4,R8
    02059 2059      AND	R5,R9
    0205A 8C6A      LDD	R6,Y+26
    0205B 8C7B      LDD	R7,Y+27
    0205C 8C8C      LDD	R8,Y+28
    0205D 8C9D      LDD	R9,Y+29
    0205E 0C62      ADD	R6,R2
    0205F 1C73      ADC	R7,R3
    02060 1C84      ADC	R8,R4
    02061 1C95      ADC	R9,R5
    02062 8E6A      STD	Y+26,R6
    02063 8E7B      STD	Y+27,R7
    02064 8E8C      STD	Y+28,R8
    02065 8E9D      STD	Y+29,R9
(2856) 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
    02066 EF4F      LDI	R20,0xFF
    02067 E051      LDI	R21,1
    02068 E060      LDI	R22,0
    02069 E070      LDI	R23,0
    0206A A5E8      LDD	R30,Y+40
    0206B A5F9      LDD	R31,Y+41
    0206C 9636      ADIW	R30,6
    0206D 8020      LD	R2,Z
    0206E 8031      LDD	R3,Z+1
    0206F 8042      LDD	R4,Z+2
    02070 8053      LDD	R5,Z+3
    02071 2224      AND	R2,R20
    02072 2235      AND	R3,R21
    02073 2246      AND	R4,R22
    02074 2257      AND	R5,R23
    02075 9488      BCLR	0
    02076 2022      TST	R2
    02077 0432      CPC	R3,R2
    02078 0442      CPC	R4,R2
    02079 0452      CPC	R5,R2
    0207A F409      BNE	0x207C
    0207B C2CC      RJMP	0x2348
    0207C A5E8      LDD	R30,Y+40
    0207D A5F9      LDD	R31,Y+41
    0207E 9676      ADIW	R30,0x16
    0207F 8020      LD	R2,Z
    02080 8031      LDD	R3,Z+1
    02081 8042      LDD	R4,Z+2
    02082 8053      LDD	R5,Z+3
    02083 8C6A      LDD	R6,Y+26
    02084 8C7B      LDD	R7,Y+27
    02085 8C8C      LDD	R8,Y+28
    02086 8C9D      LDD	R9,Y+29
    02087 1462      CP	R6,R2
    02088 0473      CPC	R7,R3
    02089 0484      CPC	R8,R4
    0208A 0495      CPC	R9,R5
    0208B F409      BNE	0x208D
    0208C C2BB      RJMP	0x2348
(2857) #if !_FS_TINY
(2858) #if !_FS_READONLY
(2859) 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2860) 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2861) 							ABORT(fp->fs, FR_DISK_ERR);
(2862) 						fp->flag &= ~FA__DIRTY;
(2863) 					}
(2864) #endif
(2865) 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
(2866) 						ABORT(fp->fs, FR_DISK_ERR);
(2867) #endif
(2868) 					fp->dsect = dsc;
    0208D 0113      MOVW	R2,R6
    0208E 0124      MOVW	R4,R8
    0208F A5E8      LDD	R30,Y+40
    02090 A5F9      LDD	R31,Y+41
    02091 8A26      STD	Z+22,R2
    02092 8A37      STD	Z+23,R3
    02093 8E40      STD	Z+24,R4
    02094 8E51      STD	Z+25,R5
(2869) 				}
(2870) 			}
(2871) 		}
(2872) 	} else
    02095 C2B2      RJMP	0x2348
(2873) #endif
(2874) 
(2875) 	/* Normal Seek */
(2876) 	{
(2877) 		DWORD clst, bcs, nsect, ifptr;
(2878) 
(2879) 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    02096 A5E8      LDD	R30,Y+40
    02097 A5F9      LDD	R31,Y+41
    02098 963A      ADIW	R30,0xA
    02099 8020      LD	R2,Z
    0209A 8031      LDD	R3,Z+1
    0209B 8042      LDD	R4,Z+2
    0209C 8053      LDD	R5,Z+3
    0209D A46A      LDD	R6,Y+42
    0209E A47B      LDD	R7,Y+43
    0209F A48C      LDD	R8,Y+44
    020A0 A49D      LDD	R9,Y+45
    020A1 1426      CP	R2,R6
    020A2 0437      CPC	R3,R7
    020A3 0448      CPC	R4,R8
    020A4 0459      CPC	R5,R9
    020A5 F470      BCC	0x20B4
    020A6 A5E8      LDD	R30,Y+40
    020A7 A5F9      LDD	R31,Y+41
    020A8 8024      LDD	R2,Z+4
    020A9 FC21      SBRC	R2,1
    020AA C009      RJMP	0x20B4
(2880) #if !_FS_READONLY
(2881) 			 && !(fp->flag & FA_WRITE)
(2882) #endif
(2883) 			) ofs = fp->fsize;
    020AB 963A      ADIW	R30,0xA
    020AC 8020      LD	R2,Z
    020AD 8031      LDD	R3,Z+1
    020AE 8042      LDD	R4,Z+2
    020AF 8053      LDD	R5,Z+3
    020B0 A62A      STD	Y+42,R2
    020B1 A63B      STD	Y+43,R3
    020B2 A64C      STD	Y+44,R4
    020B3 A65D      STD	Y+45,R5
(2884) 
(2885) 		ifptr = fp->fptr;
    020B4 A5E8      LDD	R30,Y+40
    020B5 A5F9      LDD	R31,Y+41
    020B6 9636      ADIW	R30,6
    020B7 8020      LD	R2,Z
    020B8 8031      LDD	R3,Z+1
    020B9 8042      LDD	R4,Z+2
    020BA 8053      LDD	R5,Z+3
    020BB 862E      STD	Y+14,R2
    020BC 863F      STD	Y+15,R3
    020BD 8A48      STD	Y+16,R4
    020BE 8A59      STD	Y+17,R5
(2886) 		fp->fptr = nsect = 0;
    020BF E080      LDI	R24,0
    020C0 878A      STD	Y+10,R24
    020C1 878B      STD	Y+11,R24
    020C2 878C      STD	Y+12,R24
    020C3 878D      STD	Y+13,R24
    020C4 A5E8      LDD	R30,Y+40
    020C5 A5F9      LDD	R31,Y+41
    020C6 9636      ADIW	R30,6
    020C7 E080      LDI	R24,0
    020C8 8380      ST	Z,R24
    020C9 8381      STD	Z+1,R24
    020CA 8382      STD	Z+2,R24
    020CB 8383      STD	Z+3,R24
(2887) 		if (ofs) {
    020CC A42A      LDD	R2,Y+42
    020CD A43B      LDD	R3,Y+43
    020CE A44C      LDD	R4,Y+44
    020CF A45D      LDD	R5,Y+45
    020D0 9488      BCLR	0
    020D1 2022      TST	R2
    020D2 0432      CPC	R3,R2
    020D3 0442      CPC	R4,R2
    020D4 0452      CPC	R5,R2
    020D5 F409      BNE	0x20D7
    020D6 C226      RJMP	0x22FD
(2888) 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    020D7 A5E8      LDD	R30,Y+40
    020D8 A5F9      LDD	R31,Y+41
    020D9 93AF      PUSH	R26
    020DA 93BF      PUSH	R27
    020DB 81A0      LD	R26,Z
    020DC 81B1      LDD	R27,Z+1
    020DD 01FD      MOVW	R30,R26
    020DE 91BF      POP	R27
    020DF 91AF      POP	R26
    020E0 9632      ADIW	R30,2
    020E1 8020      LD	R2,Z
    020E2 2433      CLR	R3
    020E3 2444      CLR	R4
    020E4 2455      CLR	R5
    020E5 E040      LDI	R20,0
    020E6 E052      LDI	R21,2
    020E7 E060      LDI	R22,0
    020E8 E070      LDI	R23,0
    020E9 925A      ST	-Y,R5
    020EA 924A      ST	-Y,R4
    020EB 923A      ST	-Y,R3
    020EC 922A      ST	-Y,R2
    020ED 018A      MOVW	R16,R20
    020EE 019B      MOVW	R18,R22
    020EF 940E 4117 CALL	empy32u|empy32s
    020F1 830E      STD	Y+6,R16
    020F2 831F      STD	Y+7,R17
    020F3 8728      STD	Y+8,R18
    020F4 8739      STD	Y+9,R19
(2889) 			if (ifptr > 0 &&
    020F5 842E      LDD	R2,Y+14
    020F6 843F      LDD	R3,Y+15
    020F7 8848      LDD	R4,Y+16
    020F8 8859      LDD	R5,Y+17
    020F9 9488      BCLR	0
    020FA 2022      TST	R2
    020FB 0432      CPC	R3,R2
    020FC 0442      CPC	R4,R2
    020FD 0452      CPC	R5,R2
    020FE F409      BNE	0x2100
    020FF C075      RJMP	0x2175
    02100 E041      LDI	R20,1
    02101 E050      LDI	R21,0
    02102 E060      LDI	R22,0
    02103 E070      LDI	R23,0
    02104 0181      MOVW	R16,R2
    02105 0192      MOVW	R18,R4
    02106 1B04      SUB	R16,R20
    02107 0B15      SBC	R17,R21
    02108 0B26      SBC	R18,R22
    02109 0B37      SBC	R19,R23
    0210A 802E      LDD	R2,Y+6
    0210B 803F      LDD	R3,Y+7
    0210C 8448      LDD	R4,Y+8
    0210D 8459      LDD	R5,Y+9
    0210E 925A      ST	-Y,R5
    0210F 924A      ST	-Y,R4
    02110 923A      ST	-Y,R3
    02111 922A      ST	-Y,R2
    02112 940E 4071 CALL	div32u
    02114 0118      MOVW	R2,R16
    02115 0129      MOVW	R4,R18
    02116 E041      LDI	R20,1
    02117 E050      LDI	R21,0
    02118 E060      LDI	R22,0
    02119 E070      LDI	R23,0
    0211A A50A      LDD	R16,Y+42
    0211B A51B      LDD	R17,Y+43
    0211C A52C      LDD	R18,Y+44
    0211D A53D      LDD	R19,Y+45
    0211E 1B04      SUB	R16,R20
    0211F 0B15      SBC	R17,R21
    02120 0B26      SBC	R18,R22
    02121 0B37      SBC	R19,R23
    02122 806E      LDD	R6,Y+6
    02123 807F      LDD	R7,Y+7
    02124 8488      LDD	R8,Y+8
    02125 8499      LDD	R9,Y+9
    02126 929A      ST	-Y,R9
    02127 928A      ST	-Y,R8
    02128 927A      ST	-Y,R7
    02129 926A      ST	-Y,R6
    0212A 940E 4071 CALL	div32u
    0212C 1502      CP	R16,R2
    0212D 0513      CPC	R17,R3
    0212E 0524      CPC	R18,R4
    0212F 0535      CPC	R19,R5
    02130 F408      BCC	0x2132
    02131 C043      RJMP	0x2175
(2890) 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
(2891) 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    02132 E041      LDI	R20,1
    02133 E050      LDI	R21,0
    02134 E060      LDI	R22,0
    02135 E070      LDI	R23,0
    02136 802E      LDD	R2,Y+6
    02137 803F      LDD	R3,Y+7
    02138 8448      LDD	R4,Y+8
    02139 8459      LDD	R5,Y+9
    0213A 1A24      SUB	R2,R20
    0213B 0A35      SBC	R3,R21
    0213C 0A46      SBC	R4,R22
    0213D 0A57      SBC	R5,R23
    0213E 9420      COM	R2
    0213F 9430      COM	R3
    02140 9440      COM	R4
    02141 9450      COM	R5
    02142 E041      LDI	R20,1
    02143 E050      LDI	R21,0
    02144 E060      LDI	R22,0
    02145 E070      LDI	R23,0
    02146 846E      LDD	R6,Y+14
    02147 847F      LDD	R7,Y+15
    02148 8888      LDD	R8,Y+16
    02149 8899      LDD	R9,Y+17
    0214A 1A64      SUB	R6,R20
    0214B 0A75      SBC	R7,R21
    0214C 0A86      SBC	R8,R22
    0214D 0A97      SBC	R9,R23
    0214E 2062      AND	R6,R2
    0214F 2073      AND	R7,R3
    02150 2084      AND	R8,R4
    02151 2095      AND	R9,R5
    02152 A5E8      LDD	R30,Y+40
    02153 A5F9      LDD	R31,Y+41
    02154 8266      STD	Z+6,R6
    02155 8277      STD	Z+7,R7
    02156 8680      STD	Z+8,R8
    02157 8691      STD	Z+9,R9
(2892) 				ofs -= fp->fptr;
    02158 9636      ADIW	R30,6
    02159 8020      LD	R2,Z
    0215A 8031      LDD	R3,Z+1
    0215B 8042      LDD	R4,Z+2
    0215C 8053      LDD	R5,Z+3
    0215D A46A      LDD	R6,Y+42
    0215E A47B      LDD	R7,Y+43
    0215F A48C      LDD	R8,Y+44
    02160 A49D      LDD	R9,Y+45
    02161 1862      SUB	R6,R2
    02162 0873      SBC	R7,R3
    02163 0884      SBC	R8,R4
    02164 0895      SBC	R9,R5
    02165 A66A      STD	Y+42,R6
    02166 A67B      STD	Y+43,R7
    02167 A68C      STD	Y+44,R8
    02168 A69D      STD	Y+45,R9
(2893) 				clst = fp->clust;
    02169 A5E8      LDD	R30,Y+40
    0216A A5F9      LDD	R31,Y+41
    0216B 9672      ADIW	R30,0x12
    0216C 8020      LD	R2,Z
    0216D 8031      LDD	R3,Z+1
    0216E 8042      LDD	R4,Z+2
    0216F 8053      LDD	R5,Z+3
    02170 822A      STD	Y+2,R2
    02171 823B      STD	Y+3,R3
    02172 824C      STD	Y+4,R4
    02173 825D      STD	Y+5,R5
(2894) 			} else {									/* When seek to back cluster, */
    02174 C069      RJMP	0x21DE
(2895) 				clst = fp->sclust;						/* start from the first cluster */
    02175 A5E8      LDD	R30,Y+40
    02176 A5F9      LDD	R31,Y+41
    02177 963E      ADIW	R30,0xE
    02178 8020      LD	R2,Z
    02179 8031      LDD	R3,Z+1
    0217A 8042      LDD	R4,Z+2
    0217B 8053      LDD	R5,Z+3
    0217C 822A      STD	Y+2,R2
    0217D 823B      STD	Y+3,R3
    0217E 824C      STD	Y+4,R4
    0217F 825D      STD	Y+5,R5
(2896) #if !_FS_READONLY
(2897) 				if (clst == 0) {						/* If no cluster chain, create a new chain */
    02180 802A      LDD	R2,Y+2
    02181 803B      LDD	R3,Y+3
    02182 804C      LDD	R4,Y+4
    02183 805D      LDD	R5,Y+5
    02184 9488      BCLR	0
    02185 2022      TST	R2
    02186 0432      CPC	R3,R2
    02187 0442      CPC	R4,R2
    02188 0452      CPC	R5,R2
    02189 F009      BEQ	0x218B
    0218A C049      RJMP	0x21D4
(2898) 					clst = create_chain(fp->fs, 0);
    0218B E040      LDI	R20,0
    0218C E050      LDI	R21,0
    0218D E060      LDI	R22,0
    0218E E070      LDI	R23,0
    0218F 8368      ST	Y,R22
    02190 8379      STD	Y+1,R23
    02191 019A      MOVW	R18,R20
    02192 A5E8      LDD	R30,Y+40
    02193 A5F9      LDD	R31,Y+41
    02194 8100      LD	R16,Z
    02195 8111      LDD	R17,Z+1
    02196 940E 08DB CALL	ff.c:create_chain
    02198 830A      STD	Y+2,R16
    02199 831B      STD	Y+3,R17
    0219A 832C      STD	Y+4,R18
    0219B 833D      STD	Y+5,R19
(2899) 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    0219C E041      LDI	R20,1
    0219D E050      LDI	R21,0
    0219E E060      LDI	R22,0
    0219F E070      LDI	R23,0
    021A0 802A      LDD	R2,Y+2
    021A1 803B      LDD	R3,Y+3
    021A2 804C      LDD	R4,Y+4
    021A3 805D      LDD	R5,Y+5
    021A4 1624      CP	R2,R20
    021A5 0635      CPC	R3,R21
    021A6 0646      CPC	R4,R22
    021A7 0657      CPC	R5,R23
    021A8 F451      BNE	0x21B3
    021A9 A588      LDD	R24,Y+40
    021AA A599      LDD	R25,Y+41
    021AB 9604      ADIW	R24,4
    021AC 017C      MOVW	R14,R24
    021AD 01FC      MOVW	R30,R24
    021AE 8180      LD	R24,Z
    021AF 6880      ORI	R24,0x80
    021B0 8380      ST	Z,R24
    021B1 E002      LDI	R16,2
    021B2 C196      RJMP	0x2349
(2900) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    021B3 EF4F      LDI	R20,0xFF
    021B4 EF5F      LDI	R21,0xFF
    021B5 EF6F      LDI	R22,0xFF
    021B6 EF7F      LDI	R23,0xFF
    021B7 802A      LDD	R2,Y+2
    021B8 803B      LDD	R3,Y+3
    021B9 804C      LDD	R4,Y+4
    021BA 805D      LDD	R5,Y+5
    021BB 1624      CP	R2,R20
    021BC 0635      CPC	R3,R21
    021BD 0646      CPC	R4,R22
    021BE 0657      CPC	R5,R23
    021BF F451      BNE	0x21CA
    021C0 A588      LDD	R24,Y+40
    021C1 A599      LDD	R25,Y+41
    021C2 9604      ADIW	R24,4
    021C3 017C      MOVW	R14,R24
    021C4 01FC      MOVW	R30,R24
    021C5 8180      LD	R24,Z
    021C6 6880      ORI	R24,0x80
    021C7 8380      ST	Z,R24
    021C8 E001      LDI	R16,1
    021C9 C17F      RJMP	0x2349
(2901) 					fp->sclust = clst;
    021CA 802A      LDD	R2,Y+2
    021CB 803B      LDD	R3,Y+3
    021CC 804C      LDD	R4,Y+4
    021CD 805D      LDD	R5,Y+5
    021CE A5E8      LDD	R30,Y+40
    021CF A5F9      LDD	R31,Y+41
    021D0 8626      STD	Z+14,R2
    021D1 8637      STD	Z+15,R3
    021D2 8A40      STD	Z+16,R4
    021D3 8A51      STD	Z+17,R5
(2902) 				}
(2903) #endif
(2904) 				fp->clust = clst;
    021D4 802A      LDD	R2,Y+2
    021D5 803B      LDD	R3,Y+3
    021D6 804C      LDD	R4,Y+4
    021D7 805D      LDD	R5,Y+5
    021D8 A5E8      LDD	R30,Y+40
    021D9 A5F9      LDD	R31,Y+41
    021DA 8A22      STD	Z+18,R2
    021DB 8A33      STD	Z+19,R3
    021DC 8A44      STD	Z+20,R4
    021DD 8A55      STD	Z+21,R5
(2905) 			}
(2906) 			if (clst != 0) {
    021DE 802A      LDD	R2,Y+2
    021DF 803B      LDD	R3,Y+3
    021E0 804C      LDD	R4,Y+4
    021E1 805D      LDD	R5,Y+5
    021E2 9488      BCLR	0
    021E3 2022      TST	R2
    021E4 0432      CPC	R3,R2
    021E5 0442      CPC	R4,R2
    021E6 0452      CPC	R5,R2
    021E7 F409      BNE	0x21E9
    021E8 C114      RJMP	0x22FD
    021E9 C0A7      RJMP	0x2291
(2907) 				while (ofs > bcs) {						/* Cluster following loop */
(2908) #if !_FS_READONLY
(2909) 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    021EA A5E8      LDD	R30,Y+40
    021EB A5F9      LDD	R31,Y+41
    021EC 9634      ADIW	R30,4
    021ED 8020      LD	R2,Z
    021EE FE21      SBRS	R2,1
    021EF C024      RJMP	0x2214
(2910) 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    021F0 802A      LDD	R2,Y+2
    021F1 803B      LDD	R3,Y+3
    021F2 804C      LDD	R4,Y+4
    021F3 805D      LDD	R5,Y+5
    021F4 8248      ST	Y,R4
    021F5 8259      STD	Y+1,R5
    021F6 0191      MOVW	R18,R2
    021F7 A5E8      LDD	R30,Y+40
    021F8 A5F9      LDD	R31,Y+41
    021F9 8100      LD	R16,Z
    021FA 8111      LDD	R17,Z+1
    021FB 940E 08DB CALL	ff.c:create_chain
    021FD 830A      STD	Y+2,R16
    021FE 831B      STD	Y+3,R17
    021FF 832C      STD	Y+4,R18
    02200 833D      STD	Y+5,R19
(2911) 						if (clst == 0) {				/* When disk gets full, clip file size */
    02201 802A      LDD	R2,Y+2
    02202 803B      LDD	R3,Y+3
    02203 804C      LDD	R4,Y+4
    02204 805D      LDD	R5,Y+5
    02205 9488      BCLR	0
    02206 2022      TST	R2
    02207 0432      CPC	R3,R2
    02208 0442      CPC	R4,R2
    02209 0452      CPC	R5,R2
    0220A F4D1      BNE	0x2225
(2912) 							ofs = bcs; break;
    0220B 802E      LDD	R2,Y+6
    0220C 803F      LDD	R3,Y+7
    0220D 8448      LDD	R4,Y+8
    0220E 8459      LDD	R5,Y+9
    0220F A62A      STD	Y+42,R2
    02210 A63B      STD	Y+43,R3
    02211 A64C      STD	Y+44,R4
    02212 A65D      STD	Y+45,R5
    02213 C08B      RJMP	0x229F
(2913) 						}
(2914) 					} else
(2915) #endif
(2916) 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    02214 802A      LDD	R2,Y+2
    02215 803B      LDD	R3,Y+3
    02216 804C      LDD	R4,Y+4
    02217 805D      LDD	R5,Y+5
    02218 8248      ST	Y,R4
    02219 8259      STD	Y+1,R5
    0221A 0191      MOVW	R18,R2
    0221B A5E8      LDD	R30,Y+40
    0221C A5F9      LDD	R31,Y+41
    0221D 8100      LD	R16,Z
    0221E 8111      LDD	R17,Z+1
    0221F 940E 0519 CALL	_get_fat
    02221 830A      STD	Y+2,R16
    02222 831B      STD	Y+3,R17
    02223 832C      STD	Y+4,R18
    02224 833D      STD	Y+5,R19
(2917) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    02225 EF4F      LDI	R20,0xFF
    02226 EF5F      LDI	R21,0xFF
    02227 EF6F      LDI	R22,0xFF
    02228 EF7F      LDI	R23,0xFF
    02229 802A      LDD	R2,Y+2
    0222A 803B      LDD	R3,Y+3
    0222B 804C      LDD	R4,Y+4
    0222C 805D      LDD	R5,Y+5
    0222D 1624      CP	R2,R20
    0222E 0635      CPC	R3,R21
    0222F 0646      CPC	R4,R22
    02230 0657      CPC	R5,R23
    02231 F451      BNE	0x223C
    02232 A588      LDD	R24,Y+40
    02233 A599      LDD	R25,Y+41
    02234 9604      ADIW	R24,4
    02235 017C      MOVW	R14,R24
    02236 01FC      MOVW	R30,R24
    02237 8180      LD	R24,Z
    02238 6880      ORI	R24,0x80
    02239 8380      ST	Z,R24
    0223A E001      LDI	R16,1
    0223B C10D      RJMP	0x2349
(2918) 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    0223C E041      LDI	R20,1
    0223D E050      LDI	R21,0
    0223E E060      LDI	R22,0
    0223F E070      LDI	R23,0
    02240 802A      LDD	R2,Y+2
    02241 803B      LDD	R3,Y+3
    02242 804C      LDD	R4,Y+4
    02243 805D      LDD	R5,Y+5
    02244 1542      CP	R20,R2
    02245 0553      CPC	R21,R3
    02246 0564      CPC	R22,R4
    02247 0575      CPC	R23,R5
    02248 F490      BCC	0x225B
    02249 A5E8      LDD	R30,Y+40
    0224A A5F9      LDD	R31,Y+41
    0224B 81A0      LD	R26,Z
    0224C 81B1      LDD	R27,Z+1
    0224D 9656      ADIW	R26,0x16
    0224E 902D      LD	R2,X+
    0224F 903D      LD	R3,X+
    02250 904D      LD	R4,X+
    02251 905C      LD	R5,X
    02252 806A      LDD	R6,Y+2
    02253 807B      LDD	R7,Y+3
    02254 808C      LDD	R8,Y+4
    02255 809D      LDD	R9,Y+5
    02256 1462      CP	R6,R2
    02257 0473      CPC	R7,R3
    02258 0484      CPC	R8,R4
    02259 0495      CPC	R9,R5
    0225A F050      BCS	0x2265
    0225B A588      LDD	R24,Y+40
    0225C A599      LDD	R25,Y+41
    0225D 9604      ADIW	R24,4
    0225E 017C      MOVW	R14,R24
    0225F 01FC      MOVW	R30,R24
    02260 8180      LD	R24,Z
    02261 6880      ORI	R24,0x80
    02262 8380      ST	Z,R24
    02263 E002      LDI	R16,2
    02264 C0E4      RJMP	0x2349
(2919) 					fp->clust = clst;
    02265 802A      LDD	R2,Y+2
    02266 803B      LDD	R3,Y+3
    02267 804C      LDD	R4,Y+4
    02268 805D      LDD	R5,Y+5
    02269 A5E8      LDD	R30,Y+40
    0226A A5F9      LDD	R31,Y+41
    0226B 9672      ADIW	R30,0x12
    0226C 8220      ST	Z,R2
    0226D 8231      STD	Z+1,R3
    0226E 8242      STD	Z+2,R4
    0226F 8253      STD	Z+3,R5
(2920) 					fp->fptr += bcs;
    02270 A588      LDD	R24,Y+40
    02271 A599      LDD	R25,Y+41
    02272 9606      ADIW	R24,6
    02273 017C      MOVW	R14,R24
    02274 802E      LDD	R2,Y+6
    02275 803F      LDD	R3,Y+7
    02276 8448      LDD	R4,Y+8
    02277 8459      LDD	R5,Y+9
    02278 01FC      MOVW	R30,R24
    02279 8060      LD	R6,Z
    0227A 8071      LDD	R7,Z+1
    0227B 8082      LDD	R8,Z+2
    0227C 8093      LDD	R9,Z+3
    0227D 0C62      ADD	R6,R2
    0227E 1C73      ADC	R7,R3
    0227F 1C84      ADC	R8,R4
    02280 1C95      ADC	R9,R5
    02281 8260      ST	Z,R6
    02282 8271      STD	Z+1,R7
    02283 8282      STD	Z+2,R8
    02284 8293      STD	Z+3,R9
(2921) 					ofs -= bcs;
    02285 A46A      LDD	R6,Y+42
    02286 A47B      LDD	R7,Y+43
    02287 A48C      LDD	R8,Y+44
    02288 A49D      LDD	R9,Y+45
    02289 1862      SUB	R6,R2
    0228A 0873      SBC	R7,R3
    0228B 0884      SBC	R8,R4
    0228C 0895      SBC	R9,R5
    0228D A66A      STD	Y+42,R6
    0228E A67B      STD	Y+43,R7
    0228F A68C      STD	Y+44,R8
    02290 A69D      STD	Y+45,R9
    02291 802E      LDD	R2,Y+6
    02292 803F      LDD	R3,Y+7
    02293 8448      LDD	R4,Y+8
    02294 8459      LDD	R5,Y+9
    02295 A46A      LDD	R6,Y+42
    02296 A47B      LDD	R7,Y+43
    02297 A48C      LDD	R8,Y+44
    02298 A49D      LDD	R9,Y+45
    02299 1426      CP	R2,R6
    0229A 0437      CPC	R3,R7
    0229B 0448      CPC	R4,R8
    0229C 0459      CPC	R5,R9
    0229D F408      BCC	0x229F
    0229E CF4B      RJMP	0x21EA
(2922) 				}
(2923) 				fp->fptr += ofs;
    0229F A588      LDD	R24,Y+40
    022A0 A599      LDD	R25,Y+41
    022A1 9606      ADIW	R24,6
    022A2 017C      MOVW	R14,R24
    022A3 A42A      LDD	R2,Y+42
    022A4 A43B      LDD	R3,Y+43
    022A5 A44C      LDD	R4,Y+44
    022A6 A45D      LDD	R5,Y+45
    022A7 01FC      MOVW	R30,R24
    022A8 8060      LD	R6,Z
    022A9 8071      LDD	R7,Z+1
    022AA 8082      LDD	R8,Z+2
    022AB 8093      LDD	R9,Z+3
    022AC 0C62      ADD	R6,R2
    022AD 1C73      ADC	R7,R3
    022AE 1C84      ADC	R8,R4
    022AF 1C95      ADC	R9,R5
    022B0 8260      ST	Z,R6
    022B1 8271      STD	Z+1,R7
    022B2 8282      STD	Z+2,R8
    022B3 8293      STD	Z+3,R9
(2924) 				if (ofs % SS(fp->fs)) {
    022B4 EF4F      LDI	R20,0xFF
    022B5 E051      LDI	R21,1
    022B6 E060      LDI	R22,0
    022B7 E070      LDI	R23,0
    022B8 2224      AND	R2,R20
    022B9 2235      AND	R3,R21
    022BA 2246      AND	R4,R22
    022BB 2257      AND	R5,R23
    022BC 9488      BCLR	0
    022BD 2022      TST	R2
    022BE 0432      CPC	R3,R2
    022BF 0442      CPC	R4,R2
    022C0 0452      CPC	R5,R2
    022C1 F409      BNE	0x22C3
    022C2 C03A      RJMP	0x22FD
(2925) 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    022C3 802A      LDD	R2,Y+2
    022C4 803B      LDD	R3,Y+3
    022C5 804C      LDD	R4,Y+4
    022C6 805D      LDD	R5,Y+5
    022C7 8248      ST	Y,R4
    022C8 8259      STD	Y+1,R5
    022C9 0191      MOVW	R18,R2
    022CA A5E8      LDD	R30,Y+40
    022CB A5F9      LDD	R31,Y+41
    022CC 8100      LD	R16,Z
    022CD 8111      LDD	R17,Z+1
    022CE 940E 04C7 CALL	_clust2sect
    022D0 870A      STD	Y+10,R16
    022D1 871B      STD	Y+11,R17
    022D2 872C      STD	Y+12,R18
    022D3 873D      STD	Y+13,R19
(2926) 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    022D4 842A      LDD	R2,Y+10
    022D5 843B      LDD	R3,Y+11
    022D6 844C      LDD	R4,Y+12
    022D7 845D      LDD	R5,Y+13
    022D8 9488      BCLR	0
    022D9 2022      TST	R2
    022DA 0432      CPC	R3,R2
    022DB 0442      CPC	R4,R2
    022DC 0452      CPC	R5,R2
    022DD F451      BNE	0x22E8
    022DE A588      LDD	R24,Y+40
    022DF A599      LDD	R25,Y+41
    022E0 9604      ADIW	R24,4
    022E1 017C      MOVW	R14,R24
    022E2 01FC      MOVW	R30,R24
    022E3 8180      LD	R24,Z
    022E4 6880      ORI	R24,0x80
    022E5 8380      ST	Z,R24
    022E6 E002      LDI	R16,2
    022E7 C061      RJMP	0x2349
(2927) 					nsect += ofs / SS(fp->fs);
    022E8 E089      LDI	R24,0x9
    022E9 E090      LDI	R25,0
    022EA A50A      LDD	R16,Y+42
    022EB A51B      LDD	R17,Y+43
    022EC A52C      LDD	R18,Y+44
    022ED A53D      LDD	R19,Y+45
    022EE 938A      ST	-Y,R24
    022EF 940E 4206 CALL	lsr32
    022F1 842A      LDD	R2,Y+10
    022F2 843B      LDD	R3,Y+11
    022F3 844C      LDD	R4,Y+12
    022F4 845D      LDD	R5,Y+13
    022F5 0E20      ADD	R2,R16
    022F6 1E31      ADC	R3,R17
    022F7 1E42      ADC	R4,R18
    022F8 1E53      ADC	R5,R19
    022F9 862A      STD	Y+10,R2
    022FA 863B      STD	Y+11,R3
    022FB 864C      STD	Y+12,R4
    022FC 865D      STD	Y+13,R5
(2928) 				}
(2929) 			}
(2930) 		}
(2931) 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    022FD EF4F      LDI	R20,0xFF
    022FE E051      LDI	R21,1
    022FF E060      LDI	R22,0
    02300 E070      LDI	R23,0
    02301 A5E8      LDD	R30,Y+40
    02302 A5F9      LDD	R31,Y+41
    02303 9636      ADIW	R30,6
    02304 8020      LD	R2,Z
    02305 8031      LDD	R3,Z+1
    02306 8042      LDD	R4,Z+2
    02307 8053      LDD	R5,Z+3
    02308 2224      AND	R2,R20
    02309 2235      AND	R3,R21
    0230A 2246      AND	R4,R22
    0230B 2257      AND	R5,R23
    0230C 9488      BCLR	0
    0230D 2022      TST	R2
    0230E 0432      CPC	R3,R2
    0230F 0442      CPC	R4,R2
    02310 0452      CPC	R5,R2
    02311 F0C1      BEQ	0x232A
    02312 A5E8      LDD	R30,Y+40
    02313 A5F9      LDD	R31,Y+41
    02314 9676      ADIW	R30,0x16
    02315 8020      LD	R2,Z
    02316 8031      LDD	R3,Z+1
    02317 8042      LDD	R4,Z+2
    02318 8053      LDD	R5,Z+3
    02319 846A      LDD	R6,Y+10
    0231A 847B      LDD	R7,Y+11
    0231B 848C      LDD	R8,Y+12
    0231C 849D      LDD	R9,Y+13
    0231D 1462      CP	R6,R2
    0231E 0473      CPC	R7,R3
    0231F 0484      CPC	R8,R4
    02320 0495      CPC	R9,R5
    02321 F041      BEQ	0x232A
(2932) #if !_FS_TINY
(2933) #if !_FS_READONLY
(2934) 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
(2935) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2936) 					ABORT(fp->fs, FR_DISK_ERR);
(2937) 				fp->flag &= ~FA__DIRTY;
(2938) 			}
(2939) #endif
(2940) 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
(2941) 				ABORT(fp->fs, FR_DISK_ERR);
(2942) #endif
(2943) 			fp->dsect = nsect;
    02322 0113      MOVW	R2,R6
    02323 0124      MOVW	R4,R8
    02324 A5E8      LDD	R30,Y+40
    02325 A5F9      LDD	R31,Y+41
    02326 8A26      STD	Z+22,R2
    02327 8A37      STD	Z+23,R3
    02328 8E40      STD	Z+24,R4
    02329 8E51      STD	Z+25,R5
(2944) 		}
(2945) #if !_FS_READONLY
(2946) 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    0232A A5E8      LDD	R30,Y+40
    0232B A5F9      LDD	R31,Y+41
    0232C 8422      LDD	R2,Z+10
    0232D 8433      LDD	R3,Z+11
    0232E 8444      LDD	R4,Z+12
    0232F 8455      LDD	R5,Z+13
    02330 8066      LDD	R6,Z+6
    02331 8077      LDD	R7,Z+7
    02332 8480      LDD	R8,Z+8
    02333 8491      LDD	R9,Z+9
    02334 1426      CP	R2,R6
    02335 0437      CPC	R3,R7
    02336 0448      CPC	R4,R8
    02337 0459      CPC	R5,R9
    02338 F478      BCC	0x2348
(2947) 			fp->fsize = fp->fptr;
    02339 8026      LDD	R2,Z+6
    0233A 8037      LDD	R3,Z+7
    0233B 8440      LDD	R4,Z+8
    0233C 8451      LDD	R5,Z+9
    0233D 8622      STD	Z+10,R2
    0233E 8633      STD	Z+11,R3
    0233F 8644      STD	Z+12,R4
    02340 8655      STD	Z+13,R5
(2948) 			fp->flag |= FA__WRITTEN;
    02341 01CF      MOVW	R24,R30
    02342 9604      ADIW	R24,4
    02343 016C      MOVW	R12,R24
    02344 01FC      MOVW	R30,R24
    02345 8180      LD	R24,Z
    02346 6280      ORI	R24,0x20
    02347 8380      ST	Z,R24
(2949) 		}
(2950) #endif
(2951) 	}
(2952) 
(2953) 	LEAVE_FF(fp->fs, res);
    02348 2D0A      MOV	R16,R10
    02349 966E      ADIW	R28,0x1E
    0234A 940E 4160 CALL	pop_xgsetF0FC
    0234C 9624      ADIW	R28,4
    0234D 9508      RET
_f_opendir:
  sfn                  --> Y,+1
  res                  --> R20
  path                 --> Y,+19
  dj                   --> R22
    0234E 933A      ST	-Y,R19
    0234F 932A      ST	-Y,R18
    02350 940E 418A CALL	push_xgsetF00C
    02352 01B8      MOVW	R22,R16
    02353 972D      SBIW	R28,0xD
(2954) }
(2955) 
(2956) 
(2957) 
(2958) #if _FS_MINIMIZE <= 1
(2959) /*-----------------------------------------------------------------------*/
(2960) /* Create a Directroy Object                                             */
(2961) /*-----------------------------------------------------------------------*/
(2962) 
(2963) FRESULT f_opendir (
(2964) 	DIR *dj,			/* Pointer to directory object to create */
(2965) 	const TCHAR *path	/* Pointer to the directory path */
(2966) )
(2967) {
(2968) 	FRESULT res;
(2969) 	DEF_NAMEBUF;
(2970) 
(2971) 
(2972) 	res = chk_mounted(&path, &dj->fs, 0);
    02354 2422      CLR	R2
    02355 8228      ST	Y,R2
    02356 019B      MOVW	R18,R22
    02357 018E      MOVW	R16,R28
    02358 5E0D      SUBI	R16,0xED
    02359 4F1F      SBCI	R17,0xFF
    0235A 940E 116E CALL	ff.c:chk_mounted
    0235C 2F40      MOV	R20,R16
(2973) 	if (res == FR_OK) {
    0235D 2300      TST	R16
    0235E F009      BEQ	0x2360
    0235F C05C      RJMP	0x23BC
(2974) 		INIT_BUF(*dj);
    02360 01CE      MOVW	R24,R28
    02361 9601      ADIW	R24,1
    02362 01FB      MOVW	R30,R22
    02363 8B95      STD	Z+21,R25
    02364 8B84      STD	Z+20,R24
(2975) 		res = follow_path(dj, path);			/* Follow the path to the directory */
    02365 892B      LDD	R18,Y+19
    02366 893C      LDD	R19,Y+20
    02367 018F      MOVW	R16,R30
    02368 940E 1022 CALL	ff.c:follow_path
    0236A 2F40      MOV	R20,R16
(2976) 		FREE_BUF();
(2977) 		if (res == FR_OK) {						/* Follow completed */
    0236B 2300      TST	R16
    0236C F009      BEQ	0x236E
    0236D C04B      RJMP	0x23B9
(2978) 			if (dj->dir) {						/* It is not the root dir */
    0236E 01FB      MOVW	R30,R22
    0236F 8822      LDD	R2,Z+18
    02370 8833      LDD	R3,Z+19
    02371 2022      TST	R2
    02372 F419      BNE	0x2376
    02373 2033      TST	R3
    02374 F409      BNE	0x2376
    02375 C032      RJMP	0x23A8
(2979) 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    02376 93AF      PUSH	R26
    02377 93BF      PUSH	R27
    02378 89A2      LDD	R26,Z+18
    02379 89B3      LDD	R27,Z+19
    0237A 01FD      MOVW	R30,R26
    0237B 91BF      POP	R27
    0237C 91AF      POP	R26
    0237D 8423      LDD	R2,Z+11
    0237E FE24      SBRS	R2,4
    0237F C027      RJMP	0x23A7
(2980) 					dj->sclust = LD_CLUST(dj->dir);
    02380 01FB      MOVW	R30,R22
    02381 88A2      LDD	R10,Z+18
    02382 88B3      LDD	R11,Z+19
    02383 01F5      MOVW	R30,R10
    02384 8C22      LDD	R2,Z+26
    02385 2433      CLR	R3
    02386 8C43      LDD	R4,Z+27
    02387 2455      CLR	R5
    02388 2C54      MOV	R5,R4
    02389 2444      CLR	R4
    0238A 2842      OR	R4,R2
    0238B 2853      OR	R5,R3
    0238C 0112      MOVW	R2,R4
    0238D 2444      CLR	R4
    0238E 2455      CLR	R5
    0238F 8864      LDD	R6,Z+20
    02390 2477      CLR	R7
    02391 8885      LDD	R8,Z+21
    02392 2499      CLR	R9
    02393 2C98      MOV	R9,R8
    02394 2488      CLR	R8
    02395 2886      OR	R8,R6
    02396 2897      OR	R9,R7
    02397 0134      MOVW	R6,R8
    02398 2488      CLR	R8
    02399 2499      CLR	R9
    0239A 0143      MOVW	R8,R6
    0239B 2466      CLR	R6
    0239C 2477      CLR	R7
    0239D 2862      OR	R6,R2
    0239E 2873      OR	R7,R3
    0239F 2884      OR	R8,R4
    023A0 2895      OR	R9,R5
    023A1 01FB      MOVW	R30,R22
    023A2 8266      STD	Z+6,R6
    023A3 8277      STD	Z+7,R7
    023A4 8680      STD	Z+8,R8
    023A5 8691      STD	Z+9,R9
(2981) 				} else {						/* The object is not a directory */
    023A6 C001      RJMP	0x23A8
(2982) 					res = FR_NO_PATH;
    023A7 E045      LDI	R20,5
(2983) 				}
(2984) 			}
(2985) 			if (res == FR_OK) {
    023A8 2344      TST	R20
    023A9 F479      BNE	0x23B9
(2986) 				dj->id = dj->fs->id;
    023AA 01FB      MOVW	R30,R22
    023AB 81A0      LD	R26,Z
    023AC 81B1      LDD	R27,Z+1
    023AD 9616      ADIW	R26,6
    023AE 902D      LD	R2,X+
    023AF 903C      LD	R3,X
    023B0 8233      STD	Z+3,R3
    023B1 8222      STD	Z+2,R2
(2987) 				res = dir_sdi(dj, 0);			/* Rewind dir */
    023B2 2722      CLR	R18
    023B3 2733      CLR	R19
    023B4 018F      MOVW	R16,R30
    023B5 940E 0ACC CALL	ff.c:dir_sdi
    023B7 2EA0      MOV	R10,R16
    023B8 2D4A      MOV	R20,R10
(2988) 			}
(2989) 		}
(2990) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
    023B9 3044      CPI	R20,4
    023BA F409      BNE	0x23BC
    023BB E045      LDI	R20,5
(2991) 	}
(2992) 
(2993) 	LEAVE_FF(dj->fs, res);
    023BC 2F04      MOV	R16,R20
    023BD 962D      ADIW	R28,0xD
    023BE 940E 4191 CALL	pop_xgsetF00C
    023C0 9622      ADIW	R28,2
    023C1 9508      RET
_f_readdir:
  sfn                  --> Y,+0
  res                  --> R20
  fno                  --> R10
  dj                   --> R22
    023C2 940E 41A6 CALL	push_xgsetF03C
    023C4 0159      MOVW	R10,R18
    023C5 01B8      MOVW	R22,R16
    023C6 972C      SBIW	R28,0xC
(2994) }
(2995) 
(2996) 
(2997) 
(2998) 
(2999) /*-----------------------------------------------------------------------*/
(3000) /* Read Directory Entry in Sequense                                      */
(3001) /*-----------------------------------------------------------------------*/
(3002) 
(3003) FRESULT f_readdir (
(3004) 	DIR *dj,			/* Pointer to the open directory object */
(3005) 	FILINFO *fno		/* Pointer to file information to return */
(3006) )
(3007) {
(3008) 	FRESULT res;
(3009) 	DEF_NAMEBUF;
(3010) 
(3011) 
(3012) 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    023C7 01FB      MOVW	R30,R22
    023C8 8122      LDD	R18,Z+2
    023C9 8133      LDD	R19,Z+3
    023CA 8100      LD	R16,Z
    023CB 8111      LDD	R17,Z+1
    023CC 940E 1668 CALL	ff.c:validate
    023CE 2F40      MOV	R20,R16
(3013) 	if (res == FR_OK) {
    023CF 2300      TST	R16
    023D0 F009      BEQ	0x23D2
    023D1 C035      RJMP	0x2407
(3014) 		if (!fno) {
    023D2 20AA      TST	R10
    023D3 F449      BNE	0x23DD
    023D4 20BB      TST	R11
    023D5 F439      BNE	0x23DD
(3015) 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    023D6 2722      CLR	R18
    023D7 2733      CLR	R19
    023D8 018B      MOVW	R16,R22
    023D9 940E 0ACC CALL	ff.c:dir_sdi
    023DB 2F40      MOV	R20,R16
(3016) 		} else {
    023DC C02A      RJMP	0x2407
(3017) 			INIT_BUF(*dj);
    023DD 01CE      MOVW	R24,R28
    023DE 01FB      MOVW	R30,R22
    023DF 8B95      STD	Z+21,R25
    023E0 8B84      STD	Z+20,R24
(3018) 			res = dir_read(dj);				/* Read an directory item */
    023E1 018F      MOVW	R16,R30
    023E2 940E 0DC9 CALL	ff.c:dir_read
    023E4 2EC0      MOV	R12,R16
    023E5 2D4C      MOV	R20,R12
(3019) 			if (res == FR_NO_FILE) {		/* Reached end of dir */
    023E6 3004      CPI	R16,4
    023E7 F441      BNE	0x23F0
(3020) 				dj->sect = 0;
    023E8 01FB      MOVW	R30,R22
    023E9 963E      ADIW	R30,0xE
    023EA E080      LDI	R24,0
    023EB 8380      ST	Z,R24
    023EC 8381      STD	Z+1,R24
    023ED 8382      STD	Z+2,R24
    023EE 8383      STD	Z+3,R24
(3021) 				res = FR_OK;
    023EF 2744      CLR	R20
(3022) 			}
(3023) 			if (res == FR_OK) {				/* A valid entry is found */
    023F0 2344      TST	R20
    023F1 F4A9      BNE	0x2407
(3024) 				get_fileinfo(dj, fno);		/* Get the object information */
    023F2 0195      MOVW	R18,R10
    023F3 018B      MOVW	R16,R22
    023F4 940E 0F7F CALL	ff.c:get_fileinfo
(3025) 				res = dir_next(dj, 0);		/* Increment index for next */
    023F6 2722      CLR	R18
    023F7 2733      CLR	R19
    023F8 018B      MOVW	R16,R22
    023F9 940E 0BD6 CALL	ff.c:dir_next
    023FB 2EA0      MOV	R10,R16
    023FC 2D4A      MOV	R20,R10
(3026) 				if (res == FR_NO_FILE) {
    023FD 3004      CPI	R16,4
    023FE F441      BNE	0x2407
(3027) 					dj->sect = 0;
    023FF 01FB      MOVW	R30,R22
    02400 963E      ADIW	R30,0xE
    02401 E080      LDI	R24,0
    02402 8380      ST	Z,R24
    02403 8381      STD	Z+1,R24
    02404 8382      STD	Z+2,R24
    02405 8383      STD	Z+3,R24
(3028) 					res = FR_OK;
    02406 2744      CLR	R20
(3029) 				}
(3030) 			}
(3031) 			FREE_BUF();
(3032) 		}
(3033) 	}
(3034) 
(3035) 	LEAVE_FF(dj->fs, res);
    02407 2F04      MOV	R16,R20
    02408 962C      ADIW	R28,0xC
    02409 940C 41AF JMP	pop_xgsetF03C
FILE: D:\LQD\software\master\software_src\delay.c
(0001) /*******************************
(0002)  function ：延时函数
(0003) Clock F  :7.3728M 
(0004) Software : ICCAVR7.14C
(0005) ********************************/
(0006) /*---------------------------------------------------------------------------------
(0007)      延时程序计算方法
(0008)      计数个数j = 延时时间/6*晶振频率 - 1
(0009) ---------------------------------------------------------------------------------*/
(0010) void delayus(unsigned int tttt)   // 1.2us 延时子函数   
(0011) { 
(0012)    do
(0013)    {
(0014)        tttt--;
_delayus:
  tttt                 --> R16
    0240B 5001      SUBI	R16,1
    0240C 4010      SBCI	R17,0
(0015)    }
(0016)    while(tttt>1);
    0240D E081      LDI	R24,1
    0240E E090      LDI	R25,0
    0240F 1780      CP	R24,R16
    02410 0791      CPC	R25,R17
    02411 F3C8      BCS	0x240B
    02412 9508      RET
_delayms:
  j                    --> R20
  i                    --> R16
    02413 934A      ST	-Y,R20
    02414 935A      ST	-Y,R21
(0017) }
(0018) void delayms(unsigned int i)                 //1ms延时
(0019)    {
    02415 C00A      RJMP	0x2420
(0020)     while(i--)
(0021)     {                          
(0022) 	    unsigned int j;                
(0023)         for(j=1;j<=1227;j++)   
    02416 E041      LDI	R20,1
    02417 E050      LDI	R21,0
    02418 C002      RJMP	0x241B
    02419 5F4F      SUBI	R20,0xFF
    0241A 4F5F      SBCI	R21,0xFF
    0241B EC8B      LDI	R24,0xCB
    0241C E094      LDI	R25,4
    0241D 1784      CP	R24,R20
    0241E 0795      CPC	R25,R21
    0241F F7C8      BCC	0x2419
    02420 0118      MOVW	R2,R16
    02421 5001      SUBI	R16,1
    02422 4010      SBCI	R17,0
    02423 2022      TST	R2
    02424 F789      BNE	0x2416
    02425 2033      TST	R3
    02426 F779      BNE	0x2416
    02427 9159      LD	R21,Y+
    02428 9149      LD	R20,Y+
    02429 9508      RET
FILE: D:\LQD\software\master\software_src\main.c
(0001) #include "config.h"
(0002) #define  N_per_Second  (2.72*60)
(0003) const char tab[]="\t\0";
(0004) const char enter[]="\n\0";
(0005) char buffer[512];
(0006) char TempChar[80]; //存放临时字串
(0007) struct DATA Result;
(0008) struct tm t;
(0009) unsigned long now =0; 
(0010) void debug(UINT8 *str,UINT8 val);
(0011) void WriteSDFile(void);
(0012) struct CONFIG config;
(0013) void initDevices(void){
(0014)      CLI();
_initDevices:
    0242A 94F8      BCLR	7
(0015) 	 DDRA=0XFF;
    0242B EF8F      LDI	R24,0xFF
    0242C BB8A      OUT	0x1A,R24
(0016) 	 PORTA=0XFF;
    0242D BB8B      OUT	0x1B,R24
(0017) 	 DDRB=0XFF;
    0242E BB87      OUT	0x17,R24
(0018) 	 PORTB=0XFF; 	 
    0242F BB88      OUT	0x18,R24
(0019) 	 DDRC=0XFF;
    02430 BB84      OUT	0x14,R24
(0020) 	 PORTC=0XFF;
    02431 BB85      OUT	0x15,R24
(0021) 	 DDRG=0XFF;
    02432 9380 0064 STS	0x64,R24
(0022) 	 PORTG=0XFF;	 
    02434 9380 0065 STS	0x65,R24
(0023) 	 SPI_IO_Init(); 
    02436 940E 3986 CALL	_SPI_IO_Init
(0024) 	 SD_Init();
    02438 940E 2B76 CALL	_SD_Init
(0025) 	 uart1_init();
    0243A 940E 37B0 CALL	_uart1_init
(0026) 	 LCD_INT();delayms(50);LCD_INT();
    0243C 940E 39A4 CALL	_LCD_INT
    0243E E302      LDI	R16,0x32
    0243F E010      LDI	R17,0
    02440 940E 2413 CALL	_delayms
    02442 940E 39A4 CALL	_LCD_INT
(0027) 	 LCD_SW(1);
    02444 E001      LDI	R16,1
    02445 940E 399A CALL	_LCD_SW
(0028) 	 config.THRESHOLD_delta_sec=3; //一次检测用时
    02447 E083      LDI	R24,3
    02448 9380 07E4 STS	config+4,R24
    0244A E080      LDI	R24,0
    0244B 9380 07E5 STS	config+5,R24
    0244D 9380 07E6 STS	config+6,R24
    0244F 9380 07E7 STS	config+7,R24
(0029) 	 config.autocheck=1;        //自动检测开关
    02451 E081      LDI	R24,1
    02452 9380 07F0 STS	config+16,R24
(0030) 	 config.checkDeltaTime=5;  //自动检测模式 时间间隔
    02454 E085      LDI	R24,5
    02455 E090      LDI	R25,0
    02456 9390 07F2 STS	config+18,R25
    02458 9380 07F1 STS	config+17,R24
(0031) 	 config.readMode = 0;      //读数据模式
    0245A 2422      CLR	R2
    0245B 9220 07F3 STS	config+19,R2
(0032) 	 SEI();
    0245D 9478      BSET	7
    0245E 9508      RET
(0033) }
(0034) void timer1_init(void)
(0035) {
(0036)  TCCR1B = 0x00; //stop
_timer1_init:
    0245F 2422      CLR	R2
    02460 BC2E      OUT	0x2E,R2
(0037)  TCNT1H = 0x00 /*INVALID SETTING*/; //setup
    02461 BC2D      OUT	0x2D,R2
(0038)  TCNT1L = 0x00 /*INVALID SETTING*/;
    02462 BC2C      OUT	0x2C,R2
(0039)  TCCR1A = 0x00;
    02463 BC2F      OUT	0x2F,R2
(0040)  TCCR1B = 0x46; //start Timer
    02464 E486      LDI	R24,0x46
    02465 BD8E      OUT	0x2E,R24
    02466 9508      RET
_main:
  keycode              --> Y,+1
  i                    --> R10
  filename             --> Y,+513
  buf512               --> Y,+0
  tmp                  --> R10
    02467 97EF      SBIW	R28,0x3F
    02468 97EF      SBIW	R28,0x3F
    02469 97EF      SBIW	R28,0x3F
    0246A 97EF      SBIW	R28,0x3F
    0246B 97EF      SBIW	R28,0x3F
    0246C 97EF      SBIW	R28,0x3F
    0246D 97EF      SBIW	R28,0x3F
    0246E 97EF      SBIW	R28,0x3F
    0246F 9767      SBIW	R28,0x17
(0041) }
(0042) ////////////////////////////////////////////////////////////////
(0043) void main(void){
(0044) 	 UINT8 tmp,keycode;
(0045) 	 UINT8 buf512[513];
(0046) 	 char filename[]="201302.xls\0\0\0";
    02470 E189      LDI	R24,0x19
    02471 E091      LDI	R25,1
    02472 01FE      MOVW	R30,R28
    02473 5FEF      SUBI	R30,0xFF
    02474 4FFD      SBCI	R31,0xFD
    02475 E00E      LDI	R16,0xE
    02476 E010      LDI	R17,0
    02477 93FA      ST	-Y,R31
    02478 93EA      ST	-Y,R30
    02479 939A      ST	-Y,R25
    0247A 938A      ST	-Y,R24
    0247B 940E 4212 CALL	asgnblk
(0047) 	 int i=0;
    0247D 24AA      CLR	R10
    0247E 24BB      CLR	R11
(0048) 	 initDevices();
    0247F DFAA      RCALL	_initDevices
(0049) 	 dateRefresh(1);
    02480 E001      LDI	R16,1
    02481 940E 3663 CALL	_dateRefresh
(0050) 	 WriteFileHead();
    02483 D0FD      RCALL	_WriteFileHead
(0051)      Result.Index=findIndex(get_name(filename),buf512);
    02484 018E      MOVW	R16,R28
    02485 5F0F      SUBI	R16,0xFF
    02486 4F1D      SBCI	R17,0xFD
    02487 D5C4      RCALL	_get_name
    02488 019E      MOVW	R18,R28
    02489 D23A      RCALL	_findIndex
    0248A 0118      MOVW	R2,R16
    0248B 2444      CLR	R4
    0248C 2455      CLR	R5
    0248D 9230 057B STS	Result+11,R3
    0248F 9220 057A STS	Result+10,R2
    02491 9250 057D STS	Result+13,R5
    02493 9240 057C STS	Result+12,R4
(0052) 	 //selfTest();
(0053) 	 GUI_welcome();
    02495 940E 3646 CALL	_GUI_welcome
    02497 C025      RJMP	0x24BD
(0054) 	 while(1){
(0055) 	    tmp=GUI_mainmeu();
    02498 940E 2D4F CALL	_GUI_mainmeu
    0249A 2EA0      MOV	R10,R16
(0056) 		switch(tmp){
    0249B 2D4A      MOV	R20,R10
    0249C 2755      CLR	R21
    0249D 3043      CPI	R20,3
    0249E E0E0      LDI	R30,0
    0249F 075E      CPC	R21,R30
    024A0 F069      BEQ	0x24AE
    024A1 3044      CPI	R20,4
    024A2 E0E0      LDI	R30,0
    024A3 075E      CPC	R21,R30
    024A4 F061      BEQ	0x24B1
    024A5 3045      CPI	R20,5
    024A6 E0E0      LDI	R30,0
    024A7 075E      CPC	R21,R30
    024A8 F059      BEQ	0x24B4
    024A9 3047      CPI	R20,7
    024AA E0E0      LDI	R30,0
    024AB 075E      CPC	R21,R30
    024AC F059      BEQ	0x24B8
    024AD C00B      RJMP	0x24B9
(0057) 		    case 3 : GUI_check(); break; 
    024AE 940E 2E3E CALL	_GUI_check
    024B0 C008      RJMP	0x24B9
(0058) 			case 4 : GUI_set_time(); break ;
    024B1 940E 32E1 CALL	_GUI_set_time
    024B3 C005      RJMP	0x24B9
(0059) 			case 5 : GUI_readback(buf512); break;
    024B4 018E      MOVW	R16,R28
    024B5 940E 3529 CALL	_GUI_readback
    024B7 C001      RJMP	0x24B9
(0060) 			//case 6 : GUI_send_date();
(0061) 			case 7 : selfTest(); break ;
    024B8 D00F      RCALL	_selfTest
(0062) 			default : break;
(0063) 	   }
(0064) 	   delayms(100);
    024B9 E604      LDI	R16,0x64
    024BA E010      LDI	R17,0
    024BB 940E 2413 CALL	_delayms
    024BD CFDA      RJMP	0x2498
    024BE 96EF      ADIW	R28,0x3F
    024BF 96EF      ADIW	R28,0x3F
    024C0 96EF      ADIW	R28,0x3F
    024C1 96EF      ADIW	R28,0x3F
    024C2 96EF      ADIW	R28,0x3F
    024C3 96EF      ADIW	R28,0x3F
    024C4 96EF      ADIW	R28,0x3F
    024C5 96EF      ADIW	R28,0x3F
    024C6 9667      ADIW	R28,0x17
    024C7 9508      RET
_selfTest:
  str2                 --> Y,+12
  str1                 --> Y,+6
  tmp                  --> Y,+2
    024C8 9762      SBIW	R28,0x12
(0065) 	 }
(0066) 
(0067) }
(0068) void selfTest(void){
(0069) 	float tmp=0;                                                                
    024C9 EB04      LDI	R16,0xB4
    024CA E010      LDI	R17,0
    024CB 940E 40F3 CALL	elpm32
    024CD 830A      STD	Y+2,R16
    024CE 831B      STD	Y+3,R17
    024CF 832C      STD	Y+4,R18
    024D0 833D      STD	Y+5,R19
(0070) 	char str1[6],str2[6];
(0071) 	
(0072) 	 //自检程序
(0073) 	lp("自检程序");delayms(500);
    024D1 E401      LDI	R16,0x41
    024D2 E012      LDI	R17,2
    024D3 940E 3CD3 CALL	_lp
    024D5 EF04      LDI	R16,0xF4
    024D6 E011      LDI	R17,1
    024D7 940E 2413 CALL	_delayms
(0074) 	lp("外部温度 ");
    024D9 E307      LDI	R16,0x37
    024DA E012      LDI	R17,2
    024DB 940E 3CD3 CALL	_lp
(0075) 	tmp=read_T_NUM(0);
    024DD 2700      CLR	R16
    024DE 940E 3F06 CALL	_read_T_NUM
    024E0 830A      STD	Y+2,R16
    024E1 831B      STD	Y+3,R17
    024E2 832C      STD	Y+4,R18
    024E3 833D      STD	Y+5,R19
(0076) 	ftochr(tmp,str1);
    024E4 01CE      MOVW	R24,R28
    024E5 9606      ADIW	R24,6
    024E6 8399      STD	Y+1,R25
    024E7 8388      ST	Y,R24
    024E8 810A      LDD	R16,Y+2
    024E9 811B      LDD	R17,Y+3
    024EA 812C      LDD	R18,Y+4
    024EB 813D      LDD	R19,Y+5
    024EC D465      RCALL	_ftochr
(0077) 	str1[6]=0;
    024ED 2422      CLR	R2
    024EE 862C      STD	Y+12,R2
(0078) 	lp(str1);
    024EF 018E      MOVW	R16,R28
    024F0 5F0A      SUBI	R16,0xFA
    024F1 4F1F      SBCI	R17,0xFF
    024F2 940E 3CD3 CALL	_lp
(0079) 	delayms(500);
    024F4 EF04      LDI	R16,0xF4
    024F5 E011      LDI	R17,1
    024F6 940E 2413 CALL	_delayms
(0080) 	lp("内部温度");
    024F8 E20E      LDI	R16,0x2E
    024F9 E012      LDI	R17,2
    024FA 940E 3CD3 CALL	_lp
(0081) 	tmp=read_T_NUM(1);
    024FC E001      LDI	R16,1
    024FD 940E 3F06 CALL	_read_T_NUM
    024FF 830A      STD	Y+2,R16
    02500 831B      STD	Y+3,R17
    02501 832C      STD	Y+4,R18
    02502 833D      STD	Y+5,R19
(0082) 	ftochr(tmp,str2);
    02503 01CE      MOVW	R24,R28
    02504 960C      ADIW	R24,0xC
    02505 8399      STD	Y+1,R25
    02506 8388      ST	Y,R24
    02507 810A      LDD	R16,Y+2
    02508 811B      LDD	R17,Y+3
    02509 812C      LDD	R18,Y+4
    0250A 813D      LDD	R19,Y+5
    0250B D446      RCALL	_ftochr
(0083) 	str2[6]=0;
    0250C 2422      CLR	R2
    0250D 8A2A      STD	Y+18,R2
(0084) 	lp(str2);
    0250E 018E      MOVW	R16,R28
    0250F 5F04      SUBI	R16,0xF4
    02510 4F1F      SBCI	R17,0xFF
    02511 940E 3CD3 CALL	_lp
(0085) 	delayms(500);
    02513 EF04      LDI	R16,0xF4
    02514 E011      LDI	R17,1
    02515 940E 2413 CALL	_delayms
(0086) 	lp("风速脉冲：");delayms(500);
    02517 E203      LDI	R16,0x23
    02518 E012      LDI	R17,2
    02519 940E 3CD3 CALL	_lp
    0251B EF04      LDI	R16,0xF4
    0251C E011      LDI	R17,1
    0251D 940E 2413 CALL	_delayms
(0087) 	lp("蜂鸣器"); beep(2,2);delayms(500);
    0251F E10C      LDI	R16,0x1C
    02520 E012      LDI	R17,2
    02521 940E 3CD3 CALL	_lp
    02523 E022      LDI	R18,2
    02524 E002      LDI	R16,2
    02525 940E 3D49 CALL	_beep
    02527 EF04      LDI	R16,0xF4
    02528 E011      LDI	R17,1
    02529 940E 2413 CALL	_delayms
(0088) 	lp("power 指示灯");
    0252B E00F      LDI	R16,0xF
    0252C E012      LDI	R17,2
    0252D 940E 3CD3 CALL	_lp
(0089) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    0252F 9AA7      SBI	0x14,7
    02530 98AF      CBI	0x15,7
    02531 E604      LDI	R16,0x64
    02532 E010      LDI	R17,0
    02533 940E 2413 CALL	_delayms
    02535 9AA7      SBI	0x14,7
    02536 9AAF      SBI	0x15,7
    02537 E604      LDI	R16,0x64
    02538 E010      LDI	R17,0
    02539 940E 2413 CALL	_delayms
(0090) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    0253B 9AA7      SBI	0x14,7
    0253C 98AF      CBI	0x15,7
    0253D E604      LDI	R16,0x64
    0253E E010      LDI	R17,0
    0253F 940E 2413 CALL	_delayms
    02541 9AA7      SBI	0x14,7
    02542 9AAF      SBI	0x15,7
    02543 E604      LDI	R16,0x64
    02544 E010      LDI	R17,0
    02545 940E 2413 CALL	_delayms
(0091) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02547 9AA7      SBI	0x14,7
    02548 98AF      CBI	0x15,7
    02549 E604      LDI	R16,0x64
    0254A E010      LDI	R17,0
    0254B 940E 2413 CALL	_delayms
    0254D 9AA7      SBI	0x14,7
    0254E 9AAF      SBI	0x15,7
    0254F E604      LDI	R16,0x64
    02550 E010      LDI	R17,0
    02551 940E 2413 CALL	_delayms
(0092) 	delayms(500);
    02553 EF04      LDI	R16,0xF4
    02554 E011      LDI	R17,1
    02555 940E 2413 CALL	_delayms
(0093) 	lp("加热开关");
    02557 E006      LDI	R16,6
    02558 E012      LDI	R17,2
    02559 940E 3CD3 CALL	_lp
(0094) 	RELAY_ON();delayms(100);  
    0255B 9AAD      SBI	0x15,5
    0255C E604      LDI	R16,0x64
    0255D E010      LDI	R17,0
    0255E 940E 2413 CALL	_delayms
(0095) 	RELAY_OFF();delayms(100);
    02560 98AD      CBI	0x15,5
    02561 E604      LDI	R16,0x64
    02562 E010      LDI	R17,0
    02563 940E 2413 CALL	_delayms
(0096) 	RELAY_ON();delayms(100);
    02565 9AAD      SBI	0x15,5
    02566 E604      LDI	R16,0x64
    02567 E010      LDI	R17,0
    02568 940E 2413 CALL	_delayms
(0097) 	RELAY_OFF();delayms(100);
    0256A 98AD      CBI	0x15,5
    0256B E604      LDI	R16,0x64
    0256C E010      LDI	R17,0
    0256D 940E 2413 CALL	_delayms
(0098) 	lp("  ");delayms(500);
    0256F E003      LDI	R16,3
    02570 E012      LDI	R17,2
    02571 940E 3CD3 CALL	_lp
    02573 EF04      LDI	R16,0xF4
    02574 E011      LDI	R17,1
    02575 940E 2413 CALL	_delayms
(0099) 	lp("完成自检");delayms(500);
    02577 EF0A      LDI	R16,0xFA
    02578 E011      LDI	R17,1
    02579 940E 3CD3 CALL	_lp
    0257B EF04      LDI	R16,0xF4
    0257C E011      LDI	R17,1
    0257D 940E 2413 CALL	_delayms
    0257F 9662      ADIW	R28,0x12
    02580 9508      RET
_WriteFileHead:
  fs                   --> Y,+177
  bw                   --> Y,+175
  fnamep               --> Y,+161
  itam                 --> Y,+38
  file                 --> Y,+4
  res                  --> R10
    02581 940E 4171 CALL	push_xgset003C
    02583 97EF      SBIW	R28,0x3F
    02584 97EF      SBIW	R28,0x3F
    02585 97EF      SBIW	R28,0x3F
    02586 97EF      SBIW	R28,0x3F
    02587 97EF      SBIW	R28,0x3F
    02588 97EF      SBIW	R28,0x3F
    02589 97EF      SBIW	R28,0x3F
    0258A 97EF      SBIW	R28,0x3F
    0258B 97EF      SBIW	R28,0x3F
    0258C 97EF      SBIW	R28,0x3F
    0258D 97EF      SBIW	R28,0x3F
    0258E 97AA      SBIW	R28,0x2A
(0100) 	  
(0101) }
(0102) void WriteFileHead(void)   
(0103) {
(0104)  	 unsigned int bw;
(0105) 	 FRESULT res;
(0106) 	 FATFS fs;
(0107) 	 FIL file;
(0108) 	 char fnamep[]="201201.xls\0\0\0"; 
    0258F E287      LDI	R24,0x27
    02590 E091      LDI	R25,1
    02591 01FE      MOVW	R30,R28
    02592 55EF      SUBI	R30,0x5F
    02593 4FFF      SBCI	R31,0xFF
    02594 E00E      LDI	R16,0xE
    02595 E010      LDI	R17,0
    02596 93FA      ST	-Y,R31
    02597 93EA      ST	-Y,R30
    02598 939A      ST	-Y,R25
    02599 938A      ST	-Y,R24
    0259A 940E 4212 CALL	asgnblk
(0109) 	 UINT8 itam[]="DEV000001\t\t\t\t\t\t\t\t\t\t\r\n序号\t日期\t时分\t温度\t风速\t风冷指数\t等价制冷温度\t相当温度\t冻伤危害性\t安静作业\t中等强度作业\t高强度作业\n\0";
    0259C E385      LDI	R24,0x35
    0259D E091      LDI	R25,1
    0259E 01FE      MOVW	R30,R28
    0259F 96B6      ADIW	R30,0x26
    025A0 E70B      LDI	R16,0x7B
    025A1 E010      LDI	R17,0
    025A2 93FA      ST	-Y,R31
    025A3 93EA      ST	-Y,R30
    025A4 939A      ST	-Y,R25
    025A5 938A      ST	-Y,R24
    025A6 940E 4212 CALL	asgnblk
(0110) 	 res=disk_initialize(0);
    025A8 2700      CLR	R16
    025A9 940E 0299 CALL	_disk_initialize
    025AB 2EA0      MOV	R10,R16
(0111) 	 #ifdef _DEBUG
(0112) 	 debug("dinit",res);
    025AC 2D2A      MOV	R18,R10
    025AD EF04      LDI	R16,0xF4
    025AE E011      LDI	R17,1
    025AF D577      RCALL	_debug
(0113) 	 #endif
(0114) 	 res = f_mount(0, &fs);
    025B0 019E      MOVW	R18,R28
    025B1 542F      SUBI	R18,0x4F
    025B2 4F3F      SBCI	R19,0xFF
    025B3 2700      CLR	R16
    025B4 940E 1685 CALL	_f_mount
    025B6 2EA0      MOV	R10,R16
(0115) 	 #ifdef _DEBUG
(0116)  	 debug("dmnt",res);
    025B7 2D2A      MOV	R18,R10
    025B8 EE0F      LDI	R16,0xEF
    025B9 E011      LDI	R17,1
    025BA D56C      RCALL	_debug
(0117) 	 #endif
(0118) 	 //get_name(fnamep)
(0119) 	 res = f_open(&file, get_name(fnamep) , FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    025BB 018E      MOVW	R16,R28
    025BC 550F      SUBI	R16,0x5F
    025BD 4F1F      SBCI	R17,0xFF
    025BE D48D      RCALL	_get_name
    025BF 0168      MOVW	R12,R16
    025C0 E182      LDI	R24,0x12
    025C1 8388      ST	Y,R24
    025C2 0196      MOVW	R18,R12
    025C3 018E      MOVW	R16,R28
    025C4 5F0C      SUBI	R16,0xFC
    025C5 4F1F      SBCI	R17,0xFF
    025C6 940E 16B0 CALL	_f_open
    025C8 2EC0      MOV	R12,R16
    025C9 2CAC      MOV	R10,R12
(0120) 	 #ifdef _DEBUG
(0121) 	 debug("fopen",res);
    025CA 2D2A      MOV	R18,R10
    025CB EE09      LDI	R16,0xE9
    025CC E011      LDI	R17,1
    025CD D559      RCALL	_debug
(0122) 	 #endif
(0123) 	 res = f_write(&file,itam,sizeof(itam),&bw);   //bw 已写入字节数
    025CE 01CE      MOVW	R24,R28
    025CF 5581      SUBI	R24,0x51
    025D0 4F9F      SBCI	R25,0xFF
    025D1 839B      STD	Y+3,R25
    025D2 838A      STD	Y+2,R24
    025D3 E78B      LDI	R24,0x7B
    025D4 E090      LDI	R25,0
    025D5 8399      STD	Y+1,R25
    025D6 8388      ST	Y,R24
    025D7 019E      MOVW	R18,R28
    025D8 5D2A      SUBI	R18,0xDA
    025D9 4F3F      SBCI	R19,0xFF
    025DA 018E      MOVW	R16,R28
    025DB 5F0C      SUBI	R16,0xFC
    025DC 4F1F      SBCI	R17,0xFF
    025DD 940E 1AB7 CALL	_f_write
    025DF 2EC0      MOV	R12,R16
    025E0 2CAC      MOV	R10,R12
(0124) 	 #ifdef _DEBUG
(0125) 	 debug("fwrite",res);
    025E1 2D2A      MOV	R18,R10
    025E2 EE02      LDI	R16,0xE2
    025E3 E011      LDI	R17,1
    025E4 D542      RCALL	_debug
(0126) 	 #endif
(0127) 	 f_close(&file);
    025E5 018E      MOVW	R16,R28
    025E6 5F0C      SUBI	R16,0xFC
    025E7 4F1F      SBCI	R17,0xFF
    025E8 940E 1E81 CALL	_f_close
(0128) 	 f_mount(0, NULL);
    025EA 2722      CLR	R18
    025EB 2733      CLR	R19
    025EC 2700      CLR	R16
    025ED 940E 1685 CALL	_f_mount
    025EF 96EF      ADIW	R28,0x3F
    025F0 96EF      ADIW	R28,0x3F
    025F1 96EF      ADIW	R28,0x3F
    025F2 96EF      ADIW	R28,0x3F
    025F3 96EF      ADIW	R28,0x3F
    025F4 96EF      ADIW	R28,0x3F
    025F5 96EF      ADIW	R28,0x3F
    025F6 96EF      ADIW	R28,0x3F
    025F7 96EF      ADIW	R28,0x3F
    025F8 96EF      ADIW	R28,0x3F
    025F9 96EF      ADIW	R28,0x3F
    025FA 96AA      ADIW	R28,0x2A
    025FB 940C 414B JMP	pop_xgset003C
_WriteSDFile:
  fnamep               --> Y,+602
  fs                   --> Y,+44
  bw                   --> Y,+42
  lenth                --> Y,+38
  res                  --> R10
  file                 --> Y,+4
    025FD 92AA      ST	-Y,R10
    025FE 92CA      ST	-Y,R12
    025FF 97EF      SBIW	R28,0x3F
    02600 97EF      SBIW	R28,0x3F
    02601 97EF      SBIW	R28,0x3F
    02602 97EF      SBIW	R28,0x3F
    02603 97EF      SBIW	R28,0x3F
    02604 97EF      SBIW	R28,0x3F
    02605 97EF      SBIW	R28,0x3F
    02606 97EF      SBIW	R28,0x3F
    02607 97EF      SBIW	R28,0x3F
    02608 97E0      SBIW	R28,0x30
(0129) } /////////////////////////////////////////////////
(0130) //       写入文件函数 
(0131) //(创建)打开文件 
(0132) // data 指向欲写入的的字符串 64byt 
(0133) //////////////////////////////////////////////// 
(0134) void WriteSDFile(void)   
(0135) {
(0136)     unsigned int bw;
(0137) 	FRESULT res;
(0138) 	FATFS fs;
(0139)     FIL file;
(0140) 	char fnamep[13];
(0141) 	long lenth=0;
    02609 E080      LDI	R24,0
    0260A A38E      STD	Y+38,R24
    0260B A38F      STD	Y+39,R24
    0260C A788      STD	Y+40,R24
    0260D A789      STD	Y+41,R24
(0142) 	disk_initialize(0);
    0260E 2700      CLR	R16
    0260F 940E 0299 CALL	_disk_initialize
(0143) 	res = f_mount(0, &fs);
    02611 019E      MOVW	R18,R28
    02612 5D24      SUBI	R18,0xD4
    02613 4F3F      SBCI	R19,0xFF
    02614 2700      CLR	R16
    02615 940E 1685 CALL	_f_mount
(0144) 	res = f_open(&file,get_name(fnamep), FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    02617 018E      MOVW	R16,R28
    02618 5A06      SUBI	R16,0xA6
    02619 4F1D      SBCI	R17,0xFD
    0261A D431      RCALL	_get_name
    0261B E182      LDI	R24,0x12
    0261C 8388      ST	Y,R24
    0261D 0198      MOVW	R18,R16
    0261E 018E      MOVW	R16,R28
    0261F 5F0C      SUBI	R16,0xFC
    02620 4F1F      SBCI	R17,0xFF
    02621 940E 16B0 CALL	_f_open
(0145) 	lenth=file.fsize;   
    02623 842E      LDD	R2,Y+14
    02624 843F      LDD	R3,Y+15
    02625 8848      LDD	R4,Y+16
    02626 8859      LDD	R5,Y+17
    02627 A22E      STD	Y+38,R2
    02628 A23F      STD	Y+39,R3
    02629 A648      STD	Y+40,R4
    0262A A659      STD	Y+41,R5
(0146) 	res = f_lseek (&file,lenth);	 
    0262B A02E      LDD	R2,Y+38
    0262C A03F      LDD	R3,Y+39
    0262D A448      LDD	R4,Y+40
    0262E A459      LDD	R5,Y+41
    0262F 8248      ST	Y,R4
    02630 8259      STD	Y+1,R5
    02631 0191      MOVW	R18,R2
    02632 018E      MOVW	R16,R28
    02633 5F0C      SUBI	R16,0xFC
    02634 4F1F      SBCI	R17,0xFF
    02635 940E 1E91 CALL	_f_lseek
(0147) 	res = f_write(&file,TempChar,64,&bw);   //bw 已写入字节数
    02637 01CE      MOVW	R24,R28
    02638 968A      ADIW	R24,0x2A
    02639 839B      STD	Y+3,R25
    0263A 838A      STD	Y+2,R24
    0263B E480      LDI	R24,0x40
    0263C E090      LDI	R25,0
    0263D 8399      STD	Y+1,R25
    0263E 8388      ST	Y,R24
    0263F E220      LDI	R18,0x20
    02640 E035      LDI	R19,5
    02641 018E      MOVW	R16,R28
    02642 5F0C      SUBI	R16,0xFC
    02643 4F1F      SBCI	R17,0xFF
    02644 940E 1AB7 CALL	_f_write
    02646 2EC0      MOV	R12,R16
    02647 2CAC      MOV	R10,R12
(0148) 	f_close(&file);
    02648 018E      MOVW	R16,R28
    02649 5F0C      SUBI	R16,0xFC
    0264A 4F1F      SBCI	R17,0xFF
    0264B 940E 1E81 CALL	_f_close
(0149) 	f_mount(0, NULL);
    0264D 2722      CLR	R18
    0264E 2733      CLR	R19
    0264F 2700      CLR	R16
    02650 940E 1685 CALL	_f_mount
    02652 96EF      ADIW	R28,0x3F
    02653 96EF      ADIW	R28,0x3F
    02654 96EF      ADIW	R28,0x3F
    02655 96EF      ADIW	R28,0x3F
    02656 96EF      ADIW	R28,0x3F
    02657 96EF      ADIW	R28,0x3F
    02658 96EF      ADIW	R28,0x3F
    02659 96EF      ADIW	R28,0x3F
    0265A 96EF      ADIW	R28,0x3F
    0265B 96E0      ADIW	R28,0x30
    0265C 90C9      LD	R12,Y+
    0265D 90A9      LD	R10,Y+
    0265E 9508      RET
_ReadSDFile:
  fs                   --> Y,+53
  bw                   --> Y,+51
  fnamep               --> Y,+38
  file                 --> Y,+4
  res                  --> R20
  data                 --> R10
  index                --> R22
    0265F 940E 41A6 CALL	push_xgsetF03C
    02661 0159      MOVW	R10,R18
    02662 01B8      MOVW	R22,R16
    02663 97EF      SBIW	R28,0x3F
    02664 97EF      SBIW	R28,0x3F
    02665 97EF      SBIW	R28,0x3F
    02666 97EF      SBIW	R28,0x3F
    02667 97EF      SBIW	R28,0x3F
    02668 97EF      SBIW	R28,0x3F
    02669 97EF      SBIW	R28,0x3F
    0266A 97EF      SBIW	R28,0x3F
    0266B 97EF      SBIW	R28,0x3F
    0266C 97AC      SBIW	R28,0x2C
(0150) }
(0151) /////////////////////////////////////////////////
(0152) //       读取文件函数
(0153) //以64byte为一块 读取
(0154) //index数据偏移量   data读出后存放地
(0155) //////////////////////////////////////////////// 
(0156) char ReadSDFile(unsigned int index,char *data)
(0157) {
(0158)  	unsigned int bw;
(0159) 	char res;
(0160) 	FATFS fs;
(0161)     FIL file;
(0162) 	char fnamep[13];
(0163)     get_name(fnamep); 
    0266D 018E      MOVW	R16,R28
    0266E 5D0A      SUBI	R16,0xDA
    0266F 4F1F      SBCI	R17,0xFF
    02670 D3DB      RCALL	_get_name
(0164)     disk_initialize(0);
    02671 2700      CLR	R16
    02672 940E 0299 CALL	_disk_initialize
(0165)     res = f_mount(0, &fs);
    02674 019E      MOVW	R18,R28
    02675 5C2B      SUBI	R18,0xCB
    02676 4F3F      SBCI	R19,0xFF
    02677 2700      CLR	R16
    02678 940E 1685 CALL	_f_mount
(0166)     res = f_open(&file,fnamep,FA_READ);  
    0267A E081      LDI	R24,1
    0267B 8388      ST	Y,R24
    0267C 019E      MOVW	R18,R28
    0267D 5D2A      SUBI	R18,0xDA
    0267E 4F3F      SBCI	R19,0xFF
    0267F 018E      MOVW	R16,R28
    02680 5F0C      SUBI	R16,0xFC
    02681 4F1F      SBCI	R17,0xFF
    02682 940E 16B0 CALL	_f_open
    02684 2F40      MOV	R20,R16
(0167)     if(res==FR_NO_FILE) {data=NULL;
    02685 3004      CPI	R16,4
    02686 F419      BNE	0x268A
    02687 24AA      CLR	R10
    02688 24BB      CLR	R11
(0168)     #if _debug >= 1 
(0169)     debug_out("now file",255);
(0170) 	debug_out(filename,res);
(0171) 	debug_out("file is no exist....",255);
(0172)     #endif 
(0173)     return res;
    02689 C02E      RJMP	0x26B8
(0174)     }   
(0175)     res = f_lseek (&file,(index+2)*64);	 //前两个字节数据为文件头空间 所以从第三块读/写起
    0268A 019B      MOVW	R18,R22
    0268B 5F2E      SUBI	R18,0xFE
    0268C 4F3F      SBCI	R19,0xFF
    0268D E400      LDI	R16,0x40
    0268E E010      LDI	R17,0
    0268F 940E 4107 CALL	empy16s
    02691 0118      MOVW	R2,R16
    02692 2444      CLR	R4
    02693 2455      CLR	R5
    02694 8248      ST	Y,R4
    02695 8259      STD	Y+1,R5
    02696 0191      MOVW	R18,R2
    02697 018E      MOVW	R16,R28
    02698 5F0C      SUBI	R16,0xFC
    02699 4F1F      SBCI	R17,0xFF
    0269A 940E 1E91 CALL	_f_lseek
    0269C 2EC0      MOV	R12,R16
(0176)     res = f_read(&file,data,64,&bw);
    0269D 01CE      MOVW	R24,R28
    0269E 96C3      ADIW	R24,0x33
    0269F 839B      STD	Y+3,R25
    026A0 838A      STD	Y+2,R24
    026A1 E480      LDI	R24,0x40
    026A2 E090      LDI	R25,0
    026A3 8399      STD	Y+1,R25
    026A4 8388      ST	Y,R24
    026A5 0195      MOVW	R18,R10
    026A6 018E      MOVW	R16,R28
    026A7 5F0C      SUBI	R16,0xFC
    026A8 4F1F      SBCI	R17,0xFF
    026A9 940E 184C CALL	_f_read
    026AB 2EA0      MOV	R10,R16
    026AC 2D4A      MOV	R20,R10
(0177)     f_close(&file);
    026AD 018E      MOVW	R16,R28
    026AE 5F0C      SUBI	R16,0xFC
    026AF 4F1F      SBCI	R17,0xFF
    026B0 940E 1E81 CALL	_f_close
(0178) 	f_mount(0, NULL);
    026B2 2722      CLR	R18
    026B3 2733      CLR	R19
    026B4 2700      CLR	R16
    026B5 940E 1685 CALL	_f_mount
(0179) 	return res;
    026B7 2F04      MOV	R16,R20
    026B8 96EF      ADIW	R28,0x3F
    026B9 96EF      ADIW	R28,0x3F
    026BA 96EF      ADIW	R28,0x3F
    026BB 96EF      ADIW	R28,0x3F
    026BC 96EF      ADIW	R28,0x3F
    026BD 96EF      ADIW	R28,0x3F
    026BE 96EF      ADIW	R28,0x3F
    026BF 96EF      ADIW	R28,0x3F
    026C0 96EF      ADIW	R28,0x3F
    026C1 96AC      ADIW	R28,0x2C
    026C2 940C 41AF JMP	pop_xgsetF03C
_findIndex:
  fs                   --> Y,+48
  bw                   --> Y,+46
  fnamep               --> R14
  readsize             --> R10
  res                  --> R12
  file                 --> Y,+12
  lenth                --> Y,+8
  index                --> Y,+4
  is_first_end         --> Y,+606
  tmp                  --> R10
  buf                  --> Y,+617
  filename             --> R10
    026C4 933A      ST	-Y,R19
    026C5 932A      ST	-Y,R18
    026C6 940E 416B CALL	push_xgsetF0FC
    026C8 0158      MOVW	R10,R16
    026C9 97EF      SBIW	R28,0x3F
    026CA 97EF      SBIW	R28,0x3F
    026CB 97EF      SBIW	R28,0x3F
    026CC 97EF      SBIW	R28,0x3F
    026CD 97EF      SBIW	R28,0x3F
    026CE 97EF      SBIW	R28,0x3F
    026CF 97EF      SBIW	R28,0x3F
    026D0 97EF      SBIW	R28,0x3F
    026D1 97EF      SBIW	R28,0x3F
    026D2 97A8      SBIW	R28,0x28
(0180) } 
(0181) //////////////////////////////////
(0182) //   find index
(0183) // 检查当前文件尺寸，根据倒数第二个
(0184) //'\n'及其后面的index确定当前index值
(0185) //////////////////////////////////
(0186) unsigned int findIndex(char *filename,char *buf){
(0187)     unsigned int bw,tmp;
(0188) 	long index =0;
    026D3 E080      LDI	R24,0
    026D4 838C      STD	Y+4,R24
    026D5 838D      STD	Y+5,R24
    026D6 838E      STD	Y+6,R24
    026D7 838F      STD	Y+7,R24
(0189) 	unsigned char is_first_end=0;
    026D8 2400      CLR	R0
    026D9 01DE      MOVW	R26,R28
    026DA 5AA2      SUBI	R26,0xA2
    026DB 4FBD      SBCI	R27,0xFD
    026DC 920C      ST	X,R0
(0190) 	char *fnamep=filename;
    026DD 0175      MOVW	R14,R10
(0191) 	FRESULT res;
(0192) 	FATFS fs;
(0193) 	FIL file;
(0194) 	long lenth=0;
    026DE E080      LDI	R24,0
    026DF 8788      STD	Y+8,R24
    026E0 8789      STD	Y+9,R24
    026E1 878A      STD	Y+10,R24
    026E2 878B      STD	Y+11,R24
(0195) 	int readsize=0;
    026E3 24AA      CLR	R10
    026E4 24BB      CLR	R11
(0196) 	//PrintString_n(fnamep);
(0197) 	res = f_mount(0, &fs);
    026E5 019E      MOVW	R18,R28
    026E6 5D20      SUBI	R18,0xD0
    026E7 4F3F      SBCI	R19,0xFF
    026E8 2700      CLR	R16
    026E9 940E 1685 CALL	_f_mount
(0198) 	res = f_open(&file,fnamep, FA_OPEN_ALWAYS | FA_READ );  //创建一个新的文件
    026EB E181      LDI	R24,0x11
    026EC 8388      ST	Y,R24
    026ED 0197      MOVW	R18,R14
    026EE 018E      MOVW	R16,R28
    026EF 5F04      SUBI	R16,0xF4
    026F0 4F1F      SBCI	R17,0xFF
    026F1 940E 16B0 CALL	_f_open
    026F3 2EC0      MOV	R12,R16
(0199) 	if(res !=  FR_OK){ //openerror
    026F4 2300      TST	R16
    026F5 F011      BEQ	0x26F8
(0200) 	    return res;}
    026F6 2711      CLR	R17
    026F7 C11E      RJMP	0x2816
(0201) 	lenth=file.fsize;   //文件尾部为 file.size 
    026F8 882E      LDD	R2,Y+22
    026F9 883F      LDD	R3,Y+23
    026FA 8C48      LDD	R4,Y+24
    026FB 8C59      LDD	R5,Y+25
    026FC 8628      STD	Y+8,R2
    026FD 8639      STD	Y+9,R3
    026FE 864A      STD	Y+10,R4
    026FF 865B      STD	Y+11,R5
(0202) 	//debug("size=",0xff);
(0203) 	//PrintLong(lenth);
(0204) 	if(lenth > 512) {
    02700 E040      LDI	R20,0
    02701 E052      LDI	R21,2
    02702 E060      LDI	R22,0
    02703 E070      LDI	R23,0
    02704 8428      LDD	R2,Y+8
    02705 8439      LDD	R3,Y+9
    02706 844A      LDD	R4,Y+10
    02707 845B      LDD	R5,Y+11
    02708 1542      CP	R20,R2
    02709 0553      CPC	R21,R3
    0270A 0564      CPC	R22,R4
    0270B 0575      CPC	R23,R5
    0270C F464      BGE	0x2719
(0205) 	    readsize=512;
    0270D E080      LDI	R24,0
    0270E E092      LDI	R25,2
    0270F 015C      MOVW	R10,R24
(0206) 		lenth=file.fsize;
    02710 882E      LDD	R2,Y+22
    02711 883F      LDD	R3,Y+23
    02712 8C48      LDD	R4,Y+24
    02713 8C59      LDD	R5,Y+25
    02714 8628      STD	Y+8,R2
    02715 8639      STD	Y+9,R3
    02716 864A      STD	Y+10,R4
    02717 865B      STD	Y+11,R5
(0207) 	}
    02718 C007      RJMP	0x2720
(0208) 	else {
(0209) 	    readsize =file.fsize;
    02719 88AE      LDD	R10,Y+22
    0271A 88BF      LDD	R11,Y+23
(0210) 		lenth=0;
    0271B E080      LDI	R24,0
    0271C 8788      STD	Y+8,R24
    0271D 8789      STD	Y+9,R24
    0271E 878A      STD	Y+10,R24
    0271F 878B      STD	Y+11,R24
(0211) 	}
(0212) 	res = f_lseek (&file,file.fsize-readsize);
    02720 0115      MOVW	R2,R10
    02721 2444      CLR	R4
    02722 FC37      SBRC	R3,7
    02723 9440      COM	R4
    02724 2455      CLR	R5
    02725 FC47      SBRC	R4,7
    02726 9450      COM	R5
    02727 886E      LDD	R6,Y+22
    02728 887F      LDD	R7,Y+23
    02729 8C88      LDD	R8,Y+24
    0272A 8C99      LDD	R9,Y+25
    0272B 1862      SUB	R6,R2
    0272C 0873      SBC	R7,R3
    0272D 0884      SBC	R8,R4
    0272E 0895      SBC	R9,R5
    0272F 8288      ST	Y,R8
    02730 8299      STD	Y+1,R9
    02731 0193      MOVW	R18,R6
    02732 018E      MOVW	R16,R28
    02733 5F04      SUBI	R16,0xF4
    02734 4F1F      SBCI	R17,0xFF
    02735 940E 1E91 CALL	_f_lseek
(0213) 	//debug("readSIZE=",0x00);
(0214) 	//PrintLong((file.fsize-readsize));
(0215) 	res = f_read(&file,buf,readsize,&bw);
    02737 01CE      MOVW	R24,R28
    02738 968E      ADIW	R24,0x2E
    02739 839B      STD	Y+3,R25
    0273A 838A      STD	Y+2,R24
    0273B 82B9      STD	Y+1,R11
    0273C 82A8      ST	Y,R10
    0273D 01FE      MOVW	R30,R28
    0273E 59E7      SUBI	R30,0x97
    0273F 4FFD      SBCI	R31,0xFD
    02740 8120      LD	R18,Z
    02741 8131      LDD	R19,Z+1
    02742 018E      MOVW	R16,R28
    02743 5F04      SUBI	R16,0xF4
    02744 4F1F      SBCI	R17,0xFF
    02745 940E 184C CALL	_f_read
    02747 2EE0      MOV	R14,R16
    02748 2CCE      MOV	R12,R14
(0216) 	f_close(&file);
    02749 018E      MOVW	R16,R28
    0274A 5F04      SUBI	R16,0xF4
    0274B 4F1F      SBCI	R17,0xFF
    0274C 940E 1E81 CALL	_f_close
(0217) 	//debug("readRES=",res);
(0218) 	//debug("readbw=",0X00);
(0219) 	//PrintLong(bw);
(0220) 	//PrintString_n(buf);
(0221) 	for(tmp=readsize;tmp>0;tmp--){
    0274E C04E      RJMP	0x279D
(0222) 		//debug("buf index",buf[tmp]);
(0223) 		//PrintLong(tmp);
(0224) 		if(buf[tmp] == '\n') Usart_Transmit('@');						  
    0274F 01F5      MOVW	R30,R10
    02750 01DE      MOVW	R26,R28
    02751 59A7      SUBI	R26,0x97
    02752 4FBD      SBCI	R27,0xFD
    02753 900D      LD	R0,X+
    02754 901C      LD	R1,X
    02755 0DE0      ADD	R30,R0
    02756 1DF1      ADC	R31,R1
    02757 8180      LD	R24,Z
    02758 308A      CPI	R24,0xA
    02759 F419      BNE	0x275D
    0275A E400      LDI	R16,0x40
    0275B 940E 37CA CALL	_Usart_Transmit
(0225) 		if(buf[tmp] == '\n' && is_first_end== 0){
    0275D 01F5      MOVW	R30,R10
    0275E 01DE      MOVW	R26,R28
    0275F 59A7      SUBI	R26,0x97
    02760 4FBD      SBCI	R27,0xFD
    02761 900D      LD	R0,X+
    02762 901C      LD	R1,X
    02763 0DE0      ADD	R30,R0
    02764 1DF1      ADC	R31,R1
    02765 8180      LD	R24,Z
    02766 308A      CPI	R24,0xA
    02767 F469      BNE	0x2775
    02768 01FE      MOVW	R30,R28
    02769 5AE2      SUBI	R30,0xA2
    0276A 4FFD      SBCI	R31,0xFD
    0276B 8000      LD	R0,Z
    0276C 2000      TST	R0
    0276D F439      BNE	0x2775
(0226) 		    is_first_end=1; 	
    0276E 2400      CLR	R0
    0276F 9403      INC	R0
    02770 01FE      MOVW	R30,R28
    02771 5AE2      SUBI	R30,0xA2
    02772 4FFD      SBCI	R31,0xFD
    02773 8200      ST	Z,R0
(0227) 			//debug("first=",0xf0);					      
(0228) 		}
    02774 C025      RJMP	0x279A
(0229) 		else if(buf[tmp] == '\n' && is_first_end== 1){
    02775 01F5      MOVW	R30,R10
    02776 01DE      MOVW	R26,R28
    02777 59A7      SUBI	R26,0x97
    02778 4FBD      SBCI	R27,0xFD
    02779 900D      LD	R0,X+
    0277A 901C      LD	R1,X
    0277B 0DE0      ADD	R30,R0
    0277C 1DF1      ADC	R31,R1
    0277D 8180      LD	R24,Z
    0277E 308A      CPI	R24,0xA
    0277F F4D1      BNE	0x279A
    02780 01DE      MOVW	R26,R28
    02781 5AA2      SUBI	R26,0xA2
    02782 4FBD      SBCI	R27,0xFD
    02783 918C      LD	R24,X
    02784 3081      CPI	R24,1
    02785 F4A1      BNE	0x279A
(0230) 		    lenth -= (512-tmp);
    02786 E080      LDI	R24,0
    02787 E092      LDI	R25,2
    02788 011C      MOVW	R2,R24
    02789 182A      SUB	R2,R10
    0278A 083B      SBC	R3,R11
    0278B 2444      CLR	R4
    0278C 2455      CLR	R5
    0278D 8468      LDD	R6,Y+8
    0278E 8479      LDD	R7,Y+9
    0278F 848A      LDD	R8,Y+10
    02790 849B      LDD	R9,Y+11
    02791 1862      SUB	R6,R2
    02792 0873      SBC	R7,R3
    02793 0884      SBC	R8,R4
    02794 0895      SBC	R9,R5
    02795 8668      STD	Y+8,R6
    02796 8679      STD	Y+9,R7
    02797 868A      STD	Y+10,R8
    02798 869B      STD	Y+11,R9
(0231) 			break;
    02799 C009      RJMP	0x27A3
    0279A 01C5      MOVW	R24,R10
    0279B 9701      SBIW	R24,1
    0279C 015C      MOVW	R10,R24
    0279D 20AA      TST	R10
    0279E F009      BEQ	0x27A0
    0279F CFAF      RJMP	0x274F
    027A0 20BB      TST	R11
    027A1 F009      BEQ	0x27A3
    027A2 CFAC      RJMP	0x274F
(0232) 		} 						
(0233) 	}
(0234) 	//debug("start=",0X00); PrintLong(lenth);
(0235) 	if(lenth < 118 ){ 
    027A3 E746      LDI	R20,0x76
    027A4 E050      LDI	R21,0
    027A5 E060      LDI	R22,0
    027A6 E070      LDI	R23,0
    027A7 8428      LDD	R2,Y+8
    027A8 8439      LDD	R3,Y+9
    027A9 844A      LDD	R4,Y+10
    027AA 845B      LDD	R5,Y+11
    027AB 1624      CP	R2,R20
    027AC 0635      CPC	R3,R21
    027AD 0646      CPC	R4,R22
    027AE 0657      CPC	R5,R23
    027AF F434      BGE	0x27B6
(0236)  		return 1;
    027B0 E001      LDI	R16,1
    027B1 E010      LDI	R17,0
    027B2 C063      RJMP	0x2816
(0237) 	}
(0238) 	else {
(0239) 		 //debug(">128 ",0X00);
(0240) 		 while(buf[tmp] <= '0' || buf[tmp] >= '9') tmp++;
    027B3 01C5      MOVW	R24,R10
    027B4 9601      ADIW	R24,1
    027B5 015C      MOVW	R10,R24
    027B6 01F5      MOVW	R30,R10
    027B7 01DE      MOVW	R26,R28
    027B8 59A7      SUBI	R26,0x97
    027B9 4FBD      SBCI	R27,0xFD
    027BA 900D      LD	R0,X+
    027BB 901C      LD	R1,X
    027BC 0DE0      ADD	R30,R0
    027BD 1DF1      ADC	R31,R1
    027BE 80E0      LD	R14,Z
    027BF 24FF      CLR	R15
    027C0 E380      LDI	R24,0x30
    027C1 158E      CP	R24,R14
    027C2 F780      BCC	0x27B3
    027C3 2D8E      MOV	R24,R14
    027C4 3389      CPI	R24,0x39
    027C5 F768      BCC	0x27B3
    027C6 C02F      RJMP	0x27F6
(0241) 		 //debug("nozero ",bw); PrintLong(tmp);
(0242) 		 while(buf[tmp] != 't' && buf[tmp] >= '0' && buf[tmp] <= '9'){
(0243) 		     index=index*10+(buf[tmp]-'0');
    027C7 01F5      MOVW	R30,R10
    027C8 01DE      MOVW	R26,R28
    027C9 59A7      SUBI	R26,0x97
    027CA 4FBD      SBCI	R27,0xFD
    027CB 900D      LD	R0,X+
    027CC 901C      LD	R1,X
    027CD 0DE0      ADD	R30,R0
    027CE 1DF1      ADC	R31,R1
    027CF 8180      LD	R24,Z
    027D0 2799      CLR	R25
    027D1 97C0      SBIW	R24,0x30
    027D2 011C      MOVW	R2,R24
    027D3 2444      CLR	R4
    027D4 FC37      SBRC	R3,7
    027D5 9440      COM	R4
    027D6 2455      CLR	R5
    027D7 FC47      SBRC	R4,7
    027D8 9450      COM	R5
    027D9 806C      LDD	R6,Y+4
    027DA 807D      LDD	R7,Y+5
    027DB 808E      LDD	R8,Y+6
    027DC 809F      LDD	R9,Y+7
    027DD E04A      LDI	R20,0xA
    027DE E050      LDI	R21,0
    027DF E060      LDI	R22,0
    027E0 E070      LDI	R23,0
    027E1 929A      ST	-Y,R9
    027E2 928A      ST	-Y,R8
    027E3 927A      ST	-Y,R7
    027E4 926A      ST	-Y,R6
    027E5 018A      MOVW	R16,R20
    027E6 019B      MOVW	R18,R22
    027E7 940E 4117 CALL	empy32u|empy32s
    027E9 0138      MOVW	R6,R16
    027EA 0149      MOVW	R8,R18
    027EB 0C62      ADD	R6,R2
    027EC 1C73      ADC	R7,R3
    027ED 1C84      ADC	R8,R4
    027EE 1C95      ADC	R9,R5
    027EF 826C      STD	Y+4,R6
    027F0 827D      STD	Y+5,R7
    027F1 828E      STD	Y+6,R8
    027F2 829F      STD	Y+7,R9
(0244) 		 	 //Usart_Transmit(buf[tmp]);	
(0245) 		 	 tmp++;
    027F3 01C5      MOVW	R24,R10
    027F4 9601      ADIW	R24,1
    027F5 015C      MOVW	R10,R24
    027F6 01F5      MOVW	R30,R10
    027F7 01DE      MOVW	R26,R28
    027F8 59A7      SUBI	R26,0x97
    027F9 4FBD      SBCI	R27,0xFD
    027FA 900D      LD	R0,X+
    027FB 901C      LD	R1,X
    027FC 0DE0      ADD	R30,R0
    027FD 1DF1      ADC	R31,R1
    027FE 80E0      LD	R14,Z
    027FF 24FF      CLR	R15
    02800 2D8E      MOV	R24,R14
    02801 3784      CPI	R24,0x74
    02802 F031      BEQ	0x2809
    02803 3380      CPI	R24,0x30
    02804 F020      BCS	0x2809
    02805 E389      LDI	R24,0x39
    02806 158E      CP	R24,R14
    02807 F008      BCS	0x2809
    02808 CFBE      RJMP	0x27C7
(0246) 		 }
(0247) 	}
(0248) 	//debug("index=",0X00);
(0249) 	//PrintLong(index+1);
(0250) 	return index+1;
    02809 E041      LDI	R20,1
    0280A E050      LDI	R21,0
    0280B E060      LDI	R22,0
    0280C E070      LDI	R23,0
    0280D 802C      LDD	R2,Y+4
    0280E 803D      LDD	R3,Y+5
    0280F 804E      LDD	R4,Y+6
    02810 805F      LDD	R5,Y+7
    02811 0E24      ADD	R2,R20
    02812 1E35      ADC	R3,R21
    02813 1E46      ADC	R4,R22
    02814 1E57      ADC	R5,R23
    02815 0181      MOVW	R16,R2
    02816 96EF      ADIW	R28,0x3F
    02817 96EF      ADIW	R28,0x3F
    02818 96EF      ADIW	R28,0x3F
    02819 96EF      ADIW	R28,0x3F
    0281A 96EF      ADIW	R28,0x3F
    0281B 96EF      ADIW	R28,0x3F
    0281C 96EF      ADIW	R28,0x3F
    0281D 96EF      ADIW	R28,0x3F
    0281E 96EF      ADIW	R28,0x3F
    0281F 96A8      ADIW	R28,0x28
    02820 940E 4160 CALL	pop_xgsetF0FC
    02822 9622      ADIW	R28,2
    02823 9508      RET
_check:
  WScounter            --> R10
  tmp                  --> R12
    02824 940E 4171 CALL	push_xgset003C
    02826 9722      SBIW	R28,2
(0251) }
(0252) void check( void )
(0253) {
(0254)  unsigned char tmp;
(0255)  unsigned int WScounter;
(0256)  //检测风速
(0257)  //读计数器1 此步需严格按手册进行。
(0258)  tmp=SREG;
    02827 B6CF      IN	R12,0x3F
(0259)  CLI();
    02828 94F8      BCLR	7
(0260)  WScounter=TCNT1H*256+TCNT1L;
    02829 B52D      IN	R18,0x2D
    0282A 2733      CLR	R19
    0282B E000      LDI	R16,0
    0282C E011      LDI	R17,1
    0282D 940E 4107 CALL	empy16s
    0282F 0158      MOVW	R10,R16
    02830 B42C      IN	R2,0x2C
    02831 2433      CLR	R3
    02832 0CA2      ADD	R10,R2
    02833 1CB3      ADC	R11,R3
(0261)  SREG=tmp;
    02834 BECF      OUT	0x3F,R12
(0262)  SEI();
    02835 9478      BSET	7
(0263)  //计算风速
(0264)  Result.WindSpeed=WScounter/N_per_Second;
    02836 0185      MOVW	R16,R10
    02837 940E 42C5 CALL	uint2fp
    02839 0118      MOVW	R2,R16
    0283A 0129      MOVW	R4,R18
    0283B EB00      LDI	R16,0xB0
    0283C E010      LDI	R17,0
    0283D 940E 40F3 CALL	elpm32
    0283F 933A      ST	-Y,R19
    02840 932A      ST	-Y,R18
    02841 931A      ST	-Y,R17
    02842 930A      ST	-Y,R16
    02843 0181      MOVW	R16,R2
    02844 0192      MOVW	R18,R4
    02845 940E 42F2 CALL	fpdiv2
    02847 9310 05A4 STS	Result+52,R17
    02849 9300 05A3 STS	Result+51,R16
    0284B 9330 05A6 STS	Result+54,R19
    0284D 9320 05A5 STS	Result+53,R18
(0265)  //温度
(0266)  Result.Temperature=read_T_NUM(1);
    0284F E001      LDI	R16,1
    02850 940E 3F06 CALL	_read_T_NUM
    02852 9310 059A STS	Result+42,R17
    02854 9300 0599 STS	Result+41,R16
    02856 9330 059C STS	Result+44,R19
    02858 9320 059B STS	Result+43,R18
(0267)  //WCI风冷指数
(0268)   Result.WCI = 4.18 *(10*SquareRootFloat(Result.WindSpeed) + 10.45 -  Result.WindSpeed  ) *( 33 - Result.Temperature );
    0285A 9120 05A5 LDS	R18,Result+53
    0285C 9130 05A6 LDS	R19,Result+54
    0285E 9100 05A3 LDS	R16,Result+51
    02860 9110 05A4 LDS	R17,Result+52
    02862 D228      RCALL	_SquareRootFloat
    02863 0118      MOVW	R2,R16
    02864 0129      MOVW	R4,R18
    02865 EA0C      LDI	R16,0xAC
    02866 E010      LDI	R17,0
    02867 940E 40F3 CALL	elpm32
    02869 0138      MOVW	R6,R16
    0286A 0149      MOVW	R8,R18
    0286B EA08      LDI	R16,0xA8
    0286C E010      LDI	R17,0
    0286D 940E 40F3 CALL	elpm32
    0286F 925A      ST	-Y,R5
    02870 924A      ST	-Y,R4
    02871 923A      ST	-Y,R3
    02872 922A      ST	-Y,R2
    02873 940E 446C CALL	fpmule2
    02875 0118      MOVW	R2,R16
    02876 0129      MOVW	R4,R18
    02877 EA04      LDI	R16,0xA4
    02878 E010      LDI	R17,0
    02879 940E 40F3 CALL	elpm32
    0287B 933A      ST	-Y,R19
    0287C 932A      ST	-Y,R18
    0287D 931A      ST	-Y,R17
    0287E 930A      ST	-Y,R16
    0287F 0181      MOVW	R16,R2
    02880 0192      MOVW	R18,R4
    02881 940E 4294 CALL	fpadd2
    02883 EA83      LDI	R24,0xA3
    02884 E095      LDI	R25,5
    02885 939A      ST	-Y,R25
    02886 938A      ST	-Y,R24
    02887 940E 42AA CALL	fpsub1x
    02889 0183      MOVW	R16,R6
    0288A 0194      MOVW	R18,R8
    0288B 940E 446C CALL	fpmule2
    0288D 0118      MOVW	R2,R16
    0288E 0129      MOVW	R4,R18
    0288F EA00      LDI	R16,0xA0
    02890 E010      LDI	R17,0
    02891 940E 40F3 CALL	elpm32
    02893 E989      LDI	R24,0x99
    02894 E095      LDI	R25,5
    02895 939A      ST	-Y,R25
    02896 938A      ST	-Y,R24
    02897 940E 42AA CALL	fpsub1x
    02899 0181      MOVW	R16,R2
    0289A 0192      MOVW	R18,R4
    0289B 940E 446C CALL	fpmule2
    0289D 9310 05AD STS	Result+61,R17
    0289F 9300 05AC STS	Result+60,R16
    028A1 9330 05AF STS	Result+63,R19
    028A3 9320 05AE STS	Result+62,R18
(0269)  //ECT等价制冷温度
(0270)  Result.ECT = 33 - 0.01085 * Result.WCI;
    028A5 E90C      LDI	R16,0x9C
    028A6 E010      LDI	R17,0
    028A7 940E 40F3 CALL	elpm32
    028A9 0118      MOVW	R2,R16
    028AA 0129      MOVW	R4,R18
    028AB E908      LDI	R16,0x98
    028AC E010      LDI	R17,0
    028AD 940E 40F3 CALL	elpm32
    028AF EA8C      LDI	R24,0xAC
    028B0 E095      LDI	R25,5
    028B1 939A      ST	-Y,R25
    028B2 938A      ST	-Y,R24
    028B3 940E 4477 CALL	fpmule1x
    028B5 0181      MOVW	R16,R2
    028B6 0192      MOVW	R18,R4
    028B7 940E 429F CALL	fpsub2
    028B9 9310 05B7 STS	Result+71,R17
    028BB 9300 05B6 STS	Result+70,R16
    028BD 9330 05B9 STS	Result+73,R19
    028BF 9320 05B8 STS	Result+72,R18
(0271)  //TEQ 相当温度
(0272)  Result.Teq = Result.Temperature +( (Result.Temperature -36)/10 ) * Result.WindSpeed ;
    028C1 9040 059B LDS	R4,Result+43
    028C3 9050 059C LDS	R5,Result+44
    028C5 9020 0599 LDS	R2,Result+41
    028C7 9030 059A LDS	R3,Result+42
    028C9 0131      MOVW	R6,R2
    028CA 0142      MOVW	R8,R4
    028CB E904      LDI	R16,0x94
    028CC E010      LDI	R17,0
    028CD 940E 40F3 CALL	elpm32
    028CF 933A      ST	-Y,R19
    028D0 932A      ST	-Y,R18
    028D1 931A      ST	-Y,R17
    028D2 930A      ST	-Y,R16
    028D3 0183      MOVW	R16,R6
    028D4 0194      MOVW	R18,R8
    028D5 940E 429F CALL	fpsub2
    028D7 0138      MOVW	R6,R16
    028D8 0149      MOVW	R8,R18
    028D9 EA08      LDI	R16,0xA8
    028DA E010      LDI	R17,0
    028DB 940E 40F3 CALL	elpm32
    028DD 933A      ST	-Y,R19
    028DE 932A      ST	-Y,R18
    028DF 931A      ST	-Y,R17
    028E0 930A      ST	-Y,R16
    028E1 0183      MOVW	R16,R6
    028E2 0194      MOVW	R18,R8
    028E3 940E 42F2 CALL	fpdiv2
    028E5 EA83      LDI	R24,0xA3
    028E6 E095      LDI	R25,5
    028E7 939A      ST	-Y,R25
    028E8 938A      ST	-Y,R24
    028E9 940E 4477 CALL	fpmule1x
    028EB 0181      MOVW	R16,R2
    028EC 0192      MOVW	R18,R4
    028ED 940E 4294 CALL	fpadd2
    028EF 9310 05C1 STS	Result+81,R17
    028F1 9300 05C0 STS	Result+80,R16
    028F3 9330 05C3 STS	Result+83,R19
    028F5 9320 05C2 STS	Result+82,R18
(0273) //将数据转换成字符串
(0274)  
(0275) ftochr(Result.WindSpeed,Result.WSChar);
    028F7 EA87      LDI	R24,0xA7
    028F8 E095      LDI	R25,5
    028F9 8399      STD	Y+1,R25
    028FA 8388      ST	Y,R24
    028FB 9120 05A5 LDS	R18,Result+53
    028FD 9130 05A6 LDS	R19,Result+54
    028FF 9100 05A3 LDS	R16,Result+51
    02901 9110 05A4 LDS	R17,Result+52
    02903 D04E      RCALL	_ftochr
(0276) ftochr(Result.Temperature,Result.TempChar);
    02904 E98D      LDI	R24,0x9D
    02905 E095      LDI	R25,5
    02906 8399      STD	Y+1,R25
    02907 8388      ST	Y,R24
    02908 9120 059B LDS	R18,Result+43
    0290A 9130 059C LDS	R19,Result+44
    0290C 9100 0599 LDS	R16,Result+41
    0290E 9110 059A LDS	R17,Result+42
    02910 D041      RCALL	_ftochr
(0277) ftochr(Result.WCI,Result.WCIChar);
    02911 EB80      LDI	R24,0xB0
    02912 E095      LDI	R25,5
    02913 8399      STD	Y+1,R25
    02914 8388      ST	Y,R24
    02915 9120 05AE LDS	R18,Result+62
    02917 9130 05AF LDS	R19,Result+63
    02919 9100 05AC LDS	R16,Result+60
    0291B 9110 05AD LDS	R17,Result+61
    0291D D034      RCALL	_ftochr
(0278) ftochr(Result.ECT,Result.ECTChar);
    0291E EB8A      LDI	R24,0xBA
    0291F E095      LDI	R25,5
    02920 8399      STD	Y+1,R25
    02921 8388      ST	Y,R24
    02922 9120 05B8 LDS	R18,Result+72
    02924 9130 05B9 LDS	R19,Result+73
    02926 9100 05B6 LDS	R16,Result+70
    02928 9110 05B7 LDS	R17,Result+71
    0292A D027      RCALL	_ftochr
(0279) ftochr(Result.Teq,Result.TeqChar);
    0292B EC84      LDI	R24,0xC4
    0292C E095      LDI	R25,5
    0292D 8399      STD	Y+1,R25
    0292E 8388      ST	Y,R24
    0292F 9120 05C2 LDS	R18,Result+82
    02931 9130 05C3 LDS	R19,Result+83
    02933 9100 05C0 LDS	R16,Result+80
    02935 9110 05C1 LDS	R17,Result+81
    02937 D01A      RCALL	_ftochr
(0280) itoa(Result.IndexChar,Result.Index,10);
    02938 E08A      LDI	R24,0xA
    02939 E090      LDI	R25,0
    0293A 8399      STD	Y+1,R25
    0293B 8388      ST	Y,R24
    0293C 9120 057A LDS	R18,Result+10
    0293E 9130 057B LDS	R19,Result+11
    02940 E70E      LDI	R16,0x7E
    02941 E015      LDI	R17,5
    02942 940E 449D CALL	_itoa
(0281) Result.TempChar[6]='\0';
    02944 2422      CLR	R2
    02945 9220 05A3 STS	Result+51,R2
(0282) Result.WSChar[5]='\0';
    02947 9220 05AC STS	Result+60,R2
(0283) Result.WCIChar[6]='\0';
    02949 9220 05B6 STS	Result+70,R2
(0284) Result.ECTChar[6]='\0';
    0294B 9220 05C0 STS	Result+80,R2
(0285) Result.TeqChar[6]='\0';
    0294D 9220 05CA STS	Result+90,R2
(0286)  return ;
    0294F 9622      ADIW	R28,2
    02950 940C 414B JMP	pop_xgset003C
_ftochr:
  status               --> Y,+2
  j                    --> R12
  lenth                --> R20
  res                  --> R12
  i                    --> R10
  dest                 --> R14
  a                    --> Y,+12
    02952 940E 4026 CALL	push_arg4
    02954 940E 416D CALL	push_xgset30FC
    02956 9724      SBIW	R28,4
    02957 88E8      LDD	R14,Y+16
    02958 88F9      LDD	R15,Y+17
(0287) }
(0288) ////////////////////////////////////////////
(0289) //				字符串转换函数
(0290) //   浮点 到  字符串
(0291) ////////////////////////////////////////////
(0292) void ftochr(float a,char * dest){//float
(0293) char i=0,j=0,lenth;
(0294) int status;
(0295) char *res;
(0296)  res=ftoa(a,&status);  //float to ascii
    02959 01CE      MOVW	R24,R28
    0295A 9602      ADIW	R24,2
    0295B 8399      STD	Y+1,R25
    0295C 8388      ST	Y,R24
    0295D 850C      LDD	R16,Y+12
    0295E 851D      LDD	R17,Y+13
    0295F 852E      LDD	R18,Y+14
    02960 853F      LDD	R19,Y+15
    02961 940E 45C0 CALL	_ftoa
    02963 0168      MOVW	R12,R16
(0297) lenth=strlen(res);
    02964 940E 401A CALL	_strlen
    02966 2F40      MOV	R20,R16
(0298) 
(0299) for(i=0;i <lenth;i++) 
    02967 24AA      CLR	R10
    02968 C023      RJMP	0x298C
(0300)        {
(0301) 	   	dest[i]=res[i];
    02969 2DEA      MOV	R30,R10
    0296A 27FF      CLR	R31
    0296B 0DEC      ADD	R30,R12
    0296C 1DFD      ADC	R31,R13
    0296D 8020      LD	R2,Z
    0296E 2DEA      MOV	R30,R10
    0296F 27FF      CLR	R31
    02970 0DEE      ADD	R30,R14
    02971 1DFF      ADC	R31,R15
    02972 8220      ST	Z,R2
(0302) 
(0303) 		if( res[i]=='.'  ) 
    02973 2DEA      MOV	R30,R10
    02974 27FF      CLR	R31
    02975 0DEC      ADD	R30,R12
    02976 1DFD      ADC	R31,R13
    02977 8180      LD	R24,Z
    02978 328E      CPI	R24,0x2E
    02979 F489      BNE	0x298B
(0304) 			{
(0305) 				dest[i+1]=res[i+1];
    0297A 2DEA      MOV	R30,R10
    0297B 27FF      CLR	R31
    0297C 0DEC      ADD	R30,R12
    0297D 1DFD      ADC	R31,R13
    0297E 8021      LDD	R2,Z+1
    0297F 2DEA      MOV	R30,R10
    02980 27FF      CLR	R31
    02981 0DEE      ADD	R30,R14
    02982 1DFF      ADC	R31,R15
    02983 8221      STD	Z+1,R2
(0306) 					dest[i+2]='\0';
    02984 2DEA      MOV	R30,R10
    02985 27FF      CLR	R31
    02986 0DEE      ADD	R30,R14
    02987 1DFF      ADC	R31,R15
    02988 2422      CLR	R2
    02989 8222      STD	Z+2,R2
(0307) 						return ;    
    0298A C003      RJMP	0x298E
    0298B 94A3      INC	R10
    0298C 16A4      CP	R10,R20
    0298D F2D8      BCS	0x2969
    0298E 9624      ADIW	R28,4
    0298F 940E 4157 CALL	pop_xgset30FC
    02991 9624      ADIW	R28,4
    02992 9508      RET
_itochr:
  dest                 --> R10
  a                    --> R12
    02993 940E 4171 CALL	push_xgset003C
    02995 0159      MOVW	R10,R18
    02996 0168      MOVW	R12,R16
    02997 9722      SBIW	R28,2
(0308) 		    }
(0309)  
(0310)  		}
(0311) }
(0312) //////////////////////////////////////////////////////
(0313) //              整型数据变字符串
(0314) //    a  到  dest
(0315) ///////////////////////////////////////////////////////
(0316) void itochr(int a,char * dest){ //int to ascii
(0317) 	 itoa(dest,a,10); 
    02998 E08A      LDI	R24,0xA
    02999 E090      LDI	R25,0
    0299A 8399      STD	Y+1,R25
    0299B 8388      ST	Y,R24
    0299C 0196      MOVW	R18,R12
    0299D 0185      MOVW	R16,R10
    0299E 940E 449D CALL	_itoa
    029A0 9622      ADIW	R28,2
    029A1 940C 414B JMP	pop_xgset003C
_StructToChar:
  otherbyte            --> Y,+16
  ary                  --> Y,+0
  i                    --> R10
    029A3 92AA      ST	-Y,R10
    029A4 9768      SBIW	R28,0x18
(0318) }
(0319) //////////////////////////////////////////////////////
(0320) //                  结构体 变字符串
(0321) // 将目前存于结构体的数据转换到Temp_Char中。
(0322) ///////////////////////////////////////////////////////
(0323) void  StructToChar(void)
(0324) { 
(0325)   unsigned char i;
(0326)   char otherbyte[]="0\t0\t0\t0";
    029A5 EB80      LDI	R24,0xB0
    029A6 E091      LDI	R25,1
    029A7 01FE      MOVW	R30,R28
    029A8 9670      ADIW	R30,0x10
    029A9 E008      LDI	R16,0x8
    029AA E010      LDI	R17,0
    029AB 93FA      ST	-Y,R31
    029AC 93EA      ST	-Y,R30
    029AD 939A      ST	-Y,R25
    029AE 938A      ST	-Y,R24
    029AF 940E 4212 CALL	asgnblk
(0327)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    029B1 EB88      LDI	R24,0xB8
    029B2 E091      LDI	R25,1
    029B3 01FE      MOVW	R30,R28
    029B4 E100      LDI	R16,0x10
    029B5 E010      LDI	R17,0
    029B6 93FA      ST	-Y,R31
    029B7 93EA      ST	-Y,R30
    029B8 939A      ST	-Y,R25
    029B9 938A      ST	-Y,R24
    029BA 940E 4212 CALL	asgnblk
(0328)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0329) 				Result.TeqChar
(0330) 			   };  //指向数组首地址的指针
(0331)   //strcat(Temp_Char,Result.Name);
(0332)   for(i=0;i<=80;i++) TempChar[i]='\0';  //清空数组
    029BC 24AA      CLR	R10
    029BD C009      RJMP	0x29C7
    029BE E280      LDI	R24,0x20
    029BF E095      LDI	R25,5
    029C0 2DEA      MOV	R30,R10
    029C1 27FF      CLR	R31
    029C2 0FE8      ADD	R30,R24
    029C3 1FF9      ADC	R31,R25
    029C4 2422      CLR	R2
    029C5 8220      ST	Z,R2
    029C6 94A3      INC	R10
    029C7 E580      LDI	R24,0x50
    029C8 158A      CP	R24,R10
    029C9 F7A0      BCC	0x29BE
(0333)     for(i=0;i<=7;i++){
    029CA 24AA      CLR	R10
    029CB C014      RJMP	0x29E0
(0334) 		strcat(TempChar,ary[i]);  // 按顺序复制字符串
    029CC 01CE      MOVW	R24,R28
    029CD 2DEA      MOV	R30,R10
    029CE 27FF      CLR	R31
    029CF 0FEE      LSL	R30
    029D0 1FFF      ROL	R31
    029D1 0FE8      ADD	R30,R24
    029D2 1FF9      ADC	R31,R25
    029D3 8120      LD	R18,Z
    029D4 8131      LDD	R19,Z+1
    029D5 E200      LDI	R16,0x20
    029D6 E015      LDI	R17,5
    029D7 940E 400D CALL	_strcat
(0335) 		strcat(TempChar,tab);     // 字串结尾加上制表符
    029D9 E02F      LDI	R18,0xF
    029DA E031      LDI	R19,1
    029DB E200      LDI	R16,0x20
    029DC E015      LDI	R17,5
    029DD 940E 400D CALL	_strcat
    029DF 94A3      INC	R10
    029E0 E087      LDI	R24,7
    029E1 158A      CP	R24,R10
    029E2 F748      BCC	0x29CC
(0336)     }
(0337) 				 
(0338) 				 otherbyte[0]=otherbyte[0]+Result.WeiHai;
    029E3 9020 05CA LDS	R2,Result+90
    029E5 8838      LDD	R3,Y+16
    029E6 0C32      ADD	R3,R2
    029E7 8A38      STD	Y+16,R3
(0339) 				 otherbyte[2]=otherbyte[0]+Result.LowLabor;
    029E8 9020 05CB LDS	R2,Result+91
    029EA 0C32      ADD	R3,R2
    029EB 8A3A      STD	Y+18,R3
(0340) 				 otherbyte[4]=otherbyte[0]+Result.MidLabor;
    029EC 9020 05CC LDS	R2,Result+92
    029EE 8838      LDD	R3,Y+16
    029EF 0C32      ADD	R3,R2
    029F0 8A3C      STD	Y+20,R3
(0341) 				 otherbyte[6]=otherbyte[0]+Result.HighLabor;
    029F1 9020 05CD LDS	R2,Result+93
    029F3 8838      LDD	R3,Y+16
    029F4 0C32      ADD	R3,R2
    029F5 8A3E      STD	Y+22,R3
(0342)  
(0343)   strcat(TempChar,otherbyte);  
    029F6 019E      MOVW	R18,R28
    029F7 5F20      SUBI	R18,0xF0
    029F8 4F3F      SBCI	R19,0xFF
    029F9 E200      LDI	R16,0x20
    029FA E015      LDI	R17,5
    029FB 940E 400D CALL	_strcat
(0344)   strcat(TempChar,enter);  
    029FD E122      LDI	R18,0x12
    029FE E031      LDI	R19,1
    029FF E200      LDI	R16,0x20
    02A00 E015      LDI	R17,5
    02A01 940E 400D CALL	_strcat
(0345)   strcat(TempChar,"\0\0");
    02A03 ED2F      LDI	R18,0xDF
    02A04 E031      LDI	R19,1
    02A05 E200      LDI	R16,0x20
    02A06 E015      LDI	R17,5
    02A07 940E 400D CALL	_strcat
    02A09 9668      ADIW	R28,0x18
    02A0A 90A9      LD	R10,Y+
    02A0B 9508      RET
_CharToStruct:
  Temp_Char            --> Y,+16
  i                    --> R20
  ary                  --> Y,+0
  j                    --> R14
  p                    --> R10
  q                    --> R12
    02A0C 940E 416D CALL	push_xgset30FC
    02A0E 97EF      SBIW	R28,0x3F
    02A0F 97A1      SBIW	R28,0x21
(0346) }
(0347) 
(0348) //////////////////////////////////////////////////////
(0349) //               字符串  变  结构体
(0350) // 
(0351) ///////////////////////////////////////////////////////
(0352) void CharToStruct(void)
(0353) {
(0354)   unsigned char i=0,j=0;
    02A10 2744      CLR	R20
    02A11 24EE      CLR	R14
(0355)   unsigned char *p,*q;
(0356)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    02A12 EC88      LDI	R24,0xC8
    02A13 E091      LDI	R25,1
    02A14 01FE      MOVW	R30,R28
    02A15 E100      LDI	R16,0x10
    02A16 E010      LDI	R17,0
    02A17 93FA      ST	-Y,R31
    02A18 93EA      ST	-Y,R30
    02A19 939A      ST	-Y,R25
    02A1A 938A      ST	-Y,R24
    02A1B 940E 4212 CALL	asgnblk
(0357)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0358) 				Result.TeqChar
(0359) 			   };  //指向数组首地址的指针
(0360)   char Temp_Char[80];
(0361)     p=ary[j];
    02A1D 01CE      MOVW	R24,R28
    02A1E 2DEE      MOV	R30,R14
    02A1F 27FF      CLR	R31
    02A20 0FEE      LSL	R30
    02A21 1FFF      ROL	R31
    02A22 0FE8      ADD	R30,R24
    02A23 1FF9      ADC	R31,R25
    02A24 80A0      LD	R10,Z
    02A25 80B1      LDD	R11,Z+1
(0362) 	q=Temp_Char;
    02A26 01CE      MOVW	R24,R28
    02A27 9640      ADIW	R24,0x10
    02A28 016C      MOVW	R12,R24
    02A29 C01D      RJMP	0x2A47
(0363) 	while(1){
(0364)     if(*q =='\n') {*p='\0'; return;} ;
    02A2A 01F6      MOVW	R30,R12
    02A2B 8180      LD	R24,Z
    02A2C 308A      CPI	R24,0xA
    02A2D F421      BNE	0x2A32
    02A2E 2422      CLR	R2
    02A2F 01F5      MOVW	R30,R10
    02A30 8220      ST	Z,R2
    02A31 C016      RJMP	0x2A48
(0365) 	if(*q =='\t') {j++;p=ary[j];i=0;}
    02A32 01F6      MOVW	R30,R12
    02A33 8180      LD	R24,Z
    02A34 3089      CPI	R24,0x9
    02A35 F459      BNE	0x2A41
    02A36 94E3      INC	R14
    02A37 01CE      MOVW	R24,R28
    02A38 2DEE      MOV	R30,R14
    02A39 27FF      CLR	R31
    02A3A 0FEE      LSL	R30
    02A3B 1FFF      ROL	R31
    02A3C 0FE8      ADD	R30,R24
    02A3D 1FF9      ADC	R31,R25
    02A3E 80A0      LD	R10,Z
    02A3F 80B1      LDD	R11,Z+1
    02A40 2744      CLR	R20
(0366)     *p++=*q++;
    02A41 01F6      MOVW	R30,R12
    02A42 01D5      MOVW	R26,R10
    02A43 9001      LD	R0,Z+
    02A44 016F      MOVW	R12,R30
    02A45 920D      ST	X+,R0
    02A46 015D      MOVW	R10,R26
    02A47 CFE2      RJMP	0x2A2A
    02A48 96EF      ADIW	R28,0x3F
    02A49 96A1      ADIW	R28,0x21
    02A4A 940C 4157 JMP	pop_xgset30FC
_get_name:
  i                    --> R20
  filenamep            --> R16
    02A4C 940E 4180 CALL	push_xgsetF000
(0367) 	}
(0368)   }
(0369)  
(0370)  ////////////////////////////////////////////
(0371) //				根据当前日期获取文件名
(0372) //   
(0373) ////////////////////////////////////////////
(0374) char *get_name( char filenamep[] ){     
(0375) 	  unsigned char i=0;
(0376)  	  for(i=0;i<6;i++) {
    02A4E 2744      CLR	R20
    02A4F C00D      RJMP	0x2A5D
(0377) 	  				    *(filenamep+i)=Result.Date[i];
    02A50 E886      LDI	R24,0x86
    02A51 E095      LDI	R25,5
    02A52 2FE4      MOV	R30,R20
    02A53 27FF      CLR	R31
    02A54 0FE8      ADD	R30,R24
    02A55 1FF9      ADC	R31,R25
    02A56 8020      LD	R2,Z
    02A57 2FE4      MOV	R30,R20
    02A58 27FF      CLR	R31
    02A59 0FE0      ADD	R30,R16
    02A5A 1FF1      ADC	R31,R17
    02A5B 8220      ST	Z,R2
    02A5C 9543      INC	R20
    02A5D 3046      CPI	R20,6
    02A5E F388      BCS	0x2A50
(0378) 	  				   } 
(0379) 	 	*(filenamep+(i++))='.';
    02A5F 2E24      MOV	R2,R20
    02A60 2433      CLR	R3
    02A61 5F4F      SUBI	R20,0xFF
    02A62 2DE2      MOV	R30,R2
    02A63 27FF      CLR	R31
    02A64 0FE0      ADD	R30,R16
    02A65 1FF1      ADC	R31,R17
    02A66 E28E      LDI	R24,0x2E
    02A67 8380      ST	Z,R24
(0380) 		*(filenamep+(i++))='x';
    02A68 2E24      MOV	R2,R20
    02A69 2433      CLR	R3
    02A6A 5F4F      SUBI	R20,0xFF
    02A6B 2DE2      MOV	R30,R2
    02A6C 27FF      CLR	R31
    02A6D 0FE0      ADD	R30,R16
    02A6E 1FF1      ADC	R31,R17
    02A6F E788      LDI	R24,0x78
    02A70 8380      ST	Z,R24
(0381) 		*(filenamep+(i++))='l';
    02A71 2F64      MOV	R22,R20
    02A72 2777      CLR	R23
    02A73 5F4F      SUBI	R20,0xFF
    02A74 2FE6      MOV	R30,R22
    02A75 27FF      CLR	R31
    02A76 0FE0      ADD	R30,R16
    02A77 1FF1      ADC	R31,R17
    02A78 E68C      LDI	R24,0x6C
    02A79 8380      ST	Z,R24
(0382) 		*(filenamep+(i++))='s';
    02A7A 2F64      MOV	R22,R20
    02A7B 2777      CLR	R23
    02A7C 5F4F      SUBI	R20,0xFF
    02A7D 2FE6      MOV	R30,R22
    02A7E 27FF      CLR	R31
    02A7F 0FE0      ADD	R30,R16
    02A80 1FF1      ADC	R31,R17
    02A81 E783      LDI	R24,0x73
    02A82 8380      ST	Z,R24
(0383) 		*(filenamep+(i))='\0';
    02A83 2FE4      MOV	R30,R20
    02A84 27FF      CLR	R31
    02A85 0FE0      ADD	R30,R16
    02A86 1FF1      ADC	R31,R17
    02A87 2422      CLR	R2
    02A88 8220      ST	Z,R2
(0384) 					   
(0385)       return filenamep;
    02A89 940C 4185 JMP	pop_xgsetF000
_SquareRootFloat:
  f                    --> Y,+12
  x                    --> Y,+8
  i                    --> Y,+4
  y                    --> Y,+0
  number               --> Y,+20
    02A8B 940E 4026 CALL	push_arg4
    02A8D 940E 4180 CALL	push_xgsetF000
    02A8F 9760      SBIW	R28,0x10
(0386) } 
(0387) float SquareRootFloat(float number)
(0388) {
(0389)     long i;
(0390)     float x, y;
(0391)     const float f = 1.5F;
    02A90 E900      LDI	R16,0x90
    02A91 E010      LDI	R17,0
    02A92 940E 40F3 CALL	elpm32
    02A94 870C      STD	Y+12,R16
    02A95 871D      STD	Y+13,R17
    02A96 872E      STD	Y+14,R18
    02A97 873F      STD	Y+15,R19
(0392)     x = number * 0.5F;
    02A98 E80C      LDI	R16,0x8C
    02A99 E010      LDI	R17,0
    02A9A 940E 40F3 CALL	elpm32
    02A9C 01CE      MOVW	R24,R28
    02A9D 9644      ADIW	R24,0x14
    02A9E 939A      ST	-Y,R25
    02A9F 938A      ST	-Y,R24
    02AA0 940E 4462 CALL	fpmule1
    02AA2 8708      STD	Y+8,R16
    02AA3 8719      STD	Y+9,R17
    02AA4 872A      STD	Y+10,R18
    02AA5 873B      STD	Y+11,R19
(0393)     y  = number;
    02AA6 882C      LDD	R2,Y+20
    02AA7 883D      LDD	R3,Y+21
    02AA8 884E      LDD	R4,Y+22
    02AA9 885F      LDD	R5,Y+23
    02AAA 8228      ST	Y,R2
    02AAB 8239      STD	Y+1,R3
    02AAC 824A      STD	Y+2,R4
    02AAD 825B      STD	Y+3,R5
(0394)     i  = * ( long * ) &y;
    02AAE 01FE      MOVW	R30,R28
    02AAF 8020      LD	R2,Z
    02AB0 8031      LDD	R3,Z+1
    02AB1 8042      LDD	R4,Z+2
    02AB2 8053      LDD	R5,Z+3
    02AB3 822C      STD	Y+4,R2
    02AB4 823D      STD	Y+5,R3
    02AB5 824E      STD	Y+6,R4
    02AB6 825F      STD	Y+7,R5
(0395)     i  = 0x5f3759df - ( i >> 1 );  //卡马克
    02AB7 802C      LDD	R2,Y+4
    02AB8 803D      LDD	R3,Y+5
    02AB9 804E      LDD	R4,Y+6
    02ABA 805F      LDD	R5,Y+7
    02ABB 9455      ASR	R5
    02ABC 9447      ROR	R4
    02ABD 9437      ROR	R3
    02ABE 9427      ROR	R2
    02ABF ED4F      LDI	R20,0xDF
    02AC0 E559      LDI	R21,0x59
    02AC1 E367      LDI	R22,0x37
    02AC2 E57F      LDI	R23,0x5F
    02AC3 1942      SUB	R20,R2
    02AC4 0953      SBC	R21,R3
    02AC5 0964      SBC	R22,R4
    02AC6 0975      SBC	R23,R5
    02AC7 834C      STD	Y+4,R20
    02AC8 835D      STD	Y+5,R21
    02AC9 836E      STD	Y+6,R22
    02ACA 837F      STD	Y+7,R23
(0396)   //i  = 0x5f375a86 - ( i >> 1 );  //Lomont
(0397)     y  = * ( float * ) &i;
    02ACB 01FE      MOVW	R30,R28
    02ACC 9634      ADIW	R30,4
    02ACD 8020      LD	R2,Z
    02ACE 8031      LDD	R3,Z+1
    02ACF 8042      LDD	R4,Z+2
    02AD0 8053      LDD	R5,Z+3
    02AD1 8228      ST	Y,R2
    02AD2 8239      STD	Y+1,R3
    02AD3 824A      STD	Y+2,R4
    02AD4 825B      STD	Y+3,R5
(0398)     y  = y * ( f - ( x * y * y ) );
    02AD5 8028      LD	R2,Y
    02AD6 8039      LDD	R3,Y+1
    02AD7 804A      LDD	R4,Y+2
    02AD8 805B      LDD	R5,Y+3
    02AD9 846C      LDD	R6,Y+12
    02ADA 847D      LDD	R7,Y+13
    02ADB 848E      LDD	R8,Y+14
    02ADC 849F      LDD	R9,Y+15
    02ADD 8508      LDD	R16,Y+8
    02ADE 8519      LDD	R17,Y+9
    02ADF 852A      LDD	R18,Y+10
    02AE0 853B      LDD	R19,Y+11
    02AE1 01CE      MOVW	R24,R28
    02AE2 939A      ST	-Y,R25
    02AE3 938A      ST	-Y,R24
    02AE4 940E 4462 CALL	fpmule1
    02AE6 01CE      MOVW	R24,R28
    02AE7 939A      ST	-Y,R25
    02AE8 938A      ST	-Y,R24
    02AE9 940E 4477 CALL	fpmule1x
    02AEB 0183      MOVW	R16,R6
    02AEC 0194      MOVW	R18,R8
    02AED 940E 42B7 CALL	fpsub2x
    02AEF 0181      MOVW	R16,R2
    02AF0 0192      MOVW	R18,R4
    02AF1 940E 446C CALL	fpmule2
    02AF3 8308      ST	Y,R16
    02AF4 8319      STD	Y+1,R17
    02AF5 832A      STD	Y+2,R18
    02AF6 833B      STD	Y+3,R19
(0399)     y  = y * ( f - ( x * y * y ) );
    02AF7 8028      LD	R2,Y
    02AF8 8039      LDD	R3,Y+1
    02AF9 804A      LDD	R4,Y+2
    02AFA 805B      LDD	R5,Y+3
    02AFB 846C      LDD	R6,Y+12
    02AFC 847D      LDD	R7,Y+13
    02AFD 848E      LDD	R8,Y+14
    02AFE 849F      LDD	R9,Y+15
    02AFF 8508      LDD	R16,Y+8
    02B00 8519      LDD	R17,Y+9
    02B01 852A      LDD	R18,Y+10
    02B02 853B      LDD	R19,Y+11
    02B03 01CE      MOVW	R24,R28
    02B04 939A      ST	-Y,R25
    02B05 938A      ST	-Y,R24
    02B06 940E 4462 CALL	fpmule1
    02B08 01CE      MOVW	R24,R28
    02B09 939A      ST	-Y,R25
    02B0A 938A      ST	-Y,R24
    02B0B 940E 4477 CALL	fpmule1x
    02B0D 0183      MOVW	R16,R6
    02B0E 0194      MOVW	R18,R8
    02B0F 940E 42B7 CALL	fpsub2x
    02B11 0181      MOVW	R16,R2
    02B12 0192      MOVW	R18,R4
    02B13 940E 446C CALL	fpmule2
    02B15 8308      ST	Y,R16
    02B16 8319      STD	Y+1,R17
    02B17 832A      STD	Y+2,R18
    02B18 833B      STD	Y+3,R19
(0400)     return number * y;
    02B19 890C      LDD	R16,Y+20
    02B1A 891D      LDD	R17,Y+21
    02B1B 892E      LDD	R18,Y+22
    02B1C 893F      LDD	R19,Y+23
    02B1D 01CE      MOVW	R24,R28
    02B1E 939A      ST	-Y,R25
    02B1F 938A      ST	-Y,R24
    02B20 940E 4462 CALL	fpmule1
    02B22 9660      ADIW	R28,0x10
    02B23 940E 4185 CALL	pop_xgsetF000
    02B25 9624      ADIW	R28,4
    02B26 9508      RET
_debug:
  str2                 --> Y,+0
  val                  --> R10
  str                  --> R12
    02B27 940E 4171 CALL	push_xgset003C
    02B29 2EA2      MOV	R10,R18
    02B2A 0168      MOVW	R12,R16
    02B2B 9724      SBIW	R28,4
(0401) } 
(0402) //
(0403) //###############################################################//
(0404) //debug
(0405) void debug(UINT8 *str,UINT8 val)
(0406) {
(0407)  UINT8 str2[4]={0,0,0,0};
    02B2C ED88      LDI	R24,0xD8
    02B2D E091      LDI	R25,1
    02B2E 01FE      MOVW	R30,R28
    02B2F E004      LDI	R16,4
    02B30 E010      LDI	R17,0
    02B31 93FA      ST	-Y,R31
    02B32 93EA      ST	-Y,R30
    02B33 939A      ST	-Y,R25
    02B34 938A      ST	-Y,R24
    02B35 940E 4212 CALL	asgnblk
(0408)  str=str;
(0409)  val=val;
(0410)  #ifdef _UARTDEBUG
(0411)  PrintString("\r\n");
    02B37 ED0C      LDI	R16,0xDC
    02B38 E011      LDI	R17,1
    02B39 940E 37FC CALL	_PrintString
(0412)  PrintString(str);
    02B3B 0186      MOVW	R16,R12
    02B3C 940E 37FC CALL	_PrintString
(0413)  PrintChar(val);
    02B3E 2D0A      MOV	R16,R10
    02B3F 940E 3966 CALL	_PrintChar
    02B41 9624      ADIW	R28,4
    02B42 940C 414B JMP	pop_xgset003C
_SD_Write_cmd:
  k                    --> R22
  temp                 --> R20
  p                    --> R20
    02B44 940E 4180 CALL	push_xgsetF000
    02B46 01A8      MOVW	R20,R16
FILE: D:\LQD\software\master\software_src\sd.c
(0001) //*****************************************************************************//
(0002) //*								数码相框
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SD卡控制
(0006) //*修改者：  桃子
(0007) //*****************************************************************************//
(0008) #include "sd.h"
(0009) 
(0010) //****************************************************************
(0011) //*隶属模块：SD卡控制
(0012) //*函数功能：写6字节数据
(0013) //****************************************************************
(0014) UINT8 SD_Write_cmd(UINT8 *p)
(0015) {	
(0016) 	UINT16 temp,k=0;
    02B47 2766      CLR	R22
    02B48 2777      CLR	R23
(0017) 	SD_CS_DIS();//禁止SPI
    02B49 9AC0      SBI	0x18,0
(0018) 	SPI_Read();//空读一字节
    02B4A 940E 3994 CALL	_SPI_Read
(0019) 	SD_CS_EN();//使能SPI
    02B4C 98C0      CBI	0x18,0
(0020) 
(0021) 	SPI_Write(p[0]);
    02B4D 01FA      MOVW	R30,R20
    02B4E 8100      LD	R16,Z
    02B4F 940E 3990 CALL	_SPI_Write
(0022) 	SPI_Write(p[1]);
    02B51 01FA      MOVW	R30,R20
    02B52 8101      LDD	R16,Z+1
    02B53 940E 3990 CALL	_SPI_Write
(0023) 	SPI_Write(p[2]);
    02B55 01FA      MOVW	R30,R20
    02B56 8102      LDD	R16,Z+2
    02B57 940E 3990 CALL	_SPI_Write
(0024) 	SPI_Write(p[3]);
    02B59 01FA      MOVW	R30,R20
    02B5A 8103      LDD	R16,Z+3
    02B5B 940E 3990 CALL	_SPI_Write
(0025) 	SPI_Write(p[4]);
    02B5D 01FA      MOVW	R30,R20
    02B5E 8104      LDD	R16,Z+4
    02B5F 940E 3990 CALL	_SPI_Write
(0026) 	SPI_Write(p[5]);
    02B61 01FA      MOVW	R30,R20
    02B62 8105      LDD	R16,Z+5
    02B63 940E 3990 CALL	_SPI_Write
(0027) 
(0028) 	do 
(0029)  	{  
(0030)   		temp = SPI_Read();//一直读，直到读到的不是0xff或超时
    02B65 940E 3994 CALL	_SPI_Read
    02B67 2F40      MOV	R20,R16
    02B68 2755      CLR	R21
(0031)  		k++;
    02B69 5F6F      SUBI	R22,0xFF
    02B6A 4F7F      SBCI	R23,0xFF
(0032)  	}while((temp==0xff)&&(k<TRY_TIME)); 
    02B6B 3F4F      CPI	R20,0xFF
    02B6C E0E0      LDI	R30,0
    02B6D 075E      CPC	R21,R30
    02B6E F421      BNE	0x2B73
    02B6F 3164      CPI	R22,0x14
    02B70 E0E0      LDI	R30,0
    02B71 077E      CPC	R23,R30
    02B72 F390      BCS	0x2B65
(0033) 
(0034) 	return temp;
    02B73 2F04      MOV	R16,R20
    02B74 940C 4185 JMP	pop_xgsetF000
_SD_Init:
  pcmd                 --> Y,+0
  temp                 --> R22
  time                 --> R20
    02B76 940E 418A CALL	push_xgsetF00C
    02B78 9726      SBIW	R28,6
(0035) }
(0036) //****************************************************************
(0037) //*隶属模块：SD卡控制
(0038) //*函数功能：初始化
(0039) //****************************************************************
(0040) UINT8 SD_Init(void)	
(0041) {  
(0042) 	UINT8 time=0,temp=0;
    02B79 2744      CLR	R20
    02B7A 2766      CLR	R22
(0043) 	UINT8 pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; //命令0的字节序列
    02B7B E48A      LDI	R24,0x4A
    02B7C E092      LDI	R25,2
    02B7D 01FE      MOVW	R30,R28
    02B7E E006      LDI	R16,6
    02B7F E010      LDI	R17,0
    02B80 93FA      ST	-Y,R31
    02B81 93EA      ST	-Y,R30
    02B82 939A      ST	-Y,R25
    02B83 938A      ST	-Y,R24
    02B84 940E 4212 CALL	asgnblk
(0044) 	if(SD_DET()==0) return 0x02; //no disk
    02B86 B181      IN	R24,0x01
    02B87 9586      LSR	R24
    02B88 9586      LSR	R24
    02B89 9586      LSR	R24
    02B8A 9586      LSR	R24
    02B8B 9586      LSR	R24
    02B8C 7081      ANDI	R24,1
    02B8D F421      BNE	0x2B92
    02B8E E081      LDI	R24,1
    02B8F E090      LDI	R25,0
    02B90 015C      MOVW	R10,R24
    02B91 C002      RJMP	0x2B94
    02B92 24AA      CLR	R10
    02B93 24BB      CLR	R11
    02B94 20AA      TST	R10
    02B95 F421      BNE	0x2B9A
    02B96 20BB      TST	R11
    02B97 F411      BNE	0x2B9A
    02B98 E002      LDI	R16,2
    02B99 C039      RJMP	0x2BD3
(0045) 	SD_PORT |= (1<<SD_CS);
    02B9A 9AC0      SBI	0x18,0
(0046) 	SD_DDR |= (1<<SD_CS);
    02B9B 9AB8      SBI	0x17,0
(0047) 
(0048) 	SPI_IO_Init();
    02B9C 940E 3986 CALL	_SPI_IO_Init
(0049) 	SPI_Low();
    02B9E E582      LDI	R24,0x52
    02B9F B98D      OUT	0x0D,R24
    02BA0 B18E      IN	R24,0x0E
    02BA1 7F8F      ANDI	R24,0xFF
    02BA2 B98E      OUT	0x0E,R24
(0050) 
(0051) 	SD_CS_DIS();  //关闭片选 
    02BA3 9AC0      SBI	0x18,0
(0052) 	for(time=0;time<10;time++) //初始时，首先要发送最少74个时钟信号，这是必须的！！！
    02BA4 2744      CLR	R20
    02BA5 C003      RJMP	0x2BA9
(0053) 	{
(0054)   		SPI_Read(); 
    02BA6 940E 3994 CALL	_SPI_Read
    02BA8 9543      INC	R20
    02BA9 304A      CPI	R20,0xA
    02BAA F3D8      BCS	0x2BA6
(0055) 	}
(0056) 	SD_CS_EN(); //打开片选
    02BAB 98C0      CBI	0x18,0
(0057) 	time = 0;
    02BAC 2744      CLR	R20
(0058) 	do
(0059) 	{ 
(0060) 		temp=SD_Write_cmd(pcmd);//写入CMD0
    02BAD 018E      MOVW	R16,R28
    02BAE DF95      RCALL	_SD_Write_cmd
    02BAF 2F60      MOV	R22,R16
(0061) 	 	time++;
    02BB0 9543      INC	R20
(0062) 	 	if(time==TRY_TIME) 
    02BB1 3144      CPI	R20,0x14
    02BB2 F419      BNE	0x2BB6
(0063) 	 	{ 
(0064) 	  		SD_CS_DIS(); //关闭片选
    02BB3 9AC0      SBI	0x18,0
(0065) 	  		return(INIT_CMD0_ERROR);//CMD0写入失败
    02BB4 E001      LDI	R16,1
    02BB5 C01D      RJMP	0x2BD3
(0066) 	 	}
(0067) 	 }while(temp!=0x01);
    02BB6 3061      CPI	R22,1
    02BB7 F7A9      BNE	0x2BAD
(0068) 
(0069) 	SD_CS_DIS(); //关闭片选
    02BB8 9AC0      SBI	0x18,0
(0070) 	SPI_Read(); //按照SD卡的操作时序在这里补8个时钟 
    02BB9 940E 3994 CALL	_SPI_Read
(0071) 	SD_CS_EN(); //打开片选
    02BBB 98C0      CBI	0x18,0
(0072) 
(0073) 	pcmd[0]=0x41,pcmd[5]=0xff;
    02BBC E481      LDI	R24,0x41
    02BBD 8388      ST	Y,R24
    02BBE EF8F      LDI	R24,0xFF
    02BBF 838D      STD	Y+5,R24
(0074) 	time = 0;
    02BC0 2744      CLR	R20
(0075) 	do
(0076) 	{ 
(0077) 		temp=SD_Write_cmd(pcmd);
    02BC1 018E      MOVW	R16,R28
    02BC2 DF81      RCALL	_SD_Write_cmd
    02BC3 2F60      MOV	R22,R16
(0078) 		time++;
    02BC4 9543      INC	R20
(0079) 		if(time==TRY_TIME) 
    02BC5 3144      CPI	R20,0x14
    02BC6 F419      BNE	0x2BCA
(0080) 		{ 
(0081) 		 	SD_CS_DIS(); //关闭片选
    02BC7 9AC0      SBI	0x18,0
(0082) 			 return(INIT_CMD1_ERROR);//CMD1写入失败
    02BC8 E002      LDI	R16,2
    02BC9 C009      RJMP	0x2BD3
(0083) 		 }
(0084) 	 }while(temp!=0);
    02BCA 2366      TST	R22
    02BCB F7A9      BNE	0x2BC1
(0085)   
(0086) 	 SPI_High();  
    02BCC E580      LDI	R24,0x50
    02BCD B98D      OUT	0x0D,R24
    02BCE 9A70      SBI	0x0E,0
(0087) 	 SD_CS_DIS();  //关闭片选 
    02BCF 9AC0      SBI	0x18,0
(0088) 	 SPI_Read(); //按照SD卡的操作时序在这里补8个时钟
    02BD0 940E 3994 CALL	_SPI_Read
(0089) 	 return SD_TURE; //返回0,说明初始化操作成功
    02BD2 2700      CLR	R16
    02BD3 9626      ADIW	R28,6
    02BD4 940C 4191 JMP	pop_xgsetF00C
_SD_Write_Sector:
  pcmd                 --> Y,+0
  time                 --> R12
  temp                 --> R20
  i                    --> R22
  buffer               --> R10
  addr                 --> Y,+14
    02BD6 940E 4026 CALL	push_arg4
    02BD8 940E 41A6 CALL	push_xgsetF03C
    02BDA 9726      SBIW	R28,6
    02BDB 88AA      LDD	R10,Y+18
    02BDC 88BB      LDD	R11,Y+19
(0090) } 
(0091) //****************************************************************
(0092) //*隶属模块：SD卡控制
(0093) //*函数功能：写512字节数据（一扇区字节）
(0094) //****************************************************************
(0095) UINT16 SD_Write_Sector(UINT32 addr,UINT8 *buffer)
(0096) {  
(0097) 	UINT8 temp=0,time=0;
    02BDD 2744      CLR	R20
    02BDE 24CC      CLR	R12
(0098) 	UINT16 i=0;
    02BDF 2766      CLR	R22
    02BE0 2777      CLR	R23
(0099) 	UINT8 pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //向SD卡中单个块（512字节，一个扇区）写入数据，用CMD24
    02BE1 E580      LDI	R24,0x50
    02BE2 E092      LDI	R25,2
    02BE3 01FE      MOVW	R30,R28
    02BE4 E006      LDI	R16,6
    02BE5 E010      LDI	R17,0
    02BE6 93FA      ST	-Y,R31
    02BE7 93EA      ST	-Y,R30
    02BE8 939A      ST	-Y,R25
    02BE9 938A      ST	-Y,R24
    02BEA 940E 4212 CALL	asgnblk
(0100) 
(0101) 	 addr<<=9; //将块地址（扇区地址）转为字节地址 ［这里就限制了SD卡的最大容量为4G］
    02BEC E089      LDI	R24,0x9
    02BED E090      LDI	R25,0
    02BEE 850E      LDD	R16,Y+14
    02BEF 851F      LDD	R17,Y+15
    02BF0 8928      LDD	R18,Y+16
    02BF1 8939      LDD	R19,Y+17
    02BF2 938A      ST	-Y,R24
    02BF3 940E 41ED CALL	lsl32
    02BF5 870E      STD	Y+14,R16
    02BF6 871F      STD	Y+15,R17
    02BF7 8B28      STD	Y+16,R18
    02BF8 8B39      STD	Y+17,R19
(0102) 
(0103) 	 pcmd[1]=(addr>>24); //将字节地址写入到CMD24字节序列中
    02BF9 E188      LDI	R24,0x18
    02BFA E090      LDI	R25,0
    02BFB 850E      LDD	R16,Y+14
    02BFC 851F      LDD	R17,Y+15
    02BFD 8928      LDD	R18,Y+16
    02BFE 8939      LDD	R19,Y+17
    02BFF 938A      ST	-Y,R24
    02C00 940E 4206 CALL	lsr32
    02C02 8309      STD	Y+1,R16
(0104) 	 pcmd[2]=(addr>>16);
    02C03 842E      LDD	R2,Y+14
    02C04 843F      LDD	R3,Y+15
    02C05 8848      LDD	R4,Y+16
    02C06 8859      LDD	R5,Y+17
    02C07 0112      MOVW	R2,R4
    02C08 2444      CLR	R4
    02C09 2455      CLR	R5
    02C0A 822A      STD	Y+2,R2
(0105) 	 pcmd[3]=(addr>>8);
    02C0B E088      LDI	R24,0x8
    02C0C E090      LDI	R25,0
    02C0D 850E      LDD	R16,Y+14
    02C0E 851F      LDD	R17,Y+15
    02C0F 8928      LDD	R18,Y+16
    02C10 8939      LDD	R19,Y+17
    02C11 938A      ST	-Y,R24
    02C12 940E 4206 CALL	lsr32
    02C14 830B      STD	Y+3,R16
(0106) 	// pcmd[4]=offset;	
(0107) 	 SD_CS_EN();//打开SD卡片选
    02C15 98C0      CBI	0x18,0
(0108) 
(0109) 	 do
(0110) 	 {  
(0111) 		temp=SD_Write_cmd(pcmd);
    02C16 018E      MOVW	R16,R28
    02C17 DF2C      RCALL	_SD_Write_cmd
    02C18 2F40      MOV	R20,R16
(0112)   		time++;
    02C19 94C3      INC	R12
(0113)   		if(time==TRY_TIME) 
    02C1A 2D8C      MOV	R24,R12
    02C1B 3184      CPI	R24,0x14
    02C1C F419      BNE	0x2C20
(0114)   		{ 
(0115)    			SD_CS_DIS(); //关闭片选
    02C1D 9AC0      SBI	0x18,0
(0116)    			return(temp); //命令写入失败
    02C1E 2711      CLR	R17
    02C1F C037      RJMP	0x2C57
(0117)   		}
(0118) 	}while(temp!=0); 
    02C20 2344      TST	R20
    02C21 F7A1      BNE	0x2C16
(0119) 
(0120) 	for(i=0;i<100;i++) //这里要插入若干时钟信号
    02C22 2766      CLR	R22
    02C23 2777      CLR	R23
    02C24 C004      RJMP	0x2C29
(0121)   		SPI_Read();
    02C25 940E 3994 CALL	_SPI_Read
    02C27 5F6F      SUBI	R22,0xFF
    02C28 4F7F      SBCI	R23,0xFF
    02C29 3664      CPI	R22,0x64
    02C2A E0E0      LDI	R30,0
    02C2B 077E      CPC	R23,R30
    02C2C F3C0      BCS	0x2C25
(0122) 	
(0123) 	SPI_Write(0xfe);//写入开始字节 0xfe，后面就是要写入的512个字节的数据	
    02C2D EF0E      LDI	R16,0xFE
    02C2E 940E 3990 CALL	_SPI_Write
(0124) 	
(0125) 	for(i=0;i<512;i++) //将缓冲区中要写入的512个字节写入SD卡
    02C30 2766      CLR	R22
    02C31 2777      CLR	R23
    02C32 C007      RJMP	0x2C3A
(0126) 		SPI_Write(*buffer++);
    02C33 01F5      MOVW	R30,R10
    02C34 9101      LD	R16,Z+
    02C35 015F      MOVW	R10,R30
    02C36 940E 3990 CALL	_SPI_Write
    02C38 5F6F      SUBI	R22,0xFF
    02C39 4F7F      SBCI	R23,0xFF
    02C3A 3060      CPI	R22,0
    02C3B E0E2      LDI	R30,2
    02C3C 077E      CPC	R23,R30
    02C3D F3A8      BCS	0x2C33
(0127)   
(0128) 	SPI_Read(); 
    02C3E 940E 3994 CALL	_SPI_Read
(0129) 	SPI_Read(); //两个字节的CRC校验码，不用关心
    02C40 940E 3994 CALL	_SPI_Read
(0130)    
(0131)     
(0132) 	temp=SPI_Read();   //读取返回值
    02C42 940E 3994 CALL	_SPI_Read
    02C44 2F40      MOV	R20,R16
(0133) 	if((temp&0x1F)!=0x05) //如果返回值是 XXX00101说明数据已经被SD卡接受了
    02C45 2F84      MOV	R24,R20
    02C46 718F      ANDI	R24,0x1F
    02C47 3085      CPI	R24,5
    02C48 F021      BEQ	0x2C4D
(0134) 	{
(0135)  		SD_CS_DIS();
    02C49 9AC0      SBI	0x18,0
(0136)  		return(WRITE_BLOCK_ERROR); //写块数据失败
    02C4A E003      LDI	R16,3
    02C4B E010      LDI	R17,0
    02C4C C00A      RJMP	0x2C57
(0137) 	}
(0138)  
(0139) 	while(SPI_Read()!=0xff);//等到SD卡不忙（数据被接受以后，SD卡要将这些数据写入到自身的FLASH中，需要一个时间）
    02C4D 940E 3994 CALL	_SPI_Read
    02C4F 2F40      MOV	R20,R16
    02C50 3F0F      CPI	R16,0xFF
    02C51 F7D9      BNE	0x2C4D
(0140) 						    //忙时，读回来的值为0x00,不忙时，为0xff
(0141) 
(0142) 	SD_CS_DIS(); //关闭片选
    02C52 9AC0      SBI	0x18,0
(0143) 
(0144) 	SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02C53 940E 3994 CALL	_SPI_Read
(0145) 	return SD_TURE;		 //返回0,说明写扇区操作成功
    02C55 2700      CLR	R16
    02C56 2711      CLR	R17
    02C57 9626      ADIW	R28,6
    02C58 940E 41AF CALL	pop_xgsetF03C
    02C5A 9624      ADIW	R28,4
    02C5B 9508      RET
_SD_Read_Sector:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  buffer               --> R10
  addr                 --> Y,+14
    02C5C 940E 4026 CALL	push_arg4
    02C5E 940E 41A6 CALL	push_xgsetF03C
    02C60 9726      SBIW	R28,6
    02C61 88AA      LDD	R10,Y+18
    02C62 88BB      LDD	R11,Y+19
(0146) } 
(0147) //****************************************************************
(0148) //*隶属模块：SD卡控制
(0149) //*函数功能：读512字节数据（一扇区字节）
(0150) //****************************************************************
(0151) UINT16 SD_Read_Sector(UINT32 addr,UINT8 *buffer)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0152) {
(0153) 
(0154) 	 UINT16 j=0;
    02C63 2744      CLR	R20
    02C64 2755      CLR	R21
(0155) 	 UINT8 time=0,temp=0;
    02C65 2766      CLR	R22
    02C66 24CC      CLR	R12
(0156) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02C67 E586      LDI	R24,0x56
    02C68 E092      LDI	R25,2
    02C69 01FE      MOVW	R30,R28
    02C6A E006      LDI	R16,6
    02C6B E010      LDI	R17,0
    02C6C 93FA      ST	-Y,R31
    02C6D 93EA      ST	-Y,R30
    02C6E 939A      ST	-Y,R25
    02C6F 938A      ST	-Y,R24
    02C70 940E 4212 CALL	asgnblk
(0157) 
(0158) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02C72 E089      LDI	R24,0x9
    02C73 E090      LDI	R25,0
    02C74 850E      LDD	R16,Y+14
    02C75 851F      LDD	R17,Y+15
    02C76 8928      LDD	R18,Y+16
    02C77 8939      LDD	R19,Y+17
    02C78 938A      ST	-Y,R24
    02C79 940E 41ED CALL	lsl32
    02C7B 870E      STD	Y+14,R16
    02C7C 871F      STD	Y+15,R17
    02C7D 8B28      STD	Y+16,R18
    02C7E 8B39      STD	Y+17,R19
(0159) 
(0160) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02C7F E188      LDI	R24,0x18
    02C80 E090      LDI	R25,0
    02C81 850E      LDD	R16,Y+14
    02C82 851F      LDD	R17,Y+15
    02C83 8928      LDD	R18,Y+16
    02C84 8939      LDD	R19,Y+17
    02C85 938A      ST	-Y,R24
    02C86 940E 4206 CALL	lsr32
    02C88 8309      STD	Y+1,R16
(0161) 	 pcmd[2] = (addr>>16);
    02C89 842E      LDD	R2,Y+14
    02C8A 843F      LDD	R3,Y+15
    02C8B 8848      LDD	R4,Y+16
    02C8C 8859      LDD	R5,Y+17
    02C8D 0112      MOVW	R2,R4
    02C8E 2444      CLR	R4
    02C8F 2455      CLR	R5
    02C90 822A      STD	Y+2,R2
(0162) 	 pcmd[3] =(addr>>8);
    02C91 E088      LDI	R24,0x8
    02C92 E090      LDI	R25,0
    02C93 850E      LDD	R16,Y+14
    02C94 851F      LDD	R17,Y+15
    02C95 8928      LDD	R18,Y+16
    02C96 8939      LDD	R19,Y+17
    02C97 938A      ST	-Y,R24
    02C98 940E 4206 CALL	lsr32
    02C9A 830B      STD	Y+3,R16
(0163) 	// pcmd[4] = offset;
(0164) 
(0165) 	 SD_CS_EN();//打开片选 
    02C9B 98C0      CBI	0x18,0
(0166) 
(0167) 	 do
(0168) 	 {  
(0169) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02C9C 018E      MOVW	R16,R28
    02C9D DEA6      RCALL	_SD_Write_cmd
    02C9E 2EC0      MOV	R12,R16
(0170) 		  time++;
    02C9F 9563      INC	R22
(0171) 		  if(time==TRY_TIME) 
    02CA0 3164      CPI	R22,0x14
    02CA1 F421      BNE	0x2CA6
(0172) 		  {
(0173) 		   SD_CS_DIS();
    02CA2 9AC0      SBI	0x18,0
(0174) 		   return(READ_BLOCK_ERROR); //读块失败
    02CA3 E004      LDI	R16,4
    02CA4 E010      LDI	R17,0
    02CA5 C01F      RJMP	0x2CC5
(0175) 		  }
(0176) 	 }while(temp!=0); 
    02CA6 20CC      TST	R12
    02CA7 F7A1      BNE	0x2C9C
(0177)    			
(0178) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02CA8 940E 3994 CALL	_SPI_Read
    02CAA 3F0E      CPI	R16,0xFE
    02CAB F7E1      BNE	0x2CA8
(0179)  		   	   	
(0180) 	 for(j=0;j<512;j++)	 //将数据写入到数据缓冲区中
    02CAC 2744      CLR	R20
    02CAD 2755      CLR	R21
    02CAE C009      RJMP	0x2CB8
(0181) 	 {	
(0182) 	    buffer[j]=SPI_Read();
    02CAF 940E 3994 CALL	_SPI_Read
    02CB1 2EC0      MOV	R12,R16
    02CB2 01FA      MOVW	R30,R20
    02CB3 0DEA      ADD	R30,R10
    02CB4 1DFB      ADC	R31,R11
    02CB5 82C0      ST	Z,R12
    02CB6 5F4F      SUBI	R20,0xFF
    02CB7 4F5F      SBCI	R21,0xFF
    02CB8 3040      CPI	R20,0
    02CB9 E0E2      LDI	R30,2
    02CBA 075E      CPC	R21,R30
    02CBB F398      BCS	0x2CAF
(0183) 	 }
(0184) 
(0185) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02CBC 940E 3994 CALL	_SPI_Read
(0186) 	 SPI_Read();
    02CBE 940E 3994 CALL	_SPI_Read
(0187) 
(0188) 	 SD_CS_DIS();  //SD卡关闭片选 
    02CC0 9AC0      SBI	0x18,0
(0189) 
(0190) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02CC1 940E 3994 CALL	_SPI_Read
(0191) 
(0192) 	 return SD_TURE;
    02CC3 2700      CLR	R16
    02CC4 2711      CLR	R17
    02CC5 9626      ADIW	R28,6
    02CC6 940E 41AF CALL	pop_xgsetF03C
    02CC8 9624      ADIW	R28,4
    02CC9 9508      RET
_SD_Read_Sector_ndata:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  len                  --> R14
  offset               --> R10
  buffer               --> Y,+20
  addr                 --> Y,+16
    02CCA 940E 4026 CALL	push_arg4
    02CCC 940E 416B CALL	push_xgsetF0FC
    02CCE 9726      SBIW	R28,6
    02CCF 88AE      LDD	R10,Y+22
    02CD0 88BF      LDD	R11,Y+23
    02CD1 8CE8      LDD	R14,Y+24
    02CD2 8CF9      LDD	R15,Y+25
(0193) }
(0194) //****************************************************************
(0195) //*隶属模块：SD卡控制
(0196) //*函数功能：写多扇区数据（多扇区字节）
(0197) //****************************************************************
(0198) UINT16 SD_Read_Sector_ndata(UINT32 addr,UINT8 *buffer,UINT16 offset,UINT16 len)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0199) {
(0200) 
(0201) 	 UINT16 j=0;
    02CD3 2744      CLR	R20
    02CD4 2755      CLR	R21
(0202) 	 UINT8 time=0,temp=0;
    02CD5 2766      CLR	R22
    02CD6 24CC      CLR	R12
(0203) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02CD7 E58C      LDI	R24,0x5C
    02CD8 E092      LDI	R25,2
    02CD9 01FE      MOVW	R30,R28
    02CDA E006      LDI	R16,6
    02CDB E010      LDI	R17,0
    02CDC 93FA      ST	-Y,R31
    02CDD 93EA      ST	-Y,R30
    02CDE 939A      ST	-Y,R25
    02CDF 938A      ST	-Y,R24
    02CE0 940E 4212 CALL	asgnblk
(0204) 
(0205) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02CE2 E089      LDI	R24,0x9
    02CE3 E090      LDI	R25,0
    02CE4 8908      LDD	R16,Y+16
    02CE5 8919      LDD	R17,Y+17
    02CE6 892A      LDD	R18,Y+18
    02CE7 893B      LDD	R19,Y+19
    02CE8 938A      ST	-Y,R24
    02CE9 940E 41ED CALL	lsl32
    02CEB 8B08      STD	Y+16,R16
    02CEC 8B19      STD	Y+17,R17
    02CED 8B2A      STD	Y+18,R18
    02CEE 8B3B      STD	Y+19,R19
(0206) 
(0207) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02CEF E188      LDI	R24,0x18
    02CF0 E090      LDI	R25,0
    02CF1 8908      LDD	R16,Y+16
    02CF2 8919      LDD	R17,Y+17
    02CF3 892A      LDD	R18,Y+18
    02CF4 893B      LDD	R19,Y+19
    02CF5 938A      ST	-Y,R24
    02CF6 940E 4206 CALL	lsr32
    02CF8 8309      STD	Y+1,R16
(0208) 	 pcmd[2] = (addr>>16);
    02CF9 8828      LDD	R2,Y+16
    02CFA 8839      LDD	R3,Y+17
    02CFB 884A      LDD	R4,Y+18
    02CFC 885B      LDD	R5,Y+19
    02CFD 0112      MOVW	R2,R4
    02CFE 2444      CLR	R4
    02CFF 2455      CLR	R5
    02D00 822A      STD	Y+2,R2
(0209) 	 pcmd[3] =(addr>>8);
    02D01 E088      LDI	R24,0x8
    02D02 E090      LDI	R25,0
    02D03 8908      LDD	R16,Y+16
    02D04 8919      LDD	R17,Y+17
    02D05 892A      LDD	R18,Y+18
    02D06 893B      LDD	R19,Y+19
    02D07 938A      ST	-Y,R24
    02D08 940E 4206 CALL	lsr32
    02D0A 830B      STD	Y+3,R16
(0210) 	// pcmd[4] = offset;
(0211) 
(0212) 	 SD_CS_EN();//打开片选 
    02D0B 98C0      CBI	0x18,0
(0213) 
(0214) 	 do
(0215) 	 {  
(0216) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02D0C 018E      MOVW	R16,R28
    02D0D DE36      RCALL	_SD_Write_cmd
    02D0E 2EC0      MOV	R12,R16
(0217) 		  time++;
    02D0F 9563      INC	R22
(0218) 		  if(time==TRY_TIME) 
    02D10 3164      CPI	R22,0x14
    02D11 F421      BNE	0x2D16
(0219) 		  {
(0220) 		   SD_CS_DIS();
    02D12 9AC0      SBI	0x18,0
(0221) 		   return(READ_BLOCK_ERROR); //读块失败
    02D13 E004      LDI	R16,4
    02D14 E010      LDI	R17,0
    02D15 C034      RJMP	0x2D4A
(0222) 		  }
(0223) 	 }while(temp!=0); 
    02D16 20CC      TST	R12
    02D17 F7A1      BNE	0x2D0C
(0224)    			
(0225) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02D18 940E 3994 CALL	_SPI_Read
    02D1A 3F0E      CPI	R16,0xFE
    02D1B F7E1      BNE	0x2D18
(0226)  		   	   	
(0227) 	 for(j=0;j<offset;j++)	 //将数据写入到数据缓冲区中
    02D1C 2744      CLR	R20
    02D1D 2755      CLR	R21
    02D1E C004      RJMP	0x2D23
(0228) 	    SPI_Read();
    02D1F 940E 3994 CALL	_SPI_Read
    02D21 5F4F      SUBI	R20,0xFF
    02D22 4F5F      SBCI	R21,0xFF
    02D23 154A      CP	R20,R10
    02D24 055B      CPC	R21,R11
    02D25 F3C8      BCS	0x2D1F
(0229) 	 for(;j<offset+len;j++)	 
    02D26 C00B      RJMP	0x2D32
(0230) 		buffer[j]=SPI_Read();
    02D27 940E 3994 CALL	_SPI_Read
    02D29 2F60      MOV	R22,R16
    02D2A 01FA      MOVW	R30,R20
    02D2B 880C      LDD	R0,Y+20
    02D2C 881D      LDD	R1,Y+21
    02D2D 0DE0      ADD	R30,R0
    02D2E 1DF1      ADC	R31,R1
    02D2F 8360      ST	Z,R22
    02D30 5F4F      SUBI	R20,0xFF
    02D31 4F5F      SBCI	R21,0xFF
    02D32 0115      MOVW	R2,R10
    02D33 0C2E      ADD	R2,R14
    02D34 1C3F      ADC	R3,R15
    02D35 1542      CP	R20,R2
    02D36 0553      CPC	R21,R3
    02D37 F378      BCS	0x2D27
(0231) 	 for(;j<512;j++)	 
    02D38 C004      RJMP	0x2D3D
(0232) 		SPI_Read();
    02D39 940E 3994 CALL	_SPI_Read
    02D3B 5F4F      SUBI	R20,0xFF
    02D3C 4F5F      SBCI	R21,0xFF
    02D3D 3040      CPI	R20,0
    02D3E E0E2      LDI	R30,2
    02D3F 075E      CPC	R21,R30
    02D40 F3C0      BCS	0x2D39
(0233) 
(0234) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02D41 940E 3994 CALL	_SPI_Read
(0235) 	 SPI_Read();
    02D43 940E 3994 CALL	_SPI_Read
(0236) 
(0237) 	 SD_CS_DIS();  //SD卡关闭片选 
    02D45 9AC0      SBI	0x18,0
(0238) 
(0239) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02D46 940E 3994 CALL	_SPI_Read
(0240) 
(0241) 	 return SD_TURE;
    02D48 2700      CLR	R16
    02D49 2711      CLR	R17
    02D4A 9626      ADIW	R28,6
    02D4B 940E 4160 CALL	pop_xgsetF0FC
    02D4D 9624      ADIW	R28,4
    02D4E 9508      RET
_GUI_mainmeu:
  key                  --> R22
  select               --> R20
    02D4F 940E 418A CALL	push_xgsetF00C
    02D51 9723      SBIW	R28,3
FILE: D:\LQD\software\master\software_src\gui.c
(0001) #include "config.h"
(0002) const char labelH[]="高强度作业：\0";
(0003) const char labelM[]="中等强度作业：\0";
(0004) const char labelL[]="低强度作业：\0";
(0005) const char H01[]="加强劳动监督；\0";
(0006) const char H02[]="增加饮水;\0" ;
(0007) const char H03[]="保持干燥禁裸露。\0";
(0008) #define M01 H01
(0009) #define M02 H03
(0010) const char M03[]="戴面罩。\0";
(0011) const char M04[]="禁油彩。\0";
(0012) #define L01 M03
(0013) #define L02 M04
(0014) const char L03[]="缩短作业时间。";
(0015) //-----//
(0016) #define H11 M04
(0017) #define H12 H03
(0018) const char H13[]="休息注意保暖。\0";
(0019) #define M11 H01
(0020) const char M12[]="减少非必须作业；\0";
(0021) const char M13[]="劳动时间<30min。\0";
(0022) const char L11[]="取消非必须的作业\0";
(0023) const char L12[]="劳动时间<15min；\0";
(0024) #define L13 H03
(0025) //-----//
(0026) #define H21 L11
(0027) #define H22 L12
(0028) #define H23 H03
(0029) const char M21[]="取消户外作业。"; 
(0030) #define L21 M21
(0031) 
(0032) //#define LEDON   PORTC&=~(1<<7)					   
(0033) //#define LEDOFF  PINC|=(1<<7)
(0034) char GUI_date[17]="09月19日18:00:00\0";
(0035) 
(0036) // 主菜单
(0037) unsigned char GUI_mainmeu( void ){
(0038)  	unsigned char key=0; //init= nokey
    02D52 2766      CLR	R22
(0039) 	unsigned char select=3;
    02D53 E043      LDI	R20,3
(0040) 	LCD_CLR();
    02D54 940E 3A74 CALL	_LCD_CLR
(0041) 	
(0042)  	Set_White(1,1,8,1);
    02D56 E081      LDI	R24,1
    02D57 838A      STD	Y+2,R24
    02D58 E088      LDI	R24,0x8
    02D59 8388      ST	Y,R24
    02D5A E021      LDI	R18,1
    02D5B E001      LDI	R16,1
    02D5C 940E 3AFE CALL	_Set_White
(0043) 	Set_White(1,2,8,1);
    02D5E E081      LDI	R24,1
    02D5F 838A      STD	Y+2,R24
    02D60 E088      LDI	R24,0x8
    02D61 8388      ST	Y,R24
    02D62 E022      LDI	R18,2
    02D63 E001      LDI	R16,1
    02D64 940E 3AFE CALL	_Set_White
(0044) 	Set_White(1,3,8,1);
    02D66 E081      LDI	R24,1
    02D67 838A      STD	Y+2,R24
    02D68 E088      LDI	R24,0x8
    02D69 8388      ST	Y,R24
    02D6A E023      LDI	R18,3
    02D6B E001      LDI	R16,1
    02D6C 940E 3AFE CALL	_Set_White
(0045) 	Set_White(1,4,8,1);
    02D6E E081      LDI	R24,1
    02D6F 838A      STD	Y+2,R24
    02D70 E088      LDI	R24,0x8
    02D71 8388      ST	Y,R24
    02D72 E024      LDI	R18,4
    02D73 E001      LDI	R16,1
    02D74 940E 3AFE CALL	_Set_White
(0046) 	dateRefresh(1); //更新系统时间
    02D76 E001      LDI	R16,1
    02D77 940E 3663 CALL	_dateRefresh
(0047) 	LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02D79 D539      RCALL	_GUI_get_date
    02D7A 8319      STD	Y+1,R17
    02D7B 8308      ST	Y,R16
    02D7C E021      LDI	R18,1
    02D7D E001      LDI	R16,1
    02D7E 940E 39CE CALL	_LCD_const_disp
(0048) 	LCD_const_disp(2,1,"  检测  时钟调整");
    02D80 EE87      LDI	R24,0xE7
    02D81 E094      LDI	R25,4
    02D82 8399      STD	Y+1,R25
    02D83 8388      ST	Y,R24
    02D84 E021      LDI	R18,1
    02D85 E002      LDI	R16,2
    02D86 940E 39CE CALL	_LCD_const_disp
(0049) 	LCD_const_disp(3,1,"  查询  数据传输");
    02D88 ED86      LDI	R24,0xD6
    02D89 E094      LDI	R25,4
    02D8A 8399      STD	Y+1,R25
    02D8B 8388      ST	Y,R24
    02D8C E021      LDI	R18,1
    02D8D E003      LDI	R16,3
    02D8E 940E 39CE CALL	_LCD_const_disp
(0050) 	LCD_const_disp(4,1,"  初始化");
    02D90 EC8D      LDI	R24,0xCD
    02D91 E094      LDI	R25,4
    02D92 8399      STD	Y+1,R25
    02D93 8388      ST	Y,R24
    02D94 E021      LDI	R18,1
    02D95 E004      LDI	R16,4
    02D96 940E 39CE CALL	_LCD_const_disp
(0051) 	Set_White(1,1,8,1);
    02D98 E081      LDI	R24,1
    02D99 838A      STD	Y+2,R24
    02D9A E088      LDI	R24,0x8
    02D9B 8388      ST	Y,R24
    02D9C E021      LDI	R18,1
    02D9D E001      LDI	R16,1
    02D9E 940E 3AFE CALL	_Set_White
(0052) 	Set_White(1,2,8,1);
    02DA0 E081      LDI	R24,1
    02DA1 838A      STD	Y+2,R24
    02DA2 E088      LDI	R24,0x8
    02DA3 8388      ST	Y,R24
    02DA4 E022      LDI	R18,2
    02DA5 E001      LDI	R16,1
    02DA6 940E 3AFE CALL	_Set_White
(0053) 	Set_White(1,3,8,1);
    02DA8 E081      LDI	R24,1
    02DA9 838A      STD	Y+2,R24
    02DAA E088      LDI	R24,0x8
    02DAB 8388      ST	Y,R24
    02DAC E023      LDI	R18,3
    02DAD E001      LDI	R16,1
    02DAE 940E 3AFE CALL	_Set_White
(0054) 	Set_White(1,4,8,1);
    02DB0 E081      LDI	R24,1
    02DB1 838A      STD	Y+2,R24
    02DB2 E088      LDI	R24,0x8
    02DB3 8388      ST	Y,R24
    02DB4 E024      LDI	R18,4
    02DB5 E001      LDI	R16,1
    02DB6 940E 3AFE CALL	_Set_White
(0055) 	set_white_n(select,0);
    02DB8 2722      CLR	R18
    02DB9 2F04      MOV	R16,R20
    02DBA 940E 3B90 CALL	_set_white_n
    02DBC C07D      RJMP	0x2E3A
(0056) 	while(1)
(0057) 	{
(0058) 	 	key=kbscan();
    02DBD 940E 3FBD CALL	_kbscan
    02DBF 2F60      MOV	R22,R16
(0059) 		dateRefresh(1); //更新系统时间
    02DC0 E001      LDI	R16,1
    02DC1 940E 3663 CALL	_dateRefresh
(0060) 		LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02DC3 D4EF      RCALL	_GUI_get_date
    02DC4 0158      MOVW	R10,R16
    02DC5 82B9      STD	Y+1,R11
    02DC6 82A8      ST	Y,R10
    02DC7 E021      LDI	R18,1
    02DC8 E001      LDI	R16,1
    02DC9 940E 39CE CALL	_LCD_const_disp
(0061) 		if((select>3) && ( key==up ) ){
    02DCB E083      LDI	R24,3
    02DCC 1784      CP	R24,R20
    02DCD F4F8      BCC	0x2DED
    02DCE 316E      CPI	R22,0x1E
    02DCF F4E9      BNE	0x2DED
(0062) 		 Set_White(1,2,8,1);
    02DD0 E081      LDI	R24,1
    02DD1 838A      STD	Y+2,R24
    02DD2 E088      LDI	R24,0x8
    02DD3 8388      ST	Y,R24
    02DD4 E022      LDI	R18,2
    02DD5 E001      LDI	R16,1
    02DD6 940E 3AFE CALL	_Set_White
(0063) 		 Set_White(1,3,8,1);
    02DD8 E081      LDI	R24,1
    02DD9 838A      STD	Y+2,R24
    02DDA E088      LDI	R24,0x8
    02DDB 8388      ST	Y,R24
    02DDC E023      LDI	R18,3
    02DDD E001      LDI	R16,1
    02DDE 940E 3AFE CALL	_Set_White
(0064) 		 Set_White(1,4,8,1);
    02DE0 E081      LDI	R24,1
    02DE1 838A      STD	Y+2,R24
    02DE2 E088      LDI	R24,0x8
    02DE3 8388      ST	Y,R24
    02DE4 E024      LDI	R18,4
    02DE5 E001      LDI	R16,1
    02DE6 940E 3AFE CALL	_Set_White
(0065) 		 select--;
    02DE8 954A      DEC	R20
(0066) 		 set_white_n(select,0);
    02DE9 2722      CLR	R18
    02DEA 2F04      MOV	R16,R20
    02DEB 940E 3B90 CALL	_set_white_n
(0067) 		}
(0068) 		if((select<7) && ( key==down ) ){
    02DED 3047      CPI	R20,7
    02DEE F538      BCC	0x2E16
    02DEF 316D      CPI	R22,0x1D
    02DF0 F529      BNE	0x2E16
(0069) 		 Set_White(1,1,8,1);
    02DF1 E081      LDI	R24,1
    02DF2 838A      STD	Y+2,R24
    02DF3 E088      LDI	R24,0x8
    02DF4 8388      ST	Y,R24
    02DF5 E021      LDI	R18,1
    02DF6 E001      LDI	R16,1
    02DF7 940E 3AFE CALL	_Set_White
(0070) 		 Set_White(1,2,8,1);
    02DF9 E081      LDI	R24,1
    02DFA 838A      STD	Y+2,R24
    02DFB E088      LDI	R24,0x8
    02DFC 8388      ST	Y,R24
    02DFD E022      LDI	R18,2
    02DFE E001      LDI	R16,1
    02DFF 940E 3AFE CALL	_Set_White
(0071) 		 Set_White(1,3,8,1);
    02E01 E081      LDI	R24,1
    02E02 838A      STD	Y+2,R24
    02E03 E088      LDI	R24,0x8
    02E04 8388      ST	Y,R24
    02E05 E023      LDI	R18,3
    02E06 E001      LDI	R16,1
    02E07 940E 3AFE CALL	_Set_White
(0072) 		 Set_White(1,4,8,1);
    02E09 E081      LDI	R24,1
    02E0A 838A      STD	Y+2,R24
    02E0B E088      LDI	R24,0x8
    02E0C 8388      ST	Y,R24
    02E0D E024      LDI	R18,4
    02E0E E001      LDI	R16,1
    02E0F 940E 3AFE CALL	_Set_White
(0073) 		 select++;
    02E11 9543      INC	R20
(0074) 		 set_white_n(select,0);
    02E12 2722      CLR	R18
    02E13 2F04      MOV	R16,R20
    02E14 940E 3B90 CALL	_set_white_n
(0075) 		}
(0076) 		if(key == left ){
    02E16 316B      CPI	R22,0x1B
    02E17 F511      BNE	0x2E3A
(0077) 		 Set_White(1,1,8,1);
    02E18 E081      LDI	R24,1
    02E19 838A      STD	Y+2,R24
    02E1A E088      LDI	R24,0x8
    02E1B 8388      ST	Y,R24
    02E1C E021      LDI	R18,1
    02E1D E001      LDI	R16,1
    02E1E 940E 3AFE CALL	_Set_White
(0078) 		 Set_White(1,2,8,1);
    02E20 E081      LDI	R24,1
    02E21 838A      STD	Y+2,R24
    02E22 E088      LDI	R24,0x8
    02E23 8388      ST	Y,R24
    02E24 E022      LDI	R18,2
    02E25 E001      LDI	R16,1
    02E26 940E 3AFE CALL	_Set_White
(0079) 		 Set_White(1,3,8,1);
    02E28 E081      LDI	R24,1
    02E29 838A      STD	Y+2,R24
    02E2A E088      LDI	R24,0x8
    02E2B 8388      ST	Y,R24
    02E2C E023      LDI	R18,3
    02E2D E001      LDI	R16,1
    02E2E 940E 3AFE CALL	_Set_White
(0080) 		 Set_White(1,4,8,1);
    02E30 E081      LDI	R24,1
    02E31 838A      STD	Y+2,R24
    02E32 E088      LDI	R24,0x8
    02E33 8388      ST	Y,R24
    02E34 E024      LDI	R18,4
    02E35 E001      LDI	R16,1
    02E36 940E 3AFE CALL	_Set_White
(0081) 		 //beep(3,select);
(0082) 		 return select;
    02E38 2F04      MOV	R16,R20
    02E39 C001      RJMP	0x2E3B
    02E3A CF82      RJMP	0x2DBD
    02E3B 9623      ADIW	R28,3
    02E3C 940C 4191 JMP	pop_xgsetF00C
_GUI_check:
  windcounter          --> R10
  next_step_time       --> Y,+3
  selectCheckMode      --> R14
  is_on                --> Y,+8
  page                 --> Y,+7
  key                  --> R12
    02E3E 940E 416B CALL	push_xgsetF0FC
    02E40 9729      SBIW	R28,0x9
(0083) 		}
(0084)     }
(0085) 	return 0xff; //error
(0086) 	
(0087) }
(0088) 
(0089) //”检测 “菜单
(0090) void GUI_check(void){
(0091)     char key;
(0092) 	char page=0,is_on=0;
    02E41 2400      CLR	R0
    02E42 820F      STD	Y+7,R0
    02E43 8608      STD	Y+8,R0
(0093) 	char windcounter=0;
    02E44 24AA      CLR	R10
(0094) 	unsigned long next_step_time=0;
    02E45 E080      LDI	R24,0
    02E46 838B      STD	Y+3,R24
    02E47 838C      STD	Y+4,R24
    02E48 838D      STD	Y+5,R24
    02E49 838E      STD	Y+6,R24
(0095) 	char selectCheckMode=config.autocheck; //自动检测开关
    02E4A 90E0 07F0 LDS	R14,config+16
(0096) RE_IN:
(0097) 	dateRefresh(1);
    02E4C E001      LDI	R16,1
    02E4D 940E 3663 CALL	_dateRefresh
(0098) 	LCD_CLR();
    02E4F 940E 3A74 CALL	_LCD_CLR
(0099) 	LCD_const_disp(1,1,"菜单/ 检测");
    02E51 EC82      LDI	R24,0xC2
    02E52 E094      LDI	R25,4
    02E53 8399      STD	Y+1,R25
    02E54 8388      ST	Y,R24
    02E55 E021      LDI	R18,1
    02E56 E001      LDI	R16,1
    02E57 940E 39CE CALL	_LCD_const_disp
(0100) 	LCD_const_disp(2,3,"自动");		 
    02E59 EB8D      LDI	R24,0xBD
    02E5A E094      LDI	R25,4
    02E5B 8399      STD	Y+1,R25
    02E5C 8388      ST	Y,R24
    02E5D E023      LDI	R18,3
    02E5E E002      LDI	R16,2
    02E5F 940E 39CE CALL	_LCD_const_disp
(0101) 	LCD_const_disp(3,3,"手动");
    02E61 EB88      LDI	R24,0xB8
    02E62 E094      LDI	R25,4
    02E63 8399      STD	Y+1,R25
    02E64 8388      ST	Y,R24
    02E65 E023      LDI	R18,3
    02E66 E003      LDI	R16,3
    02E67 940E 39CE CALL	_LCD_const_disp
(0102) 	if(selectCheckMode==1) {
    02E69 2D8E      MOV	R24,R14
    02E6A 3081      CPI	R24,1
    02E6B F489      BNE	0x2E7D
(0103) 	    Set_White(1,2,8,0);
    02E6C 2422      CLR	R2
    02E6D 822A      STD	Y+2,R2
    02E6E E088      LDI	R24,0x8
    02E6F 8388      ST	Y,R24
    02E70 E022      LDI	R18,2
    02E71 E001      LDI	R16,1
    02E72 940E 3AFE CALL	_Set_White
(0104) 		Set_White(1,3,8,1);
    02E74 E081      LDI	R24,1
    02E75 838A      STD	Y+2,R24
    02E76 E088      LDI	R24,0x8
    02E77 8388      ST	Y,R24
    02E78 E023      LDI	R18,3
    02E79 E001      LDI	R16,1
    02E7A 940E 3AFE CALL	_Set_White
(0105) 	}
    02E7C C05B      RJMP	0x2ED8
(0106) 	else {
(0107) 		 Set_White(1,2,8,1);
    02E7D E081      LDI	R24,1
    02E7E 838A      STD	Y+2,R24
    02E7F E088      LDI	R24,0x8
    02E80 8388      ST	Y,R24
    02E81 E022      LDI	R18,2
    02E82 E001      LDI	R16,1
    02E83 940E 3AFE CALL	_Set_White
(0108) 		 Set_White(1,3,8,0);
    02E85 2422      CLR	R2
    02E86 822A      STD	Y+2,R2
    02E87 E088      LDI	R24,0x8
    02E88 8388      ST	Y,R24
    02E89 E023      LDI	R18,3
    02E8A E001      LDI	R16,1
    02E8B 940E 3AFE CALL	_Set_White
(0109) 	}
    02E8D C04A      RJMP	0x2ED8
(0110) 	
(0111) //<<菜单/检测/手（自）动>>
(0112) 	while(1){
(0113) 	 	key=kbscan();
    02E8E 940E 3FBD CALL	_kbscan
    02E90 2EC0      MOV	R12,R16
(0114) 		//上键短按 选择
(0115) 		if(key==up || key ==down){
    02E91 2D8C      MOV	R24,R12
    02E92 310E      CPI	R16,0x1E
    02E93 F011      BEQ	0x2E96
    02E94 310D      CPI	R16,0x1D
    02E95 F539      BNE	0x2EBD
(0116) 		    if(selectCheckMode >0){
    02E96 E080      LDI	R24,0
    02E97 158E      CP	R24,R14
    02E98 F490      BCC	0x2EAB
(0117) 			    selectCheckMode=0;
    02E99 24EE      CLR	R14
(0118) 				Set_White(1,2,8,1);
    02E9A E081      LDI	R24,1
    02E9B 838A      STD	Y+2,R24
    02E9C E088      LDI	R24,0x8
    02E9D 8388      ST	Y,R24
    02E9E E022      LDI	R18,2
    02E9F E001      LDI	R16,1
    02EA0 940E 3AFE CALL	_Set_White
(0119) 	 			Set_White(1,3,8,0);
    02EA2 2422      CLR	R2
    02EA3 822A      STD	Y+2,R2
    02EA4 E088      LDI	R24,0x8
    02EA5 8388      ST	Y,R24
    02EA6 E023      LDI	R18,3
    02EA7 E001      LDI	R16,1
    02EA8 940E 3AFE CALL	_Set_White
(0120) 			}
    02EAA C012      RJMP	0x2EBD
(0121) 			else {
(0122) 			    selectCheckMode=1;
    02EAB 24EE      CLR	R14
    02EAC 94E3      INC	R14
(0123) 				Set_White(1,2,8,0);
    02EAD 2422      CLR	R2
    02EAE 822A      STD	Y+2,R2
    02EAF E088      LDI	R24,0x8
    02EB0 8388      ST	Y,R24
    02EB1 E022      LDI	R18,2
    02EB2 E001      LDI	R16,1
    02EB3 940E 3AFE CALL	_Set_White
(0124) 	 			Set_White(1,3,8,1);
    02EB5 E081      LDI	R24,1
    02EB6 838A      STD	Y+2,R24
    02EB7 E088      LDI	R24,0x8
    02EB8 8388      ST	Y,R24
    02EB9 E023      LDI	R18,3
    02EBA E001      LDI	R16,1
    02EBB 940E 3AFE CALL	_Set_White
(0125) 			}
(0126) 			
(0127) 		}
(0128) 		//左键短按  进入
(0129) 		if(key == left) {
    02EBD 2D8C      MOV	R24,R12
    02EBE 318B      CPI	R24,0x1B
    02EBF F499      BNE	0x2ED3
(0130) 			config.autocheck=selectCheckMode; 
    02EC0 92E0 07F0 STS	config+16,R14
(0131) 			Set_White(1,2,8,1);
    02EC2 E081      LDI	R24,1
    02EC3 838A      STD	Y+2,R24
    02EC4 E088      LDI	R24,0x8
    02EC5 8388      ST	Y,R24
    02EC6 E022      LDI	R18,2
    02EC7 E001      LDI	R16,1
    02EC8 940E 3AFE CALL	_Set_White
(0132) 	 		Set_White(1,3,8,1); 
    02ECA E081      LDI	R24,1
    02ECB 838A      STD	Y+2,R24
    02ECC E088      LDI	R24,0x8
    02ECD 8388      ST	Y,R24
    02ECE E023      LDI	R18,3
    02ECF E001      LDI	R16,1
    02ED0 940E 3AFE CALL	_Set_White
(0133) 			break ;		
    02ED2 C006      RJMP	0x2ED9
(0134) 		}
(0135) 		//右键短按  返回
(0136) 		if(key == right) {
    02ED3 2D8C      MOV	R24,R12
    02ED4 3187      CPI	R24,0x17
    02ED5 F409      BNE	0x2ED7
(0137) 			return ;		
    02ED6 C1CD      RJMP	0x30A4
(0138) 		}
(0139) 		key=0;
    02ED7 24CC      CLR	R12
    02ED8 CFB5      RJMP	0x2E8E
(0140) 	} //end of while
(0141)     //自动开启检测
(0142) 	dateRefresh(0);
    02ED9 2700      CLR	R16
    02EDA D788      RCALL	_dateRefresh
(0143) 	is_on =1 ;
    02EDB 2400      CLR	R0
    02EDC 9403      INC	R0
    02EDD 8608      STD	Y+8,R0
(0144) 	config.time1=config.now+config.THRESHOLD_delta_sec;
    02EDE 9040 07E6 LDS	R4,config+6
    02EE0 9050 07E7 LDS	R5,config+7
    02EE2 9020 07E4 LDS	R2,config+4
    02EE4 9030 07E5 LDS	R3,config+5
    02EE6 9080 07EE LDS	R8,config+14
    02EE8 9090 07EF LDS	R9,config+15
    02EEA 9060 07EC LDS	R6,config+12
    02EEC 9070 07ED LDS	R7,config+13
    02EEE 0C62      ADD	R6,R2
    02EEF 1C73      ADC	R7,R3
    02EF0 1C84      ADC	R8,R4
    02EF1 1C95      ADC	R9,R5
    02EF2 9270 07E9 STS	config+9,R7
    02EF4 9260 07E8 STS	config+8,R6
    02EF6 9290 07EB STS	config+11,R9
    02EF8 9280 07EA STS	config+10,R8
(0145) 	Result.TempChar[0]=0; //清除上次结果
    02EFA 2422      CLR	R2
    02EFB 9220 059D STS	Result+45,R2
(0146) 	Result.WSChar[0]=0;
    02EFD 9220 05A7 STS	Result+55,R2
    02EFF C1A3      RJMP	0x30A3
(0147) 	while(1){
(0148) 		key=kbscan();
    02F00 940E 3FBD CALL	_kbscan
    02F02 2EC0      MOV	R12,R16
(0149) 		if(key != 0) beep(0,1);
    02F03 2300      TST	R16
    02F04 F021      BEQ	0x2F09
    02F05 E021      LDI	R18,1
    02F06 2700      CLR	R16
    02F07 940E 3D49 CALL	_beep
(0150) 		if(key==right){	//右键 退出
    02F09 2D8C      MOV	R24,R12
    02F0A 3187      CPI	R24,0x17
    02F0B F569      BNE	0x2F39
(0151) 		    is_on=0;
    02F0C 2400      CLR	R0
    02F0D 8608      STD	Y+8,R0
(0152) 			LCD_CLR();
    02F0E 940E 3A74 CALL	_LCD_CLR
(0153) 		 	LCD_Init();	  
    02F10 940E 3A42 CALL	_LCD_Init
(0154) 	 	 	LCD_const_disp(4,5,"退出    "); 
    02F12 EA8F      LDI	R24,0xAF
    02F13 E094      LDI	R25,4
    02F14 8399      STD	Y+1,R25
    02F15 8388      ST	Y,R24
    02F16 E025      LDI	R18,5
    02F17 E004      LDI	R16,4
    02F18 940E 39CE CALL	_LCD_const_disp
(0155) 		 	delayms(200);
    02F1A EC08      LDI	R16,0xC8
    02F1B E010      LDI	R17,0
    02F1C 940E 2413 CALL	_delayms
(0156) 		 	LCD_const_disp(4,7,".."); 
    02F1E EA8C      LDI	R24,0xAC
    02F1F E094      LDI	R25,4
    02F20 8399      STD	Y+1,R25
    02F21 8388      ST	Y,R24
    02F22 E027      LDI	R18,7
    02F23 E004      LDI	R16,4
    02F24 940E 39CE CALL	_LCD_const_disp
(0157) 		 	delayms(200);
    02F26 EC08      LDI	R16,0xC8
    02F27 E010      LDI	R17,0
    02F28 940E 2413 CALL	_delayms
(0158) 		 	LCD_const_disp(4,8,".."); 	
    02F2A EA8C      LDI	R24,0xAC
    02F2B E094      LDI	R25,4
    02F2C 8399      STD	Y+1,R25
    02F2D 8388      ST	Y,R24
    02F2E E028      LDI	R18,0x8
    02F2F E004      LDI	R16,4
    02F30 940E 39CE CALL	_LCD_const_disp
(0159) 		 	delayms(500);
    02F32 EF04      LDI	R16,0xF4
    02F33 E011      LDI	R17,1
    02F34 940E 2413 CALL	_delayms
(0160) 		 	LCD_CLR();
    02F36 940E 3A74 CALL	_LCD_CLR
(0161) 		 	goto RE_IN;
    02F38 CF13      RJMP	0x2E4C
(0162) 		}
(0163) 		if(is_on==1){ 
    02F39 8588      LDD	R24,Y+8
    02F3A 3081      CPI	R24,1
    02F3B F009      BEQ	0x2F3D
    02F3C C08B      RJMP	0x2FC8
(0164) 			dateRefresh(1); 
    02F3D E001      LDI	R16,1
    02F3E D724      RCALL	_dateRefresh
(0165) 		    _GUI_datashow(page); //更新时间
    02F3F 810F      LDD	R16,Y+7
    02F40 D166      RCALL	__GUI_datashow
(0166) 		    if(config.now < config.time1) {
    02F41 9040 07EA LDS	R4,config+10
    02F43 9050 07EB LDS	R5,config+11
    02F45 9020 07E8 LDS	R2,config+8
    02F47 9030 07E9 LDS	R3,config+9
    02F49 9080 07EE LDS	R8,config+14
    02F4B 9090 07EF LDS	R9,config+15
    02F4D 9060 07EC LDS	R6,config+12
    02F4F 9070 07ED LDS	R7,config+13
    02F51 1462      CP	R6,R2
    02F52 0473      CPC	R7,R3
    02F53 0484      CPC	R8,R4
    02F54 0495      CPC	R9,R5
    02F55 F598      BCC	0x2F89
(0167) 				//时间更新 开启风速检测 等待检测 不支持翻页
(0168) 				if(windcounter==0){
    02F56 20AA      TST	R10
    02F57 F421      BNE	0x2F5C
(0169) 				    windcounter=1; //清零开启风速计数器
    02F58 24AA      CLR	R10
    02F59 94A3      INC	R10
(0170) 					timer1_init(); //开启风速传感器技术
    02F5A 940E 245F CALL	_timer1_init
(0171) 				}
(0172) 				if(page == 0 ){
    02F5C 800F      LDD	R0,Y+7
    02F5D 2000      TST	R0
    02F5E F009      BEQ	0x2F60
    02F5F C13F      RJMP	0x309F
(0173) 				
(0174) 				    LCD_const_disp(4,1,"正在检测");
    02F60 EA83      LDI	R24,0xA3
    02F61 E094      LDI	R25,4
    02F62 8399      STD	Y+1,R25
    02F63 8388      ST	Y,R24
    02F64 E021      LDI	R18,1
    02F65 E004      LDI	R16,4
    02F66 940E 39CE CALL	_LCD_const_disp
(0175) 					LCD_print4num(4,5,config.time1-config.now);
    02F68 9020 07EC LDS	R2,config+12
    02F6A 9030 07ED LDS	R3,config+13
    02F6C 9040 07E8 LDS	R4,config+8
    02F6E 9050 07E9 LDS	R5,config+9
    02F70 1842      SUB	R4,R2
    02F71 0853      SBC	R5,R3
    02F72 8259      STD	Y+1,R5
    02F73 8248      ST	Y,R4
    02F74 E025      LDI	R18,5
    02F75 E004      LDI	R16,4
    02F76 940E 3C90 CALL	_LCD_print4num
(0176) 					LCD_const_disp(2,6,"      ");
    02F78 E98C      LDI	R24,0x9C
    02F79 E094      LDI	R25,4
    02F7A 8399      STD	Y+1,R25
    02F7B 8388      ST	Y,R24
    02F7C E026      LDI	R18,6
    02F7D E002      LDI	R16,2
    02F7E 940E 39CE CALL	_LCD_const_disp
(0177) 					LCD_const_disp(3,6,"      ");
    02F80 E98C      LDI	R24,0x9C
    02F81 E094      LDI	R25,4
    02F82 8399      STD	Y+1,R25
    02F83 8388      ST	Y,R24
    02F84 E026      LDI	R18,6
    02F85 E003      LDI	R16,3
    02F86 940E 39CE CALL	_LCD_const_disp
(0178) 				}
(0179) 			} 
    02F88 C116      RJMP	0x309F
(0180) 			else {
(0181) 			   //检测完成 获得数据 转换数据 存储数据 切换到非检测状态
(0182) 			    windcounter =0 ; //关闭风速传感器计数器
    02F89 24AA      CLR	R10
(0183) 				check();
    02F8A 940E 2824 CALL	_check
(0184) 				StructToChar(); //转成字符串
    02F8C 940E 29A3 CALL	_StructToChar
(0185) 				WriteFileHead();//重写文件头
    02F8E 940E 2581 CALL	_WriteFileHead
(0186) 				WriteSDFile();  //写入sd卡
    02F90 940E 25FD CALL	_WriteSDFile
(0187) 				//zigbee_send(); //发送
(0188) 				Result.Index++; //索引自增一
    02F92 E041      LDI	R20,1
    02F93 E050      LDI	R21,0
    02F94 E060      LDI	R22,0
    02F95 E070      LDI	R23,0
    02F96 9040 057C LDS	R4,Result+12
    02F98 9050 057D LDS	R5,Result+13
    02F9A 9020 057A LDS	R2,Result+10
    02F9C 9030 057B LDS	R3,Result+11
    02F9E 0E24      ADD	R2,R20
    02F9F 1E35      ADC	R3,R21
    02FA0 1E46      ADC	R4,R22
    02FA1 1E57      ADC	R5,R23
    02FA2 9230 057B STS	Result+11,R3
    02FA4 9220 057A STS	Result+10,R2
    02FA6 9250 057D STS	Result+13,R5
    02FA8 9240 057C STS	Result+12,R4
(0189) 				is_on=0; //切换到非检测状态
    02FAA 2400      CLR	R0
    02FAB 8608      STD	Y+8,R0
(0190) 				next_step_time=config.now+config.checkDeltaTime;//自动翻页时间更新
    02FAC 9020 07F1 LDS	R2,config+17
    02FAE 9030 07F2 LDS	R3,config+18
    02FB0 2444      CLR	R4
    02FB1 FC37      SBRC	R3,7
    02FB2 9440      COM	R4
    02FB3 2455      CLR	R5
    02FB4 FC47      SBRC	R4,7
    02FB5 9450      COM	R5
    02FB6 9080 07EE LDS	R8,config+14
    02FB8 9090 07EF LDS	R9,config+15
    02FBA 9060 07EC LDS	R6,config+12
    02FBC 9070 07ED LDS	R7,config+13
    02FBE 0C62      ADD	R6,R2
    02FBF 1C73      ADC	R7,R3
    02FC0 1C84      ADC	R8,R4
    02FC1 1C95      ADC	R9,R5
    02FC2 826B      STD	Y+3,R6
    02FC3 827C      STD	Y+4,R7
    02FC4 828D      STD	Y+5,R8
    02FC5 829E      STD	Y+6,R9
(0191) 				page=0;
    02FC6 820F      STD	Y+7,R0
(0192) 		   }
(0193) 		}
    02FC7 C0D7      RJMP	0x309F
(0194) 		else { //is_on == 0 非检测状态 手动翻页/自动翻页
(0195) 		    dateRefresh(0);//不更新时间
    02FC8 2700      CLR	R16
    02FC9 D699      RCALL	_dateRefresh
(0196) 			_GUI_datashow(page); 
    02FCA 810F      LDD	R16,Y+7
    02FCB D0DB      RCALL	__GUI_datashow
(0197) 			if(page == 0 ){
    02FCC 800F      LDD	R0,Y+7
    02FCD 2000      TST	R0
    02FCE F4E9      BNE	0x2FEC
(0198) 				
(0199) 				    LCD_const_disp(4,1,"完成检测        ");
    02FCF E88B      LDI	R24,0x8B
    02FD0 E094      LDI	R25,4
    02FD1 8399      STD	Y+1,R25
    02FD2 8388      ST	Y,R24
    02FD3 E021      LDI	R18,1
    02FD4 E004      LDI	R16,4
    02FD5 940E 39CE CALL	_LCD_const_disp
(0200) 					if(config.autocheck == 1){
    02FD7 9180 07F0 LDS	R24,config+16
    02FD9 3081      CPI	R24,1
    02FDA F449      BNE	0x2FE4
(0201) 					    LCD_const_disp(4,7,"自动");
    02FDB EB8D      LDI	R24,0xBD
    02FDC E094      LDI	R25,4
    02FDD 8399      STD	Y+1,R25
    02FDE 8388      ST	Y,R24
    02FDF E027      LDI	R18,7
    02FE0 E004      LDI	R16,4
    02FE1 940E 39CE CALL	_LCD_const_disp
(0202) 					}
    02FE3 C008      RJMP	0x2FEC
(0203) 					else {
(0204) 					    LCD_const_disp(4,7,"手动");
    02FE4 EB88      LDI	R24,0xB8
    02FE5 E094      LDI	R25,4
    02FE6 8399      STD	Y+1,R25
    02FE7 8388      ST	Y,R24
    02FE8 E027      LDI	R18,7
    02FE9 E004      LDI	R16,4
    02FEA 940E 39CE CALL	_LCD_const_disp
(0205) 					}
(0206) 					
(0207) 				}
(0208) 						//手动翻页 
(0209) 			if(key==up){ //上键 : 页面减 
    02FEC 2D8C      MOV	R24,R12
    02FED 318E      CPI	R24,0x1E
    02FEE F539      BNE	0x3016
(0210) 		        if(page>0) page--;
    02FEF E080      LDI	R24,0
    02FF0 800F      LDD	R0,Y+7
    02FF1 1580      CP	R24,R0
    02FF2 F418      BCC	0x2FF6
    02FF3 940A      DEC	R0
    02FF4 820F      STD	Y+7,R0
    02FF5 C01C      RJMP	0x3012
(0211) 				else{
(0212) 				page =5;
    02FF6 E085      LDI	R24,5
    02FF7 838F      STD	Y+7,R24
(0213) 				next_step_time = config.now + config.checkDeltaTime;
    02FF8 9020 07F1 LDS	R2,config+17
    02FFA 9030 07F2 LDS	R3,config+18
    02FFC 2444      CLR	R4
    02FFD FC37      SBRC	R3,7
    02FFE 9440      COM	R4
    02FFF 2455      CLR	R5
    03000 FC47      SBRC	R4,7
    03001 9450      COM	R5
    03002 9080 07EE LDS	R8,config+14
    03004 9090 07EF LDS	R9,config+15
    03006 9060 07EC LDS	R6,config+12
    03008 9070 07ED LDS	R7,config+13
    0300A 0C62      ADD	R6,R2
    0300B 1C73      ADC	R7,R3
    0300C 1C84      ADC	R8,R4
    0300D 1C95      ADC	R9,R5
    0300E 826B      STD	Y+3,R6
    0300F 827C      STD	Y+4,R7
    03010 828D      STD	Y+5,R8
    03011 829E      STD	Y+6,R9
(0214) 				}
(0215) 		    	LCD_CLR();
    03012 940E 3A74 CALL	_LCD_CLR
(0216) 		    	LCD_Init();
    03014 940E 3A42 CALL	_LCD_Init
(0217) 			}
(0218) 			if(key==down){//下键 ： 页面加
    03016 2D8C      MOV	R24,R12
    03017 318D      CPI	R24,0x1D
    03018 F509      BNE	0x303A
(0219) 		        page++;
    03019 800F      LDD	R0,Y+7
    0301A 9403      INC	R0
    0301B 820F      STD	Y+7,R0
(0220) 				next_step_time = config.now + config.checkDeltaTime;
    0301C 9020 07F1 LDS	R2,config+17
    0301E 9030 07F2 LDS	R3,config+18
    03020 2444      CLR	R4
    03021 FC37      SBRC	R3,7
    03022 9440      COM	R4
    03023 2455      CLR	R5
    03024 FC47      SBRC	R4,7
    03025 9450      COM	R5
    03026 9080 07EE LDS	R8,config+14
    03028 9090 07EF LDS	R9,config+15
    0302A 9060 07EC LDS	R6,config+12
    0302C 9070 07ED LDS	R7,config+13
    0302E 0C62      ADD	R6,R2
    0302F 1C73      ADC	R7,R3
    03030 1C84      ADC	R8,R4
    03031 1C95      ADC	R9,R5
    03032 826B      STD	Y+3,R6
    03033 827C      STD	Y+4,R7
    03034 828D      STD	Y+5,R8
    03035 829E      STD	Y+6,R9
(0221) 		  		LCD_CLR();
    03036 940E 3A74 CALL	_LCD_CLR
(0222) 		    	LCD_Init();
    03038 940E 3A42 CALL	_LCD_Init
(0223) 			} 	
(0224) 			//LCD_print2num(4,1,page);
(0225) 			//LCD_print4num(4,3,config.now);
(0226) 			//LCD_print4num(4,6,next_step_time);
(0227) 			if( config.autocheck == 1 ){  //如果开启自动翻页
    0303A 9180 07F0 LDS	R24,config+16
    0303C 3081      CPI	R24,1
    0303D F009      BEQ	0x303F
    0303E C060      RJMP	0x309F
(0228) 			      if(config.now >= next_step_time || page >=6 )	{
    0303F 802B      LDD	R2,Y+3
    03040 803C      LDD	R3,Y+4
    03041 804D      LDD	R4,Y+5
    03042 805E      LDD	R5,Y+6
    03043 9080 07EE LDS	R8,config+14
    03045 9090 07EF LDS	R9,config+15
    03047 9060 07EC LDS	R6,config+12
    03049 9070 07ED LDS	R7,config+13
    0304B 1462      CP	R6,R2
    0304C 0473      CPC	R7,R3
    0304D 0484      CPC	R8,R4
    0304E 0495      CPC	R9,R5
    0304F F420      BCC	0x3054
    03050 818F      LDD	R24,Y+7
    03051 3086      CPI	R24,6
    03052 F408      BCC	0x3054
    03053 C04B      RJMP	0x309F
(0229) 				      next_step_time = config.now + config.checkDeltaTime;
    03054 9020 07F1 LDS	R2,config+17
    03056 9030 07F2 LDS	R3,config+18
    03058 2444      CLR	R4
    03059 FC37      SBRC	R3,7
    0305A 9440      COM	R4
    0305B 2455      CLR	R5
    0305C FC47      SBRC	R4,7
    0305D 9450      COM	R5
    0305E 9080 07EE LDS	R8,config+14
    03060 9090 07EF LDS	R9,config+15
    03062 9060 07EC LDS	R6,config+12
    03064 9070 07ED LDS	R7,config+13
    03066 0C62      ADD	R6,R2
    03067 1C73      ADC	R7,R3
    03068 1C84      ADC	R8,R4
    03069 1C95      ADC	R9,R5
    0306A 826B      STD	Y+3,R6
    0306B 827C      STD	Y+4,R7
    0306C 828D      STD	Y+5,R8
    0306D 829E      STD	Y+6,R9
(0230) 					  page++;
    0306E 800F      LDD	R0,Y+7
    0306F 9403      INC	R0
    03070 820F      STD	Y+7,R0
(0231) 					  if( page>=6 ){
    03071 2D80      MOV	R24,R0
    03072 3086      CPI	R24,6
    03073 F140      BCS	0x309C
(0232) 					      //自动翻到最后页，页面清零开启下次检测
(0233) 					      page = 0;
    03074 2400      CLR	R0
    03075 820F      STD	Y+7,R0
(0234) 						  dateRefresh(1); //刷新时间
    03076 E001      LDI	R16,1
    03077 D5EB      RCALL	_dateRefresh
(0235) 						  is_on =1 ; //开启检测
    03078 2400      CLR	R0
    03079 9403      INC	R0
    0307A 8608      STD	Y+8,R0
(0236) 						  config.time1=config.now+config.THRESHOLD_delta_sec; //更新下次检测时间
    0307B 9040 07E6 LDS	R4,config+6
    0307D 9050 07E7 LDS	R5,config+7
    0307F 9020 07E4 LDS	R2,config+4
    03081 9030 07E5 LDS	R3,config+5
    03083 9080 07EE LDS	R8,config+14
    03085 9090 07EF LDS	R9,config+15
    03087 9060 07EC LDS	R6,config+12
    03089 9070 07ED LDS	R7,config+13
    0308B 0C62      ADD	R6,R2
    0308C 1C73      ADC	R7,R3
    0308D 1C84      ADC	R8,R4
    0308E 1C95      ADC	R9,R5
    0308F 9270 07E9 STS	config+9,R7
    03091 9260 07E8 STS	config+8,R6
    03093 9290 07EB STS	config+11,R9
    03095 9280 07EA STS	config+10,R8
(0237) 						  Result.TempChar[0]=0; //清除上次结果
    03097 2422      CLR	R2
    03098 9220 059D STS	Result+45,R2
(0238) 						  Result.WSChar[0]=0;
    0309A 9220 05A7 STS	Result+55,R2
(0239) 					  }
(0240) 				      LCD_CLR();      
    0309C 940E 3A74 CALL	_LCD_CLR
(0241) 					  key=0;
    0309E 24CC      CLR	R12
(0242) 				  }  
(0243) 			}
(0244) 
(0245) 			
(0246) 
(0247) 			 
(0248) 		} 
(0249) 	    delayms(10); 
    0309F E00A      LDI	R16,0xA
    030A0 E010      LDI	R17,0
    030A1 940E 2413 CALL	_delayms
    030A3 CE5C      RJMP	0x2F00
    030A4 9629      ADIW	R28,0x9
    030A5 940C 4160 JMP	pop_xgsetF0FC
__GUI_datashow:
  page                 --> R20
    030A7 940E 418A CALL	push_xgsetF00C
    030A9 2F40      MOV	R20,R16
    030AA 9722      SBIW	R28,2
(0250) 	}//end while
(0251) }//end function
(0252) void _GUI_datashow(char page){
(0253) 	if(page == 0){
    030AB 2344      TST	R20
    030AC F539      BNE	0x30D4
(0254)  	//显示日期时间
(0255) 	    LCD_var_disp(1,1,GUI_get_date());
    030AD D205      RCALL	_GUI_get_date
    030AE 8319      STD	Y+1,R17
    030AF 8308      ST	Y,R16
    030B0 E021      LDI	R18,1
    030B1 E001      LDI	R16,1
    030B2 940E 39FB CALL	_LCD_var_disp
(0256) 	//显示温度
(0257) 	 	LCD_const_disp(2,1,"温度 (℃):");
    030B4 E880      LDI	R24,0x80
    030B5 E094      LDI	R25,4
    030B6 8399      STD	Y+1,R25
    030B7 8388      ST	Y,R24
    030B8 E021      LDI	R18,1
    030B9 E002      LDI	R16,2
    030BA 940E 39CE CALL	_LCD_const_disp
(0258) 	 	LCD_var_disp(2,6,Result.TempChar);
    030BC E98D      LDI	R24,0x9D
    030BD E095      LDI	R25,5
    030BE 8399      STD	Y+1,R25
    030BF 8388      ST	Y,R24
    030C0 E026      LDI	R18,6
    030C1 E002      LDI	R16,2
    030C2 940E 39FB CALL	_LCD_var_disp
(0259) 	//显示风速
(0260) 	    LCD_const_disp(3,1,"风速(m/s): ");
    030C4 E784      LDI	R24,0x74
    030C5 E094      LDI	R25,4
    030C6 8399      STD	Y+1,R25
    030C7 8388      ST	Y,R24
    030C8 E021      LDI	R18,1
    030C9 E003      LDI	R16,3
    030CA 940E 39CE CALL	_LCD_const_disp
(0261) 	 	LCD_const_disp(3,6,Result.WSChar);
    030CC EA87      LDI	R24,0xA7
    030CD E095      LDI	R25,5
    030CE 8399      STD	Y+1,R25
    030CF 8388      ST	Y,R24
    030D0 E026      LDI	R18,6
    030D1 E003      LDI	R16,3
    030D2 940E 39CE CALL	_LCD_const_disp
(0262) 
(0263) 	 } 
(0264) 	 if(page == 1){
    030D4 3041      CPI	R20,1
    030D5 F5B9      BNE	0x310D
(0265) 	     LCD_var_disp(1,1,GUI_get_date());
    030D6 D1DC      RCALL	_GUI_get_date
    030D7 8319      STD	Y+1,R17
    030D8 8308      ST	Y,R16
    030D9 E021      LDI	R18,1
    030DA E001      LDI	R16,1
    030DB 940E 39FB CALL	_LCD_var_disp
(0266) 		 LCD_const_disp(2,1,"风冷指数: ");
    030DD E689      LDI	R24,0x69
    030DE E094      LDI	R25,4
    030DF 8399      STD	Y+1,R25
    030E0 8388      ST	Y,R24
    030E1 E021      LDI	R18,1
    030E2 E002      LDI	R16,2
    030E3 940E 39CE CALL	_LCD_const_disp
(0267) 		 LCD_var_disp(2,6,Result.WCIChar);						
    030E5 EB80      LDI	R24,0xB0
    030E6 E095      LDI	R25,5
    030E7 8399      STD	Y+1,R25
    030E8 8388      ST	Y,R24
    030E9 E026      LDI	R18,6
    030EA E002      LDI	R16,2
    030EB 940E 39FB CALL	_LCD_var_disp
(0268) 		 LCD_const_disp(3,1,"等价温度: ");
    030ED E58E      LDI	R24,0x5E
    030EE E094      LDI	R25,4
    030EF 8399      STD	Y+1,R25
    030F0 8388      ST	Y,R24
    030F1 E021      LDI	R18,1
    030F2 E003      LDI	R16,3
    030F3 940E 39CE CALL	_LCD_const_disp
(0269) 		 LCD_var_disp(3,6,Result.ECTChar);	 
    030F5 EB8A      LDI	R24,0xBA
    030F6 E095      LDI	R25,5
    030F7 8399      STD	Y+1,R25
    030F8 8388      ST	Y,R24
    030F9 E026      LDI	R18,6
    030FA E003      LDI	R16,3
    030FB 940E 39FB CALL	_LCD_var_disp
(0270) 		 LCD_const_disp(4,1,"相当温度: ");
    030FD E583      LDI	R24,0x53
    030FE E094      LDI	R25,4
    030FF 8399      STD	Y+1,R25
    03100 8388      ST	Y,R24
    03101 E021      LDI	R18,1
    03102 E004      LDI	R16,4
    03103 940E 39CE CALL	_LCD_const_disp
(0271) 		 LCD_var_disp(4,6,Result.TeqChar);	
    03105 EC84      LDI	R24,0xC4
    03106 E095      LDI	R25,5
    03107 8399      STD	Y+1,R25
    03108 8388      ST	Y,R24
    03109 E026      LDI	R18,6
    0310A E004      LDI	R16,4
    0310B 940E 39FB CALL	_LCD_var_disp
(0272) 	 }
(0273) 	 if(page == 2){
    0310D 3042      CPI	R20,2
    0310E F009      BEQ	0x3110
    0310F C03F      RJMP	0x314F
(0274) 	     LCD_var_disp(1,1,GUI_get_date());
    03110 D1A2      RCALL	_GUI_get_date
    03111 0158      MOVW	R10,R16
    03112 82B9      STD	Y+1,R11
    03113 82A8      ST	Y,R10
    03114 E021      LDI	R18,1
    03115 E001      LDI	R16,1
    03116 940E 39FB CALL	_LCD_var_disp
(0275) 		 LCD_const_disp(2,1,"冻伤危害性:");
    03118 E487      LDI	R24,0x47
    03119 E094      LDI	R25,4
    0311A 8399      STD	Y+1,R25
    0311B 8388      ST	Y,R24
    0311C E021      LDI	R18,1
    0311D E002      LDI	R16,2
    0311E 940E 39CE CALL	_LCD_const_disp
(0276) 	 if(Result.WeiHai==0){LCD_const_disp(3,1,"  冻伤危害性小");			 }
    03120 9020 05CA LDS	R2,Result+90
    03122 2022      TST	R2
    03123 F449      BNE	0x312D
    03124 E388      LDI	R24,0x38
    03125 E094      LDI	R25,4
    03126 8399      STD	Y+1,R25
    03127 8388      ST	Y,R24
    03128 E021      LDI	R18,1
    03129 E003      LDI	R16,3
    0312A 940E 39CE CALL	_LCD_const_disp
    0312C C022      RJMP	0x314F
(0277) 	 else if(Result.WeiHai==1){	LCD_const_disp(3,1,"  冻伤危害性较大");	 }
    0312D 9180 05CA LDS	R24,Result+90
    0312F 3081      CPI	R24,1
    03130 F449      BNE	0x313A
    03131 E287      LDI	R24,0x27
    03132 E094      LDI	R25,4
    03133 8399      STD	Y+1,R25
    03134 8388      ST	Y,R24
    03135 E021      LDI	R18,1
    03136 E003      LDI	R16,3
    03137 940E 39CE CALL	_LCD_const_disp
    03139 C015      RJMP	0x314F
(0278) 	 else if(Result.WeiHai==2){	LCD_const_disp(3,1,"  冻伤危害性很大");	 }
    0313A 9180 05CA LDS	R24,Result+90
    0313C 3082      CPI	R24,2
    0313D F449      BNE	0x3147
    0313E E186      LDI	R24,0x16
    0313F E094      LDI	R25,4
    03140 8399      STD	Y+1,R25
    03141 8388      ST	Y,R24
    03142 E021      LDI	R18,1
    03143 E003      LDI	R16,3
    03144 940E 39CE CALL	_LCD_const_disp
    03146 C008      RJMP	0x314F
(0279) 	 else LCD_const_disp(3,1,"冻伤危害性小。");
    03147 E087      LDI	R24,7
    03148 E094      LDI	R25,4
    03149 8399      STD	Y+1,R25
    0314A 8388      ST	Y,R24
    0314B E021      LDI	R18,1
    0314C E003      LDI	R16,3
    0314D 940E 39CE CALL	_LCD_const_disp
(0280) 	 }	  
(0281) 	 if(page==3){
    0314F 3043      CPI	R20,3
    03150 F009      BEQ	0x3152
    03151 C061      RJMP	0x31B3
(0282) 	     LCD_const_disp(1,1,labelH);		
    03152 E682      LDI	R24,0x62
    03153 E092      LDI	R25,2
    03154 8399      STD	Y+1,R25
    03155 8388      ST	Y,R24
    03156 E021      LDI	R18,1
    03157 E001      LDI	R16,1
    03158 940E 39CE CALL	_LCD_const_disp
(0283) 	 	 switch( Result.WeiHai ){
    0315A 9160 05CA LDS	R22,Result+90
    0315C 2777      CLR	R23
    0315D 3060      CPI	R22,0
    0315E 0767      CPC	R22,R23
    0315F F049      BEQ	0x3169
    03160 3061      CPI	R22,1
    03161 E0E0      LDI	R30,0
    03162 077E      CPC	R23,R30
    03163 F0F1      BEQ	0x3182
    03164 3062      CPI	R22,2
    03165 E0E0      LDI	R30,0
    03166 077E      CPC	R23,R30
    03167 F199      BEQ	0x319B
    03168 C04A      RJMP	0x31B3
(0284) 			case 0 :
(0285) 			LCD_const_disp(2,1,H01);
    03169 E88E      LDI	R24,0x8E
    0316A E092      LDI	R25,2
    0316B 8399      STD	Y+1,R25
    0316C 8388      ST	Y,R24
    0316D E021      LDI	R18,1
    0316E E002      LDI	R16,2
    0316F 940E 39CE CALL	_LCD_const_disp
(0286) 			LCD_const_disp(3,1,H02);
    03171 E98E      LDI	R24,0x9E
    03172 E092      LDI	R25,2
    03173 8399      STD	Y+1,R25
    03174 8388      ST	Y,R24
    03175 E021      LDI	R18,1
    03176 E003      LDI	R16,3
    03177 940E 39CE CALL	_LCD_const_disp
(0287) 			LCD_const_disp(4,1,H03);
    03179 EA89      LDI	R24,0xA9
    0317A E092      LDI	R25,2
    0317B 8399      STD	Y+1,R25
    0317C 8388      ST	Y,R24
    0317D E021      LDI	R18,1
    0317E E004      LDI	R16,4
    0317F 940E 39CE CALL	_LCD_const_disp
(0288) 			break;
    03181 C031      RJMP	0x31B3
(0289) 			case 1 : 
(0290) 			LCD_const_disp(2,1,H11);
    03182 EC85      LDI	R24,0xC5
    03183 E092      LDI	R25,2
    03184 8399      STD	Y+1,R25
    03185 8388      ST	Y,R24
    03186 E021      LDI	R18,1
    03187 E002      LDI	R16,2
    03188 940E 39CE CALL	_LCD_const_disp
(0291) 			LCD_const_disp(3,1,H12);
    0318A EA89      LDI	R24,0xA9
    0318B E092      LDI	R25,2
    0318C 8399      STD	Y+1,R25
    0318D 8388      ST	Y,R24
    0318E E021      LDI	R18,1
    0318F E003      LDI	R16,3
    03190 940E 39CE CALL	_LCD_const_disp
(0292) 			LCD_const_disp(4,1,H13);
    03192 ED8E      LDI	R24,0xDE
    03193 E092      LDI	R25,2
    03194 8399      STD	Y+1,R25
    03195 8388      ST	Y,R24
    03196 E021      LDI	R18,1
    03197 E004      LDI	R16,4
    03198 940E 39CE CALL	_LCD_const_disp
(0293) 			break ;	
    0319A C018      RJMP	0x31B3
(0294) 			case 2 :
(0295) 			LCD_const_disp(2,1,H21);
    0319B E182      LDI	R24,0x12
    0319C E093      LDI	R25,3
    0319D 8399      STD	Y+1,R25
    0319E 8388      ST	Y,R24
    0319F E021      LDI	R18,1
    031A0 E002      LDI	R16,2
    031A1 940E 39CE CALL	_LCD_const_disp
(0296) 			LCD_const_disp(3,1,H22);
    031A3 E284      LDI	R24,0x24
    031A4 E093      LDI	R25,3
    031A5 8399      STD	Y+1,R25
    031A6 8388      ST	Y,R24
    031A7 E021      LDI	R18,1
    031A8 E003      LDI	R16,3
    031A9 940E 39CE CALL	_LCD_const_disp
(0297) 			LCD_const_disp(4,1,H23);
    031AB EA89      LDI	R24,0xA9
    031AC E092      LDI	R25,2
    031AD 8399      STD	Y+1,R25
    031AE 8388      ST	Y,R24
    031AF E021      LDI	R18,1
    031B0 E004      LDI	R16,4
    031B1 940E 39CE CALL	_LCD_const_disp
(0298) 			break;
(0299) 			default : ;
(0300) 		}
(0301) 	 } 
(0302) 	 if(page==4){
    031B3 3044      CPI	R20,4
    031B4 F009      BEQ	0x31B6
    031B5 C086      RJMP	0x323C
(0303) 	 		LCD_const_disp(1,1,labelM);		
    031B6 E780      LDI	R24,0x70
    031B7 E092      LDI	R25,2
    031B8 8399      STD	Y+1,R25
    031B9 8388      ST	Y,R24
    031BA E021      LDI	R18,1
    031BB E001      LDI	R16,1
    031BC 940E 39CE CALL	_LCD_const_disp
(0304) 	 		switch( Result.WeiHai ){
    031BE 9160 05CA LDS	R22,Result+90
    031C0 2777      CLR	R23
    031C1 3060      CPI	R22,0
    031C2 0767      CPC	R22,R23
    031C3 F059      BEQ	0x31CF
    031C4 3061      CPI	R22,1
    031C5 E0E0      LDI	R30,0
    031C6 077E      CPC	R23,R30
    031C7 F409      BNE	0x31C9
    031C8 C052      RJMP	0x321B
    031C9 3062      CPI	R22,2
    031CA E0E0      LDI	R30,0
    031CB 077E      CPC	R23,R30
    031CC F409      BNE	0x31CE
    031CD C066      RJMP	0x3234
    031CE C06D      RJMP	0x323C
(0305) 	 			case 0 :
(0306) 				LCD_const_disp(2,1,M01);
    031CF E88E      LDI	R24,0x8E
    031D0 E092      LDI	R25,2
    031D1 8399      STD	Y+1,R25
    031D2 8388      ST	Y,R24
    031D3 E021      LDI	R18,1
    031D4 E002      LDI	R16,2
    031D5 940E 39CE CALL	_LCD_const_disp
(0307) 				LCD_const_disp(3,1,M02);
    031D7 EA89      LDI	R24,0xA9
    031D8 E092      LDI	R25,2
    031D9 8399      STD	Y+1,R25
    031DA 8388      ST	Y,R24
    031DB E021      LDI	R18,1
    031DC E003      LDI	R16,3
    031DD 940E 39CE CALL	_LCD_const_disp
(0308) 				if(Result.Temperature < 17.7){
    031DF 9040 059B LDS	R4,Result+43
    031E1 9050 059C LDS	R5,Result+44
    031E3 9020 0599 LDS	R2,Result+41
    031E5 9030 059A LDS	R3,Result+42
    031E7 EC00      LDI	R16,0xC0
    031E8 E010      LDI	R17,0
    031E9 940E 40F3 CALL	elpm32
    031EB 933A      ST	-Y,R19
    031EC 932A      ST	-Y,R18
    031ED 931A      ST	-Y,R17
    031EE 930A      ST	-Y,R16
    031EF 0181      MOVW	R16,R2
    031F0 0192      MOVW	R18,R4
    031F1 940E 4491 CALL	fpcmp2
    031F3 F44C      BGE	0x31FD
(0309) 				    LCD_const_disp(4,1,"戴面罩；禁油彩。");
    031F4 EF86      LDI	R24,0xF6
    031F5 E093      LDI	R25,3
    031F6 8399      STD	Y+1,R25
    031F7 8388      ST	Y,R24
    031F8 E021      LDI	R18,1
    031F9 E004      LDI	R16,4
    031FA 940E 39CE CALL	_LCD_const_disp
(0310) 				}
    031FC C03F      RJMP	0x323C
(0311) 				else if(Result.Temperature < 12){
    031FD 9040 059B LDS	R4,Result+43
    031FF 9050 059C LDS	R5,Result+44
    03201 9020 0599 LDS	R2,Result+41
    03203 9030 059A LDS	R3,Result+42
    03205 EB0C      LDI	R16,0xBC
    03206 E010      LDI	R17,0
    03207 940E 40F3 CALL	elpm32
    03209 933A      ST	-Y,R19
    0320A 932A      ST	-Y,R18
    0320B 931A      ST	-Y,R17
    0320C 930A      ST	-Y,R16
    0320D 0181      MOVW	R16,R2
    0320E 0192      MOVW	R18,R4
    0320F 940E 4491 CALL	fpcmp2
    03211 F554      BGE	0x323C
(0312) 				    LCD_const_disp(4,1,"禁油彩。        \0");
    03212 EE84      LDI	R24,0xE4
    03213 E093      LDI	R25,3
    03214 8399      STD	Y+1,R25
    03215 8388      ST	Y,R24
    03216 E021      LDI	R18,1
    03217 E004      LDI	R16,4
    03218 940E 39CE CALL	_LCD_const_disp
(0313) 				}
(0314) 				break;
    0321A C021      RJMP	0x323C
(0315) 				case 1 : 
(0316) 			    LCD_const_disp(2,1,M11);
    0321B E88E      LDI	R24,0x8E
    0321C E092      LDI	R25,2
    0321D 8399      STD	Y+1,R25
    0321E 8388      ST	Y,R24
    0321F E021      LDI	R18,1
    03220 E002      LDI	R16,2
    03221 940E 39CE CALL	_LCD_const_disp
(0317) 				LCD_const_disp(3,1,M12);
    03223 EE8E      LDI	R24,0xEE
    03224 E092      LDI	R25,2
    03225 8399      STD	Y+1,R25
    03226 8388      ST	Y,R24
    03227 E021      LDI	R18,1
    03228 E003      LDI	R16,3
    03229 940E 39CE CALL	_LCD_const_disp
(0318) 				LCD_const_disp(4,1,M13);
    0322B E080      LDI	R24,0
    0322C E093      LDI	R25,3
    0322D 8399      STD	Y+1,R25
    0322E 8388      ST	Y,R24
    0322F E021      LDI	R18,1
    03230 E004      LDI	R16,4
    03231 940E 39CE CALL	_LCD_const_disp
(0319) 				break ;
    03233 C008      RJMP	0x323C
(0320) 				case 2 :
(0321) 				LCD_const_disp(2,1,M21);
    03234 E386      LDI	R24,0x36
    03235 E093      LDI	R25,3
    03236 8399      STD	Y+1,R25
    03237 8388      ST	Y,R24
    03238 E021      LDI	R18,1
    03239 E002      LDI	R16,2
    0323A 940E 39CE CALL	_LCD_const_disp
(0322) 				break ;
(0323) 				default :;
(0324) 	 		}
(0325) 	 }
(0326) 	 if(page==5){
    0323C 3045      CPI	R20,5
    0323D F009      BEQ	0x323F
    0323E C071      RJMP	0x32B0
(0327) 	     LCD_const_disp(1,1,labelL);		
    0323F E880      LDI	R24,0x80
    03240 E092      LDI	R25,2
    03241 8399      STD	Y+1,R25
    03242 8388      ST	Y,R24
    03243 E021      LDI	R18,1
    03244 E001      LDI	R16,1
    03245 940E 39CE CALL	_LCD_const_disp
(0328) 	 	 switch( Result.WeiHai ){	
    03247 9140 05CA LDS	R20,Result+90
    03249 2755      CLR	R21
    0324A 3040      CPI	R20,0
    0324B 0745      CPC	R20,R21
    0324C F059      BEQ	0x3258
    0324D 3041      CPI	R20,1
    0324E E0E0      LDI	R30,0
    0324F 075E      CPC	R21,R30
    03250 F409      BNE	0x3252
    03251 C03D      RJMP	0x328F
    03252 3042      CPI	R20,2
    03253 E0E0      LDI	R30,0
    03254 075E      CPC	R21,R30
    03255 F409      BNE	0x3257
    03256 C051      RJMP	0x32A8
    03257 C058      RJMP	0x32B0
(0329) 		     case 0 :
(0330) 			 LCD_const_disp(2,1,L01);
    03258 EB8B      LDI	R24,0xBB
    03259 E092      LDI	R25,2
    0325A 8399      STD	Y+1,R25
    0325B 8388      ST	Y,R24
    0325C E021      LDI	R18,1
    0325D E002      LDI	R16,2
    0325E 940E 39CE CALL	_LCD_const_disp
(0331) 			 if(Result.Temperature < -12) {
    03260 9040 059B LDS	R4,Result+43
    03262 9050 059C LDS	R5,Result+44
    03264 9020 0599 LDS	R2,Result+41
    03266 9030 059A LDS	R3,Result+42
    03268 EB08      LDI	R16,0xB8
    03269 E010      LDI	R17,0
    0326A 940E 40F3 CALL	elpm32
    0326C 933A      ST	-Y,R19
    0326D 932A      ST	-Y,R18
    0326E 931A      ST	-Y,R17
    0326F 930A      ST	-Y,R16
    03270 0181      MOVW	R16,R2
    03271 0192      MOVW	R18,R4
    03272 940E 4491 CALL	fpcmp2
    03274 F48C      BGE	0x3286
(0332) 			 LCD_const_disp(3,1,L02);
    03275 EC85      LDI	R24,0xC5
    03276 E092      LDI	R25,2
    03277 8399      STD	Y+1,R25
    03278 8388      ST	Y,R24
    03279 E021      LDI	R18,1
    0327A E003      LDI	R16,3
    0327B 940E 39CE CALL	_LCD_const_disp
(0333) 			 LCD_const_disp(4,1,L03);
    0327D EC8F      LDI	R24,0xCF
    0327E E092      LDI	R25,2
    0327F 8399      STD	Y+1,R25
    03280 8388      ST	Y,R24
    03281 E021      LDI	R18,1
    03282 E004      LDI	R16,4
    03283 940E 39CE CALL	_LCD_const_disp
(0334) 			 } 
    03285 C02A      RJMP	0x32B0
(0335) 			 else {
(0336) 			 LCD_const_disp(3,1,L03);
    03286 EC8F      LDI	R24,0xCF
    03287 E092      LDI	R25,2
    03288 8399      STD	Y+1,R25
    03289 8388      ST	Y,R24
    0328A E021      LDI	R18,1
    0328B E003      LDI	R16,3
    0328C 940E 39CE CALL	_LCD_const_disp
(0337) 			 }
(0338) 			 break;
    0328E C021      RJMP	0x32B0
(0339) 			 case 1: 
(0340) 			 LCD_const_disp(2,1,L11);
    0328F E182      LDI	R24,0x12
    03290 E093      LDI	R25,3
    03291 8399      STD	Y+1,R25
    03292 8388      ST	Y,R24
    03293 E021      LDI	R18,1
    03294 E002      LDI	R16,2
    03295 940E 39CE CALL	_LCD_const_disp
(0341) 			 LCD_const_disp(3,1,L12);
    03297 E284      LDI	R24,0x24
    03298 E093      LDI	R25,3
    03299 8399      STD	Y+1,R25
    0329A 8388      ST	Y,R24
    0329B E021      LDI	R18,1
    0329C E003      LDI	R16,3
    0329D 940E 39CE CALL	_LCD_const_disp
(0342) 			 LCD_const_disp(3,1,L13);
    0329F EA89      LDI	R24,0xA9
    032A0 E092      LDI	R25,2
    032A1 8399      STD	Y+1,R25
    032A2 8388      ST	Y,R24
    032A3 E021      LDI	R18,1
    032A4 E003      LDI	R16,3
    032A5 940E 39CE CALL	_LCD_const_disp
(0343) 			 break ;
    032A7 C008      RJMP	0x32B0
(0344) 			 case 2 :
(0345) 			 LCD_const_disp(2,1,L21);
    032A8 E386      LDI	R24,0x36
    032A9 E093      LDI	R25,3
    032AA 8399      STD	Y+1,R25
    032AB 8388      ST	Y,R24
    032AC E021      LDI	R18,1
    032AD E002      LDI	R16,2
    032AE 940E 39CE CALL	_LCD_const_disp
(0346) 			 break;
(0347) 			 default : ;
(0348) 		} //end switch
(0349) 	}  //end if
    032B0 9622      ADIW	R28,2
    032B1 940C 4191 JMP	pop_xgsetF00C
(0350) }
(0351) char * GUI_get_date(void) {  
(0352)   //格式12年12月11日19:00:00
(0353)     GUI_date[0]=Result.Date[4]; 
_GUI_get_date:
    032B3 9020 058A LDS	R2,Result+26
    032B5 9220 0345 STS	GUI_date,R2
(0354)     GUI_date[1]=Result.Date[5];
    032B7 9020 058B LDS	R2,Result+27
    032B9 9220 0346 STS	GUI_date+1,R2
(0355)     GUI_date[4]=Result.Date[6];
    032BB 9020 058C LDS	R2,Result+28
    032BD 9220 0349 STS	GUI_date+4,R2
(0356)     GUI_date[5]=Result.Date[7];
    032BF 9020 058D LDS	R2,Result+29
    032C1 9220 034A STS	GUI_date+5,R2
(0357)     GUI_date[8]=Result.Time[0];
    032C3 9020 058F LDS	R2,Result+31
    032C5 9220 034D STS	GUI_date+8,R2
(0358)     GUI_date[9]=Result.Time[1];
    032C7 9020 0590 LDS	R2,Result+32
    032C9 9220 034E STS	GUI_date+9,R2
(0359)     GUI_date[11]=Result.Time[4];
    032CB 9020 0593 LDS	R2,Result+35
    032CD 9220 0350 STS	GUI_date+11,R2
(0360)     GUI_date[12]=Result.Time[5];
    032CF 9020 0594 LDS	R2,Result+36
    032D1 9220 0351 STS	GUI_date+12,R2
(0361)     GUI_date[14]=Result.Time[8];
    032D3 9020 0597 LDS	R2,Result+39
    032D5 9220 0353 STS	GUI_date+14,R2
(0362)     GUI_date[15]=Result.Time[9];
    032D7 9020 0598 LDS	R2,Result+40
    032D9 9220 0354 STS	GUI_date+15,R2
(0363)     GUI_date[16]='\0';
    032DB 2422      CLR	R2
    032DC 9220 0355 STS	GUI_date+16,R2
(0364)     return GUI_date;
    032DE E405      LDI	R16,0x45
    032DF E013      LDI	R17,3
    032E0 9508      RET
_GUI_set_time:
  GUI_down             --> Y,+5
  GUI_up               --> Y,+2
  pT                   --> R14
  ary                  --> R12
  p                    --> Y,+10
  i                    --> R20
  keyc                 --> R22
  pD                   --> Y,+8
    032E1 940E 416B CALL	push_xgsetF0FC
    032E3 972B      SBIW	R28,0xB
(0365) }
(0366) //设置时间 菜单 
(0367) void GUI_set_time(void){
(0368)     unsigned char p=2;
    032E4 E082      LDI	R24,2
    032E5 878A      STD	Y+10,R24
(0369) 	char GUI_up[]= "↑";
    032E6 E586      LDI	R24,0x56
    032E7 E093      LDI	R25,3
    032E8 01FE      MOVW	R30,R28
    032E9 9632      ADIW	R30,2
    032EA E003      LDI	R16,3
    032EB E010      LDI	R17,0
    032EC 93FA      ST	-Y,R31
    032ED 93EA      ST	-Y,R30
    032EE 939A      ST	-Y,R25
    032EF 938A      ST	-Y,R24
    032F0 940E 4212 CALL	asgnblk
(0370) 	char GUI_down[]= "↓";
    032F2 E589      LDI	R24,0x59
    032F3 E093      LDI	R25,3
    032F4 01FE      MOVW	R30,R28
    032F5 9635      ADIW	R30,5
    032F6 E003      LDI	R16,3
    032F7 E010      LDI	R17,0
    032F8 93FA      ST	-Y,R31
    032F9 93EA      ST	-Y,R30
    032FA 939A      ST	-Y,R25
    032FB 938A      ST	-Y,R24
    032FC 940E 4212 CALL	asgnblk
(0371) 	char *pD=NULL,*pT=NULL;
    032FE 2400      CLR	R0
    032FF 2411      CLR	R1
    03300 8619      STD	Y+9,R1
    03301 8608      STD	Y+8,R0
(0372) 	char *ary=GUI_up;
    03302 01CE      MOVW	R24,R28
    03303 9602      ADIW	R24,2
    03304 016C      MOVW	R12,R24
(0373) 	unsigned char i=0,keyc=NO_KEY;
    03305 2744      CLR	R20
    03306 2766      CLR	R22
(0374) 	LCD_CLR(); //清屏
    03307 940E 3A74 CALL	_LCD_CLR
(0375) 	pD="2012年12月31日\0";
    03309 ED84      LDI	R24,0xD4
    0330A E093      LDI	R25,3
    0330B 8799      STD	Y+9,R25
    0330C 8788      STD	Y+8,R24
(0376) 	pT=Result.Time;
    0330D E88F      LDI	R24,0x8F
    0330E E095      LDI	R25,5
    0330F 017C      MOVW	R14,R24
(0377) 	LCD_const_disp(1,1,"时间设置:       ");
    03310 EC83      LDI	R24,0xC3
    03311 E093      LDI	R25,3
    03312 8399      STD	Y+1,R25
    03313 8388      ST	Y,R24
    03314 E021      LDI	R18,1
    03315 E001      LDI	R16,1
    03316 940E 39CE CALL	_LCD_const_disp
(0378) 	LCD_const_disp(4,7,"保存");
    03318 EB8E      LDI	R24,0xBE
    03319 E093      LDI	R25,3
    0331A 8399      STD	Y+1,R25
    0331B 8388      ST	Y,R24
    0331C E027      LDI	R18,7
    0331D E004      LDI	R16,4
    0331E 940E 39CE CALL	_LCD_const_disp
(0379) 	LCD_var_disp(3,p,ary);
    03320 82D9      STD	Y+1,R13
    03321 82C8      ST	Y,R12
    03322 852A      LDD	R18,Y+10
    03323 E003      LDI	R16,3
    03324 940E 39FB CALL	_LCD_var_disp
(0380) 	LCD_var_disp(2,1,pD);
    03326 8408      LDD	R0,Y+8
    03327 8419      LDD	R1,Y+9
    03328 8219      STD	Y+1,R1
    03329 8208      ST	Y,R0
    0332A E021      LDI	R18,1
    0332B E002      LDI	R16,2
    0332C 940E 39FB CALL	_LCD_var_disp
(0381) 	LCD_var_disp(4,1,pT);
    0332E 82F9      STD	Y+1,R15
    0332F 82E8      ST	Y,R14
    03330 E021      LDI	R18,1
    03331 E004      LDI	R16,4
    03332 940E 39FB CALL	_LCD_var_disp
(0382) 	delayms(250);
    03334 EF0A      LDI	R16,0xFA
    03335 E010      LDI	R17,0
    03336 940E 2413 CALL	_delayms
    03338 C1EC      RJMP	0x3525
(0383) 	while(1){
(0384) 	    keyc=kbscan();
    03339 940E 3FBD CALL	_kbscan
    0333B 2F60      MOV	R22,R16
(0385) 		pD[2]=Result.Date[2];
    0333C 9020 0588 LDS	R2,Result+24
    0333E 85E8      LDD	R30,Y+8
    0333F 85F9      LDD	R31,Y+9
    03340 8222      STD	Z+2,R2
(0386) 		pD[3]=Result.Date[3];
    03341 9020 0589 LDS	R2,Result+25
    03343 8223      STD	Z+3,R2
(0387) 		pD[6]=Result.Date[4];
    03344 9020 058A LDS	R2,Result+26
    03346 8226      STD	Z+6,R2
(0388) 		pD[7]=Result.Date[5];
    03347 9020 058B LDS	R2,Result+27
    03349 8227      STD	Z+7,R2
(0389) 		pD[10]=Result.Date[6];
    0334A 9020 058C LDS	R2,Result+28
    0334C 8622      STD	Z+10,R2
(0390) 		pD[11]=Result.Date[7];  
    0334D 9020 058D LDS	R2,Result+29
    0334F 8623      STD	Z+11,R2
(0391) 
(0392) 		switch(i){
    03350 2EA4      MOV	R10,R20
    03351 24BB      CLR	R11
    03352 20AA      TST	R10
    03353 F411      BNE	0x3356
    03354 20BB      TST	R11
    03355 F0D9      BEQ	0x3371
    03356 01C5      MOVW	R24,R10
    03357 3081      CPI	R24,1
    03358 E0E0      LDI	R30,0
    03359 079E      CPC	R25,R30
    0335A F409      BNE	0x335C
    0335B C049      RJMP	0x33A5
    0335C 3082      CPI	R24,2
    0335D E0E0      LDI	R30,0
    0335E 079E      CPC	R25,R30
    0335F F409      BNE	0x3361
    03360 C07D      RJMP	0x33DE
    03361 3083      CPI	R24,3
    03362 E0E0      LDI	R30,0
    03363 079E      CPC	R25,R30
    03364 F409      BNE	0x3366
    03365 C0C1      RJMP	0x3427
    03366 3084      CPI	R24,4
    03367 E0E0      LDI	R30,0
    03368 079E      CPC	R25,R30
    03369 F409      BNE	0x336B
    0336A C0F6      RJMP	0x3461
    0336B 3085      CPI	R24,5
    0336C E0E0      LDI	R30,0
    0336D 079E      CPC	R25,R30
    0336E F409      BNE	0x3370
    0336F C12A      RJMP	0x349A
    03370 C165      RJMP	0x34D6
(0393)             case 0: p=2;ary=GUI_up;  //年
    03371 E082      LDI	R24,2
    03372 878A      STD	Y+10,R24
    03373 01CE      MOVW	R24,R28
    03374 9602      ADIW	R24,2
    03375 016C      MOVW	R12,R24
(0394) 		 	  	 if(keyc==up){
    03376 316E      CPI	R22,0x1E
    03377 F491      BNE	0x338A
(0395) 				     if(time_buf[1]<0x99){ 
    03378 9180 0515 LDS	R24,time_buf+1
    0337A 3989      CPI	R24,0x99
    0337B F008      BCS	0x337D
    0337C C159      RJMP	0x34D6
(0396) 					     time_buf[1]++;
    0337D 5F8F      SUBI	R24,0xFF
    0337E 9380 0515 STS	time_buf+1,R24
(0397) 						 if((time_buf[1]&0x0f)==0x0a) 
    03380 708F      ANDI	R24,0xF
    03381 308A      CPI	R24,0xA
    03382 F009      BEQ	0x3384
    03383 C152      RJMP	0x34D6
(0398) 						     time_buf[1]=time_buf[1]+6;
    03384 9180 0515 LDS	R24,time_buf+1
    03386 5F8A      SUBI	R24,0xFA
    03387 9380 0515 STS	time_buf+1,R24
(0399) 					 }
(0400) 												     
(0401) 				}				  
    03389 C14C      RJMP	0x34D6
(0402)  					        
(0403) 			    else if(keyc==down){ 
    0338A 316D      CPI	R22,0x1D
    0338B F4A1      BNE	0x33A0
(0404) 				    if(time_buf[1]>0x00){
    0338C E080      LDI	R24,0
    0338D 9020 0515 LDS	R2,time_buf+1
    0338F 1582      CP	R24,R2
    03390 F008      BCS	0x3392
    03391 C144      RJMP	0x34D6
(0405) 				        time_buf[1]--;
    03392 2D82      MOV	R24,R2
    03393 5081      SUBI	R24,1
    03394 9380 0515 STS	time_buf+1,R24
(0406) 						if((time_buf[1]&0x0f)==0x0f) 
    03396 708F      ANDI	R24,0xF
    03397 308F      CPI	R24,0xF
    03398 F009      BEQ	0x339A
    03399 C13C      RJMP	0x34D6
(0407) 						    time_buf[1]=time_buf[1]-6;
    0339A 9180 0515 LDS	R24,time_buf+1
    0339C 5086      SUBI	R24,6
    0339D 9380 0515 STS	time_buf+1,R24
(0408) 		 	  	 		 }
(0409) 												   
(0410) 					}			   		
    0339F C136      RJMP	0x34D6
(0411) 				else if(keyc==right) {i=1;}
    033A0 3167      CPI	R22,0x17
    033A1 F009      BEQ	0x33A3
    033A2 C133      RJMP	0x34D6
    033A3 E041      LDI	R20,1
(0412) 				break;
    033A4 C131      RJMP	0x34D6
(0413) 		 case 1:p=4;ary=GUI_up;  //月
    033A5 E084      LDI	R24,4
    033A6 878A      STD	Y+10,R24
    033A7 01CE      MOVW	R24,R28
    033A8 9602      ADIW	R24,2
    033A9 016C      MOVW	R12,R24
(0414) 		  	  	if(keyc==up){
    033AA 316E      CPI	R22,0x1E
    033AB F499      BNE	0x33BF
(0415) 				    if(time_buf[2]<0x12){  
    033AC 9180 0516 LDS	R24,time_buf+2
    033AE 3182      CPI	R24,0x12
    033AF F460      BCC	0x33BC
(0416) 					    time_buf[2]++;	
    033B0 5F8F      SUBI	R24,0xFF
    033B1 9380 0516 STS	time_buf+2,R24
(0417) 						if((time_buf[2]&0x0f)==0x0a) time_buf[2]+=6;
    033B3 708F      ANDI	R24,0xF
    033B4 308A      CPI	R24,0xA
    033B5 F449      BNE	0x33BF
    033B6 9180 0516 LDS	R24,time_buf+2
    033B8 5F8A      SUBI	R24,0xFA
    033B9 9380 0516 STS	time_buf+2,R24
(0418) 					}
    033BB C003      RJMP	0x33BF
(0419) 					else 
(0420) 					    time_buf[2]=0x01;
    033BC E081      LDI	R24,1
    033BD 9380 0516 STS	time_buf+2,R24
(0421) 				}						 
(0422) 				if(keyc==down){ 
    033BF 316D      CPI	R22,0x1D
    033C0 F4A9      BNE	0x33D6
(0423) 				    if(time_buf[2]>0x01){  
    033C1 E081      LDI	R24,1
    033C2 9020 0516 LDS	R2,time_buf+2
    033C4 1582      CP	R24,R2
    033C5 F468      BCC	0x33D3
(0424) 					    time_buf[2]--;	
    033C6 2D82      MOV	R24,R2
    033C7 5081      SUBI	R24,1
    033C8 9380 0516 STS	time_buf+2,R24
(0425) 						if((time_buf[2]&0x0f)==0x0f) 
    033CA 708F      ANDI	R24,0xF
    033CB 308F      CPI	R24,0xF
    033CC F449      BNE	0x33D6
(0426) 						    time_buf[2]-=6;
    033CD 9180 0516 LDS	R24,time_buf+2
    033CF 5086      SUBI	R24,6
    033D0 9380 0516 STS	time_buf+2,R24
(0427) 			  		}
    033D2 C003      RJMP	0x33D6
(0428) 				    else 
(0429) 					    time_buf[2]=0x12;						
    033D3 E182      LDI	R24,0x12
    033D4 9380 0516 STS	time_buf+2,R24
(0430) 				}						 							
(0431) 				if(keyc==left){
    033D6 316B      CPI	R22,0x1B
    033D7 F409      BNE	0x33D9
(0432) 				    i=0;   
    033D8 2744      CLR	R20
(0433) 				}									
(0434) 				if(keyc==right){
    033D9 3167      CPI	R22,0x17
    033DA F009      BEQ	0x33DC
    033DB C0FA      RJMP	0x34D6
(0435) 				    i=2;   
    033DC E042      LDI	R20,2
(0436) 				}  
(0437) 				break;
    033DD C0F8      RJMP	0x34D6
(0438) 	 	 case 2: p=6;ary=GUI_up;
    033DE E086      LDI	R24,6
    033DF 878A      STD	Y+10,R24
    033E0 01CE      MOVW	R24,R28
    033E1 9602      ADIW	R24,2
    033E2 016C      MOVW	R12,R24
(0439) 		 	  	 if(keyc==up){ 
    033E3 316E      CPI	R22,0x1E
    033E4 F519      BNE	0x3408
(0440) 				     if(time_buf[3]<0x31){ 
    033E5 9180 0517 LDS	R24,time_buf+3
    033E7 3381      CPI	R24,0x31
    033E8 F5B0      BCC	0x341F
(0441) 				         time_buf[3]++;
    033E9 5F8F      SUBI	R24,0xFF
    033EA 9380 0517 STS	time_buf+3,R24
(0442) 						 if ((time_buf[3]&0x0f)==0x0a) time_buf[3]=time_buf[3]+6;
    033EC 708F      ANDI	R24,0xF
    033ED 308A      CPI	R24,0xA
    033EE F429      BNE	0x33F4
    033EF 9180 0517 LDS	R24,time_buf+3
    033F1 5F8A      SUBI	R24,0xFA
    033F2 9380 0517 STS	time_buf+3,R24
(0443) 						 if(  //2 4 6 9 11 月最大30天
(0444) 						  ( ((time_buf[2]==0x02) || (time_buf[2]==0x04)|| (time_buf[2]==0x06)||
    033F4 9180 0516 LDS	R24,time_buf+2
    033F6 3082      CPI	R24,2
    033F7 F041      BEQ	0x3400
    033F8 3084      CPI	R24,4
    033F9 F031      BEQ	0x3400
    033FA 3086      CPI	R24,6
    033FB F021      BEQ	0x3400
    033FC 3089      CPI	R24,0x9
    033FD F011      BEQ	0x3400
    033FE 3181      CPI	R24,0x11
    033FF F4F9      BNE	0x341F
    03400 9180 0517 LDS	R24,time_buf+3
    03402 3381      CPI	R24,0x31
    03403 F4D9      BNE	0x341F
(0445) 						  (time_buf[2]==0x09)||(time_buf[2]==0x11))&&(time_buf[3]==0x31))){
(0446) 						      time_buf[3]=0x30;
    03404 E380      LDI	R24,0x30
    03405 9380 0517 STS	time_buf+3,R24
(0447) 						}
(0448) 				     }
(0449)  									  
(0450)  				 }
    03407 C017      RJMP	0x341F
(0451) 			     else if(keyc==down){ 
    03408 316D      CPI	R22,0x1D
    03409 F4A9      BNE	0x341F
(0452) 				      if(time_buf[3]>0x01){  
    0340A E081      LDI	R24,1
    0340B 9020 0517 LDS	R2,time_buf+3
    0340D 1582      CP	R24,R2
    0340E F468      BCC	0x341C
(0453) 					     time_buf[3]--;
    0340F 2D82      MOV	R24,R2
    03410 5081      SUBI	R24,1
    03411 9380 0517 STS	time_buf+3,R24
(0454) 				 	  	 if((time_buf[3]&0x0f)==0x0f) time_buf[3]=time_buf[3]-6;
    03413 708F      ANDI	R24,0xF
    03414 308F      CPI	R24,0xF
    03415 F449      BNE	0x341F
    03416 9180 0517 LDS	R24,time_buf+3
    03418 5086      SUBI	R24,6
    03419 9380 0517 STS	time_buf+3,R24
(0455) 		 	  	 	 }
    0341B C003      RJMP	0x341F
(0456) 					 else time_buf[3]=0x31;						
    0341C E381      LDI	R24,0x31
    0341D 9380 0517 STS	time_buf+3,R24
(0457) 											   
(0458) 				}
(0459) 				if(keyc==left) {i=1;  }						 			   		
    0341F 316B      CPI	R22,0x1B
    03420 F409      BNE	0x3422
    03421 E041      LDI	R20,1
(0460) 				if(keyc==right) {i=3;    }  	
    03422 3167      CPI	R22,0x17
    03423 F009      BEQ	0x3425
    03424 C0B1      RJMP	0x34D6
    03425 E043      LDI	R20,3
(0461) 				break;
    03426 C0AF      RJMP	0x34D6
(0462) 		case 3:p=1;ary=GUI_down;
    03427 2400      CLR	R0
    03428 9403      INC	R0
    03429 860A      STD	Y+10,R0
    0342A 01CE      MOVW	R24,R28
    0342B 9605      ADIW	R24,5
    0342C 016C      MOVW	R12,R24
(0463)  	  	if(keyc==up){ if(time_buf[4]<0x23){  time_buf[4]++;	
    0342D 316E      CPI	R22,0x1E
    0342E F499      BNE	0x3442
    0342F 9180 0518 LDS	R24,time_buf+4
    03431 3283      CPI	R24,0x23
    03432 F460      BCC	0x343F
    03433 5F8F      SUBI	R24,0xFF
    03434 9380 0518 STS	time_buf+4,R24
(0464) 													if((time_buf[4]&0x0f)==0x0a) time_buf[4]+=6;
    03436 708F      ANDI	R24,0xF
    03437 308A      CPI	R24,0xA
    03438 F449      BNE	0x3442
    03439 9180 0518 LDS	R24,time_buf+4
    0343B 5F8A      SUBI	R24,0xFA
    0343C 9380 0518 STS	time_buf+4,R24
(0465) 													 
(0466) 													
(0467) 												 }
    0343E C003      RJMP	0x3442
(0468) 							else time_buf[4]=0x00;
    0343F 2422      CLR	R2
    03440 9220 0518 STS	time_buf+4,R2
(0469) 						  }						 
(0470) 				if(keyc==down){ if(time_buf[4]>0x00){  time_buf[4]--;	
    03442 316D      CPI	R22,0x1D
    03443 F4A9      BNE	0x3459
    03444 E080      LDI	R24,0
    03445 9020 0518 LDS	R2,time_buf+4
    03447 1582      CP	R24,R2
    03448 F468      BCC	0x3456
    03449 2D82      MOV	R24,R2
    0344A 5081      SUBI	R24,1
    0344B 9380 0518 STS	time_buf+4,R24
(0471) 													if((time_buf[4]&0x0f)==0x0f) time_buf[4]-=6;
    0344D 708F      ANDI	R24,0xF
    0344E 308F      CPI	R24,0xF
    0344F F449      BNE	0x3459
    03450 9180 0518 LDS	R24,time_buf+4
    03452 5086      SUBI	R24,6
    03453 9380 0518 STS	time_buf+4,R24
(0472) 													
(0473) 												 }
    03455 C003      RJMP	0x3459
(0474) 							 else time_buf[4]=0x23;						
    03456 E283      LDI	R24,0x23
    03457 9380 0518 STS	time_buf+4,R24
(0475) 						  }	
(0476) 		if(keyc==left ) {i=2;   } 				  
    03459 316B      CPI	R22,0x1B
    0345A F409      BNE	0x345C
    0345B E042      LDI	R20,2
(0477) 		if(keyc==right) {i=4;    } 
    0345C 3167      CPI	R22,0x17
    0345D F009      BEQ	0x345F
    0345E C077      RJMP	0x34D6
    0345F E044      LDI	R20,4
(0478) 		break;						  					 			
    03460 C075      RJMP	0x34D6
(0479)  case 4:p=3;ary=GUI_down;
    03461 E083      LDI	R24,3
    03462 878A      STD	Y+10,R24
    03463 01CE      MOVW	R24,R28
    03464 9605      ADIW	R24,5
    03465 016C      MOVW	R12,R24
(0480)  	  	if(keyc==up){ if(time_buf[5]<0x59){  time_buf[5]++;	
    03466 316E      CPI	R22,0x1E
    03467 F499      BNE	0x347B
    03468 9180 0519 LDS	R24,time_buf+5
    0346A 3589      CPI	R24,0x59
    0346B F460      BCC	0x3478
    0346C 5F8F      SUBI	R24,0xFF
    0346D 9380 0519 STS	time_buf+5,R24
(0481) 											 if((time_buf[5]&0x0f)==0x0a) time_buf[5]+=6;
    0346F 708F      ANDI	R24,0xF
    03470 308A      CPI	R24,0xA
    03471 F449      BNE	0x347B
    03472 9180 0519 LDS	R24,time_buf+5
    03474 5F8A      SUBI	R24,0xFA
    03475 9380 0519 STS	time_buf+5,R24
(0482) 										  }
    03477 C003      RJMP	0x347B
(0483) 					  else time_buf[5]=0x00;
    03478 2422      CLR	R2
    03479 9220 0519 STS	time_buf+5,R2
(0484) 					}						 
(0485) 		if(keyc==down){ if(time_buf[5]>0x00){  time_buf[5]--;	
    0347B 316D      CPI	R22,0x1D
    0347C F4A9      BNE	0x3492
    0347D E080      LDI	R24,0
    0347E 9020 0519 LDS	R2,time_buf+5
    03480 1582      CP	R24,R2
    03481 F468      BCC	0x348F
    03482 2D82      MOV	R24,R2
    03483 5081      SUBI	R24,1
    03484 9380 0519 STS	time_buf+5,R24
(0486) 												if((time_buf[5]&0x0f)==0x0f) time_buf[5]-=6;
    03486 708F      ANDI	R24,0xF
    03487 308F      CPI	R24,0xF
    03488 F449      BNE	0x3492
    03489 9180 0519 LDS	R24,time_buf+5
    0348B 5086      SUBI	R24,6
    0348C 9380 0519 STS	time_buf+5,R24
(0487) 											}
    0348E C003      RJMP	0x3492
(0488) 						else time_buf[5]=0x59;						
    0348F E589      LDI	R24,0x59
    03490 9380 0519 STS	time_buf+5,R24
(0489) 					  }
(0490) 		if(keyc==left ) {i=3;    } 		  						 								  			
    03492 316B      CPI	R22,0x1B
    03493 F409      BNE	0x3495
    03494 E043      LDI	R20,3
(0491)  		if(keyc==right) {i=5;   }	
    03495 3167      CPI	R22,0x17
    03496 F009      BEQ	0x3498
    03497 C03E      RJMP	0x34D6
    03498 E045      LDI	R20,5
(0492) 		break;			   
    03499 C03C      RJMP	0x34D6
(0493)  case 5:p=5;ary=GUI_down;
    0349A E085      LDI	R24,5
    0349B 878A      STD	Y+10,R24
    0349C 01CE      MOVW	R24,R28
    0349D 9605      ADIW	R24,5
    0349E 016C      MOVW	R12,R24
(0494)  	  	if(keyc==up){ if(time_buf[6]<0x59){  time_buf[6]++;	
    0349F 316E      CPI	R22,0x1E
    034A0 F499      BNE	0x34B4
    034A1 9180 051A LDS	R24,time_buf+6
    034A3 3589      CPI	R24,0x59
    034A4 F460      BCC	0x34B1
    034A5 5F8F      SUBI	R24,0xFF
    034A6 9380 051A STS	time_buf+6,R24
(0495) 											 if((time_buf[6]&0x0f)==0x0a) time_buf[6]+=6;
    034A8 708F      ANDI	R24,0xF
    034A9 308A      CPI	R24,0xA
    034AA F449      BNE	0x34B4
    034AB 9180 051A LDS	R24,time_buf+6
    034AD 5F8A      SUBI	R24,0xFA
    034AE 9380 051A STS	time_buf+6,R24
(0496) 										 }
    034B0 C003      RJMP	0x34B4
(0497) 					  else time_buf[6]=0x00;
    034B1 2422      CLR	R2
    034B2 9220 051A STS	time_buf+6,R2
(0498) 					}						 
(0499) 		if(keyc==down){ if(time_buf[6]>0x00){  time_buf[6]--;	
    034B4 316D      CPI	R22,0x1D
    034B5 F4A9      BNE	0x34CB
    034B6 E080      LDI	R24,0
    034B7 9020 051A LDS	R2,time_buf+6
    034B9 1582      CP	R24,R2
    034BA F468      BCC	0x34C8
    034BB 2D82      MOV	R24,R2
    034BC 5081      SUBI	R24,1
    034BD 9380 051A STS	time_buf+6,R24
(0500) 						if((time_buf[6]&0x0f)==0x0f) time_buf[6]-=6;
    034BF 708F      ANDI	R24,0xF
    034C0 308F      CPI	R24,0xF
    034C1 F449      BNE	0x34CB
    034C2 9180 051A LDS	R24,time_buf+6
    034C4 5086      SUBI	R24,6
    034C5 9380 051A STS	time_buf+6,R24
(0501) 					  }
    034C7 C003      RJMP	0x34CB
(0502) 		else time_buf[6]=0x59;		}				
    034C8 E589      LDI	R24,0x59
    034C9 9380 051A STS	time_buf+6,R24
(0503) 		if(keyc==left ) {i=4;    } 		  				 														   
    034CB 316B      CPI	R22,0x1B
    034CC F409      BNE	0x34CE
    034CD E044      LDI	R20,4
(0504) 		if(keyc==right) {i=6;p=1;ary=NULL;}  
    034CE 3167      CPI	R22,0x17
    034CF F431      BNE	0x34D6
    034D0 E046      LDI	R20,6
    034D1 2400      CLR	R0
    034D2 9403      INC	R0
    034D3 860A      STD	Y+10,R0
    034D4 24CC      CLR	R12
    034D5 24DD      CLR	R13
(0505) 		break;           
(0506) 							 
(0507) 		 }//endcase
(0508)  		 dateRefresh(1);
    034D6 E001      LDI	R16,1
    034D7 D18B      RCALL	_dateRefresh
(0509) 		 
(0510) 		 LCD_const_disp(3,1,"                "); //清空箭头 
    034D8 EA8D      LDI	R24,0xAD
    034D9 E093      LDI	R25,3
    034DA 8399      STD	Y+1,R25
    034DB 8388      ST	Y,R24
    034DC E021      LDI	R18,1
    034DD E003      LDI	R16,3
    034DE 940E 39CE CALL	_LCD_const_disp
(0511)  		 LCD_var_disp(3,p,ary); //显示箭头 
    034E0 82D9      STD	Y+1,R13
    034E1 82C8      ST	Y,R12
    034E2 852A      LDD	R18,Y+10
    034E3 E003      LDI	R16,3
    034E4 940E 39FB CALL	_LCD_var_disp
(0512)  		 LCD_var_disp(2,1,pD);  //显示日期
    034E6 8408      LDD	R0,Y+8
    034E7 8419      LDD	R1,Y+9
    034E8 8219      STD	Y+1,R1
    034E9 8208      ST	Y,R0
    034EA E021      LDI	R18,1
    034EB E002      LDI	R16,2
    034EC 940E 39FB CALL	_LCD_var_disp
(0513)  		 LCD_var_disp(4,1,pT);  //显示时间
    034EE 82F9      STD	Y+1,R15
    034EF 82E8      ST	Y,R14
    034F0 E021      LDI	R18,1
    034F1 E004      LDI	R16,4
    034F2 940E 39FB CALL	_LCD_var_disp
(0514)  if(keyc==lright) {		  
    034F4 3967      CPI	R22,0x97
    034F5 F479      BNE	0x3505
(0515)  		  LCD_const_disp(3,1,"        放弃修改"); 
    034F6 E98C      LDI	R24,0x9C
    034F7 E093      LDI	R25,3
    034F8 8399      STD	Y+1,R25
    034F9 8388      ST	Y,R24
    034FA E021      LDI	R18,1
    034FB E003      LDI	R16,3
    034FC 940E 39CE CALL	_LCD_const_disp
(0516) 		  delayms(500);
    034FE EF04      LDI	R16,0xF4
    034FF E011      LDI	R17,1
    03500 940E 2413 CALL	_delayms
(0517) 		  LCD_CLR(); //清屏
    03502 940E 3A74 CALL	_LCD_CLR
(0518) 		  return ;} 
    03504 C021      RJMP	0x3526
(0519)  keyc=NO_KEY;
    03505 2766      CLR	R22
(0520)  if(i==6){    //各值改变完成后 显示已保存 清屏 返回
    03506 3046      CPI	R20,6
    03507 F4C9      BNE	0x3521
(0521) 		  ds1302_write_time(); 
    03508 940E 3F70 CALL	_ds1302_write_time
(0522)           LCD_const_disp(4,7,"    ");		  
    0350A E987      LDI	R24,0x97
    0350B E093      LDI	R25,3
    0350C 8399      STD	Y+1,R25
    0350D 8388      ST	Y,R24
    0350E E027      LDI	R18,7
    0350F E004      LDI	R16,4
    03510 940E 39CE CALL	_LCD_const_disp
(0523) 		  LCD_const_disp(3,1,"          已保存"); 
    03512 E886      LDI	R24,0x86
    03513 E093      LDI	R25,3
    03514 8399      STD	Y+1,R25
    03515 8388      ST	Y,R24
    03516 E021      LDI	R18,1
    03517 E003      LDI	R16,3
    03518 940E 39CE CALL	_LCD_const_disp
(0524) 		  delayms(300);
    0351A E20C      LDI	R16,0x2C
    0351B E011      LDI	R17,1
    0351C 940E 2413 CALL	_delayms
(0525) 		  LCD_CLR(); //清屏
    0351E 940E 3A74 CALL	_LCD_CLR
(0526) 		  return ;
    03520 C005      RJMP	0x3526
(0527) 		  }
(0528)  delayms(2);	  
    03521 E002      LDI	R16,2
    03522 E010      LDI	R17,0
    03523 940E 2413 CALL	_delayms
    03525 CE13      RJMP	0x3339
    03526 962B      ADIW	R28,0xB
    03527 940C 4160 JMP	pop_xgsetF0FC
_GUI_readback:
  index                --> Y,+3
  page                 --> R10
  key                  --> R14
  buf                  --> R12
    03529 940E 416B CALL	push_xgsetF0FC
    0352B 0168      MOVW	R12,R16
    0352C 9727      SBIW	R28,7
(0529) }//endwhile(1)
(0530) }
(0531) void GUI_readback(char *buf){
(0532)     char key=0;
    0352D 24EE      CLR	R14
(0533) 	char page=0;
    0352E 24AA      CLR	R10
(0534) 	long index=Result.Index;
    0352F 9040 057C LDS	R4,Result+12
    03531 9050 057D LDS	R5,Result+13
    03533 9020 057A LDS	R2,Result+10
    03535 9030 057B LDS	R3,Result+11
    03537 822B      STD	Y+3,R2
    03538 823C      STD	Y+4,R3
    03539 824D      STD	Y+5,R4
    0353A 825E      STD	Y+6,R5
(0535) 	LCD_CLR(); //清屏
    0353B 940E 3A74 CALL	_LCD_CLR
(0536) 	LCD_const_disp(1,1,"菜单/ 检测");
    0353D EC82      LDI	R24,0xC2
    0353E E094      LDI	R25,4
    0353F 8399      STD	Y+1,R25
    03540 8388      ST	Y,R24
    03541 E021      LDI	R18,1
    03542 E001      LDI	R16,1
    03543 940E 39CE CALL	_LCD_const_disp
(0537)     LCD_const_disp(2,3,"最后一次");		 
    03545 E78D      LDI	R24,0x7D
    03546 E093      LDI	R25,3
    03547 8399      STD	Y+1,R25
    03548 8388      ST	Y,R24
    03549 E023      LDI	R18,3
    0354A E002      LDI	R16,2
    0354B 940E 39CE CALL	_LCD_const_disp
(0538) 	LCD_const_disp(3,3,"按顺序");
    0354D E786      LDI	R24,0x76
    0354E E093      LDI	R25,3
    0354F 8399      STD	Y+1,R25
    03550 8388      ST	Y,R24
    03551 E023      LDI	R18,3
    03552 E003      LDI	R16,3
    03553 940E 39CE CALL	_LCD_const_disp
    03555 C061      RJMP	0x35B7
(0539) 	//<<菜单/检测/手（自）动>>
(0540) while(1){
(0541)  	key=kbscan();
    03556 940E 3FBD CALL	_kbscan
    03558 2EE0      MOV	R14,R16
(0542) 	//上键短按 选择
(0543) 	if(key==up || key ==down){
    03559 2D8E      MOV	R24,R14
    0355A 310E      CPI	R16,0x1E
    0355B F011      BEQ	0x355E
    0355C 310D      CPI	R16,0x1D
    0355D F5E1      BNE	0x359A
(0544) 	    if(config.readMode == 0){
    0355E 9020 07F3 LDS	R2,config+19
    03560 2022      TST	R2
    03561 F501      BNE	0x3582
(0545) 		    config.readMode=1;
    03562 E081      LDI	R24,1
    03563 9380 07F3 STS	config+19,R24
(0546) 			Set_White(1,2,8,0);
    03565 2422      CLR	R2
    03566 822A      STD	Y+2,R2
    03567 E088      LDI	R24,0x8
    03568 8388      ST	Y,R24
    03569 E022      LDI	R18,2
    0356A E001      LDI	R16,1
    0356B 940E 3AFE CALL	_Set_White
(0547)  			Set_White(1,3,8,1);
    0356D E081      LDI	R24,1
    0356E 838A      STD	Y+2,R24
    0356F E088      LDI	R24,0x8
    03570 8388      ST	Y,R24
    03571 E023      LDI	R18,3
    03572 E001      LDI	R16,1
    03573 940E 3AFE CALL	_Set_White
(0548) 			index=Result.Index;	
    03575 9040 057C LDS	R4,Result+12
    03577 9050 057D LDS	R5,Result+13
    03579 9020 057A LDS	R2,Result+10
    0357B 9030 057B LDS	R3,Result+11
    0357D 822B      STD	Y+3,R2
    0357E 823C      STD	Y+4,R3
    0357F 824D      STD	Y+5,R4
    03580 825E      STD	Y+6,R5
(0549) 		}
    03581 C018      RJMP	0x359A
(0550) 		else {
(0551) 		    config.readMode=0;
    03582 2422      CLR	R2
    03583 9220 07F3 STS	config+19,R2
(0552) 			Set_White(1,2,8,1);
    03585 E081      LDI	R24,1
    03586 838A      STD	Y+2,R24
    03587 E088      LDI	R24,0x8
    03588 8388      ST	Y,R24
    03589 E022      LDI	R18,2
    0358A E001      LDI	R16,1
    0358B 940E 3AFE CALL	_Set_White
(0553)  			Set_White(1,3,8,0);
    0358D 2422      CLR	R2
    0358E 822A      STD	Y+2,R2
    0358F E088      LDI	R24,0x8
    03590 8388      ST	Y,R24
    03591 E023      LDI	R18,3
    03592 E001      LDI	R16,1
    03593 940E 3AFE CALL	_Set_White
(0554) 			index=0;
    03595 E080      LDI	R24,0
    03596 838B      STD	Y+3,R24
    03597 838C      STD	Y+4,R24
    03598 838D      STD	Y+5,R24
    03599 838E      STD	Y+6,R24
(0555) 		}
(0556) 		
(0557) 	}
(0558) 	//左键短按  进入
(0559) 	if(key == left) {
    0359A 2D8E      MOV	R24,R14
    0359B 318B      CPI	R24,0x1B
    0359C F4A9      BNE	0x35B2
(0560) 		Set_White(1,2,8,1);
    0359D E081      LDI	R24,1
    0359E 838A      STD	Y+2,R24
    0359F E088      LDI	R24,0x8
    035A0 8388      ST	Y,R24
    035A1 E022      LDI	R18,2
    035A2 E001      LDI	R16,1
    035A3 940E 3AFE CALL	_Set_White
(0561)  		Set_White(1,3,8,1);
    035A5 E081      LDI	R24,1
    035A6 838A      STD	Y+2,R24
    035A7 E088      LDI	R24,0x8
    035A8 8388      ST	Y,R24
    035A9 E023      LDI	R18,3
    035AA E001      LDI	R16,1
    035AB 940E 3AFE CALL	_Set_White
(0562) 		delayms(100);
    035AD E604      LDI	R16,0x64
    035AE E010      LDI	R17,0
    035AF 940E 2413 CALL	_delayms
(0563) 		break ;		
    035B1 C006      RJMP	0x35B8
(0564) 	}
(0565) 	//右键短按  返回
(0566) 	if(key == right) {
    035B2 2D8E      MOV	R24,R14
    035B3 3187      CPI	R24,0x17
    035B4 F409      BNE	0x35B6
(0567) 		return ;		
    035B5 C08D      RJMP	0x3643
(0568) 	}
(0569) 	key=0;
    035B6 24EE      CLR	R14
    035B7 CF9E      RJMP	0x3556
(0570) } //end of while
(0571) ReadSDFile(index,buf);
    035B8 0196      MOVW	R18,R12
    035B9 810B      LDD	R16,Y+3
    035BA 811C      LDD	R17,Y+4
    035BB 940E 265F CALL	_ReadSDFile
(0572) CharToStruct();
    035BD 940E 2A0C CALL	_CharToStruct
    035BF C082      RJMP	0x3642
(0573) while(1){
(0574) 	key=kbscan();
    035C0 940E 3FBD CALL	_kbscan
    035C2 2EE0      MOV	R14,R16
(0575) 	if(key != 0) beep(0,1);
    035C3 2300      TST	R16
    035C4 F021      BEQ	0x35C9
    035C5 E021      LDI	R18,1
    035C6 2700      CLR	R16
    035C7 940E 3D49 CALL	_beep
(0576) 	dateRefresh(0);
    035C9 2700      CLR	R16
    035CA D098      RCALL	_dateRefresh
(0577) 	_GUI_datashow(page);
    035CB 2D0A      MOV	R16,R10
    035CC DADA      RCALL	__GUI_datashow
(0578) 	if( key==left ){ //按left键下一条
    035CD 2D8E      MOV	R24,R14
    035CE 318B      CPI	R24,0x1B
    035CF F541      BNE	0x35F8
(0579) pre_item:
(0580) 		if(index < Result.Index){
    035D0 9040 057C LDS	R4,Result+12
    035D2 9050 057D LDS	R5,Result+13
    035D4 9020 057A LDS	R2,Result+10
    035D6 9030 057B LDS	R3,Result+11
    035D8 806B      LDD	R6,Y+3
    035D9 807C      LDD	R7,Y+4
    035DA 808D      LDD	R8,Y+5
    035DB 809E      LDD	R9,Y+6
    035DC 1462      CP	R6,R2
    035DD 0473      CPC	R7,R3
    035DE 0484      CPC	R8,R4
    035DF 0495      CPC	R9,R5
    035E0 F4B0      BCC	0x35F7
(0581) 		    index++;
    035E1 E041      LDI	R20,1
    035E2 E050      LDI	R21,0
    035E3 E060      LDI	R22,0
    035E4 E070      LDI	R23,0
    035E5 0113      MOVW	R2,R6
    035E6 0124      MOVW	R4,R8
    035E7 0E24      ADD	R2,R20
    035E8 1E35      ADC	R3,R21
    035E9 1E46      ADC	R4,R22
    035EA 1E57      ADC	R5,R23
    035EB 822B      STD	Y+3,R2
    035EC 823C      STD	Y+4,R3
    035ED 824D      STD	Y+5,R4
    035EE 825E      STD	Y+6,R5
(0582) 			ReadSDFile(index,buf);
    035EF 0196      MOVW	R18,R12
    035F0 810B      LDD	R16,Y+3
    035F1 811C      LDD	R17,Y+4
    035F2 940E 265F CALL	_ReadSDFile
(0583) 			CharToStruct();
    035F4 940E 2A0C CALL	_CharToStruct
(0584) 			page = 0;
    035F6 24AA      CLR	R10
(0585) 		}
(0586) 		key=0;
    035F7 24EE      CLR	R14
(0587) 	}
(0588) 	if( key==lleft ){ //长按按left键上一条
    035F8 2D8E      MOV	R24,R14
    035F9 398B      CPI	R24,0x9B
    035FA F511      BNE	0x361D
(0589) next_item:
(0590) 		if(index > 0){
    035FB E040      LDI	R20,0
    035FC E050      LDI	R21,0
    035FD E060      LDI	R22,0
    035FE E070      LDI	R23,0
    035FF 802B      LDD	R2,Y+3
    03600 803C      LDD	R3,Y+4
    03601 804D      LDD	R4,Y+5
    03602 805E      LDD	R5,Y+6
    03603 1542      CP	R20,R2
    03604 0553      CPC	R21,R3
    03605 0564      CPC	R22,R4
    03606 0575      CPC	R23,R5
    03607 F4A4      BGE	0x361C
(0591) 		    index--;
    03608 E041      LDI	R20,1
    03609 E050      LDI	R21,0
    0360A E060      LDI	R22,0
    0360B E070      LDI	R23,0
    0360C 1A24      SUB	R2,R20
    0360D 0A35      SBC	R3,R21
    0360E 0A46      SBC	R4,R22
    0360F 0A57      SBC	R5,R23
    03610 822B      STD	Y+3,R2
    03611 823C      STD	Y+4,R3
    03612 824D      STD	Y+5,R4
    03613 825E      STD	Y+6,R5
(0592) 			ReadSDFile(index,buf);
    03614 0196      MOVW	R18,R12
    03615 810B      LDD	R16,Y+3
    03616 811C      LDD	R17,Y+4
    03617 940E 265F CALL	_ReadSDFile
(0593) 			CharToStruct();
    03619 940E 2A0C CALL	_CharToStruct
(0594) 			page = 0;
    0361B 24AA      CLR	R10
(0595) 		}
(0596) 		key=0;
    0361C 24EE      CLR	R14
(0597) 	}
(0598) 	
(0599) 	if(key==up){ //上键 : 页面减 
    0361D 2D8E      MOV	R24,R14
    0361E 318E      CPI	R24,0x1E
    0361F F449      BNE	0x3629
(0600) 	    if(page>0) page--;
    03620 E080      LDI	R24,0
    03621 158A      CP	R24,R10
    03622 F008      BCS	0x3624
    03623 CFAC      RJMP	0x35D0
    03624 94AA      DEC	R10
(0601) 	    else goto pre_item;
(0602) 		LCD_CLR();
    03625 940E 3A74 CALL	_LCD_CLR
(0603) 	    LCD_Init();
    03627 940E 3A42 CALL	_LCD_Init
(0604) 		
(0605) 	}
(0606) 	if(key==down){ //下键 ： 页面加
    03629 2D8E      MOV	R24,R14
    0362A 318D      CPI	R24,0x1D
    0362B F441      BNE	0x3634
(0607) 	    if(page<5) page++;
    0362C 2D8A      MOV	R24,R10
    0362D 3085      CPI	R24,5
    0362E F660      BCC	0x35FB
    0362F 94A3      INC	R10
(0608) 	  	else goto next_item;
(0609) 	    LCD_CLR();
    03630 940E 3A74 CALL	_LCD_CLR
(0610) 	    LCD_Init();
    03632 940E 3A42 CALL	_LCD_Init
(0611) 	}
(0612) 	if(key==right){	//右键 退出
    03634 2D8E      MOV	R24,R14
    03635 3187      CPI	R24,0x17
    03636 F439      BNE	0x363E
(0613) 	    beep(0,1); 
    03637 E021      LDI	R18,1
    03638 2700      CLR	R16
    03639 940E 3D49 CALL	_beep
(0614) 	 	LCD_CLR();
    0363B 940E 3A74 CALL	_LCD_CLR
(0615) 	 	return ;
    0363D C005      RJMP	0x3643
(0616) 	}
(0617) 	
(0618)     delayms(30); 
    0363E E10E      LDI	R16,0x1E
    0363F E010      LDI	R17,0
    03640 940E 2413 CALL	_delayms
    03642 CF7D      RJMP	0x35C0
    03643 9627      ADIW	R28,7
    03644 940C 4160 JMP	pop_xgsetF0FC
_GUI_welcome:
    03646 9722      SBIW	R28,2
(0619) }//end while
(0620) }
(0621) void GUI_welcome(void){
(0622)     LCD_CLR(); //清屏
    03647 940E 3A74 CALL	_LCD_CLR
(0623) 	LCD_const_disp(2,3,"欢迎使用");
    03649 E68D      LDI	R24,0x6D
    0364A E093      LDI	R25,3
    0364B 8399      STD	Y+1,R25
    0364C 8388      ST	Y,R24
    0364D E023      LDI	R18,3
    0364E E002      LDI	R16,2
    0364F 940E 39CE CALL	_LCD_const_disp
(0624) 	LCD_const_disp(3,1,"环境冷强度检测仪");
    03651 E58C      LDI	R24,0x5C
    03652 E093      LDI	R25,3
    03653 8399      STD	Y+1,R25
    03654 8388      ST	Y,R24
    03655 E021      LDI	R18,1
    03656 E003      LDI	R16,3
    03657 940E 39CE CALL	_LCD_const_disp
(0625) 	delayms(800);
    03659 E200      LDI	R16,0x20
    0365A E013      LDI	R17,3
    0365B 940E 2413 CALL	_delayms
(0626) 	beep(0,1);
    0365D E021      LDI	R18,1
    0365E 2700      CLR	R16
    0365F 940E 3D49 CALL	_beep
    03661 9622      ADIW	R28,2
    03662 9508      RET
_dateRefresh:
  readhardware         --> R10
    03663 92AA      ST	-Y,R10
    03664 2EA0      MOV	R10,R16
(0627) 	
(0628) }
(0629) 
(0630) ////////////////////////////////////
(0631) //  函数作用
(0632) //   将ds1302中缓存的时钟数据转换进结构体中
(0633) ////////////////////////////////////
(0634) void dateRefresh(unsigned char readhardware)
(0635) {	//readhardware = 0 not refresh, =1 refresh
(0636) 	ds1302_read_time();
    03665 940E 3F95 CALL	_ds1302_read_time
(0637) 	t.tm_sec=(((time_buf[6]&0x70)>>4)*10)+(time_buf[6]&0x0f);
    03667 9110 051A LDS	R17,time_buf+6
    03669 7710      ANDI	R17,0x70
    0366A 9512      SWAP	R17
    0366B 701F      ANDI	R17,0xF
    0366C E00A      LDI	R16,0xA
    0366D 0301      MULSU	R16,R17
    0366E 0110      MOVW	R2,R0
    0366F 9180 051A LDS	R24,time_buf+6
    03671 2799      CLR	R25
    03672 708F      ANDI	R24,0xF
    03673 7090      ANDI	R25,0
    03674 0E28      ADD	R2,R24
    03675 1E39      ADC	R3,R25
    03676 9230 07CF STS	t+1,R3
    03678 9220 07CE STS	t,R2
(0638) 	t.tm_min=  (((time_buf[5]&0x70)>>4)*10)+(time_buf[5]&0x0f);
    0367A 9110 0519 LDS	R17,time_buf+5
    0367C 7710      ANDI	R17,0x70
    0367D 9512      SWAP	R17
    0367E 701F      ANDI	R17,0xF
    0367F 0301      MULSU	R16,R17
    03680 0110      MOVW	R2,R0
    03681 9180 0519 LDS	R24,time_buf+5
    03683 2799      CLR	R25
    03684 708F      ANDI	R24,0xF
    03685 7090      ANDI	R25,0
    03686 0E28      ADD	R2,R24
    03687 1E39      ADC	R3,R25
    03688 9230 07D1 STS	t+3,R3
    0368A 9220 07D0 STS	t+2,R2
(0639) 	t.tm_hour=  (((time_buf[4]&0x70)>>4)*10)+(time_buf[4]&0x0f);
    0368C 9110 0518 LDS	R17,time_buf+4
    0368E 7710      ANDI	R17,0x70
    0368F 9512      SWAP	R17
    03690 701F      ANDI	R17,0xF
    03691 0301      MULSU	R16,R17
    03692 0110      MOVW	R2,R0
    03693 9180 0518 LDS	R24,time_buf+4
    03695 2799      CLR	R25
    03696 708F      ANDI	R24,0xF
    03697 7090      ANDI	R25,0
    03698 0E28      ADD	R2,R24
    03699 1E39      ADC	R3,R25
    0369A 9230 07D3 STS	t+5,R3
    0369C 9220 07D2 STS	t+4,R2
(0640) 	t.tm_mday=	(((time_buf[3]&0x70)>>4)*10)+(time_buf[3]&0x0f);
    0369E 9110 0517 LDS	R17,time_buf+3
    036A0 7710      ANDI	R17,0x70
    036A1 9512      SWAP	R17
    036A2 701F      ANDI	R17,0xF
    036A3 0301      MULSU	R16,R17
    036A4 0110      MOVW	R2,R0
    036A5 9180 0517 LDS	R24,time_buf+3
    036A7 2799      CLR	R25
    036A8 708F      ANDI	R24,0xF
    036A9 7090      ANDI	R25,0
    036AA 0E28      ADD	R2,R24
    036AB 1E39      ADC	R3,R25
    036AC 9230 07D5 STS	t+7,R3
    036AE 9220 07D4 STS	t+6,R2
(0641) 	t.tm_mon= (((time_buf[2]&0x70)>>4)*10)+(time_buf[2]&0x0f);
    036B0 9110 0516 LDS	R17,time_buf+2
    036B2 7710      ANDI	R17,0x70
    036B3 9512      SWAP	R17
    036B4 701F      ANDI	R17,0xF
    036B5 0301      MULSU	R16,R17
    036B6 0110      MOVW	R2,R0
    036B7 9180 0516 LDS	R24,time_buf+2
    036B9 2799      CLR	R25
    036BA 708F      ANDI	R24,0xF
    036BB 7090      ANDI	R25,0
    036BC 0E28      ADD	R2,R24
    036BD 1E39      ADC	R3,R25
    036BE 9230 07D7 STS	t+9,R3
    036C0 9220 07D6 STS	t+8,R2
(0642) 	t.tm_wday=	(time_buf[7]&0x0f);
    036C2 9180 051B LDS	R24,time_buf+7
    036C4 2799      CLR	R25
    036C5 708F      ANDI	R24,0xF
    036C6 7090      ANDI	R25,0
    036C7 9390 07DB STS	t+13,R25
    036C9 9380 07DA STS	t+12,R24
(0643)     t.tm_year=	(((time_buf[1]&0x70)>>4)*10)+(time_buf[1]&0x0f);
    036CB 9110 0515 LDS	R17,time_buf+1
    036CD 7710      ANDI	R17,0x70
    036CE 9512      SWAP	R17
    036CF 701F      ANDI	R17,0xF
    036D0 0301      MULSU	R16,R17
    036D1 0110      MOVW	R2,R0
    036D2 9180 0515 LDS	R24,time_buf+1
    036D4 2799      CLR	R25
    036D5 708F      ANDI	R24,0xF
    036D6 7090      ANDI	R25,0
    036D7 0E28      ADD	R2,R24
    036D8 1E39      ADC	R3,R25
    036D9 9230 07D9 STS	t+11,R3
    036DB 9220 07D8 STS	t+10,R2
(0644) 	if(readhardware != 0){
    036DD 20AA      TST	R10
    036DE F409      BNE	0x36E0
    036DF C0A5      RJMP	0x3785
(0645) 	Result.Date[0]='2';
    036E0 E382      LDI	R24,0x32
    036E1 9380 0586 STS	Result+22,R24
(0646) 	Result.Date[1]='0';
    036E3 E380      LDI	R24,0x30
    036E4 9380 0587 STS	Result+23,R24
(0647) 	Result.Date[2]=t.tm_year/10+'0';
    036E6 E02A      LDI	R18,0xA
    036E7 E030      LDI	R19,0
    036E8 0181      MOVW	R16,R2
    036E9 940E 403B CALL	div16s
    036EB 01C8      MOVW	R24,R16
    036EC 96C0      ADIW	R24,0x30
    036ED 9380 0588 STS	Result+24,R24
(0648) 	Result.Date[3]=t.tm_year%10+'0';
    036EF E02A      LDI	R18,0xA
    036F0 E030      LDI	R19,0
    036F1 9100 07D8 LDS	R16,t+10
    036F3 9110 07D9 LDS	R17,t+11
    036F5 940E 4037 CALL	mod16s
    036F7 01C8      MOVW	R24,R16
    036F8 96C0      ADIW	R24,0x30
    036F9 9380 0589 STS	Result+25,R24
(0649) 	Result.Date[4]=t.tm_mon/10+'0';
    036FB E02A      LDI	R18,0xA
    036FC E030      LDI	R19,0
    036FD 9100 07D6 LDS	R16,t+8
    036FF 9110 07D7 LDS	R17,t+9
    03701 940E 403B CALL	div16s
    03703 01C8      MOVW	R24,R16
    03704 96C0      ADIW	R24,0x30
    03705 9380 058A STS	Result+26,R24
(0650) 	Result.Date[5]=t.tm_mon%10+'0';
    03707 E02A      LDI	R18,0xA
    03708 E030      LDI	R19,0
    03709 9100 07D6 LDS	R16,t+8
    0370B 9110 07D7 LDS	R17,t+9
    0370D 940E 4037 CALL	mod16s
    0370F 01C8      MOVW	R24,R16
    03710 96C0      ADIW	R24,0x30
    03711 9380 058B STS	Result+27,R24
(0651) 	Result.Date[6]=t.tm_mday/10+'0';
    03713 E02A      LDI	R18,0xA
    03714 E030      LDI	R19,0
    03715 9100 07D4 LDS	R16,t+6
    03717 9110 07D5 LDS	R17,t+7
    03719 940E 403B CALL	div16s
    0371B 01C8      MOVW	R24,R16
    0371C 96C0      ADIW	R24,0x30
    0371D 9380 058C STS	Result+28,R24
(0652) 	Result.Date[7]=t.tm_mday%10+'0';
    0371F E02A      LDI	R18,0xA
    03720 E030      LDI	R19,0
    03721 9100 07D4 LDS	R16,t+6
    03723 9110 07D5 LDS	R17,t+7
    03725 940E 4037 CALL	mod16s
    03727 01C8      MOVW	R24,R16
    03728 96C0      ADIW	R24,0x30
    03729 9380 058D STS	Result+29,R24
(0653)     Result.Date[8]='\0';
    0372B 2422      CLR	R2
    0372C 9220 058E STS	Result+30,R2
(0654) 
(0655) 	Result.Time[0]=t.tm_hour/10+'0';
    0372E E02A      LDI	R18,0xA
    0372F E030      LDI	R19,0
    03730 9100 07D2 LDS	R16,t+4
    03732 9110 07D3 LDS	R17,t+5
    03734 940E 403B CALL	div16s
    03736 01C8      MOVW	R24,R16
    03737 96C0      ADIW	R24,0x30
    03738 9380 058F STS	Result+31,R24
(0656) 	Result.Time[1]=t.tm_hour%10+'0';
    0373A E02A      LDI	R18,0xA
    0373B E030      LDI	R19,0
    0373C 9100 07D2 LDS	R16,t+4
    0373E 9110 07D3 LDS	R17,t+5
    03740 940E 4037 CALL	mod16s
    03742 01C8      MOVW	R24,R16
    03743 96C0      ADIW	R24,0x30
    03744 9380 0590 STS	Result+32,R24
(0657) 	Result.Time[2]=':';
    03746 E38A      LDI	R24,0x3A
    03747 9380 0591 STS	Result+33,R24
(0658) 	Result.Time[3]=' ';
    03749 E280      LDI	R24,0x20
    0374A 9380 0592 STS	Result+34,R24
(0659) 	Result.Time[4]=t.tm_min/10+'0';
    0374C E02A      LDI	R18,0xA
    0374D E030      LDI	R19,0
    0374E 9100 07D0 LDS	R16,t+2
    03750 9110 07D1 LDS	R17,t+3
    03752 940E 403B CALL	div16s
    03754 01C8      MOVW	R24,R16
    03755 96C0      ADIW	R24,0x30
    03756 9380 0593 STS	Result+35,R24
(0660) 	Result.Time[5]=t.tm_min%10+'0';
    03758 E02A      LDI	R18,0xA
    03759 E030      LDI	R19,0
    0375A 9100 07D0 LDS	R16,t+2
    0375C 9110 07D1 LDS	R17,t+3
    0375E 940E 4037 CALL	mod16s
    03760 01C8      MOVW	R24,R16
    03761 96C0      ADIW	R24,0x30
    03762 9380 0594 STS	Result+36,R24
(0661) 	Result.Time[6]=':';
    03764 E38A      LDI	R24,0x3A
    03765 9380 0595 STS	Result+37,R24
(0662) 	Result.Time[7]=' ';
    03767 E280      LDI	R24,0x20
    03768 9380 0596 STS	Result+38,R24
(0663) 	Result.Time[8]=t.tm_sec/10+'0';
    0376A E02A      LDI	R18,0xA
    0376B E030      LDI	R19,0
    0376C 9100 07CE LDS	R16,t
    0376E 9110 07CF LDS	R17,t+1
    03770 940E 403B CALL	div16s
    03772 01C8      MOVW	R24,R16
    03773 96C0      ADIW	R24,0x30
    03774 9380 0597 STS	Result+39,R24
(0664) 	Result.Time[9]=t.tm_sec%10+'0';
    03776 E02A      LDI	R18,0xA
    03777 E030      LDI	R19,0
    03778 9100 07CE LDS	R16,t
    0377A 9110 07CF LDS	R17,t+1
    0377C 940E 4037 CALL	mod16s
    0377E 01C8      MOVW	R24,R16
    0377F 96C0      ADIW	R24,0x30
    03780 9380 0598 STS	Result+40,R24
(0665) 	Result.Time[10]='\0'; 
    03782 2422      CLR	R2
    03783 9220 0599 STS	Result+41,R2
(0666) 	}
(0667)     config.now =t.tm_hour*3600 + t.tm_min*60 + t.tm_sec; //更新系统心跳
    03785 9120 07D0 LDS	R18,t+2
    03787 9130 07D1 LDS	R19,t+3
    03789 E30C      LDI	R16,0x3C
    0378A E010      LDI	R17,0
    0378B 940E 4107 CALL	empy16s
    0378D 0118      MOVW	R2,R16
    0378E 9120 07D2 LDS	R18,t+4
    03790 9130 07D3 LDS	R19,t+5
    03792 E100      LDI	R16,0x10
    03793 E01E      LDI	R17,0xE
    03794 940E 4107 CALL	empy16s
    03796 0128      MOVW	R4,R16
    03797 0C42      ADD	R4,R2
    03798 1C53      ADC	R5,R3
    03799 9020 07CE LDS	R2,t
    0379B 9030 07CF LDS	R3,t+1
    0379D 0C42      ADD	R4,R2
    0379E 1C53      ADC	R5,R3
    0379F 0112      MOVW	R2,R4
    037A0 2444      CLR	R4
    037A1 FC37      SBRC	R3,7
    037A2 9440      COM	R4
    037A3 2455      CLR	R5
    037A4 FC47      SBRC	R4,7
    037A5 9450      COM	R5
    037A6 9230 07ED STS	config+13,R3
    037A8 9220 07EC STS	config+12,R2
    037AA 9250 07EF STS	config+15,R5
    037AC 9240 07EE STS	config+14,R4
    037AE 90A9      LD	R10,Y+
    037AF 9508      RET
FILE: D:\LQD\software\master\software_src\usart.c
(0001) #include "config.h"
(0002) 
(0003) 
(0004) #define fosc 7372800UL //晶振7.3728MHZ
(0005) #define baud 38400  //波特率
(0006) //串口通信初始化  MEGA128
(0007) //UART1 initialize
(0008) // desired baud rate:38400
(0009) // actual baud rate:38400 (0.0%)
(0010) // char size: 8 bit
(0011) // parity: Disabled
(0012) void uart1_init(void)
(0013) {
(0014)  	 UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    037B0 2422      CLR	R2
    037B1 9220 009A STS	0x9A,R2
(0015)      UCSR1A = 0x00;
    037B3 9220 009B STS	0x9B,R2
(0016)      UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//8bit+1bit stop
    037B5 E086      LDI	R24,6
    037B6 9380 009D STS	0x9D,R24
(0017)      UBRR1L=(fosc/16/(baud+1))%256;
    037B8 E08B      LDI	R24,0xB
    037B9 9380 0099 STS	0x99,R24
(0018)      UBRR1H=(fosc/16/(baud+1))/256;
    037BB 9220 0098 STS	0x98,R2
(0019)      UCSR1B =(1<<RXEN1)|(1<<TXEN1);//RXCEN TXCEN
    037BD E188      LDI	R24,0x18
    037BE 9380 009A STS	0x9A,R24
    037C0 9508      RET
_uart1_rx_isr:
  tmp                  --> R16
    037C1 930A      ST	-Y,R16
    037C2 B70F      IN	R16,0x3F
    037C3 930A      ST	-Y,R16
(0020) }
(0021) 
(0022) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0023) void uart1_rx_isr(void){   
(0024) 	 char tmp;
(0025) 	 tmp=UDR1;
    037C4 9100 009C LDS	R16,0x9C
    037C6 9109      LD	R16,Y+
    037C7 BF0F      OUT	0x3F,R16
    037C8 9109      LD	R16,Y+
    037C9 9518      RETI
(0026) }
(0027) 
(0028) void Usart_Transmit(char c)
(0029) {
(0030)  	 while (!(UCSR1A&(1<<UDRE1)));//表明发送器一准备就绪
_Usart_Transmit:
  c                    --> R16
    037CA 9020 009B LDS	R2,0x9B
    037CC FE25      SBRS	R2,5
    037CD CFFC      RJMP	_Usart_Transmit
(0031) 	 UDR1=c;
    037CE 9300 009C STS	0x9C,R16
    037D0 9508      RET
_Puts:
  s                    --> R20
    037D1 934A      ST	-Y,R20
    037D2 935A      ST	-Y,R21
    037D3 01A8      MOVW	R20,R16
(0032) }
(0033) 
(0034) //串口输出字符串
(0035) void Puts( unsigned char *s)
(0036) { 
    037D4 C00B      RJMP	0x37E0
(0037) 	 while (*s) 
(0038)       { 
(0039) 	  //为数据间的隔断创造一个串口能显示的隔断字符 即'/t'  ->  ' '
(0040) 	  if(*s==0x09)  
    037D5 01FA      MOVW	R30,R20
    037D6 8180      LD	R24,Z
    037D7 3089      CPI	R24,0x9
    037D8 F411      BNE	0x37DB
(0041) 	  {   Usart_Transmit(' ');    }
    037D9 E200      LDI	R16,0x20
    037DA DFEF      RCALL	_Usart_Transmit
(0042) 	 Usart_Transmit(*s);
    037DB 01FA      MOVW	R30,R20
    037DC 8100      LD	R16,Z
    037DD DFEC      RCALL	_Usart_Transmit
(0043) 	 s++;
    037DE 5F4F      SUBI	R20,0xFF
    037DF 4F5F      SBCI	R21,0xFF
    037E0 01FA      MOVW	R30,R20
    037E1 8020      LD	R2,Z
    037E2 2022      TST	R2
    037E3 F789      BNE	0x37D5
    037E4 9159      LD	R21,Y+
    037E5 9149      LD	R20,Y+
    037E6 9508      RET
_Send_nByte:
  i                    --> R20
  len                  --> R10
  p                    --> R12
    037E7 940E 4198 CALL	push_xgset303C
    037E9 2EA2      MOV	R10,R18
    037EA 0168      MOVW	R12,R16
(0044) 	
(0045) 	
(0046)       }
(0047) }
(0048) 
(0049) 
(0050) 
(0051) void Send_nByte(unsigned char *p, unsigned char len)
(0052) { 
(0053)   int i = 0;
(0054)   for(i=0;i<len;i++)
    037EB 2744      CLR	R20
    037EC 2755      CLR	R21
    037ED C007      RJMP	0x37F5
(0055)   {
(0056)    	Usart_Transmit(*(p+i));
    037EE 01FA      MOVW	R30,R20
    037EF 0DEC      ADD	R30,R12
    037F0 1DFD      ADC	R31,R13
    037F1 8100      LD	R16,Z
    037F2 DFD7      RCALL	_Usart_Transmit
    037F3 5F4F      SUBI	R20,0xFF
    037F4 4F5F      SBCI	R21,0xFF
    037F5 2C2A      MOV	R2,R10
    037F6 2433      CLR	R3
    037F7 1542      CP	R20,R2
    037F8 0553      CPC	R21,R3
    037F9 F3A4      BLT	0x37EE
    037FA 940C 419F JMP	pop_xgset303C
_PrintString:
  str                  --> R10
    037FC 92AA      ST	-Y,R10
    037FD 92BA      ST	-Y,R11
    037FE 0158      MOVW	R10,R16
(0057)   }
(0058) }
(0059) 
(0060) void  PrintString(const unsigned char *str)
(0061) {    
    037FF C004      RJMP	0x3804
(0062) 	while(*str!=0)	Usart_Transmit(*str++);
    03800 01F5      MOVW	R30,R10
    03801 9101      LD	R16,Z+
    03802 015F      MOVW	R10,R30
    03803 DFC6      RCALL	_Usart_Transmit
    03804 01F5      MOVW	R30,R10
    03805 8020      LD	R2,Z
    03806 2022      TST	R2
    03807 F7C1      BNE	0x3800
    03808 90B9      LD	R11,Y+
    03809 90A9      LD	R10,Y+
    0380A 9508      RET
_PrintString_n:
  str                  --> R10
    0380B 92AA      ST	-Y,R10
    0380C 92BA      ST	-Y,R11
    0380D 0158      MOVW	R10,R16
(0063) }
(0064) void  PrintString_n(const unsigned char *str)
(0065) {   
(0066) 	Usart_Transmit('\r');
    0380E E00D      LDI	R16,0xD
    0380F DFBA      RCALL	_Usart_Transmit
(0067) 	Usart_Transmit('\n'); 
    03810 E00A      LDI	R16,0xA
    03811 DFB8      RCALL	_Usart_Transmit
    03812 C004      RJMP	0x3817
(0068) 	while(*str!=0)	Usart_Transmit(*str++);
    03813 01F5      MOVW	R30,R10
    03814 9101      LD	R16,Z+
    03815 015F      MOVW	R10,R30
    03816 DFB3      RCALL	_Usart_Transmit
    03817 01F5      MOVW	R30,R10
    03818 8020      LD	R2,Z
    03819 2022      TST	R2
    0381A F7C1      BNE	0x3813
    0381B 90B9      LD	R11,Y+
    0381C 90A9      LD	R10,Y+
    0381D 9508      RET
_PrintLong:
  i                    --> R20
  da                   --> Y,+0
  data                 --> Y,+9
    0381E 940E 4026 CALL	push_arg4
    03820 934A      ST	-Y,R20
    03821 9728      SBIW	R28,0x8
(0069) 
(0070) } 
(0071)  
(0072) void PrintLong(unsigned long data)
(0073) {
(0074)  
(0075) 	unsigned char da[8];
(0076) 	unsigned char i;
(0077) 	for(i=0;i<8;i++)	da[i]=0;
    03822 2744      CLR	R20
    03823 C008      RJMP	0x382C
    03824 01CE      MOVW	R24,R28
    03825 2FE4      MOV	R30,R20
    03826 27FF      CLR	R31
    03827 0FE8      ADD	R30,R24
    03828 1FF9      ADC	R31,R25
    03829 2422      CLR	R2
    0382A 8220      ST	Z,R2
    0382B 9543      INC	R20
    0382C 3048      CPI	R20,0x8
    0382D F3B0      BCS	0x3824
    0382E C013      RJMP	0x3842
(0078) 	while(data>=10000000L){ ++da[7];data-=10000000L;}
    0382F 818F      LDD	R24,Y+7
    03830 5F8F      SUBI	R24,0xFF
    03831 838F      STD	Y+7,R24
    03832 E880      LDI	R24,0x80
    03833 E996      LDI	R25,0x96
    03834 E9A8      LDI	R26,0x98
    03835 E0B0      LDI	R27,0
    03836 8429      LDD	R2,Y+9
    03837 843A      LDD	R3,Y+10
    03838 844B      LDD	R4,Y+11
    03839 845C      LDD	R5,Y+12
    0383A 1A28      SUB	R2,R24
    0383B 0A39      SBC	R3,R25
    0383C 0A4A      SBC	R4,R26
    0383D 0A5B      SBC	R5,R27
    0383E 8629      STD	Y+9,R2
    0383F 863A      STD	Y+10,R3
    03840 864B      STD	Y+11,R4
    03841 865C      STD	Y+12,R5
    03842 E880      LDI	R24,0x80
    03843 E996      LDI	R25,0x96
    03844 E9A8      LDI	R26,0x98
    03845 E0B0      LDI	R27,0
    03846 8429      LDD	R2,Y+9
    03847 843A      LDD	R3,Y+10
    03848 844B      LDD	R4,Y+11
    03849 845C      LDD	R5,Y+12
    0384A 1628      CP	R2,R24
    0384B 0639      CPC	R3,R25
    0384C 064A      CPC	R4,R26
    0384D 065B      CPC	R5,R27
    0384E F700      BCC	0x382F
(0079) 	if(da[7])	i=0;
    0384F 802F      LDD	R2,Y+7
    03850 2022      TST	R2
    03851 F009      BEQ	0x3853
    03852 2744      CLR	R20
(0080) 	if(i==0)	Usart_Transmit('0'+da[7]);
    03853 2344      TST	R20
    03854 F4B9      BNE	0x386C
    03855 810F      LDD	R16,Y+7
    03856 5D00      SUBI	R16,0xD0
    03857 DF72      RCALL	_Usart_Transmit
    03858 C013      RJMP	0x386C
(0081) 	while(data>=1000000L) { ++da[6];data-=1000000L;}
    03859 818E      LDD	R24,Y+6
    0385A 5F8F      SUBI	R24,0xFF
    0385B 838E      STD	Y+6,R24
    0385C E480      LDI	R24,0x40
    0385D E492      LDI	R25,0x42
    0385E E0AF      LDI	R26,0xF
    0385F E0B0      LDI	R27,0
    03860 8429      LDD	R2,Y+9
    03861 843A      LDD	R3,Y+10
    03862 844B      LDD	R4,Y+11
    03863 845C      LDD	R5,Y+12
    03864 1A28      SUB	R2,R24
    03865 0A39      SBC	R3,R25
    03866 0A4A      SBC	R4,R26
    03867 0A5B      SBC	R5,R27
    03868 8629      STD	Y+9,R2
    03869 863A      STD	Y+10,R3
    0386A 864B      STD	Y+11,R4
    0386B 865C      STD	Y+12,R5
    0386C E480      LDI	R24,0x40
    0386D E492      LDI	R25,0x42
    0386E E0AF      LDI	R26,0xF
    0386F E0B0      LDI	R27,0
    03870 8429      LDD	R2,Y+9
    03871 843A      LDD	R3,Y+10
    03872 844B      LDD	R4,Y+11
    03873 845C      LDD	R5,Y+12
    03874 1628      CP	R2,R24
    03875 0639      CPC	R3,R25
    03876 064A      CPC	R4,R26
    03877 065B      CPC	R5,R27
    03878 F700      BCC	0x3859
(0082) 	if(da[6])	i=0;
    03879 802E      LDD	R2,Y+6
    0387A 2022      TST	R2
    0387B F009      BEQ	0x387D
    0387C 2744      CLR	R20
(0083) 	if(i==0)	Usart_Transmit('0'+da[6]);
    0387D 2344      TST	R20
    0387E F4B9      BNE	0x3896
    0387F 810E      LDD	R16,Y+6
    03880 5D00      SUBI	R16,0xD0
    03881 DF48      RCALL	_Usart_Transmit
    03882 C013      RJMP	0x3896
(0084) 	while(data>=100000L)  { ++da[5];data-=100000L;}
    03883 818D      LDD	R24,Y+5
    03884 5F8F      SUBI	R24,0xFF
    03885 838D      STD	Y+5,R24
    03886 EA80      LDI	R24,0xA0
    03887 E896      LDI	R25,0x86
    03888 E0A1      LDI	R26,1
    03889 E0B0      LDI	R27,0
    0388A 8429      LDD	R2,Y+9
    0388B 843A      LDD	R3,Y+10
    0388C 844B      LDD	R4,Y+11
    0388D 845C      LDD	R5,Y+12
    0388E 1A28      SUB	R2,R24
    0388F 0A39      SBC	R3,R25
    03890 0A4A      SBC	R4,R26
    03891 0A5B      SBC	R5,R27
    03892 8629      STD	Y+9,R2
    03893 863A      STD	Y+10,R3
    03894 864B      STD	Y+11,R4
    03895 865C      STD	Y+12,R5
    03896 EA80      LDI	R24,0xA0
    03897 E896      LDI	R25,0x86
    03898 E0A1      LDI	R26,1
    03899 E0B0      LDI	R27,0
    0389A 8429      LDD	R2,Y+9
    0389B 843A      LDD	R3,Y+10
    0389C 844B      LDD	R4,Y+11
    0389D 845C      LDD	R5,Y+12
    0389E 1628      CP	R2,R24
    0389F 0639      CPC	R3,R25
    038A0 064A      CPC	R4,R26
    038A1 065B      CPC	R5,R27
    038A2 F700      BCC	0x3883
(0085) 	if(da[5])	i=0;
    038A3 802D      LDD	R2,Y+5
    038A4 2022      TST	R2
    038A5 F009      BEQ	0x38A7
    038A6 2744      CLR	R20
(0086) 	if(i==0)	Usart_Transmit('0'+da[5]);
    038A7 2344      TST	R20
    038A8 F4B9      BNE	0x38C0
    038A9 810D      LDD	R16,Y+5
    038AA 5D00      SUBI	R16,0xD0
    038AB DF1E      RCALL	_Usart_Transmit
    038AC C013      RJMP	0x38C0
(0087) 	while(data>=10000L)   { ++da[4];data-=10000L;}
    038AD 818C      LDD	R24,Y+4
    038AE 5F8F      SUBI	R24,0xFF
    038AF 838C      STD	Y+4,R24
    038B0 E180      LDI	R24,0x10
    038B1 E297      LDI	R25,0x27
    038B2 E0A0      LDI	R26,0
    038B3 E0B0      LDI	R27,0
    038B4 8429      LDD	R2,Y+9
    038B5 843A      LDD	R3,Y+10
    038B6 844B      LDD	R4,Y+11
    038B7 845C      LDD	R5,Y+12
    038B8 1A28      SUB	R2,R24
    038B9 0A39      SBC	R3,R25
    038BA 0A4A      SBC	R4,R26
    038BB 0A5B      SBC	R5,R27
    038BC 8629      STD	Y+9,R2
    038BD 863A      STD	Y+10,R3
    038BE 864B      STD	Y+11,R4
    038BF 865C      STD	Y+12,R5
    038C0 E180      LDI	R24,0x10
    038C1 E297      LDI	R25,0x27
    038C2 E0A0      LDI	R26,0
    038C3 E0B0      LDI	R27,0
    038C4 8429      LDD	R2,Y+9
    038C5 843A      LDD	R3,Y+10
    038C6 844B      LDD	R4,Y+11
    038C7 845C      LDD	R5,Y+12
    038C8 1628      CP	R2,R24
    038C9 0639      CPC	R3,R25
    038CA 064A      CPC	R4,R26
    038CB 065B      CPC	R5,R27
    038CC F700      BCC	0x38AD
(0088) 	if(da[4])	i=0;
    038CD 802C      LDD	R2,Y+4
    038CE 2022      TST	R2
    038CF F009      BEQ	0x38D1
    038D0 2744      CLR	R20
(0089) 	if(i==0)	Usart_Transmit('0'+da[4]);
    038D1 2344      TST	R20
    038D2 F4B9      BNE	0x38EA
    038D3 810C      LDD	R16,Y+4
    038D4 5D00      SUBI	R16,0xD0
    038D5 DEF4      RCALL	_Usart_Transmit
    038D6 C013      RJMP	0x38EA
(0090) 	while(data>=1000L)    { ++da[3];data-=1000L;}
    038D7 818B      LDD	R24,Y+3
    038D8 5F8F      SUBI	R24,0xFF
    038D9 838B      STD	Y+3,R24
    038DA EE88      LDI	R24,0xE8
    038DB E093      LDI	R25,3
    038DC E0A0      LDI	R26,0
    038DD E0B0      LDI	R27,0
    038DE 8429      LDD	R2,Y+9
    038DF 843A      LDD	R3,Y+10
    038E0 844B      LDD	R4,Y+11
    038E1 845C      LDD	R5,Y+12
    038E2 1A28      SUB	R2,R24
    038E3 0A39      SBC	R3,R25
    038E4 0A4A      SBC	R4,R26
    038E5 0A5B      SBC	R5,R27
    038E6 8629      STD	Y+9,R2
    038E7 863A      STD	Y+10,R3
    038E8 864B      STD	Y+11,R4
    038E9 865C      STD	Y+12,R5
    038EA EE88      LDI	R24,0xE8
    038EB E093      LDI	R25,3
    038EC E0A0      LDI	R26,0
    038ED E0B0      LDI	R27,0
    038EE 8429      LDD	R2,Y+9
    038EF 843A      LDD	R3,Y+10
    038F0 844B      LDD	R4,Y+11
    038F1 845C      LDD	R5,Y+12
    038F2 1628      CP	R2,R24
    038F3 0639      CPC	R3,R25
    038F4 064A      CPC	R4,R26
    038F5 065B      CPC	R5,R27
    038F6 F700      BCC	0x38D7
(0091) 	if(da[3])	i=0;
    038F7 802B      LDD	R2,Y+3
    038F8 2022      TST	R2
    038F9 F009      BEQ	0x38FB
    038FA 2744      CLR	R20
(0092) 	if(i==0)	Usart_Transmit('0'+da[3]);
    038FB 2344      TST	R20
    038FC F4B9      BNE	0x3914
    038FD 810B      LDD	R16,Y+3
    038FE 5D00      SUBI	R16,0xD0
    038FF DECA      RCALL	_Usart_Transmit
    03900 C013      RJMP	0x3914
(0093) 	while(data>=100L)     { ++da[2];data-=100L;}
    03901 818A      LDD	R24,Y+2
    03902 5F8F      SUBI	R24,0xFF
    03903 838A      STD	Y+2,R24
    03904 E684      LDI	R24,0x64
    03905 E090      LDI	R25,0
    03906 E0A0      LDI	R26,0
    03907 E0B0      LDI	R27,0
    03908 8429      LDD	R2,Y+9
    03909 843A      LDD	R3,Y+10
    0390A 844B      LDD	R4,Y+11
    0390B 845C      LDD	R5,Y+12
    0390C 1A28      SUB	R2,R24
    0390D 0A39      SBC	R3,R25
    0390E 0A4A      SBC	R4,R26
    0390F 0A5B      SBC	R5,R27
    03910 8629      STD	Y+9,R2
    03911 863A      STD	Y+10,R3
    03912 864B      STD	Y+11,R4
    03913 865C      STD	Y+12,R5
    03914 E684      LDI	R24,0x64
    03915 E090      LDI	R25,0
    03916 E0A0      LDI	R26,0
    03917 E0B0      LDI	R27,0
    03918 8429      LDD	R2,Y+9
    03919 843A      LDD	R3,Y+10
    0391A 844B      LDD	R4,Y+11
    0391B 845C      LDD	R5,Y+12
    0391C 1628      CP	R2,R24
    0391D 0639      CPC	R3,R25
    0391E 064A      CPC	R4,R26
    0391F 065B      CPC	R5,R27
    03920 F700      BCC	0x3901
(0094) 	if(da[2])	i=0;
    03921 802A      LDD	R2,Y+2
    03922 2022      TST	R2
    03923 F009      BEQ	0x3925
    03924 2744      CLR	R20
(0095) 	if(i==0)	Usart_Transmit('0'+da[2]);
    03925 2344      TST	R20
    03926 F4B9      BNE	0x393E
    03927 810A      LDD	R16,Y+2
    03928 5D00      SUBI	R16,0xD0
    03929 DEA0      RCALL	_Usart_Transmit
    0392A C013      RJMP	0x393E
(0096) 	while(data>=10L)      { ++da[1];data-=10L;}
    0392B 8189      LDD	R24,Y+1
    0392C 5F8F      SUBI	R24,0xFF
    0392D 8389      STD	Y+1,R24
    0392E E08A      LDI	R24,0xA
    0392F E090      LDI	R25,0
    03930 E0A0      LDI	R26,0
    03931 E0B0      LDI	R27,0
    03932 8429      LDD	R2,Y+9
    03933 843A      LDD	R3,Y+10
    03934 844B      LDD	R4,Y+11
    03935 845C      LDD	R5,Y+12
    03936 1A28      SUB	R2,R24
    03937 0A39      SBC	R3,R25
    03938 0A4A      SBC	R4,R26
    03939 0A5B      SBC	R5,R27
    0393A 8629      STD	Y+9,R2
    0393B 863A      STD	Y+10,R3
    0393C 864B      STD	Y+11,R4
    0393D 865C      STD	Y+12,R5
    0393E E08A      LDI	R24,0xA
    0393F E090      LDI	R25,0
    03940 E0A0      LDI	R26,0
    03941 E0B0      LDI	R27,0
    03942 8429      LDD	R2,Y+9
    03943 843A      LDD	R3,Y+10
    03944 844B      LDD	R4,Y+11
    03945 845C      LDD	R5,Y+12
    03946 1628      CP	R2,R24
    03947 0639      CPC	R3,R25
    03948 064A      CPC	R4,R26
    03949 065B      CPC	R5,R27
    0394A F700      BCC	0x392B
(0097) 	if(da[1])	i=0;
    0394B 8029      LDD	R2,Y+1
    0394C 2022      TST	R2
    0394D F009      BEQ	0x394F
    0394E 2744      CLR	R20
(0098) 	if(i==0)	Usart_Transmit('0'+da[1]);
    0394F 2344      TST	R20
    03950 F419      BNE	0x3954
    03951 8109      LDD	R16,Y+1
    03952 5D00      SUBI	R16,0xD0
    03953 DE76      RCALL	_Usart_Transmit
(0099) 	Usart_Transmit('0'+data);
    03954 E380      LDI	R24,0x30
    03955 E090      LDI	R25,0
    03956 E0A0      LDI	R26,0
    03957 E0B0      LDI	R27,0
    03958 8429      LDD	R2,Y+9
    03959 843A      LDD	R3,Y+10
    0395A 844B      LDD	R4,Y+11
    0395B 845C      LDD	R5,Y+12
    0395C 0E28      ADD	R2,R24
    0395D 1E39      ADC	R3,R25
    0395E 1E4A      ADC	R4,R26
    0395F 1E5B      ADC	R5,R27
    03960 2D02      MOV	R16,R2
    03961 DE68      RCALL	_Usart_Transmit
    03962 9628      ADIW	R28,0x8
    03963 9149      LD	R20,Y+
    03964 9624      ADIW	R28,4
    03965 9508      RET
_PrintChar:
  h                    --> R20
  d                    --> R22
    03966 934A      ST	-Y,R20
    03967 936A      ST	-Y,R22
    03968 2F60      MOV	R22,R16
(0100)  
(0101) }
(0102)  
(0103) void PrintChar(unsigned char d)
(0104) {
(0105) 	unsigned char h=(d&0xF0)>>4;
    03969 2F46      MOV	R20,R22
    0396A 7F40      ANDI	R20,0xF0
    0396B 9542      SWAP	R20
    0396C 704F      ANDI	R20,0xF
(0106) 	if(h<10)	Usart_Transmit('0'+h);
    0396D 304A      CPI	R20,0xA
    0396E F420      BCC	0x3973
    0396F 2F04      MOV	R16,R20
    03970 5D00      SUBI	R16,0xD0
    03971 DE58      RCALL	_Usart_Transmit
    03972 C003      RJMP	0x3976
(0107) 	else		Usart_Transmit('A'-10+h);
    03973 2F04      MOV	R16,R20
    03974 5C09      SUBI	R16,0xC9
    03975 DE54      RCALL	_Usart_Transmit
(0108) 	h=d&0x0f;
    03976 2F46      MOV	R20,R22
    03977 704F      ANDI	R20,0xF
(0109) 	if(h<10)	Usart_Transmit('0'+h);
    03978 304A      CPI	R20,0xA
    03979 F420      BCC	0x397E
    0397A 2F04      MOV	R16,R20
    0397B 5D00      SUBI	R16,0xD0
    0397C DE4D      RCALL	_Usart_Transmit
    0397D C003      RJMP	0x3981
(0110) 	else		Usart_Transmit('A'-10+h);
    0397E 2F04      MOV	R16,R20
    0397F 5C09      SUBI	R16,0xC9
    03980 DE49      RCALL	_Usart_Transmit
(0111) 	Usart_Transmit(' ');
    03981 E200      LDI	R16,0x20
    03982 DE47      RCALL	_Usart_Transmit
    03983 9169      LD	R22,Y+
    03984 9149      LD	R20,Y+
    03985 9508      RET
FILE: D:\LQD\software\master\software_src\SPI.c
(0001) //*****************************************************************************//
(0002) //*								 
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SPI接口控制
(0006) //*****************************************************************************//
(0007) #include "SPI.h"
(0008) 
(0009) /******************************************************************
(0010) SPI接口函数初始化
(0011) ******************************************************************/
(0012) void SPI_IO_Init(void)
(0013) {
(0014) 	SPI_PORT |= (1<<SS);////拉高CS
_SPI_IO_Init:
    03986 9AC0      SBI	0x18,0
(0015) 	SPI_DDR |= (1<<SCLK)|(1<<MOSI)|(1<<SS);////CS,CLK,MOSI设为输出
    03987 B387      IN	R24,0x17
    03988 6087      ORI	R24,7
    03989 BB87      OUT	0x17,R24
(0016) 	SPI_DDR &=~(1<<MISO);//MISO设为输入
    0398A 98BB      CBI	0x17,3
(0017) 	SPI_PORT |= (1<<SCLK);//拉高CLK
    0398B 9AC1      SBI	0x18,1
(0018) 	SPI_High();//SPI高通
    0398C E580      LDI	R24,0x50
    0398D B98D      OUT	0x0D,R24
    0398E 9A70      SBI	0x0E,0
    0398F 9508      RET
(0019) }
(0020) /******************************************************************
(0021) SPI写一个字节
(0022) ******************************************************************/
(0023) void SPI_Write(UINT8 data)
(0024) {
(0025) 	SPDR = data;
_SPI_Write:
  data                 --> R16
    03990 B90F      OUT	0x0F,R16
(0026) 	while ((SPSR&(1<<SPIF))==0);
    03991 9B77      SBIS	0x0E,7
    03992 CFFE      RJMP	0x3991
    03993 9508      RET
(0027) 	//loop_until_bit_is_set(SPSR,SPIF);
(0028) }
(0029) /******************************************************************
(0030) SPI读一个字节
(0031) ******************************************************************/
(0032) unsigned char SPI_Read(void)
(0033) {
(0034) 	SPDR = 0xFF;//写0xFF启动SPI
_SPI_Read:
    03994 EF8F      LDI	R24,0xFF
    03995 B98F      OUT	0x0F,R24
(0035) 	while ((SPSR&(1<<SPIF))==0);
    03996 9B77      SBIS	0x0E,7
    03997 CFFE      RJMP	0x3996
(0036) 	//loop_until_bit_is_set(SPSR,SPIF);//等待SPIF为高电平
(0037) 	return  SPDR;//返回读取值
    03998 B10F      IN	R16,0x0F
    03999 9508      RET
FILE: D:\LQD\software\master\software_src\lcd.c
(0001) #include "config.h"
(0002) 
(0003) //此硬件引脚适合冷强度检测仪第2版电路  mega128
(0004) #define LCD_PIN_CS   4
(0005) #define LCD_PIN_SID  3
(0006) #define LCD_PIN_SCLK 2
(0007) #define LCD_PIN_RST  1
(0008) #define LCD_BACKLIGHT_SW		0
(0009) #define LCD_PORT PORTC
(0010) #define LCD_PIN_DDR DDRC
(0011) #define Set_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT |= (1<<LCD_PIN_CS) 
(0012) #define Set_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT |= (1<<LCD_PIN_SID) 
(0013) #define Set_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT |= (1<<LCD_PIN_SCLK) 
(0014) #define LCD_LIGHT_ON()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT |= (1<<LCD_BACKLIGHT_SW) 
(0015) #define Set_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT |= (1<<LCD_PIN_RST) 
(0016) 
(0017) #define Clr_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT &=~(1<<LCD_PIN_CS) 
(0018) #define Clr_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT &=~(1<<LCD_PIN_SID) 
(0019) #define Clr_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT &=~(1<<LCD_PIN_SCLK) 
(0020) #define LCD_LIGHT_OFF()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT &=~(1<<LCD_BACKLIGHT_SW) 
(0021) #define Clr_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT &=~(1<<LCD_PIN_RST) 
(0022)  
(0023) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data); 
(0024) void Write_8bits(unsigned int W_bits); 
(0025) void LCD_Init(void); 
(0026) unsigned char LCD_INT(void); 
(0027) 
(0028) unsigned char LCD_SW(unsigned char i)
(0029) {
(0030)  if(i==0){
_LCD_SW:
  i                    --> R16
    0399A 2300      TST	R16
    0399B F421      BNE	0x39A0
(0031)  LCD_LIGHT_OFF();
    0399C 9AA0      SBI	0x14,0
    0399D 98A8      CBI	0x15,0
(0032)  return 0;
    0399E 2700      CLR	R16
    0399F C003      RJMP	0x39A3
(0033)  }
(0034)  else{
(0035)  LCD_LIGHT_ON();
    039A0 9AA0      SBI	0x14,0
    039A1 9AA8      SBI	0x15,0
(0036)  return 1;
    039A2 E001      LDI	R16,1
    039A3 9508      RET
(0037)  }
(0038)  
(0039) }
(0040)  
(0041) unsigned char LCD_INT(void) 
(0042) { 
(0043)   Clr_CS(); 
_LCD_INT:
    039A4 9AA4      SBI	0x14,4
    039A5 98AC      CBI	0x15,4
(0044)   Clr_SID(); 
    039A6 9AA3      SBI	0x14,3
    039A7 98AB      CBI	0x15,3
(0045)   Clr_SCLK(); 
    039A8 9AA2      SBI	0x14,2
    039A9 98AA      CBI	0x15,2
(0046)   LCD_Init(); 
    039AA D097      RCALL	_LCD_Init
(0047)   return (0);
    039AB 2700      CLR	R16
    039AC 9508      RET
_address:
  a                    --> R20
  y                    --> R18
  x                    --> R16
    039AD 940E 4180 CALL	push_xgsetF000
(0048) } 
(0049)   
(0050) /******************************************************************** 
(0051) 函数 名：address
(0052) 入口参数：地址转换
(0053) 出口参数：无 
(0054) 函数作用： 
(0055) 说        明： 
(0056) ********************************************************************/ 
(0057) unsigned char address(unsigned char x,unsigned char y)
(0058) {  
(0059)  unsigned char a;
(0060) 
(0061) switch(x) 
    039AF 2F60      MOV	R22,R16
    039B0 2777      CLR	R23
    039B1 3061      CPI	R22,1
    039B2 E0E0      LDI	R30,0
    039B3 077E      CPC	R23,R30
    039B4 F069      BEQ	0x39C2
    039B5 3062      CPI	R22,2
    039B6 E0E0      LDI	R30,0
    039B7 077E      CPC	R23,R30
    039B8 F059      BEQ	0x39C4
    039B9 3063      CPI	R22,3
    039BA E0E0      LDI	R30,0
    039BB 077E      CPC	R23,R30
    039BC F049      BEQ	0x39C6
    039BD 3064      CPI	R22,4
    039BE E0E0      LDI	R30,0
    039BF 077E      CPC	R23,R30
    039C0 F039      BEQ	0x39C8
    039C1 C007      RJMP	0x39C9
(0062) { 
(0063) case 1: 
(0064) {a=0x80;break;} 
    039C2 E840      LDI	R20,0x80
    039C3 C005      RJMP	0x39C9
(0065) case 2: 
(0066) {a=0x90;break;} 
    039C4 E940      LDI	R20,0x90
    039C5 C003      RJMP	0x39C9
(0067)   case 3: 
(0068) {a=0x88;break;} 
    039C6 E848      LDI	R20,0x88
    039C7 C001      RJMP	0x39C9
(0069)   case 4: 
(0070) {a=0x98;break;} 
    039C8 E948      LDI	R20,0x98
(0071) } 
(0072) a=a+y-1;
    039C9 0F42      ADD	R20,R18
    039CA 5041      SUBI	R20,1
(0073) 
(0074) return a;
    039CB 2F04      MOV	R16,R20
    039CC 940C 4185 JMP	pop_xgsetF000
_LCD_const_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    039CE 940E 416D CALL	push_xgset30FC
    039D0 2EE2      MOV	R14,R18
    039D1 2EC0      MOV	R12,R16
    039D2 9721      SBIW	R28,1
    039D3 84A9      LDD	R10,Y+9
    039D4 84BA      LDD	R11,Y+10
(0075) }
(0076)  
(0077) //////////////////////////////////////////////////////////////
(0078) 
(0079) /******************************************************************** 
(0080) 函数 名：LCD_const_disp
(0081) 入口参数：x y  *single_data
(0082) 出口参数：无 
(0083) 函数作用：负责 显示一串常量
(0084) 说        明： 
(0085) ********************************************************************/ 
(0086) void LCD_const_disp(unsigned char x, unsigned char y, const unsigned char *single_data) 
(0087) { 
(0088) unsigned char  a,i; 
(0089) a=address(x,y);
    039D5 2D2E      MOV	R18,R14
    039D6 2D0C      MOV	R16,R12
    039D7 DFD5      RCALL	_address
    039D8 2EC0      MOV	R12,R16
(0090) W_1byte(0,0,a);     //显示的地址 
    039D9 82C8      ST	Y,R12
    039DA 2722      CLR	R18
    039DB 2700      CLR	R16
    039DC D0B7      RCALL	_W_1byte
(0091)    for(i=0; single_data[i]!='\0';i++) 
    039DD 2744      CLR	R20
    039DE C00D      RJMP	0x39EC
(0092)    {
(0093)     if(i>=16) break; 
    039DF 3140      CPI	R20,0x10
    039E0 F008      BCS	0x39E2
    039E1 C011      RJMP	0x39F3
(0094)     W_1byte(0,1,single_data[i]); 
    039E2 2FE4      MOV	R30,R20
    039E3 27FF      CLR	R31
    039E4 0DEA      ADD	R30,R10
    039E5 1DFB      ADC	R31,R11
    039E6 8020      LD	R2,Z
    039E7 8228      ST	Y,R2
    039E8 E021      LDI	R18,1
    039E9 2700      CLR	R16
    039EA D0A9      RCALL	_W_1byte
    039EB 9543      INC	R20
    039EC 2FE4      MOV	R30,R20
    039ED 27FF      CLR	R31
    039EE 0DEA      ADD	R30,R10
    039EF 1DFB      ADC	R31,R11
    039F0 8020      LD	R2,Z
    039F1 2022      TST	R2
    039F2 F761      BNE	0x39DF
(0095)     
(0096)    } 
(0097)    W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    039F3 EF8F      LDI	R24,0xFF
    039F4 8388      ST	Y,R24
    039F5 2722      CLR	R18
    039F6 2700      CLR	R16
    039F7 D09C      RCALL	_W_1byte
    039F8 9621      ADIW	R28,1
    039F9 940C 4157 JMP	pop_xgset30FC
_LCD_var_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    039FB 940E 416D CALL	push_xgset30FC
    039FD 2EE2      MOV	R14,R18
    039FE 2EC0      MOV	R12,R16
    039FF 9721      SBIW	R28,1
    03A00 84A9      LDD	R10,Y+9
    03A01 84BA      LDD	R11,Y+10
(0098)  
(0099) } 
(0100) 
(0101) /******************************************************************** 
(0102) 函数 名：LCD_var_disp
(0103) 入口参数：single_row single_line  *single_data
(0104) 出口参数：无 
(0105) 函数作用：负责 显示一串变量
(0106) 说        明： 
(0107) ********************************************************************/ 
(0108) 
(0109) void LCD_var_disp(unsigned char x, unsigned char y, unsigned char *single_data) 
(0110) { 
(0111) unsigned char  a,i; 
(0112) 
(0113) #if _debug == 1 
(0114) 	PrintString_n(single_data);
(0115) #endif 
(0116) 
(0117) a=address( x,y);
    03A02 2D2E      MOV	R18,R14
    03A03 2D0C      MOV	R16,R12
    03A04 DFA8      RCALL	_address
    03A05 2EC0      MOV	R12,R16
(0118) W_1byte(0,0,a);     //显示的地址0x88 
    03A06 82C8      ST	Y,R12
    03A07 2722      CLR	R18
    03A08 2700      CLR	R16
    03A09 D08A      RCALL	_W_1byte
(0119) 
(0120) for(i=0; single_data[i]!='\0';i++) 
    03A0A 2744      CLR	R20
    03A0B C00D      RJMP	0x3A19
(0121)    { 
(0122)     if(i>=16) break;
    03A0C 3140      CPI	R20,0x10
    03A0D F008      BCS	0x3A0F
    03A0E C011      RJMP	0x3A20
(0123)     W_1byte(0,1,single_data[i]); 
    03A0F 2FE4      MOV	R30,R20
    03A10 27FF      CLR	R31
    03A11 0DEA      ADD	R30,R10
    03A12 1DFB      ADC	R31,R11
    03A13 8020      LD	R2,Z
    03A14 8228      ST	Y,R2
    03A15 E021      LDI	R18,1
    03A16 2700      CLR	R16
    03A17 D07C      RCALL	_W_1byte
    03A18 9543      INC	R20
    03A19 2FE4      MOV	R30,R20
    03A1A 27FF      CLR	R31
    03A1B 0DEA      ADD	R30,R10
    03A1C 1DFB      ADC	R31,R11
    03A1D 8020      LD	R2,Z
    03A1E 2022      TST	R2
    03A1F F761      BNE	0x3A0C
(0124) 	} 
(0125)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03A20 EF8F      LDI	R24,0xFF
    03A21 8388      ST	Y,R24
    03A22 2722      CLR	R18
    03A23 2700      CLR	R16
    03A24 D06F      RCALL	_W_1byte
    03A25 9621      ADIW	R28,1
    03A26 940C 4157 JMP	pop_xgset30FC
_LCD_char_disp:
  a                    --> R12
  data                 --> R10
  y                    --> R14
  x                    --> R12
    03A28 940E 416F CALL	push_xgset00FC
    03A2A 2EE2      MOV	R14,R18
    03A2B 2EC0      MOV	R12,R16
    03A2C 9721      SBIW	R28,1
    03A2D 80AF      LDD	R10,Y+7
(0126) } 
(0127) /******************************************************************** 
(0128) 函数 名：LCD_char_disp
(0129) 入口参数：single_row single_line  data
(0130) 出口参数：无 
(0131) 函数作用：负责 显示一个 变量
(0132) 说        明： 
(0133) ********************************************************************/ 
(0134) 
(0135) void LCD_char_disp(unsigned char x, unsigned char y, unsigned char data) 
(0136) { 
(0137) unsigned char a; 
(0138) a=address(x,y);
    03A2E 2D2E      MOV	R18,R14
    03A2F 2D0C      MOV	R16,R12
    03A30 DF7C      RCALL	_address
    03A31 2EC0      MOV	R12,R16
(0139) W_1byte(0,0,a);     //显示的地址 
    03A32 82C8      ST	Y,R12
    03A33 2722      CLR	R18
    03A34 2700      CLR	R16
    03A35 D05E      RCALL	_W_1byte
(0140) W_1byte(0,1,data);  //显示内容
    03A36 82A8      ST	Y,R10
    03A37 E021      LDI	R18,1
    03A38 2700      CLR	R16
    03A39 D05A      RCALL	_W_1byte
(0141)  
(0142)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03A3A EF8F      LDI	R24,0xFF
    03A3B 8388      ST	Y,R24
    03A3C 2722      CLR	R18
    03A3D 2700      CLR	R16
    03A3E D055      RCALL	_W_1byte
    03A3F 9621      ADIW	R28,1
    03A40 940C 4150 JMP	pop_xgset00FC
_LCD_Init:
  cmd                  --> R20
    03A42 934A      ST	-Y,R20
    03A43 9721      SBIW	R28,1
(0143) } 
(0144) 
(0145) /******************************************************************** 
(0146) 函数 名：LCD_Init
(0147) 入口参数：无
(0148) 出口参数：unsigned char  0/1
(0149) 函数作用：负责 清空液晶显示
(0150) 说        明： 
(0151) ********************************************************************/ 
(0152) void LCD_Init(void) 
(0153) { 
(0154)    unsigned char cmd; 
(0155)    cmd=0x30;      //功能设置 8 位数据，基本指令 
    03A44 E340      LDI	R20,0x30
(0156)   W_1byte(0,0,cmd); 
    03A45 8348      ST	Y,R20
    03A46 2722      CLR	R18
    03A47 2700      CLR	R16
    03A48 D04B      RCALL	_W_1byte
(0157)   delayms(2); 
    03A49 E002      LDI	R16,2
    03A4A E010      LDI	R17,0
    03A4B 940E 2413 CALL	_delayms
(0158)   cmd=0x0C;      //显示状态 ON，游标OFF，反白OFF 
    03A4D E04C      LDI	R20,0xC
(0159)   W_1byte(0,0,cmd); //写指令 
    03A4E 8348      ST	Y,R20
    03A4F 2722      CLR	R18
    03A50 2700      CLR	R16
    03A51 D042      RCALL	_W_1byte
(0160)   delayms(2); 
    03A52 E002      LDI	R16,2
    03A53 E010      LDI	R17,0
    03A54 940E 2413 CALL	_delayms
(0161)   cmd=0x01;      //清除显示 
    03A56 E041      LDI	R20,1
(0162)   W_1byte(0,0,cmd); //写指令 
    03A57 8348      ST	Y,R20
    03A58 2722      CLR	R18
    03A59 2700      CLR	R16
    03A5A D039      RCALL	_W_1byte
(0163)   delayms(2); 
    03A5B E002      LDI	R16,2
    03A5C E010      LDI	R17,0
    03A5D 940E 2413 CALL	_delayms
(0164)   cmd=0x02;      //地址归位 
    03A5F E042      LDI	R20,2
(0165)   W_1byte(0,0,cmd); //写指令 
    03A60 8348      ST	Y,R20
    03A61 2722      CLR	R18
    03A62 2700      CLR	R16
    03A63 D030      RCALL	_W_1byte
(0166)   delayms(2); 
    03A64 E002      LDI	R16,2
    03A65 E010      LDI	R17,0
    03A66 940E 2413 CALL	_delayms
(0167)   cmd=0x80;      //设置DDRAM 地址 
    03A68 E840      LDI	R20,0x80
(0168)   W_1byte(0,0,cmd); //写指令 
    03A69 8348      ST	Y,R20
    03A6A 2722      CLR	R18
    03A6B 2700      CLR	R16
    03A6C D027      RCALL	_W_1byte
(0169)   delayms(2);     //延时 
    03A6D E002      LDI	R16,2
    03A6E E010      LDI	R17,0
    03A6F 940E 2413 CALL	_delayms
    03A71 9621      ADIW	R28,1
    03A72 9149      LD	R20,Y+
    03A73 9508      RET
_LCD_CLR:
  cmd                  --> R20
    03A74 934A      ST	-Y,R20
    03A75 9721      SBIW	R28,1
(0170) } 
(0171) 
(0172) void LCD_CLR(void)
(0173) {
(0174) unsigned char cmd;
(0175)   cmd=0x01;      //清除显示 
    03A76 E041      LDI	R20,1
(0176)   W_1byte(0,0,cmd); //写指令 
    03A77 8348      ST	Y,R20
    03A78 2722      CLR	R18
    03A79 2700      CLR	R16
    03A7A D019      RCALL	_W_1byte
(0177)   delayms(1); 
    03A7B E001      LDI	R16,1
    03A7C E010      LDI	R17,0
    03A7D 940E 2413 CALL	_delayms
(0178)   cmd=0x02;      //地址归位 
    03A7F E042      LDI	R20,2
(0179)   W_1byte(0,0,cmd); //写指令 
    03A80 8348      ST	Y,R20
    03A81 2722      CLR	R18
    03A82 2700      CLR	R16
    03A83 D010      RCALL	_W_1byte
(0180)   delayms(1); 
    03A84 E001      LDI	R16,1
    03A85 E010      LDI	R17,0
    03A86 940E 2413 CALL	_delayms
(0181)   cmd=0x80;      //设置DDRAM 地址 
    03A88 E840      LDI	R20,0x80
(0182)   W_1byte(0,0,cmd); //写指令 
    03A89 8348      ST	Y,R20
    03A8A 2722      CLR	R18
    03A8B 2700      CLR	R16
    03A8C D007      RCALL	_W_1byte
(0183)   delayms(1);     //延时
    03A8D E001      LDI	R16,1
    03A8E E010      LDI	R17,0
    03A8F 940E 2413 CALL	_delayms
    03A91 9621      ADIW	R28,1
    03A92 9149      LD	R20,Y+
    03A93 9508      RET
_W_1byte:
  H_data               --> R22
  S_ID                 --> R10
  L_data               --> R20
  W_data               --> R12
  RS                   --> R14
  RW                   --> R20
    03A94 940E 416B CALL	push_xgsetF0FC
    03A96 2EE2      MOV	R14,R18
    03A97 2F40      MOV	R20,R16
    03A98 84CA      LDD	R12,Y+10
(0184) 
(0185) }
(0186)  
(0187) /*******************************************************************
(0188) 函 数 名：W_1byte
(0189) 入口参数：RW、RS、W_data
(0190) 出口参数：无
(0191) 建立日期：2007年3月3日
(0192) 修改日期：
(0193) 函数作用：写一个字节的数据到12864液晶，包括指令和数据
(0194) 说    明：RW=1，从液晶读数据到MCU；RW=0，写一个数据到液晶；
(0195) 		 （一般RW都设为0，即只向液晶写数据，不读数据）
(0196)           RS=1，写入的是数据；RS=0，写入的是指令；
(0197) 		  一般模式：RW=0，RS=1;写数据
(0198) 		  			RW=0，RS=0;写指令
(0199) ********************************************************************/
(0200) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data)
(0201) {
(0202) 	unsigned int H_data,L_data,S_ID = 0xf8;	 //11111RWRS0
    03A99 EF88      LDI	R24,0xF8
    03A9A E090      LDI	R25,0
    03A9B 015C      MOVW	R10,R24
(0203) 	if(RW == 0)
    03A9C 2344      TST	R20
    03A9D F419      BNE	0x3AA1
(0204) 	{
(0205) 	 	S_ID &=~ 0x04;
    03A9E 7F8B      ANDI	R24,0xFB
    03A9F 015C      MOVW	R10,R24
(0206) 	}
    03AA0 C003      RJMP	0x3AA4
(0207) 	else					//if(RW==1)
(0208) 	{
(0209) 	 	S_ID |= 0X04;
    03AA1 01C5      MOVW	R24,R10
    03AA2 6084      ORI	R24,4
    03AA3 015C      MOVW	R10,R24
(0210) 	}
(0211) 	if(RS == 0)
    03AA4 20EE      TST	R14
    03AA5 F421      BNE	0x3AAA
(0212) 	{
(0213) 	 	S_ID &=~ 0x02;
    03AA6 01C5      MOVW	R24,R10
    03AA7 7F8D      ANDI	R24,0xFD
    03AA8 015C      MOVW	R10,R24
(0214) 	}
    03AA9 C003      RJMP	0x3AAD
(0215) 	else					//if(RS==1)
(0216) 	{
(0217) 	 	S_ID |= 0X02;
    03AAA 01C5      MOVW	R24,R10
    03AAB 6082      ORI	R24,2
    03AAC 015C      MOVW	R10,R24
(0218) 	}
(0219) 	H_data = W_data;
    03AAD 2D6C      MOV	R22,R12
    03AAE 2777      CLR	R23
(0220) 	H_data &= 0xf0;			//屏蔽低4位的数据
    03AAF 7F60      ANDI	R22,0xF0
    03AB0 7070      ANDI	R23,0
(0221) 	L_data = W_data;	   	//xxxx0000格式
    03AB1 2D4C      MOV	R20,R12
    03AB2 2755      CLR	R21
(0222) 	L_data &= 0x0f;			//屏蔽高4位的数据
    03AB3 704F      ANDI	R20,0xF
    03AB4 7050      ANDI	R21,0
(0223) 	L_data <<= 4;			//xxxx0000格式
    03AB5 0F44      LSL	R20
    03AB6 1F55      ROL	R21
    03AB7 0F44      LSL	R20
    03AB8 1F55      ROL	R21
    03AB9 0F44      LSL	R20
    03ABA 1F55      ROL	R21
    03ABB 0F44      LSL	R20
    03ABC 1F55      ROL	R21
(0224) 	Set_CS();
    03ABD 9AA4      SBI	0x14,4
    03ABE 9AAC      SBI	0x15,4
(0225) 	Write_8bits(S_ID); 		//发送S_ID
    03ABF 0185      MOVW	R16,R10
    03AC0 D00C      RCALL	_Write_8bits
(0226) 	Write_8bits(H_data);	//发送H_data
    03AC1 018B      MOVW	R16,R22
    03AC2 D00A      RCALL	_Write_8bits
(0227) 	Write_8bits(L_data);	//发送L_data
    03AC3 018A      MOVW	R16,R20
    03AC4 D008      RCALL	_Write_8bits
(0228) 	Clr_CS();	Clr_CS();	Clr_CS();	
    03AC5 9AA4      SBI	0x14,4
    03AC6 98AC      CBI	0x15,4
    03AC7 9AA4      SBI	0x14,4
    03AC8 98AC      CBI	0x15,4
    03AC9 9AA4      SBI	0x14,4
    03ACA 98AC      CBI	0x15,4
    03ACB 940C 4160 JMP	pop_xgsetF0FC
_Write_8bits:
  Temp_data            --> R12
  i                    --> R20
  W_bits               --> R10
    03ACD 940E 4198 CALL	push_xgset303C
    03ACF 0158      MOVW	R10,R16
(0229) 	 
(0230) 
(0231) }
(0232) /********************************************************************
(0233) 函 数 名：Write_8bits
(0234) 入口参数：W_bits
(0235) 出口参数：无
(0236) 建立日期：2007年3月3日
(0237) 修改日期：
(0238) 函数作用：负责串行输出8个bit位
(0239) 说    明：
(0240) ********************************************************************/
(0241) void Write_8bits(unsigned int W_bits)
(0242) {
(0243) 	unsigned int i,Temp_data;
(0244) 	for(i=0; i<8; i++)
    03AD0 2744      CLR	R20
    03AD1 2755      CLR	R21
    03AD2 C019      RJMP	0x3AEC
(0245) 	{
(0246) 		Temp_data = W_bits;
    03AD3 0165      MOVW	R12,R10
(0247) 		Temp_data <<= i;
    03AD4 019A      MOVW	R18,R20
    03AD5 0186      MOVW	R16,R12
    03AD6 940E 41E6 CALL	lsl16
    03AD8 0168      MOVW	R12,R16
(0248) 		if((Temp_data&0x80)==0) 
    03AD9 FD07      SBRC	R16,7
    03ADA C003      RJMP	0x3ADE
(0249) 		{
(0250) 		 	Clr_SID();
    03ADB 9AA3      SBI	0x14,3
    03ADC 98AB      CBI	0x15,3
(0251) 		}
    03ADD C002      RJMP	0x3AE0
(0252) 		else
(0253) 		{
(0254) 		 	Set_SID();
    03ADE 9AA3      SBI	0x14,3
    03ADF 9AAB      SBI	0x15,3
(0255) 		} 
(0256) 		NOP();
    03AE0 0000      NOP
(0257) 		Set_SCLK();
    03AE1 9AA2      SBI	0x14,2
    03AE2 9AAA      SBI	0x15,2
(0258) 		NOP();
    03AE3 0000      NOP
(0259) 		NOP();
    03AE4 0000      NOP
(0260) 		Clr_SCLK();
    03AE5 9AA2      SBI	0x14,2
    03AE6 98AA      CBI	0x15,2
(0261) 		NOP();
    03AE7 0000      NOP
(0262) 		Clr_SID();
    03AE8 9AA3      SBI	0x14,3
    03AE9 98AB      CBI	0x15,3
    03AEA 5F4F      SUBI	R20,0xFF
    03AEB 4F5F      SBCI	R21,0xFF
    03AEC 3048      CPI	R20,0x8
    03AED E0E0      LDI	R30,0
    03AEE 075E      CPC	R21,R30
    03AEF F318      BCS	0x3AD3
    03AF0 940C 419F JMP	pop_xgset303C
_Set_Draw:
    03AF2 9721      SBIW	R28,1
(0263) 	}
(0264) }
(0265)  
(0266) /********************************************************************
(0267) 函 数 名：Set_Draw(
(0268) 入口参数：无
(0269) 出口参数：无
(0270) 函数作用：设置为绘图模式
(0271) 说    明：
(0272) ********************************************************************/
(0273) void Set_Draw(void)
(0274) {  	
(0275) 	//W_1byte(0,0,0x34);			//8BIT控制界面，扩充指令集,，绘图显示OFF
(0276) 	W_1byte(0,0,0x36);
    03AF3 E386      LDI	R24,0x36
    03AF4 8388      ST	Y,R24
    03AF5 2722      CLR	R18
    03AF6 2700      CLR	R16
    03AF7 DF9C      RCALL	_W_1byte
(0277) 	delayms(1);					//延时
    03AF8 E001      LDI	R16,1
    03AF9 E010      LDI	R17,0
    03AFA 940E 2413 CALL	_delayms
    03AFC 9621      ADIW	R28,1
    03AFD 9508      RET
_Set_White:
  clr_y                --> R10
  clr_x                --> R20
  white_y              --> Y,+2
  white_x              --> Y,+1
  i                    --> R22
  white_end_x          --> R12
  j                    --> R14
  clear                --> Y,+15
  end_x                --> R12
  y                    --> R14
  x                    --> R22
    03AFE 940E 416B CALL	push_xgsetF0FC
    03B00 2EE2      MOV	R14,R18
    03B01 2F60      MOV	R22,R16
    03B02 9723      SBIW	R28,3
    03B03 84CD      LDD	R12,Y+13
(0278) } 
(0279)  
(0280) 
(0281) /******************************************************************** 
(0282) 函数 名：Set_White 
(0283) 入口参数：  x,   y,  end_x,  clear
(0284) 出口参数：无 
(0285) 函数作用： 设置反显
(0286) 说        明： 
(0287) ********************************************************************/ 
(0288) void Set_White(unsigned char x,unsigned char y,unsigned char end_x,unsigned char clear)
(0289) {
(0290)  
(0291) 	unsigned char i, j, white_x, white_y,white_end_x,clr_x,clr_y ;		//
(0292)   
(0293) 	W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03B04 E386      LDI	R24,0x36
    03B05 8388      ST	Y,R24
    03B06 2722      CLR	R18
    03B07 2700      CLR	R16
    03B08 DF8B      RCALL	_W_1byte
(0294) 	delayus(20);					//延时
    03B09 E104      LDI	R16,0x14
    03B0A E010      LDI	R17,0
    03B0B 940E 240B CALL	_delayus
(0295)  
(0296) 	white_end_x = (end_x-x+1);
    03B0D 2D8C      MOV	R24,R12
    03B0E 1B86      SUB	R24,R22
    03B0F 5F8F      SUBI	R24,0xFF
    03B10 2EC8      MOV	R12,R24
(0297) 	white_end_x <<= 1;
    03B11 0CCC      LSL	R12
(0298) 	if(y==1)   //x,1  a=80+x-1                   
    03B12 2D8E      MOV	R24,R14
    03B13 3081      CPI	R24,1
    03B14 F449      BNE	0x3B1E
(0299) 	{
(0300) 	 	white_x = (0x80+x-1); 
    03B15 2F86      MOV	R24,R22
    03B16 5880      SUBI	R24,0x80
    03B17 5081      SUBI	R24,1
    03B18 8389      STD	Y+1,R24
(0301) 		white_y = 0x80;
    03B19 E880      LDI	R24,0x80
    03B1A 838A      STD	Y+2,R24
(0302) 		clr_x = 0x80;
    03B1B E840      LDI	R20,0x80
(0303) 		clr_y = 0x80;
    03B1C 2EA8      MOV	R10,R24
(0304) 	}
    03B1D C023      RJMP	0x3B41
(0305) 	else if(y==2)
    03B1E 2D8E      MOV	R24,R14
    03B1F 3082      CPI	R24,2
    03B20 F449      BNE	0x3B2A
(0306) 	{
(0307) 	 	white_x = (0x80+x-1);
    03B21 2F86      MOV	R24,R22
    03B22 5880      SUBI	R24,0x80
    03B23 5081      SUBI	R24,1
    03B24 8389      STD	Y+1,R24
(0308) 		white_y = 0x90;
    03B25 E980      LDI	R24,0x90
    03B26 838A      STD	Y+2,R24
(0309) 		clr_x = 0x80;
    03B27 E840      LDI	R20,0x80
(0310) 		clr_y = 0x90;
    03B28 2EA8      MOV	R10,R24
(0311) 	}
    03B29 C017      RJMP	0x3B41
(0312) 	else if(y==3)
    03B2A 2D8E      MOV	R24,R14
    03B2B 3083      CPI	R24,3
    03B2C F449      BNE	0x3B36
(0313) 	{
(0314) 	 	white_x = (0x88+x-1);
    03B2D 2F86      MOV	R24,R22
    03B2E 5788      SUBI	R24,0x78
    03B2F 5081      SUBI	R24,1
    03B30 8389      STD	Y+1,R24
(0315) 		white_y = 0x80;
    03B31 E880      LDI	R24,0x80
    03B32 838A      STD	Y+2,R24
(0316) 		clr_x = 0x88;
    03B33 E848      LDI	R20,0x88
(0317) 		clr_y = 0x80;
    03B34 2EA8      MOV	R10,R24
(0318) 	}
    03B35 C00B      RJMP	0x3B41
(0319) 	else if(y==4)
    03B36 2D8E      MOV	R24,R14
    03B37 3084      CPI	R24,4
    03B38 F441      BNE	0x3B41
(0320) 	{
(0321) 	 	white_x = (0x88+x-1);
    03B39 2F86      MOV	R24,R22
    03B3A 5788      SUBI	R24,0x78
    03B3B 5081      SUBI	R24,1
    03B3C 8389      STD	Y+1,R24
(0322) 		white_y = 0x90;
    03B3D E980      LDI	R24,0x90
    03B3E 838A      STD	Y+2,R24
(0323) 		clr_x = 0x88;
    03B3F E848      LDI	R20,0x88
(0324) 		clr_y = 0x90;
    03B40 2EA8      MOV	R10,R24
(0325) 	}
(0326)   if(clear==0)//要反白时，先将整行的液晶全部清成不反白（此处行指y）
    03B41 840F      LDD	R0,Y+15
    03B42 2000      TST	R0
    03B43 F4E9      BNE	0x3B61
(0327) 	{
(0328) 	 	for(i=0;i<16;i++ )			//16行
    03B44 2766      CLR	R22
    03B45 C019      RJMP	0x3B5F
(0329) 		{
(0330) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03B46 2C2A      MOV	R2,R10
    03B47 2D82      MOV	R24,R2
    03B48 5F8F      SUBI	R24,0xFF
    03B49 2EA8      MOV	R10,R24
    03B4A 8228      ST	Y,R2
    03B4B 2722      CLR	R18
    03B4C 2700      CLR	R16
    03B4D DF46      RCALL	_W_1byte
(0331) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03B4E 8348      ST	Y,R20
    03B4F 2722      CLR	R18
    03B50 2700      CLR	R16
    03B51 DF42      RCALL	_W_1byte
(0332) 			for(j=0;j<16;j++)		//
    03B52 24EE      CLR	R14
    03B53 C007      RJMP	0x3B5B
(0333) 			{
(0334) 			 	W_1byte(0,1,0x00);	//清成不反白
    03B54 2422      CLR	R2
    03B55 8228      ST	Y,R2
    03B56 E021      LDI	R18,1
    03B57 2700      CLR	R16
    03B58 DF3B      RCALL	_W_1byte
(0335) 			 	nop();
    03B59 0000      NOP
    03B5A 94E3      INC	R14
    03B5B 2D8E      MOV	R24,R14
    03B5C 3180      CPI	R24,0x10
    03B5D F3B0      BCS	0x3B54
    03B5E 9563      INC	R22
    03B5F 3160      CPI	R22,0x10
    03B60 F328      BCS	0x3B46
(0336) 			}
(0337) 		}
(0338) 	}
(0339) 	nop();
    03B61 0000      NOP
(0340) //	
(0341) 	for(i=0;i<16;i++ )				//16行，因为是16*16汉字
    03B62 2766      CLR	R22
    03B63 C022      RJMP	0x3B86
(0342) 	{
(0343) 		W_1byte(0,0,white_y++);		//设置绘图区的Y地址坐标0
    03B64 802A      LDD	R2,Y+2
    03B65 2D82      MOV	R24,R2
    03B66 5F8F      SUBI	R24,0xFF
    03B67 838A      STD	Y+2,R24
    03B68 8228      ST	Y,R2
    03B69 2722      CLR	R18
    03B6A 2700      CLR	R16
    03B6B DF28      RCALL	_W_1byte
(0344) 		W_1byte(0,0,white_x);		//设置绘图区的X地址坐标0
    03B6C 8009      LDD	R0,Y+1
    03B6D 8208      ST	Y,R0
    03B6E 2722      CLR	R18
    03B6F 2700      CLR	R16
    03B70 DF23      RCALL	_W_1byte
(0345) 		for(j=0;j<white_end_x;j++)	//
    03B71 24EE      CLR	R14
    03B72 C010      RJMP	0x3B83
(0346) 		{
(0347) 			 if(clear==1)
    03B73 858F      LDD	R24,Y+15
    03B74 3081      CPI	R24,1
    03B75 F431      BNE	0x3B7C
(0348) 			 {
(0349) 			  	W_1byte(0,1,0x00); //取消这一行的8个点的反白，液晶地址自动加1
    03B76 2422      CLR	R2
    03B77 8228      ST	Y,R2
    03B78 E021      LDI	R18,1
    03B79 2700      CLR	R16
    03B7A DF19      RCALL	_W_1byte
(0350) 								   //（此处行指一个一个液晶点所组成的行）
(0351) 			 }
    03B7B C005      RJMP	0x3B81
(0352) 			 else
(0353) 			 {
(0354) 				W_1byte(0,1,0xff); //反白这一行的8个点，液晶地址自动加1
    03B7C EF8F      LDI	R24,0xFF
    03B7D 8388      ST	Y,R24
    03B7E E021      LDI	R18,1
    03B7F 2700      CLR	R16
    03B80 DF13      RCALL	_W_1byte
(0355) 								   //（此处行指一个一个液晶点所组成的行）
(0356) 			 }
(0357) 			nop();
    03B81 0000      NOP
    03B82 94E3      INC	R14
    03B83 14EC      CP	R14,R12
    03B84 F370      BCS	0x3B73
    03B85 9563      INC	R22
    03B86 3160      CPI	R22,0x10
    03B87 F2E0      BCS	0x3B64
(0358) 		}
(0359) 	}
(0360) 	W_1byte(0,0,0x30);		//基本指令集,，绘图显示OFF
    03B88 E380      LDI	R24,0x30
    03B89 8388      ST	Y,R24
    03B8A 2722      CLR	R18
    03B8B 2700      CLR	R16
    03B8C DF07      RCALL	_W_1byte
    03B8D 9623      ADIW	R28,3
    03B8E 940C 4160 JMP	pop_xgsetF0FC
_set_white_n:
  tempendx             --> R10
  tempy                --> R22
  tempx                --> R20
  clear                --> R12
  n                    --> R14
    03B90 940E 416B CALL	push_xgsetF0FC
    03B92 2EC2      MOV	R12,R18
    03B93 2EE0      MOV	R14,R16
    03B94 9723      SBIW	R28,3
(0361)  }
(0362) 
(0363) /******************************************************************** 
(0364) 函数 名：set_white_n
(0365) 入口参数： n ,  clear
(0366) 出口参数：无 
(0367) 函数作用：   将四行分成八个位置。n代表位置1-8。本函数用于反显或取消反显
(0368)           某一位置的文字。
(0369) 说        明： 例如 set_white_n(1,0); 表示反显第一行前四个字
(0370) ********************************************************************/ 
(0371) void set_white_n(unsigned char n,unsigned char clear)
(0372) {
(0373) unsigned char tempx,tempy,tempendx;
(0374) if(n==1) {tempx=1;tempy=1;tempendx=4;}
    03B95 2D8E      MOV	R24,R14
    03B96 3081      CPI	R24,1
    03B97 F429      BNE	0x3B9D
    03B98 E041      LDI	R20,1
    03B99 E061      LDI	R22,1
    03B9A E084      LDI	R24,4
    03B9B 2EA8      MOV	R10,R24
    03B9C C037      RJMP	0x3BD4
(0375) else if(n==2) {tempx=5;tempy=1;tempendx=8;}
    03B9D 2D8E      MOV	R24,R14
    03B9E 3082      CPI	R24,2
    03B9F F429      BNE	0x3BA5
    03BA0 E045      LDI	R20,5
    03BA1 E061      LDI	R22,1
    03BA2 E088      LDI	R24,0x8
    03BA3 2EA8      MOV	R10,R24
    03BA4 C02F      RJMP	0x3BD4
(0376) else if(n==3) {tempx=1;tempy=2;tempendx=4;}
    03BA5 2D8E      MOV	R24,R14
    03BA6 3083      CPI	R24,3
    03BA7 F429      BNE	0x3BAD
    03BA8 E041      LDI	R20,1
    03BA9 E062      LDI	R22,2
    03BAA E084      LDI	R24,4
    03BAB 2EA8      MOV	R10,R24
    03BAC C027      RJMP	0x3BD4
(0377) else if(n==4) {tempx=5;tempy=2;tempendx=8;}
    03BAD 2D8E      MOV	R24,R14
    03BAE 3084      CPI	R24,4
    03BAF F429      BNE	0x3BB5
    03BB0 E045      LDI	R20,5
    03BB1 E062      LDI	R22,2
    03BB2 E088      LDI	R24,0x8
    03BB3 2EA8      MOV	R10,R24
    03BB4 C01F      RJMP	0x3BD4
(0378) else if(n==5) {tempx=1;tempy=3;tempendx=4;}
    03BB5 2D8E      MOV	R24,R14
    03BB6 3085      CPI	R24,5
    03BB7 F429      BNE	0x3BBD
    03BB8 E041      LDI	R20,1
    03BB9 E063      LDI	R22,3
    03BBA E084      LDI	R24,4
    03BBB 2EA8      MOV	R10,R24
    03BBC C017      RJMP	0x3BD4
(0379) else if(n==6) {tempx=5;tempy=3;tempendx=8;}
    03BBD 2D8E      MOV	R24,R14
    03BBE 3086      CPI	R24,6
    03BBF F429      BNE	0x3BC5
    03BC0 E045      LDI	R20,5
    03BC1 E063      LDI	R22,3
    03BC2 E088      LDI	R24,0x8
    03BC3 2EA8      MOV	R10,R24
    03BC4 C00F      RJMP	0x3BD4
(0380) else if(n==7) {tempx=1;tempy=4;tempendx=4;}
    03BC5 2D8E      MOV	R24,R14
    03BC6 3087      CPI	R24,7
    03BC7 F429      BNE	0x3BCD
    03BC8 E041      LDI	R20,1
    03BC9 E064      LDI	R22,4
    03BCA E084      LDI	R24,4
    03BCB 2EA8      MOV	R10,R24
    03BCC C007      RJMP	0x3BD4
(0381) else if(n==8) {tempx=5;tempy=4;tempendx=8;}
    03BCD 2D8E      MOV	R24,R14
    03BCE 3088      CPI	R24,0x8
    03BCF F421      BNE	0x3BD4
    03BD0 E045      LDI	R20,5
    03BD1 E064      LDI	R22,4
    03BD2 E088      LDI	R24,0x8
    03BD3 2EA8      MOV	R10,R24
(0382) Set_White(tempx,tempy,tempendx,clear);
    03BD4 82CA      STD	Y+2,R12
    03BD5 82A8      ST	Y,R10
    03BD6 2F26      MOV	R18,R22
    03BD7 2F04      MOV	R16,R20
    03BD8 DF25      RCALL	_Set_White
    03BD9 9623      ADIW	R28,3
    03BDA 940C 4160 JMP	pop_xgsetF0FC
_clr_white:
  clr_x                --> R10
  clr_y                --> R20
  i                    --> R22
  j                    --> R12
    03BDC 940E 416B CALL	push_xgsetF0FC
    03BDE 9721      SBIW	R28,1
(0383) 
(0384) }
(0385)  
(0386) /******************************************************************** 
(0387) 函数 名：clr_white
(0388) 入口参数： 清所有 反白
(0389) 出口参数：无 
(0390) 函数作用： 
(0391) 说        明： 
(0392) ********************************************************************/ 
(0393) void clr_white(void)
(0394) {      unsigned char i,j;
(0395) 
(0396)        unsigned char  clr_y=0x80;
    03BDF E840      LDI	R20,0x80
(0397) 	   unsigned char  clr_x=0x80;
    03BE0 E880      LDI	R24,0x80
    03BE1 2EA8      MOV	R10,R24
(0398) 	   W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03BE2 E386      LDI	R24,0x36
    03BE3 8388      ST	Y,R24
    03BE4 2722      CLR	R18
    03BE5 2700      CLR	R16
    03BE6 DEAD      RCALL	_W_1byte
(0399) 	 	for(i=0;i<16;i++ )			//16行
    03BE7 2766      CLR	R22
    03BE8 C017      RJMP	0x3C00
(0400) 		{
(0401) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03BE9 2E24      MOV	R2,R20
    03BEA 5F4F      SUBI	R20,0xFF
    03BEB 8228      ST	Y,R2
    03BEC 2722      CLR	R18
    03BED 2700      CLR	R16
    03BEE DEA5      RCALL	_W_1byte
(0402) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03BEF 82A8      ST	Y,R10
    03BF0 2722      CLR	R18
    03BF1 2700      CLR	R16
    03BF2 DEA1      RCALL	_W_1byte
(0403) 			for(j=0;j<16;j++)		//
    03BF3 24CC      CLR	R12
    03BF4 C007      RJMP	0x3BFC
(0404) 			{
(0405) 			 	W_1byte(0,1,0x00);	//清成不反白
    03BF5 2422      CLR	R2
    03BF6 8228      ST	Y,R2
    03BF7 E021      LDI	R18,1
    03BF8 2700      CLR	R16
    03BF9 DE9A      RCALL	_W_1byte
(0406) 			 	nop();
    03BFA 0000      NOP
    03BFB 94C3      INC	R12
    03BFC 2D8C      MOV	R24,R12
    03BFD 3180      CPI	R24,0x10
    03BFE F3B0      BCS	0x3BF5
    03BFF 9563      INC	R22
    03C00 3160      CPI	R22,0x10
    03C01 F338      BCS	0x3BE9
(0407) 			}
(0408) 		}
(0409) 	
(0410) 	    clr_y=0x80;
    03C02 E840      LDI	R20,0x80
(0411) 	    clr_x=0x90;
    03C03 E980      LDI	R24,0x90
    03C04 2EA8      MOV	R10,R24
(0412) 		 	for(i=0;i<16;i++ )			//16行
    03C05 2766      CLR	R22
    03C06 C017      RJMP	0x3C1E
(0413) 		{
(0414) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03C07 2E24      MOV	R2,R20
    03C08 5F4F      SUBI	R20,0xFF
    03C09 8228      ST	Y,R2
    03C0A 2722      CLR	R18
    03C0B 2700      CLR	R16
    03C0C DE87      RCALL	_W_1byte
(0415) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03C0D 82A8      ST	Y,R10
    03C0E 2722      CLR	R18
    03C0F 2700      CLR	R16
    03C10 DE83      RCALL	_W_1byte
(0416) 			for(j=0;j<16;j++)		//
    03C11 24CC      CLR	R12
    03C12 C007      RJMP	0x3C1A
(0417) 			{
(0418) 			 	W_1byte(0,1,0x00);	//清成不反白
    03C13 2422      CLR	R2
    03C14 8228      ST	Y,R2
    03C15 E021      LDI	R18,1
    03C16 2700      CLR	R16
    03C17 DE7C      RCALL	_W_1byte
(0419) 			 	nop();
    03C18 0000      NOP
    03C19 94C3      INC	R12
    03C1A 2D8C      MOV	R24,R12
    03C1B 3180      CPI	R24,0x10
    03C1C F3B0      BCS	0x3C13
    03C1D 9563      INC	R22
    03C1E 3160      CPI	R22,0x10
    03C1F F338      BCS	0x3C07
(0420) 			}
(0421) 		}   
(0422) 	   
(0423) 	     clr_y=0x88;
    03C20 E848      LDI	R20,0x88
(0424) 	     clr_x=0x80;
    03C21 E880      LDI	R24,0x80
    03C22 2EA8      MOV	R10,R24
(0425) 		 	for(i=0;i<16;i++ )			//16行
    03C23 2766      CLR	R22
    03C24 C017      RJMP	0x3C3C
(0426) 		{
(0427) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03C25 2EE4      MOV	R14,R20
    03C26 5F4F      SUBI	R20,0xFF
    03C27 82E8      ST	Y,R14
    03C28 2722      CLR	R18
    03C29 2700      CLR	R16
    03C2A DE69      RCALL	_W_1byte
(0428) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03C2B 82A8      ST	Y,R10
    03C2C 2722      CLR	R18
    03C2D 2700      CLR	R16
    03C2E DE65      RCALL	_W_1byte
(0429) 			for(j=0;j<16;j++)		//
    03C2F 24CC      CLR	R12
    03C30 C007      RJMP	0x3C38
(0430) 			{
(0431) 			 	W_1byte(0,1,0x00);	//清成不反白
    03C31 2422      CLR	R2
    03C32 8228      ST	Y,R2
    03C33 E021      LDI	R18,1
    03C34 2700      CLR	R16
    03C35 DE5E      RCALL	_W_1byte
(0432) 			 	nop();
    03C36 0000      NOP
    03C37 94C3      INC	R12
    03C38 2D8C      MOV	R24,R12
    03C39 3180      CPI	R24,0x10
    03C3A F3B0      BCS	0x3C31
    03C3B 9563      INC	R22
    03C3C 3160      CPI	R22,0x10
    03C3D F338      BCS	0x3C25
(0433) 			}
(0434) 		} 
(0435) 	     clr_y=0x88;
    03C3E E848      LDI	R20,0x88
(0436) 	     clr_x=0x90;
    03C3F E980      LDI	R24,0x90
    03C40 2EA8      MOV	R10,R24
(0437) 		 	for(i=0;i<16;i++ )			//16行
    03C41 2766      CLR	R22
    03C42 C017      RJMP	0x3C5A
(0438) 		{
(0439) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03C43 2EE4      MOV	R14,R20
    03C44 5F4F      SUBI	R20,0xFF
    03C45 82E8      ST	Y,R14
    03C46 2722      CLR	R18
    03C47 2700      CLR	R16
    03C48 DE4B      RCALL	_W_1byte
(0440) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03C49 82A8      ST	Y,R10
    03C4A 2722      CLR	R18
    03C4B 2700      CLR	R16
    03C4C DE47      RCALL	_W_1byte
(0441) 			for(j=0;j<16;j++)		//
    03C4D 24CC      CLR	R12
    03C4E C007      RJMP	0x3C56
(0442) 			{
(0443) 			 	W_1byte(0,1,0x00);	//清成不反白
    03C4F 2422      CLR	R2
    03C50 8228      ST	Y,R2
    03C51 E021      LDI	R18,1
    03C52 2700      CLR	R16
    03C53 DE40      RCALL	_W_1byte
(0444) 			 	nop();
    03C54 0000      NOP
    03C55 94C3      INC	R12
    03C56 2D8C      MOV	R24,R12
    03C57 3180      CPI	R24,0x10
    03C58 F3B0      BCS	0x3C4F
    03C59 9563      INC	R22
    03C5A 3160      CPI	R22,0x10
    03C5B F338      BCS	0x3C43
(0445) 			}
(0446) 		} 		
(0447)   W_1byte(0,0,0x30);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03C5C E380      LDI	R24,0x30
    03C5D 8388      ST	Y,R24
    03C5E 2722      CLR	R18
    03C5F 2700      CLR	R16
    03C60 DE33      RCALL	_W_1byte
    03C61 9621      ADIW	R28,1
    03C62 940C 4160 JMP	pop_xgsetF0FC
_LCD_print2num:
  a                    --> R12
  tem                  --> R20
  num                  --> R10
  y                    --> R14
  x                    --> R12
    03C64 940E 416D CALL	push_xgset30FC
    03C66 2EE2      MOV	R14,R18
    03C67 2EC0      MOV	R12,R16
    03C68 9721      SBIW	R28,1
    03C69 84A9      LDD	R10,Y+9
(0448) 	}
(0449) /******************************************************************** 
(0450) 函数 名：LCD_print2num
(0451) 入口参数： 显示2数字
(0452) 出口参数：无 
(0453) 函数作用： 
(0454) 说        明： 
(0455) ********************************************************************/ 
(0456) void LCD_print2num(unsigned char x,unsigned char y,unsigned char num){
(0457) unsigned char tem;
(0458) unsigned char a; 
(0459) 
(0460) a=address(x,y);
    03C6A 2D2E      MOV	R18,R14
    03C6B 2D0C      MOV	R16,R12
    03C6C DD40      RCALL	_address
    03C6D 2EC0      MOV	R12,R16
(0461) W_1byte(0,0,a);     //显示的地址 
    03C6E 82C8      ST	Y,R12
    03C6F 2722      CLR	R18
    03C70 2700      CLR	R16
    03C71 DE22      RCALL	_W_1byte
(0462) tem=num/10;
    03C72 E01A      LDI	R17,0xA
    03C73 2D0A      MOV	R16,R10
    03C74 940E 40DD CALL	div8u
    03C76 2F40      MOV	R20,R16
(0463) W_1byte(0,1,tem+0x30);
    03C77 2F84      MOV	R24,R20
    03C78 5D80      SUBI	R24,0xD0
    03C79 8388      ST	Y,R24
    03C7A E021      LDI	R18,1
    03C7B 2700      CLR	R16
    03C7C DE17      RCALL	_W_1byte
(0464) tem=num%10;
    03C7D E01A      LDI	R17,0xA
    03C7E 2D0A      MOV	R16,R10
    03C7F 940E 40DB CALL	mod8u
    03C81 2F40      MOV	R20,R16
(0465) W_1byte(0,1,tem+0x30); 
    03C82 2F84      MOV	R24,R20
    03C83 5D80      SUBI	R24,0xD0
    03C84 8388      ST	Y,R24
    03C85 E021      LDI	R18,1
    03C86 2700      CLR	R16
    03C87 DE0C      RCALL	_W_1byte
(0466) W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03C88 EF8F      LDI	R24,0xFF
    03C89 8388      ST	Y,R24
    03C8A 2722      CLR	R18
    03C8B 2700      CLR	R16
    03C8C DE07      RCALL	_W_1byte
    03C8D 9621      ADIW	R28,1
    03C8E 940C 4157 JMP	pop_xgset30FC
_LCD_print4num:
  tem                  --> R12
  num                  --> R14
  y                    --> R20
  x                    --> R10
    03C90 940E 416D CALL	push_xgset30FC
    03C92 2F42      MOV	R20,R18
    03C93 2EA0      MOV	R10,R16
    03C94 9721      SBIW	R28,1
    03C95 84E9      LDD	R14,Y+9
    03C96 84FA      LDD	R15,Y+10
(0467) }
(0468)  
(0469) /******************************************************************** 
(0470) 函数 名：LCD_print4num
(0471) 入口参数： 显示4数字
(0472) 出口参数：无 
(0473) 函数作用： 
(0474) 说        明： 
(0475) ********************************************************************/ 
(0476) void LCD_print4num(unsigned char x,unsigned char y,unsigned int num){
(0477) unsigned char tem;
(0478) tem=num/100;
    03C97 E624      LDI	R18,0x64
    03C98 E030      LDI	R19,0
    03C99 0187      MOVW	R16,R14
    03C9A 940E 4057 CALL	div16u
    03C9C 2EC0      MOV	R12,R16
(0479) LCD_print2num(x,y,tem);
    03C9D 82C8      ST	Y,R12
    03C9E 2F24      MOV	R18,R20
    03C9F 2D0A      MOV	R16,R10
    03CA0 DFC3      RCALL	_LCD_print2num
(0480) 
(0481) tem=num%100;   
    03CA1 E624      LDI	R18,0x64
    03CA2 E030      LDI	R19,0
    03CA3 0187      MOVW	R16,R14
    03CA4 940E 4055 CALL	mod16u
    03CA6 2EC0      MOV	R12,R16
(0482) LCD_print2num(x,y+1,tem);
    03CA7 82C8      ST	Y,R12
    03CA8 2F24      MOV	R18,R20
    03CA9 5F2F      SUBI	R18,0xFF
    03CAA 2D0A      MOV	R16,R10
    03CAB DFB8      RCALL	_LCD_print2num
(0483) 
(0484) 
(0485)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03CAC EF8F      LDI	R24,0xFF
    03CAD 8388      ST	Y,R24
    03CAE 2722      CLR	R18
    03CAF 2700      CLR	R16
    03CB0 DDE3      RCALL	_W_1byte
    03CB1 9621      ADIW	R28,1
    03CB2 940C 4157 JMP	pop_xgset30FC
_LCD_print:
  a                    --> R12
  ch                   --> R10
  y                    --> R14
  x                    --> R12
    03CB4 940E 416F CALL	push_xgset00FC
    03CB6 2EE2      MOV	R14,R18
    03CB7 2EC0      MOV	R12,R16
    03CB8 9721      SBIW	R28,1
    03CB9 80AF      LDD	R10,Y+7
(0486) }
(0487)  
(0488) //////////////////////////////////////////////////////////////
(0489) 
(0490) /******************************************************************** 
(0491) 函数 名：LCD_print 
(0492) 入口参数： 显示1 ascii
(0493) 出口参数：无 
(0494) 函数作用： 
(0495) 说        明： 
(0496) ********************************************************************/ 
(0497) void LCD_print(unsigned char x,unsigned char y,unsigned char ch)
(0498) {  
(0499) unsigned char a; 
(0500) a=address(x,y);
    03CBA 2D2E      MOV	R18,R14
    03CBB 2D0C      MOV	R16,R12
    03CBC DCF0      RCALL	_address
    03CBD 2EC0      MOV	R12,R16
(0501) W_1byte(0,0,a);     //显示的地址 
    03CBE 82C8      ST	Y,R12
    03CBF 2722      CLR	R18
    03CC0 2700      CLR	R16
    03CC1 DDD2      RCALL	_W_1byte
(0502) W_1byte(0,1,ch); 
    03CC2 82A8      ST	Y,R10
    03CC3 E021      LDI	R18,1
    03CC4 2700      CLR	R16
    03CC5 DDCE      RCALL	_W_1byte
    03CC6 9621      ADIW	R28,1
    03CC7 940C 4150 JMP	pop_xgset00FC
_LCD_print1:
  ch                   --> R10
    03CC9 92AA      ST	-Y,R10
    03CCA 2EA0      MOV	R10,R16
    03CCB 9721      SBIW	R28,1
(0503) 
(0504) 
(0505) 
(0506) }
(0507) /******************************************************************** 
(0508) 函数 名：LCD_print1 
(0509) 入口参数： 显示1 ascii
(0510) 出口参数：无 
(0511) 函数作用：接着上文地址显示，不重设地址 
(0512) 说        明： 
(0513) ********************************************************************/ 
(0514) void LCD_print1(char ch)
(0515) {  
(0516) W_1byte(0,1,ch); 
    03CCC 82A8      ST	Y,R10
    03CCD E021      LDI	R18,1
    03CCE 2700      CLR	R16
    03CCF DDC4      RCALL	_W_1byte
    03CD0 9621      ADIW	R28,1
    03CD1 90A9      LD	R10,Y+
    03CD2 9508      RET
_lp:
  p                    --> R10
    03CD3 92AA      ST	-Y,R10
    03CD4 92BA      ST	-Y,R11
    03CD5 0158      MOVW	R10,R16
    03CD6 9722      SBIW	R28,2
(0517) }
(0518) //////////////////////////////////////////////////////////////
(0519) 
(0520) 
(0521) 
(0522)  void lp(unsigned char *p)
(0523)  {
(0524)  static unsigned char *p1=" ",*p2=" ",*p3=" ",*p4=" ";
(0525)  p4=p3;
    03CD7 9020 04FC LDS	R2,lcd.c:p3
    03CD9 9030 04FD LDS	R3,lcd.c:p3+1
    03CDB 9230 04FF STS	lcd.c:p4+1,R3
    03CDD 9220 04FE STS	lcd.c:p4,R2
(0526)  p3=p2;
    03CDF 9020 04FA LDS	R2,lcd.c:p2
    03CE1 9030 04FB LDS	R3,lcd.c:p2+1
    03CE3 9230 04FD STS	lcd.c:p3+1,R3
    03CE5 9220 04FC STS	lcd.c:p3,R2
(0527)  p2=p1;
    03CE7 9020 04F8 LDS	R2,lcd.c:p1
    03CE9 9030 04F9 LDS	R3,lcd.c:p1+1
    03CEB 9230 04FB STS	lcd.c:p2+1,R3
    03CED 9220 04FA STS	lcd.c:p2,R2
(0528)  p1=p;
    03CEF 92B0 04F9 STS	lcd.c:p1+1,R11
    03CF1 92A0 04F8 STS	lcd.c:p1,R10
(0529)   LCD_const_disp(1,1,"                ");
    03CF3 E080      LDI	R24,0
    03CF4 E095      LDI	R25,5
    03CF5 8399      STD	Y+1,R25
    03CF6 8388      ST	Y,R24
    03CF7 E021      LDI	R18,1
    03CF8 E001      LDI	R16,1
    03CF9 DCD4      RCALL	_LCD_const_disp
(0530)   LCD_const_disp(2,1,"                ");
    03CFA E080      LDI	R24,0
    03CFB E095      LDI	R25,5
    03CFC 8399      STD	Y+1,R25
    03CFD 8388      ST	Y,R24
    03CFE E021      LDI	R18,1
    03CFF E002      LDI	R16,2
    03D00 DCCD      RCALL	_LCD_const_disp
(0531)   LCD_const_disp(3,1,"                ");
    03D01 E080      LDI	R24,0
    03D02 E095      LDI	R25,5
    03D03 8399      STD	Y+1,R25
    03D04 8388      ST	Y,R24
    03D05 E021      LDI	R18,1
    03D06 E003      LDI	R16,3
    03D07 DCC6      RCALL	_LCD_const_disp
(0532)   LCD_const_disp(4,1,"                ");
    03D08 E080      LDI	R24,0
    03D09 E095      LDI	R25,5
    03D0A 8399      STD	Y+1,R25
    03D0B 8388      ST	Y,R24
    03D0C E021      LDI	R18,1
    03D0D E004      LDI	R16,4
    03D0E DCBF      RCALL	_LCD_const_disp
(0533)   LCD_var_disp(1,1,p4);
    03D0F 9020 04FE LDS	R2,lcd.c:p4
    03D11 9030 04FF LDS	R3,lcd.c:p4+1
    03D13 8239      STD	Y+1,R3
    03D14 8228      ST	Y,R2
    03D15 E021      LDI	R18,1
    03D16 E001      LDI	R16,1
    03D17 DCE3      RCALL	_LCD_var_disp
(0534)   LCD_var_disp(2,1,p3);
    03D18 9020 04FC LDS	R2,lcd.c:p3
    03D1A 9030 04FD LDS	R3,lcd.c:p3+1
    03D1C 8239      STD	Y+1,R3
    03D1D 8228      ST	Y,R2
    03D1E E021      LDI	R18,1
    03D1F E002      LDI	R16,2
    03D20 DCDA      RCALL	_LCD_var_disp
(0535)   LCD_var_disp(3,1,p2);
    03D21 9020 04FA LDS	R2,lcd.c:p2
    03D23 9030 04FB LDS	R3,lcd.c:p2+1
    03D25 8239      STD	Y+1,R3
    03D26 8228      ST	Y,R2
    03D27 E021      LDI	R18,1
    03D28 E003      LDI	R16,3
    03D29 DCD1      RCALL	_LCD_var_disp
(0536)   LCD_var_disp(4,1,p1);
    03D2A 9020 04F8 LDS	R2,lcd.c:p1
    03D2C 9030 04F9 LDS	R3,lcd.c:p1+1
    03D2E 8239      STD	Y+1,R3
    03D2F 8228      ST	Y,R2
    03D30 E021      LDI	R18,1
    03D31 E004      LDI	R16,4
    03D32 DCC8      RCALL	_LCD_var_disp
(0537)   delayms(300);
    03D33 E20C      LDI	R16,0x2C
    03D34 E011      LDI	R17,1
    03D35 940E 2413 CALL	_delayms
    03D37 9622      ADIW	R28,2
    03D38 90B9      LD	R11,Y+
    03D39 90A9      LD	R10,Y+
    03D3A 9508      RET
FILE: D:\LQD\software\master\software_src\relay.c
(0001) #include "config.h"
(0002) /*继电器初始化
(0003) *设置端口
(0004) *初始化关闭
(0005) */
(0006) void relay_init(void){
(0007) 	
(0008) 		RELAY_DDR_SET() ;
_relay_init:
    03D3B 9AA5      SBI	0x14,5
(0009) 		RELAY_OFF();
    03D3C 98AD      CBI	0x15,5
    03D3D 9508      RET
(0010) 		//state.Relay = 0;
(0011) 	}	
(0012) 
(0013) /*继电器控制
(0014) *传入 ： 温度
(0015) *传出 ： 当前继电器状态
(0016) *
(0017) */
(0018) unsigned char  relay(int temp)
(0019) {
(0020) 	if(temp<HEAT_THRESHOLD)
_relay:
  temp                 --> R16
    03D3E 3005      CPI	R16,5
    03D3F E0E0      LDI	R30,0
    03D40 071E      CPC	R17,R30
    03D41 F41C      BGE	0x3D45
(0021) 	{
(0022) 	 		RELAY_DDR_SET();
    03D42 9AA5      SBI	0x14,5
(0023) 			RELAY_ON();
    03D43 9AAD      SBI	0x15,5
(0024) 			//state.Relay = 1 ;
(0025) 	}
    03D44 C002      RJMP	0x3D47
(0026) 	else
(0027) 	{
(0028) 	 	RELAY_DDR_SET();
    03D45 9AA5      SBI	0x14,5
(0029) 		RELAY_OFF();
    03D46 98AD      CBI	0x15,5
(0030) 		//state.Relay = 0 ;
(0031) 	}		
(0032) 	//return state.Relay;
(0033) 	return 0;
    03D47 2700      CLR	R16
    03D48 9508      RET
_beep:
  i                    --> R10
  short_beep           --> R12
  long_beep            --> R14
    03D49 940E 416F CALL	push_xgset00FC
    03D4B 2EC2      MOV	R12,R18
    03D4C 2EE0      MOV	R14,R16
FILE: D:\LQD\software\master\software_src\beep.c
(0001) #include "config.h"
(0002) 
(0003) #define BEEP_PORT	PORTC
(0004) #define BEEP_PIN	6
(0005) #define BEEP_OFF() BEEP_PORT|=(1<<BEEP_PIN)
(0006) #define BEEP_ON()  BEEP_PORT&=~(1<<BEEP_PIN)
(0007) //楦ｅ
(0008) void beep(unsigned char long_beep,unsigned char short_beep)
(0009) { 
(0010) unsigned char i;
(0011) DDRB|=(1<<0);
    03D4D 9AB8      SBI	0x17,0
(0012) for(i=0;i<long_beep;i++)
    03D4E 24AA      CLR	R10
    03D4F C00B      RJMP	0x3D5B
(0013) {
(0014) BEEP_ON();  delayms(200);
    03D50 98AE      CBI	0x15,6
    03D51 EC08      LDI	R16,0xC8
    03D52 E010      LDI	R17,0
    03D53 940E 2413 CALL	_delayms
(0015) BEEP_OFF(); delayms(50);
    03D55 9AAE      SBI	0x15,6
    03D56 E302      LDI	R16,0x32
    03D57 E010      LDI	R17,0
    03D58 940E 2413 CALL	_delayms
    03D5A 94A3      INC	R10
    03D5B 14AE      CP	R10,R14
    03D5C F398      BCS	0x3D50
(0016) }
(0017) delayms(100);
    03D5D E604      LDI	R16,0x64
    03D5E E010      LDI	R17,0
    03D5F 940E 2413 CALL	_delayms
(0018) for(i=0;i<short_beep;i++)
    03D61 24AA      CLR	R10
    03D62 C00B      RJMP	0x3D6E
(0019) {
(0020) BEEP_ON();  delayms(80);
    03D63 98AE      CBI	0x15,6
    03D64 E500      LDI	R16,0x50
    03D65 E010      LDI	R17,0
    03D66 940E 2413 CALL	_delayms
(0021) BEEP_OFF(); delayms(50);
    03D68 9AAE      SBI	0x15,6
    03D69 E302      LDI	R16,0x32
    03D6A E010      LDI	R17,0
    03D6B 940E 2413 CALL	_delayms
    03D6D 94A3      INC	R10
    03D6E 14AC      CP	R10,R12
    03D6F F398      BCS	0x3D63
    03D70 940C 4150 JMP	pop_xgset00FC
_Delay_nus:
  i                    --> R20
  n                    --> R16
    03D72 934A      ST	-Y,R20
    03D73 935A      ST	-Y,R21
FILE: D:\LQD\software\master\software_src\DS18B20_driver.c
(0001) //------------------------------------------------------------------------------
(0002) // 文件名：DS18B20_driver.c
(0003) // 说明：  DS18B20驱动头文件
(0004) // 功能：  实现1-wire器件的读写
(0005) // 使用方法：   void Delay_nus(unsigned int n);             //延时n微秒函数
(0006) //              unsigned char reset_18B20(void);            //18B20复位
(0007) //              void write_bit_18B20(char bitval);          //写一位到18B20
(0008) //              unsigned char read_bit_18B20(void);         //读一位从18B20
(0009) //              void write_byte_18B20(unsigned char data);  //写一字节到18B20
(0010) //              unsigned char read_18B20(void);             //读一字节到18B20
(0011) //
(0012) // 运行平台：   AVR 8bit (M16已验证)
(0013) // 依存关系：   DS18B20_driver.h    DS18B20基本驱动头文件（函数声明）
(0014) // 移植人：     
(0015) // 最后修改：   
(0016) //------------------------------------------------------------------------------
(0017) 
(0018) #include "config.h"
(0019) #define DS18B20_PORT PORTG
(0020) #define DS18B20_PIN  PING
(0021) #define DS18B20_DDR  DDRG
(0022) #define CL_DQ   DS18B20_PORT&=~(1<<T_NUM)					   
(0023) #define SET_DQ  DS18B20_PORT|=(1<<T_NUM)			   
(0024) #define SET_OUT DS18B20_DDR|=(1<<T_NUM)				   
(0025) #define SET_IN  DS18B20_DDR&=~(1<<T_NUM)			   
(0026) #define IN_DQ   DS18B20_PIN&(1<<T_NUM)				  
(0027) unsigned char T_NUM=0;
(0028) 
(0029) 
(0030) //------------------------------------------------------------------------------
(0031) // 延时N微秒程序 供控制读写DS18B20时序使用
(0032) //------------------------------------------------------------------------------
(0033) void Delay_nus(unsigned int n)   
(0034) {  unsigned int i;
(0035) 	  for (i=0;i<n;i++) 
    03D74 2744      CLR	R20
    03D75 2755      CLR	R21
    03D76 C005      RJMP	0x3D7C
(0036) 	  		{NOP();
    03D77 0000      NOP
(0037) 						NOP();
    03D78 0000      NOP
(0038) 						NOP();				        //20--300//比较接近
    03D79 0000      NOP
    03D7A 5F4F      SUBI	R20,0xFF
    03D7B 4F5F      SBCI	R21,0xFF
    03D7C 1740      CP	R20,R16
    03D7D 0751      CPC	R21,R17
    03D7E F3C0      BCS	0x3D77
    03D7F 9159      LD	R21,Y+
    03D80 9149      LD	R20,Y+
    03D81 9508      RET
_reset_18B20:
  bus_flag             --> R10
    03D82 92AA      ST	-Y,R10
(0039) 					}
(0040) }
(0041) 
(0042) 
(0043) //------------------------------------------------------------------------------
(0044) // 1-wire总线复位
(0045) //------------------------------------------------------------------------------
(0046) unsigned char reset_18B20(void)
(0047) {
(0048) 	char bus_flag;
(0049) 	CLI();
    03D83 94F8      BCLR	7
(0050) 	SET_DQ;
    03D84 9110 0513 LDS	R17,T_NUM
    03D86 E001      LDI	R16,1
    03D87 940E 41F9 CALL	lsl8
    03D89 9020 0065 LDS	R2,0x65
    03D8B 2A20      OR	R2,R16
    03D8C 9220 0065 STS	0x65,R2
(0051) 	SET_OUT;
    03D8E 9110 0513 LDS	R17,T_NUM
    03D90 E001      LDI	R16,1
    03D91 940E 41F9 CALL	lsl8
    03D93 9020 0064 LDS	R2,0x64
    03D95 2A20      OR	R2,R16
    03D96 9220 0064 STS	0x64,R2
(0052)  	
(0053)   	Delay_nus(1);
    03D98 E001      LDI	R16,1
    03D99 E010      LDI	R17,0
    03D9A DFD7      RCALL	_Delay_nus
(0054)   	CL_DQ;
    03D9B 9110 0513 LDS	R17,T_NUM
    03D9D E001      LDI	R16,1
    03D9E 940E 41F9 CALL	lsl8
    03DA0 2E20      MOV	R2,R16
    03DA1 9420      COM	R2
    03DA2 9030 0065 LDS	R3,0x65
    03DA4 2032      AND	R3,R2
    03DA5 9230 0065 STS	0x65,R3
(0055)   	Delay_nus(550);		//拉低至少480us时间
    03DA7 E206      LDI	R16,0x26
    03DA8 E012      LDI	R17,2
    03DA9 DFC8      RCALL	_Delay_nus
(0056)   	SET_DQ;				//释放
    03DAA 9110 0513 LDS	R17,T_NUM
    03DAC E001      LDI	R16,1
    03DAD 940E 41F9 CALL	lsl8
    03DAF 9020 0065 LDS	R2,0x65
    03DB1 2A20      OR	R2,R16
    03DB2 9220 0065 STS	0x65,R2
(0057) 					NOP();
    03DB4 0000      NOP
(0058) 					NOP();
    03DB5 0000      NOP
(0059)   	SET_IN;				//输入
    03DB6 9110 0513 LDS	R17,T_NUM
    03DB8 E001      LDI	R16,1
    03DB9 940E 41F9 CALL	lsl8
    03DBB 2E20      MOV	R2,R16
    03DBC 9420      COM	R2
    03DBD 9030 0064 LDS	R3,0x64
    03DBF 2032      AND	R3,R2
    03DC0 9230 0064 STS	0x64,R3
(0060)   	Delay_nus(60);
    03DC2 E30C      LDI	R16,0x3C
    03DC3 E010      LDI	R17,0
    03DC4 DFAD      RCALL	_Delay_nus
(0061)   	
(0062) 						//等待回复
(0063)   	bus_flag = IN_DQ;
    03DC5 9110 0513 LDS	R17,T_NUM
    03DC7 E001      LDI	R16,1
    03DC8 940E 41F9 CALL	lsl8
    03DCA 90A0 0063 LDS	R10,0x63
    03DCC 22A0      AND	R10,R16
(0064)   	
(0065)   	Delay_nus(240);		//回复的低电平在60到240US
    03DCD EF00      LDI	R16,0xF0
    03DCE E010      LDI	R17,0
    03DCF DFA2      RCALL	_Delay_nus
(0066)   	SET_OUT;
    03DD0 9110 0513 LDS	R17,T_NUM
    03DD2 E001      LDI	R16,1
    03DD3 940E 41F9 CALL	lsl8
    03DD5 9020 0064 LDS	R2,0x64
    03DD7 2A20      OR	R2,R16
    03DD8 9220 0064 STS	0x64,R2
(0067) 					NOP();
    03DDA 0000      NOP
(0068) 					NOP();
    03DDB 0000      NOP
(0069)   	SET_DQ;				//回到初始DQ=1；
    03DDC 9110 0513 LDS	R17,T_NUM
    03DDE E001      LDI	R16,1
    03DDF 940E 41F9 CALL	lsl8
    03DE1 9020 0065 LDS	R2,0x65
    03DE3 2A20      OR	R2,R16
    03DE4 9220 0065 STS	0x65,R2
(0070) 
(0071)   	SEI();
    03DE6 9478      BSET	7
(0072) 	if(bus_flag){
    03DE7 20AA      TST	R10
    03DE8 F011      BEQ	0x3DEB
(0073) 		return FALSE;
    03DE9 2700      CLR	R16
    03DEA C001      RJMP	0x3DEC
(0074) 	}else{
(0075) 		return TRUE;
    03DEB E001      LDI	R16,1
    03DEC 90A9      LD	R10,Y+
    03DED 9508      RET
_write_bit_18B20:
  bitval               --> R10
    03DEE 92AA      ST	-Y,R10
    03DEF 2EA0      MOV	R10,R16
(0076) 	}
(0077) 
(0078) }
(0079) 
(0080) //------------------------------------------------------------------------------
(0081) // 写一位到总线
(0082) //------------------------------------------------------------------------------
(0083) void write_bit_18B20(char bitval)
(0084) {
(0085)     SET_OUT;
    03DF0 9110 0513 LDS	R17,T_NUM
    03DF2 E001      LDI	R16,1
    03DF3 940E 41F9 CALL	lsl8
    03DF5 9020 0064 LDS	R2,0x64
    03DF7 2A20      OR	R2,R16
    03DF8 9220 0064 STS	0x64,R2
(0086) 					NOP();
    03DFA 0000      NOP
(0087) 					NOP();
    03DFB 0000      NOP
(0088) 			 CL_DQ;
    03DFC 9110 0513 LDS	R17,T_NUM
    03DFE E001      LDI	R16,1
    03DFF 940E 41F9 CALL	lsl8
    03E01 2E20      MOV	R2,R16
    03E02 9420      COM	R2
    03E03 9030 0065 LDS	R3,0x65
    03E05 2032      AND	R3,R2
    03E06 9230 0065 STS	0x65,R3
(0089) 	   Delay_nus(1);
    03E08 E001      LDI	R16,1
    03E09 E010      LDI	R17,0
    03E0A DF67      RCALL	_Delay_nus
(0090) 	   if(bitval){    //写数据，从低位开始
    03E0B 20AA      TST	R10
    03E0C F059      BEQ	0x3E18
(0091) 		     SET_DQ;
    03E0D 9110 0513 LDS	R17,T_NUM
    03E0F E001      LDI	R16,1
    03E10 940E 41F9 CALL	lsl8
    03E12 9020 0065 LDS	R2,0x65
    03E14 2A20      OR	R2,R16
    03E15 9220 0065 STS	0x65,R2
(0092) 	  }else{
    03E17 C00C      RJMP	0x3E24
(0093) 		     CL_DQ;
    03E18 9110 0513 LDS	R17,T_NUM
    03E1A E001      LDI	R16,1
    03E1B 940E 41F9 CALL	lsl8
    03E1D 2E20      MOV	R2,R16
    03E1E 9420      COM	R2
    03E1F 9030 0065 LDS	R3,0x65
    03E21 2032      AND	R3,R2
    03E22 9230 0065 STS	0x65,R3
(0094) 	  }
(0095) 	Delay_nus(40);		//15~60us
    03E24 E208      LDI	R16,0x28
    03E25 E010      LDI	R17,0
    03E26 DF4B      RCALL	_Delay_nus
(0096) 	SET_DQ;
    03E27 9110 0513 LDS	R17,T_NUM
    03E29 E001      LDI	R16,1
    03E2A 940E 41F9 CALL	lsl8
    03E2C 9020 0065 LDS	R2,0x65
    03E2E 2A20      OR	R2,R16
    03E2F 9220 0065 STS	0x65,R2
(0097) 	Delay_nus(10);
    03E31 E00A      LDI	R16,0xA
    03E32 E010      LDI	R17,0
    03E33 DF3E      RCALL	_Delay_nus
    03E34 90A9      LD	R10,Y+
    03E35 9508      RET
_read_bit_18B20:
  k                    --> R10
    03E36 92AA      ST	-Y,R10
(0098) }
(0099) 
(0100) //------------------------------------------------------------------------------
(0101) // 读一位从总线
(0102) //------------------------------------------------------------------------------
(0103) unsigned char read_bit_18B20(void)
(0104) {
(0105) 	unsigned char k;
(0106) 	SET_OUT;
    03E37 9110 0513 LDS	R17,T_NUM
    03E39 E001      LDI	R16,1
    03E3A 940E 41F9 CALL	lsl8
    03E3C 9020 0064 LDS	R2,0x64
    03E3E 2A20      OR	R2,R16
    03E3F 9220 0064 STS	0x64,R2
(0107) 	CL_DQ;			//读时间片开始，拉低总线至少1us
    03E41 9110 0513 LDS	R17,T_NUM
    03E43 E001      LDI	R16,1
    03E44 940E 41F9 CALL	lsl8
    03E46 2E20      MOV	R2,R16
    03E47 9420      COM	R2
    03E48 9030 0065 LDS	R3,0x65
    03E4A 2032      AND	R3,R2
    03E4B 9230 0065 STS	0x65,R3
(0108) 	Delay_nus(1);
    03E4D E001      LDI	R16,1
    03E4E E010      LDI	R17,0
    03E4F DF22      RCALL	_Delay_nus
(0109) 	
(0110) 					//SET_DQ;	
(0111) 	SET_IN;
    03E50 9110 0513 LDS	R17,T_NUM
    03E52 E001      LDI	R16,1
    03E53 940E 41F9 CALL	lsl8
    03E55 2E20      MOV	R2,R16
    03E56 9420      COM	R2
    03E57 9030 0064 LDS	R3,0x64
    03E59 2032      AND	R3,R2
    03E5A 9230 0064 STS	0x64,R3
(0112) 	Delay_nus(4);
    03E5C E004      LDI	R16,4
    03E5D E010      LDI	R17,0
    03E5E DF13      RCALL	_Delay_nus
(0113) 	k=IN_DQ;    	//读数据,从低位开始
    03E5F 9110 0513 LDS	R17,T_NUM
    03E61 E001      LDI	R16,1
    03E62 940E 41F9 CALL	lsl8
    03E64 90A0 0063 LDS	R10,0x63
    03E66 22A0      AND	R10,R16
(0114) 	Delay_nus(10);
    03E67 E00A      LDI	R16,0xA
    03E68 E010      LDI	R17,0
    03E69 DF08      RCALL	_Delay_nus
(0115) 	SET_DQ;	
    03E6A 9110 0513 LDS	R17,T_NUM
    03E6C E001      LDI	R16,1
    03E6D 940E 41F9 CALL	lsl8
    03E6F 9020 0065 LDS	R2,0x65
    03E71 2A20      OR	R2,R16
    03E72 9220 0065 STS	0x65,R2
(0116) 				NOP();
    03E74 0000      NOP
(0117) 				NOP();
    03E75 0000      NOP
(0118) 	SET_OUT;
    03E76 9110 0513 LDS	R17,T_NUM
    03E78 E001      LDI	R16,1
    03E79 940E 41F9 CALL	lsl8
    03E7B 9020 0064 LDS	R2,0x64
    03E7D 2A20      OR	R2,R16
    03E7E 9220 0064 STS	0x64,R2
(0119) 	    NOP();
    03E80 0000      NOP
(0120) 					NOP();
    03E81 0000      NOP
(0121) 	if(k){
    03E82 20AA      TST	R10
    03E83 F011      BEQ	0x3E86
(0122) 	    return 1;
    03E84 E001      LDI	R16,1
    03E85 C001      RJMP	0x3E87
(0123) 	}else{
(0124) 	    return 0;
    03E86 2700      CLR	R16
    03E87 90A9      LD	R10,Y+
    03E88 9508      RET
_write_byte_18B20:
  i                    --> R20
  data                 --> R10
    03E89 92AA      ST	-Y,R10
    03E8A 934A      ST	-Y,R20
    03E8B 2EA0      MOV	R10,R16
(0125) 	}
(0126) 	
(0127) }
(0128) 
(0129) //------------------------------------------------------------------------------
(0130) // 写一个字节到总线
(0131) //------------------------------------------------------------------------------
(0132) void write_byte_18B20(unsigned char data)
(0133) {
(0134) 	unsigned char i;
(0135)    CLI();
    03E8C 94F8      BCLR	7
(0136)     for(i=0;i<8;i++)
    03E8D 2744      CLR	R20
    03E8E C009      RJMP	0x3E98
(0137)     {
(0138)         write_bit_18B20(data&(1<<i));
    03E8F E001      LDI	R16,1
    03E90 2F14      MOV	R17,R20
    03E91 940E 41F9 CALL	lsl8
    03E93 2E20      MOV	R2,R16
    03E94 2D0A      MOV	R16,R10
    03E95 2102      AND	R16,R2
    03E96 DF57      RCALL	_write_bit_18B20
    03E97 9543      INC	R20
    03E98 3048      CPI	R20,0x8
    03E99 F3A8      BCS	0x3E8F
(0139)         
(0140)     }
(0141)     SET_DQ;
    03E9A 9110 0513 LDS	R17,T_NUM
    03E9C E001      LDI	R16,1
    03E9D 940E 41F9 CALL	lsl8
    03E9F 9020 0065 LDS	R2,0x65
    03EA1 2A20      OR	R2,R16
    03EA2 9220 0065 STS	0x65,R2
(0142) 				  NOP();
    03EA4 0000      NOP
(0143) 					 NOP();
    03EA5 0000      NOP
(0144)     SEI();
    03EA6 9478      BSET	7
    03EA7 9149      LD	R20,Y+
    03EA8 90A9      LD	R10,Y+
    03EA9 9508      RET
_read_byte_18B20:
  temp                 --> R10
  n                    --> R20
    03EAA 92AA      ST	-Y,R10
    03EAB 934A      ST	-Y,R20
(0145)     
(0146)     //return;
(0147) }
(0148) 
(0149) //------------------------------------------------------------------------------
(0150) // 读一个字节
(0151) //------------------------------------------------------------------------------
(0152) unsigned char read_byte_18B20(void)
(0153) {
(0154) 	unsigned char temp,n;
(0155)     CLI();
    03EAC 94F8      BCLR	7
(0156)   	temp=0;
    03EAD 24AA      CLR	R10
(0157)     for(n=0;n<8;n++)
    03EAE 2744      CLR	R20
    03EAF C014      RJMP	0x3EC4
(0158)     {
(0159)       	if(read_bit_18B20()){
    03EB0 DF85      RCALL	_read_bit_18B20
    03EB1 2300      TST	R16
    03EB2 F031      BEQ	0x3EB9
(0160)       		temp|=(1<<n);
    03EB3 E001      LDI	R16,1
    03EB4 2F14      MOV	R17,R20
    03EB5 940E 41F9 CALL	lsl8
    03EB7 2AA0      OR	R10,R16
(0161)       	}else{
    03EB8 C007      RJMP	0x3EC0
(0162)       		temp&=~(1<<n);
    03EB9 E001      LDI	R16,1
    03EBA 2F14      MOV	R17,R20
    03EBB 940E 41F9 CALL	lsl8
    03EBD 2E20      MOV	R2,R16
    03EBE 9420      COM	R2
    03EBF 20A2      AND	R10,R2
(0163)       	}
(0164)       	Delay_nus(70); //60~120us
    03EC0 E406      LDI	R16,0x46
    03EC1 E010      LDI	R17,0
    03EC2 DEAF      RCALL	_Delay_nus
    03EC3 9543      INC	R20
    03EC4 3048      CPI	R20,0x8
    03EC5 F350      BCS	0x3EB0
(0165)       	
(0166)    }
(0167)    SEI();
    03EC6 9478      BSET	7
(0168) 
(0169)    return temp;
    03EC7 2D0A      MOV	R16,R10
    03EC8 9149      LD	R20,Y+
    03EC9 90A9      LD	R10,Y+
    03ECA 9508      RET
(0170) }
(0171) 
(0172) 
(0173) 
(0174) //------------------------------------------------------------------------------
(0175) // 应用函数部分！ 供外部调用
(0176) //------------------------------------------------------------------------------
(0177) //------------------------------------------------------------------------------
(0178) // 单器件/多器件：开始转换
(0179) //------------------------------------------------------------------------------
(0180) void convert_T(void)
(0181) {
(0182) 					if(reset_18B20()){
_convert_T:
    03ECB DEB6      RCALL	_reset_18B20
    03ECC 2300      TST	R16
    03ECD F021      BEQ	0x3ED2
(0183) 					write_byte_18B20(0xcc);
    03ECE EC0C      LDI	R16,0xCC
    03ECF DFB9      RCALL	_write_byte_18B20
(0184) 					write_byte_18B20(0x44);
    03ED0 E404      LDI	R16,0x44
    03ED1 DFB7      RCALL	_write_byte_18B20
(0185) 					}
    03ED2 9508      RET
_read_T:
  sign                 --> Y,+1
  tmp                  --> Y,+0
  value                --> R10
    03ED3 940E 4171 CALL	push_xgset003C
    03ED5 9724      SBIW	R28,4
(0186) }
(0187) 
(0188) //------------------------------------------------------------------------------
(0189) // 单器件：读温度，返回INIT8U型温度数据（原始数据）
(0190) //------------------------------------------------------------------------------
(0191) float read_T(void)
(0192) {
(0193)     unsigned int value=0;
    03ED6 24AA      CLR	R10
    03ED7 24BB      CLR	R11
(0194) 	unsigned char sign;
(0195) 	
(0196) 	float tmp;
(0197)     
(0198)     if(reset_18B20()){
    03ED8 DEA9      RCALL	_reset_18B20
    03ED9 2300      TST	R16
    03EDA F021      BEQ	0x3EDF
(0199)     	write_byte_18B20(0xcc);
    03EDB EC0C      LDI	R16,0xCC
    03EDC DFAC      RCALL	_write_byte_18B20
(0200)     	write_byte_18B20(0xbe);
    03EDD EB0E      LDI	R16,0xBE
    03EDE DFAA      RCALL	_write_byte_18B20
(0201)     }
(0202)     
(0203)     value = (unsigned int)read_byte_18B20();
    03EDF DFCA      RCALL	_read_byte_18B20
    03EE0 2EA0      MOV	R10,R16
    03EE1 24BB      CLR	R11
(0204)     value += ((unsigned int)(read_byte_18B20()))<<8;
    03EE2 DFC7      RCALL	_read_byte_18B20
    03EE3 2EC0      MOV	R12,R16
    03EE4 2C2C      MOV	R2,R12
    03EE5 2433      CLR	R3
    03EE6 2C32      MOV	R3,R2
    03EE7 2422      CLR	R2
    03EE8 0CA2      ADD	R10,R2
    03EE9 1CB3      ADC	R11,R3
(0205) 	/*   if((value&0x8000)==0x8000) //负温度
(0206) 					{
(0207) 					 sign=0;
(0208) 					 data=(~data)+1;       //补码形式，取反加一
(0209) 					}
(0210) 		elae 
(0211) 					{
(0212) 					 sign=1;
(0213) 					}
(0214) 		 xiaoshu1=(unsigned char) ((data&0x000f)*10/16);
(0215) 		 zhengshu=(unsigned char) (data>>4); 
(0216) 		*/
(0217) 	tmp= ((float)value)*0.0625;
    03EEA EC08      LDI	R16,0xC8
    03EEB E010      LDI	R17,0
    03EEC 940E 40F3 CALL	elpm32
    03EEE 0118      MOVW	R2,R16
    03EEF 0129      MOVW	R4,R18
    03EF0 0185      MOVW	R16,R10
    03EF1 940E 42C5 CALL	uint2fp
    03EF3 933A      ST	-Y,R19
    03EF4 932A      ST	-Y,R18
    03EF5 931A      ST	-Y,R17
    03EF6 930A      ST	-Y,R16
    03EF7 0181      MOVW	R16,R2
    03EF8 0192      MOVW	R18,R4
    03EF9 940E 446C CALL	fpmule2
    03EFB 8308      ST	Y,R16
    03EFC 8319      STD	Y+1,R17
    03EFD 832A      STD	Y+2,R18
    03EFE 833B      STD	Y+3,R19
(0218) 	
(0219)     return( tmp);
    03EFF 8108      LD	R16,Y
    03F00 8119      LDD	R17,Y+1
    03F01 812A      LDD	R18,Y+2
    03F02 813B      LDD	R19,Y+3
    03F03 9624      ADIW	R28,4
    03F04 940C 414B JMP	pop_xgset003C
_read_T_NUM:
  ttemp                --> Y,+0
  NUM                  --> R10
    03F06 92AA      ST	-Y,R10
    03F07 2EA0      MOV	R10,R16
    03F08 9724      SBIW	R28,4
(0220) }
(0221) 
(0222) float read_T_NUM(unsigned char NUM){
(0223) float ttemp;
(0224) if ( NUM >1) return 123.45;
    03F09 E081      LDI	R24,1
    03F0A 158A      CP	R24,R10
    03F0B F428      BCC	0x3F11
    03F0C EC04      LDI	R16,0xC4
    03F0D E010      LDI	R17,0
    03F0E 940E 40F3 CALL	elpm32
    03F10 C010      RJMP	0x3F21
(0225) T_NUM=NUM;//设置访问器件
    03F11 92A0 0513 STS	T_NUM,R10
(0226) convert_T();//温度转换
    03F13 DFB7      RCALL	_convert_T
(0227) delayms(800);
    03F14 E200      LDI	R16,0x20
    03F15 E013      LDI	R17,3
    03F16 940E 2413 CALL	_delayms
(0228) ttemp=read_T();
    03F18 DFBA      RCALL	_read_T
    03F19 8308      ST	Y,R16
    03F1A 8319      STD	Y+1,R17
    03F1B 832A      STD	Y+2,R18
    03F1C 833B      STD	Y+3,R19
(0229) return ttemp;
    03F1D 8108      LD	R16,Y
    03F1E 8119      LDD	R17,Y+1
    03F1F 812A      LDD	R18,Y+2
    03F20 813B      LDD	R19,Y+3
    03F21 9624      ADIW	R28,4
    03F22 90A9      LD	R10,Y+
    03F23 9508      RET
FILE: D:\LQD\software\master\software_src\ds1302.c
(0001) #include "config.h"
(0002) 
(0003) #define TPORT PORTB
(0004) #define TDDR DDRB
(0005) #define TPIN PINB
(0006) #define PIN_RST	 4
(0007) #define PIN_IO	 5
(0008) #define PIN_SCK	 6
(0009) /******************复位脚*********************/
(0010) #define RST_CLR	TPORT &= ~(1 << PIN_RST)   /*电平置低*/
(0011) #define RST_SET	TPORT |= (1 << PIN_RST)    /*电平置高*/
(0012) #define RST_IN	TDDR &= ~(1 << PIN_RST)    /*方向输入*/
(0013) #define RST_OUT	TDDR |= (1 << PIN_RST)     /*方向输出*/
(0014) 
(0015) /*****************双向数据********************/
(0016) #define IO_CLR	TPORT &= ~(1 << PIN_IO)  /*电平置低*/
(0017) #define IO_SET	TPORT |= (1 << PIN_IO)   /*电平置高*/
(0018) #define IO_R	TPIN & (1 << PIN_IO)     /*电平读取*/
(0019) #define IO_IN	TDDR &= ~(1 << PIN_IO)   /*方向输入*/
(0020) #define IO_OUT	TDDR |= (1 << PIN_IO)    /*方向输出*/
(0021) 
(0022) /*****************时钟信号*******************/
(0023) #define SCK_CLR	TPORT &= ~(1 << PIN_SCK)  /*时钟信号*/
(0024) #define SCK_SET	TPORT |= (1 << PIN_SCK)   /*电平置高*/
(0025) #define SCK_IN	TDDR &= ~(1 << PIN_SCK)   /*方向输入*/
(0026) #define SCK_OUT	TDDR |= (1 << PIN_SCK)    /*方向输出*/
(0027) 
(0028) #define ds1302_sec_add			0x80		//秒数据地址
(0029) #define ds1302_min_add			0x82		//分数据地址
(0030) #define ds1302_hr_add			0x84		//时数据地址
(0031) #define ds1302_date_add			0x86		//日数据地址
(0032) #define ds1302_month_add		0x88		//月数据地址
(0033) #define ds1302_day_add			0x8a		//星期数据地址
(0034) #define ds1302_year_add			0x8c		//年数据地址
(0035) #define ds1302_control_add		0x8e		//控制数据地址
(0036) #define ds1302_charger_add		0x90 					 
(0037) #define ds1302_clkburst_add		0xbe
(0038) 
(0039) unsigned char time_buf[8] = {0x20,0x0c,0x0A,0x1c,0x22,0x46,0x00,0x06};
(0040) /*
(0041)  struct tm {
(0042)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0043)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0044) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0045) 	int tm_mday;  // 日 day of the month, 1 to 31
(0046) 	int tm_mon;   // 月 months since January, 0 to 11
(0047) 	int tm_year;  // 年 years since 1900
(0048) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0049) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0050)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0051)  	};	
(0052) 	*/
(0053) 
(0054) //DS1302初始化函数
(0055) void ds1302_init(void) 
(0056) {
(0057) 	RST_CLR;			/*RST脚置低*/
_ds1302_init:
    03F24 98C4      CBI	0x18,4
(0058) 	SCK_CLR;			/*SCK脚置低*/
    03F25 98C6      CBI	0x18,6
(0059) 	RST_OUT;			/*RST脚设置为输出*/
    03F26 9ABC      SBI	0x17,4
(0060) 	SCK_OUT;			/*SCK脚设置为输出*/
    03F27 9ABE      SBI	0x17,6
    03F28 9508      RET
_ds1302_write_byte:
  i                    --> R20
  d                    --> R18
  addr                 --> R16
    03F29 934A      ST	-Y,R20
(0061) }
(0062) 
(0063) //向DS1302写入一字节数据
(0064) void ds1302_write_byte(unsigned char addr, unsigned char d) {
(0065) 
(0066) 	unsigned char i;
(0067) 	RST_SET;					/*启动DS1302总线*/
    03F2A 9AC4      SBI	0x18,4
(0068) 	
(0069) 	/*写入目标地址：addr*/
(0070) 	IO_OUT;
    03F2B 9ABD      SBI	0x17,5
(0071) 	addr = addr & 0xFE;   //最低位置零，寄存器0位为0时写，为1时读
    03F2C 7F0E      ANDI	R16,0xFE
(0072) 	for (i = 0; i < 8; i ++) {
    03F2D 2744      CLR	R20
    03F2E C009      RJMP	0x3F38
(0073) 		if (addr & 0x01) {
    03F2F FF00      SBRS	R16,0
    03F30 C002      RJMP	0x3F33
(0074) 			IO_SET;
    03F31 9AC5      SBI	0x18,5
(0075) 			}
    03F32 C001      RJMP	0x3F34
(0076) 		else {
(0077) 			IO_CLR;
    03F33 98C5      CBI	0x18,5
(0078) 			}
(0079) 		SCK_SET;      //产生时钟
    03F34 9AC6      SBI	0x18,6
(0080) 		SCK_CLR;
    03F35 98C6      CBI	0x18,6
(0081) 		addr = addr >> 1;
    03F36 9506      LSR	R16
    03F37 9543      INC	R20
    03F38 3048      CPI	R20,0x8
    03F39 F3A8      BCS	0x3F2F
(0082) 		}
(0083) 	
(0084) 	/*写入数据：d*/
(0085) 	IO_OUT;
    03F3A 9ABD      SBI	0x17,5
(0086) 	for (i = 0; i < 8; i ++) {
    03F3B 2744      CLR	R20
    03F3C C009      RJMP	0x3F46
(0087) 		if (d & 0x01) {
    03F3D FF20      SBRS	R18,0
    03F3E C002      RJMP	0x3F41
(0088) 			IO_SET;
    03F3F 9AC5      SBI	0x18,5
(0089) 			}
    03F40 C001      RJMP	0x3F42
(0090) 		else {
(0091) 			IO_CLR;
    03F41 98C5      CBI	0x18,5
(0092) 			}
(0093) 		SCK_SET;    //产生时钟
    03F42 9AC6      SBI	0x18,6
(0094) 		SCK_CLR;
    03F43 98C6      CBI	0x18,6
(0095) 		d = d >> 1;
    03F44 9526      LSR	R18
    03F45 9543      INC	R20
    03F46 3048      CPI	R20,0x8
    03F47 F3A8      BCS	0x3F3D
(0096) 		}
(0097) 	RST_CLR;		//停止DS1302总线
    03F48 98C4      CBI	0x18,4
    03F49 9149      LD	R20,Y+
    03F4A 9508      RET
_ds1302_read_byte:
  temp                 --> R20
  i                    --> R22
  addr                 --> R16
    03F4B 934A      ST	-Y,R20
    03F4C 936A      ST	-Y,R22
(0098) 	
(0099) }
(0100) 
(0101) //从DS1302读出一字节数据
(0102) unsigned char ds1302_read_byte(unsigned char addr) {
(0103) 
(0104) 	unsigned char i;
(0105) 	unsigned char temp;
(0106) 	RST_SET;					/*启动DS1302总线*/
    03F4D 9AC4      SBI	0x18,4
(0107) 
(0108) 	/*写入目标地址：addr*/
(0109) 	IO_OUT;
    03F4E 9ABD      SBI	0x17,5
(0110) 	addr = addr | 0x01;    //最低位置高，寄存器0位为0时写，为1时读
    03F4F 6001      ORI	R16,1
(0111) 	for (i = 0; i < 8; i ++) {
    03F50 2766      CLR	R22
    03F51 C009      RJMP	0x3F5B
(0112) 		if (addr & 0x01) {
    03F52 FF00      SBRS	R16,0
    03F53 C002      RJMP	0x3F56
(0113) 			IO_SET;
    03F54 9AC5      SBI	0x18,5
(0114) 			}
    03F55 C001      RJMP	0x3F57
(0115) 		else {
(0116) 			IO_CLR;
    03F56 98C5      CBI	0x18,5
(0117) 			}
(0118) 		SCK_SET;
    03F57 9AC6      SBI	0x18,6
(0119) 		SCK_CLR;
    03F58 98C6      CBI	0x18,6
(0120) 		addr = addr >> 1;
    03F59 9506      LSR	R16
    03F5A 9563      INC	R22
    03F5B 3068      CPI	R22,0x8
    03F5C F3A8      BCS	0x3F52
(0121) 		}
(0122) 	
(0123) 	/*输出数据：temp*/
(0124) 	IO_IN;
    03F5D 98BD      CBI	0x17,5
(0125) 	for (i = 0; i < 8; i ++) {
    03F5E 2766      CLR	R22
    03F5F C009      RJMP	0x3F69
(0126) 		temp = temp >> 1;
    03F60 9546      LSR	R20
(0127) 		if (IO_R) {
    03F61 9BB5      SBIS	0x16,5
    03F62 C002      RJMP	0x3F65
(0128) 			temp |= 0x80;
    03F63 6840      ORI	R20,0x80
(0129) 			}
    03F64 C001      RJMP	0x3F66
(0130) 		else {
(0131) 			temp &= 0x7F;
    03F65 774F      ANDI	R20,0x7F
(0132) 			}
(0133) 		SCK_SET;
    03F66 9AC6      SBI	0x18,6
(0134) 		SCK_CLR;
    03F67 98C6      CBI	0x18,6
    03F68 9563      INC	R22
    03F69 3068      CPI	R22,0x8
    03F6A F3A8      BCS	0x3F60
(0135) 		}
(0136) 	
(0137) 	RST_CLR;					/*停止DS1302总线*/
    03F6B 98C4      CBI	0x18,4
(0138) 	return temp;
    03F6C 2F04      MOV	R16,R20
    03F6D 9169      LD	R22,Y+
    03F6E 9149      LD	R20,Y+
    03F6F 9508      RET
(0139) }
(0140) 
(0141) //向DS302写入时钟数据
(0142) void ds1302_write_time(void) {
(0143) 
(0144) 	ds1302_write_byte(ds1302_control_add,0x00);			//关闭写保护 
_ds1302_write_time:
    03F70 2722      CLR	R18
    03F71 E80E      LDI	R16,0x8E
    03F72 DFB6      RCALL	_ds1302_write_byte
(0145) 	ds1302_write_byte(ds1302_sec_add,0x80);				//暂停时钟 
    03F73 E820      LDI	R18,0x80
    03F74 E800      LDI	R16,0x80
    03F75 DFB3      RCALL	_ds1302_write_byte
(0146) 	//ds1302_write_byte(ds1302_charger_add,0xa9);	    //涓流充电 
(0147) 	ds1302_write_byte(ds1302_year_add,time_buf[1]);		//年 
    03F76 9120 0515 LDS	R18,time_buf+1
    03F78 E80C      LDI	R16,0x8C
    03F79 DFAF      RCALL	_ds1302_write_byte
(0148) 	ds1302_write_byte(ds1302_month_add,time_buf[2]);	//月 
    03F7A 9120 0516 LDS	R18,time_buf+2
    03F7C E808      LDI	R16,0x88
    03F7D DFAB      RCALL	_ds1302_write_byte
(0149) 	ds1302_write_byte(ds1302_date_add,time_buf[3]);		//日 
    03F7E 9120 0517 LDS	R18,time_buf+3
    03F80 E806      LDI	R16,0x86
    03F81 DFA7      RCALL	_ds1302_write_byte
(0150) 	ds1302_write_byte(ds1302_hr_add,time_buf[4]);		//时 
    03F82 9120 0518 LDS	R18,time_buf+4
    03F84 E804      LDI	R16,0x84
    03F85 DFA3      RCALL	_ds1302_write_byte
(0151) 	ds1302_write_byte(ds1302_min_add,time_buf[5]);		//分
    03F86 9120 0519 LDS	R18,time_buf+5
    03F88 E802      LDI	R16,0x82
    03F89 DF9F      RCALL	_ds1302_write_byte
(0152) 	ds1302_write_byte(ds1302_sec_add,time_buf[6]);		//秒
    03F8A 9120 051A LDS	R18,time_buf+6
    03F8C E800      LDI	R16,0x80
    03F8D DF9B      RCALL	_ds1302_write_byte
(0153) 	ds1302_write_byte(ds1302_day_add,time_buf[7]);		//周 
    03F8E 9120 051B LDS	R18,time_buf+7
    03F90 E80A      LDI	R16,0x8A
    03F91 DF97      RCALL	_ds1302_write_byte
(0154) 	ds1302_write_byte(ds1302_control_add,0x80);			//打开写保护 
    03F92 E820      LDI	R18,0x80
    03F93 E80E      LDI	R16,0x8E
    03F94 CF94      RJMP	_ds1302_write_byte
_ds1302_read_time:
    03F95 92AA      ST	-Y,R10
    03F96 934A      ST	-Y,R20
(0155) }
(0156) 
(0157) //从DS302读出时钟数据
(0158) void ds1302_read_time(void)  { 
(0159) 	time_buf[1]=ds1302_read_byte(ds1302_year_add);		//年 
    03F97 E80C      LDI	R16,0x8C
    03F98 DFB2      RCALL	_ds1302_read_byte
    03F99 9300 0515 STS	time_buf+1,R16
(0160) 	time_buf[2]=ds1302_read_byte(ds1302_month_add);		//月 
    03F9B E808      LDI	R16,0x88
    03F9C DFAE      RCALL	_ds1302_read_byte
    03F9D 9300 0516 STS	time_buf+2,R16
(0161) 	time_buf[3]=ds1302_read_byte(ds1302_date_add);		//日 
    03F9F E806      LDI	R16,0x86
    03FA0 DFAA      RCALL	_ds1302_read_byte
    03FA1 2EA0      MOV	R10,R16
    03FA2 92A0 0517 STS	time_buf+3,R10
(0162) 	time_buf[4]=ds1302_read_byte(ds1302_hr_add);		//时 
    03FA4 E804      LDI	R16,0x84
    03FA5 DFA5      RCALL	_ds1302_read_byte
    03FA6 2EA0      MOV	R10,R16
    03FA7 92A0 0518 STS	time_buf+4,R10
(0163) 	time_buf[5]=ds1302_read_byte(ds1302_min_add);		//分 
    03FA9 E802      LDI	R16,0x82
    03FAA DFA0      RCALL	_ds1302_read_byte
    03FAB 2EA0      MOV	R10,R16
    03FAC 92A0 0519 STS	time_buf+5,R10
(0164) 	time_buf[6]=(ds1302_read_byte(ds1302_sec_add))&0x7F;//秒，屏蔽秒的第7位，避免超出59
    03FAE E800      LDI	R16,0x80
    03FAF DF9B      RCALL	_ds1302_read_byte
    03FB0 2F40      MOV	R20,R16
    03FB1 2F84      MOV	R24,R20
    03FB2 778F      ANDI	R24,0x7F
    03FB3 9380 051A STS	time_buf+6,R24
(0165) 	time_buf[7]=ds1302_read_byte(ds1302_day_add);		//周 
    03FB5 E80A      LDI	R16,0x8A
    03FB6 DF94      RCALL	_ds1302_read_byte
    03FB7 2EA0      MOV	R10,R16
    03FB8 92A0 051B STS	time_buf+7,R10
    03FBA 9149      LD	R20,Y+
    03FBB 90A9      LD	R10,Y+
    03FBC 9508      RET
_kbscan:
  key                  --> R20
  temp                 --> Y,+0
    03FBD 934A      ST	-Y,R20
    03FBE 9724      SBIW	R28,4
FILE: D:\LQD\software\master\software_src\key.c
(0001) #include "config.h"
(0002) //键盘扫描函数
(0003) unsigned char kbscan(void)
(0004)   {
(0005)    unsigned char key;
(0006)    unsigned long temp=0;
    03FBF E080      LDI	R24,0
    03FC0 8388      ST	Y,R24
    03FC1 8389      STD	Y+1,R24
    03FC2 838A      STD	Y+2,R24
    03FC3 838B      STD	Y+3,R24
(0007)    DDR_SET;
    03FC4 B38A      IN	R24,0x1A
    03FC5 7087      ANDI	R24,7
    03FC6 BB8A      OUT	0x1A,R24
(0008)    
(0009)    if((KEY_PIN) != KEY_MASK)         //检测A口按键引脚电平，如果全是高电平则退出
    03FC7 B389      IN	R24,0x19
    03FC8 718F      ANDI	R24,0x1F
    03FC9 318F      CPI	R24,0x1F
    03FCA F189      BEQ	0x3FFC
(0010)     {
(0011)      delayms(20);           //防抖
    03FCB E104      LDI	R16,0x14
    03FCC E010      LDI	R17,0
    03FCD 940E 2413 CALL	_delayms
(0012)      if((KEY_PIN) != KEY_MASK )      //再次检测A口电平，如果不全是高电平则继续执行程序
    03FCF B389      IN	R24,0x19
    03FD0 718F      ANDI	R24,0x1F
    03FD1 318F      CPI	R24,0x1F
    03FD2 F159      BEQ	0x3FFE
(0013)       {
(0014)        key = KEY_PIN ;          //读取PINA，将其存放在key中
    03FD3 B349      IN	R20,0x19
    03FD4 714F      ANDI	R20,0x1F
    03FD5 C020      RJMP	0x3FF6
(0015)         while((KEY_PIN) != KEY_MASK)
(0016) 		{
(0017) 		 temp++ ;
    03FD6 E081      LDI	R24,1
    03FD7 E090      LDI	R25,0
    03FD8 E0A0      LDI	R26,0
    03FD9 E0B0      LDI	R27,0
    03FDA 8028      LD	R2,Y
    03FDB 8039      LDD	R3,Y+1
    03FDC 804A      LDD	R4,Y+2
    03FDD 805B      LDD	R5,Y+3
    03FDE 0E28      ADD	R2,R24
    03FDF 1E39      ADC	R3,R25
    03FE0 1E4A      ADC	R4,R26
    03FE1 1E5B      ADC	R5,R27
    03FE2 8228      ST	Y,R2
    03FE3 8239      STD	Y+1,R3
    03FE4 824A      STD	Y+2,R4
    03FE5 825B      STD	Y+3,R5
(0018) 		 if(temp>LONGKEY) 
    03FE6 E880      LDI	R24,0x80
    03FE7 E398      LDI	R25,0x38
    03FE8 E0A1      LDI	R26,1
    03FE9 E0B0      LDI	R27,0
    03FEA 8028      LD	R2,Y
    03FEB 8039      LDD	R3,Y+1
    03FEC 804A      LDD	R4,Y+2
    03FED 805B      LDD	R5,Y+3
    03FEE 1582      CP	R24,R2
    03FEF 0593      CPC	R25,R3
    03FF0 05A4      CPC	R26,R4
    03FF1 05B5      CPC	R27,R5
    03FF2 F418      BCC	0x3FF6
(0019) 		 {  return key+0x80;  };
    03FF3 2F04      MOV	R16,R20
    03FF4 5800      SUBI	R16,0x80
    03FF5 C009      RJMP	0x3FFF
    03FF6 B389      IN	R24,0x19
    03FF7 718F      ANDI	R24,0x1F
    03FF8 318F      CPI	R24,0x1F
    03FF9 F6E1      BNE	0x3FD6
(0020) 		}
(0021) 		; //当前有按键处于按下状态，再按其他按键时程序维持当前状态 
(0022)       	
(0023) 		return key;
    03FFA 2F04      MOV	R16,R20
    03FFB C003      RJMP	0x3FFF
(0024) 	  
(0025) 	  }
(0026)     }
(0027) 	else return NO_KEY;
    03FFC 2700      CLR	R16
    03FFD C001      RJMP	0x3FFF
(0028) 	
(0029) 	return NO_KEY;
FILE: <library>
    03FFE 2700      CLR	R16
    03FFF 9624      ADIW	R28,4
    04000 9149      LD	R20,Y+
    04001 9508      RET
_memset:
    04002 8188      LD	R24,Y
    04003 8199      LDD	R25,Y+1
    04004 3080      CPI	R24,0
    04005 0789      CPC	R24,R25
    04006 F029      BEQ	0x400C
    04007 2FE0      MOV	R30,R16
    04008 2FF1      MOV	R31,R17
    04009 9321      ST	Z+,R18
    0400A 9701      SBIW	R24,1
    0400B F7E9      BNE	0x4009
    0400C 9508      RET
_strcat:
    0400D 2FA0      MOV	R26,R16
    0400E 2FB1      MOV	R27,R17
    0400F 2FE2      MOV	R30,R18
    04010 2FF3      MOV	R31,R19
    04011 912D      LD	R18,X+
    04012 2322      TST	R18
    04013 F7E9      BNE	0x4011
    04014 9711      SBIW	R26,1
    04015 9121      LD	R18,Z+
    04016 932D      ST	X+,R18
    04017 2322      TST	R18
    04018 F7E1      BNE	0x4015
    04019 9508      RET
_strlen:
    0401A 2FE0      MOV	R30,R16
    0401B 2FF1      MOV	R31,R17
    0401C 27AA      CLR	R26
    0401D 27BB      CLR	R27
    0401E 9001      LD	R0,Z+
    0401F 2000      TST	R0
    04020 F011      BEQ	0x4023
    04021 9611      ADIW	R26,1
    04022 CFFB      RJMP	0x401E
    04023 2F0A      MOV	R16,R26
    04024 2F1B      MOV	R17,R27
    04025 9508      RET
push_arg4:
    04026 933A      ST	-Y,R19
    04027 932A      ST	-Y,R18
push_arg2:
    04028 931A      ST	-Y,R17
    04029 930A      ST	-Y,R16
    0402A 9508      RET
asr32:
    0402B 920F      PUSH	R0
    0402C 9009      LD	R0,Y+
    0402D 2000      TST	R0
    0402E F031      BEQ	0x4035
    0402F 9535      ASR	R19
    04030 9527      ROR	R18
    04031 9517      ROR	R17
    04032 9507      ROR	R16
    04033 940A      DEC	R0
    04034 CFF8      RJMP	0x402D
    04035 900F      POP	R0
    04036 9508      RET
mod16s:
    04037 9468      BSET	6
    04038 92DA      ST	-Y,R13
    04039 2ED1      MOV	R13,R17
    0403A C004      RJMP	0x403F
div16s:
    0403B 94E8      BCLR	6
    0403C 92DA      ST	-Y,R13
    0403D 2ED1      MOV	R13,R17
    0403E 26D3      EOR	R13,R19
    0403F FF17      SBRS	R17,7
    04040 C004      RJMP	0x4045
    04041 9510      COM	R17
    04042 9500      COM	R16
    04043 5F0F      SUBI	R16,0xFF
    04044 4F1F      SBCI	R17,0xFF
    04045 FF37      SBRS	R19,7
    04046 C004      RJMP	0x404B
    04047 9530      COM	R19
    04048 9520      COM	R18
    04049 5F2F      SUBI	R18,0xFF
    0404A 4F3F      SBCI	R19,0xFF
    0404B 940E 4058 CALL	xdiv16u
    0404D FED7      SBRS	R13,7
    0404E C004      RJMP	0x4053
    0404F 9510      COM	R17
    04050 9500      COM	R16
    04051 5F0F      SUBI	R16,0xFF
    04052 4F1F      SBCI	R17,0xFF
    04053 90D9      LD	R13,Y+
    04054 9508      RET
mod16u:
    04055 9468      BSET	6
    04056 C001      RJMP	xdiv16u
div16u:
    04057 94E8      BCLR	6
xdiv16u:
    04058 92EA      ST	-Y,R14
    04059 92FA      ST	-Y,R15
    0405A 938A      ST	-Y,R24
    0405B 24EE      CLR	R14
    0405C 24FF      CLR	R15
    0405D E180      LDI	R24,0x10
    0405E 0F00      LSL	R16
    0405F 1F11      ROL	R17
    04060 1CEE      ROL	R14
    04061 1CFF      ROL	R15
    04062 16E2      CP	R14,R18
    04063 06F3      CPC	R15,R19
    04064 F018      BCS	0x4068
    04065 1AE2      SUB	R14,R18
    04066 0AF3      SBC	R15,R19
    04067 9503      INC	R16
    04068 958A      DEC	R24
    04069 F7A1      BNE	0x405E
    0406A F416      BRTC	0x406D
    0406B 2D0E      MOV	R16,R14
    0406C 2D1F      MOV	R17,R15
    0406D 9189      LD	R24,Y+
    0406E 90F9      LD	R15,Y+
    0406F 90E9      LD	R14,Y+
    04070 9508      RET
div32u:
    04071 94E8      BCLR	6
    04072 C001      RJMP	0x4074
mod32u:
    04073 9468      BSET	6
    04074 D030      RCALL	long_div_prolog
    04075 24CC      CLR	R12
    04076 C009      RJMP	0x4080
div32s:
    04077 94E8      BCLR	6
    04078 C001      RJMP	0x407A
mod32s:
    04079 9468      BSET	6
    0407A D02A      RCALL	long_div_prolog
    0407B FD37      SBRC	R19,7
    0407C 940E 41B8 CALL	neg32
    0407E FDB7      SBRC	R27,7
    0407F D052      RCALL	neg_R24_R27
    04080 2477      CLR	R7
    04081 2488      CLR	R8
    04082 2499      CLR	R9
    04083 24AA      CLR	R10
    04084 24BB      CLR	R11
    04085 D042      RCALL	tst_R16_R19
    04086 F0C1      BEQ	0x409F
    04087 D045      RCALL	tst_R24_R27
    04088 F0B1      BEQ	0x409F
    04089 E2E8      LDI	R30,0x28
    0408A 0F00      LSL	R16
    0408B 1F11      ROL	R17
    0408C 1F22      ROL	R18
    0408D 1F33      ROL	R19
    0408E 1C77      ROL	R7
    0408F 1C88      ROL	R8
    04090 1C99      ROL	R9
    04091 1CAA      ROL	R10
    04092 1CBB      ROL	R11
    04093 1688      CP	R8,R24
    04094 0699      CPC	R9,R25
    04095 06AA      CPC	R10,R26
    04096 06BB      CPC	R11,R27
    04097 F028      BCS	0x409D
    04098 1A88      SUB	R8,R24
    04099 0A99      SBC	R9,R25
    0409A 0AAA      SBC	R10,R26
    0409B 0ABB      SBC	R11,R27
    0409C 9503      INC	R16
    0409D 95EA      DEC	R30
    0409E F759      BNE	0x408A
    0409F F426      BRTC	0x40A4
    040A0 2D08      MOV	R16,R8
    040A1 2D19      MOV	R17,R9
    040A2 2D2A      MOV	R18,R10
    040A3 2D3B      MOV	R19,R11
    040A4 C013      RJMP	long_div_epilog
long_div_prolog:
    040A5 927A      ST	-Y,R7
    040A6 928A      ST	-Y,R8
    040A7 929A      ST	-Y,R9
    040A8 92AA      ST	-Y,R10
    040A9 92BA      ST	-Y,R11
    040AA 92CA      ST	-Y,R12
    040AB 93EA      ST	-Y,R30
    040AC 938A      ST	-Y,R24
    040AD 939A      ST	-Y,R25
    040AE 93AA      ST	-Y,R26
    040AF 93BA      ST	-Y,R27
    040B0 858B      LDD	R24,Y+11
    040B1 859C      LDD	R25,Y+12
    040B2 85AD      LDD	R26,Y+13
    040B3 85BE      LDD	R27,Y+14
    040B4 2EC3      MOV	R12,R19
    040B5 F00E      BRTS	0x40B7
    040B6 26CB      EOR	R12,R27
    040B7 9508      RET
long_div_epilog:
    040B8 FCC7      SBRC	R12,7
    040B9 940E 41B8 CALL	neg32
    040BB 91B9      LD	R27,Y+
    040BC 91A9      LD	R26,Y+
    040BD 9199      LD	R25,Y+
    040BE 9189      LD	R24,Y+
    040BF 91E9      LD	R30,Y+
    040C0 90C9      LD	R12,Y+
    040C1 90B9      LD	R11,Y+
    040C2 90A9      LD	R10,Y+
    040C3 9099      LD	R9,Y+
    040C4 9089      LD	R8,Y+
    040C5 9079      LD	R7,Y+
    040C6 9624      ADIW	R28,4
    040C7 9508      RET
tst_R16_R19:
    040C8 2FE0      MOV	R30,R16
    040C9 2BE1      OR	R30,R17
    040CA 2BE2      OR	R30,R18
    040CB 2BE3      OR	R30,R19
    040CC 9508      RET
tst_R24_R27:
    040CD 2FE8      MOV	R30,R24
    040CE 2BE9      OR	R30,R25
    040CF 2BEA      OR	R30,R26
    040D0 2BEB      OR	R30,R27
    040D1 9508      RET
neg_R24_R27:
    040D2 9580      COM	R24
    040D3 9590      COM	R25
    040D4 95A0      COM	R26
    040D5 95B0      COM	R27
    040D6 5F8F      SUBI	R24,0xFF
    040D7 4F9F      SBCI	R25,0xFF
    040D8 4FAF      SBCI	R26,0xFF
    040D9 4FBF      SBCI	R27,0xFF
    040DA 9508      RET
mod8u:
    040DB 9468      BSET	6
    040DC C001      RJMP	xdiv8u
div8u:
    040DD 94E8      BCLR	6
xdiv8u:
    040DE 932A      ST	-Y,R18
    040DF 92FA      ST	-Y,R15
    040E0 92EA      ST	-Y,R14
    040E1 24FF      CLR	R15
    040E2 24EE      CLR	R14
    040E3 E120      LDI	R18,0x10
    040E4 0F00      LSL	R16
    040E5 1CFF      ROL	R15
    040E6 1CEE      ROL	R14
    040E7 16E1      CP	R14,R17
    040E8 F010      BCS	0x40EB
    040E9 1AE1      SUB	R14,R17
    040EA 9503      INC	R16
    040EB 952A      DEC	R18
    040EC F7B9      BNE	0x40E4
    040ED F40E      BRTC	0x40EF
    040EE 2D0E      MOV	R16,R14
    040EF 90E9      LD	R14,Y+
    040F0 90F9      LD	R15,Y+
    040F1 9129      LD	R18,Y+
    040F2 9508      RET
elpm32:
    040F3 93EA      ST	-Y,R30
    040F4 93FA      ST	-Y,R31
    040F5 920A      ST	-Y,R0
    040F6 2FE0      MOV	R30,R16
    040F7 2FF1      MOV	R31,R17
    040F8 95D8      ELPM
    040F9 2D00      MOV	R16,R0
    040FA 9631      ADIW	R30,1
    040FB 95D8      ELPM
    040FC 2D10      MOV	R17,R0
    040FD 9631      ADIW	R30,1
    040FE 95D8      ELPM
    040FF 2D20      MOV	R18,R0
    04100 9631      ADIW	R30,1
    04101 95D8      ELPM
    04102 2D30      MOV	R19,R0
    04103 9009      LD	R0,Y+
    04104 91F9      LD	R31,Y+
    04105 91E9      LD	R30,Y+
    04106 9508      RET
empy16s:
    04107 920A      ST	-Y,R0
    04108 921A      ST	-Y,R1
    04109 938A      ST	-Y,R24
    0410A 939A      ST	-Y,R25
    0410B 9F02      MUL	R16,R18
    0410C 01C0      MOVW	R24,R0
    0410D 9F12      MUL	R17,R18
    0410E 0D90      ADD	R25,R0
    0410F 9F03      MUL	R16,R19
    04110 0D90      ADD	R25,R0
    04111 018C      MOVW	R16,R24
    04112 9199      LD	R25,Y+
    04113 9189      LD	R24,Y+
    04114 9019      LD	R1,Y+
    04115 9009      LD	R0,Y+
    04116 9508      RET
empy32u|empy32s:
    04117 940E 41C1 CALL	long_prolog
    04119 927A      ST	-Y,R7
    0411A 940E 41DA CALL	tstzero1
    0411C F159      BEQ	0x4148
    0411D 2477      CLR	R7
    0411E 940E 41E0 CALL	tstzero2
    04120 F419      BNE	0x4124
    04121 018C      MOVW	R16,R24
    04122 019D      MOVW	R18,R26
    04123 C024      RJMP	0x4148
    04124 920A      ST	-Y,R0
    04125 921A      ST	-Y,R1
    04126 9F08      MUL	R16,R24
    04127 2CB0      MOV	R11,R0
    04128 2CA1      MOV	R10,R1
    04129 9F28      MUL	R18,R24
    0412A 2C90      MOV	R9,R0
    0412B 2C81      MOV	R8,R1
    0412C 9F18      MUL	R17,R24
    0412D 0CA0      ADD	R10,R0
    0412E 1C91      ADC	R9,R1
    0412F 1C87      ADC	R8,R7
    04130 9F09      MUL	R16,R25
    04131 0CA0      ADD	R10,R0
    04132 1C91      ADC	R9,R1
    04133 1C87      ADC	R8,R7
    04134 9F19      MUL	R17,R25
    04135 0C90      ADD	R9,R0
    04136 1C81      ADC	R8,R1
    04137 9F0A      MUL	R16,R26
    04138 0C90      ADD	R9,R0
    04139 1C81      ADC	R8,R1
    0413A 9F38      MUL	R19,R24
    0413B 0C80      ADD	R8,R0
    0413C 9F29      MUL	R18,R25
    0413D 0C80      ADD	R8,R0
    0413E 9F1A      MUL	R17,R26
    0413F 0C80      ADD	R8,R0
    04140 9F0B      MUL	R16,R27
    04141 0C80      ADD	R8,R0
    04142 9019      LD	R1,Y+
    04143 9009      LD	R0,Y+
    04144 2D0B      MOV	R16,R11
    04145 2D1A      MOV	R17,R10
    04146 2D29      MOV	R18,R9
    04147 2D38      MOV	R19,R8
    04148 9079      LD	R7,Y+
    04149 940C 41CF JMP	long_epilog
pop_xgset003C:
    0414B 90A9      LD	R10,Y+
    0414C 90B9      LD	R11,Y+
    0414D 90C9      LD	R12,Y+
    0414E 90D9      LD	R13,Y+
    0414F 9508      RET
pop_xgset00FC:
    04150 90A9      LD	R10,Y+
    04151 90B9      LD	R11,Y+
    04152 90C9      LD	R12,Y+
    04153 90D9      LD	R13,Y+
    04154 90E9      LD	R14,Y+
    04155 90F9      LD	R15,Y+
    04156 9508      RET
pop_xgset30FC:
    04157 90A9      LD	R10,Y+
    04158 90B9      LD	R11,Y+
    04159 90C9      LD	R12,Y+
    0415A 90D9      LD	R13,Y+
    0415B 90E9      LD	R14,Y+
    0415C 90F9      LD	R15,Y+
    0415D 9149      LD	R20,Y+
    0415E 9159      LD	R21,Y+
    0415F 9508      RET
pop_xgsetF0FC:
    04160 90A9      LD	R10,Y+
    04161 90B9      LD	R11,Y+
    04162 90C9      LD	R12,Y+
    04163 90D9      LD	R13,Y+
    04164 90E9      LD	R14,Y+
    04165 90F9      LD	R15,Y+
    04166 9149      LD	R20,Y+
    04167 9159      LD	R21,Y+
    04168 9169      LD	R22,Y+
    04169 9179      LD	R23,Y+
    0416A 9508      RET
push_xgsetF0FC:
    0416B 937A      ST	-Y,R23
    0416C 936A      ST	-Y,R22
push_xgset30FC:
    0416D 935A      ST	-Y,R21
    0416E 934A      ST	-Y,R20
push_xgset00FC:
    0416F 92FA      ST	-Y,R15
    04170 92EA      ST	-Y,R14
push_xgset003C:
    04171 92DA      ST	-Y,R13
    04172 92CA      ST	-Y,R12
    04173 92BA      ST	-Y,R11
    04174 92AA      ST	-Y,R10
    04175 9508      RET
push_xgset300C:
    04176 935A      ST	-Y,R21
    04177 934A      ST	-Y,R20
    04178 92BA      ST	-Y,R11
    04179 92AA      ST	-Y,R10
    0417A 9508      RET
pop_xgset300C:
    0417B 90A9      LD	R10,Y+
    0417C 90B9      LD	R11,Y+
    0417D 9149      LD	R20,Y+
    0417E 9159      LD	R21,Y+
    0417F 9508      RET
push_xgsetF000:
    04180 937A      ST	-Y,R23
    04181 936A      ST	-Y,R22
    04182 935A      ST	-Y,R21
    04183 934A      ST	-Y,R20
    04184 9508      RET
pop_xgsetF000:
    04185 9149      LD	R20,Y+
    04186 9159      LD	R21,Y+
    04187 9169      LD	R22,Y+
    04188 9179      LD	R23,Y+
    04189 9508      RET
push_xgsetF00C:
    0418A 937A      ST	-Y,R23
    0418B 936A      ST	-Y,R22
    0418C 935A      ST	-Y,R21
    0418D 934A      ST	-Y,R20
    0418E 92BA      ST	-Y,R11
    0418F 92AA      ST	-Y,R10
    04190 9508      RET
pop_xgsetF00C:
    04191 90A9      LD	R10,Y+
    04192 90B9      LD	R11,Y+
    04193 9149      LD	R20,Y+
    04194 9159      LD	R21,Y+
    04195 9169      LD	R22,Y+
    04196 9179      LD	R23,Y+
    04197 9508      RET
push_xgset303C:
    04198 935A      ST	-Y,R21
    04199 934A      ST	-Y,R20
    0419A 92DA      ST	-Y,R13
    0419B 92CA      ST	-Y,R12
    0419C 92BA      ST	-Y,R11
    0419D 92AA      ST	-Y,R10
    0419E 9508      RET
pop_xgset303C:
    0419F 90A9      LD	R10,Y+
    041A0 90B9      LD	R11,Y+
    041A1 90C9      LD	R12,Y+
    041A2 90D9      LD	R13,Y+
    041A3 9149      LD	R20,Y+
    041A4 9159      LD	R21,Y+
    041A5 9508      RET
push_xgsetF03C:
    041A6 937A      ST	-Y,R23
    041A7 936A      ST	-Y,R22
    041A8 935A      ST	-Y,R21
    041A9 934A      ST	-Y,R20
    041AA 92DA      ST	-Y,R13
    041AB 92CA      ST	-Y,R12
    041AC 92BA      ST	-Y,R11
    041AD 92AA      ST	-Y,R10
    041AE 9508      RET
pop_xgsetF03C:
    041AF 90A9      LD	R10,Y+
    041B0 90B9      LD	R11,Y+
    041B1 90C9      LD	R12,Y+
    041B2 90D9      LD	R13,Y+
    041B3 9149      LD	R20,Y+
    041B4 9159      LD	R21,Y+
    041B5 9169      LD	R22,Y+
    041B6 9179      LD	R23,Y+
    041B7 9508      RET
neg32:
    041B8 9500      COM	R16
    041B9 9510      COM	R17
    041BA 9520      COM	R18
    041BB 9530      COM	R19
    041BC 5F0F      SUBI	R16,0xFF
    041BD 4F1F      SBCI	R17,0xFF
    041BE 4F2F      SBCI	R18,0xFF
    041BF 4F3F      SBCI	R19,0xFF
    041C0 9508      RET
long_prolog:
    041C1 928A      ST	-Y,R8
    041C2 929A      ST	-Y,R9
    041C3 92AA      ST	-Y,R10
    041C4 92BA      ST	-Y,R11
    041C5 93EA      ST	-Y,R30
    041C6 938A      ST	-Y,R24
    041C7 939A      ST	-Y,R25
    041C8 93AA      ST	-Y,R26
    041C9 93BA      ST	-Y,R27
    041CA 8589      LDD	R24,Y+9
    041CB 859A      LDD	R25,Y+10
    041CC 85AB      LDD	R26,Y+11
    041CD 85BC      LDD	R27,Y+12
    041CE 9508      RET
long_epilog:
    041CF 91B9      LD	R27,Y+
    041D0 91A9      LD	R26,Y+
    041D1 9199      LD	R25,Y+
    041D2 9189      LD	R24,Y+
    041D3 91E9      LD	R30,Y+
    041D4 90B9      LD	R11,Y+
    041D5 90A9      LD	R10,Y+
    041D6 9099      LD	R9,Y+
    041D7 9089      LD	R8,Y+
    041D8 9624      ADIW	R28,4
    041D9 9508      RET
tstzero1:
    041DA 27EE      CLR	R30
    041DB 2BE0      OR	R30,R16
    041DC 2BE1      OR	R30,R17
    041DD 2BE2      OR	R30,R18
    041DE 2BE3      OR	R30,R19
    041DF 9508      RET
tstzero2:
    041E0 27EE      CLR	R30
    041E1 2BE8      OR	R30,R24
    041E2 2BE9      OR	R30,R25
    041E3 2BEA      OR	R30,R26
    041E4 2BEB      OR	R30,R27
    041E5 9508      RET
lsl16:
    041E6 2322      TST	R18
    041E7 F021      BEQ	0x41EC
    041E8 0F00      LSL	R16
    041E9 1F11      ROL	R17
    041EA 952A      DEC	R18
    041EB CFFA      RJMP	lsl16
    041EC 9508      RET
lsl32:
    041ED 920F      PUSH	R0
    041EE 9009      LD	R0,Y+
    041EF 2000      TST	R0
    041F0 F031      BEQ	0x41F7
    041F1 0F00      LSL	R16
    041F2 1F11      ROL	R17
    041F3 1F22      ROL	R18
    041F4 1F33      ROL	R19
    041F5 940A      DEC	R0
    041F6 CFF8      RJMP	0x41EF
    041F7 900F      POP	R0
    041F8 9508      RET
lsl8:
    041F9 2311      TST	R17
    041FA F019      BEQ	0x41FE
    041FB 0F00      LSL	R16
    041FC 951A      DEC	R17
    041FD CFFB      RJMP	lsl8
    041FE 9508      RET
lsr16:
    041FF 2322      TST	R18
    04200 F021      BEQ	0x4205
    04201 9516      LSR	R17
    04202 9507      ROR	R16
    04203 952A      DEC	R18
    04204 CFFA      RJMP	lsr16
    04205 9508      RET
lsr32:
    04206 920F      PUSH	R0
    04207 9009      LD	R0,Y+
    04208 2000      TST	R0
    04209 F031      BEQ	0x4210
    0420A 9536      LSR	R19
    0420B 9527      ROR	R18
    0420C 9517      ROR	R17
    0420D 9507      ROR	R16
    0420E 940A      DEC	R0
    0420F CFF8      RJMP	0x4208
    04210 900F      POP	R0
    04211 9508      RET
asgnblk:
    04212 93AA      ST	-Y,R26
    04213 93BA      ST	-Y,R27
    04214 93EA      ST	-Y,R30
    04215 93FA      ST	-Y,R31
    04216 920A      ST	-Y,R0
    04217 81AF      LDD	R26,Y+7
    04218 85B8      LDD	R27,Y+8
    04219 81ED      LDD	R30,Y+5
    0421A 81FE      LDD	R31,Y+6
    0421B 3000      CPI	R16,0
    0421C 0701      CPC	R16,R17
    0421D F029      BEQ	0x4223
    0421E 9001      LD	R0,Z+
    0421F 920D      ST	X+,R0
    04220 5001      SUBI	R16,1
    04221 4010      SBCI	R17,0
    04222 CFF8      RJMP	0x421B
    04223 9009      LD	R0,Y+
    04224 91F9      LD	R31,Y+
    04225 91E9      LD	R30,Y+
    04226 91B9      LD	R27,Y+
    04227 91A9      LD	R26,Y+
    04228 9624      ADIW	R28,4
    04229 9508      RET
fpsub:
    0422A 9468      BSET	6
    0422B C001      RJMP	fpadd_alt
fpadd:
    0422C 94E8      BCLR	6
fpadd_alt:
    0422D 940E 43F1 CALL	saveFPRegs
    0422F 940E 4383 CALL	unpacks
    04231 F409      BNE	0x4233
    04232 C048      RJMP	0x427B
    04233 2CE6      MOV	R14,R6
    04234 2CD5      MOV	R13,R5
    04235 2CC4      MOV	R12,R4
    04236 2EB3      MOV	R11,R19
    04237 2EA2      MOV	R10,R18
    04238 2E91      MOV	R9,R17
    04239 2E80      MOV	R8,R16
    0423A 8100      LD	R16,Z
    0423B 8111      LDD	R17,Z+1
    0423C 8122      LDD	R18,Z+2
    0423D 8133      LDD	R19,Z+3
    0423E 940E 4383 CALL	unpacks
    04240 F409      BNE	0x4242
    04241 C044      RJMP	0x4286
    04242 2D84      MOV	R24,R4
    04243 2D95      MOV	R25,R5
    04244 198C      SUB	R24,R12
    04245 099D      SBC	R25,R13
    04246 F0B9      BEQ	0x425E
    04247 F472      BPL	0x4256
    04248 9590      COM	R25
    04249 9580      COM	R24
    0424A 9601      ADIW	R24,1
    0424B 2C4C      MOV	R4,R12
    0424C 2C5D      MOV	R5,R13
    0424D 3188      CPI	R24,0x18
    0424E F5B8      BCC	0x4286
    0424F 9535      ASR	R19
    04250 9527      ROR	R18
    04251 9517      ROR	R17
    04252 9507      ROR	R16
    04253 9701      SBIW	R24,1
    04254 F7D1      BNE	0x424F
    04255 C008      RJMP	0x425E
    04256 3188      CPI	R24,0x18
    04257 F518      BCC	0x427B
    04258 94B5      ASR	R11
    04259 94A7      ROR	R10
    0425A 9497      ROR	R9
    0425B 9487      ROR	R8
    0425C 9701      SBIW	R24,1
    0425D F7D1      BNE	0x4258
    0425E 2466      CLR	R6
    0425F F02E      BRTS	0x4265
    04260 0D08      ADD	R16,R8
    04261 1D19      ADC	R17,R9
    04262 1D2A      ADC	R18,R10
    04263 1D3B      ADC	R19,R11
    04264 C009      RJMP	0x426E
    04265 1A80      SUB	R8,R16
    04266 0A91      SBC	R9,R17
    04267 0AA2      SBC	R10,R18
    04268 0AB3      SBC	R11,R19
    04269 2D08      MOV	R16,R8
    0426A 2D19      MOV	R17,R9
    0426B 2D2A      MOV	R18,R10
    0426C 2D3B      MOV	R19,R11
    0426D 2333      TST	R19
    0426E F422      BPL	0x4273
    0426F 940E 41B8 CALL	neg32
    04271 E880      LDI	R24,0x80
    04272 2E68      MOV	R6,R24
    04273 940E 43AC CALL	normalize_and_pack
    04275 C002      RJMP	0x4278
    04276 940E 43E1 CALL	pack
    04278 940E 4400 CALL	restoreFPRegs
    0427A 9508      RET
    0427B 8100      LD	R16,Z
    0427C 8111      LDD	R17,Z+1
    0427D 8122      LDD	R18,Z+2
    0427E 8133      LDD	R19,Z+3
    0427F F7C6      BRTC	0x4278
    04280 940E 438B CALL	tstR16_R19
    04282 F3A9      BEQ	0x4278
    04283 E880      LDI	R24,0x80
    04284 2738      EOR	R19,R24
    04285 CFF2      RJMP	0x4278
    04286 2D08      MOV	R16,R8
    04287 2D19      MOV	R17,R9
    04288 2D2A      MOV	R18,R10
    04289 2D3B      MOV	R19,R11
    0428A 2C4C      MOV	R4,R12
    0428B 2C5D      MOV	R5,R13
    0428C 2C6E      MOV	R6,R14
    0428D 2333      TST	R19
    0428E F73A      BPL	0x4276
    0428F 940E 41B8 CALL	neg32
    04291 E880      LDI	R24,0x80
    04292 2E68      MOV	R6,R24
    04293 CFE2      RJMP	0x4276
fpadd2:
    04294 93FA      ST	-Y,R31
    04295 93EA      ST	-Y,R30
    04296 2FEC      MOV	R30,R28
    04297 2FFD      MOV	R31,R29
    04298 9632      ADIW	R30,2
    04299 940E 422C CALL	fpadd
    0429B 91E9      LD	R30,Y+
    0429C 91F9      LD	R31,Y+
    0429D 9624      ADIW	R28,4
    0429E 9508      RET
fpsub2:
    0429F 93FA      ST	-Y,R31
    042A0 93EA      ST	-Y,R30
    042A1 2FEC      MOV	R30,R28
    042A2 2FFD      MOV	R31,R29
    042A3 9632      ADIW	R30,2
    042A4 940E 422A CALL	fpsub
    042A6 91E9      LD	R30,Y+
    042A7 91F9      LD	R31,Y+
    042A8 9624      ADIW	R28,4
    042A9 9508      RET
fpsub1x:
    042AA 93FA      ST	-Y,R31
    042AB 93EA      ST	-Y,R30
    042AC 81EA      LDD	R30,Y+2
    042AD 81FB      LDD	R31,Y+3
    042AE 940E 422A CALL	fpsub
    042B0 91E9      LD	R30,Y+
    042B1 91F9      LD	R31,Y+
    042B2 8339      STD	Y+1,R19
    042B3 8328      ST	Y,R18
    042B4 931A      ST	-Y,R17
    042B5 930A      ST	-Y,R16
    042B6 9508      RET
fpsub2x:
    042B7 93FA      ST	-Y,R31
    042B8 93EA      ST	-Y,R30
    042B9 2FEC      MOV	R30,R28
    042BA 2FFD      MOV	R31,R29
    042BB 9632      ADIW	R30,2
    042BC 940E 422A CALL	fpsub
    042BE 91E9      LD	R30,Y+
    042BF 91F9      LD	R31,Y+
    042C0 833B      STD	Y+3,R19
    042C1 832A      STD	Y+2,R18
    042C2 8319      STD	Y+1,R17
    042C3 8308      ST	Y,R16
    042C4 9508      RET
uint2fp:
    042C5 9468      BSET	6
    042C6 C001      RJMP	0x42C8
int2fp:
    042C7 94E8      BCLR	6
    042C8 2722      CLR	R18
    042C9 2733      CLR	R19
    042CA F046      BRTS	0x42D3
    042CB FD17      SBRC	R17,7
    042CC 9520      COM	R18
    042CD FD17      SBRC	R17,7
    042CE 9530      COM	R19
    042CF C003      RJMP	0x42D3
ulong2fp:
    042D0 9468      BSET	6
    042D1 C001      RJMP	0x42D3
long2fp:
    042D2 94E8      BCLR	6
    042D3 924A      ST	-Y,R4
    042D4 925A      ST	-Y,R5
    042D5 926A      ST	-Y,R6
    042D6 938A      ST	-Y,R24
    042D7 E187      LDI	R24,0x17
    042D8 2E48      MOV	R4,R24
    042D9 2455      CLR	R5
    042DA 2466      CLR	R6
    042DB F036      BRTS	0x42E2
    042DC 2333      TST	R19
    042DD F422      BPL	0x42E2
    042DE 940E 41B8 CALL	neg32
    042E0 E880      LDI	R24,0x80
    042E1 2E68      MOV	R6,R24
    042E2 940E 43AC CALL	normalize_and_pack
    042E4 9189      LD	R24,Y+
    042E5 9069      LD	R6,Y+
    042E6 9059      LD	R5,Y+
    042E7 9049      LD	R4,Y+
    042E8 9508      RET
fpdiv1:
    042E9 93FA      ST	-Y,R31
    042EA 93EA      ST	-Y,R30
    042EB 81EA      LDD	R30,Y+2
    042EC 81FB      LDD	R31,Y+3
    042ED D027      RCALL	0x4315
    042EE 91E9      LD	R30,Y+
    042EF 91F9      LD	R31,Y+
    042F0 9622      ADIW	R28,2
    042F1 9508      RET
fpdiv2:
    042F2 93FA      ST	-Y,R31
    042F3 93EA      ST	-Y,R30
    042F4 2FEC      MOV	R30,R28
    042F5 2FFD      MOV	R31,R29
    042F6 9632      ADIW	R30,2
    042F7 D01D      RCALL	0x4315
    042F8 91E9      LD	R30,Y+
    042F9 91F9      LD	R31,Y+
    042FA 9624      ADIW	R28,4
    042FB 9508      RET
fpdiv1x:
    042FC 93FA      ST	-Y,R31
    042FD 93EA      ST	-Y,R30
    042FE 81EA      LDD	R30,Y+2
    042FF 81FB      LDD	R31,Y+3
    04300 D014      RCALL	0x4315
    04301 91E9      LD	R30,Y+
    04302 91F9      LD	R31,Y+
    04303 8339      STD	Y+1,R19
    04304 8328      ST	Y,R18
    04305 931A      ST	-Y,R17
    04306 930A      ST	-Y,R16
    04307 9508      RET
fpdiv2x:
    04308 93FA      ST	-Y,R31
    04309 93EA      ST	-Y,R30
    0430A 2FEC      MOV	R30,R28
    0430B 2FFD      MOV	R31,R29
    0430C 9632      ADIW	R30,2
    0430D D007      RCALL	0x4315
    0430E 91E9      LD	R30,Y+
    0430F 91F9      LD	R31,Y+
    04310 833B      STD	Y+3,R19
    04311 832A      STD	Y+2,R18
    04312 8319      STD	Y+1,R17
    04313 8308      ST	Y,R16
    04314 9508      RET
    04315 920A      ST	-Y,R0
    04316 921A      ST	-Y,R1
    04317 922A      ST	-Y,R2
    04318 923A      ST	-Y,R3
    04319 940E 43F1 CALL	saveFPRegs
    0431B 933A      ST	-Y,R19
    0431C 932A      ST	-Y,R18
    0431D 931A      ST	-Y,R17
    0431E 930A      ST	-Y,R16
    0431F 8100      LD	R16,Z
    04320 8111      LDD	R17,Z+1
    04321 8122      LDD	R18,Z+2
    04322 8133      LDD	R19,Z+3
    04323 940E 4393 CALL	unpacku
    04325 F409      BNE	0x4327
    04326 C057      RJMP	0x437E
    04327 2CE6      MOV	R14,R6
    04328 2CD5      MOV	R13,R5
    04329 2CC4      MOV	R12,R4
    0432A 2EB3      MOV	R11,R19
    0432B 2EA2      MOV	R10,R18
    0432C 2E91      MOV	R9,R17
    0432D 2E80      MOV	R8,R16
    0432E 9109      LD	R16,Y+
    0432F 9119      LD	R17,Y+
    04330 9129      LD	R18,Y+
    04331 9139      LD	R19,Y+
    04332 940E 4393 CALL	unpacku
    04334 F1A1      BEQ	0x4369
    04335 246E      EOR	R6,R14
    04336 184C      SUB	R4,R12
    04337 085D      SBC	R5,R13
    04338 E880      LDI	R24,0x80
    04339 1648      CP	R4,R24
    0433A 0653      CPC	R5,R19
    0433B F00C      BLT	0x433D
    0433C C033      RJMP	0x4370
    0433D E881      LDI	R24,0x81
    0433E 1648      CP	R4,R24
    0433F EF8F      LDI	R24,0xFF
    04340 0658      CPC	R5,R24
    04341 F40C      BGE	0x4343
    04342 C036      RJMP	0x4379
    04343 E280      LDI	R24,0x20
    04344 2433      CLR	R3
    04345 2E23      MOV	R2,R19
    04346 2E12      MOV	R1,R18
    04347 2E01      MOV	R0,R17
    04348 2F30      MOV	R19,R16
    04349 2722      CLR	R18
    0434A 2711      CLR	R17
    0434B 2700      CLR	R16
    0434C 9426      LSR	R2
    0434D 9417      ROR	R1
    0434E 9407      ROR	R0
    0434F 9537      ROR	R19
    04350 9527      ROR	R18
    04351 0F00      LSL	R16
    04352 1F11      ROL	R17
    04353 1F22      ROL	R18
    04354 1F33      ROL	R19
    04355 1C00      ROL	R0
    04356 1C11      ROL	R1
    04357 1C22      ROL	R2
    04358 1C33      ROL	R3
    04359 F028      BCS	0x435F
    0435A 1808      SUB	R0,R8
    0435B 0819      SBC	R1,R9
    0435C 082A      SBC	R2,R10
    0435D 083B      SBC	R3,R11
    0435E C004      RJMP	0x4363
    0435F 0C08      ADD	R0,R8
    04360 1C19      ADC	R1,R9
    04361 1C2A      ADC	R2,R10
    04362 1C3B      ADC	R3,R11
    04363 F00A      BMI	0x4365
    04364 6001      ORI	R16,1
    04365 958A      DEC	R24
    04366 F751      BNE	0x4351
    04367 940E 43AC CALL	normalize_and_pack
    04369 940E 4400 CALL	restoreFPRegs
    0436B 9039      LD	R3,Y+
    0436C 9029      LD	R2,Y+
    0436D 9019      LD	R1,Y+
    0436E 9009      LD	R0,Y+
    0436F 9508      RET
    04370 EF0F      LDI	R16,0xFF
    04371 2F10      MOV	R17,R16
    04372 E72F      LDI	R18,0x7F
    04373 E73F      LDI	R19,0x7F
    04374 2066      TST	R6
    04375 F399      BEQ	0x4369
    04376 940E 41B8 CALL	neg32
    04378 CFF0      RJMP	0x4369
    04379 2700      CLR	R16
    0437A 2F10      MOV	R17,R16
    0437B 2F20      MOV	R18,R16
    0437C 2F30      MOV	R19,R16
    0437D CFEB      RJMP	0x4369
    0437E 9109      LD	R16,Y+
    0437F 9119      LD	R17,Y+
    04380 9129      LD	R18,Y+
    04381 9139      LD	R19,Y+
    04382 CFED      RJMP	0x4370
unpacks:
    04383 D00F      RCALL	unpacku
    04384 F029      BEQ	0x438A
    04385 2066      TST	R6
    04386 F011      BEQ	0x4389
    04387 940E 41B8 CALL	neg32
    04389 9498      BCLR	1
    0438A 9508      RET
tstR16_R19:
    0438B 2300      TST	R16
    0438C F429      BNE	0x4392
    0438D 2311      TST	R17
    0438E F419      BNE	0x4392
    0438F 2322      TST	R18
    04390 F409      BNE	0x4392
    04391 2333      TST	R19
    04392 9508      RET
unpacku:
    04393 DFF7      RCALL	tstR16_R19
    04394 F099      BEQ	0x43A8
    04395 938A      ST	-Y,R24
    04396 2E63      MOV	R6,R19
    04397 E880      LDI	R24,0x80
    04398 2268      AND	R6,R24
    04399 0F22      LSL	R18
    0439A 1F33      ROL	R19
    0439B 2E43      MOV	R4,R19
    0439C E78F      LDI	R24,0x7F
    0439D 1A48      SUB	R4,R24
    0439E 2455      CLR	R5
    0439F 2788      CLR	R24
    043A0 0A58      SBC	R5,R24
    043A1 9526      LSR	R18
    043A2 E830      LDI	R19,0x80
    043A3 2B23      OR	R18,R19
    043A4 2733      CLR	R19
    043A5 9189      LD	R24,Y+
    043A6 9498      BCLR	1
    043A7 9508      RET
    043A8 2444      CLR	R4
    043A9 2455      CLR	R5
    043AA 2466      CLR	R6
    043AB 9508      RET
normalize_and_pack:
    043AC DFDE      RCALL	tstR16_R19
    043AD F409      BNE	0x43AF
    043AE 9508      RET
    043AF 93AA      ST	-Y,R26
    043B0 93BA      ST	-Y,R27
    043B1 01D2      MOVW	R26,R4
    043B2 939A      ST	-Y,R25
    043B3 938A      ST	-Y,R24
    043B4 E78E      LDI	R24,0x7E
    043B5 E090      LDI	R25,0
    043B6 2333      TST	R19
    043B7 F049      BEQ	0x43C1
    043B8 9536      LSR	R19
    043B9 9527      ROR	R18
    043BA 9517      ROR	R17
    043BB 9507      ROR	R16
    043BC 17A8      CP	R26,R24
    043BD 07B9      CPC	R27,R25
    043BE F4CC      BGE	0x43D8
    043BF 9611      ADIW	R26,1
    043C0 CFF5      RJMP	0x43B6
    043C1 9580      COM	R24
    043C2 9590      COM	R25
    043C3 9601      ADIW	R24,1
    043C4 2322      TST	R18
    043C5 F0BA      BMI	0x43DD
    043C6 0F00      LSL	R16
    043C7 1F11      ROL	R17
    043C8 1F22      ROL	R18
    043C9 17A8      CP	R26,R24
    043CA 07B9      CPC	R27,R25
    043CB F014      BLT	0x43CE
    043CC 9711      SBIW	R26,1
    043CD CFF6      RJMP	0x43C4
    043CE 2700      CLR	R16
    043CF 2711      CLR	R17
    043D0 2722      CLR	R18
    043D1 2733      CLR	R19
    043D2 9189      LD	R24,Y+
    043D3 9199      LD	R25,Y+
    043D4 012D      MOVW	R4,R26
    043D5 91B9      LD	R27,Y+
    043D6 91A9      LD	R26,Y+
    043D7 9508      RET
    043D8 2733      CLR	R19
    043D9 EF0F      LDI	R16,0xFF
    043DA 2F10      MOV	R17,R16
    043DB E72F      LDI	R18,0x7F
    043DC 2F32      MOV	R19,R18
    043DD 9189      LD	R24,Y+
    043DE 9199      LD	R25,Y+
    043DF 012D      MOVW	R4,R26
    043E0 C002      RJMP	0x43E3
pack:
    043E1 93AA      ST	-Y,R26
    043E2 93BA      ST	-Y,R27
    043E3 DFA7      RCALL	tstR16_R19
    043E4 F049      BEQ	0x43EE
    043E5 01D2      MOVW	R26,R4
    043E6 58A1      SUBI	R26,0x81
    043E7 4FBF      SBCI	R27,0xFF
    043E8 012D      MOVW	R4,R26
    043E9 2D34      MOV	R19,R4
    043EA 0F22      LSL	R18
    043EB 9536      LSR	R19
    043EC 9527      ROR	R18
    043ED 2936      OR	R19,R6
    043EE 91B9      LD	R27,Y+
    043EF 91A9      LD	R26,Y+
    043F0 9508      RET
saveFPRegs:
    043F1 924A      ST	-Y,R4
    043F2 925A      ST	-Y,R5
    043F3 926A      ST	-Y,R6
    043F4 927A      ST	-Y,R7
    043F5 928A      ST	-Y,R8
    043F6 929A      ST	-Y,R9
    043F7 92AA      ST	-Y,R10
    043F8 92BA      ST	-Y,R11
    043F9 92CA      ST	-Y,R12
    043FA 92DA      ST	-Y,R13
    043FB 92EA      ST	-Y,R14
    043FC 92FA      ST	-Y,R15
    043FD 938A      ST	-Y,R24
    043FE 939A      ST	-Y,R25
    043FF 9508      RET
restoreFPRegs:
    04400 9199      LD	R25,Y+
    04401 9189      LD	R24,Y+
    04402 90F9      LD	R15,Y+
    04403 90E9      LD	R14,Y+
    04404 90D9      LD	R13,Y+
    04405 90C9      LD	R12,Y+
    04406 90B9      LD	R11,Y+
    04407 90A9      LD	R10,Y+
    04408 9099      LD	R9,Y+
    04409 9089      LD	R8,Y+
    0440A 9079      LD	R7,Y+
    0440B 9069      LD	R6,Y+
    0440C 9059      LD	R5,Y+
    0440D 9049      LD	R4,Y+
    0440E 9508      RET
fpmule:
    0440F 940E 43F1 CALL	saveFPRegs
    04411 93AA      ST	-Y,R26
    04412 93BA      ST	-Y,R27
    04413 940E 4393 CALL	unpacku
    04415 F1E1      BEQ	0x4452
    04416 2CE6      MOV	R14,R6
    04417 2CD5      MOV	R13,R5
    04418 2CC4      MOV	R12,R4
    04419 2EB3      MOV	R11,R19
    0441A 2EA2      MOV	R10,R18
    0441B 2E91      MOV	R9,R17
    0441C 2E80      MOV	R8,R16
    0441D 8100      LD	R16,Z
    0441E 8111      LDD	R17,Z+1
    0441F 8122      LDD	R18,Z+2
    04420 8133      LDD	R19,Z+3
    04421 940E 4393 CALL	unpacku
    04423 F171      BEQ	0x4452
    04424 246E      EOR	R6,R14
    04425 0C4C      ADD	R4,R12
    04426 1C5D      ADC	R5,R13
    04427 E880      LDI	R24,0x80
    04428 1648      CP	R4,R24
    04429 0653      CPC	R5,R19
    0442A F564      BGE	0x4457
    0442B E881      LDI	R24,0x81
    0442C 1648      CP	R4,R24
    0442D EF8F      LDI	R24,0xFF
    0442E 0658      CPC	R5,R24
    0442F F16C      BLT	0x445D
    04430 9EA2      MUL	R10,R18
    04431 2DB1      MOV	R27,R1
    04432 2DA0      MOV	R26,R0
    04433 9E91      MUL	R9,R17
    04434 2D91      MOV	R25,R1
    04435 2D80      MOV	R24,R0
    04436 9EA0      MUL	R10,R16
    04437 0D80      ADD	R24,R0
    04438 1D91      ADC	R25,R1
    04439 1FA3      ADC	R26,R19
    0443A 1FB3      ADC	R27,R19
    0443B 9E82      MUL	R8,R18
    0443C 0D80      ADD	R24,R0
    0443D 1D91      ADC	R25,R1
    0443E 1FA3      ADC	R26,R19
    0443F 1FB3      ADC	R27,R19
    04440 9E92      MUL	R9,R18
    04441 0D90      ADD	R25,R0
    04442 1DA1      ADC	R26,R1
    04443 1FB3      ADC	R27,R19
    04444 9EA1      MUL	R10,R17
    04445 0D90      ADD	R25,R0
    04446 1DA1      ADC	R26,R1
    04447 1FB3      ADC	R27,R19
    04448 2F2B      MOV	R18,R27
    04449 2F1A      MOV	R17,R26
    0444A 2F09      MOV	R16,R25
    0444B 0F88      LSL	R24
    0444C 1F00      ROL	R16
    0444D 1F11      ROL	R17
    0444E 1F22      ROL	R18
    0444F 1F33      ROL	R19
    04450 940E 43AC CALL	normalize_and_pack
    04452 91B9      LD	R27,Y+
    04453 91A9      LD	R26,Y+
    04454 940E 4400 CALL	restoreFPRegs
    04456 9508      RET
    04457 EF0F      LDI	R16,0xFF
    04458 2F10      MOV	R17,R16
    04459 E72F      LDI	R18,0x7F
    0445A E78F      LDI	R24,0x7F
    0445B 2E48      MOV	R4,R24
    0445C CFF5      RJMP	0x4452
    0445D 2700      CLR	R16
    0445E 2F10      MOV	R17,R16
    0445F 2F20      MOV	R18,R16
    04460 2F30      MOV	R19,R16
    04461 CFF0      RJMP	0x4452
fpmule1:
    04462 93FA      ST	-Y,R31
    04463 93EA      ST	-Y,R30
    04464 81EA      LDD	R30,Y+2
    04465 81FB      LDD	R31,Y+3
    04466 940E 440F CALL	fpmule
    04468 91E9      LD	R30,Y+
    04469 91F9      LD	R31,Y+
    0446A 9622      ADIW	R28,2
    0446B 9508      RET
fpmule2:
    0446C 93FA      ST	-Y,R31
    0446D 93EA      ST	-Y,R30
    0446E 2FEC      MOV	R30,R28
    0446F 2FFD      MOV	R31,R29
    04470 9632      ADIW	R30,2
    04471 940E 440F CALL	fpmule
    04473 91E9      LD	R30,Y+
    04474 91F9      LD	R31,Y+
    04475 9624      ADIW	R28,4
    04476 9508      RET
fpmule1x:
    04477 93FA      ST	-Y,R31
    04478 93EA      ST	-Y,R30
    04479 81EA      LDD	R30,Y+2
    0447A 81FB      LDD	R31,Y+3
    0447B 940E 440F CALL	fpmule
    0447D 91E9      LD	R30,Y+
    0447E 91F9      LD	R31,Y+
    0447F 8339      STD	Y+1,R19
    04480 8328      ST	Y,R18
    04481 931A      ST	-Y,R17
    04482 930A      ST	-Y,R16
    04483 9508      RET
fpcmp:
    04484 940E 422A CALL	fpsub
    04486 2333      TST	R19
    04487 F03A      BMI	0x448F
    04488 940E 438B CALL	tstR16_R19
    0448A F011      BEQ	0x448D
    0448B E001      LDI	R16,1
    0448C 9508      RET
    0448D 2700      CLR	R16
    0448E 9508      RET
    0448F EF0F      LDI	R16,0xFF
    04490 9508      RET
fpcmp2:
    04491 93FA      ST	-Y,R31
    04492 93EA      ST	-Y,R30
    04493 2FEC      MOV	R30,R28
    04494 2FFD      MOV	R31,R29
    04495 9632      ADIW	R30,2
    04496 940E 4484 CALL	fpcmp
    04498 91E9      LD	R30,Y+
    04499 91F9      LD	R31,Y+
    0449A 9624      ADIW	R28,4
    0449B 2300      TST	R16
    0449C 9508      RET
_itoa:
    0449D 940E 4026 CALL	push_arg4
    0449F 940E 416B CALL	push_xgsetF0FC
    044A1 01A9      MOVW	R20,R18
    044A2 84EE      LDD	R14,Y+14
    044A3 84FF      LDD	R15,Y+15
    044A4 015A      MOVW	R10,R20
    044A5 20AA      TST	R10
    044A6 F451      BNE	0x44B1
    044A7 20BB      TST	R11
    044A8 F441      BNE	0x44B1
    044A9 E380      LDI	R24,0x30
    044AA 85EA      LDD	R30,Y+10
    044AB 85FB      LDD	R31,Y+11
    044AC 8380      ST	Z,R24
    044AD 2422      CLR	R2
    044AE 8221      STD	Z+1,R2
    044AF 018F      MOVW	R16,R30
    044B0 C053      RJMP	0x4504
    044B1 3040      CPI	R20,0
    044B2 E0E0      LDI	R30,0
    044B3 075E      CPC	R21,R30
    044B4 F46C      BGE	0x44C2
    044B5 01C7      MOVW	R24,R14
    044B6 308A      CPI	R24,0xA
    044B7 E0E0      LDI	R30,0
    044B8 079E      CPC	R25,R30
    044B9 F441      BNE	0x44C2
    044BA 24CC      CLR	R12
    044BB 94C3      INC	R12
    044BC 01C5      MOVW	R24,R10
    044BD 9580      COM	R24
    044BE 9590      COM	R25
    044BF 9601      ADIW	R24,1
    044C0 015C      MOVW	R10,R24
    044C1 C001      RJMP	0x44C3
    044C2 24CC      CLR	R12
    044C3 856A      LDD	R22,Y+10
    044C4 857B      LDD	R23,Y+11
    044C5 0197      MOVW	R18,R14
    044C6 0185      MOVW	R16,R10
    044C7 940E 4055 CALL	mod16u
    044C9 01A8      MOVW	R20,R16
    044CA E089      LDI	R24,0x9
    044CB E090      LDI	R25,0
    044CC 1780      CP	R24,R16
    044CD 0791      CPC	R25,R17
    044CE F034      BLT	0x44D5
    044CF 01CA      MOVW	R24,R20
    044D0 96C0      ADIW	R24,0x30
    044D1 01FB      MOVW	R30,R22
    044D2 9381      ST	Z+,R24
    044D3 01BF      MOVW	R22,R30
    044D4 C006      RJMP	0x44DB
    044D5 01CA      MOVW	R24,R20
    044D6 5A89      SUBI	R24,0xA9
    044D7 4F9F      SBCI	R25,0xFF
    044D8 01FB      MOVW	R30,R22
    044D9 9381      ST	Z+,R24
    044DA 01BF      MOVW	R22,R30
    044DB 0197      MOVW	R18,R14
    044DC 0185      MOVW	R16,R10
    044DD 940E 4057 CALL	div16u
    044DF 0158      MOVW	R10,R16
    044E0 20AA      TST	R10
    044E1 F719      BNE	0x44C5
    044E2 20BB      TST	R11
    044E3 F709      BNE	0x44C5
    044E4 20CC      TST	R12
    044E5 F021      BEQ	0x44EA
    044E6 E28D      LDI	R24,0x2D
    044E7 01FB      MOVW	R30,R22
    044E8 9381      ST	Z+,R24
    044E9 01BF      MOVW	R22,R30
    044EA 012B      MOVW	R4,R22
    044EB 5061      SUBI	R22,1
    044EC 4070      SBCI	R23,0
    044ED 2422      CLR	R2
    044EE 01F2      MOVW	R30,R4
    044EF 8220      ST	Z,R2
    044F0 84AA      LDD	R10,Y+10
    044F1 84BB      LDD	R11,Y+11
    044F2 C00C      RJMP	0x44FF
    044F3 01F5      MOVW	R30,R10
    044F4 80C0      LD	R12,Z
    044F5 01FB      MOVW	R30,R22
    044F6 8020      LD	R2,Z
    044F7 01F5      MOVW	R30,R10
    044F8 9221      ST	Z+,R2
    044F9 015F      MOVW	R10,R30
    044FA 011B      MOVW	R2,R22
    044FB 5061      SUBI	R22,1
    044FC 4070      SBCI	R23,0
    044FD 01F1      MOVW	R30,R2
    044FE 82C0      ST	Z,R12
    044FF 16A6      CP	R10,R22
    04500 06B7      CPC	R11,R23
    04501 F388      BCS	0x44F3
    04502 850A      LDD	R16,Y+10
    04503 851B      LDD	R17,Y+11
    04504 940E 4160 CALL	pop_xgsetF0FC
    04506 9624      ADIW	R28,4
    04507 9508      RET
_ltoa:
    04508 940E 4026 CALL	push_arg4
    0450A 940E 416B CALL	push_xgsetF0FC
    0450C 9724      SBIW	R28,4
    0450D 8828      LDD	R2,Y+16
    0450E 8839      LDD	R3,Y+17
    0450F 884A      LDD	R4,Y+18
    04510 885B      LDD	R5,Y+19
    04511 8228      ST	Y,R2
    04512 8239      STD	Y+1,R3
    04513 824A      STD	Y+2,R4
    04514 825B      STD	Y+3,R5
    04515 8828      LDD	R2,Y+16
    04516 8839      LDD	R3,Y+17
    04517 884A      LDD	R4,Y+18
    04518 885B      LDD	R5,Y+19
    04519 9488      BCLR	0
    0451A 2022      TST	R2
    0451B 0432      CPC	R3,R2
    0451C 0442      CPC	R4,R2
    0451D 0452      CPC	R5,R2
    0451E F441      BNE	0x4527
    0451F E380      LDI	R24,0x30
    04520 85EE      LDD	R30,Y+14
    04521 85FF      LDD	R31,Y+15
    04522 8380      ST	Z,R24
    04523 2422      CLR	R2
    04524 8221      STD	Z+1,R2
    04525 018F      MOVW	R16,R30
    04526 C094      RJMP	0x45BB
    04527 E040      LDI	R20,0
    04528 E050      LDI	R21,0
    04529 E060      LDI	R22,0
    0452A E070      LDI	R23,0
    0452B 8828      LDD	R2,Y+16
    0452C 8839      LDD	R3,Y+17
    0452D 884A      LDD	R4,Y+18
    0452E 885B      LDD	R5,Y+19
    0452F 1624      CP	R2,R20
    04530 0635      CPC	R3,R21
    04531 0646      CPC	R4,R22
    04532 0657      CPC	R5,R23
    04533 F4EC      BGE	0x4551
    04534 898C      LDD	R24,Y+20
    04535 899D      LDD	R25,Y+21
    04536 308A      CPI	R24,0xA
    04537 E0A0      LDI	R26,0
    04538 079A      CPC	R25,R26
    04539 F4B9      BNE	0x4551
    0453A 24AA      CLR	R10
    0453B 94A3      INC	R10
    0453C E041      LDI	R20,1
    0453D E050      LDI	R21,0
    0453E E060      LDI	R22,0
    0453F E070      LDI	R23,0
    04540 8028      LD	R2,Y
    04541 8039      LDD	R3,Y+1
    04542 804A      LDD	R4,Y+2
    04543 805B      LDD	R5,Y+3
    04544 9420      COM	R2
    04545 9430      COM	R3
    04546 9440      COM	R4
    04547 9450      COM	R5
    04548 0E24      ADD	R2,R20
    04549 1E35      ADC	R3,R21
    0454A 1E46      ADC	R4,R22
    0454B 1E57      ADC	R5,R23
    0454C 8228      ST	Y,R2
    0454D 8239      STD	Y+1,R3
    0454E 824A      STD	Y+2,R4
    0454F 825B      STD	Y+3,R5
    04550 C001      RJMP	0x4552
    04551 24AA      CLR	R10
    04552 84CE      LDD	R12,Y+14
    04553 84DF      LDD	R13,Y+15
    04554 882C      LDD	R2,Y+20
    04555 883D      LDD	R3,Y+21
    04556 2444      CLR	R4
    04557 FC37      SBRC	R3,7
    04558 9440      COM	R4
    04559 2455      CLR	R5
    0455A FC47      SBRC	R4,7
    0455B 9450      COM	R5
    0455C 8108      LD	R16,Y
    0455D 8119      LDD	R17,Y+1
    0455E 812A      LDD	R18,Y+2
    0455F 813B      LDD	R19,Y+3
    04560 925A      ST	-Y,R5
    04561 924A      ST	-Y,R4
    04562 923A      ST	-Y,R3
    04563 922A      ST	-Y,R2
    04564 940E 4073 CALL	mod32u
    04566 0178      MOVW	R14,R16
    04567 E089      LDI	R24,0x9
    04568 E090      LDI	R25,0
    04569 1780      CP	R24,R16
    0456A 0791      CPC	R25,R17
    0456B F034      BLT	0x4572
    0456C 01C7      MOVW	R24,R14
    0456D 96C0      ADIW	R24,0x30
    0456E 01F6      MOVW	R30,R12
    0456F 9381      ST	Z+,R24
    04570 016F      MOVW	R12,R30
    04571 C006      RJMP	0x4578
    04572 01C7      MOVW	R24,R14
    04573 5A89      SUBI	R24,0xA9
    04574 4F9F      SBCI	R25,0xFF
    04575 01F6      MOVW	R30,R12
    04576 9381      ST	Z+,R24
    04577 016F      MOVW	R12,R30
    04578 882C      LDD	R2,Y+20
    04579 883D      LDD	R3,Y+21
    0457A 2444      CLR	R4
    0457B FC37      SBRC	R3,7
    0457C 9440      COM	R4
    0457D 2455      CLR	R5
    0457E FC47      SBRC	R4,7
    0457F 9450      COM	R5
    04580 8108      LD	R16,Y
    04581 8119      LDD	R17,Y+1
    04582 812A      LDD	R18,Y+2
    04583 813B      LDD	R19,Y+3
    04584 925A      ST	-Y,R5
    04585 924A      ST	-Y,R4
    04586 923A      ST	-Y,R3
    04587 922A      ST	-Y,R2
    04588 940E 4071 CALL	div32u
    0458A 8308      ST	Y,R16
    0458B 8319      STD	Y+1,R17
    0458C 832A      STD	Y+2,R18
    0458D 833B      STD	Y+3,R19
    0458E 8028      LD	R2,Y
    0458F 8039      LDD	R3,Y+1
    04590 804A      LDD	R4,Y+2
    04591 805B      LDD	R5,Y+3
    04592 9488      BCLR	0
    04593 2022      TST	R2
    04594 0432      CPC	R3,R2
    04595 0442      CPC	R4,R2
    04596 0452      CPC	R5,R2
    04597 F009      BEQ	0x4599
    04598 CFBB      RJMP	0x4554
    04599 20AA      TST	R10
    0459A F021      BEQ	0x459F
    0459B E28D      LDI	R24,0x2D
    0459C 01F6      MOVW	R30,R12
    0459D 9381      ST	Z+,R24
    0459E 016F      MOVW	R12,R30
    0459F 0126      MOVW	R4,R12
    045A0 01C2      MOVW	R24,R4
    045A1 9701      SBIW	R24,1
    045A2 016C      MOVW	R12,R24
    045A3 2422      CLR	R2
    045A4 01F2      MOVW	R30,R4
    045A5 8220      ST	Z,R2
    045A6 84EE      LDD	R14,Y+14
    045A7 84FF      LDD	R15,Y+15
    045A8 C00D      RJMP	0x45B6
    045A9 01F7      MOVW	R30,R14
    045AA 80A0      LD	R10,Z
    045AB 01F6      MOVW	R30,R12
    045AC 8020      LD	R2,Z
    045AD 01F7      MOVW	R30,R14
    045AE 9221      ST	Z+,R2
    045AF 017F      MOVW	R14,R30
    045B0 0116      MOVW	R2,R12
    045B1 01C1      MOVW	R24,R2
    045B2 9701      SBIW	R24,1
    045B3 016C      MOVW	R12,R24
    045B4 01F1      MOVW	R30,R2
    045B5 82A0      ST	Z,R10
    045B6 14EC      CP	R14,R12
    045B7 04FD      CPC	R15,R13
    045B8 F380      BCS	0x45A9
    045B9 850E      LDD	R16,Y+14
    045BA 851F      LDD	R17,Y+15
    045BB 9624      ADIW	R28,4
    045BC 940E 4160 CALL	pop_xgsetF0FC
    045BE 9624      ADIW	R28,4
    045BF 9508      RET
_ftoa:
    045C0 940E 4026 CALL	push_arg4
    045C2 940E 416B CALL	push_xgsetF0FC
    045C4 9764      SBIW	R28,0x14
    045C5 A0CA      LDD	R12,Y+34
    045C6 A0DB      LDD	R13,Y+35
    045C7 2422      CLR	R2
    045C8 2433      CLR	R3
    045C9 01F6      MOVW	R30,R12
    045CA 8231      STD	Z+1,R3
    045CB 8220      ST	Z,R2
    045CC 8C2E      LDD	R2,Y+30
    045CD 8C3F      LDD	R3,Y+31
    045CE A048      LDD	R4,Y+32
    045CF A059      LDD	R5,Y+33
    045D0 EC0C      LDI	R16,0xCC
    045D1 E010      LDI	R17,0
    045D2 940E 40F3 CALL	elpm32
    045D4 933A      ST	-Y,R19
    045D5 932A      ST	-Y,R18
    045D6 931A      ST	-Y,R17
    045D7 930A      ST	-Y,R16
    045D8 0181      MOVW	R16,R2
    045D9 0192      MOVW	R18,R4
    045DA 940E 4491 CALL	fpcmp2
    045DC F479      BNE	0x45EC
    045DD E380      LDI	R24,0x30
    045DE 9380 07F4 STS	config+20,R24
    045E0 E28E      LDI	R24,0x2E
    045E1 9380 07F5 STS	config+21,R24
    045E3 E380      LDI	R24,0x30
    045E4 9380 07F6 STS	config+22,R24
    045E6 2422      CLR	R2
    045E7 9220 07F7 STS	config+23,R2
    045E9 EF04      LDI	R16,0xF4
    045EA E017      LDI	R17,7
    045EB C15E      RJMP	0x474A
    045EC 8C2E      LDD	R2,Y+30
    045ED 8C3F      LDD	R3,Y+31
    045EE A048      LDD	R4,Y+32
    045EF A059      LDD	R5,Y+33
    045F0 8628      STD	Y+8,R2
    045F1 8639      STD	Y+9,R3
    045F2 864A      STD	Y+10,R4
    045F3 865B      STD	Y+11,R5
    045F4 E187      LDI	R24,0x17
    045F5 E090      LDI	R25,0
    045F6 8508      LDD	R16,Y+8
    045F7 8519      LDD	R17,Y+9
    045F8 852A      LDD	R18,Y+10
    045F9 853B      LDD	R19,Y+11
    045FA 938A      ST	-Y,R24
    045FB 940E 402B CALL	asr32
    045FD 2F80      MOV	R24,R16
    045FE 2799      CLR	R25
    045FF 578F      SUBI	R24,0x7F
    04600 4090      SBCI	R25,0
    04601 015C      MOVW	R10,R24
    04602 EF4F      LDI	R20,0xFF
    04603 EF5F      LDI	R21,0xFF
    04604 EF6F      LDI	R22,0xFF
    04605 E070      LDI	R23,0
    04606 8428      LDD	R2,Y+8
    04607 8439      LDD	R3,Y+9
    04608 844A      LDD	R4,Y+10
    04609 845B      LDD	R5,Y+11
    0460A 2224      AND	R2,R20
    0460B 2235      AND	R3,R21
    0460C 2246      AND	R4,R22
    0460D 2257      AND	R5,R23
    0460E 93EF      PUSH	R30
    0460F 2DE4      MOV	R30,R4
    04610 68E0      ORI	R30,0x80
    04611 2E4E      MOV	R4,R30
    04612 91EF      POP	R30
    04613 8A28      STD	Y+16,R2
    04614 8A39      STD	Y+17,R3
    04615 8A4A      STD	Y+18,R4
    04616 8A5B      STD	Y+19,R5
    04617 E080      LDI	R24,0
    04618 838C      STD	Y+4,R24
    04619 838D      STD	Y+5,R24
    0461A 838E      STD	Y+6,R24
    0461B 838F      STD	Y+7,R24
    0461C E080      LDI	R24,0
    0461D 878C      STD	Y+12,R24
    0461E 878D      STD	Y+13,R24
    0461F 878E      STD	Y+14,R24
    04620 878F      STD	Y+15,R24
    04621 01C5      MOVW	R24,R10
    04622 318F      CPI	R24,0x1F
    04623 E0E0      LDI	R30,0
    04624 079E      CPC	R25,R30
    04625 F044      BLT	0x462E
    04626 EF8E      LDI	R24,0xFE
    04627 EF9F      LDI	R25,0xFF
    04628 01F6      MOVW	R30,R12
    04629 8391      STD	Z+1,R25
    0462A 8380      ST	Z,R24
    0462B 2700      CLR	R16
    0462C 2711      CLR	R17
    0462D C11C      RJMP	0x474A
    0462E 01C5      MOVW	R24,R10
    0462F 3E89      CPI	R24,0xE9
    04630 EFEF      LDI	R30,0xFF
    04631 079E      CPC	R25,R30
    04632 F444      BGE	0x463B
    04633 EF8F      LDI	R24,0xFF
    04634 EF9F      LDI	R25,0xFF
    04635 01F6      MOVW	R30,R12
    04636 8391      STD	Z+1,R25
    04637 8380      ST	Z,R24
    04638 2700      CLR	R16
    04639 2711      CLR	R17
    0463A C10F      RJMP	0x474A
    0463B 01C5      MOVW	R24,R10
    0463C 3187      CPI	R24,0x17
    0463D E0A0      LDI	R26,0
    0463E 079A      CPC	R25,R26
    0463F F06C      BLT	0x464D
    04640 9747      SBIW	R24,0x17
    04641 8908      LDD	R16,Y+16
    04642 8919      LDD	R17,Y+17
    04643 892A      LDD	R18,Y+18
    04644 893B      LDD	R19,Y+19
    04645 938A      ST	-Y,R24
    04646 940E 41ED CALL	lsl32
    04648 870C      STD	Y+12,R16
    04649 871D      STD	Y+13,R17
    0464A 872E      STD	Y+14,R18
    0464B 873F      STD	Y+15,R19
    0464C C045      RJMP	0x4692
    0464D 01C5      MOVW	R24,R10
    0464E 3080      CPI	R24,0
    0464F E0A0      LDI	R26,0
    04650 079A      CPC	R25,R26
    04651 F13C      BLT	0x4679
    04652 E187      LDI	R24,0x17
    04653 E090      LDI	R25,0
    04654 198A      SUB	R24,R10
    04655 099B      SBC	R25,R11
    04656 8908      LDD	R16,Y+16
    04657 8919      LDD	R17,Y+17
    04658 892A      LDD	R18,Y+18
    04659 893B      LDD	R19,Y+19
    0465A 938A      ST	-Y,R24
    0465B 940E 402B CALL	asr32
    0465D 870C      STD	Y+12,R16
    0465E 871D      STD	Y+13,R17
    0465F 872E      STD	Y+14,R18
    04660 873F      STD	Y+15,R19
    04661 01C5      MOVW	R24,R10
    04662 9601      ADIW	R24,1
    04663 8908      LDD	R16,Y+16
    04664 8919      LDD	R17,Y+17
    04665 892A      LDD	R18,Y+18
    04666 893B      LDD	R19,Y+19
    04667 938A      ST	-Y,R24
    04668 940E 41ED CALL	lsl32
    0466A 0118      MOVW	R2,R16
    0466B 0129      MOVW	R4,R18
    0466C EF4F      LDI	R20,0xFF
    0466D EF5F      LDI	R21,0xFF
    0466E EF6F      LDI	R22,0xFF
    0466F E070      LDI	R23,0
    04670 2224      AND	R2,R20
    04671 2235      AND	R3,R21
    04672 2246      AND	R4,R22
    04673 2257      AND	R5,R23
    04674 822C      STD	Y+4,R2
    04675 823D      STD	Y+5,R3
    04676 824E      STD	Y+6,R4
    04677 825F      STD	Y+7,R5
    04678 C019      RJMP	0x4692
    04679 EF4F      LDI	R20,0xFF
    0467A EF5F      LDI	R21,0xFF
    0467B EF6F      LDI	R22,0xFF
    0467C E070      LDI	R23,0
    0467D 8908      LDD	R16,Y+16
    0467E 8919      LDD	R17,Y+17
    0467F 892A      LDD	R18,Y+18
    04680 893B      LDD	R19,Y+19
    04681 2304      AND	R16,R20
    04682 2315      AND	R17,R21
    04683 2326      AND	R18,R22
    04684 2337      AND	R19,R23
    04685 01C5      MOVW	R24,R10
    04686 9601      ADIW	R24,1
    04687 9580      COM	R24
    04688 9590      COM	R25
    04689 5F8F      SUBI	R24,0xFF
    0468A 4F9F      SBCI	R25,0xFF
    0468B 938A      ST	-Y,R24
    0468C 940E 402B CALL	asr32
    0468E 830C      STD	Y+4,R16
    0468F 831D      STD	Y+5,R17
    04690 832E      STD	Y+6,R18
    04691 833F      STD	Y+7,R19
    04692 EF84      LDI	R24,0xF4
    04693 E097      LDI	R25,7
    04694 015C      MOVW	R10,R24
    04695 E040      LDI	R20,0
    04696 E050      LDI	R21,0
    04697 E060      LDI	R22,0
    04698 E070      LDI	R23,0
    04699 8428      LDD	R2,Y+8
    0469A 8439      LDD	R3,Y+9
    0469B 844A      LDD	R4,Y+10
    0469C 845B      LDD	R5,Y+11
    0469D 1624      CP	R2,R20
    0469E 0635      CPC	R3,R21
    0469F 0646      CPC	R4,R22
    046A0 0657      CPC	R5,R23
    046A1 F424      BGE	0x46A6
    046A2 E28D      LDI	R24,0x2D
    046A3 01F5      MOVW	R30,R10
    046A4 9381      ST	Z+,R24
    046A5 015F      MOVW	R10,R30
    046A6 842C      LDD	R2,Y+12
    046A7 843D      LDD	R3,Y+13
    046A8 844E      LDD	R4,Y+14
    046A9 845F      LDD	R5,Y+15
    046AA 9488      BCLR	0
    046AB 2022      TST	R2
    046AC 0432      CPC	R3,R2
    046AD 0442      CPC	R4,R2
    046AE 0452      CPC	R5,R2
    046AF F429      BNE	0x46B5
    046B0 E380      LDI	R24,0x30
    046B1 01F5      MOVW	R30,R10
    046B2 9381      ST	Z+,R24
    046B3 015F      MOVW	R10,R30
    046B4 C016      RJMP	0x46CB
    046B5 E08A      LDI	R24,0xA
    046B6 E090      LDI	R25,0
    046B7 839B      STD	Y+3,R25
    046B8 838A      STD	Y+2,R24
    046B9 842C      LDD	R2,Y+12
    046BA 843D      LDD	R3,Y+13
    046BB 844E      LDD	R4,Y+14
    046BC 845F      LDD	R5,Y+15
    046BD 8248      ST	Y,R4
    046BE 8259      STD	Y+1,R5
    046BF 0191      MOVW	R18,R2
    046C0 0185      MOVW	R16,R10
    046C1 940E 4508 CALL	_ltoa
    046C3 C003      RJMP	0x46C7
    046C4 01C5      MOVW	R24,R10
    046C5 9601      ADIW	R24,1
    046C6 015C      MOVW	R10,R24
    046C7 01F5      MOVW	R30,R10
    046C8 8020      LD	R2,Z
    046C9 2022      TST	R2
    046CA F7C9      BNE	0x46C4
    046CB E28E      LDI	R24,0x2E
    046CC 01F5      MOVW	R30,R10
    046CD 9381      ST	Z+,R24
    046CE 015F      MOVW	R10,R30
    046CF 802C      LDD	R2,Y+4
    046D0 803D      LDD	R3,Y+5
    046D1 804E      LDD	R4,Y+6
    046D2 805F      LDD	R5,Y+7
    046D3 9488      BCLR	0
    046D4 2022      TST	R2
    046D5 0432      CPC	R3,R2
    046D6 0442      CPC	R4,R2
    046D7 0452      CPC	R5,R2
    046D8 F421      BNE	0x46DD
    046D9 E380      LDI	R24,0x30
    046DA 9381      ST	Z+,R24
    046DB 015F      MOVW	R10,R30
    046DC C068      RJMP	0x4745
    046DD EF84      LDI	R24,0xF4
    046DE E097      LDI	R25,7
    046DF 0115      MOVW	R2,R10
    046E0 1A28      SUB	R2,R24
    046E1 0A39      SBC	R3,R25
    046E2 E08F      LDI	R24,0xF
    046E3 E090      LDI	R25,0
    046E4 1982      SUB	R24,R2
    046E5 0993      SBC	R25,R3
    046E6 9701      SBIW	R24,1
    046E7 2EC8      MOV	R12,R24
    046E8 E087      LDI	R24,7
    046E9 158C      CP	R24,R12
    046EA F408      BCC	0x46EC
    046EB 2EC8      MOV	R12,R24
    046EC 24EE      CLR	R14
    046ED C042      RJMP	0x4730
    046EE E083      LDI	R24,3
    046EF E090      LDI	R25,0
    046F0 810C      LDD	R16,Y+4
    046F1 811D      LDD	R17,Y+5
    046F2 812E      LDD	R18,Y+6
    046F3 813F      LDD	R19,Y+7
    046F4 938A      ST	-Y,R24
    046F5 940E 41ED CALL	lsl32
    046F7 0118      MOVW	R2,R16
    046F8 0129      MOVW	R4,R18
    046F9 806C      LDD	R6,Y+4
    046FA 807D      LDD	R7,Y+5
    046FB 808E      LDD	R8,Y+6
    046FC 809F      LDD	R9,Y+7
    046FD 0C66      LSL	R6
    046FE 1C77      ROL	R7
    046FF 1C88      ROL	R8
    04700 1C99      ROL	R9
    04701 0C26      ADD	R2,R6
    04702 1C37      ADC	R3,R7
    04703 1C48      ADC	R4,R8
    04704 1C59      ADC	R5,R9
    04705 822C      STD	Y+4,R2
    04706 823D      STD	Y+5,R3
    04707 824E      STD	Y+6,R4
    04708 825F      STD	Y+7,R5
    04709 E188      LDI	R24,0x18
    0470A E090      LDI	R25,0
    0470B 810C      LDD	R16,Y+4
    0470C 811D      LDD	R17,Y+5
    0470D 812E      LDD	R18,Y+6
    0470E 813F      LDD	R19,Y+7
    0470F 938A      ST	-Y,R24
    04710 940E 402B CALL	asr32
    04712 0118      MOVW	R2,R16
    04713 0129      MOVW	R4,R18
    04714 E340      LDI	R20,0x30
    04715 E050      LDI	R21,0
    04716 E060      LDI	R22,0
    04717 E070      LDI	R23,0
    04718 0E24      ADD	R2,R20
    04719 1E35      ADC	R3,R21
    0471A 1E46      ADC	R4,R22
    0471B 1E57      ADC	R5,R23
    0471C 01F5      MOVW	R30,R10
    0471D 9221      ST	Z+,R2
    0471E 015F      MOVW	R10,R30
    0471F EF4F      LDI	R20,0xFF
    04720 EF5F      LDI	R21,0xFF
    04721 EF6F      LDI	R22,0xFF
    04722 E070      LDI	R23,0
    04723 802C      LDD	R2,Y+4
    04724 803D      LDD	R3,Y+5
    04725 804E      LDD	R4,Y+6
    04726 805F      LDD	R5,Y+7
    04727 2224      AND	R2,R20
    04728 2235      AND	R3,R21
    04729 2246      AND	R4,R22
    0472A 2257      AND	R5,R23
    0472B 822C      STD	Y+4,R2
    0472C 823D      STD	Y+5,R3
    0472D 824E      STD	Y+6,R4
    0472E 825F      STD	Y+7,R5
    0472F 94E3      INC	R14
    04730 14EC      CP	R14,R12
    04731 F408      BCC	0x4733
    04732 CFBB      RJMP	0x46EE
    04733 01C5      MOVW	R24,R10
    04734 9701      SBIW	R24,1
    04735 015C      MOVW	R10,R24
    04736 C003      RJMP	0x473A
    04737 01C5      MOVW	R24,R10
    04738 9701      SBIW	R24,1
    04739 015C      MOVW	R10,R24
    0473A 01F5      MOVW	R30,R10
    0473B 8180      LD	R24,Z
    0473C 3380      CPI	R24,0x30
    0473D F421      BNE	0x4742
    0473E 9731      SBIW	R30,1
    0473F 8180      LD	R24,Z
    04740 328E      CPI	R24,0x2E
    04741 F7A9      BNE	0x4737
    04742 01C5      MOVW	R24,R10
    04743 9601      ADIW	R24,1
    04744 015C      MOVW	R10,R24
    04745 2422      CLR	R2
    04746 01F5      MOVW	R30,R10
    04747 8220      ST	Z,R2
    04748 EF04      LDI	R16,0xF4
    04749 E017      LDI	R17,7
    0474A 9664      ADIW	R28,0x14
    0474B 940E 4160 CALL	pop_xgsetF0FC
    0474D 9624      ADIW	R28,4
    0474E 9508      RET
