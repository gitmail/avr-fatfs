Interrupt Vectors
    00000 940C 025F JMP	__start|__text_start
    0003C 940C 35C3 JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    0025F EFCF      LDI	R28,0xFF
    00260 E1D0      LDI	R29,0x10
    00261 BFCD      OUT	0x3D,R28
    00262 BFDE      OUT	0x3E,R29
    00263 51CE      SUBI	R28,0x1E
    00264 40D0      SBCI	R29,0
    00265 EA0A      LDI	R16,0xAA
    00266 8308      ST	Y,R16
    00267 2400      CLR	R0
    00268 EEEE      LDI	R30,0xEE
    00269 E0F4      LDI	R31,4
    0026A E017      LDI	R17,7
    0026B 3DE2      CPI	R30,0xD2
    0026C 07F1      CPC	R31,R17
    0026D F011      BEQ	0x0270
    0026E 9201      ST	Z+,R0
    0026F CFFB      RJMP	0x026B
    00270 8300      ST	Z,R16
    00271 EDE0      LDI	R30,0xD0
    00272 E0F0      LDI	R31,0
    00273 E0A0      LDI	R26,0
    00274 E0B1      LDI	R27,1
    00275 E014      LDI	R17,4
    00276 E000      LDI	R16,0
    00277 BF0B      OUT	0x3B,R16
    00278 3BEE      CPI	R30,0xBE
    00279 07F1      CPC	R31,R17
    0027A F021      BEQ	0x027F
    0027B 95C8      LPM
    0027C 9631      ADIW	R30,1
    0027D 920D      ST	X+,R0
    0027E CFF9      RJMP	0x0278
    0027F 940E 2440 CALL	_main
_exit:
    00281 CFFF      RJMP	_exit
_disk_initialize:
  state                --> R20
  drv                  --> R10
    00282 92AA      ST	-Y,R10
    00283 934A      ST	-Y,R20
    00284 2EA0      MOV	R10,R16
FILE: D:\LQD\software\master\software_src\diskio.c
(0001) 
(0002) 
(0003) /*-----------------------------------------------------------------------*/
(0004) /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
(0005) /*-----------------------------------------------------------------------*/
(0006) /* This is a stub disk I/O module that acts as front end of the existing */
(0007) /* disk I/O modules and attach it to FatFs module with common interface. */
(0008) /*-----------------------------------------------------------------------*/
(0009) 
(0010) #include "diskio.h"
(0011) #include "sd.h"
(0012) 
(0013) 
(0014) /*-----------------------------------------------------------------------*/
(0015) /* Correspondence between physical drive number and physical drive.      */
(0016) /* Note that Tiny-FatFs supports only single drive and always            */
(0017)                                       
(0018) 
(0019) ////////////////////////////
(0020) /*
(0021)    struct tm {
(0022)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0023)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0024) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0025) 	int tm_mday;  // 日 day of the month, 1 to 31
(0026) 	int tm_mon;   // 月 months since January, 0 to 11
(0027) 	int tm_year;  // 年 years since 1900
(0028) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0029) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0030)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0031)  	};
(0032) */
(0033) /*-----------------------------------------------------------------------*/
(0034) /* Inidialize a Drive                                                    */
(0035) 
(0036) DSTATUS disk_initialize ( 
(0037) BYTE drv				/* Physical drive nmuber (0..) */
(0038) )
(0039) {
(0040)     unsigned char state;
(0041) 
(0042)     if(drv)
    00285 20AA      TST	R10
    00286 F011      BEQ	0x0289
(0043)     {
(0044)         return STA_NOINIT;  //仅支持磁盘0的操作
    00287 E001      LDI	R16,1
    00288 C00C      RJMP	0x0295
(0045)     }
(0046) 
(0047)     state = SD_Init();
    00289 940E 2B54 CALL	_SD_Init
    0028B 2F40      MOV	R20,R16
(0048)     if(state == STA_NODISK)
    0028C 3002      CPI	R16,2
    0028D F411      BNE	0x0290
(0049)     {
(0050)         return STA_NODISK;
    0028E E002      LDI	R16,2
    0028F C005      RJMP	0x0295
(0051)     }
(0052)     else if(state != 0)
    00290 2344      TST	R20
    00291 F011      BEQ	0x0294
(0053)     {
(0054)         return STA_NOINIT;  //其他错误：初始化失败
    00292 E001      LDI	R16,1
    00293 C001      RJMP	0x0295
(0055)     }
(0056)     else
(0057)     {
(0058)         return 0;           //初始化成功
    00294 2700      CLR	R16
    00295 9149      LD	R20,Y+
    00296 90A9      LD	R10,Y+
    00297 9508      RET
(0059)     }
(0060) }
(0061) 
(0062) 
(0063) 
(0064) /*-----------------------------------------------------------------------*/
(0065) /* Return Disk Status                                                    */
(0066) 
(0067) DSTATUS disk_status (
(0068) 	BYTE drv		/* Physical drive nmuber (0..) */
(0069) )
(0070) {
(0071)     if(drv)
_disk_status:
  drv                  --> R16
    00298 2300      TST	R16
    00299 F011      BEQ	0x029C
(0072)     {
(0073)         return STA_NOINIT;  //仅支持磁盘0操作
    0029A E001      LDI	R16,1
    0029B C001      RJMP	0x029D
(0074)     }
(0075)     return 0;
    0029C 2700      CLR	R16
    0029D 9508      RET
_disk_read:
  res                  --> R10
  count                --> R20
  sector               --> Y,+10
  buff                 --> R12
  drv                  --> R14
    0029E 940E 3F6F CALL	push_xgset30FC
    002A0 0169      MOVW	R12,R18
    002A1 2EE0      MOV	R14,R16
    002A2 9722      SBIW	R28,2
    002A3 854E      LDD	R20,Y+14
(0076) }
(0077) 
(0078) 
(0079) 
(0080) /*-----------------------------------------------------------------------*/
(0081) /* Read Sector(s)                                                        */
(0082) 
(0083) DRESULT disk_read (
(0084) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0085) 	BYTE *buff,		/* Data buffer to store read data */
(0086) 	DWORD sector,	/* Sector address (LBA) */
(0087) 	BYTE count		/* Number of sectors to read (1..255) */
(0088) )
(0089) {
(0090) 	unsigned char res=0;
    002A4 24AA      CLR	R10
(0091)     if (drv || !count)
    002A5 20EE      TST	R14
    002A6 F411      BNE	0x02A9
    002A7 2344      TST	R20
    002A8 F411      BNE	0x02AB
(0092)     {    
(0093)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002A9 E004      LDI	R16,4
    002AA C010      RJMP	0x02BB
(0094)     }
(0095) 
(0096)     if(count==1)            //1个sector的读操作      
    002AB 3041      CPI	R20,1
    002AC F449      BNE	0x02B6
(0097)     {                                                
(0098)         res = SD_Read_Sector(sector, buff);      
    002AD 82D9      STD	Y+1,R13
    002AE 82C8      ST	Y,R12
    002AF 850A      LDD	R16,Y+10
    002B0 851B      LDD	R17,Y+11
    002B1 852C      LDD	R18,Y+12
    002B2 853D      LDD	R19,Y+13
    002B3 940E 2C3A CALL	_SD_Read_Sector
    002B5 2EA0      MOV	R10,R16
(0099)     }                                                                                                 
(0100) 
(0101)     //处理返回值，将SD_driver.c的返回值转成ff.c的返回值
(0102)     if(res == 0x00)
    002B6 20AA      TST	R10
    002B7 F411      BNE	0x02BA
(0103)     {
(0104)         return RES_OK;
    002B8 2700      CLR	R16
    002B9 C001      RJMP	0x02BB
(0105)     }
(0106)     else
(0107)     {
(0108)         return RES_ERROR;
    002BA E001      LDI	R16,1
    002BB 9622      ADIW	R28,2
    002BC 940C 3F59 JMP	pop_xgset30FC
_disk_write:
  count                --> R12
  sector               --> Y,+8
  buff                 --> R10
  drv                  --> R14
    002BE 940E 3F71 CALL	push_xgset00FC
    002C0 0159      MOVW	R10,R18
    002C1 2EE0      MOV	R14,R16
    002C2 9722      SBIW	R28,2
    002C3 84CC      LDD	R12,Y+12
(0109)     }
(0110) }
(0111) 
(0112) 
(0113) 
(0114) /*-----------------------------------------------------------------------*/
(0115) /* Write Sector(s)                                                       */
(0116) 
(0117) #if _READONLY == 0
(0118) DRESULT disk_write (
(0119) 	BYTE drv,			/* Physical drive nmuber (0..) */
(0120) 	BYTE *buff,	        /* Data to be written */
(0121) 	DWORD sector,		/* Sector address (LBA) */
(0122) 	BYTE count			/* Number of sectors to write (1..255) */
(0123) )
(0124) {
(0125)     if (drv || !count)
    002C4 20EE      TST	R14
    002C5 F411      BNE	0x02C8
    002C6 20CC      TST	R12
    002C7 F411      BNE	0x02CA
(0126)     {    
(0127)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002C8 E004      LDI	R16,4
    002C9 C009      RJMP	0x02D3
(0128)     }   
(0129)    // 读写操作
(0130)     SD_Write_Sector(sector,buff);
    002CA 82B9      STD	Y+1,R11
    002CB 82A8      ST	Y,R10
    002CC 8508      LDD	R16,Y+8
    002CD 8519      LDD	R17,Y+9
    002CE 852A      LDD	R18,Y+10
    002CF 853B      LDD	R19,Y+11
    002D0 940E 2BB4 CALL	_SD_Write_Sector
(0131) 	  
(0132)     return RES_OK;
    002D2 2700      CLR	R16
    002D3 9622      ADIW	R28,2
    002D4 940C 3F52 JMP	pop_xgset00FC
_disk_ioctl:
  buff                 --> Y,+4
  ctrl                 --> Y,+2
  drv                  --> Y,+0
    002D6 940E 3E28 CALL	push_arg4
(0133) }
(0134) #endif /* _READONLY */
(0135) 
(0136) 
(0137) 
(0138) /*-----------------------------------------------------------------------*/
(0139) /* Miscellaneous Functions                                               */
(0140) DRESULT disk_ioctl (
(0141) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0142) 	BYTE ctrl,		/* Control code */
(0143) 	void *buff		/* Buffer to send/receive control data */
(0144) )
(0145) {
(0146)  	drv=drv;
(0147) 	ctrl=ctrl;
(0148) 	buff=buff;
(0149) 	return 0;
    002D8 2700      CLR	R16
    002D9 9624      ADIW	R28,4
    002DA 9508      RET
(0150) }
(0151) DWORD get_fattime (void)
(0152) {
(0153) 
(0154)   return 1950466005;
_get_fattime:
    002DB ED05      LDI	R16,0xD5
    002DC EB1F      LDI	R17,0xBF
    002DD E421      LDI	R18,0x41
    002DE E734      LDI	R19,0x74
    002DF 9508      RET
ff.c:mem_cpy:
  s                    --> R12
  d                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    002E0 940E 3F9A CALL	push_xgset303C
    002E2 814E      LDD	R20,Y+6
    002E3 815F      LDD	R21,Y+7
FILE: D:\LQD\software\master\software_src\ff.c
(0001) /*----------------------------------------------------------------------------/
(0002) /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
(0003) /-----------------------------------------------------------------------------/
(0004) / FatFs module is a generic FAT file system module for small embedded systems.
(0005) / This is a free software that opened for education, research and commercial
(0006) / developments under license policy of following terms.
(0007) /
(0008) /  Copyright (C) 2011, ChaN, all right reserved.
(0009) /
(0010) / * The FatFs module is a free software and there is NO WARRANTY.
(0011) / * No restriction on use. You can use, modify and redistribute it for
(0012) /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
(0013) / * Redistributions of source code must retain the above copyright notice.
(0014) /
(0015) /-----------------------------------------------------------------------------/
(0016) / Feb 26,'06 R0.00  Prototype.
(0017) /
(0018) / Apr 29,'06 R0.01  First stable version.
(0019) /
(0020) / Jun 01,'06 R0.02  Added FAT12 support.
(0021) /                   Removed unbuffered mode.
(0022) /                   Fixed a problem on small (<32M) partition.
(0023) / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
(0024) /
(0025) / Sep 22,'06 R0.03  Added f_rename().
(0026) /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
(0027) / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
(0028) /                   Fixed f_mkdir() creates incorrect directory on FAT32.
(0029) /
(0030) / Feb 04,'07 R0.04  Supported multiple drive system.
(0031) /                   Changed some interfaces for multiple drive system.
(0032) /                   Changed f_mountdrv() to f_mount().
(0033) /                   Added f_mkfs().
(0034) / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
(0035) /                   Added a capability of extending file size to f_lseek().
(0036) /                   Added minimization level 3.
(0037) /                   Fixed an endian sensitive code in f_mkfs().
(0038) / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
(0039) /                   Added FSInfo support.
(0040) /                   Fixed DBCS name can result FR_INVALID_NAME.
(0041) /                   Fixed short seek (<= csize) collapses the file object.
(0042) /
(0043) / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
(0044) /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
(0045) /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
(0046) / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
(0047) /                   Fixed off by one error at FAT sub-type determination.
(0048) /                   Fixed btr in f_read() can be mistruncated.
(0049) /                   Fixed cached sector is not flushed when create and close without write.
(0050) /
(0051) / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
(0052) /                   Improved performance of f_lseek() on moving to the same or following cluster.
(0053) /
(0054) / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
(0055) /                   Added long file name feature.
(0056) /                   Added multiple code page feature.
(0057) /                   Added re-entrancy for multitask operation.
(0058) /                   Added auto cluster size selection to f_mkfs().
(0059) /                   Added rewind option to f_readdir().
(0060) /                   Changed result code of critical errors.
(0061) /                   Renamed string functions to avoid name collision.
(0062) / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
(0063) /                   Added multiple sector size feature.
(0064) / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
(0065) /                   Fixed wrong cache control in f_lseek().
(0066) /                   Added relative path feature.
(0067) /                   Added f_chdir() and f_chdrive().
(0068) /                   Added proper case conversion to extended char.
(0069) / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
(0070) /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
(0071) /                   Fixed name matching error on the 13 char boundary.
(0072) /                   Added a configuration option, _LFN_UNICODE.
(0073) /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
(0074) /
(0075) / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
(0076) /                   Added file lock feature. (_FS_SHARE)
(0077) /                   Added fast seek feature. (_USE_FASTSEEK)
(0078) /                   Changed some types on the API, XCHAR->TCHAR.
(0079) /                   Changed fname member in the FILINFO structure on Unicode cfg.
(0080) /                   String functions support UTF-8 encoding files on Unicode cfg.
(0081) / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
(0082) /                   Added sector erase feature. (_USE_ERASE)
(0083) /                   Moved file lock semaphore table from fs object to the bss.
(0084) /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
(0085) /                   Fixed f_mkfs() creates wrong FAT32 volume.
(0086) / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
(0087) /                   f_lseek() reports required table size on creating CLMP.
(0088) /                   Extended format syntax of f_printf function.
(0089) /                   Ignores duplicated directory separators in given path names.
(0090) /
(0091) / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
(0092) /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
(0093) /---------------------------------------------------------------------------*/
(0094) 
(0095) #include "ff.h"			/* FatFs configurations and declarations */
(0096) #include "diskio.h"		/* Declarations of low level disk I/O functions */
(0097) #include <string.h>
(0098) 
(0099) /*--------------------------------------------------------------------------
(0100) 
(0101)    Module Private Definitions
(0102) 
(0103) ---------------------------------------------------------------------------*/
(0104) 
(0105) #if _FATFS != 6502	/* Revision ID */
(0106) #error Wrong include file (ff.h).
(0107) #endif
(0108) 
(0109) 
(0110) /* Definitions on sector size */
(0111) #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
(0112) #error Wrong sector size.
(0113) #endif
(0114) #if _MAX_SS != 512
(0115) #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
(0116) #else
(0117) #define	SS(fs)	512U			/* Fixed sector size */
(0118) #endif
(0119) 
(0120) 
(0121) /* Reentrancy related */
(0122) #if _FS_REENTRANT
(0123) #if _USE_LFN == 1
(0124) #error Static LFN work area must not be used in re-entrant configuration.
(0125) #endif
(0126) #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
(0127) #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
(0128) #else
(0129) #define	ENTER_FF(fs)
(0130) #define LEAVE_FF(fs, res)	return res
(0131) #endif
(0132) 
(0133) #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
(0134) 
(0135) 
(0136) /* File shareing feature */
(0137) #if _FS_SHARE
(0138) #if _FS_READONLY
(0139) #error _FS_SHARE must be 0 on read-only cfg.
(0140) #endif
(0141) typedef struct {
(0142) 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
(0143) 	DWORD clu;				/* File ID 2, directory */
(0144) 	WORD idx;				/* File ID 3, directory index */
(0145) 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
(0146) } FILESEM;
(0147) #endif
(0148) 
(0149) 
(0150) /* Misc definitions */
(0151) #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
(0152) #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
(0153) 
(0154) 
(0155) /* DBCS code ranges and SBCS extend char conversion table */
(0156) 
(0157) #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
(0158) #define _DF1S	0x81	/* DBC 1st byte range 1 start */
(0159) #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
(0160) #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
(0161) #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
(0162) #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
(0163) #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
(0164) #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
(0165) #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
(0166) 
(0167) #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
(0168) #define _DF1S	0x81
(0169) #define _DF1E	0xFE
(0170) #define _DS1S	0x40
(0171) #define _DS1E	0x7E
(0172) #define _DS2S	0x80
(0173) #define _DS2E	0xFE
(0174) 
(0175) #elif _CODE_PAGE == 949	/* Korean */
(0176) #define _DF1S	0x81
(0177) #define _DF1E	0xFE
(0178) #define _DS1S	0x41
(0179) #define _DS1E	0x5A
(0180) #define _DS2S	0x61
(0181) #define _DS2E	0x7A
(0182) #define _DS3S	0x81
(0183) #define _DS3E	0xFE
(0184) 
(0185) #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
(0186) #define _DF1S	0x81
(0187) #define _DF1E	0xFE
(0188) #define _DS1S	0x40
(0189) #define _DS1E	0x7E
(0190) #define _DS2S	0xA1
(0191) #define _DS2E	0xFE
(0192) 
(0193) #elif _CODE_PAGE == 437	/* U.S. (OEM) */
(0194) #define _DF1S	0
(0195) #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0196) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0197) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0198) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0199) 
(0200) #elif _CODE_PAGE == 720	/* Arabic (OEM) */
(0201) #define _DF1S	0
(0202) #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0203) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0204) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0205) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0206) 
(0207) #elif _CODE_PAGE == 737	/* Greek (OEM) */
(0208) #define _DF1S	0
(0209) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
(0210) 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0211) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0212) 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0213) 
(0214) #elif _CODE_PAGE == 775	/* Baltic (OEM) */
(0215) #define _DF1S	0
(0216) #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0217) 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0218) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0219) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0220) 
(0221) #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
(0222) #define _DF1S	0
(0223) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0224) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0225) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0226) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0227) 
(0228) #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
(0229) #define _DF1S	0
(0230) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
(0231) 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
(0232) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0233) 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
(0234) 
(0235) #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
(0236) #define _DF1S	0
(0237) #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
(0238) 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
(0239) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
(0240) 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
(0241) 
(0242) #elif _CODE_PAGE == 857	/* Turkish (OEM) */
(0243) #define _DF1S	0
(0244) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
(0245) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0246) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0247) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0248) 
(0249) #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
(0250) #define _DF1S	0
(0251) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0252) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0253) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0254) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0255) 
(0256) #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
(0257) #define _DF1S	0
(0258) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0259) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0260) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0261) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0262) 
(0263) #elif _CODE_PAGE == 866	/* Russian (OEM) */
(0264) #define _DF1S	0
(0265) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0266) 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0267) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0268) 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0269) 
(0270) #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
(0271) #define _DF1S	0
(0272) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0273) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0274) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0275) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0276) 
(0277) #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
(0278) #define _DF1S	0
(0279) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0280) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
(0281) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0282) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0283) 
(0284) #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
(0285) #define _DF1S	0
(0286) #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0287) 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
(0288) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0289) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
(0290) 
(0291) #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
(0292) #define _DF1S	0
(0293) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
(0294) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0295) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0296) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0297) 
(0298) #elif _CODE_PAGE == 1253 /* Greek (Windows) */
(0299) #define _DF1S	0
(0300) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0301) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0302) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
(0303) 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
(0304) 
(0305) #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
(0306) #define _DF1S	0
(0307) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0308) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0309) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0310) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0311) 
(0312) #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
(0313) #define _DF1S	0
(0314) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0315) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0316) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0317) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0318) 
(0319) #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
(0320) #define _DF1S	0
(0321) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0322) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0323) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0324) 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
(0325) 
(0326) #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
(0327) #define _DF1S	0
(0328) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0329) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
(0330) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0331) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0332) 
(0333) #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
(0334) #define _DF1S	0
(0335) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
(0336) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0337) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0338) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
(0339) 
(0340) #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
(0341) #if _USE_LFN
(0342) #error Cannot use LFN feature without valid code page.
(0343) #endif
(0344) #define _DF1S	0
(0345) 
(0346) #else
(0347) #error Unknown code page
(0348) 
(0349) #endif
(0350) 
(0351) 
(0352) /* Character code support macros */
(0353) #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
(0354) #define IsLower(c)	(((c)>='a')&&((c)<='z'))
(0355) #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
(0356) 
(0357) #if _DF1S		/* Code page is DBCS */
(0358) 
(0359) #ifdef _DF2S	/* Two 1st byte areas */
(0360) #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
(0361) #else			/* One 1st byte area */
(0362) #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
(0363) #endif
(0364) 
(0365) #ifdef _DS3S	/* Three 2nd byte areas */
(0366) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
(0367) #else			/* Two 2nd byte areas */
(0368) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
(0369) #endif
(0370) 
(0371) #else			/* Code page is SBCS */
(0372) 
(0373) #define IsDBCS1(c)	0
(0374) #define IsDBCS2(c)	0
(0375) 
(0376) #endif /* _DF1S */
(0377) 
(0378) 
(0379) /* Name status flags */
(0380) #define NS			11		/* Index of name status byte in fn[] */
(0381) #define NS_LOSS		0x01	/* Out of 8.3 format */
(0382) #define NS_LFN		0x02	/* Force to create LFN entry */
(0383) #define NS_LAST		0x04	/* Last segment */
(0384) #define NS_BODY		0x08	/* Lower case flag (body) */
(0385) #define NS_EXT		0x10	/* Lower case flag (ext) */
(0386) #define NS_DOT		0x20	/* Dot entry */
(0387) 
(0388) 
(0389) /* FAT sub-type boundaries */
(0390) /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
(0391) #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
(0392) #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
(0393) 
(0394) 
(0395) /* FatFs refers the members in the FAT structures as byte array instead of
(0396) / structure member because the structure is not binary compatible between
(0397) / different platforms */
(0398) 
(0399) #define BS_jmpBoot			0	/* Jump instruction (3) */
(0400) #define BS_OEMName			3	/* OEM name (8) */
(0401) #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
(0402) #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
(0403) #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
(0404) #define BPB_NumFATs			16	/* Number of FAT copies (1) */
(0405) #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
(0406) #define BPB_TotSec16		19	/* Volume size [sector] (2) */
(0407) #define BPB_Media			21	/* Media descriptor (1) */
(0408) #define BPB_FATSz16			22	/* FAT size [sector] (2) */
(0409) #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
(0410) #define BPB_NumHeads		26	/* Number of heads (2) */
(0411) #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
(0412) #define BPB_TotSec32		32	/* Volume size [sector] (4) */
(0413) #define BS_DrvNum			36	/* Physical drive number (2) */
(0414) #define BS_BootSig			38	/* Extended boot signature (1) */
(0415) #define BS_VolID			39	/* Volume serial number (4) */
(0416) #define BS_VolLab			43	/* Volume label (8) */
(0417) #define BS_FilSysType		54	/* File system type (1) */
(0418) #define BPB_FATSz32			36	/* FAT size [sector] (4) */
(0419) #define BPB_ExtFlags		40	/* Extended flags (2) */
(0420) #define BPB_FSVer			42	/* File system version (2) */
(0421) #define BPB_RootClus		44	/* Root dir first cluster (4) */
(0422) #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
(0423) #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
(0424) #define BS_DrvNum32			64	/* Physical drive number (2) */
(0425) #define BS_BootSig32		66	/* Extended boot signature (1) */
(0426) #define BS_VolID32			67	/* Volume serial number (4) */
(0427) #define BS_VolLab32			71	/* Volume label (8) */
(0428) #define BS_FilSysType32		82	/* File system type (1) */
(0429) #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
(0430) #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
(0431) #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
(0432) #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
(0433) #define MBR_Table			446	/* MBR: Partition table offset (2) */
(0434) #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
(0435) #define BS_55AA				510	/* Boot sector signature (2) */
(0436) 
(0437) #define	DIR_Name			0	/* Short file name (11) */
(0438) #define	DIR_Attr			11	/* Attribute (1) */
(0439) #define	DIR_NTres			12	/* NT flag (1) */
(0440) #define	DIR_CrtTime			14	/* Created time (2) */
(0441) #define	DIR_CrtDate			16	/* Created date (2) */
(0442) #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
(0443) #define	DIR_WrtTime			22	/* Modified time (2) */
(0444) #define	DIR_WrtDate			24	/* Modified date (2) */
(0445) #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
(0446) #define	DIR_FileSize		28	/* File size (4) */
(0447) #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
(0448) #define	LDIR_Attr			11	/* LFN attribute (1) */
(0449) #define	LDIR_Type			12	/* LFN type (1) */
(0450) #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
(0451) #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
(0452) #define	SZ_DIR				32		/* Size of a directory entry */
(0453) #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
(0454) #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
(0455) #define	NDDE				0x05	/* Replacement of a character collides with DDE */
(0456) 
(0457) 
(0458) /*------------------------------------------------------------*/
(0459) /* Module private work area                                   */
(0460) /*------------------------------------------------------------*/
(0461) /* Note that uninitialized variables with static duration are
(0462) /  zeroed/nulled at start-up. If not, the compiler or start-up
(0463) /  routine is out of ANSI-C standard.
(0464) */
(0465) 
(0466) #if _VOLUMES
(0467) static
(0468) FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
(0469) #else
(0470) #error Number of volumes must not be 0.
(0471) #endif
(0472) 
(0473) static
(0474) WORD Fsid;				/* File system mount ID */
(0475) 
(0476) #if _FS_RPATH
(0477) static
(0478) BYTE CurrVol;			/* Current drive */
(0479) #endif
(0480) 
(0481) #if _FS_SHARE
(0482) static
(0483) FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
(0484) #endif
(0485) 
(0486) #if _USE_LFN == 0			/* No LFN feature */
(0487) #define	DEF_NAMEBUF			BYTE sfn[12]
(0488) #define INIT_BUF(dobj)		(dobj).fn = sfn
(0489) #define	FREE_BUF()
(0490) 
(0491) #elif _USE_LFN == 1			/* LFN feature with static working buffer */
(0492) static WCHAR LfnBuf[_MAX_LFN+1];
(0493) #define	DEF_NAMEBUF			BYTE sfn[12]
(0494) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
(0495) #define	FREE_BUF()
(0496) 
(0497) #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
(0498) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
(0499) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
(0500) #define	FREE_BUF()
(0501) 
(0502) #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
(0503) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
(0504) #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
(0505) 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
(0506) 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
(0507) #define	FREE_BUF()			ff_memfree(lfn)
(0508) 
(0509) #else
(0510) #error Wrong LFN configuration.
(0511) #endif
(0512) 
(0513) 
(0514) 
(0515) 
(0516) /*--------------------------------------------------------------------------
(0517) 
(0518)    Module Private Functions
(0519) 
(0520) ---------------------------------------------------------------------------*/
(0521) 
(0522) 
(0523) /*-----------------------------------------------------------------------*/
(0524) /* String functions                                                      */
(0525) /*-----------------------------------------------------------------------*/
(0526) 
(0527) /* Copy memory to memory */
(0528) static
(0529) void mem_cpy (void* dst, const void* src, UINT cnt) {
(0530) 	BYTE *d = (BYTE*)dst;
    002E4 0158      MOVW	R10,R16
(0531) 	const BYTE *s = (const BYTE*)src;
    002E5 0169      MOVW	R12,R18
    002E6 C006      RJMP	0x02ED
(0532) 
(0533) #if _WORD_ACCESS == 1
(0534) 	while (cnt >= sizeof(int)) {
(0535) 		*(int*)d = *(int*)s;
(0536) 		d += sizeof(int); s += sizeof(int);
(0537) 		cnt -= sizeof(int);
(0538) 	}
(0539) #endif
(0540) 	while (cnt--)
(0541) 		*d++ = *s++;
    002E7 01F6      MOVW	R30,R12
    002E8 01D5      MOVW	R26,R10
    002E9 9001      LD	R0,Z+
    002EA 016F      MOVW	R12,R30
    002EB 920D      ST	X+,R0
    002EC 015D      MOVW	R10,R26
    002ED 011A      MOVW	R2,R20
    002EE 5041      SUBI	R20,1
    002EF 4050      SBCI	R21,0
    002F0 2022      TST	R2
    002F1 F7A9      BNE	0x02E7
    002F2 2033      TST	R3
    002F3 F799      BNE	0x02E7
    002F4 940C 3FA1 JMP	pop_xgset303C
ff.c:mem_set:
  d                    --> R10
  cnt                  --> R20
  val                  --> R18
  dst                  --> R16
    002F6 940E 3F78 CALL	push_xgset300C
    002F8 814C      LDD	R20,Y+4
    002F9 815D      LDD	R21,Y+5
(0542) }
(0543) 
(0544) /* Fill memory */
(0545) static
(0546) void mem_set (void* dst, int val, UINT cnt) {
(0547) 	BYTE *d = (BYTE*)dst;
    002FA 0158      MOVW	R10,R16
    002FB C003      RJMP	0x02FF
(0548) 
(0549) 	while (cnt--)
(0550) 		*d++ = (BYTE)val;
    002FC 01F5      MOVW	R30,R10
    002FD 9321      ST	Z+,R18
    002FE 015F      MOVW	R10,R30
    002FF 011A      MOVW	R2,R20
    00300 5041      SUBI	R20,1
    00301 4050      SBCI	R21,0
    00302 2022      TST	R2
    00303 F7C1      BNE	0x02FC
    00304 2033      TST	R3
    00305 F7B1      BNE	0x02FC
    00306 940C 3F7D JMP	pop_xgset300C
ff.c:mem_cmp:
  s                    --> R14
  d                    --> R12
  r                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    00308 940E 3F6F CALL	push_xgset30FC
    0030A 8548      LDD	R20,Y+8
    0030B 8559      LDD	R21,Y+9
(0551) }
(0552) 
(0553) /* Compare memory to memory */
(0554) static
(0555) int mem_cmp (const void* dst, const void* src, UINT cnt) {
(0556) 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    0030C 0168      MOVW	R12,R16
    0030D 0179      MOVW	R14,R18
(0557) 	int r = 0;
    0030E 24AA      CLR	R10
    0030F 24BB      CLR	R11
(0558) 
(0559) 	while (cnt-- && (r = *d++ - *s++) == 0) ;
    00310 011A      MOVW	R2,R20
    00311 5041      SUBI	R20,1
    00312 4050      SBCI	R21,0
    00313 2022      TST	R2
    00314 F411      BNE	0x0317
    00315 2033      TST	R3
    00316 F079      BEQ	0x0326
    00317 01F7      MOVW	R30,R14
    00318 9021      LD	R2,Z+
    00319 017F      MOVW	R14,R30
    0031A 2433      CLR	R3
    0031B 01F6      MOVW	R30,R12
    0031C 9041      LD	R4,Z+
    0031D 016F      MOVW	R12,R30
    0031E 2455      CLR	R5
    0031F 1842      SUB	R4,R2
    00320 0853      SBC	R5,R3
    00321 0152      MOVW	R10,R4
    00322 20AA      TST	R10
    00323 F411      BNE	0x0326
    00324 20BB      TST	R11
    00325 F351      BEQ	0x0310
(0560) 	return r;
    00326 0185      MOVW	R16,R10
    00327 940C 3F59 JMP	pop_xgset30FC
(0561) }
(0562) 
(0563) /* Check if chr is contained in the string */
(0564) static
(0565) int chk_chr (const char* str, int chr) {
ff.c:chk_chr:
  chr                  --> R18
  str                  --> R16
    00329 C002      RJMP	0x032C
(0566) 	while (*str && *str != chr) str++;
    0032A 5F0F      SUBI	R16,0xFF
    0032B 4F1F      SBCI	R17,0xFF
    0032C 01F8      MOVW	R30,R16
    0032D 8020      LD	R2,Z
    0032E 2433      CLR	R3
    0032F 2022      TST	R2
    00330 F021      BEQ	0x0335
    00331 2433      CLR	R3
    00332 1622      CP	R2,R18
    00333 0633      CPC	R3,R19
    00334 F7A9      BNE	0x032A
(0567) 	return *str;
    00335 01F8      MOVW	R30,R16
    00336 8100      LD	R16,Z
    00337 2711      CLR	R17
    00338 9508      RET
ff.c:move_window:
  nf                   --> R10
  wsect                --> Y,+5
  sector               --> Y,+13
  fs                   --> R20
    00339 933A      ST	-Y,R19
    0033A 932A      ST	-Y,R18
    0033B 940E 3F78 CALL	push_xgset300C
    0033D 01A8      MOVW	R20,R16
    0033E 9729      SBIW	R28,0x9
(0568) }
(0569) 
(0570) 
(0571) 
(0572) /*-----------------------------------------------------------------------*/
(0573) /* Request/Release grant to access the volume                            */
(0574) /*-----------------------------------------------------------------------*/
(0575) #if _FS_REENTRANT
(0576) 
(0577) static
(0578) int lock_fs (
(0579) 	FATFS *fs		/* File system object */
(0580) )
(0581) {
(0582) 	return ff_req_grant(fs->sobj);
(0583) }
(0584) 
(0585) 
(0586) static
(0587) void unlock_fs (
(0588) 	FATFS *fs,		/* File system object */
(0589) 	FRESULT res		/* Result code to be returned */
(0590) )
(0591) {
(0592) 	if (res != FR_NOT_ENABLED &&
(0593) 		res != FR_INVALID_DRIVE &&
(0594) 		res != FR_INVALID_OBJECT &&
(0595) 		res != FR_TIMEOUT) {
(0596) 		ff_rel_grant(fs->sobj);
(0597) 	}
(0598) }
(0599) #endif
(0600) 
(0601) 
(0602) 
(0603) /*-----------------------------------------------------------------------*/
(0604) /* File shareing control functions                                       */
(0605) /*-----------------------------------------------------------------------*/
(0606) #if _FS_SHARE
(0607) 
(0608) static
(0609) FRESULT chk_lock (	/* Check if the file can be accessed */
(0610) 	DIR* dj,		/* Directory object pointing the file to be checked */
(0611) 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
(0612) )
(0613) {
(0614) 	UINT i, be;
(0615) 
(0616) 	/* Search file semaphore table */
(0617) 	for (i = be = 0; i < _FS_SHARE; i++) {
(0618) 		if (Files[i].fs) {	/* Existing entry */
(0619) 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
(0620) 				Files[i].clu == dj->sclust &&
(0621) 				Files[i].idx == dj->index) break;
(0622) 		} else {			/* Blank entry */
(0623) 			be++;
(0624) 		}
(0625) 	}
(0626) 	if (i == _FS_SHARE)	/* The file is not opened */
(0627) 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
(0628) 
(0629) 	/* The file has been opened. Reject any open against writing file and all write mode open */
(0630) 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
(0631) }
(0632) 
(0633) 
(0634) static
(0635) int enq_lock (void)	/* Check if an entry is available for a new file */
(0636) {
(0637) 	UINT i;
(0638) 
(0639) 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0640) 	return (i == _FS_SHARE) ? 0 : 1;
(0641) }
(0642) 
(0643) 
(0644) static
(0645) UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
(0646) 	DIR* dj,	/* Directory object pointing the file to register or increment */
(0647) 	int acc		/* Desired access mode (0:Read, !0:Write) */
(0648) )
(0649) {
(0650) 	UINT i;
(0651) 
(0652) 
(0653) 	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
(0654) 		if (Files[i].fs == dj->fs &&
(0655) 			Files[i].clu == dj->sclust &&
(0656) 			Files[i].idx == dj->index) break;
(0657) 	}
(0658) 
(0659) 	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
(0660) 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0661) 		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
(0662) 		Files[i].fs = dj->fs;
(0663) 		Files[i].clu = dj->sclust;
(0664) 		Files[i].idx = dj->index;
(0665) 		Files[i].ctr = 0;
(0666) 	}
(0667) 
(0668) 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
(0669) 
(0670) 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
(0671) 
(0672) 	return i + 1;
(0673) }
(0674) 
(0675) 
(0676) static
(0677) FRESULT dec_lock (	/* Decrement file open counter */
(0678) 	UINT i			/* Semaphore index */
(0679) )
(0680) {
(0681) 	WORD n;
(0682) 	FRESULT res;
(0683) 
(0684) 
(0685) 	if (--i < _FS_SHARE) {
(0686) 		n = Files[i].ctr;
(0687) 		if (n == 0x100) n = 0;
(0688) 		if (n) n--;
(0689) 		Files[i].ctr = n;
(0690) 		if (!n) Files[i].fs = 0;
(0691) 		res = FR_OK;
(0692) 	} else {
(0693) 		res = FR_INT_ERR;
(0694) 	}
(0695) 	return res;
(0696) }
(0697) 
(0698) 
(0699) static
(0700) void clear_lock (	/* Clear lock entries of the volume */
(0701) 	FATFS *fs
(0702) )
(0703) {
(0704) 	UINT i;
(0705) 
(0706) 	for (i = 0; i < _FS_SHARE; i++) {
(0707) 		if (Files[i].fs == fs) Files[i].fs = 0;
(0708) 	}
(0709) }
(0710) #endif
(0711) 
(0712) 
(0713) 
(0714) /*-----------------------------------------------------------------------*/
(0715) /* Change window offset                                                  */
(0716) /*-----------------------------------------------------------------------*/
(0717) 
(0718) static
(0719) FRESULT move_window (
(0720) 	FATFS *fs,		/* File system object */
(0721) 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
(0722) )					/* Move to zero only writes back dirty window */
(0723) {
(0724) 	DWORD wsect;
(0725) 
(0726) 
(0727) 	wsect = fs->winsect;
    0033F 01FA      MOVW	R30,R20
    00340 96BA      ADIW	R30,0x2A
    00341 8020      LD	R2,Z
    00342 8031      LDD	R3,Z+1
    00343 8042      LDD	R4,Z+2
    00344 8053      LDD	R5,Z+3
    00345 822D      STD	Y+5,R2
    00346 823E      STD	Y+6,R3
    00347 824F      STD	Y+7,R4
    00348 8658      STD	Y+8,R5
(0728) 	if (wsect != sector) {	/* Changed current window */
    00349 842D      LDD	R2,Y+13
    0034A 843E      LDD	R3,Y+14
    0034B 844F      LDD	R4,Y+15
    0034C 8858      LDD	R5,Y+16
    0034D 806D      LDD	R6,Y+5
    0034E 807E      LDD	R7,Y+6
    0034F 808F      LDD	R8,Y+7
    00350 8498      LDD	R9,Y+8
    00351 1462      CP	R6,R2
    00352 0473      CPC	R7,R3
    00353 0484      CPC	R8,R4
    00354 0495      CPC	R9,R5
    00355 F409      BNE	0x0357
    00356 C07E      RJMP	0x03D5
(0729) #if !_FS_READONLY
(0730) 		if (fs->wflag) {	/* Write back dirty window if needed */
    00357 01FA      MOVW	R30,R20
    00358 8024      LDD	R2,Z+4
    00359 2022      TST	R2
    0035A F409      BNE	0x035C
    0035B C055      RJMP	0x03B1
(0731) 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    0035C E081      LDI	R24,1
    0035D 838C      STD	Y+4,R24
    0035E 0113      MOVW	R2,R6
    0035F 0124      MOVW	R4,R8
    00360 8228      ST	Y,R2
    00361 8239      STD	Y+1,R3
    00362 824A      STD	Y+2,R4
    00363 825B      STD	Y+3,R5
    00364 019A      MOVW	R18,R20
    00365 5D22      SUBI	R18,0xD2
    00366 4F3F      SBCI	R19,0xFF
    00367 8101      LDD	R16,Z+1
    00368 940E 02BE CALL	_disk_write
    0036A 2300      TST	R16
    0036B F011      BEQ	0x036E
(0732) 				return FR_DISK_ERR;
    0036C E001      LDI	R16,1
    0036D C068      RJMP	0x03D6
(0733) 			fs->wflag = 0;
    0036E 2422      CLR	R2
    0036F 01FA      MOVW	R30,R20
    00370 8224      STD	Z+4,R2
(0734) 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    00371 8C22      LDD	R2,Z+26
    00372 8C33      LDD	R3,Z+27
    00373 8C44      LDD	R4,Z+28
    00374 8C55      LDD	R5,Z+29
    00375 967E      ADIW	R30,0x1E
    00376 8060      LD	R6,Z
    00377 8071      LDD	R7,Z+1
    00378 8082      LDD	R8,Z+2
    00379 8093      LDD	R9,Z+3
    0037A 0C62      ADD	R6,R2
    0037B 1C73      ADC	R7,R3
    0037C 1C84      ADC	R8,R4
    0037D 1C95      ADC	R9,R5
    0037E 802D      LDD	R2,Y+5
    0037F 803E      LDD	R3,Y+6
    00380 804F      LDD	R4,Y+7
    00381 8458      LDD	R5,Y+8
    00382 1426      CP	R2,R6
    00383 0437      CPC	R3,R7
    00384 0448      CPC	R4,R8
    00385 0459      CPC	R5,R9
    00386 F550      BCC	0x03B1
(0735) 				BYTE nf;
(0736) 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    00387 01FA      MOVW	R30,R20
    00388 80A3      LDD	R10,Z+3
    00389 C024      RJMP	0x03AE
(0737) 					wsect += fs->fsize;
    0038A 01FA      MOVW	R30,R20
    0038B 967A      ADIW	R30,0x1A
    0038C 8020      LD	R2,Z
    0038D 8031      LDD	R3,Z+1
    0038E 8042      LDD	R4,Z+2
    0038F 8053      LDD	R5,Z+3
    00390 806D      LDD	R6,Y+5
    00391 807E      LDD	R7,Y+6
    00392 808F      LDD	R8,Y+7
    00393 8498      LDD	R9,Y+8
    00394 0C62      ADD	R6,R2
    00395 1C73      ADC	R7,R3
    00396 1C84      ADC	R8,R4
    00397 1C95      ADC	R9,R5
    00398 826D      STD	Y+5,R6
    00399 827E      STD	Y+6,R7
    0039A 828F      STD	Y+7,R8
    0039B 8698      STD	Y+8,R9
(0738) 					disk_write(fs->drv, fs->win, wsect, 1);
    0039C E081      LDI	R24,1
    0039D 838C      STD	Y+4,R24
    0039E 802D      LDD	R2,Y+5
    0039F 803E      LDD	R3,Y+6
    003A0 804F      LDD	R4,Y+7
    003A1 8458      LDD	R5,Y+8
    003A2 8228      ST	Y,R2
    003A3 8239      STD	Y+1,R3
    003A4 824A      STD	Y+2,R4
    003A5 825B      STD	Y+3,R5
    003A6 019A      MOVW	R18,R20
    003A7 5D22      SUBI	R18,0xD2
    003A8 4F3F      SBCI	R19,0xFF
    003A9 01FA      MOVW	R30,R20
    003AA 8101      LDD	R16,Z+1
    003AB 940E 02BE CALL	_disk_write
    003AD 94AA      DEC	R10
    003AE E081      LDI	R24,1
    003AF 158A      CP	R24,R10
    003B0 F2C8      BCS	0x038A
(0739) 				}
(0740) 			}
(0741) 		}
(0742) #endif
(0743) 		if (sector) {
    003B1 842D      LDD	R2,Y+13
    003B2 843E      LDD	R3,Y+14
    003B3 844F      LDD	R4,Y+15
    003B4 8858      LDD	R5,Y+16
    003B5 9488      BCLR	0
    003B6 2022      TST	R2
    003B7 0432      CPC	R3,R2
    003B8 0442      CPC	R4,R2
    003B9 0452      CPC	R5,R2
    003BA F0D1      BEQ	0x03D5
(0744) 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    003BB E081      LDI	R24,1
    003BC 838C      STD	Y+4,R24
    003BD 8228      ST	Y,R2
    003BE 8239      STD	Y+1,R3
    003BF 824A      STD	Y+2,R4
    003C0 825B      STD	Y+3,R5
    003C1 019A      MOVW	R18,R20
    003C2 5D22      SUBI	R18,0xD2
    003C3 4F3F      SBCI	R19,0xFF
    003C4 01FA      MOVW	R30,R20
    003C5 8101      LDD	R16,Z+1
    003C6 940E 029E CALL	_disk_read
    003C8 2300      TST	R16
    003C9 F011      BEQ	0x03CC
(0745) 				return FR_DISK_ERR;
    003CA E001      LDI	R16,1
    003CB C00A      RJMP	0x03D6
(0746) 			fs->winsect = sector;
    003CC 842D      LDD	R2,Y+13
    003CD 843E      LDD	R3,Y+14
    003CE 844F      LDD	R4,Y+15
    003CF 8858      LDD	R5,Y+16
    003D0 01FA      MOVW	R30,R20
    003D1 A622      STD	Z+42,R2
    003D2 A633      STD	Z+43,R3
    003D3 A644      STD	Z+44,R4
    003D4 A655      STD	Z+45,R5
(0747) 		}
(0748) 	}
(0749) 
(0750) 	return FR_OK;
    003D5 2700      CLR	R16
    003D6 9629      ADIW	R28,0x9
    003D7 940E 3F7D CALL	pop_xgset300C
    003D9 9622      ADIW	R28,2
    003DA 9508      RET
ff.c:sync:
  res                  --> R20
  fs                   --> R22
    003DB 940E 3F82 CALL	push_xgsetF000
    003DD 01B8      MOVW	R22,R16
    003DE 9725      SBIW	R28,5
(0751) }
(0752) 
(0753) 
(0754) 
(0755) 
(0756) /*-----------------------------------------------------------------------*/
(0757) /* Clean-up cached data                                                  */
(0758) /*-----------------------------------------------------------------------*/
(0759) #if !_FS_READONLY
(0760) static
(0761) FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
(0762) 	FATFS *fs	/* File system object */
(0763) )
(0764) {
(0765) 	FRESULT res;
(0766) 
(0767) 
(0768) 	res = move_window(fs, 0);
    003DF E080      LDI	R24,0
    003E0 E090      LDI	R25,0
    003E1 E0A0      LDI	R26,0
    003E2 E0B0      LDI	R27,0
    003E3 83A8      ST	Y,R26
    003E4 83B9      STD	Y+1,R27
    003E5 019C      MOVW	R18,R24
    003E6 018B      MOVW	R16,R22
    003E7 DF51      RCALL	ff.c:move_window
    003E8 2F40      MOV	R20,R16
(0769) 	if (res == FR_OK) {
    003E9 2300      TST	R16
    003EA F009      BEQ	0x03EC
    003EB C0C0      RJMP	0x04AC
(0770) 		/* Update FSInfo sector if needed */
(0771) 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    003EC 01FB      MOVW	R30,R22
    003ED 8180      LD	R24,Z
    003EE 3083      CPI	R24,3
    003EF F009      BEQ	0x03F1
    003F0 C0AC      RJMP	0x049D
    003F1 8025      LDD	R2,Z+5
    003F2 2022      TST	R2
    003F3 F409      BNE	0x03F5
    003F4 C0A8      RJMP	0x049D
(0772) 			fs->winsect = 0;
    003F5 96BA      ADIW	R30,0x2A
    003F6 E080      LDI	R24,0
    003F7 8380      ST	Z,R24
    003F8 8381      STD	Z+1,R24
    003F9 8382      STD	Z+2,R24
    003FA 8383      STD	Z+3,R24
(0773) 			/* Create FSInfo structure */
(0774) 			mem_set(fs->win, 0, 512);
    003FB E080      LDI	R24,0
    003FC E092      LDI	R25,2
    003FD 8399      STD	Y+1,R25
    003FE 8388      ST	Y,R24
    003FF 2722      CLR	R18
    00400 2733      CLR	R19
    00401 018B      MOVW	R16,R22
    00402 5D02      SUBI	R16,0xD2
    00403 4F1F      SBCI	R17,0xFF
    00404 DEF1      RCALL	ff.c:mem_set
(0775) 			ST_WORD(fs->win+BS_55AA, 0xAA55);
    00405 E585      LDI	R24,0x55
    00406 01FB      MOVW	R30,R22
    00407 5DE4      SUBI	R30,0xD4
    00408 4FFD      SBCI	R31,0xFD
    00409 8380      ST	Z,R24
    0040A 52EC      SUBI	R30,0x2C
    0040B 40F2      SBCI	R31,2
    0040C EA8A      LDI	R24,0xAA
    0040D 5DE3      SUBI	R30,0xD3
    0040E 4FFD      SBCI	R31,0xFD
    0040F 8380      ST	Z,R24
    00410 52ED      SUBI	R30,0x2D
    00411 40F2      SBCI	R31,2
(0776) 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    00412 E582      LDI	R24,0x52
    00413 A786      STD	Z+46,R24
    00414 A787      STD	Z+47,R24
    00415 E681      LDI	R24,0x61
    00416 AB80      STD	Z+48,R24
    00417 E481      LDI	R24,0x41
    00418 AB81      STD	Z+49,R24
(0777) 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    00419 E782      LDI	R24,0x72
    0041A 5EEE      SUBI	R30,0xEE
    0041B 4FFD      SBCI	R31,0xFD
    0041C 8380      ST	Z,R24
    0041D 51E2      SUBI	R30,0x12
    0041E 40F2      SBCI	R31,2
    0041F 5EED      SUBI	R30,0xED
    00420 4FFD      SBCI	R31,0xFD
    00421 8380      ST	Z,R24
    00422 51E3      SUBI	R30,0x13
    00423 40F2      SBCI	R31,2
    00424 E481      LDI	R24,0x41
    00425 5EEC      SUBI	R30,0xEC
    00426 4FFD      SBCI	R31,0xFD
    00427 8380      ST	Z,R24
    00428 51E4      SUBI	R30,0x14
    00429 40F2      SBCI	R31,2
    0042A E681      LDI	R24,0x61
    0042B 5EEB      SUBI	R30,0xEB
    0042C 4FFD      SBCI	R31,0xFD
    0042D 8380      ST	Z,R24
    0042E 51E5      SUBI	R30,0x15
    0042F 40F2      SBCI	R31,2
(0778) 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    00430 8426      LDD	R2,Z+14
    00431 8437      LDD	R3,Z+15
    00432 8840      LDD	R4,Z+16
    00433 8851      LDD	R5,Z+17
    00434 5EEA      SUBI	R30,0xEA
    00435 4FFD      SBCI	R31,0xFD
    00436 8220      ST	Z,R2
    00437 51E6      SUBI	R30,0x16
    00438 40F2      SBCI	R31,2
    00439 8426      LDD	R2,Z+14
    0043A 8437      LDD	R3,Z+15
    0043B 2C23      MOV	R2,R3
    0043C 2433      CLR	R3
    0043D 5EE9      SUBI	R30,0xE9
    0043E 4FFD      SBCI	R31,0xFD
    0043F 8220      ST	Z,R2
    00440 51E7      SUBI	R30,0x17
    00441 40F2      SBCI	R31,2
    00442 8426      LDD	R2,Z+14
    00443 8437      LDD	R3,Z+15
    00444 8840      LDD	R4,Z+16
    00445 8851      LDD	R5,Z+17
    00446 0112      MOVW	R2,R4
    00447 2444      CLR	R4
    00448 2455      CLR	R5
    00449 5EE8      SUBI	R30,0xE8
    0044A 4FFD      SBCI	R31,0xFD
    0044B 8220      ST	Z,R2
    0044C 51E8      SUBI	R30,0x18
    0044D 40F2      SBCI	R31,2
    0044E E188      LDI	R24,0x18
    0044F E090      LDI	R25,0
    00450 8506      LDD	R16,Z+14
    00451 8517      LDD	R17,Z+15
    00452 8920      LDD	R18,Z+16
    00453 8931      LDD	R19,Z+17
    00454 938A      ST	-Y,R24
    00455 940E 4008 CALL	lsr32
    00457 01FB      MOVW	R30,R22
    00458 5EE7      SUBI	R30,0xE7
    00459 4FFD      SBCI	R31,0xFD
    0045A 8300      ST	Z,R16
    0045B 51E9      SUBI	R30,0x19
    0045C 40F2      SBCI	R31,2
(0779) 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    0045D 8422      LDD	R2,Z+10
    0045E 8433      LDD	R3,Z+11
    0045F 8444      LDD	R4,Z+12
    00460 8455      LDD	R5,Z+13
    00461 5EE6      SUBI	R30,0xE6
    00462 4FFD      SBCI	R31,0xFD
    00463 8220      ST	Z,R2
    00464 51EA      SUBI	R30,0x1A
    00465 40F2      SBCI	R31,2
    00466 8422      LDD	R2,Z+10
    00467 8433      LDD	R3,Z+11
    00468 2C23      MOV	R2,R3
    00469 2433      CLR	R3
    0046A 5EE5      SUBI	R30,0xE5
    0046B 4FFD      SBCI	R31,0xFD
    0046C 8220      ST	Z,R2
    0046D 51EB      SUBI	R30,0x1B
    0046E 40F2      SBCI	R31,2
    0046F 8422      LDD	R2,Z+10
    00470 8433      LDD	R3,Z+11
    00471 8444      LDD	R4,Z+12
    00472 8455      LDD	R5,Z+13
    00473 0112      MOVW	R2,R4
    00474 2444      CLR	R4
    00475 2455      CLR	R5
    00476 5EE4      SUBI	R30,0xE4
    00477 4FFD      SBCI	R31,0xFD
    00478 8220      ST	Z,R2
    00479 51EC      SUBI	R30,0x1C
    0047A 40F2      SBCI	R31,2
    0047B E188      LDI	R24,0x18
    0047C E090      LDI	R25,0
    0047D 8502      LDD	R16,Z+10
    0047E 8513      LDD	R17,Z+11
    0047F 8524      LDD	R18,Z+12
    00480 8535      LDD	R19,Z+13
    00481 938A      ST	-Y,R24
    00482 940E 4008 CALL	lsr32
    00484 01FB      MOVW	R30,R22
    00485 5EE3      SUBI	R30,0xE3
    00486 4FFD      SBCI	R31,0xFD
    00487 8300      ST	Z,R16
    00488 51ED      SUBI	R30,0x1D
    00489 40F2      SBCI	R31,2
(0780) 			/* Write it into the FSInfo sector */
(0781) 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    0048A E081      LDI	R24,1
    0048B 838C      STD	Y+4,R24
    0048C 8822      LDD	R2,Z+18
    0048D 8833      LDD	R3,Z+19
    0048E 8844      LDD	R4,Z+20
    0048F 8855      LDD	R5,Z+21
    00490 8228      ST	Y,R2
    00491 8239      STD	Y+1,R3
    00492 824A      STD	Y+2,R4
    00493 825B      STD	Y+3,R5
    00494 019F      MOVW	R18,R30
    00495 5D22      SUBI	R18,0xD2
    00496 4F3F      SBCI	R19,0xFF
    00497 8101      LDD	R16,Z+1
    00498 940E 02BE CALL	_disk_write
(0782) 			fs->fsi_flag = 0;
    0049A 2422      CLR	R2
    0049B 01FB      MOVW	R30,R22
    0049C 8225      STD	Z+5,R2
(0783) 		}
(0784) 		/* Make sure that no pending write process in the physical drive */
(0785) 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    0049D 2422      CLR	R2
    0049E 2433      CLR	R3
    0049F 8239      STD	Y+1,R3
    004A0 8228      ST	Y,R2
    004A1 2722      CLR	R18
    004A2 2733      CLR	R19
    004A3 01FB      MOVW	R30,R22
    004A4 8101      LDD	R16,Z+1
    004A5 2711      CLR	R17
    004A6 940E 02D6 CALL	_disk_ioctl
    004A8 3000      CPI	R16,0
    004A9 0701      CPC	R16,R17
    004AA F009      BEQ	0x04AC
(0786) 			res = FR_DISK_ERR;
    004AB E041      LDI	R20,1
(0787) 	}
(0788) 
(0789) 	return res;
    004AC 2F04      MOV	R16,R20
    004AD 9625      ADIW	R28,5
    004AE 940C 3F87 JMP	pop_xgsetF000
_clust2sect:
  clst                 --> Y,+6
  fs                   --> R10
    004B0 933A      ST	-Y,R19
    004B1 932A      ST	-Y,R18
    004B2 940E 3F8C CALL	push_xgsetF00C
    004B4 0158      MOVW	R10,R16
(0790) }
(0791) #endif
(0792) 
(0793) 
(0794) 
(0795) 
(0796) /*-----------------------------------------------------------------------*/
(0797) /* Get sector# from cluster#                                             */
(0798) /*-----------------------------------------------------------------------*/
(0799) 
(0800) 
(0801) DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
(0802) 	FATFS *fs,		/* File system object */
(0803) 	DWORD clst		/* Cluster# to be converted */
(0804) )
(0805) {
(0806) 	clst -= 2;
    004B5 E042      LDI	R20,2
    004B6 E050      LDI	R21,0
    004B7 E060      LDI	R22,0
    004B8 E070      LDI	R23,0
    004B9 802E      LDD	R2,Y+6
    004BA 803F      LDD	R3,Y+7
    004BB 8448      LDD	R4,Y+8
    004BC 8459      LDD	R5,Y+9
    004BD 1A24      SUB	R2,R20
    004BE 0A35      SBC	R3,R21
    004BF 0A46      SBC	R4,R22
    004C0 0A57      SBC	R5,R23
    004C1 822E      STD	Y+6,R2
    004C2 823F      STD	Y+7,R3
    004C3 8648      STD	Y+8,R4
    004C4 8659      STD	Y+9,R5
(0807) 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    004C5 E042      LDI	R20,2
    004C6 E050      LDI	R21,0
    004C7 E060      LDI	R22,0
    004C8 E070      LDI	R23,0
    004C9 01F5      MOVW	R30,R10
    004CA 9676      ADIW	R30,0x16
    004CB 8020      LD	R2,Z
    004CC 8031      LDD	R3,Z+1
    004CD 8042      LDD	R4,Z+2
    004CE 8053      LDD	R5,Z+3
    004CF 1A24      SUB	R2,R20
    004D0 0A35      SBC	R3,R21
    004D1 0A46      SBC	R4,R22
    004D2 0A57      SBC	R5,R23
    004D3 806E      LDD	R6,Y+6
    004D4 807F      LDD	R7,Y+7
    004D5 8488      LDD	R8,Y+8
    004D6 8499      LDD	R9,Y+9
    004D7 1462      CP	R6,R2
    004D8 0473      CPC	R7,R3
    004D9 0484      CPC	R8,R4
    004DA 0495      CPC	R9,R5
    004DB F028      BCS	0x04E1
    004DC E000      LDI	R16,0
    004DD E010      LDI	R17,0
    004DE E020      LDI	R18,0
    004DF E030      LDI	R19,0
    004E0 C01D      RJMP	0x04FE
(0808) 	return clst * fs->csize + fs->database;
    004E1 01F5      MOVW	R30,R10
    004E2 9632      ADIW	R30,2
    004E3 8020      LD	R2,Z
    004E4 2433      CLR	R3
    004E5 2444      CLR	R4
    004E6 2455      CLR	R5
    004E7 810E      LDD	R16,Y+6
    004E8 811F      LDD	R17,Y+7
    004E9 8528      LDD	R18,Y+8
    004EA 8539      LDD	R19,Y+9
    004EB 925A      ST	-Y,R5
    004EC 924A      ST	-Y,R4
    004ED 923A      ST	-Y,R3
    004EE 922A      ST	-Y,R2
    004EF 940E 3F19 CALL	empy32u|empy32s
    004F1 0118      MOVW	R2,R16
    004F2 0129      MOVW	R4,R18
    004F3 01F5      MOVW	R30,R10
    004F4 A066      LDD	R6,Z+38
    004F5 A077      LDD	R7,Z+39
    004F6 A480      LDD	R8,Z+40
    004F7 A491      LDD	R9,Z+41
    004F8 0C26      ADD	R2,R6
    004F9 1C37      ADC	R3,R7
    004FA 1C48      ADC	R4,R8
    004FB 1C59      ADC	R5,R9
    004FC 0181      MOVW	R16,R2
    004FD 0192      MOVW	R18,R4
    004FE 940E 3F93 CALL	pop_xgsetF00C
    00500 9622      ADIW	R28,2
    00501 9508      RET
_get_fat:
  wc                   --> R14
  p                    --> R10
  bc                   --> R10
  clst                 --> Y,+12
  fs                   --> R12
    00502 933A      ST	-Y,R19
    00503 932A      ST	-Y,R18
    00504 940E 3F6D CALL	push_xgsetF0FC
    00506 0168      MOVW	R12,R16
    00507 9722      SBIW	R28,2
(0809) }
(0810) 
(0811) 
(0812) 
(0813) 
(0814) /*-----------------------------------------------------------------------*/
(0815) /* FAT access - Read value of a FAT entry                                */
(0816) /*-----------------------------------------------------------------------*/
(0817) 
(0818) 
(0819) DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
(0820) 	FATFS *fs,	/* File system object */
(0821) 	DWORD clst	/* Cluster# to get the link information */
(0822) )
(0823) {
(0824) 	UINT wc, bc;
(0825) 	BYTE *p;
(0826) 
(0827) 
(0828) 	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    00508 E042      LDI	R20,2
    00509 E050      LDI	R21,0
    0050A E060      LDI	R22,0
    0050B E070      LDI	R23,0
    0050C 842C      LDD	R2,Y+12
    0050D 843D      LDD	R3,Y+13
    0050E 844E      LDD	R4,Y+14
    0050F 845F      LDD	R5,Y+15
    00510 1624      CP	R2,R20
    00511 0635      CPC	R3,R21
    00512 0646      CPC	R4,R22
    00513 0657      CPC	R5,R23
    00514 F078      BCS	0x0524
    00515 01F6      MOVW	R30,R12
    00516 9676      ADIW	R30,0x16
    00517 8020      LD	R2,Z
    00518 8031      LDD	R3,Z+1
    00519 8042      LDD	R4,Z+2
    0051A 8053      LDD	R5,Z+3
    0051B 846C      LDD	R6,Y+12
    0051C 847D      LDD	R7,Y+13
    0051D 848E      LDD	R8,Y+14
    0051E 849F      LDD	R9,Y+15
    0051F 1462      CP	R6,R2
    00520 0473      CPC	R7,R3
    00521 0484      CPC	R8,R4
    00522 0495      CPC	R9,R5
    00523 F028      BCS	0x0529
(0829) 		return 1;
    00524 E001      LDI	R16,1
    00525 E010      LDI	R17,0
    00526 E020      LDI	R18,0
    00527 E030      LDI	R19,0
    00528 C124      RJMP	0x064D
(0830) 
(0831) 	switch (fs->fs_type) {
    00529 01F6      MOVW	R30,R12
    0052A 80A0      LD	R10,Z
    0052B 24BB      CLR	R11
    0052C 01C5      MOVW	R24,R10
    0052D 3081      CPI	R24,1
    0052E E0E0      LDI	R30,0
    0052F 079E      CPC	R25,R30
    00530 F059      BEQ	0x053C
    00531 3082      CPI	R24,2
    00532 E0E0      LDI	R30,0
    00533 079E      CPC	R25,R30
    00534 F409      BNE	0x0536
    00535 C06F      RJMP	0x05A5
    00536 3083      CPI	R24,3
    00537 E0E0      LDI	R30,0
    00538 079E      CPC	R25,R30
    00539 F409      BNE	0x053B
    0053A C0A6      RJMP	0x05E1
    0053B C10D      RJMP	0x0649
(0832) 	case FS_FAT12 :
(0833) 		bc = (UINT)clst; bc += bc / 2;
    0053C 84AC      LDD	R10,Y+12
    0053D 84BD      LDD	R11,Y+13
    0053E 0115      MOVW	R2,R10
    0053F 9436      LSR	R3
    00540 9427      ROR	R2
    00541 0CA2      ADD	R10,R2
    00542 1CB3      ADC	R11,R3
(0834) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00543 E029      LDI	R18,0x9
    00544 E030      LDI	R19,0
    00545 0185      MOVW	R16,R10
    00546 940E 4001 CALL	lsr16
    00548 0118      MOVW	R2,R16
    00549 2444      CLR	R4
    0054A 2455      CLR	R5
    0054B 01F6      MOVW	R30,R12
    0054C 8C66      LDD	R6,Z+30
    0054D 8C77      LDD	R7,Z+31
    0054E A080      LDD	R8,Z+32
    0054F A091      LDD	R9,Z+33
    00550 0C62      ADD	R6,R2
    00551 1C73      ADC	R7,R3
    00552 1C84      ADC	R8,R4
    00553 1C95      ADC	R9,R5
    00554 8288      ST	Y,R8
    00555 8299      STD	Y+1,R9
    00556 0193      MOVW	R18,R6
    00557 018F      MOVW	R16,R30
    00558 DDE0      RCALL	ff.c:move_window
    00559 2300      TST	R16
    0055A F009      BEQ	0x055C
    0055B C0ED      RJMP	0x0649
(0835) 		wc = fs->win[bc % SS(fs)]; bc++;
    0055C 01C6      MOVW	R24,R12
    0055D 968E      ADIW	R24,0x2E
    0055E 01F5      MOVW	R30,R10
    0055F 70F1      ANDI	R31,1
    00560 0FE8      ADD	R30,R24
    00561 1FF9      ADC	R31,R25
    00562 80E0      LD	R14,Z
    00563 24FF      CLR	R15
    00564 01C5      MOVW	R24,R10
    00565 9601      ADIW	R24,1
    00566 015C      MOVW	R10,R24
(0836) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00567 E029      LDI	R18,0x9
    00568 E030      LDI	R19,0
    00569 018C      MOVW	R16,R24
    0056A 940E 4001 CALL	lsr16
    0056C 0118      MOVW	R2,R16
    0056D 2444      CLR	R4
    0056E 2455      CLR	R5
    0056F 01F6      MOVW	R30,R12
    00570 8C66      LDD	R6,Z+30
    00571 8C77      LDD	R7,Z+31
    00572 A080      LDD	R8,Z+32
    00573 A091      LDD	R9,Z+33
    00574 0C62      ADD	R6,R2
    00575 1C73      ADC	R7,R3
    00576 1C84      ADC	R8,R4
    00577 1C95      ADC	R9,R5
    00578 8288      ST	Y,R8
    00579 8299      STD	Y+1,R9
    0057A 0193      MOVW	R18,R6
    0057B 018F      MOVW	R16,R30
    0057C DDBC      RCALL	ff.c:move_window
    0057D 2300      TST	R16
    0057E F009      BEQ	0x0580
    0057F C0C9      RJMP	0x0649
(0837) 		wc |= fs->win[bc % SS(fs)] << 8;
    00580 01C6      MOVW	R24,R12
    00581 968E      ADIW	R24,0x2E
    00582 01F5      MOVW	R30,R10
    00583 70F1      ANDI	R31,1
    00584 0FE8      ADD	R30,R24
    00585 1FF9      ADC	R31,R25
    00586 8020      LD	R2,Z
    00587 2433      CLR	R3
    00588 2C32      MOV	R3,R2
    00589 2422      CLR	R2
    0058A 28E2      OR	R14,R2
    0058B 28F3      OR	R15,R3
(0838) 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    0058C 842C      LDD	R2,Y+12
    0058D 843D      LDD	R3,Y+13
    0058E 844E      LDD	R4,Y+14
    0058F 845F      LDD	R5,Y+15
    00590 2DE2      MOV	R30,R2
    00591 70E1      ANDI	R30,1
    00592 F051      BEQ	0x059D
    00593 0157      MOVW	R10,R14
    00594 94B6      LSR	R11
    00595 94A7      ROR	R10
    00596 94B6      LSR	R11
    00597 94A7      ROR	R10
    00598 94B6      LSR	R11
    00599 94A7      ROR	R10
    0059A 94B6      LSR	R11
    0059B 94A7      ROR	R10
    0059C C003      RJMP	0x05A0
    0059D 01C7      MOVW	R24,R14
    0059E 709F      ANDI	R25,0xF
    0059F 015C      MOVW	R10,R24
    005A0 0185      MOVW	R16,R10
    005A1 0196      MOVW	R18,R12
    005A2 2722      CLR	R18
    005A3 2733      CLR	R19
    005A4 C0A8      RJMP	0x064D
(0839) 
(0840) 	case FS_FAT16 :
(0841) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    005A5 E088      LDI	R24,0x8
    005A6 E090      LDI	R25,0
    005A7 850C      LDD	R16,Y+12
    005A8 851D      LDD	R17,Y+13
    005A9 852E      LDD	R18,Y+14
    005AA 853F      LDD	R19,Y+15
    005AB 938A      ST	-Y,R24
    005AC 940E 4008 CALL	lsr32
    005AE 01F6      MOVW	R30,R12
    005AF 8C26      LDD	R2,Z+30
    005B0 8C37      LDD	R3,Z+31
    005B1 A040      LDD	R4,Z+32
    005B2 A051      LDD	R5,Z+33
    005B3 0E20      ADD	R2,R16
    005B4 1E31      ADC	R3,R17
    005B5 1E42      ADC	R4,R18
    005B6 1E53      ADC	R5,R19
    005B7 8248      ST	Y,R4
    005B8 8259      STD	Y+1,R5
    005B9 0191      MOVW	R18,R2
    005BA 018F      MOVW	R16,R30
    005BB DD7D      RCALL	ff.c:move_window
    005BC 2EA0      MOV	R10,R16
    005BD 2300      TST	R16
    005BE F009      BEQ	0x05C0
    005BF C089      RJMP	0x0649
(0842) 		p = &fs->win[clst * 2 % SS(fs)];
    005C0 EF4F      LDI	R20,0xFF
    005C1 E051      LDI	R21,1
    005C2 E060      LDI	R22,0
    005C3 E070      LDI	R23,0
    005C4 842C      LDD	R2,Y+12
    005C5 843D      LDD	R3,Y+13
    005C6 844E      LDD	R4,Y+14
    005C7 845F      LDD	R5,Y+15
    005C8 0C22      LSL	R2
    005C9 1C33      ROL	R3
    005CA 1C44      ROL	R4
    005CB 1C55      ROL	R5
    005CC 2224      AND	R2,R20
    005CD 2235      AND	R3,R21
    005CE 2246      AND	R4,R22
    005CF 2257      AND	R5,R23
    005D0 0151      MOVW	R10,R2
    005D1 01C6      MOVW	R24,R12
    005D2 968E      ADIW	R24,0x2E
    005D3 0EA8      ADD	R10,R24
    005D4 1EB9      ADC	R11,R25
(0843) 		return LD_WORD(p);
    005D5 01F5      MOVW	R30,R10
    005D6 8020      LD	R2,Z
    005D7 2433      CLR	R3
    005D8 8101      LDD	R16,Z+1
    005D9 2711      CLR	R17
    005DA 2F10      MOV	R17,R16
    005DB 2700      CLR	R16
    005DC 2902      OR	R16,R2
    005DD 2913      OR	R17,R3
    005DE 2722      CLR	R18
    005DF 2733      CLR	R19
    005E0 C06C      RJMP	0x064D
(0844) 
(0845) 	case FS_FAT32 :
(0846) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    005E1 E087      LDI	R24,7
    005E2 E090      LDI	R25,0
    005E3 850C      LDD	R16,Y+12
    005E4 851D      LDD	R17,Y+13
    005E5 852E      LDD	R18,Y+14
    005E6 853F      LDD	R19,Y+15
    005E7 938A      ST	-Y,R24
    005E8 940E 4008 CALL	lsr32
    005EA 01F6      MOVW	R30,R12
    005EB 8C26      LDD	R2,Z+30
    005EC 8C37      LDD	R3,Z+31
    005ED A040      LDD	R4,Z+32
    005EE A051      LDD	R5,Z+33
    005EF 0E20      ADD	R2,R16
    005F0 1E31      ADC	R3,R17
    005F1 1E42      ADC	R4,R18
    005F2 1E53      ADC	R5,R19
    005F3 8248      ST	Y,R4
    005F4 8259      STD	Y+1,R5
    005F5 0191      MOVW	R18,R2
    005F6 018F      MOVW	R16,R30
    005F7 DD41      RCALL	ff.c:move_window
    005F8 2EE0      MOV	R14,R16
    005F9 2300      TST	R16
    005FA F009      BEQ	0x05FC
    005FB C04D      RJMP	0x0649
(0847) 		p = &fs->win[clst * 4 % SS(fs)];
    005FC E082      LDI	R24,2
    005FD E090      LDI	R25,0
    005FE 850C      LDD	R16,Y+12
    005FF 851D      LDD	R17,Y+13
    00600 852E      LDD	R18,Y+14
    00601 853F      LDD	R19,Y+15
    00602 938A      ST	-Y,R24
    00603 940E 3FEF CALL	lsl32
    00605 0118      MOVW	R2,R16
    00606 0129      MOVW	R4,R18
    00607 EF4F      LDI	R20,0xFF
    00608 E051      LDI	R21,1
    00609 E060      LDI	R22,0
    0060A E070      LDI	R23,0
    0060B 2224      AND	R2,R20
    0060C 2235      AND	R3,R21
    0060D 2246      AND	R4,R22
    0060E 2257      AND	R5,R23
    0060F 0151      MOVW	R10,R2
    00610 01C6      MOVW	R24,R12
    00611 968E      ADIW	R24,0x2E
    00612 0EA8      ADD	R10,R24
    00613 1EB9      ADC	R11,R25
(0848) 		return LD_DWORD(p) & 0x0FFFFFFF;
    00614 E188      LDI	R24,0x18
    00615 E090      LDI	R25,0
    00616 01F5      MOVW	R30,R10
    00617 8103      LDD	R16,Z+3
    00618 2711      CLR	R17
    00619 2722      CLR	R18
    0061A 2733      CLR	R19
    0061B 938A      ST	-Y,R24
    0061C 940E 3FEF CALL	lsl32
    0061E 0118      MOVW	R2,R16
    0061F 0129      MOVW	R4,R18
    00620 01F5      MOVW	R30,R10
    00621 8062      LDD	R6,Z+2
    00622 2477      CLR	R7
    00623 2488      CLR	R8
    00624 2499      CLR	R9
    00625 0143      MOVW	R8,R6
    00626 2466      CLR	R6
    00627 2477      CLR	R7
    00628 2826      OR	R2,R6
    00629 2837      OR	R3,R7
    0062A 2848      OR	R4,R8
    0062B 2859      OR	R5,R9
    0062C 8061      LDD	R6,Z+1
    0062D 2477      CLR	R7
    0062E 2C76      MOV	R7,R6
    0062F 2466      CLR	R6
    00630 2488      CLR	R8
    00631 2499      CLR	R9
    00632 2826      OR	R2,R6
    00633 2837      OR	R3,R7
    00634 2848      OR	R4,R8
    00635 2859      OR	R5,R9
    00636 8060      LD	R6,Z
    00637 2477      CLR	R7
    00638 2488      CLR	R8
    00639 2499      CLR	R9
    0063A 2826      OR	R2,R6
    0063B 2837      OR	R3,R7
    0063C 2848      OR	R4,R8
    0063D 2859      OR	R5,R9
    0063E EF4F      LDI	R20,0xFF
    0063F EF5F      LDI	R21,0xFF
    00640 EF6F      LDI	R22,0xFF
    00641 E07F      LDI	R23,0xF
    00642 2224      AND	R2,R20
    00643 2235      AND	R3,R21
    00644 2246      AND	R4,R22
    00645 2257      AND	R5,R23
    00646 0181      MOVW	R16,R2
    00647 0192      MOVW	R18,R4
    00648 C004      RJMP	0x064D
(0849) 	}
(0850) 
(0851) 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    00649 EF0F      LDI	R16,0xFF
    0064A EF1F      LDI	R17,0xFF
    0064B EF2F      LDI	R18,0xFF
    0064C EF3F      LDI	R19,0xFF
    0064D 9622      ADIW	R28,2
    0064E 940E 3F62 CALL	pop_xgsetF0FC
    00650 9622      ADIW	R28,2
    00651 9508      RET
_put_fat:
  bc                   --> R12
  p                    --> R14
  res                  --> Y,+2
  val                  --> Y,+19
  clst                 --> Y,+15
  fs                   --> Y,+13
    00652 940E 3E28 CALL	push_arg4
    00654 940E 3F6D CALL	push_xgsetF0FC
    00656 9723      SBIW	R28,3
(0852) }
(0853) 
(0854) 
(0855) 
(0856) 
(0857) /*-----------------------------------------------------------------------*/
(0858) /* FAT access - Change value of a FAT entry                              */
(0859) /*-----------------------------------------------------------------------*/
(0860) #if !_FS_READONLY
(0861) 
(0862) FRESULT put_fat (
(0863) 	FATFS *fs,	/* File system object */
(0864) 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
(0865) 	DWORD val	/* New value to mark the cluster */
(0866) )
(0867) {
(0868) 	UINT bc;
(0869) 	BYTE *p;
(0870) 	FRESULT res;
(0871) 
(0872) 
(0873) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    00657 E042      LDI	R20,2
    00658 E050      LDI	R21,0
    00659 E060      LDI	R22,0
    0065A E070      LDI	R23,0
    0065B 842F      LDD	R2,Y+15
    0065C 8838      LDD	R3,Y+16
    0065D 8849      LDD	R4,Y+17
    0065E 885A      LDD	R5,Y+18
    0065F 1624      CP	R2,R20
    00660 0635      CPC	R3,R21
    00661 0646      CPC	R4,R22
    00662 0657      CPC	R5,R23
    00663 F080      BCS	0x0674
    00664 85ED      LDD	R30,Y+13
    00665 85FE      LDD	R31,Y+14
    00666 9676      ADIW	R30,0x16
    00667 8020      LD	R2,Z
    00668 8031      LDD	R3,Z+1
    00669 8042      LDD	R4,Z+2
    0066A 8053      LDD	R5,Z+3
    0066B 846F      LDD	R6,Y+15
    0066C 8878      LDD	R7,Y+16
    0066D 8889      LDD	R8,Y+17
    0066E 889A      LDD	R9,Y+18
    0066F 1462      CP	R6,R2
    00670 0473      CPC	R7,R3
    00671 0484      CPC	R8,R4
    00672 0495      CPC	R9,R5
    00673 F018      BCS	0x0677
(0874) 		res = FR_INT_ERR;
    00674 E082      LDI	R24,2
    00675 838A      STD	Y+2,R24
(0875) 
(0876) 	} else {
    00676 C194      RJMP	0x080B
(0877) 		switch (fs->fs_type) {
    00677 85ED      LDD	R30,Y+13
    00678 85FE      LDD	R31,Y+14
    00679 80A0      LD	R10,Z
    0067A 24BB      CLR	R11
    0067B 01C5      MOVW	R24,R10
    0067C 3081      CPI	R24,1
    0067D E0E0      LDI	R30,0
    0067E 079E      CPC	R25,R30
    0067F F059      BEQ	0x068B
    00680 3082      CPI	R24,2
    00681 E0E0      LDI	R30,0
    00682 079E      CPC	R25,R30
    00683 F409      BNE	0x0685
    00684 C0B0      RJMP	0x0735
    00685 3083      CPI	R24,3
    00686 E0E0      LDI	R30,0
    00687 079E      CPC	R25,R30
    00688 F409      BNE	0x068A
    00689 C0E7      RJMP	0x0771
    0068A C17A      RJMP	0x0805
(0878) 		case FS_FAT12 :
(0879) 			bc = clst; bc += bc / 2;
    0068B 84CF      LDD	R12,Y+15
    0068C 88D8      LDD	R13,Y+16
    0068D 0116      MOVW	R2,R12
    0068E 9436      LSR	R3
    0068F 9427      ROR	R2
    00690 0CC2      ADD	R12,R2
    00691 1CD3      ADC	R13,R3
(0880) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    00692 E029      LDI	R18,0x9
    00693 E030      LDI	R19,0
    00694 0186      MOVW	R16,R12
    00695 940E 4001 CALL	lsr16
    00697 0118      MOVW	R2,R16
    00698 2444      CLR	R4
    00699 2455      CLR	R5
    0069A 85ED      LDD	R30,Y+13
    0069B 85FE      LDD	R31,Y+14
    0069C 8C66      LDD	R6,Z+30
    0069D 8C77      LDD	R7,Z+31
    0069E A080      LDD	R8,Z+32
    0069F A091      LDD	R9,Z+33
    006A0 0C62      ADD	R6,R2
    006A1 1C73      ADC	R7,R3
    006A2 1C84      ADC	R8,R4
    006A3 1C95      ADC	R9,R5
    006A4 8288      ST	Y,R8
    006A5 8299      STD	Y+1,R9
    006A6 0193      MOVW	R18,R6
    006A7 018F      MOVW	R16,R30
    006A8 DC90      RCALL	ff.c:move_window
    006A9 830A      STD	Y+2,R16
(0881) 			if (res != FR_OK) break;
    006AA 2E00      MOV	R0,R16
    006AB 2300      TST	R16
    006AC F009      BEQ	0x06AE
    006AD C159      RJMP	0x0807
(0882) 			p = &fs->win[bc % SS(fs)];
    006AE 858D      LDD	R24,Y+13
    006AF 859E      LDD	R25,Y+14
    006B0 968E      ADIW	R24,0x2E
    006B1 01F6      MOVW	R30,R12
    006B2 70F1      ANDI	R31,1
    006B3 017F      MOVW	R14,R30
    006B4 0EE8      ADD	R14,R24
    006B5 1EF9      ADC	R15,R25
(0883) 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    006B6 842F      LDD	R2,Y+15
    006B7 8838      LDD	R3,Y+16
    006B8 8849      LDD	R4,Y+17
    006B9 885A      LDD	R5,Y+18
    006BA 93EF      PUSH	R30
    006BB 2DE2      MOV	R30,R2
    006BC 70E1      ANDI	R30,1
    006BD 91EF      POP	R30
    006BE F0B1      BEQ	0x06D5
    006BF 882B      LDD	R2,Y+19
    006C0 883C      LDD	R3,Y+20
    006C1 884D      LDD	R4,Y+21
    006C2 885E      LDD	R5,Y+22
    006C3 2433      CLR	R3
    006C4 0C22      LSL	R2
    006C5 1C33      ROL	R3
    006C6 0C22      LSL	R2
    006C7 1C33      ROL	R3
    006C8 0C22      LSL	R2
    006C9 1C33      ROL	R3
    006CA 0C22      LSL	R2
    006CB 1C33      ROL	R3
    006CC 01F7      MOVW	R30,R14
    006CD 8180      LD	R24,Z
    006CE 2799      CLR	R25
    006CF 708F      ANDI	R24,0xF
    006D0 7090      ANDI	R25,0
    006D1 015C      MOVW	R10,R24
    006D2 28A2      OR	R10,R2
    006D3 28B3      OR	R11,R3
    006D4 C006      RJMP	0x06DB
    006D5 882B      LDD	R2,Y+19
    006D6 883C      LDD	R3,Y+20
    006D7 884D      LDD	R4,Y+21
    006D8 885E      LDD	R5,Y+22
    006D9 2CA2      MOV	R10,R2
    006DA 24BB      CLR	R11
    006DB 01F7      MOVW	R30,R14
    006DC 82A0      ST	Z,R10
(0884) 			bc++;
    006DD 01C6      MOVW	R24,R12
    006DE 9601      ADIW	R24,1
    006DF 016C      MOVW	R12,R24
(0885) 			fs->wflag = 1;
    006E0 E081      LDI	R24,1
    006E1 85ED      LDD	R30,Y+13
    006E2 85FE      LDD	R31,Y+14
    006E3 8384      STD	Z+4,R24
(0886) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006E4 E029      LDI	R18,0x9
    006E5 E030      LDI	R19,0
    006E6 0186      MOVW	R16,R12
    006E7 940E 4001 CALL	lsr16
    006E9 0118      MOVW	R2,R16
    006EA 2444      CLR	R4
    006EB 2455      CLR	R5
    006EC 85ED      LDD	R30,Y+13
    006ED 85FE      LDD	R31,Y+14
    006EE 8C66      LDD	R6,Z+30
    006EF 8C77      LDD	R7,Z+31
    006F0 A080      LDD	R8,Z+32
    006F1 A091      LDD	R9,Z+33
    006F2 0C62      ADD	R6,R2
    006F3 1C73      ADC	R7,R3
    006F4 1C84      ADC	R8,R4
    006F5 1C95      ADC	R9,R5
    006F6 8288      ST	Y,R8
    006F7 8299      STD	Y+1,R9
    006F8 0193      MOVW	R18,R6
    006F9 018F      MOVW	R16,R30
    006FA DC3E      RCALL	ff.c:move_window
    006FB 830A      STD	Y+2,R16
(0887) 			if (res != FR_OK) break;
    006FC 2E00      MOV	R0,R16
    006FD 2300      TST	R16
    006FE F009      BEQ	0x0700
    006FF C107      RJMP	0x0807
(0888) 			p = &fs->win[bc % SS(fs)];
    00700 858D      LDD	R24,Y+13
    00701 859E      LDD	R25,Y+14
    00702 968E      ADIW	R24,0x2E
    00703 01F6      MOVW	R30,R12
    00704 70F1      ANDI	R31,1
    00705 017F      MOVW	R14,R30
    00706 0EE8      ADD	R14,R24
    00707 1EF9      ADC	R15,R25
(0889) 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    00708 842F      LDD	R2,Y+15
    00709 8838      LDD	R3,Y+16
    0070A 8849      LDD	R4,Y+17
    0070B 885A      LDD	R5,Y+18
    0070C 93EF      PUSH	R30
    0070D 2DE2      MOV	R30,R2
    0070E 70E1      ANDI	R30,1
    0070F 91EF      POP	R30
    00710 F061      BEQ	0x071D
    00711 E084      LDI	R24,4
    00712 E090      LDI	R25,0
    00713 890B      LDD	R16,Y+19
    00714 891C      LDD	R17,Y+20
    00715 892D      LDD	R18,Y+21
    00716 893E      LDD	R19,Y+22
    00717 938A      ST	-Y,R24
    00718 940E 4008 CALL	lsr32
    0071A 2EC0      MOV	R12,R16
    0071B 24DD      CLR	R13
    0071C C015      RJMP	0x0732
    0071D E088      LDI	R24,0x8
    0071E E090      LDI	R25,0
    0071F 890B      LDD	R16,Y+19
    00720 891C      LDD	R17,Y+20
    00721 892D      LDD	R18,Y+21
    00722 893E      LDD	R19,Y+22
    00723 938A      ST	-Y,R24
    00724 940E 4008 CALL	lsr32
    00726 2F80      MOV	R24,R16
    00727 2799      CLR	R25
    00728 708F      ANDI	R24,0xF
    00729 7090      ANDI	R25,0
    0072A 01F7      MOVW	R30,R14
    0072B 81E0      LD	R30,Z
    0072C 27FF      CLR	R31
    0072D 7FE0      ANDI	R30,0xF0
    0072E 70F0      ANDI	R31,0
    0072F 016F      MOVW	R12,R30
    00730 2AC8      OR	R12,R24
    00731 2AD9      OR	R13,R25
    00732 01F7      MOVW	R30,R14
    00733 82C0      ST	Z,R12
(0890) 			break;
    00734 C0D2      RJMP	0x0807
(0891) 
(0892) 		case FS_FAT16 :
(0893) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    00735 E088      LDI	R24,0x8
    00736 E090      LDI	R25,0
    00737 850F      LDD	R16,Y+15
    00738 8918      LDD	R17,Y+16
    00739 8929      LDD	R18,Y+17
    0073A 893A      LDD	R19,Y+18
    0073B 938A      ST	-Y,R24
    0073C 940E 4008 CALL	lsr32
    0073E 85ED      LDD	R30,Y+13
    0073F 85FE      LDD	R31,Y+14
    00740 8C26      LDD	R2,Z+30
    00741 8C37      LDD	R3,Z+31
    00742 A040      LDD	R4,Z+32
    00743 A051      LDD	R5,Z+33
    00744 0E20      ADD	R2,R16
    00745 1E31      ADC	R3,R17
    00746 1E42      ADC	R4,R18
    00747 1E53      ADC	R5,R19
    00748 8248      ST	Y,R4
    00749 8259      STD	Y+1,R5
    0074A 0191      MOVW	R18,R2
    0074B 018F      MOVW	R16,R30
    0074C DBEC      RCALL	ff.c:move_window
    0074D 2EC0      MOV	R12,R16
    0074E 82CA      STD	Y+2,R12
(0894) 			if (res != FR_OK) break;
    0074F 2C0C      MOV	R0,R12
    00750 2300      TST	R16
    00751 F009      BEQ	0x0753
    00752 C0B4      RJMP	0x0807
(0895) 			p = &fs->win[clst * 2 % SS(fs)];
    00753 EF4F      LDI	R20,0xFF
    00754 E051      LDI	R21,1
    00755 E060      LDI	R22,0
    00756 E070      LDI	R23,0
    00757 842F      LDD	R2,Y+15
    00758 8838      LDD	R3,Y+16
    00759 8849      LDD	R4,Y+17
    0075A 885A      LDD	R5,Y+18
    0075B 0C22      LSL	R2
    0075C 1C33      ROL	R3
    0075D 1C44      ROL	R4
    0075E 1C55      ROL	R5
    0075F 2224      AND	R2,R20
    00760 2235      AND	R3,R21
    00761 2246      AND	R4,R22
    00762 2257      AND	R5,R23
    00763 0171      MOVW	R14,R2
    00764 858D      LDD	R24,Y+13
    00765 859E      LDD	R25,Y+14
    00766 968E      ADIW	R24,0x2E
    00767 0EE8      ADD	R14,R24
    00768 1EF9      ADC	R15,R25
(0896) 			ST_WORD(p, (WORD)val);
    00769 882B      LDD	R2,Y+19
    0076A 883C      LDD	R3,Y+20
    0076B 01F7      MOVW	R30,R14
    0076C 8220      ST	Z,R2
    0076D 2C23      MOV	R2,R3
    0076E 2433      CLR	R3
    0076F 8221      STD	Z+1,R2
(0897) 			break;
    00770 C096      RJMP	0x0807
(0898) 
(0899) 		case FS_FAT32 :
(0900) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    00771 E087      LDI	R24,7
    00772 E090      LDI	R25,0
    00773 850F      LDD	R16,Y+15
    00774 8918      LDD	R17,Y+16
    00775 8929      LDD	R18,Y+17
    00776 893A      LDD	R19,Y+18
    00777 938A      ST	-Y,R24
    00778 940E 4008 CALL	lsr32
    0077A 85ED      LDD	R30,Y+13
    0077B 85FE      LDD	R31,Y+14
    0077C 8C26      LDD	R2,Z+30
    0077D 8C37      LDD	R3,Z+31
    0077E A040      LDD	R4,Z+32
    0077F A051      LDD	R5,Z+33
    00780 0E20      ADD	R2,R16
    00781 1E31      ADC	R3,R17
    00782 1E42      ADC	R4,R18
    00783 1E53      ADC	R5,R19
    00784 8248      ST	Y,R4
    00785 8259      STD	Y+1,R5
    00786 0191      MOVW	R18,R2
    00787 018F      MOVW	R16,R30
    00788 DBB0      RCALL	ff.c:move_window
    00789 2EC0      MOV	R12,R16
    0078A 82CA      STD	Y+2,R12
(0901) 			if (res != FR_OK) break;
    0078B 2C0C      MOV	R0,R12
    0078C 2300      TST	R16
    0078D F009      BEQ	0x078F
    0078E C078      RJMP	0x0807
(0902) 			p = &fs->win[clst * 4 % SS(fs)];
    0078F E082      LDI	R24,2
    00790 E090      LDI	R25,0
    00791 850F      LDD	R16,Y+15
    00792 8918      LDD	R17,Y+16
    00793 8929      LDD	R18,Y+17
    00794 893A      LDD	R19,Y+18
    00795 938A      ST	-Y,R24
    00796 940E 3FEF CALL	lsl32
    00798 0118      MOVW	R2,R16
    00799 0129      MOVW	R4,R18
    0079A EF4F      LDI	R20,0xFF
    0079B E051      LDI	R21,1
    0079C E060      LDI	R22,0
    0079D E070      LDI	R23,0
    0079E 2224      AND	R2,R20
    0079F 2235      AND	R3,R21
    007A0 2246      AND	R4,R22
    007A1 2257      AND	R5,R23
    007A2 0171      MOVW	R14,R2
    007A3 858D      LDD	R24,Y+13
    007A4 859E      LDD	R25,Y+14
    007A5 968E      ADIW	R24,0x2E
    007A6 0EE8      ADD	R14,R24
    007A7 1EF9      ADC	R15,R25
(0903) 			val |= LD_DWORD(p) & 0xF0000000;
    007A8 E188      LDI	R24,0x18
    007A9 E090      LDI	R25,0
    007AA 01F7      MOVW	R30,R14
    007AB 8103      LDD	R16,Z+3
    007AC 2711      CLR	R17
    007AD 2722      CLR	R18
    007AE 2733      CLR	R19
    007AF 938A      ST	-Y,R24
    007B0 940E 3FEF CALL	lsl32
    007B2 0118      MOVW	R2,R16
    007B3 0129      MOVW	R4,R18
    007B4 01F7      MOVW	R30,R14
    007B5 8062      LDD	R6,Z+2
    007B6 2477      CLR	R7
    007B7 2488      CLR	R8
    007B8 2499      CLR	R9
    007B9 0143      MOVW	R8,R6
    007BA 2466      CLR	R6
    007BB 2477      CLR	R7
    007BC 2826      OR	R2,R6
    007BD 2837      OR	R3,R7
    007BE 2848      OR	R4,R8
    007BF 2859      OR	R5,R9
    007C0 8061      LDD	R6,Z+1
    007C1 2477      CLR	R7
    007C2 2C76      MOV	R7,R6
    007C3 2466      CLR	R6
    007C4 2488      CLR	R8
    007C5 2499      CLR	R9
    007C6 2826      OR	R2,R6
    007C7 2837      OR	R3,R7
    007C8 2848      OR	R4,R8
    007C9 2859      OR	R5,R9
    007CA 8060      LD	R6,Z
    007CB 2477      CLR	R7
    007CC 2488      CLR	R8
    007CD 2499      CLR	R9
    007CE 2826      OR	R2,R6
    007CF 2837      OR	R3,R7
    007D0 2848      OR	R4,R8
    007D1 2859      OR	R5,R9
    007D2 E040      LDI	R20,0
    007D3 E050      LDI	R21,0
    007D4 E060      LDI	R22,0
    007D5 EF70      LDI	R23,0xF0
    007D6 2224      AND	R2,R20
    007D7 2235      AND	R3,R21
    007D8 2246      AND	R4,R22
    007D9 2257      AND	R5,R23
    007DA 886B      LDD	R6,Y+19
    007DB 887C      LDD	R7,Y+20
    007DC 888D      LDD	R8,Y+21
    007DD 889E      LDD	R9,Y+22
    007DE 2862      OR	R6,R2
    007DF 2873      OR	R7,R3
    007E0 2884      OR	R8,R4
    007E1 2895      OR	R9,R5
    007E2 8A6B      STD	Y+19,R6
    007E3 8A7C      STD	Y+20,R7
    007E4 8A8D      STD	Y+21,R8
    007E5 8A9E      STD	Y+22,R9
(0904) 			ST_DWORD(p, val);
    007E6 882B      LDD	R2,Y+19
    007E7 883C      LDD	R3,Y+20
    007E8 884D      LDD	R4,Y+21
    007E9 885E      LDD	R5,Y+22
    007EA 8220      ST	Z,R2
    007EB 2C23      MOV	R2,R3
    007EC 2433      CLR	R3
    007ED 9631      ADIW	R30,1
    007EE 8220      ST	Z,R2
    007EF 882B      LDD	R2,Y+19
    007F0 883C      LDD	R3,Y+20
    007F1 884D      LDD	R4,Y+21
    007F2 885E      LDD	R5,Y+22
    007F3 0112      MOVW	R2,R4
    007F4 2444      CLR	R4
    007F5 2455      CLR	R5
    007F6 01F7      MOVW	R30,R14
    007F7 9632      ADIW	R30,2
    007F8 8220      ST	Z,R2
    007F9 E188      LDI	R24,0x18
    007FA E090      LDI	R25,0
    007FB 890B      LDD	R16,Y+19
    007FC 891C      LDD	R17,Y+20
    007FD 892D      LDD	R18,Y+21
    007FE 893E      LDD	R19,Y+22
    007FF 938A      ST	-Y,R24
    00800 940E 4008 CALL	lsr32
    00802 01F7      MOVW	R30,R14
    00803 8303      STD	Z+3,R16
(0905) 			break;
    00804 C002      RJMP	0x0807
(0906) 
(0907) 		default :
(0908) 			res = FR_INT_ERR;
    00805 E082      LDI	R24,2
    00806 838A      STD	Y+2,R24
(0909) 		}
(0910) 		fs->wflag = 1;
    00807 E081      LDI	R24,1
    00808 85ED      LDD	R30,Y+13
    00809 85FE      LDD	R31,Y+14
    0080A 8384      STD	Z+4,R24
(0911) 	}
(0912) 
(0913) 	return res;
    0080B 810A      LDD	R16,Y+2
    0080C 9623      ADIW	R28,3
    0080D 940E 3F62 CALL	pop_xgsetF0FC
    0080F 9624      ADIW	R28,4
    00810 9508      RET
ff.c:remove_chain:
  res                  --> R10
  nxt                  --> Y,+6
  clst                 --> Y,+18
  fs                   --> R12
    00811 933A      ST	-Y,R19
    00812 932A      ST	-Y,R18
    00813 940E 3FA8 CALL	push_xgsetF03C
    00815 0168      MOVW	R12,R16
    00816 972A      SBIW	R28,0xA
(0914) }
(0915) #endif /* !_FS_READONLY */
(0916) 
(0917) 
(0918) 
(0919) 
(0920) /*-----------------------------------------------------------------------*/
(0921) /* FAT handling - Remove a cluster chain                                 */
(0922) /*-----------------------------------------------------------------------*/
(0923) #if !_FS_READONLY
(0924) static
(0925) FRESULT remove_chain (
(0926) 	FATFS *fs,			/* File system object */
(0927) 	DWORD clst			/* Cluster# to remove a chain from */
(0928) )
(0929) {
(0930) 	FRESULT res;
(0931) 	DWORD nxt;
(0932) #if _USE_ERASE
(0933) 	DWORD scl = clst, ecl = clst, resion[2];
(0934) #endif
(0935) 
(0936) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    00817 E042      LDI	R20,2
    00818 E050      LDI	R21,0
    00819 E060      LDI	R22,0
    0081A E070      LDI	R23,0
    0081B 882A      LDD	R2,Y+18
    0081C 883B      LDD	R3,Y+19
    0081D 884C      LDD	R4,Y+20
    0081E 885D      LDD	R5,Y+21
    0081F 1624      CP	R2,R20
    00820 0635      CPC	R3,R21
    00821 0646      CPC	R4,R22
    00822 0657      CPC	R5,R23
    00823 F078      BCS	0x0833
    00824 01F6      MOVW	R30,R12
    00825 9676      ADIW	R30,0x16
    00826 8020      LD	R2,Z
    00827 8031      LDD	R3,Z+1
    00828 8042      LDD	R4,Z+2
    00829 8053      LDD	R5,Z+3
    0082A 886A      LDD	R6,Y+18
    0082B 887B      LDD	R7,Y+19
    0082C 888C      LDD	R8,Y+20
    0082D 889D      LDD	R9,Y+21
    0082E 1462      CP	R6,R2
    0082F 0473      CPC	R7,R3
    00830 0484      CPC	R8,R4
    00831 0495      CPC	R9,R5
    00832 F018      BCS	0x0836
(0937) 		res = FR_INT_ERR;
    00833 E082      LDI	R24,2
    00834 2EA8      MOV	R10,R24
(0938) 
(0939) 	} else {
    00835 C088      RJMP	0x08BE
(0940) 		res = FR_OK;
    00836 24AA      CLR	R10
    00837 C076      RJMP	0x08AE
(0941) 		while (clst < fs->n_fatent) {			/* Not a last link? */
(0942) 			nxt = get_fat(fs, clst);			/* Get cluster status */
    00838 882A      LDD	R2,Y+18
    00839 883B      LDD	R3,Y+19
    0083A 884C      LDD	R4,Y+20
    0083B 885D      LDD	R5,Y+21
    0083C 8248      ST	Y,R4
    0083D 8259      STD	Y+1,R5
    0083E 0191      MOVW	R18,R2
    0083F 0186      MOVW	R16,R12
    00840 DCC1      RCALL	_get_fat
    00841 830E      STD	Y+6,R16
    00842 831F      STD	Y+7,R17
    00843 8728      STD	Y+8,R18
    00844 8739      STD	Y+9,R19
(0943) 			if (nxt == 0) break;				/* Empty cluster? */
    00845 802E      LDD	R2,Y+6
    00846 803F      LDD	R3,Y+7
    00847 8448      LDD	R4,Y+8
    00848 8459      LDD	R5,Y+9
    00849 9488      BCLR	0
    0084A 2022      TST	R2
    0084B 0432      CPC	R3,R2
    0084C 0442      CPC	R4,R2
    0084D 0452      CPC	R5,R2
    0084E F409      BNE	0x0850
    0084F C06E      RJMP	0x08BE
(0944) 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    00850 E041      LDI	R20,1
    00851 E050      LDI	R21,0
    00852 E060      LDI	R22,0
    00853 E070      LDI	R23,0
    00854 802E      LDD	R2,Y+6
    00855 803F      LDD	R3,Y+7
    00856 8448      LDD	R4,Y+8
    00857 8459      LDD	R5,Y+9
    00858 1624      CP	R2,R20
    00859 0635      CPC	R3,R21
    0085A 0646      CPC	R4,R22
    0085B 0657      CPC	R5,R23
    0085C F419      BNE	0x0860
    0085D E082      LDI	R24,2
    0085E 2EA8      MOV	R10,R24
    0085F C05E      RJMP	0x08BE
(0945) 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    00860 EF4F      LDI	R20,0xFF
    00861 EF5F      LDI	R21,0xFF
    00862 EF6F      LDI	R22,0xFF
    00863 EF7F      LDI	R23,0xFF
    00864 802E      LDD	R2,Y+6
    00865 803F      LDD	R3,Y+7
    00866 8448      LDD	R4,Y+8
    00867 8459      LDD	R5,Y+9
    00868 1624      CP	R2,R20
    00869 0635      CPC	R3,R21
    0086A 0646      CPC	R4,R22
    0086B 0657      CPC	R5,R23
    0086C F419      BNE	0x0870
    0086D 24AA      CLR	R10
    0086E 94A3      INC	R10
    0086F C04E      RJMP	0x08BE
(0946) 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    00870 E080      LDI	R24,0
    00871 838A      STD	Y+2,R24
    00872 838B      STD	Y+3,R24
    00873 838C      STD	Y+4,R24
    00874 838D      STD	Y+5,R24
    00875 882A      LDD	R2,Y+18
    00876 883B      LDD	R3,Y+19
    00877 884C      LDD	R4,Y+20
    00878 885D      LDD	R5,Y+21
    00879 8248      ST	Y,R4
    0087A 8259      STD	Y+1,R5
    0087B 0191      MOVW	R18,R2
    0087C 0186      MOVW	R16,R12
    0087D DDD4      RCALL	_put_fat
    0087E 2EA0      MOV	R10,R16
(0947) 			if (res != FR_OK) break;
    0087F 2300      TST	R16
    00880 F009      BEQ	0x0882
    00881 C03C      RJMP	0x08BE
(0948) 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    00882 EF4F      LDI	R20,0xFF
    00883 EF5F      LDI	R21,0xFF
    00884 EF6F      LDI	R22,0xFF
    00885 EF7F      LDI	R23,0xFF
    00886 01F6      MOVW	R30,R12
    00887 8426      LDD	R2,Z+14
    00888 8437      LDD	R3,Z+15
    00889 8840      LDD	R4,Z+16
    0088A 8851      LDD	R5,Z+17
    0088B 1624      CP	R2,R20
    0088C 0635      CPC	R3,R21
    0088D 0646      CPC	R4,R22
    0088E 0657      CPC	R5,R23
    0088F F0B1      BEQ	0x08A6
(0949) 				fs->free_clust++;
    00890 01CF      MOVW	R24,R30
    00891 960E      ADIW	R24,0xE
    00892 E041      LDI	R20,1
    00893 E050      LDI	R21,0
    00894 E060      LDI	R22,0
    00895 E070      LDI	R23,0
    00896 01FC      MOVW	R30,R24
    00897 8020      LD	R2,Z
    00898 8031      LDD	R3,Z+1
    00899 8042      LDD	R4,Z+2
    0089A 8053      LDD	R5,Z+3
    0089B 0E24      ADD	R2,R20
    0089C 1E35      ADC	R3,R21
    0089D 1E46      ADC	R4,R22
    0089E 1E57      ADC	R5,R23
    0089F 8220      ST	Z,R2
    008A0 8231      STD	Z+1,R3
    008A1 8242      STD	Z+2,R4
    008A2 8253      STD	Z+3,R5
(0950) 				fs->fsi_flag = 1;
    008A3 E081      LDI	R24,1
    008A4 01F6      MOVW	R30,R12
    008A5 8385      STD	Z+5,R24
(0951) 			}
(0952) #if _USE_ERASE
(0953) 			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
(0954) 				ecl = nxt;
(0955) 			} else {				/* End of contiguous clusters */ 
(0956) 				resion[0] = clust2sect(fs, scl);					/* Start sector */
(0957) 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
(0958) 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
(0959) 				scl = ecl = nxt;
(0960) 			}
(0961) #endif
(0962) 			clst = nxt;	/* Next cluster */
    008A6 802E      LDD	R2,Y+6
    008A7 803F      LDD	R3,Y+7
    008A8 8448      LDD	R4,Y+8
    008A9 8459      LDD	R5,Y+9
    008AA 8A2A      STD	Y+18,R2
    008AB 8A3B      STD	Y+19,R3
    008AC 8A4C      STD	Y+20,R4
    008AD 8A5D      STD	Y+21,R5
    008AE 01F6      MOVW	R30,R12
    008AF 9676      ADIW	R30,0x16
    008B0 8020      LD	R2,Z
    008B1 8031      LDD	R3,Z+1
    008B2 8042      LDD	R4,Z+2
    008B3 8053      LDD	R5,Z+3
    008B4 886A      LDD	R6,Y+18
    008B5 887B      LDD	R7,Y+19
    008B6 888C      LDD	R8,Y+20
    008B7 889D      LDD	R9,Y+21
    008B8 1462      CP	R6,R2
    008B9 0473      CPC	R7,R3
    008BA 0484      CPC	R8,R4
    008BB 0495      CPC	R9,R5
    008BC F408      BCC	0x08BE
    008BD CF7A      RJMP	0x0838
(0963) 		}
(0964) 	}
(0965) 
(0966) 	return res;
    008BE 2D0A      MOV	R16,R10
    008BF 962A      ADIW	R28,0xA
    008C0 940E 3FB1 CALL	pop_xgsetF03C
    008C2 9622      ADIW	R28,2
    008C3 9508      RET
ff.c:create_chain:
  res                  --> R10
  scl                  --> Y,+14
  cs                   --> Y,+10
  ncl                  --> Y,+6
  clst                 --> Y,+32
  fs                   --> R12
    008C4 933A      ST	-Y,R19
    008C5 932A      ST	-Y,R18
    008C6 940E 3F6D CALL	push_xgsetF0FC
    008C8 0168      MOVW	R12,R16
    008C9 9766      SBIW	R28,0x16
(0967) }
(0968) #endif
(0969) 
(0970) 
(0971) 
(0972) 
(0973) /*-----------------------------------------------------------------------*/
(0974) /* FAT handling - Stretch or Create a cluster chain                      */
(0975) /*-----------------------------------------------------------------------*/
(0976) #if !_FS_READONLY
(0977) static
(0978) DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
(0979) 	FATFS *fs,			/* File system object */
(0980) 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
(0981) )
(0982) {
(0983) 	DWORD cs, ncl, scl;
(0984) 	FRESULT res;
(0985) 
(0986) 
(0987) 	if (clst == 0) {		/* Create a new chain */
    008CA A028      LDD	R2,Y+32
    008CB A039      LDD	R3,Y+33
    008CC A04A      LDD	R4,Y+34
    008CD A05B      LDD	R5,Y+35
    008CE 9488      BCLR	0
    008CF 2022      TST	R2
    008D0 0432      CPC	R3,R2
    008D1 0442      CPC	R4,R2
    008D2 0452      CPC	R5,R2
    008D3 F559      BNE	0x08FF
(0988) 		scl = fs->last_clust;			/* Get suggested start point */
    008D4 01F6      MOVW	R30,R12
    008D5 963A      ADIW	R30,0xA
    008D6 8020      LD	R2,Z
    008D7 8031      LDD	R3,Z+1
    008D8 8042      LDD	R4,Z+2
    008D9 8053      LDD	R5,Z+3
    008DA 862E      STD	Y+14,R2
    008DB 863F      STD	Y+15,R3
    008DC 8A48      STD	Y+16,R4
    008DD 8A59      STD	Y+17,R5
(0989) 		if (!scl || scl >= fs->n_fatent) scl = 1;
    008DE 842E      LDD	R2,Y+14
    008DF 843F      LDD	R3,Y+15
    008E0 8848      LDD	R4,Y+16
    008E1 8859      LDD	R5,Y+17
    008E2 9488      BCLR	0
    008E3 2022      TST	R2
    008E4 0432      CPC	R3,R2
    008E5 0442      CPC	R4,R2
    008E6 0452      CPC	R5,R2
    008E7 F081      BEQ	0x08F8
    008E8 01F6      MOVW	R30,R12
    008E9 9676      ADIW	R30,0x16
    008EA 8020      LD	R2,Z
    008EB 8031      LDD	R3,Z+1
    008EC 8042      LDD	R4,Z+2
    008ED 8053      LDD	R5,Z+3
    008EE 846E      LDD	R6,Y+14
    008EF 847F      LDD	R7,Y+15
    008F0 8888      LDD	R8,Y+16
    008F1 8899      LDD	R9,Y+17
    008F2 1462      CP	R6,R2
    008F3 0473      CPC	R7,R3
    008F4 0484      CPC	R8,R4
    008F5 0495      CPC	R9,R5
    008F6 F408      BCC	0x08F8
    008F7 C040      RJMP	0x0938
    008F8 E081      LDI	R24,1
    008F9 878E      STD	Y+14,R24
    008FA E080      LDI	R24,0
    008FB 878F      STD	Y+15,R24
    008FC 8B88      STD	Y+16,R24
    008FD 8B89      STD	Y+17,R24
(0990) 	}
    008FE C039      RJMP	0x0938
(0991) 	else {					/* Stretch the current chain */
(0992) 		cs = get_fat(fs, clst);			/* Check the cluster status */
    008FF A028      LDD	R2,Y+32
    00900 A039      LDD	R3,Y+33
    00901 A04A      LDD	R4,Y+34
    00902 A05B      LDD	R5,Y+35
    00903 8248      ST	Y,R4
    00904 8259      STD	Y+1,R5
    00905 0191      MOVW	R18,R2
    00906 0186      MOVW	R16,R12
    00907 DBFA      RCALL	_get_fat
    00908 870A      STD	Y+10,R16
    00909 871B      STD	Y+11,R17
    0090A 872C      STD	Y+12,R18
    0090B 873D      STD	Y+13,R19
(0993) 		if (cs < 2) return 1;			/* It is an invalid cluster */
    0090C E042      LDI	R20,2
    0090D E050      LDI	R21,0
    0090E E060      LDI	R22,0
    0090F E070      LDI	R23,0
    00910 842A      LDD	R2,Y+10
    00911 843B      LDD	R3,Y+11
    00912 844C      LDD	R4,Y+12
    00913 845D      LDD	R5,Y+13
    00914 1624      CP	R2,R20
    00915 0635      CPC	R3,R21
    00916 0646      CPC	R4,R22
    00917 0657      CPC	R5,R23
    00918 F428      BCC	0x091E
    00919 E001      LDI	R16,1
    0091A E010      LDI	R17,0
    0091B E020      LDI	R18,0
    0091C E030      LDI	R19,0
    0091D C119      RJMP	0x0A37
(0994) 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    0091E 01F6      MOVW	R30,R12
    0091F 9676      ADIW	R30,0x16
    00920 8020      LD	R2,Z
    00921 8031      LDD	R3,Z+1
    00922 8042      LDD	R4,Z+2
    00923 8053      LDD	R5,Z+3
    00924 846A      LDD	R6,Y+10
    00925 847B      LDD	R7,Y+11
    00926 848C      LDD	R8,Y+12
    00927 849D      LDD	R9,Y+13
    00928 1462      CP	R6,R2
    00929 0473      CPC	R7,R3
    0092A 0484      CPC	R8,R4
    0092B 0495      CPC	R9,R5
    0092C F418      BCC	0x0930
    0092D 0183      MOVW	R16,R6
    0092E 0194      MOVW	R18,R8
    0092F C107      RJMP	0x0A37
(0995) 		scl = clst;
    00930 A028      LDD	R2,Y+32
    00931 A039      LDD	R3,Y+33
    00932 A04A      LDD	R4,Y+34
    00933 A05B      LDD	R5,Y+35
    00934 862E      STD	Y+14,R2
    00935 863F      STD	Y+15,R3
    00936 8A48      STD	Y+16,R4
    00937 8A59      STD	Y+17,R5
(0996) 	}
(0997) 
(0998) 	ncl = scl;				/* Start cluster */
    00938 842E      LDD	R2,Y+14
    00939 843F      LDD	R3,Y+15
    0093A 8848      LDD	R4,Y+16
    0093B 8859      LDD	R5,Y+17
    0093C 822E      STD	Y+6,R2
    0093D 823F      STD	Y+7,R3
    0093E 8648      STD	Y+8,R4
    0093F 8659      STD	Y+9,R5
(0999) 	for (;;) {
(1000) 		ncl++;							/* Next cluster */
    00940 E041      LDI	R20,1
    00941 E050      LDI	R21,0
    00942 E060      LDI	R22,0
    00943 E070      LDI	R23,0
    00944 802E      LDD	R2,Y+6
    00945 803F      LDD	R3,Y+7
    00946 8448      LDD	R4,Y+8
    00947 8459      LDD	R5,Y+9
    00948 0E24      ADD	R2,R20
    00949 1E35      ADC	R3,R21
    0094A 1E46      ADC	R4,R22
    0094B 1E57      ADC	R5,R23
    0094C 822E      STD	Y+6,R2
    0094D 823F      STD	Y+7,R3
    0094E 8648      STD	Y+8,R4
    0094F 8659      STD	Y+9,R5
(1001) 		if (ncl >= fs->n_fatent) {		/* Wrap around */
    00950 01F6      MOVW	R30,R12
    00951 9676      ADIW	R30,0x16
    00952 8020      LD	R2,Z
    00953 8031      LDD	R3,Z+1
    00954 8042      LDD	R4,Z+2
    00955 8053      LDD	R5,Z+3
    00956 806E      LDD	R6,Y+6
    00957 807F      LDD	R7,Y+7
    00958 8488      LDD	R8,Y+8
    00959 8499      LDD	R9,Y+9
    0095A 1462      CP	R6,R2
    0095B 0473      CPC	R7,R3
    0095C 0484      CPC	R8,R4
    0095D 0495      CPC	R9,R5
    0095E F0C0      BCS	0x0977
(1002) 			ncl = 2;
    0095F E082      LDI	R24,2
    00960 838E      STD	Y+6,R24
    00961 E080      LDI	R24,0
    00962 838F      STD	Y+7,R24
    00963 8788      STD	Y+8,R24
    00964 8789      STD	Y+9,R24
(1003) 			if (ncl > scl) return 0;	/* No free cluster */
    00965 842E      LDD	R2,Y+14
    00966 843F      LDD	R3,Y+15
    00967 8848      LDD	R4,Y+16
    00968 8859      LDD	R5,Y+17
    00969 806E      LDD	R6,Y+6
    0096A 807F      LDD	R7,Y+7
    0096B 8488      LDD	R8,Y+8
    0096C 8499      LDD	R9,Y+9
    0096D 1426      CP	R2,R6
    0096E 0437      CPC	R3,R7
    0096F 0448      CPC	R4,R8
    00970 0459      CPC	R5,R9
    00971 F428      BCC	0x0977
    00972 E000      LDI	R16,0
    00973 E010      LDI	R17,0
    00974 E020      LDI	R18,0
    00975 E030      LDI	R19,0
    00976 C0C0      RJMP	0x0A37
(1004) 		}
(1005) 		cs = get_fat(fs, ncl);			/* Get the cluster status */
    00977 802E      LDD	R2,Y+6
    00978 803F      LDD	R3,Y+7
    00979 8448      LDD	R4,Y+8
    0097A 8459      LDD	R5,Y+9
    0097B 8248      ST	Y,R4
    0097C 8259      STD	Y+1,R5
    0097D 0191      MOVW	R18,R2
    0097E 0186      MOVW	R16,R12
    0097F DB82      RCALL	_get_fat
    00980 870A      STD	Y+10,R16
    00981 871B      STD	Y+11,R17
    00982 872C      STD	Y+12,R18
    00983 873D      STD	Y+13,R19
(1006) 		if (cs == 0) break;				/* Found a free cluster */
    00984 842A      LDD	R2,Y+10
    00985 843B      LDD	R3,Y+11
    00986 844C      LDD	R4,Y+12
    00987 845D      LDD	R5,Y+13
    00988 9488      BCLR	0
    00989 2022      TST	R2
    0098A 0432      CPC	R3,R2
    0098B 0442      CPC	R4,R2
    0098C 0452      CPC	R5,R2
    0098D F409      BNE	0x098F
    0098E C02E      RJMP	0x09BD
(1007) 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    0098F EF4F      LDI	R20,0xFF
    00990 EF5F      LDI	R21,0xFF
    00991 EF6F      LDI	R22,0xFF
    00992 EF7F      LDI	R23,0xFF
    00993 842A      LDD	R2,Y+10
    00994 843B      LDD	R3,Y+11
    00995 844C      LDD	R4,Y+12
    00996 845D      LDD	R5,Y+13
    00997 1624      CP	R2,R20
    00998 0635      CPC	R3,R21
    00999 0646      CPC	R4,R22
    0099A 0657      CPC	R5,R23
    0099B F049      BEQ	0x09A5
    0099C E041      LDI	R20,1
    0099D E050      LDI	R21,0
    0099E E060      LDI	R22,0
    0099F E070      LDI	R23,0
    009A0 1624      CP	R2,R20
    009A1 0635      CPC	R3,R21
    009A2 0646      CPC	R4,R22
    009A3 0657      CPC	R5,R23
    009A4 F429      BNE	0x09AA
(1008) 			return cs;
    009A5 850A      LDD	R16,Y+10
    009A6 851B      LDD	R17,Y+11
    009A7 852C      LDD	R18,Y+12
    009A8 853D      LDD	R19,Y+13
    009A9 C08D      RJMP	0x0A37
(1009) 		if (ncl == scl) return 0;		/* No free cluster */
    009AA 842E      LDD	R2,Y+14
    009AB 843F      LDD	R3,Y+15
    009AC 8848      LDD	R4,Y+16
    009AD 8859      LDD	R5,Y+17
    009AE 806E      LDD	R6,Y+6
    009AF 807F      LDD	R7,Y+7
    009B0 8488      LDD	R8,Y+8
    009B1 8499      LDD	R9,Y+9
    009B2 1462      CP	R6,R2
    009B3 0473      CPC	R7,R3
    009B4 0484      CPC	R8,R4
    009B5 0495      CPC	R9,R5
    009B6 F009      BEQ	0x09B8
    009B7 CF88      RJMP	0x0940
    009B8 E000      LDI	R16,0
    009B9 E010      LDI	R17,0
    009BA E020      LDI	R18,0
    009BB E030      LDI	R19,0
    009BC C07A      RJMP	0x0A37
(1010) 	}
(1011) 
(1012) 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    009BD EF8F      LDI	R24,0xFF
    009BE 838A      STD	Y+2,R24
    009BF 838B      STD	Y+3,R24
    009C0 838C      STD	Y+4,R24
    009C1 E08F      LDI	R24,0xF
    009C2 838D      STD	Y+5,R24
    009C3 802E      LDD	R2,Y+6
    009C4 803F      LDD	R3,Y+7
    009C5 8448      LDD	R4,Y+8
    009C6 8459      LDD	R5,Y+9
    009C7 8248      ST	Y,R4
    009C8 8259      STD	Y+1,R5
    009C9 0191      MOVW	R18,R2
    009CA 0186      MOVW	R16,R12
    009CB DC86      RCALL	_put_fat
    009CC 2EA0      MOV	R10,R16
(1013) 	if (res == FR_OK && clst != 0) {
    009CD 2300      TST	R16
    009CE F4E1      BNE	0x09EB
    009CF A028      LDD	R2,Y+32
    009D0 A039      LDD	R3,Y+33
    009D1 A04A      LDD	R4,Y+34
    009D2 A05B      LDD	R5,Y+35
    009D3 9488      BCLR	0
    009D4 2022      TST	R2
    009D5 0432      CPC	R3,R2
    009D6 0442      CPC	R4,R2
    009D7 0452      CPC	R5,R2
    009D8 F091      BEQ	0x09EB
(1014) 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    009D9 802E      LDD	R2,Y+6
    009DA 803F      LDD	R3,Y+7
    009DB 8448      LDD	R4,Y+8
    009DC 8459      LDD	R5,Y+9
    009DD 822A      STD	Y+2,R2
    009DE 823B      STD	Y+3,R3
    009DF 824C      STD	Y+4,R4
    009E0 825D      STD	Y+5,R5
    009E1 A028      LDD	R2,Y+32
    009E2 A039      LDD	R3,Y+33
    009E3 A04A      LDD	R4,Y+34
    009E4 A05B      LDD	R5,Y+35
    009E5 8248      ST	Y,R4
    009E6 8259      STD	Y+1,R5
    009E7 0191      MOVW	R18,R2
    009E8 0186      MOVW	R16,R12
    009E9 DC68      RCALL	_put_fat
    009EA 2EA0      MOV	R10,R16
(1015) 	}
(1016) 	if (res == FR_OK) {
    009EB 20AA      TST	R10
    009EC F009      BEQ	0x09EE
    009ED C02E      RJMP	0x0A1C
(1017) 		fs->last_clust = ncl;			/* Update FSINFO */
    009EE 802E      LDD	R2,Y+6
    009EF 803F      LDD	R3,Y+7
    009F0 8448      LDD	R4,Y+8
    009F1 8459      LDD	R5,Y+9
    009F2 01F6      MOVW	R30,R12
    009F3 8622      STD	Z+10,R2
    009F4 8633      STD	Z+11,R3
    009F5 8644      STD	Z+12,R4
    009F6 8655      STD	Z+13,R5
(1018) 		if (fs->free_clust != 0xFFFFFFFF) {
    009F7 EF4F      LDI	R20,0xFF
    009F8 EF5F      LDI	R21,0xFF
    009F9 EF6F      LDI	R22,0xFF
    009FA EF7F      LDI	R23,0xFF
    009FB 8426      LDD	R2,Z+14
    009FC 8437      LDD	R3,Z+15
    009FD 8840      LDD	R4,Z+16
    009FE 8851      LDD	R5,Z+17
    009FF 1624      CP	R2,R20
    00A00 0635      CPC	R3,R21
    00A01 0646      CPC	R4,R22
    00A02 0657      CPC	R5,R23
    00A03 F179      BEQ	0x0A33
(1019) 			fs->free_clust--;
    00A04 01CF      MOVW	R24,R30
    00A05 960E      ADIW	R24,0xE
    00A06 017C      MOVW	R14,R24
    00A07 E041      LDI	R20,1
    00A08 E050      LDI	R21,0
    00A09 E060      LDI	R22,0
    00A0A E070      LDI	R23,0
    00A0B 01FC      MOVW	R30,R24
    00A0C 8020      LD	R2,Z
    00A0D 8031      LDD	R3,Z+1
    00A0E 8042      LDD	R4,Z+2
    00A0F 8053      LDD	R5,Z+3
    00A10 1A24      SUB	R2,R20
    00A11 0A35      SBC	R3,R21
    00A12 0A46      SBC	R4,R22
    00A13 0A57      SBC	R5,R23
    00A14 8220      ST	Z,R2
    00A15 8231      STD	Z+1,R3
    00A16 8242      STD	Z+2,R4
    00A17 8253      STD	Z+3,R5
(1020) 			fs->fsi_flag = 1;
    00A18 E081      LDI	R24,1
    00A19 01F6      MOVW	R30,R12
    00A1A 8385      STD	Z+5,R24
(1021) 		}
(1022) 	} else {
    00A1B C017      RJMP	0x0A33
(1023) 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    00A1C 2D8A      MOV	R24,R10
    00A1D 3081      CPI	R24,1
    00A1E F431      BNE	0x0A25
    00A1F EF8F      LDI	R24,0xFF
    00A20 8B8A      STD	Y+18,R24
    00A21 8B8B      STD	Y+19,R24
    00A22 8B8C      STD	Y+20,R24
    00A23 8B8D      STD	Y+21,R24
    00A24 C006      RJMP	0x0A2B
    00A25 E081      LDI	R24,1
    00A26 8B8A      STD	Y+18,R24
    00A27 E080      LDI	R24,0
    00A28 8B8B      STD	Y+19,R24
    00A29 8B8C      STD	Y+20,R24
    00A2A 8B8D      STD	Y+21,R24
    00A2B 882A      LDD	R2,Y+18
    00A2C 883B      LDD	R3,Y+19
    00A2D 884C      LDD	R4,Y+20
    00A2E 885D      LDD	R5,Y+21
    00A2F 822E      STD	Y+6,R2
    00A30 823F      STD	Y+7,R3
    00A31 8648      STD	Y+8,R4
    00A32 8659      STD	Y+9,R5
(1024) 	}
(1025) 
(1026) 	return ncl;		/* Return new cluster number or error code */
    00A33 810E      LDD	R16,Y+6
    00A34 811F      LDD	R17,Y+7
    00A35 8528      LDD	R18,Y+8
    00A36 8539      LDD	R19,Y+9
    00A37 9666      ADIW	R28,0x16
    00A38 940E 3F62 CALL	pop_xgsetF0FC
    00A3A 9622      ADIW	R28,2
    00A3B 9508      RET
ff.c:clmt_clust:
  tbl                  --> R10
  cl                   --> Y,+4
  ncl                  --> Y,+0
  ofs                  --> Y,+12
  fp                   --> R12
    00A3C 933A      ST	-Y,R19
    00A3D 932A      ST	-Y,R18
    00A3E 940E 3F73 CALL	push_xgset003C
    00A40 0168      MOVW	R12,R16
    00A41 9728      SBIW	R28,0x8
(1027) }
(1028) #endif /* !_FS_READONLY */
(1029) 
(1030) 
(1031) 
(1032) /*-----------------------------------------------------------------------*/
(1033) /* FAT handling - Convert offset into cluster with link map table        */
(1034) /*-----------------------------------------------------------------------*/
(1035) 
(1036) #if _USE_FASTSEEK
(1037) static
(1038) DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
(1039) 	FIL* fp,		/* Pointer to the file object */
(1040) 	DWORD ofs		/* File offset to be converted to cluster# */
(1041) )
(1042) {
(1043) 	DWORD cl, ncl, *tbl;
(1044) 
(1045) 
(1046) 	tbl = fp->cltbl + 1;	/* Top of CLMT */
    00A42 01F6      MOVW	R30,R12
    00A43 96B0      ADIW	R30,0x20
    00A44 8180      LD	R24,Z
    00A45 8191      LDD	R25,Z+1
    00A46 9604      ADIW	R24,4
    00A47 015C      MOVW	R10,R24
(1047) 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
    00A48 E089      LDI	R24,0x9
    00A49 E090      LDI	R25,0
    00A4A 850C      LDD	R16,Y+12
    00A4B 851D      LDD	R17,Y+13
    00A4C 852E      LDD	R18,Y+14
    00A4D 853F      LDD	R19,Y+15
    00A4E 938A      ST	-Y,R24
    00A4F 940E 4008 CALL	lsr32
    00A51 01F6      MOVW	R30,R12
    00A52 93AF      PUSH	R26
    00A53 93BF      PUSH	R27
    00A54 81A0      LD	R26,Z
    00A55 81B1      LDD	R27,Z+1
    00A56 01FD      MOVW	R30,R26
    00A57 91BF      POP	R27
    00A58 91AF      POP	R26
    00A59 9632      ADIW	R30,2
    00A5A 8020      LD	R2,Z
    00A5B 2433      CLR	R3
    00A5C 2444      CLR	R4
    00A5D 2455      CLR	R5
    00A5E 925A      ST	-Y,R5
    00A5F 924A      ST	-Y,R4
    00A60 923A      ST	-Y,R3
    00A61 922A      ST	-Y,R2
    00A62 940E 3E73 CALL	div32u
    00A64 830C      STD	Y+4,R16
    00A65 831D      STD	Y+5,R17
    00A66 832E      STD	Y+6,R18
    00A67 833F      STD	Y+7,R19
(1048) 	for (;;) {
(1049) 		ncl = *tbl++;			/* Number of cluters in the fragment */
    00A68 01F5      MOVW	R30,R10
    00A69 9021      LD	R2,Z+
    00A6A 9031      LD	R3,Z+
    00A6B 9041      LD	R4,Z+
    00A6C 9051      LD	R5,Z+
    00A6D 015F      MOVW	R10,R30
    00A6E 8228      ST	Y,R2
    00A6F 8239      STD	Y+1,R3
    00A70 824A      STD	Y+2,R4
    00A71 825B      STD	Y+3,R5
(1050) 		if (!ncl) return 0;		/* End of table? (error) */
    00A72 8028      LD	R2,Y
    00A73 8039      LDD	R3,Y+1
    00A74 804A      LDD	R4,Y+2
    00A75 805B      LDD	R5,Y+3
    00A76 9488      BCLR	0
    00A77 2022      TST	R2
    00A78 0432      CPC	R3,R2
    00A79 0442      CPC	R4,R2
    00A7A 0452      CPC	R5,R2
    00A7B F429      BNE	0x0A81
    00A7C E000      LDI	R16,0
    00A7D E010      LDI	R17,0
    00A7E E020      LDI	R18,0
    00A7F E030      LDI	R19,0
    00A80 C02F      RJMP	0x0AB0
(1051) 		if (cl < ncl) break;	/* In this fragment? */
    00A81 8028      LD	R2,Y
    00A82 8039      LDD	R3,Y+1
    00A83 804A      LDD	R4,Y+2
    00A84 805B      LDD	R5,Y+3
    00A85 806C      LDD	R6,Y+4
    00A86 807D      LDD	R7,Y+5
    00A87 808E      LDD	R8,Y+6
    00A88 809F      LDD	R9,Y+7
    00A89 1462      CP	R6,R2
    00A8A 0473      CPC	R7,R3
    00A8B 0484      CPC	R8,R4
    00A8C 0495      CPC	R9,R5
    00A8D F408      BCC	0x0A8F
    00A8E C014      RJMP	0x0AA3
(1052) 		cl -= ncl; tbl++;		/* Next fragment */
    00A8F 8028      LD	R2,Y
    00A90 8039      LDD	R3,Y+1
    00A91 804A      LDD	R4,Y+2
    00A92 805B      LDD	R5,Y+3
    00A93 806C      LDD	R6,Y+4
    00A94 807D      LDD	R7,Y+5
    00A95 808E      LDD	R8,Y+6
    00A96 809F      LDD	R9,Y+7
    00A97 1862      SUB	R6,R2
    00A98 0873      SBC	R7,R3
    00A99 0884      SBC	R8,R4
    00A9A 0895      SBC	R9,R5
    00A9B 826C      STD	Y+4,R6
    00A9C 827D      STD	Y+5,R7
    00A9D 828E      STD	Y+6,R8
    00A9E 829F      STD	Y+7,R9
    00A9F 01C5      MOVW	R24,R10
    00AA0 9604      ADIW	R24,4
    00AA1 015C      MOVW	R10,R24
    00AA2 CFC5      RJMP	0x0A68
(1053) 	}
(1054) 	return cl + *tbl;	/* Return the cluster number */
    00AA3 01F5      MOVW	R30,R10
    00AA4 8020      LD	R2,Z
    00AA5 8031      LDD	R3,Z+1
    00AA6 8042      LDD	R4,Z+2
    00AA7 8053      LDD	R5,Z+3
    00AA8 810C      LDD	R16,Y+4
    00AA9 811D      LDD	R17,Y+5
    00AAA 812E      LDD	R18,Y+6
    00AAB 813F      LDD	R19,Y+7
    00AAC 0D02      ADD	R16,R2
    00AAD 1D13      ADC	R17,R3
    00AAE 1D24      ADC	R18,R4
    00AAF 1D35      ADC	R19,R5
    00AB0 9628      ADIW	R28,0x8
    00AB1 940E 3F4D CALL	pop_xgset003C
    00AB3 9622      ADIW	R28,2
    00AB4 9508      RET
ff.c:dir_sdi:
  ic                   --> R14
  clst                 --> Y,+2
  idx                  --> R12
  dj                   --> R10
    00AB5 940E 3F6D CALL	push_xgsetF0FC
    00AB7 0169      MOVW	R12,R18
    00AB8 0158      MOVW	R10,R16
    00AB9 9726      SBIW	R28,6
(1055) }
(1056) #endif	/* _USE_FASTSEEK */
(1057) 
(1058) 
(1059) 
(1060) /*-----------------------------------------------------------------------*/
(1061) /* Directory handling - Set directory index                              */
(1062) /*-----------------------------------------------------------------------*/
(1063) 
(1064) static
(1065) FRESULT dir_sdi (
(1066) 	DIR *dj,		/* Pointer to directory object */
(1067) 	WORD idx		/* Directory index number */
(1068) )
(1069) {
(1070) 	DWORD clst;
(1071) 	WORD ic;
(1072) 
(1073) 
(1074) 	dj->index = idx;
    00ABA 01F5      MOVW	R30,R10
    00ABB 82D5      STD	Z+5,R13
    00ABC 82C4      STD	Z+4,R12
(1075) 	clst = dj->sclust;
    00ABD 9636      ADIW	R30,6
    00ABE 8020      LD	R2,Z
    00ABF 8031      LDD	R3,Z+1
    00AC0 8042      LDD	R4,Z+2
    00AC1 8053      LDD	R5,Z+3
    00AC2 822A      STD	Y+2,R2
    00AC3 823B      STD	Y+3,R3
    00AC4 824C      STD	Y+4,R4
    00AC5 825D      STD	Y+5,R5
(1076) 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    00AC6 E041      LDI	R20,1
    00AC7 E050      LDI	R21,0
    00AC8 E060      LDI	R22,0
    00AC9 E070      LDI	R23,0
    00ACA 802A      LDD	R2,Y+2
    00ACB 803B      LDD	R3,Y+3
    00ACC 804C      LDD	R4,Y+4
    00ACD 805D      LDD	R5,Y+5
    00ACE 1624      CP	R2,R20
    00ACF 0635      CPC	R3,R21
    00AD0 0646      CPC	R4,R22
    00AD1 0657      CPC	R5,R23
    00AD2 F089      BEQ	0x0AE4
    00AD3 01F5      MOVW	R30,R10
    00AD4 81A0      LD	R26,Z
    00AD5 81B1      LDD	R27,Z+1
    00AD6 9656      ADIW	R26,0x16
    00AD7 902D      LD	R2,X+
    00AD8 903D      LD	R3,X+
    00AD9 904D      LD	R4,X+
    00ADA 905C      LD	R5,X
    00ADB 806A      LDD	R6,Y+2
    00ADC 807B      LDD	R7,Y+3
    00ADD 808C      LDD	R8,Y+4
    00ADE 809D      LDD	R9,Y+5
    00ADF 1462      CP	R6,R2
    00AE0 0473      CPC	R7,R3
    00AE1 0484      CPC	R8,R4
    00AE2 0495      CPC	R9,R5
    00AE3 F010      BCS	0x0AE6
(1077) 		return FR_INT_ERR;
    00AE4 E002      LDI	R16,2
    00AE5 C0D6      RJMP	0x0BBC
(1078) 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    00AE6 802A      LDD	R2,Y+2
    00AE7 803B      LDD	R3,Y+3
    00AE8 804C      LDD	R4,Y+4
    00AE9 805D      LDD	R5,Y+5
    00AEA 9488      BCLR	0
    00AEB 2022      TST	R2
    00AEC 0432      CPC	R3,R2
    00AED 0442      CPC	R4,R2
    00AEE 0452      CPC	R5,R2
    00AEF F479      BNE	0x0AFF
    00AF0 01F5      MOVW	R30,R10
    00AF1 81A0      LD	R26,Z
    00AF2 81B1      LDD	R27,Z+1
    00AF3 918C      LD	R24,X
    00AF4 3083      CPI	R24,3
    00AF5 F449      BNE	0x0AFF
(1079) 		clst = dj->fs->dirbase;
    00AF6 9692      ADIW	R26,0x22
    00AF7 902D      LD	R2,X+
    00AF8 903D      LD	R3,X+
    00AF9 904D      LD	R4,X+
    00AFA 905C      LD	R5,X
    00AFB 822A      STD	Y+2,R2
    00AFC 823B      STD	Y+3,R3
    00AFD 824C      STD	Y+4,R4
    00AFE 825D      STD	Y+5,R5
(1080) 
(1081) 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    00AFF 802A      LDD	R2,Y+2
    00B00 803B      LDD	R3,Y+3
    00B01 804C      LDD	R4,Y+4
    00B02 805D      LDD	R5,Y+5
    00B03 9488      BCLR	0
    00B04 2022      TST	R2
    00B05 0432      CPC	R3,R2
    00B06 0442      CPC	R4,R2
    00B07 0452      CPC	R5,R2
    00B08 F009      BEQ	0x0B0A
    00B09 C02B      RJMP	0x0B35
(1082) 		dj->clust = clst;
    00B0A 01F5      MOVW	R30,R10
    00B0B 8622      STD	Z+10,R2
    00B0C 8633      STD	Z+11,R3
    00B0D 8644      STD	Z+12,R4
    00B0E 8655      STD	Z+13,R5
(1083) 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    00B0F 81A0      LD	R26,Z
    00B10 81B1      LDD	R27,Z+1
    00B11 9618      ADIW	R26,0x8
    00B12 902D      LD	R2,X+
    00B13 903C      LD	R3,X
    00B14 14C2      CP	R12,R2
    00B15 04D3      CPC	R13,R3
    00B16 F010      BCS	0x0B19
(1084) 			return FR_INT_ERR;
    00B17 E002      LDI	R16,2
    00B18 C0A3      RJMP	0x0BBC
(1085) 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B19 0116      MOVW	R2,R12
    00B1A 9436      LSR	R3
    00B1B 9427      ROR	R2
    00B1C 9436      LSR	R3
    00B1D 9427      ROR	R2
    00B1E 9436      LSR	R3
    00B1F 9427      ROR	R2
    00B20 9436      LSR	R3
    00B21 9427      ROR	R2
    00B22 2444      CLR	R4
    00B23 2455      CLR	R5
    00B24 01F5      MOVW	R30,R10
    00B25 81A0      LD	R26,Z
    00B26 81B1      LDD	R27,Z+1
    00B27 9692      ADIW	R26,0x22
    00B28 906D      LD	R6,X+
    00B29 907D      LD	R7,X+
    00B2A 908D      LD	R8,X+
    00B2B 909C      LD	R9,X
    00B2C 0C62      ADD	R6,R2
    00B2D 1C73      ADC	R7,R3
    00B2E 1C84      ADC	R8,R4
    00B2F 1C95      ADC	R9,R5
    00B30 8666      STD	Z+14,R6
    00B31 8677      STD	Z+15,R7
    00B32 8A80      STD	Z+16,R8
    00B33 8A91      STD	Z+17,R9
(1086) 	}
    00B34 C076      RJMP	0x0BAB
(1087) 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
(1088) 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    00B35 01F5      MOVW	R30,R10
    00B36 93AF      PUSH	R26
    00B37 93BF      PUSH	R27
    00B38 81A0      LD	R26,Z
    00B39 81B1      LDD	R27,Z+1
    00B3A 01FD      MOVW	R30,R26
    00B3B 91BF      POP	R27
    00B3C 91AF      POP	R26
    00B3D 8022      LDD	R2,Z+2
    00B3E E180      LDI	R24,0x10
    00B3F 9D82      MUL	R24,R2
    00B40 0170      MOVW	R14,R0
    00B41 C040      RJMP	0x0B82
(1089) 		while (idx >= ic) {	/* Follow cluster chain */
(1090) 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    00B42 802A      LDD	R2,Y+2
    00B43 803B      LDD	R3,Y+3
    00B44 804C      LDD	R4,Y+4
    00B45 805D      LDD	R5,Y+5
    00B46 8248      ST	Y,R4
    00B47 8259      STD	Y+1,R5
    00B48 0191      MOVW	R18,R2
    00B49 01F5      MOVW	R30,R10
    00B4A 8100      LD	R16,Z
    00B4B 8111      LDD	R17,Z+1
    00B4C D9B5      RCALL	_get_fat
    00B4D 830A      STD	Y+2,R16
    00B4E 831B      STD	Y+3,R17
    00B4F 832C      STD	Y+4,R18
    00B50 833D      STD	Y+5,R19
(1091) 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    00B51 EF4F      LDI	R20,0xFF
    00B52 EF5F      LDI	R21,0xFF
    00B53 EF6F      LDI	R22,0xFF
    00B54 EF7F      LDI	R23,0xFF
    00B55 802A      LDD	R2,Y+2
    00B56 803B      LDD	R3,Y+3
    00B57 804C      LDD	R4,Y+4
    00B58 805D      LDD	R5,Y+5
    00B59 1624      CP	R2,R20
    00B5A 0635      CPC	R3,R21
    00B5B 0646      CPC	R4,R22
    00B5C 0657      CPC	R5,R23
    00B5D F411      BNE	0x0B60
    00B5E E001      LDI	R16,1
    00B5F C05C      RJMP	0x0BBC
(1092) 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    00B60 E042      LDI	R20,2
    00B61 E050      LDI	R21,0
    00B62 E060      LDI	R22,0
    00B63 E070      LDI	R23,0
    00B64 802A      LDD	R2,Y+2
    00B65 803B      LDD	R3,Y+3
    00B66 804C      LDD	R4,Y+4
    00B67 805D      LDD	R5,Y+5
    00B68 1624      CP	R2,R20
    00B69 0635      CPC	R3,R21
    00B6A 0646      CPC	R4,R22
    00B6B 0657      CPC	R5,R23
    00B6C F088      BCS	0x0B7E
    00B6D 01F5      MOVW	R30,R10
    00B6E 81A0      LD	R26,Z
    00B6F 81B1      LDD	R27,Z+1
    00B70 9656      ADIW	R26,0x16
    00B71 902D      LD	R2,X+
    00B72 903D      LD	R3,X+
    00B73 904D      LD	R4,X+
    00B74 905C      LD	R5,X
    00B75 806A      LDD	R6,Y+2
    00B76 807B      LDD	R7,Y+3
    00B77 808C      LDD	R8,Y+4
    00B78 809D      LDD	R9,Y+5
    00B79 1462      CP	R6,R2
    00B7A 0473      CPC	R7,R3
    00B7B 0484      CPC	R8,R4
    00B7C 0495      CPC	R9,R5
    00B7D F010      BCS	0x0B80
(1093) 				return FR_INT_ERR;
    00B7E E002      LDI	R16,2
    00B7F C03C      RJMP	0x0BBC
(1094) 			idx -= ic;
    00B80 18CE      SUB	R12,R14
    00B81 08DF      SBC	R13,R15
    00B82 14CE      CP	R12,R14
    00B83 04DF      CPC	R13,R15
    00B84 F008      BCS	0x0B86
    00B85 CFBC      RJMP	0x0B42
(1095) 		}
(1096) 		dj->clust = clst;
    00B86 802A      LDD	R2,Y+2
    00B87 803B      LDD	R3,Y+3
    00B88 804C      LDD	R4,Y+4
    00B89 805D      LDD	R5,Y+5
    00B8A 01F5      MOVW	R30,R10
    00B8B 8622      STD	Z+10,R2
    00B8C 8633      STD	Z+11,R3
    00B8D 8644      STD	Z+12,R4
    00B8E 8655      STD	Z+13,R5
(1097) 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B8F 8248      ST	Y,R4
    00B90 8259      STD	Y+1,R5
    00B91 0191      MOVW	R18,R2
    00B92 8100      LD	R16,Z
    00B93 8111      LDD	R17,Z+1
    00B94 D91B      RCALL	_clust2sect
    00B95 0116      MOVW	R2,R12
    00B96 9436      LSR	R3
    00B97 9427      ROR	R2
    00B98 9436      LSR	R3
    00B99 9427      ROR	R2
    00B9A 9436      LSR	R3
    00B9B 9427      ROR	R2
    00B9C 9436      LSR	R3
    00B9D 9427      ROR	R2
    00B9E 2444      CLR	R4
    00B9F 2455      CLR	R5
    00BA0 0138      MOVW	R6,R16
    00BA1 0149      MOVW	R8,R18
    00BA2 0C62      ADD	R6,R2
    00BA3 1C73      ADC	R7,R3
    00BA4 1C84      ADC	R8,R4
    00BA5 1C95      ADC	R9,R5
    00BA6 01F5      MOVW	R30,R10
    00BA7 8666      STD	Z+14,R6
    00BA8 8677      STD	Z+15,R7
    00BA9 8A80      STD	Z+16,R8
    00BAA 8A91      STD	Z+17,R9
(1098) 	}
(1099) 
(1100) 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    00BAB 0196      MOVW	R18,R12
    00BAC 702F      ANDI	R18,0xF
    00BAD 7030      ANDI	R19,0
    00BAE E200      LDI	R16,0x20
    00BAF E010      LDI	R17,0
    00BB0 940E 3F09 CALL	empy16s
    00BB2 0118      MOVW	R2,R16
    00BB3 01F5      MOVW	R30,R10
    00BB4 8180      LD	R24,Z
    00BB5 8191      LDD	R25,Z+1
    00BB6 968E      ADIW	R24,0x2E
    00BB7 0E28      ADD	R2,R24
    00BB8 1E39      ADC	R3,R25
    00BB9 8A33      STD	Z+19,R3
    00BBA 8A22      STD	Z+18,R2
(1101) 
(1102) 	return FR_OK;	/* Seek succeeded */
    00BBB 2700      CLR	R16
    00BBC 9626      ADIW	R28,6
    00BBD 940C 3F62 JMP	pop_xgsetF0FC
ff.c:dir_next:
  c                    --> R10
  clst                 --> Y,+2
  i                    --> R12
  stretch              --> R10
  dj                   --> Y,+16
    00BBF 940E 3E28 CALL	push_arg4
    00BC1 940E 3F6D CALL	push_xgsetF0FC
    00BC3 0159      MOVW	R10,R18
    00BC4 9726      SBIW	R28,6
(1103) }
(1104) 
(1105) 
(1106) 
(1107) 
(1108) /*-----------------------------------------------------------------------*/
(1109) /* Directory handling - Move directory index next                        */
(1110) /*-----------------------------------------------------------------------*/
(1111) 
(1112) static
(1113) FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
(1114) 	DIR *dj,		/* Pointer to directory object */
(1115) 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
(1116) )
(1117) {
(1118) 	DWORD clst;
(1119) 	WORD i;
(1120) 
(1121) 
(1122) 	stretch = stretch;		/* To suppress warning on read-only cfg. */
(1123) 	i = dj->index + 1;
    00BC5 89E8      LDD	R30,Y+16
    00BC6 89F9      LDD	R31,Y+17
    00BC7 8184      LDD	R24,Z+4
    00BC8 8195      LDD	R25,Z+5
    00BC9 9601      ADIW	R24,1
    00BCA 016C      MOVW	R12,R24
(1124) 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    00BCB 3080      CPI	R24,0
    00BCC 0789      CPC	R24,R25
    00BCD F059      BEQ	0x0BD9
    00BCE 963E      ADIW	R30,0xE
    00BCF 8020      LD	R2,Z
    00BD0 8031      LDD	R3,Z+1
    00BD1 8042      LDD	R4,Z+2
    00BD2 8053      LDD	R5,Z+3
    00BD3 9488      BCLR	0
    00BD4 2022      TST	R2
    00BD5 0432      CPC	R3,R2
    00BD6 0442      CPC	R4,R2
    00BD7 0452      CPC	R5,R2
    00BD8 F411      BNE	0x0BDB
(1125) 		return FR_NO_FILE;
    00BD9 E004      LDI	R16,4
    00BDA C18D      RJMP	0x0D68
(1126) 
(1127) 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    00BDB 01C6      MOVW	R24,R12
    00BDC 708F      ANDI	R24,0xF
    00BDD 7090      ANDI	R25,0
    00BDE 3080      CPI	R24,0
    00BDF 0789      CPC	R24,R25
    00BE0 F009      BEQ	0x0BE2
    00BE1 C170      RJMP	0x0D52
(1128) 		dj->sect++;					/* Next sector */
    00BE2 8988      LDD	R24,Y+16
    00BE3 8999      LDD	R25,Y+17
    00BE4 960E      ADIW	R24,0xE
    00BE5 E041      LDI	R20,1
    00BE6 E050      LDI	R21,0
    00BE7 E060      LDI	R22,0
    00BE8 E070      LDI	R23,0
    00BE9 01FC      MOVW	R30,R24
    00BEA 8020      LD	R2,Z
    00BEB 8031      LDD	R3,Z+1
    00BEC 8042      LDD	R4,Z+2
    00BED 8053      LDD	R5,Z+3
    00BEE 0E24      ADD	R2,R20
    00BEF 1E35      ADC	R3,R21
    00BF0 1E46      ADC	R4,R22
    00BF1 1E57      ADC	R5,R23
    00BF2 8220      ST	Z,R2
    00BF3 8231      STD	Z+1,R3
    00BF4 8242      STD	Z+2,R4
    00BF5 8253      STD	Z+3,R5
(1129) 
(1130) 		if (dj->clust == 0) {	/* Static table */
    00BF6 89E8      LDD	R30,Y+16
    00BF7 89F9      LDD	R31,Y+17
    00BF8 963A      ADIW	R30,0xA
    00BF9 8020      LD	R2,Z
    00BFA 8031      LDD	R3,Z+1
    00BFB 8042      LDD	R4,Z+2
    00BFC 8053      LDD	R5,Z+3
    00BFD 9488      BCLR	0
    00BFE 2022      TST	R2
    00BFF 0432      CPC	R3,R2
    00C00 0442      CPC	R4,R2
    00C01 0452      CPC	R5,R2
    00C02 F469      BNE	0x0C10
(1131) 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    00C03 89E8      LDD	R30,Y+16
    00C04 89F9      LDD	R31,Y+17
    00C05 81A0      LD	R26,Z
    00C06 81B1      LDD	R27,Z+1
    00C07 9618      ADIW	R26,0x8
    00C08 902D      LD	R2,X+
    00C09 903C      LD	R3,X
    00C0A 14C2      CP	R12,R2
    00C0B 04D3      CPC	R13,R3
    00C0C F408      BCC	0x0C0E
    00C0D C144      RJMP	0x0D52
(1132) 				return FR_NO_FILE;
    00C0E E004      LDI	R16,4
    00C0F C158      RJMP	0x0D68
(1133) 		}
(1134) 		else {					/* Dynamic table */
(1135) 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    00C10 89E8      LDD	R30,Y+16
    00C11 89F9      LDD	R31,Y+17
    00C12 93AF      PUSH	R26
    00C13 93BF      PUSH	R27
    00C14 81A0      LD	R26,Z
    00C15 81B1      LDD	R27,Z+1
    00C16 01FD      MOVW	R30,R26
    00C17 91BF      POP	R27
    00C18 91AF      POP	R26
    00C19 8182      LDD	R24,Z+2
    00C1A 2799      CLR	R25
    00C1B 9701      SBIW	R24,1
    00C1C 0116      MOVW	R2,R12
    00C1D 9436      LSR	R3
    00C1E 9427      ROR	R2
    00C1F 9436      LSR	R3
    00C20 9427      ROR	R2
    00C21 9436      LSR	R3
    00C22 9427      ROR	R2
    00C23 9436      LSR	R3
    00C24 9427      ROR	R2
    00C25 2228      AND	R2,R24
    00C26 2239      AND	R3,R25
    00C27 2022      TST	R2
    00C28 F009      BEQ	0x0C2A
    00C29 C128      RJMP	0x0D52
    00C2A 2033      TST	R3
    00C2B F009      BEQ	0x0C2D
    00C2C C125      RJMP	0x0D52
(1136) 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    00C2D 89E8      LDD	R30,Y+16
    00C2E 89F9      LDD	R31,Y+17
    00C2F 8422      LDD	R2,Z+10
    00C30 8433      LDD	R3,Z+11
    00C31 8444      LDD	R4,Z+12
    00C32 8455      LDD	R5,Z+13
    00C33 8248      ST	Y,R4
    00C34 8259      STD	Y+1,R5
    00C35 0191      MOVW	R18,R2
    00C36 8100      LD	R16,Z
    00C37 8111      LDD	R17,Z+1
    00C38 D8C9      RCALL	_get_fat
    00C39 830A      STD	Y+2,R16
    00C3A 831B      STD	Y+3,R17
    00C3B 832C      STD	Y+4,R18
    00C3C 833D      STD	Y+5,R19
(1137) 				if (clst <= 1) return FR_INT_ERR;
    00C3D E041      LDI	R20,1
    00C3E E050      LDI	R21,0
    00C3F E060      LDI	R22,0
    00C40 E070      LDI	R23,0
    00C41 802A      LDD	R2,Y+2
    00C42 803B      LDD	R3,Y+3
    00C43 804C      LDD	R4,Y+4
    00C44 805D      LDD	R5,Y+5
    00C45 1542      CP	R20,R2
    00C46 0553      CPC	R21,R3
    00C47 0564      CPC	R22,R4
    00C48 0575      CPC	R23,R5
    00C49 F010      BCS	0x0C4C
    00C4A E002      LDI	R16,2
    00C4B C11C      RJMP	0x0D68
(1138) 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C4C EF4F      LDI	R20,0xFF
    00C4D EF5F      LDI	R21,0xFF
    00C4E EF6F      LDI	R22,0xFF
    00C4F EF7F      LDI	R23,0xFF
    00C50 802A      LDD	R2,Y+2
    00C51 803B      LDD	R3,Y+3
    00C52 804C      LDD	R4,Y+4
    00C53 805D      LDD	R5,Y+5
    00C54 1624      CP	R2,R20
    00C55 0635      CPC	R3,R21
    00C56 0646      CPC	R4,R22
    00C57 0657      CPC	R5,R23
    00C58 F411      BNE	0x0C5B
    00C59 E001      LDI	R16,1
    00C5A C10D      RJMP	0x0D68
(1139) 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    00C5B 89E8      LDD	R30,Y+16
    00C5C 89F9      LDD	R31,Y+17
    00C5D 81A0      LD	R26,Z
    00C5E 81B1      LDD	R27,Z+1
    00C5F 9656      ADIW	R26,0x16
    00C60 902D      LD	R2,X+
    00C61 903D      LD	R3,X+
    00C62 904D      LD	R4,X+
    00C63 905C      LD	R5,X
    00C64 806A      LDD	R6,Y+2
    00C65 807B      LDD	R7,Y+3
    00C66 808C      LDD	R8,Y+4
    00C67 809D      LDD	R9,Y+5
    00C68 1462      CP	R6,R2
    00C69 0473      CPC	R7,R3
    00C6A 0484      CPC	R8,R4
    00C6B 0495      CPC	R9,R5
    00C6C F408      BCC	0x0C6E
    00C6D C0CD      RJMP	0x0D3B
(1140) #if !_FS_READONLY
(1141) 					BYTE c;
(1142) 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    00C6E 20AA      TST	R10
    00C6F F421      BNE	0x0C74
    00C70 20BB      TST	R11
    00C71 F411      BNE	0x0C74
    00C72 E004      LDI	R16,4
    00C73 C0F4      RJMP	0x0D68
(1143) 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    00C74 89E8      LDD	R30,Y+16
    00C75 89F9      LDD	R31,Y+17
    00C76 8422      LDD	R2,Z+10
    00C77 8433      LDD	R3,Z+11
    00C78 8444      LDD	R4,Z+12
    00C79 8455      LDD	R5,Z+13
    00C7A 8248      ST	Y,R4
    00C7B 8259      STD	Y+1,R5
    00C7C 0191      MOVW	R18,R2
    00C7D 8100      LD	R16,Z
    00C7E 8111      LDD	R17,Z+1
    00C7F DC44      RCALL	ff.c:create_chain
    00C80 830A      STD	Y+2,R16
    00C81 831B      STD	Y+3,R17
    00C82 832C      STD	Y+4,R18
    00C83 833D      STD	Y+5,R19
(1144) 					if (clst == 0) return FR_DENIED;			/* No free cluster */
    00C84 802A      LDD	R2,Y+2
    00C85 803B      LDD	R3,Y+3
    00C86 804C      LDD	R4,Y+4
    00C87 805D      LDD	R5,Y+5
    00C88 9488      BCLR	0
    00C89 2022      TST	R2
    00C8A 0432      CPC	R3,R2
    00C8B 0442      CPC	R4,R2
    00C8C 0452      CPC	R5,R2
    00C8D F411      BNE	0x0C90
    00C8E E007      LDI	R16,7
    00C8F C0D8      RJMP	0x0D68
(1145) 					if (clst == 1) return FR_INT_ERR;
    00C90 E041      LDI	R20,1
    00C91 E050      LDI	R21,0
    00C92 E060      LDI	R22,0
    00C93 E070      LDI	R23,0
    00C94 802A      LDD	R2,Y+2
    00C95 803B      LDD	R3,Y+3
    00C96 804C      LDD	R4,Y+4
    00C97 805D      LDD	R5,Y+5
    00C98 1624      CP	R2,R20
    00C99 0635      CPC	R3,R21
    00C9A 0646      CPC	R4,R22
    00C9B 0657      CPC	R5,R23
    00C9C F411      BNE	0x0C9F
    00C9D E002      LDI	R16,2
    00C9E C0C9      RJMP	0x0D68
(1146) 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C9F EF4F      LDI	R20,0xFF
    00CA0 EF5F      LDI	R21,0xFF
    00CA1 EF6F      LDI	R22,0xFF
    00CA2 EF7F      LDI	R23,0xFF
    00CA3 802A      LDD	R2,Y+2
    00CA4 803B      LDD	R3,Y+3
    00CA5 804C      LDD	R4,Y+4
    00CA6 805D      LDD	R5,Y+5
    00CA7 1624      CP	R2,R20
    00CA8 0635      CPC	R3,R21
    00CA9 0646      CPC	R4,R22
    00CAA 0657      CPC	R5,R23
    00CAB F411      BNE	0x0CAE
    00CAC E001      LDI	R16,1
    00CAD C0BA      RJMP	0x0D68
(1147) 					/* Clean-up stretched table */
(1148) 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    00CAE E040      LDI	R20,0
    00CAF E050      LDI	R21,0
    00CB0 E060      LDI	R22,0
    00CB1 E070      LDI	R23,0
    00CB2 8368      ST	Y,R22
    00CB3 8379      STD	Y+1,R23
    00CB4 019A      MOVW	R18,R20
    00CB5 89E8      LDD	R30,Y+16
    00CB6 89F9      LDD	R31,Y+17
    00CB7 8100      LD	R16,Z
    00CB8 8111      LDD	R17,Z+1
    00CB9 940E 0339 CALL	ff.c:move_window
    00CBB 2300      TST	R16
    00CBC F011      BEQ	0x0CBF
    00CBD E001      LDI	R16,1
    00CBE C0A9      RJMP	0x0D68
(1149) 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    00CBF E080      LDI	R24,0
    00CC0 E092      LDI	R25,2
    00CC1 8399      STD	Y+1,R25
    00CC2 8388      ST	Y,R24
    00CC3 2722      CLR	R18
    00CC4 2733      CLR	R19
    00CC5 89E8      LDD	R30,Y+16
    00CC6 89F9      LDD	R31,Y+17
    00CC7 8100      LD	R16,Z
    00CC8 8111      LDD	R17,Z+1
    00CC9 5D02      SUBI	R16,0xD2
    00CCA 4F1F      SBCI	R17,0xFF
    00CCB 940E 02F6 CALL	ff.c:mem_set
(1150) 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    00CCD 802A      LDD	R2,Y+2
    00CCE 803B      LDD	R3,Y+3
    00CCF 804C      LDD	R4,Y+4
    00CD0 805D      LDD	R5,Y+5
    00CD1 8248      ST	Y,R4
    00CD2 8259      STD	Y+1,R5
    00CD3 0191      MOVW	R18,R2
    00CD4 89E8      LDD	R30,Y+16
    00CD5 89F9      LDD	R31,Y+17
    00CD6 80A0      LD	R10,Z
    00CD7 80B1      LDD	R11,Z+1
    00CD8 0185      MOVW	R16,R10
    00CD9 940E 04B0 CALL	_clust2sect
    00CDB 01F5      MOVW	R30,R10
    00CDC A702      STD	Z+42,R16
    00CDD A713      STD	Z+43,R17
    00CDE A724      STD	Z+44,R18
    00CDF A735      STD	Z+45,R19
(1151) 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    00CE0 24AA      CLR	R10
    00CE1 C035      RJMP	0x0D17
(1152) 						dj->fs->wflag = 1;
    00CE2 E081      LDI	R24,1
    00CE3 89E8      LDD	R30,Y+16
    00CE4 89F9      LDD	R31,Y+17
    00CE5 93AF      PUSH	R26
    00CE6 93BF      PUSH	R27
    00CE7 81A0      LD	R26,Z
    00CE8 81B1      LDD	R27,Z+1
    00CE9 01FD      MOVW	R30,R26
    00CEA 91BF      POP	R27
    00CEB 91AF      POP	R26
    00CEC 8384      STD	Z+4,R24
(1153) 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    00CED E040      LDI	R20,0
    00CEE E050      LDI	R21,0
    00CEF E060      LDI	R22,0
    00CF0 E070      LDI	R23,0
    00CF1 8368      ST	Y,R22
    00CF2 8379      STD	Y+1,R23
    00CF3 019A      MOVW	R18,R20
    00CF4 89E8      LDD	R30,Y+16
    00CF5 89F9      LDD	R31,Y+17
    00CF6 8100      LD	R16,Z
    00CF7 8111      LDD	R17,Z+1
    00CF8 940E 0339 CALL	ff.c:move_window
    00CFA 2EE0      MOV	R14,R16
    00CFB 2300      TST	R16
    00CFC F011      BEQ	0x0CFF
    00CFD E001      LDI	R16,1
    00CFE C069      RJMP	0x0D68
(1154) 						dj->fs->winsect++;
    00CFF 89E8      LDD	R30,Y+16
    00D00 89F9      LDD	R31,Y+17
    00D01 8180      LD	R24,Z
    00D02 8191      LDD	R25,Z+1
    00D03 968A      ADIW	R24,0x2A
    00D04 017C      MOVW	R14,R24
    00D05 E041      LDI	R20,1
    00D06 E050      LDI	R21,0
    00D07 E060      LDI	R22,0
    00D08 E070      LDI	R23,0
    00D09 01FC      MOVW	R30,R24
    00D0A 8020      LD	R2,Z
    00D0B 8031      LDD	R3,Z+1
    00D0C 8042      LDD	R4,Z+2
    00D0D 8053      LDD	R5,Z+3
    00D0E 0E24      ADD	R2,R20
    00D0F 1E35      ADC	R3,R21
    00D10 1E46      ADC	R4,R22
    00D11 1E57      ADC	R5,R23
    00D12 8220      ST	Z,R2
    00D13 8231      STD	Z+1,R3
    00D14 8242      STD	Z+2,R4
    00D15 8253      STD	Z+3,R5
    00D16 94A3      INC	R10
    00D17 89E8      LDD	R30,Y+16
    00D18 89F9      LDD	R31,Y+17
    00D19 93AF      PUSH	R26
    00D1A 93BF      PUSH	R27
    00D1B 81A0      LD	R26,Z
    00D1C 81B1      LDD	R27,Z+1
    00D1D 01FD      MOVW	R30,R26
    00D1E 91BF      POP	R27
    00D1F 91AF      POP	R26
    00D20 8022      LDD	R2,Z+2
    00D21 14A2      CP	R10,R2
    00D22 F408      BCC	0x0D24
    00D23 CFBE      RJMP	0x0CE2
(1155) 					}
(1156) 					dj->fs->winsect -= c;						/* Rewind window address */
    00D24 89E8      LDD	R30,Y+16
    00D25 89F9      LDD	R31,Y+17
    00D26 8180      LD	R24,Z
    00D27 8191      LDD	R25,Z+1
    00D28 968A      ADIW	R24,0x2A
    00D29 017C      MOVW	R14,R24
    00D2A 2C2A      MOV	R2,R10
    00D2B 2433      CLR	R3
    00D2C 2444      CLR	R4
    00D2D 2455      CLR	R5
    00D2E 01FC      MOVW	R30,R24
    00D2F 8060      LD	R6,Z
    00D30 8071      LDD	R7,Z+1
    00D31 8082      LDD	R8,Z+2
    00D32 8093      LDD	R9,Z+3
    00D33 1862      SUB	R6,R2
    00D34 0873      SBC	R7,R3
    00D35 0884      SBC	R8,R4
    00D36 0895      SBC	R9,R5
    00D37 8260      ST	Z,R6
    00D38 8271      STD	Z+1,R7
    00D39 8282      STD	Z+2,R8
    00D3A 8293      STD	Z+3,R9
(1157) #else
(1158) 					return FR_NO_FILE;			/* Report EOT */
(1159) #endif
(1160) 				}
(1161) 				dj->clust = clst;				/* Initialize data for new cluster */
    00D3B 802A      LDD	R2,Y+2
    00D3C 803B      LDD	R3,Y+3
    00D3D 804C      LDD	R4,Y+4
    00D3E 805D      LDD	R5,Y+5
    00D3F 89E8      LDD	R30,Y+16
    00D40 89F9      LDD	R31,Y+17
    00D41 8622      STD	Z+10,R2
    00D42 8633      STD	Z+11,R3
    00D43 8644      STD	Z+12,R4
    00D44 8655      STD	Z+13,R5
(1162) 				dj->sect = clust2sect(dj->fs, clst);
    00D45 8248      ST	Y,R4
    00D46 8259      STD	Y+1,R5
    00D47 0191      MOVW	R18,R2
    00D48 8100      LD	R16,Z
    00D49 8111      LDD	R17,Z+1
    00D4A 940E 04B0 CALL	_clust2sect
    00D4C 89E8      LDD	R30,Y+16
    00D4D 89F9      LDD	R31,Y+17
    00D4E 8706      STD	Z+14,R16
    00D4F 8717      STD	Z+15,R17
    00D50 8B20      STD	Z+16,R18
    00D51 8B31      STD	Z+17,R19
(1163) 			}
(1164) 		}
(1165) 	}
(1166) 
(1167) 	dj->index = i;
    00D52 89E8      LDD	R30,Y+16
    00D53 89F9      LDD	R31,Y+17
    00D54 82D5      STD	Z+5,R13
    00D55 82C4      STD	Z+4,R12
(1168) 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    00D56 0196      MOVW	R18,R12
    00D57 702F      ANDI	R18,0xF
    00D58 7030      ANDI	R19,0
    00D59 E200      LDI	R16,0x20
    00D5A E010      LDI	R17,0
    00D5B 940E 3F09 CALL	empy16s
    00D5D 0118      MOVW	R2,R16
    00D5E 89E8      LDD	R30,Y+16
    00D5F 89F9      LDD	R31,Y+17
    00D60 8180      LD	R24,Z
    00D61 8191      LDD	R25,Z+1
    00D62 968E      ADIW	R24,0x2E
    00D63 0E28      ADD	R2,R24
    00D64 1E39      ADC	R3,R25
    00D65 8A33      STD	Z+19,R3
    00D66 8A22      STD	Z+18,R2
(1169) 
(1170) 	return FR_OK;
    00D67 2700      CLR	R16
    00D68 9626      ADIW	R28,6
    00D69 940E 3F62 CALL	pop_xgsetF0FC
    00D6B 9624      ADIW	R28,4
    00D6C 9508      RET
ff.c:dir_find:
  c                    --> R12
  dir                  --> R10
  res                  --> R20
  dj                   --> R22
    00D6D 940E 3FA8 CALL	push_xgsetF03C
    00D6F 01B8      MOVW	R22,R16
    00D70 9722      SBIW	R28,2
(1171) }
(1172) 
(1173) 
(1174) 
(1175) 
(1176) /*-----------------------------------------------------------------------*/
(1177) /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
(1178) /*-----------------------------------------------------------------------*/
(1179) #if _USE_LFN
(1180) static
(1181) const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
(1182) 
(1183) 
(1184) static
(1185) int cmp_lfn (			/* 1:Matched, 0:Not matched */
(1186) 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
(1187) 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
(1188) )
(1189) {
(1190) 	UINT i, s;
(1191) 	WCHAR wc, uc;
(1192) 
(1193) 
(1194) 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
(1195) 	s = 0; wc = 1;
(1196) 	do {
(1197) 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
(1198) 		if (wc) {	/* Last char has not been processed */
(1199) 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
(1200) 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
(1201) 				return 0;				/* Not matched */
(1202) 		} else {
(1203) 			if (uc != 0xFFFF) return 0;	/* Check filler */
(1204) 		}
(1205) 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
(1206) 
(1207) 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
(1208) 		return 0;
(1209) 
(1210) 	return 1;						/* The part of LFN matched */
(1211) }
(1212) 
(1213) 
(1214) 
(1215) static
(1216) int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
(1217) 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
(1218) 	BYTE *dir			/* Pointer to the directory entry */
(1219) )
(1220) {
(1221) 	UINT i, s;
(1222) 	WCHAR wc, uc;
(1223) 
(1224) 
(1225) 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
(1226) 
(1227) 	s = 0; wc = 1;
(1228) 	do {
(1229) 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
(1230) 		if (wc) {	/* Last char has not been processed */
(1231) 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
(1232) 			lfnbuf[i++] = wc = uc;			/* Store it */
(1233) 		} else {
(1234) 			if (uc != 0xFFFF) return 0;		/* Check filler */
(1235) 		}
(1236) 	} while (++s < 13);						/* Read all character in the entry */
(1237) 
(1238) 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
(1239) 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
(1240) 		lfnbuf[i] = 0;
(1241) 	}
(1242) 
(1243) 	return 1;
(1244) }
(1245) 
(1246) 
(1247) #if !_FS_READONLY
(1248) static
(1249) void fit_lfn (
(1250) 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
(1251) 	BYTE *dir,				/* Pointer to the directory entry */
(1252) 	BYTE ord,				/* LFN order (1-20) */
(1253) 	BYTE sum				/* SFN sum */
(1254) )
(1255) {
(1256) 	UINT i, s;
(1257) 	WCHAR wc;
(1258) 
(1259) 
(1260) 	dir[LDIR_Chksum] = sum;			/* Set check sum */
(1261) 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
(1262) 	dir[LDIR_Type] = 0;
(1263) 	ST_WORD(dir+LDIR_FstClusLO, 0);
(1264) 
(1265) 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
(1266) 	s = wc = 0;
(1267) 	do {
(1268) 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
(1269) 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
(1270) 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
(1271) 	} while (++s < 13);
(1272) 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
(1273) 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
(1274) }
(1275) 
(1276) #endif
(1277) #endif
(1278) 
(1279) 
(1280) 
(1281) /*-----------------------------------------------------------------------*/
(1282) /* Create numbered name                                                  */
(1283) /*-----------------------------------------------------------------------*/
(1284) #if _USE_LFN
(1285) void gen_numname (
(1286) 	BYTE *dst,			/* Pointer to generated SFN */
(1287) 	const BYTE *src,	/* Pointer to source SFN to be modified */
(1288) 	const WCHAR *lfn,	/* Pointer to LFN */
(1289) 	WORD seq			/* Sequence number */
(1290) )
(1291) {
(1292) 	BYTE ns[8], c;
(1293) 	UINT i, j;
(1294) 
(1295) 
(1296) 	mem_cpy(dst, src, 11);
(1297) 
(1298) 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
(1299) 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
(1300) 	}
(1301) 
(1302) 	/* itoa (hexdecimal) */
(1303) 	i = 7;
(1304) 	do {
(1305) 		c = (seq % 16) + '0';
(1306) 		if (c > '9') c += 7;
(1307) 		ns[i--] = c;
(1308) 		seq /= 16;
(1309) 	} while (seq);
(1310) 	ns[i] = '~';
(1311) 
(1312) 	/* Append the number */
(1313) 	for (j = 0; j < i && dst[j] != ' '; j++) {
(1314) 		if (IsDBCS1(dst[j])) {
(1315) 			if (j == i - 1) break;
(1316) 			j++;
(1317) 		}
(1318) 	}
(1319) 	do {
(1320) 		dst[j++] = (i < 8) ? ns[i++] : ' ';
(1321) 	} while (j < 8);
(1322) }
(1323) #endif
(1324) 
(1325) 
(1326) 
(1327) 
(1328) /*-----------------------------------------------------------------------*/
(1329) /* Calculate sum of an SFN                                               */
(1330) /*-----------------------------------------------------------------------*/
(1331) #if _USE_LFN
(1332) static
(1333) BYTE sum_sfn (
(1334) 	const BYTE *dir		/* Ptr to directory entry */
(1335) )
(1336) {
(1337) 	BYTE sum = 0;
(1338) 	UINT n = 11;
(1339) 
(1340) 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
(1341) 	return sum;
(1342) }
(1343) #endif
(1344) 
(1345) 
(1346) 
(1347) 
(1348) /*-----------------------------------------------------------------------*/
(1349) /* Directory handling - Find an object in the directory                  */
(1350) /*-----------------------------------------------------------------------*/
(1351) 
(1352) static
(1353) FRESULT dir_find (
(1354) 	DIR *dj			/* Pointer to the directory object linked to the file name */
(1355) )
(1356) {
(1357) 	FRESULT res;
(1358) 	BYTE c, *dir;
(1359) #if _USE_LFN
(1360) 	BYTE a, ord, sum;
(1361) #endif
(1362) 
(1363) 	res = dir_sdi(dj, 0);			/* Rewind directory object */
    00D71 2722      CLR	R18
    00D72 2733      CLR	R19
    00D73 018B      MOVW	R16,R22
    00D74 DD40      RCALL	ff.c:dir_sdi
    00D75 2F40      MOV	R20,R16
(1364) 	if (res != FR_OK) return res;
    00D76 2300      TST	R16
    00D77 F009      BEQ	0x0D79
    00D78 C036      RJMP	0x0DAF
(1365) 
(1366) #if _USE_LFN
(1367) 	ord = sum = 0xFF;
(1368) #endif
(1369) 	do {
(1370) 		res = move_window(dj->fs, dj->sect);
    00D79 01FB      MOVW	R30,R22
    00D7A 8426      LDD	R2,Z+14
    00D7B 8437      LDD	R3,Z+15
    00D7C 8840      LDD	R4,Z+16
    00D7D 8851      LDD	R5,Z+17
    00D7E 8248      ST	Y,R4
    00D7F 8259      STD	Y+1,R5
    00D80 0191      MOVW	R18,R2
    00D81 8100      LD	R16,Z
    00D82 8111      LDD	R17,Z+1
    00D83 940E 0339 CALL	ff.c:move_window
    00D85 2F40      MOV	R20,R16
(1371) 		if (res != FR_OK) break;
    00D86 2300      TST	R16
    00D87 F009      BEQ	0x0D89
    00D88 C025      RJMP	0x0DAE
(1372) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00D89 01FB      MOVW	R30,R22
    00D8A 88A2      LDD	R10,Z+18
    00D8B 88B3      LDD	R11,Z+19
(1373) 		c = dir[DIR_Name];
    00D8C 01F5      MOVW	R30,R10
    00D8D 80C0      LD	R12,Z
(1374) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00D8E 20CC      TST	R12
    00D8F F411      BNE	0x0D92
    00D90 E044      LDI	R20,4
    00D91 C01C      RJMP	0x0DAE
(1375) #if _USE_LFN	/* LFN configuration */
(1376) 		a = dir[DIR_Attr] & AM_MASK;
(1377) 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1378) 			ord = 0xFF;
(1379) 		} else {
(1380) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1381) 				if (dj->lfn) {
(1382) 					if (c & LLE) {		/* Is it start of LFN sequence? */
(1383) 						sum = dir[LDIR_Chksum];
(1384) 						c &= ~LLE; ord = c;	/* LFN start order */
(1385) 						dj->lfn_idx = dj->index;
(1386) 					}
(1387) 					/* Check validity of the LFN entry and compare it with given name */
(1388) 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1389) 				}
(1390) 			} else {					/* An SFN entry is found */
(1391) 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
(1392) 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
(1393) 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
(1394) 			}
(1395) 		}
(1396) #else		/* Non LFN configuration */
(1397) 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    00D92 01F5      MOVW	R30,R10
    00D93 8423      LDD	R2,Z+11
    00D94 FC23      SBRC	R2,3
    00D95 C00F      RJMP	0x0DA5
    00D96 E08B      LDI	R24,0xB
    00D97 E090      LDI	R25,0
    00D98 8399      STD	Y+1,R25
    00D99 8388      ST	Y,R24
    00D9A 01FB      MOVW	R30,R22
    00D9B 8924      LDD	R18,Z+20
    00D9C 8935      LDD	R19,Z+21
    00D9D 0185      MOVW	R16,R10
    00D9E 940E 0308 CALL	ff.c:mem_cmp
    00DA0 0158      MOVW	R10,R16
    00DA1 3000      CPI	R16,0
    00DA2 0701      CPC	R16,R17
    00DA3 F409      BNE	0x0DA5
(1398) 			break;
    00DA4 C009      RJMP	0x0DAE
(1399) #endif
(1400) 		res = dir_next(dj, 0);		/* Next entry */
    00DA5 2722      CLR	R18
    00DA6 2733      CLR	R19
    00DA7 018B      MOVW	R16,R22
    00DA8 DE16      RCALL	ff.c:dir_next
    00DA9 2EA0      MOV	R10,R16
    00DAA 2D4A      MOV	R20,R10
(1401) 	} while (res == FR_OK);
    00DAB 2344      TST	R20
    00DAC F409      BNE	0x0DAE
    00DAD CFCB      RJMP	0x0D79
(1402) 
(1403) 	return res;
    00DAE 2F04      MOV	R16,R20
    00DAF 9622      ADIW	R28,2
    00DB0 940C 3FB1 JMP	pop_xgsetF03C
ff.c:dir_read:
  dir                  --> R10
  c                    --> R12
  res                  --> R20
  dj                   --> R22
    00DB2 940E 3FA8 CALL	push_xgsetF03C
    00DB4 01B8      MOVW	R22,R16
    00DB5 9722      SBIW	R28,2
(1404) }
(1405) 
(1406) 
(1407) 
(1408) 
(1409) /*-----------------------------------------------------------------------*/
(1410) /* Read an object from the directory                                     */
(1411) /*-----------------------------------------------------------------------*/
(1412) #if _FS_MINIMIZE <= 1
(1413) static
(1414) FRESULT dir_read (
(1415) 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
(1416) )
(1417) {
(1418) 	FRESULT res;
(1419) 	BYTE c, *dir;
(1420) #if _USE_LFN
(1421) 	BYTE a, ord = 0xFF, sum = 0xFF;
(1422) #endif
(1423) 
(1424) 	res = FR_NO_FILE;
    00DB6 E044      LDI	R20,4
    00DB7 C02B      RJMP	0x0DE3
(1425) 	while (dj->sect) {
(1426) 		res = move_window(dj->fs, dj->sect);
    00DB8 01FB      MOVW	R30,R22
    00DB9 8426      LDD	R2,Z+14
    00DBA 8437      LDD	R3,Z+15
    00DBB 8840      LDD	R4,Z+16
    00DBC 8851      LDD	R5,Z+17
    00DBD 8248      ST	Y,R4
    00DBE 8259      STD	Y+1,R5
    00DBF 0191      MOVW	R18,R2
    00DC0 8100      LD	R16,Z
    00DC1 8111      LDD	R17,Z+1
    00DC2 940E 0339 CALL	ff.c:move_window
    00DC4 2F40      MOV	R20,R16
(1427) 		if (res != FR_OK) break;
    00DC5 2300      TST	R16
    00DC6 F009      BEQ	0x0DC8
    00DC7 C028      RJMP	0x0DF0
(1428) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00DC8 01FB      MOVW	R30,R22
    00DC9 88A2      LDD	R10,Z+18
    00DCA 88B3      LDD	R11,Z+19
(1429) 		c = dir[DIR_Name];
    00DCB 01F5      MOVW	R30,R10
    00DCC 80C0      LD	R12,Z
(1430) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00DCD 20CC      TST	R12
    00DCE F411      BNE	0x0DD1
    00DCF E044      LDI	R20,4
    00DD0 C01F      RJMP	0x0DF0
(1431) #if _USE_LFN	/* LFN configuration */
(1432) 		a = dir[DIR_Attr] & AM_MASK;
(1433) 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1434) 			ord = 0xFF;
(1435) 		} else {
(1436) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1437) 				if (c & LLE) {			/* Is it start of LFN sequence? */
(1438) 					sum = dir[LDIR_Chksum];
(1439) 					c &= ~LLE; ord = c;
(1440) 					dj->lfn_idx = dj->index;
(1441) 				}
(1442) 				/* Check LFN validity and capture it */
(1443) 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1444) 			} else {					/* An SFN entry is found */
(1445) 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
(1446) 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
(1447) 				break;
(1448) 			}
(1449) 		}
(1450) #else		/* Non LFN configuration */
(1451) 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    00DD1 2D8C      MOV	R24,R12
    00DD2 3E85      CPI	R24,0xE5
    00DD3 F039      BEQ	0x0DDB
    00DD4 328E      CPI	R24,0x2E
    00DD5 F029      BEQ	0x0DDB
    00DD6 01F5      MOVW	R30,R10
    00DD7 8423      LDD	R2,Z+11
    00DD8 FC23      SBRC	R2,3
    00DD9 C001      RJMP	0x0DDB
(1452) 			break;
    00DDA C015      RJMP	0x0DF0
(1453) #endif
(1454) 		res = dir_next(dj, 0);				/* Next entry */
    00DDB 2722      CLR	R18
    00DDC 2733      CLR	R19
    00DDD 018B      MOVW	R16,R22
    00DDE DDE0      RCALL	ff.c:dir_next
    00DDF 2F40      MOV	R20,R16
(1455) 		if (res != FR_OK) break;
    00DE0 2300      TST	R16
    00DE1 F009      BEQ	0x0DE3
    00DE2 C00D      RJMP	0x0DF0
    00DE3 01FB      MOVW	R30,R22
    00DE4 963E      ADIW	R30,0xE
    00DE5 8020      LD	R2,Z
    00DE6 8031      LDD	R3,Z+1
    00DE7 8042      LDD	R4,Z+2
    00DE8 8053      LDD	R5,Z+3
    00DE9 9488      BCLR	0
    00DEA 2022      TST	R2
    00DEB 0432      CPC	R3,R2
    00DEC 0442      CPC	R4,R2
    00DED 0452      CPC	R5,R2
    00DEE F009      BEQ	0x0DF0
    00DEF CFC8      RJMP	0x0DB8
(1456) 	}
(1457) 
(1458) 	if (res != FR_OK) dj->sect = 0;
    00DF0 2344      TST	R20
    00DF1 F039      BEQ	0x0DF9
    00DF2 01FB      MOVW	R30,R22
    00DF3 963E      ADIW	R30,0xE
    00DF4 E080      LDI	R24,0
    00DF5 8380      ST	Z,R24
    00DF6 8381      STD	Z+1,R24
    00DF7 8382      STD	Z+2,R24
    00DF8 8383      STD	Z+3,R24
(1459) 
(1460) 	return res;
    00DF9 2F04      MOV	R16,R20
    00DFA 9622      ADIW	R28,2
    00DFB 940C 3FB1 JMP	pop_xgsetF03C
ff.c:dir_register:
  dir                  --> R12
  c                    --> R22
  res                  --> R10
  dj                   --> R20
    00DFD 940E 3FA8 CALL	push_xgsetF03C
    00DFF 01A8      MOVW	R20,R16
    00E00 9722      SBIW	R28,2
(1461) }
(1462) #endif
(1463) 
(1464) 
(1465) 
(1466) /*-----------------------------------------------------------------------*/
(1467) /* Register an object to the directory                                   */
(1468) /*-----------------------------------------------------------------------*/
(1469) #if !_FS_READONLY
(1470) static
(1471) FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
(1472) 	DIR *dj				/* Target directory with object name to be created */
(1473) )
(1474) {
(1475) 	FRESULT res;
(1476) 	BYTE c, *dir;
(1477) #if _USE_LFN	/* LFN configuration */
(1478) 	WORD n, ne, is;
(1479) 	BYTE sn[12], *fn, sum;
(1480) 	WCHAR *lfn;
(1481) 
(1482) 
(1483) 	fn = dj->fn; lfn = dj->lfn;
(1484) 	mem_cpy(sn, fn, 12);
(1485) 
(1486) 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
(1487) 		return FR_INVALID_NAME;
(1488) 
(1489) 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
(1490) 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
(1491) 		for (n = 1; n < 100; n++) {
(1492) 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
(1493) 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
(1494) 			if (res != FR_OK) break;
(1495) 		}
(1496) 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
(1497) 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
(1498) 		fn[NS] = sn[NS]; dj->lfn = lfn;
(1499) 	}
(1500) 
(1501) 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
(1502) 		for (ne = 0; lfn[ne]; ne++) ;
(1503) 		ne = (ne + 25) / 13;
(1504) 	} else {						/* Otherwise reserve only an SFN entry. */
(1505) 		ne = 1;
(1506) 	}
(1507) 
(1508) 	/* Reserve contiguous entries */
(1509) 	res = dir_sdi(dj, 0);
(1510) 	if (res != FR_OK) return res;
(1511) 	n = is = 0;
(1512) 	do {
(1513) 		res = move_window(dj->fs, dj->sect);
(1514) 		if (res != FR_OK) break;
(1515) 		c = *dj->dir;				/* Check the entry status */
(1516) 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
(1517) 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
(1518) 			if (++n == ne) break;	/* A contiguous entry that required count is found */
(1519) 		} else {
(1520) 			n = 0;					/* Not a blank entry. Restart to search */
(1521) 		}
(1522) 		res = dir_next(dj, 1);		/* Next entry with table stretch */
(1523) 	} while (res == FR_OK);
(1524) 
(1525) 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
(1526) 		res = dir_sdi(dj, is);
(1527) 		if (res == FR_OK) {
(1528) 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
(1529) 			ne--;
(1530) 			do {					/* Store LFN entries in bottom first */
(1531) 				res = move_window(dj->fs, dj->sect);
(1532) 				if (res != FR_OK) break;
(1533) 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
(1534) 				dj->fs->wflag = 1;
(1535) 				res = dir_next(dj, 0);	/* Next entry */
(1536) 			} while (res == FR_OK && --ne);
(1537) 		}
(1538) 	}
(1539) 
(1540) #else	/* Non LFN configuration */
(1541) 	res = dir_sdi(dj, 0);
    00E01 2722      CLR	R18
    00E02 2733      CLR	R19
    00E03 018A      MOVW	R16,R20
    00E04 DCB0      RCALL	ff.c:dir_sdi
    00E05 2EA0      MOV	R10,R16
(1542) 	if (res == FR_OK) {
    00E06 2300      TST	R16
    00E07 F509      BNE	0x0E29
(1543) 		do {	/* Find a blank entry for the SFN */
(1544) 			res = move_window(dj->fs, dj->sect);
    00E08 01FA      MOVW	R30,R20
    00E09 8426      LDD	R2,Z+14
    00E0A 8437      LDD	R3,Z+15
    00E0B 8840      LDD	R4,Z+16
    00E0C 8851      LDD	R5,Z+17
    00E0D 8248      ST	Y,R4
    00E0E 8259      STD	Y+1,R5
    00E0F 0191      MOVW	R18,R2
    00E10 8100      LD	R16,Z
    00E11 8111      LDD	R17,Z+1
    00E12 940E 0339 CALL	ff.c:move_window
    00E14 2EA0      MOV	R10,R16
(1545) 			if (res != FR_OK) break;
    00E15 2300      TST	R16
    00E16 F009      BEQ	0x0E18
    00E17 C011      RJMP	0x0E29
(1546) 			c = *dj->dir;
    00E18 01FA      MOVW	R30,R20
    00E19 89A2      LDD	R26,Z+18
    00E1A 89B3      LDD	R27,Z+19
    00E1B 916C      LD	R22,X
(1547) 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    00E1C 3E65      CPI	R22,0xE5
    00E1D F011      BEQ	0x0E20
    00E1E 2366      TST	R22
    00E1F F409      BNE	0x0E21
    00E20 C008      RJMP	0x0E29
(1548) 			res = dir_next(dj, 1);			/* Next entry with table stretch */
    00E21 E021      LDI	R18,1
    00E22 E030      LDI	R19,0
    00E23 018A      MOVW	R16,R20
    00E24 DD9A      RCALL	ff.c:dir_next
    00E25 2EC0      MOV	R12,R16
    00E26 2CAC      MOV	R10,R12
(1549) 		} while (res == FR_OK);
    00E27 20AA      TST	R10
    00E28 F2F9      BEQ	0x0E08
(1550) 	}
(1551) #endif
(1552) 
(1553) 	if (res == FR_OK) {		/* Initialize the SFN entry */
    00E29 20AA      TST	R10
    00E2A F009      BEQ	0x0E2C
    00E2B C030      RJMP	0x0E5C
(1554) 		res = move_window(dj->fs, dj->sect);
    00E2C 01FA      MOVW	R30,R20
    00E2D 8426      LDD	R2,Z+14
    00E2E 8437      LDD	R3,Z+15
    00E2F 8840      LDD	R4,Z+16
    00E30 8851      LDD	R5,Z+17
    00E31 8248      ST	Y,R4
    00E32 8259      STD	Y+1,R5
    00E33 0191      MOVW	R18,R2
    00E34 8100      LD	R16,Z
    00E35 8111      LDD	R17,Z+1
    00E36 940E 0339 CALL	ff.c:move_window
    00E38 2EC0      MOV	R12,R16
    00E39 2CAC      MOV	R10,R12
(1555) 		if (res == FR_OK) {
    00E3A 2300      TST	R16
    00E3B F501      BNE	0x0E5C
(1556) 			dir = dj->dir;
    00E3C 01FA      MOVW	R30,R20
    00E3D 88C2      LDD	R12,Z+18
    00E3E 88D3      LDD	R13,Z+19
(1557) 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    00E3F E280      LDI	R24,0x20
    00E40 E090      LDI	R25,0
    00E41 8399      STD	Y+1,R25
    00E42 8388      ST	Y,R24
    00E43 2722      CLR	R18
    00E44 2733      CLR	R19
    00E45 0186      MOVW	R16,R12
    00E46 940E 02F6 CALL	ff.c:mem_set
(1558) 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    00E48 E08B      LDI	R24,0xB
    00E49 E090      LDI	R25,0
    00E4A 8399      STD	Y+1,R25
    00E4B 8388      ST	Y,R24
    00E4C 01FA      MOVW	R30,R20
    00E4D 8924      LDD	R18,Z+20
    00E4E 8935      LDD	R19,Z+21
    00E4F 0186      MOVW	R16,R12
    00E50 940E 02E0 CALL	ff.c:mem_cpy
(1559) #if _USE_LFN
(1560) 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
(1561) #endif
(1562) 			dj->fs->wflag = 1;
    00E52 E081      LDI	R24,1
    00E53 01FA      MOVW	R30,R20
    00E54 93AF      PUSH	R26
    00E55 93BF      PUSH	R27
    00E56 81A0      LD	R26,Z
    00E57 81B1      LDD	R27,Z+1
    00E58 01FD      MOVW	R30,R26
    00E59 91BF      POP	R27
    00E5A 91AF      POP	R26
    00E5B 8384      STD	Z+4,R24
(1563) 		}
(1564) 	}
(1565) 
(1566) 	return res;
    00E5C 2D0A      MOV	R16,R10
    00E5D 9622      ADIW	R28,2
    00E5E 940C 3FB1 JMP	pop_xgsetF03C
ff.c:create_name:
  si                   --> R22
  b                    --> Y,+8
  sfn                  --> Y,+6
  ni                   --> R12
  d                    --> R10
  i                    --> Y,+4
  p                    --> Y,+2
  c                    --> R20
  path                 --> Y,+19
  dj                   --> R20
    00E60 933A      ST	-Y,R19
    00E61 932A      ST	-Y,R18
    00E62 940E 3F6D CALL	push_xgsetF0FC
    00E64 01A8      MOVW	R20,R16
    00E65 9729      SBIW	R28,0x9
(1567) }
(1568) #endif /* !_FS_READONLY */
(1569) 
(1570) 
(1571) 
(1572) 
(1573) /*-----------------------------------------------------------------------*/
(1574) /* Remove an object from the directory                                   */
(1575) /*-----------------------------------------------------------------------*/
(1576) #if !_FS_READONLY && !_FS_MINIMIZE
(1577) static
(1578) FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
(1579) 	DIR *dj				/* Directory object pointing the entry to be removed */
(1580) )
(1581) {
(1582) 	FRESULT res;
(1583) #if _USE_LFN	/* LFN configuration */
(1584) 	WORD i;
(1585) 
(1586) 	i = dj->index;	/* SFN index */
(1587) 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
(1588) 	if (res == FR_OK) {
(1589) 		do {
(1590) 			res = move_window(dj->fs, dj->sect);
(1591) 			if (res != FR_OK) break;
(1592) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1593) 			dj->fs->wflag = 1;
(1594) 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
(1595) 			res = dir_next(dj, 0);		/* Next entry */
(1596) 		} while (res == FR_OK);
(1597) 		if (res == FR_NO_FILE) res = FR_INT_ERR;
(1598) 	}
(1599) 
(1600) #else			/* Non LFN configuration */
(1601) 	res = dir_sdi(dj, dj->index);
(1602) 	if (res == FR_OK) {
(1603) 		res = move_window(dj->fs, dj->sect);
(1604) 		if (res == FR_OK) {
(1605) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1606) 			dj->fs->wflag = 1;
(1607) 		}
(1608) 	}
(1609) #endif
(1610) 
(1611) 	return res;
(1612) }
(1613) #endif /* !_FS_READONLY */
(1614) 
(1615) 
(1616) 
(1617) 
(1618) /*-----------------------------------------------------------------------*/
(1619) /* Pick a segment and create the object name in directory form           */
(1620) /*-----------------------------------------------------------------------*/
(1621) 
(1622) static
(1623) FRESULT create_name (
(1624) 	DIR *dj,			/* Pointer to the directory object */
(1625) 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
(1626) )
(1627) {
(1628) #ifdef _EXCVT
(1629) 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
(1630) #endif
(1631) 
(1632) #if _USE_LFN	/* LFN configuration */
(1633) 	BYTE b, cf;
(1634) 	WCHAR w, *lfn;
(1635) 	UINT i, ni, si, di;
(1636) 	const TCHAR *p;
(1637) 
(1638) 	/* Create LFN in Unicode */
(1639) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
(1640) 	lfn = dj->lfn;
(1641) 	si = di = 0;
(1642) 	for (;;) {
(1643) 		w = p[si++];					/* Get a character */
(1644) 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
(1645) 		if (di >= _MAX_LFN)				/* Reject too long name */
(1646) 			return FR_INVALID_NAME;
(1647) #if !_LFN_UNICODE
(1648) 		w &= 0xFF;
(1649) 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
(1650) 			b = (BYTE)p[si++];			/* Get 2nd byte */
(1651) 			if (!IsDBCS2(b))
(1652) 				return FR_INVALID_NAME;	/* Reject invalid sequence */
(1653) 			w = (w << 8) + b;			/* Create a DBC */
(1654) 		}
(1655) 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
(1656) 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
(1657) #endif
(1658) 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
(1659) 			return FR_INVALID_NAME;
(1660) 		lfn[di++] = w;					/* Store the Unicode char */
(1661) 	}
(1662) 	*path = &p[si];						/* Return pointer to the next segment */
(1663) 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
(1664) #if _FS_RPATH
(1665) 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
(1666) 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
(1667) 		lfn[di] = 0;
(1668) 		for (i = 0; i < 11; i++)
(1669) 			dj->fn[i] = (i < di) ? '.' : ' ';
(1670) 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
(1671) 		return FR_OK;
(1672) 	}
(1673) #endif
(1674) 	while (di) {						/* Strip trailing spaces and dots */
(1675) 		w = lfn[di-1];
(1676) 		if (w != ' ' && w != '.') break;
(1677) 		di--;
(1678) 	}
(1679) 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
(1680) 
(1681) 	lfn[di] = 0;						/* LFN is created */
(1682) 
(1683) 	/* Create SFN in directory form */
(1684) 	mem_set(dj->fn, ' ', 11);
(1685) 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
(1686) 	if (si) cf |= NS_LOSS | NS_LFN;
(1687) 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
(1688) 
(1689) 	b = i = 0; ni = 8;
(1690) 	for (;;) {
(1691) 		w = lfn[si++];					/* Get an LFN char */
(1692) 		if (!w) break;					/* Break on end of the LFN */
(1693) 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
(1694) 			cf |= NS_LOSS | NS_LFN; continue;
(1695) 		}
(1696) 
(1697) 		if (i >= ni || si == di) {		/* Extension or end of SFN */
(1698) 			if (ni == 11) {				/* Long extension */
(1699) 				cf |= NS_LOSS | NS_LFN; break;
(1700) 			}
(1701) 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
(1702) 			if (si > di) break;			/* No extension */
(1703) 			si = di; i = 8; ni = 11;	/* Enter extension section */
(1704) 			b <<= 2; continue;
(1705) 		}
(1706) 
(1707) 		if (w >= 0x80) {				/* Non ASCII char */
(1708) #ifdef _EXCVT
(1709) 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
(1710) 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
(1711) #else
(1712) 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
(1713) #endif
(1714) 			cf |= NS_LFN;				/* Force create LFN entry */
(1715) 		}
(1716) 
(1717) 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
(1718) 			if (i >= ni - 1) {
(1719) 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
(1720) 			}
(1721) 			dj->fn[i++] = (BYTE)(w >> 8);
(1722) 		} else {						/* Single byte char */
(1723) 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
(1724) 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
(1725) 			} else {
(1726) 				if (IsUpper(w)) {		/* ASCII large capital */
(1727) 					b |= 2;
(1728) 				} else {
(1729) 					if (IsLower(w)) {	/* ASCII small capital */
(1730) 						b |= 1; w -= 0x20;
(1731) 					}
(1732) 				}
(1733) 			}
(1734) 		}
(1735) 		dj->fn[i++] = (BYTE)w;
(1736) 	}
(1737) 
(1738) 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
(1739) 
(1740) 	if (ni == 8) b <<= 2;
(1741) 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
(1742) 		cf |= NS_LFN;
(1743) 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
(1744) 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
(1745) 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
(1746) 	}
(1747) 
(1748) 	dj->fn[NS] = cf;	/* SFN is created */
(1749) 
(1750) 	return FR_OK;
(1751) 
(1752) 
(1753) #else	/* Non-LFN configuration */
(1754) 	BYTE b, c, d, *sfn;
(1755) 	UINT ni, si, i;
(1756) 	const char *p;
(1757) 
(1758) 	/* Create file name in directory form */
(1759) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    00E66 89EB      LDD	R30,Y+19
    00E67 89FC      LDD	R31,Y+20
    00E68 8020      LD	R2,Z
    00E69 8031      LDD	R3,Z+1
    00E6A 823B      STD	Y+3,R3
    00E6B 822A      STD	Y+2,R2
    00E6C C005      RJMP	0x0E72
    00E6D 818A      LDD	R24,Y+2
    00E6E 819B      LDD	R25,Y+3
    00E6F 9601      ADIW	R24,1
    00E70 839B      STD	Y+3,R25
    00E71 838A      STD	Y+2,R24
    00E72 81EA      LDD	R30,Y+2
    00E73 81FB      LDD	R31,Y+3
    00E74 8020      LD	R2,Z
    00E75 2433      CLR	R3
    00E76 2D82      MOV	R24,R2
    00E77 328F      CPI	R24,0x2F
    00E78 F3A1      BEQ	0x0E6D
    00E79 358C      CPI	R24,0x5C
    00E7A F391      BEQ	0x0E6D
(1760) 	sfn = dj->fn;
    00E7B 01FA      MOVW	R30,R20
    00E7C 8824      LDD	R2,Z+20
    00E7D 8835      LDD	R3,Z+21
    00E7E 823F      STD	Y+7,R3
    00E7F 822E      STD	Y+6,R2
(1761) 	mem_set(sfn, ' ', 11);
    00E80 E08B      LDI	R24,0xB
    00E81 E090      LDI	R25,0
    00E82 8399      STD	Y+1,R25
    00E83 8388      ST	Y,R24
    00E84 E220      LDI	R18,0x20
    00E85 E030      LDI	R19,0
    00E86 0181      MOVW	R16,R2
    00E87 940E 02F6 CALL	ff.c:mem_set
(1762) 	si = i = b = 0; ni = 8;
    00E89 2400      CLR	R0
    00E8A 8608      STD	Y+8,R0
    00E8B 2422      CLR	R2
    00E8C 2433      CLR	R3
    00E8D 823D      STD	Y+5,R3
    00E8E 822C      STD	Y+4,R2
    00E8F 01B1      MOVW	R22,R2
    00E90 E088      LDI	R24,0x8
    00E91 E090      LDI	R25,0
    00E92 016C      MOVW	R12,R24
(1763) #if _FS_RPATH
(1764) 	if (p[si] == '.') { /* Is this a dot entry? */
(1765) 		for (;;) {
(1766) 			c = (BYTE)p[si++];
(1767) 			if (c != '.' || si >= 3) break;
(1768) 			sfn[i++] = c;
(1769) 		}
(1770) 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
(1771) 		*path = &p[si];									/* Return pointer to the next segment */
(1772) 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
(1773) 		return FR_OK;
(1774) 	}
(1775) #endif
(1776) 	for (;;) {
(1777) 		c = (BYTE)p[si++];
    00E93 01AB      MOVW	R20,R22
    00E94 5F6F      SUBI	R22,0xFF
    00E95 4F7F      SBCI	R23,0xFF
    00E96 01FA      MOVW	R30,R20
    00E97 800A      LDD	R0,Y+2
    00E98 801B      LDD	R1,Y+3
    00E99 0DE0      ADD	R30,R0
    00E9A 1DF1      ADC	R31,R1
    00E9B 8140      LD	R20,Z
(1778) 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    00E9C E280      LDI	R24,0x20
    00E9D 1784      CP	R24,R20
    00E9E F420      BCC	0x0EA3
    00E9F 324F      CPI	R20,0x2F
    00EA0 F011      BEQ	0x0EA3
    00EA1 354C      CPI	R20,0x5C
    00EA2 F409      BNE	0x0EA4
    00EA3 C087      RJMP	0x0F2B
(1779) 		if (c == '.' || i >= ni) {
    00EA4 324E      CPI	R20,0x2E
    00EA5 F029      BEQ	0x0EAB
    00EA6 800C      LDD	R0,Y+4
    00EA7 801D      LDD	R1,Y+5
    00EA8 140C      CP	R0,R12
    00EA9 041D      CPC	R1,R13
    00EAA F0A0      BCS	0x0EBF
(1780) 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    00EAB 01C6      MOVW	R24,R12
    00EAC 3088      CPI	R24,0x8
    00EAD E0E0      LDI	R30,0
    00EAE 079E      CPC	R25,R30
    00EAF F411      BNE	0x0EB2
    00EB0 324E      CPI	R20,0x2E
    00EB1 F011      BEQ	0x0EB4
    00EB2 E006      LDI	R16,6
    00EB3 C0AF      RJMP	0x0F63
(1781) 			i = 8; ni = 11;
    00EB4 E088      LDI	R24,0x8
    00EB5 E090      LDI	R25,0
    00EB6 839D      STD	Y+5,R25
    00EB7 838C      STD	Y+4,R24
    00EB8 E08B      LDI	R24,0xB
    00EB9 016C      MOVW	R12,R24
(1782) 			b <<= 2; continue;
    00EBA 8408      LDD	R0,Y+8
    00EBB 0C00      LSL	R0
    00EBC 0C00      LSL	R0
    00EBD 8608      STD	Y+8,R0
    00EBE CFD4      RJMP	0x0E93
(1783) 		}
(1784) 		if (c >= 0x80) {				/* Extended char? */
    00EBF 3840      CPI	R20,0x80
    00EC0 F018      BCS	0x0EC4
(1785) 			b |= 3;						/* Eliminate NT flag */
    00EC1 8588      LDD	R24,Y+8
    00EC2 6083      ORI	R24,3
    00EC3 8788      STD	Y+8,R24
(1786) #ifdef _EXCVT
(1787) 			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
(1788) #else
(1789) #if !_DF1S	/* ASCII only cfg */
(1790) 			return FR_INVALID_NAME;
(1791) #endif
(1792) #endif
(1793) 		}
(1794) 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    00EC4 3841      CPI	R20,0x81
    00EC5 F408      BCC	0x0EC7
    00EC6 C039      RJMP	0x0F00
    00EC7 EF8E      LDI	R24,0xFE
    00EC8 1784      CP	R24,R20
    00EC9 F408      BCC	0x0ECB
    00ECA C035      RJMP	0x0F00
(1795) 			d = (BYTE)p[si++];			/* Get 2nd byte */
    00ECB 015B      MOVW	R10,R22
    00ECC 5F6F      SUBI	R22,0xFF
    00ECD 4F7F      SBCI	R23,0xFF
    00ECE 01F5      MOVW	R30,R10
    00ECF 800A      LDD	R0,Y+2
    00ED0 801B      LDD	R1,Y+3
    00ED1 0DE0      ADD	R30,R0
    00ED2 1DF1      ADC	R31,R1
    00ED3 80A0      LD	R10,Z
(1796) 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    00ED4 2D8A      MOV	R24,R10
    00ED5 3480      CPI	R24,0x40
    00ED6 F018      BCS	0x0EDA
    00ED7 E78E      LDI	R24,0x7E
    00ED8 158A      CP	R24,R10
    00ED9 F430      BCC	0x0EE0
    00EDA 2D8A      MOV	R24,R10
    00EDB 3880      CPI	R24,0x80
    00EDC F050      BCS	0x0EE7
    00EDD EF8E      LDI	R24,0xFE
    00EDE 158A      CP	R24,R10
    00EDF F038      BCS	0x0EE7
    00EE0 01C6      MOVW	R24,R12
    00EE1 9701      SBIW	R24,1
    00EE2 800C      LDD	R0,Y+4
    00EE3 801D      LDD	R1,Y+5
    00EE4 1608      CP	R0,R24
    00EE5 0619      CPC	R1,R25
    00EE6 F010      BCS	0x0EE9
(1797) 				return FR_INVALID_NAME;
    00EE7 E006      LDI	R16,6
    00EE8 C07A      RJMP	0x0F63
(1798) 			sfn[i++] = c;
    00EE9 80EC      LDD	R14,Y+4
    00EEA 80FD      LDD	R15,Y+5
    00EEB 01C7      MOVW	R24,R14
    00EEC 9601      ADIW	R24,1
    00EED 839D      STD	Y+5,R25
    00EEE 838C      STD	Y+4,R24
    00EEF 01F7      MOVW	R30,R14
    00EF0 800E      LDD	R0,Y+6
    00EF1 801F      LDD	R1,Y+7
    00EF2 0DE0      ADD	R30,R0
    00EF3 1DF1      ADC	R31,R1
    00EF4 8340      ST	Z,R20
(1799) 			sfn[i++] = d;
    00EF5 017C      MOVW	R14,R24
    00EF6 9601      ADIW	R24,1
    00EF7 839D      STD	Y+5,R25
    00EF8 838C      STD	Y+4,R24
    00EF9 01F7      MOVW	R30,R14
    00EFA 800E      LDD	R0,Y+6
    00EFB 801F      LDD	R1,Y+7
    00EFC 0DE0      ADD	R30,R0
    00EFD 1DF1      ADC	R31,R1
    00EFE 82A0      ST	Z,R10
(1800) 		} else {						/* Single byte code */
    00EFF CF93      RJMP	0x0E93
(1801) 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    00F00 2F24      MOV	R18,R20
    00F01 2733      CLR	R19
    00F02 E000      LDI	R16,0
    00F03 E011      LDI	R17,1
    00F04 940E 0329 CALL	ff.c:chk_chr
    00F06 0158      MOVW	R10,R16
    00F07 3000      CPI	R16,0
    00F08 0701      CPC	R16,R17
    00F09 F011      BEQ	0x0F0C
(1802) 				return FR_INVALID_NAME;
    00F0A E006      LDI	R16,6
    00F0B C057      RJMP	0x0F63
(1803) 			if (IsUpper(c)) {			/* ASCII large capital? */
    00F0C 3441      CPI	R20,0x41
    00F0D F038      BCS	0x0F15
    00F0E E58A      LDI	R24,0x5A
    00F0F 1784      CP	R24,R20
    00F10 F020      BCS	0x0F15
(1804) 				b |= 2;
    00F11 8588      LDD	R24,Y+8
    00F12 6082      ORI	R24,2
    00F13 8788      STD	Y+8,R24
(1805) 			} else {
    00F14 C009      RJMP	0x0F1E
(1806) 				if (IsLower(c)) {		/* ASCII small capital? */
    00F15 3641      CPI	R20,0x61
    00F16 F038      BCS	0x0F1E
    00F17 E78A      LDI	R24,0x7A
    00F18 1784      CP	R24,R20
    00F19 F020      BCS	0x0F1E
(1807) 					b |= 1; c -= 0x20;
    00F1A 8588      LDD	R24,Y+8
    00F1B 6081      ORI	R24,1
    00F1C 8788      STD	Y+8,R24
    00F1D 5240      SUBI	R20,0x20
(1808) 				}
(1809) 			}
(1810) 			sfn[i++] = c;
    00F1E 80AC      LDD	R10,Y+4
    00F1F 80BD      LDD	R11,Y+5
    00F20 01C5      MOVW	R24,R10
    00F21 9601      ADIW	R24,1
    00F22 839D      STD	Y+5,R25
    00F23 838C      STD	Y+4,R24
    00F24 01F5      MOVW	R30,R10
    00F25 800E      LDD	R0,Y+6
    00F26 801F      LDD	R1,Y+7
    00F27 0DE0      ADD	R30,R0
    00F28 1DF1      ADC	R31,R1
    00F29 8340      ST	Z,R20
    00F2A CF68      RJMP	0x0E93
(1811) 		}
(1812) 	}
(1813) 	*path = &p[si];						/* Return pointer to the next segment */
    00F2B 011B      MOVW	R2,R22
    00F2C 800A      LDD	R0,Y+2
    00F2D 801B      LDD	R1,Y+3
    00F2E 0C20      ADD	R2,R0
    00F2F 1C31      ADC	R3,R1
    00F30 89EB      LDD	R30,Y+19
    00F31 89FC      LDD	R31,Y+20
    00F32 8231      STD	Z+1,R3
    00F33 8220      ST	Z,R2
(1814) 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    00F34 E280      LDI	R24,0x20
    00F35 1784      CP	R24,R20
    00F36 F018      BCS	0x0F3A
    00F37 E064      LDI	R22,4
    00F38 E070      LDI	R23,0
    00F39 C002      RJMP	0x0F3C
    00F3A 2766      CLR	R22
    00F3B 2777      CLR	R23
    00F3C 2F46      MOV	R20,R22
(1815) 
(1816) 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    00F3D 800C      LDD	R0,Y+4
    00F3E 801D      LDD	R1,Y+5
    00F3F 2000      TST	R0
    00F40 F421      BNE	0x0F45
    00F41 2011      TST	R1
    00F42 F411      BNE	0x0F45
    00F43 E006      LDI	R16,6
    00F44 C01E      RJMP	0x0F63
(1817) 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    00F45 81EE      LDD	R30,Y+6
    00F46 81FF      LDD	R31,Y+7
    00F47 8180      LD	R24,Z
    00F48 3E85      CPI	R24,0xE5
    00F49 F411      BNE	0x0F4C
    00F4A E085      LDI	R24,5
    00F4B 8380      ST	Z,R24
(1818) 
(1819) 	if (ni == 8) b <<= 2;
    00F4C 01C6      MOVW	R24,R12
    00F4D 3088      CPI	R24,0x8
    00F4E E0E0      LDI	R30,0
    00F4F 079E      CPC	R25,R30
    00F50 F421      BNE	0x0F55
    00F51 8408      LDD	R0,Y+8
    00F52 0C00      LSL	R0
    00F53 0C00      LSL	R0
    00F54 8608      STD	Y+8,R0
(1820) 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    00F55 8588      LDD	R24,Y+8
    00F56 7083      ANDI	R24,3
    00F57 3081      CPI	R24,1
    00F58 F409      BNE	0x0F5A
    00F59 6140      ORI	R20,0x10
(1821) 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    00F5A 8588      LDD	R24,Y+8
    00F5B 708C      ANDI	R24,0xC
    00F5C 3084      CPI	R24,4
    00F5D F409      BNE	0x0F5F
    00F5E 6048      ORI	R20,0x8
(1822) 
(1823) 	sfn[NS] = c;		/* Store NT flag, File name is created */
    00F5F 81EE      LDD	R30,Y+6
    00F60 81FF      LDD	R31,Y+7
    00F61 8743      STD	Z+11,R20
(1824) 
(1825) 	return FR_OK;
    00F62 2700      CLR	R16
    00F63 9629      ADIW	R28,0x9
    00F64 940E 3F62 CALL	pop_xgsetF0FC
    00F66 9622      ADIW	R28,2
    00F67 9508      RET
ff.c:get_fileinfo:
  nt                   --> R12
  p                    --> R20
  dir                  --> R10
  i                    --> R12
  c                    --> R14
  fno                  --> R22
  dj                   --> R10
    00F68 940E 3F6D CALL	push_xgsetF0FC
    00F6A 01B9      MOVW	R22,R18
    00F6B 0158      MOVW	R10,R16
(1826) #endif
(1827) }
(1828) 
(1829) 
(1830) 
(1831) 
(1832) /*-----------------------------------------------------------------------*/
(1833) /* Get file information from directory entry                             */
(1834) /*-----------------------------------------------------------------------*/
(1835) #if _FS_MINIMIZE <= 1
(1836) static
(1837) void get_fileinfo (		/* No return code */
(1838) 	DIR *dj,			/* Pointer to the directory object */
(1839) 	FILINFO *fno	 	/* Pointer to the file information to be filled */
(1840) )
(1841) {
(1842) 	UINT i;
(1843) 	BYTE nt, *dir;
(1844) 	TCHAR *p, c;
(1845) 
(1846) 
(1847) 	p = fno->fname;
    00F6C 01AB      MOVW	R20,R22
    00F6D 5F47      SUBI	R20,0xF7
    00F6E 4F5F      SBCI	R21,0xFF
(1848) 	if (dj->sect) {
    00F6F 01F5      MOVW	R30,R10
    00F70 963E      ADIW	R30,0xE
    00F71 8020      LD	R2,Z
    00F72 8031      LDD	R3,Z+1
    00F73 8042      LDD	R4,Z+2
    00F74 8053      LDD	R5,Z+3
    00F75 9488      BCLR	0
    00F76 2022      TST	R2
    00F77 0432      CPC	R3,R2
    00F78 0442      CPC	R4,R2
    00F79 0452      CPC	R5,R2
    00F7A F409      BNE	0x0F7C
    00F7B C08A      RJMP	0x1006
(1849) 		dir = dj->dir;
    00F7C 01F5      MOVW	R30,R10
    00F7D 88A2      LDD	R10,Z+18
    00F7E 88B3      LDD	R11,Z+19
(1850) 		nt = dir[DIR_NTres];		/* NT flag */
(1851) 		for (i = 0; i < 8; i++) {	/* Copy name body */
    00F7F 24CC      CLR	R12
    00F80 24DD      CLR	R13
    00F81 C014      RJMP	0x0F96
(1852) 			c = dir[i];
    00F82 01F6      MOVW	R30,R12
    00F83 0DEA      ADD	R30,R10
    00F84 1DFB      ADC	R31,R11
    00F85 80E0      LD	R14,Z
(1853) 			if (c == ' ') break;
    00F86 2D8E      MOV	R24,R14
    00F87 3280      CPI	R24,0x20
    00F88 F409      BNE	0x0F8A
    00F89 C011      RJMP	0x0F9B
(1854) 			if (c == NDDE) c = (TCHAR)DDE;
    00F8A 2D8E      MOV	R24,R14
    00F8B 3085      CPI	R24,5
    00F8C F411      BNE	0x0F8F
    00F8D EE85      LDI	R24,0xE5
    00F8E 2EE8      MOV	R14,R24
(1855) 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
    00F8F C000      RJMP	0x0F90
(1856) #if _LFN_UNICODE
(1857) 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
(1858) 				c = (c << 8) | dir[++i];
(1859) 			c = ff_convert(c, 1);
(1860) 			if (!c) c = '?';
(1861) #endif
(1862) 			*p++ = c;
    00F90 01FA      MOVW	R30,R20
    00F91 92E1      ST	Z+,R14
    00F92 01AF      MOVW	R20,R30
    00F93 01C6      MOVW	R24,R12
    00F94 9601      ADIW	R24,1
    00F95 016C      MOVW	R12,R24
    00F96 01C6      MOVW	R24,R12
    00F97 3088      CPI	R24,0x8
    00F98 E0E0      LDI	R30,0
    00F99 079E      CPC	R25,R30
    00F9A F338      BCS	0x0F82
(1863) 		}
(1864) 		if (dir[8] != ' ') {		/* Copy name extension */
    00F9B 01F5      MOVW	R30,R10
    00F9C 8580      LDD	R24,Z+8
    00F9D 3280      CPI	R24,0x20
    00F9E F0E1      BEQ	0x0FBB
(1865) 			*p++ = '.';
    00F9F E28E      LDI	R24,0x2E
    00FA0 01FA      MOVW	R30,R20
    00FA1 9381      ST	Z+,R24
    00FA2 01AF      MOVW	R20,R30
(1866) 			for (i = 8; i < 11; i++) {
    00FA3 E088      LDI	R24,0x8
    00FA4 E090      LDI	R25,0
    00FA5 016C      MOVW	R12,R24
    00FA6 C00F      RJMP	0x0FB6
(1867) 				c = dir[i];
    00FA7 01F6      MOVW	R30,R12
    00FA8 0DEA      ADD	R30,R10
    00FA9 1DFB      ADC	R31,R11
    00FAA 80E0      LD	R14,Z
(1868) 				if (c == ' ') break;
    00FAB 2D8E      MOV	R24,R14
    00FAC 3280      CPI	R24,0x20
    00FAD F409      BNE	0x0FAF
    00FAE C00C      RJMP	0x0FBB
(1869) 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
    00FAF C000      RJMP	0x0FB0
(1870) #if _LFN_UNICODE
(1871) 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
(1872) 					c = (c << 8) | dir[++i];
(1873) 				c = ff_convert(c, 1);
(1874) 				if (!c) c = '?';
(1875) #endif
(1876) 				*p++ = c;
    00FB0 01FA      MOVW	R30,R20
    00FB1 92E1      ST	Z+,R14
    00FB2 01AF      MOVW	R20,R30
    00FB3 01C6      MOVW	R24,R12
    00FB4 9601      ADIW	R24,1
    00FB5 016C      MOVW	R12,R24
    00FB6 01C6      MOVW	R24,R12
    00FB7 308B      CPI	R24,0xB
    00FB8 E0E0      LDI	R30,0
    00FB9 079E      CPC	R25,R30
    00FBA F360      BCS	0x0FA7
(1877) 			}
(1878) 		}
(1879) 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    00FBB 01F5      MOVW	R30,R10
    00FBC 8423      LDD	R2,Z+11
    00FBD 01FB      MOVW	R30,R22
    00FBE 8620      STD	Z+8,R2
(1880) 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    00FBF E188      LDI	R24,0x18
    00FC0 E090      LDI	R25,0
    00FC1 01F5      MOVW	R30,R10
    00FC2 8D07      LDD	R16,Z+31
    00FC3 2711      CLR	R17
    00FC4 2722      CLR	R18
    00FC5 2733      CLR	R19
    00FC6 938A      ST	-Y,R24
    00FC7 940E 3FEF CALL	lsl32
    00FC9 0118      MOVW	R2,R16
    00FCA 0129      MOVW	R4,R18
    00FCB 01F5      MOVW	R30,R10
    00FCC 8C66      LDD	R6,Z+30
    00FCD 2477      CLR	R7
    00FCE 2488      CLR	R8
    00FCF 2499      CLR	R9
    00FD0 0143      MOVW	R8,R6
    00FD1 2466      CLR	R6
    00FD2 2477      CLR	R7
    00FD3 2826      OR	R2,R6
    00FD4 2837      OR	R3,R7
    00FD5 2848      OR	R4,R8
    00FD6 2859      OR	R5,R9
    00FD7 8C65      LDD	R6,Z+29
    00FD8 2477      CLR	R7
    00FD9 2C76      MOV	R7,R6
    00FDA 2466      CLR	R6
    00FDB 2488      CLR	R8
    00FDC 2499      CLR	R9
    00FDD 2826      OR	R2,R6
    00FDE 2837      OR	R3,R7
    00FDF 2848      OR	R4,R8
    00FE0 2859      OR	R5,R9
    00FE1 8C64      LDD	R6,Z+28
    00FE2 2477      CLR	R7
    00FE3 2488      CLR	R8
    00FE4 2499      CLR	R9
    00FE5 2826      OR	R2,R6
    00FE6 2837      OR	R3,R7
    00FE7 2848      OR	R4,R8
    00FE8 2859      OR	R5,R9
    00FE9 01FB      MOVW	R30,R22
    00FEA 8220      ST	Z,R2
    00FEB 8231      STD	Z+1,R3
    00FEC 8242      STD	Z+2,R4
    00FED 8253      STD	Z+3,R5
(1881) 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    00FEE 01F5      MOVW	R30,R10
    00FEF 8C20      LDD	R2,Z+24
    00FF0 2433      CLR	R3
    00FF1 8C41      LDD	R4,Z+25
    00FF2 2455      CLR	R5
    00FF3 2C54      MOV	R5,R4
    00FF4 2444      CLR	R4
    00FF5 2842      OR	R4,R2
    00FF6 2853      OR	R5,R3
    00FF7 01FB      MOVW	R30,R22
    00FF8 8255      STD	Z+5,R5
    00FF9 8244      STD	Z+4,R4
(1882) 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    00FFA 01F5      MOVW	R30,R10
    00FFB 8826      LDD	R2,Z+22
    00FFC 2433      CLR	R3
    00FFD 8847      LDD	R4,Z+23
    00FFE 2455      CLR	R5
    00FFF 2C54      MOV	R5,R4
    01000 2444      CLR	R4
    01001 2842      OR	R4,R2
    01002 2853      OR	R5,R3
    01003 01FB      MOVW	R30,R22
    01004 8257      STD	Z+7,R5
    01005 8246      STD	Z+6,R4
(1883) 	}
(1884) 	*p = 0;		/* Terminate SFN str by a \0 */
    01006 2422      CLR	R2
    01007 01FA      MOVW	R30,R20
    01008 8220      ST	Z,R2
    01009 940C 3F62 JMP	pop_xgsetF0FC
ff.c:follow_path:
  ns                   --> R10
  res                  --> R20
  dir                  --> R10
  path                 --> Y,+6
  dj                   --> R22
    0100B 933A      ST	-Y,R19
    0100C 932A      ST	-Y,R18
    0100D 940E 3F8C CALL	push_xgsetF00C
    0100F 01B8      MOVW	R22,R16
(1885) 
(1886) #if _USE_LFN
(1887) 	if (fno->lfname && fno->lfsize) {
(1888) 		TCHAR *tp = fno->lfname;
(1889) 		WCHAR w, *lfn;
(1890) 
(1891) 		i = 0;
(1892) 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
(1893) 			lfn = dj->lfn;
(1894) 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
(1895) #if !_LFN_UNICODE
(1896) 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
(1897) 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
(1898) 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
(1899) 					tp[i++] = (TCHAR)(w >> 8);
(1900) #endif
(1901) 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
(1902) 				tp[i++] = (TCHAR)w;
(1903) 			}
(1904) 		}
(1905) 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
(1906) 	}
(1907) #endif
(1908) }
(1909) #endif /* _FS_MINIMIZE <= 1 */
(1910) 
(1911) 
(1912) 
(1913) 
(1914) /*-----------------------------------------------------------------------*/
(1915) /* Follow a file path                                                    */
(1916) /*-----------------------------------------------------------------------*/
(1917) 
(1918) static
(1919) FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
(1920) 	DIR *dj,			/* Directory object to return last directory and found object */
(1921) 	const TCHAR *path	/* Full-path string to find a file or directory */
(1922) )
(1923) {
(1924) 	FRESULT res;
(1925) 	BYTE *dir, ns;
(1926) 
(1927) 
(1928) #if _FS_RPATH
(1929) 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
(1930) 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
(1931) 	} else {							/* No heading separator */
(1932) 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
(1933) 	}
(1934) #else
(1935) 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    01010 81EE      LDD	R30,Y+6
    01011 81FF      LDD	R31,Y+7
    01012 8020      LD	R2,Z
    01013 2433      CLR	R3
    01014 2D82      MOV	R24,R2
    01015 328F      CPI	R24,0x2F
    01016 F011      BEQ	0x1019
    01017 358C      CPI	R24,0x5C
    01018 F429      BNE	0x101E
(1936) 		path++;
    01019 818E      LDD	R24,Y+6
    0101A 819F      LDD	R25,Y+7
    0101B 9601      ADIW	R24,1
    0101C 839F      STD	Y+7,R25
    0101D 838E      STD	Y+6,R24
(1937) 	dj->sclust = 0;						/* Start from the root dir */
    0101E 01FB      MOVW	R30,R22
    0101F 9636      ADIW	R30,6
    01020 E080      LDI	R24,0
    01021 8380      ST	Z,R24
    01022 8381      STD	Z+1,R24
    01023 8382      STD	Z+2,R24
    01024 8383      STD	Z+3,R24
(1938) #endif
(1939) 
(1940) 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    01025 81EE      LDD	R30,Y+6
    01026 81FF      LDD	R31,Y+7
    01027 8180      LD	R24,Z
    01028 2799      CLR	R25
    01029 3280      CPI	R24,0x20
    0102A E0E0      LDI	R30,0
    0102B 079E      CPC	R25,R30
    0102C F458      BCC	0x1038
(1941) 		res = dir_sdi(dj, 0);
    0102D 2722      CLR	R18
    0102E 2733      CLR	R19
    0102F 018B      MOVW	R16,R22
    01030 DA84      RCALL	ff.c:dir_sdi
    01031 2F40      MOV	R20,R16
(1942) 		dj->dir = 0;
    01032 2422      CLR	R2
    01033 2433      CLR	R3
    01034 01FB      MOVW	R30,R22
    01035 8A33      STD	Z+19,R3
    01036 8A22      STD	Z+18,R2
(1943) 
(1944) 	} else {							/* Follow path */
    01037 C052      RJMP	0x108A
(1945) 		for (;;) {
(1946) 			res = create_name(dj, &path);	/* Get a segment */
    01038 019E      MOVW	R18,R28
    01039 5F2A      SUBI	R18,0xFA
    0103A 4F3F      SBCI	R19,0xFF
    0103B 018B      MOVW	R16,R22
    0103C DE23      RCALL	ff.c:create_name
    0103D 2EA0      MOV	R10,R16
    0103E 2D4A      MOV	R20,R10
(1947) 			if (res != FR_OK) break;
    0103F 2300      TST	R16
    01040 F009      BEQ	0x1042
    01041 C048      RJMP	0x108A
(1948) 			res = dir_find(dj);				/* Find it */
    01042 018B      MOVW	R16,R22
    01043 DD29      RCALL	ff.c:dir_find
    01044 2EA0      MOV	R10,R16
    01045 2D4A      MOV	R20,R10
(1949) 			ns = *(dj->fn+NS);
    01046 01FB      MOVW	R30,R22
    01047 93AF      PUSH	R26
    01048 93BF      PUSH	R27
    01049 89A4      LDD	R26,Z+20
    0104A 89B5      LDD	R27,Z+21
    0104B 01FD      MOVW	R30,R26
    0104C 91BF      POP	R27
    0104D 91AF      POP	R26
    0104E 84A3      LDD	R10,Z+11
(1950) 			if (res != FR_OK) {				/* Failed to find the object */
    0104F 2300      TST	R16
    01050 F049      BEQ	0x105A
(1951) 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    01051 3004      CPI	R16,4
    01052 F009      BEQ	0x1054
    01053 C036      RJMP	0x108A
(1952) 				/* Object not found */
(1953) 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    01054 C001      RJMP	0x1056
(1954) 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
(1955) 					res = FR_OK;
(1956) 					if (!(ns & NS_LAST)) continue;
    01055 CFE2      RJMP	0x1038
(1957) 				} else {							/* Could not find the object */
(1958) 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    01056 FCA2      SBRC	R10,2
    01057 C032      RJMP	0x108A
    01058 E045      LDI	R20,5
(1959) 				}
(1960) 				break;
    01059 C030      RJMP	0x108A
(1961) 			}
(1962) 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    0105A FEA2      SBRS	R10,2
    0105B C001      RJMP	0x105D
    0105C C02D      RJMP	0x108A
(1963) 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    0105D 01FB      MOVW	R30,R22
    0105E 88A2      LDD	R10,Z+18
    0105F 88B3      LDD	R11,Z+19
(1964) 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    01060 01F5      MOVW	R30,R10
    01061 8423      LDD	R2,Z+11
    01062 FC24      SBRC	R2,4
    01063 C002      RJMP	0x1066
(1965) 				res = FR_NO_PATH; break;
    01064 E045      LDI	R20,5
    01065 C024      RJMP	0x108A
(1966) 			}
(1967) 			dj->sclust = LD_CLUST(dir);
    01066 01F5      MOVW	R30,R10
    01067 8C22      LDD	R2,Z+26
    01068 2433      CLR	R3
    01069 8C43      LDD	R4,Z+27
    0106A 2455      CLR	R5
    0106B 2C54      MOV	R5,R4
    0106C 2444      CLR	R4
    0106D 2842      OR	R4,R2
    0106E 2853      OR	R5,R3
    0106F 0112      MOVW	R2,R4
    01070 2444      CLR	R4
    01071 2455      CLR	R5
    01072 8864      LDD	R6,Z+20
    01073 2477      CLR	R7
    01074 8885      LDD	R8,Z+21
    01075 2499      CLR	R9
    01076 2C98      MOV	R9,R8
    01077 2488      CLR	R8
    01078 2886      OR	R8,R6
    01079 2897      OR	R9,R7
    0107A 0134      MOVW	R6,R8
    0107B 2488      CLR	R8
    0107C 2499      CLR	R9
    0107D 0143      MOVW	R8,R6
    0107E 2466      CLR	R6
    0107F 2477      CLR	R7
    01080 2862      OR	R6,R2
    01081 2873      OR	R7,R3
    01082 2884      OR	R8,R4
    01083 2895      OR	R9,R5
    01084 01FB      MOVW	R30,R22
    01085 8266      STD	Z+6,R6
    01086 8277      STD	Z+7,R7
    01087 8680      STD	Z+8,R8
    01088 8691      STD	Z+9,R9
    01089 CFAE      RJMP	0x1038
(1968) 		}
(1969) 	}
(1970) 
(1971) 	return res;
    0108A 2F04      MOV	R16,R20
    0108B 940E 3F93 CALL	pop_xgsetF00C
    0108D 9622      ADIW	R28,2
    0108E 9508      RET
ff.c:check_fs:
  sect                 --> Y,+11
  fs                   --> R10
    0108F 933A      ST	-Y,R19
    01090 932A      ST	-Y,R18
    01091 940E 3F8C CALL	push_xgsetF00C
    01093 0158      MOVW	R10,R16
    01094 9725      SBIW	R28,5
(1972) }
(1973) 
(1974) 
(1975) 
(1976) 
(1977) /*-----------------------------------------------------------------------*/
(1978) /* Load a sector and check if it is an FAT Volume Boot Record            */
(1979) /*-----------------------------------------------------------------------*/
(1980) 
(1981) static
(1982) BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
(1983) 	FATFS *fs,	/* File system object */
(1984) 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
(1985) )
(1986) {
(1987) 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    01095 E081      LDI	R24,1
    01096 838C      STD	Y+4,R24
    01097 842B      LDD	R2,Y+11
    01098 843C      LDD	R3,Y+12
    01099 844D      LDD	R4,Y+13
    0109A 845E      LDD	R5,Y+14
    0109B 8228      ST	Y,R2
    0109C 8239      STD	Y+1,R3
    0109D 824A      STD	Y+2,R4
    0109E 825B      STD	Y+3,R5
    0109F 0195      MOVW	R18,R10
    010A0 5D22      SUBI	R18,0xD2
    010A1 4F3F      SBCI	R19,0xFF
    010A2 01F5      MOVW	R30,R10
    010A3 8101      LDD	R16,Z+1
    010A4 940E 029E CALL	_disk_read
    010A6 2300      TST	R16
    010A7 F011      BEQ	0x10AA
(1988) 		return 3;
    010A8 E003      LDI	R16,3
    010A9 C0A8      RJMP	0x1152
(1989) 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    010AA 01F5      MOVW	R30,R10
    010AB 5DE4      SUBI	R30,0xD4
    010AC 4FFD      SBCI	R31,0xFD
    010AD 8020      LD	R2,Z
    010AE 52EC      SUBI	R30,0x2C
    010AF 40F2      SBCI	R31,2
    010B0 2433      CLR	R3
    010B1 5DE3      SUBI	R30,0xD3
    010B2 4FFD      SBCI	R31,0xFD
    010B3 8180      LD	R24,Z
    010B4 2799      CLR	R25
    010B5 2F98      MOV	R25,R24
    010B6 2788      CLR	R24
    010B7 2982      OR	R24,R2
    010B8 2993      OR	R25,R3
    010B9 3585      CPI	R24,0x55
    010BA EAEA      LDI	R30,0xAA
    010BB 079E      CPC	R25,R30
    010BC F011      BEQ	0x10BF
(1990) 		return 2;
    010BD E002      LDI	R16,2
    010BE C093      RJMP	0x1152
(1991) 
(1992) 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    010BF E188      LDI	R24,0x18
    010C0 E090      LDI	R25,0
    010C1 01F5      MOVW	R30,R10
    010C2 59E9      SUBI	R30,0x99
    010C3 4FFF      SBCI	R31,0xFF
    010C4 8100      LD	R16,Z
    010C5 2711      CLR	R17
    010C6 2722      CLR	R18
    010C7 2733      CLR	R19
    010C8 938A      ST	-Y,R24
    010C9 940E 3FEF CALL	lsl32
    010CB 0118      MOVW	R2,R16
    010CC 0129      MOVW	R4,R18
    010CD 01F5      MOVW	R30,R10
    010CE 59EA      SUBI	R30,0x9A
    010CF 4FFF      SBCI	R31,0xFF
    010D0 8060      LD	R6,Z
    010D1 56E6      SUBI	R30,0x66
    010D2 40F0      SBCI	R31,0
    010D3 2477      CLR	R7
    010D4 2488      CLR	R8
    010D5 2499      CLR	R9
    010D6 0143      MOVW	R8,R6
    010D7 2466      CLR	R6
    010D8 2477      CLR	R7
    010D9 2826      OR	R2,R6
    010DA 2837      OR	R3,R7
    010DB 2848      OR	R4,R8
    010DC 2859      OR	R5,R9
    010DD 59EB      SUBI	R30,0x9B
    010DE 4FFF      SBCI	R31,0xFF
    010DF 8060      LD	R6,Z
    010E0 56E5      SUBI	R30,0x65
    010E1 40F0      SBCI	R31,0
    010E2 2477      CLR	R7
    010E3 2C76      MOV	R7,R6
    010E4 2466      CLR	R6
    010E5 2488      CLR	R8
    010E6 2499      CLR	R9
    010E7 2826      OR	R2,R6
    010E8 2837      OR	R3,R7
    010E9 2848      OR	R4,R8
    010EA 2859      OR	R5,R9
    010EB 59EC      SUBI	R30,0x9C
    010EC 4FFF      SBCI	R31,0xFF
    010ED 8060      LD	R6,Z
    010EE 2477      CLR	R7
    010EF 2488      CLR	R8
    010F0 2499      CLR	R9
    010F1 2826      OR	R2,R6
    010F2 2837      OR	R3,R7
    010F3 2848      OR	R4,R8
    010F4 2859      OR	R5,R9
    010F5 EF4F      LDI	R20,0xFF
    010F6 EF5F      LDI	R21,0xFF
    010F7 EF6F      LDI	R22,0xFF
    010F8 E070      LDI	R23,0
    010F9 2224      AND	R2,R20
    010FA 2235      AND	R3,R21
    010FB 2246      AND	R4,R22
    010FC 2257      AND	R5,R23
    010FD E446      LDI	R20,0x46
    010FE E451      LDI	R21,0x41
    010FF E564      LDI	R22,0x54
    01100 E070      LDI	R23,0
    01101 1624      CP	R2,R20
    01102 0635      CPC	R3,R21
    01103 0646      CPC	R4,R22
    01104 0657      CPC	R5,R23
    01105 F411      BNE	0x1108
(1993) 		return 0;
    01106 2700      CLR	R16
    01107 C04A      RJMP	0x1152
(1994) 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    01108 E188      LDI	R24,0x18
    01109 E090      LDI	R25,0
    0110A 01F5      MOVW	R30,R10
    0110B 57ED      SUBI	R30,0x7D
    0110C 4FFF      SBCI	R31,0xFF
    0110D 8100      LD	R16,Z
    0110E 2711      CLR	R17
    0110F 2722      CLR	R18
    01110 2733      CLR	R19
    01111 938A      ST	-Y,R24
    01112 940E 3FEF CALL	lsl32
    01114 0118      MOVW	R2,R16
    01115 0129      MOVW	R4,R18
    01116 01F5      MOVW	R30,R10
    01117 57EE      SUBI	R30,0x7E
    01118 4FFF      SBCI	R31,0xFF
    01119 8060      LD	R6,Z
    0111A 58E2      SUBI	R30,0x82
    0111B 40F0      SBCI	R31,0
    0111C 2477      CLR	R7
    0111D 2488      CLR	R8
    0111E 2499      CLR	R9
    0111F 0143      MOVW	R8,R6
    01120 2466      CLR	R6
    01121 2477      CLR	R7
    01122 2826      OR	R2,R6
    01123 2837      OR	R3,R7
    01124 2848      OR	R4,R8
    01125 2859      OR	R5,R9
    01126 57EF      SUBI	R30,0x7F
    01127 4FFF      SBCI	R31,0xFF
    01128 8060      LD	R6,Z
    01129 58E1      SUBI	R30,0x81
    0112A 40F0      SBCI	R31,0
    0112B 2477      CLR	R7
    0112C 2C76      MOV	R7,R6
    0112D 2466      CLR	R6
    0112E 2488      CLR	R8
    0112F 2499      CLR	R9
    01130 2826      OR	R2,R6
    01131 2837      OR	R3,R7
    01132 2848      OR	R4,R8
    01133 2859      OR	R5,R9
    01134 58E0      SUBI	R30,0x80
    01135 4FFF      SBCI	R31,0xFF
    01136 8060      LD	R6,Z
    01137 2477      CLR	R7
    01138 2488      CLR	R8
    01139 2499      CLR	R9
    0113A 2826      OR	R2,R6
    0113B 2837      OR	R3,R7
    0113C 2848      OR	R4,R8
    0113D 2859      OR	R5,R9
    0113E EF4F      LDI	R20,0xFF
    0113F EF5F      LDI	R21,0xFF
    01140 EF6F      LDI	R22,0xFF
    01141 E070      LDI	R23,0
    01142 2224      AND	R2,R20
    01143 2235      AND	R3,R21
    01144 2246      AND	R4,R22
    01145 2257      AND	R5,R23
    01146 E446      LDI	R20,0x46
    01147 E451      LDI	R21,0x41
    01148 E564      LDI	R22,0x54
    01149 E070      LDI	R23,0
    0114A 1624      CP	R2,R20
    0114B 0635      CPC	R3,R21
    0114C 0646      CPC	R4,R22
    0114D 0657      CPC	R5,R23
    0114E F411      BNE	0x1151
(1995) 		return 0;
    0114F 2700      CLR	R16
    01150 C001      RJMP	0x1152
(1996) 
(1997) 	return 1;
    01151 E001      LDI	R16,1
    01152 9625      ADIW	R28,5
    01153 940E 3F93 CALL	pop_xgsetF00C
    01155 9622      ADIW	R28,2
    01156 9508      RET
ff.c:chk_mounted:
  pi                   --> R10
  szbfat               --> Y,+25
  tbl                  --> R10
  p                    --> R10
  nrsv                 --> R14
  sysect               --> Y,+21
  bsect                --> Y,+17
  stat                 --> R10
  tsect                --> Y,+13
  nclst                --> Y,+9
  vol                  --> R14
  fasize               --> Y,+5
  b                    --> R14
  fmt                  --> R12
  fs                   --> Y,+37
  chk_wp               --> Y,+51
  rfs                  --> Y,+49
  path                 --> R12
    01157 933A      ST	-Y,R19
    01158 932A      ST	-Y,R18
    01159 940E 3F6D CALL	push_xgsetF0FC
    0115B 0168      MOVW	R12,R16
    0115C 97A7      SBIW	R28,0x27
(1998) }
(1999) 
(2000) 
(2001) 
(2002) 
(2003) /*-----------------------------------------------------------------------*/
(2004) /* Check if the file system object is valid or not                       */
(2005) /*-----------------------------------------------------------------------*/
(2006) 
(2007) static
(2008) FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
(2009) 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
(2010) 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
(2011) 	BYTE chk_wp			/* !=0: Check media write protection for write access */
(2012) )
(2013) {
(2014) 	BYTE fmt, b, pi, *tbl;
(2015) 	UINT vol;
(2016) 	DSTATUS stat;
(2017) 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
(2018) 	WORD nrsv;
(2019) 	const TCHAR *p = *path;
    0115D 01F6      MOVW	R30,R12
    0115E 80A0      LD	R10,Z
    0115F 80B1      LDD	R11,Z+1
(2020) 	FATFS *fs;
(2021) 
(2022) 	/* Get logical drive number from the path name */
(2023) 	vol = p[0] - '0';					/* Is there a drive number? */
    01160 01F5      MOVW	R30,R10
    01161 8180      LD	R24,Z
    01162 2799      CLR	R25
    01163 97C0      SBIW	R24,0x30
    01164 017C      MOVW	R14,R24
(2024) 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    01165 E089      LDI	R24,0x9
    01166 E090      LDI	R25,0
    01167 158E      CP	R24,R14
    01168 059F      CPC	R25,R15
    01169 F050      BCS	0x1174
    0116A 8181      LDD	R24,Z+1
    0116B 338A      CPI	R24,0x3A
    0116C F439      BNE	0x1174
(2025) 		p += 2; *path = p;				/* Return pointer to the path name */
    0116D 01CF      MOVW	R24,R30
    0116E 9602      ADIW	R24,2
    0116F 015C      MOVW	R10,R24
    01170 01F6      MOVW	R30,R12
    01171 82B1      STD	Z+1,R11
    01172 82A0      ST	Z,R10
(2026) 	} else {							/* No drive number is given */
    01173 C002      RJMP	0x1176
(2027) #if _FS_RPATH
(2028) 		vol = CurrVol;					/* Use current drive */
(2029) #else
(2030) 		vol = 0;						/* Use drive 0 */
    01174 24EE      CLR	R14
    01175 24FF      CLR	R15
(2031) #endif
(2032) 	}
(2033) 
(2034) 	/* Check if the file system object is valid or not */
(2035) 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    01176 01C7      MOVW	R24,R14
    01177 3081      CPI	R24,1
    01178 E0E0      LDI	R30,0
    01179 079E      CPC	R25,R30
    0117A F010      BCS	0x117D
(2036) 		return FR_INVALID_DRIVE;
    0117B E00B      LDI	R16,0xB
    0117C C4CF      RJMP	0x164C
(2037) 	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    0117D EF80      LDI	R24,0xF0
    0117E E094      LDI	R25,4
    0117F 01F7      MOVW	R30,R14
    01180 0FEE      LSL	R30
    01181 1FFF      ROL	R31
    01182 0FE8      ADD	R30,R24
    01183 1FF9      ADC	R31,R25
    01184 8020      LD	R2,Z
    01185 8031      LDD	R3,Z+1
    01186 A23E      STD	Y+38,R3
    01187 A22D      STD	Y+37,R2
    01188 A9E9      LDD	R30,Y+49
    01189 A9FA      LDD	R31,Y+50
    0118A 8231      STD	Z+1,R3
    0118B 8220      ST	Z,R2
(2038) 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    0118C 0101      MOVW	R0,R2
    0118D 2022      TST	R2
    0118E F421      BNE	0x1193
    0118F 2033      TST	R3
    01190 F411      BNE	0x1193
    01191 E00C      LDI	R16,0xC
    01192 C4B9      RJMP	0x164C
(2039) 
(2040) 	ENTER_FF(fs);						/* Lock file system */
(2041) 
(2042) 	if (fs->fs_type) {					/* If the logical drive has been mounted */
    01193 A1ED      LDD	R30,Y+37
    01194 A1FE      LDD	R31,Y+38
    01195 8020      LD	R2,Z
    01196 2022      TST	R2
    01197 F079      BEQ	0x11A7
(2043) 		stat = disk_status(fs->drv);
    01198 8101      LDD	R16,Z+1
    01199 940E 0298 CALL	_disk_status
    0119B 2EA0      MOV	R10,R16
(2044) 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    0119C FD00      SBRC	R16,0
    0119D C009      RJMP	0x11A7
(2045) 			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    0119E A80B      LDD	R0,Y+51
    0119F 2000      TST	R0
    011A0 F021      BEQ	0x11A5
    011A1 FF02      SBRS	R16,2
    011A2 C002      RJMP	0x11A5
(2046) 				return FR_WRITE_PROTECTED;
    011A3 E00A      LDI	R16,0xA
    011A4 C4A7      RJMP	0x164C
(2047) 			return FR_OK;				/* The file system object is valid */
    011A5 2700      CLR	R16
    011A6 C4A5      RJMP	0x164C
(2048) 		}
(2049) 	}
(2050) 
(2051) 	/* The file system object is not valid. */
(2052) 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
(2053) 
(2054) 	fs->fs_type = 0;					/* Clear the file system object */
    011A7 2422      CLR	R2
    011A8 A1ED      LDD	R30,Y+37
    011A9 A1FE      LDD	R31,Y+38
    011AA 8220      ST	Z,R2
(2055) 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    011AB 82E1      STD	Z+1,R14
(2056) 	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    011AC 8101      LDD	R16,Z+1
    011AD 940E 0282 CALL	_disk_initialize
    011AF 2EE0      MOV	R14,R16
    011B0 2CAE      MOV	R10,R14
(2057) 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    011B1 FF00      SBRS	R16,0
    011B2 C002      RJMP	0x11B5
(2058) 		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    011B3 E003      LDI	R16,3
    011B4 C497      RJMP	0x164C
(2059) 	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    011B5 A80B      LDD	R0,Y+51
    011B6 2000      TST	R0
    011B7 F021      BEQ	0x11BC
    011B8 FEA2      SBRS	R10,2
    011B9 C002      RJMP	0x11BC
(2060) 		return FR_WRITE_PROTECTED;
    011BA E00A      LDI	R16,0xA
    011BB C490      RJMP	0x164C
(2061) #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
(2062) 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
(2063) 		return FR_DISK_ERR;
(2064) #endif
(2065) 	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
(2066) 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    011BC E080      LDI	R24,0
    011BD 8B89      STD	Y+17,R24
    011BE 8B8A      STD	Y+18,R24
    011BF 8B8B      STD	Y+19,R24
    011C0 8B8C      STD	Y+20,R24
    011C1 E040      LDI	R20,0
    011C2 E050      LDI	R21,0
    011C3 E060      LDI	R22,0
    011C4 E070      LDI	R23,0
    011C5 8368      ST	Y,R22
    011C6 8379      STD	Y+1,R23
    011C7 019A      MOVW	R18,R20
    011C8 A10D      LDD	R16,Y+37
    011C9 A11E      LDD	R17,Y+38
    011CA DEC4      RCALL	ff.c:check_fs
    011CB 2EA0      MOV	R10,R16
    011CC 2CCA      MOV	R12,R10
(2067) 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
    011CD C000      RJMP	0x11CE
(2068) 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    011CE 2D8C      MOV	R24,R12
    011CF 3081      CPI	R24,1
    011D0 F009      BEQ	0x11D2
    011D1 C04C      RJMP	0x121E
(2069) 		/* Check the partition listed in the partition table */
(2070) 		pi = LD2PT(vol);
    011D2 24AA      CLR	R10
(2071) 		if (pi) pi--;
    011D3 F009      BEQ	0x11D5
    011D4 94AA      DEC	R10
(2072) 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
    011D5 E100      LDI	R16,0x10
    011D6 2D1A      MOV	R17,R10
    011D7 0301      MULSU	R16,R17
    011D8 0150      MOVW	R10,R0
    011D9 A18D      LDD	R24,Y+37
    011DA A19E      LDD	R25,Y+38
    011DB 5184      SUBI	R24,0x14
    011DC 4F9E      SBCI	R25,0xFE
    011DD 0EA8      ADD	R10,R24
    011DE 1EB9      ADC	R11,R25
(2073) 		if (tbl[4]) {						/* Is the partition existing? */
    011DF 01F5      MOVW	R30,R10
    011E0 8024      LDD	R2,Z+4
    011E1 2022      TST	R2
    011E2 F409      BNE	0x11E4
    011E3 C03A      RJMP	0x121E
(2074) 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    011E4 E188      LDI	R24,0x18
    011E5 E090      LDI	R25,0
    011E6 8503      LDD	R16,Z+11
    011E7 2711      CLR	R17
    011E8 2722      CLR	R18
    011E9 2733      CLR	R19
    011EA 938A      ST	-Y,R24
    011EB 940E 3FEF CALL	lsl32
    011ED 0118      MOVW	R2,R16
    011EE 0129      MOVW	R4,R18
    011EF 01F5      MOVW	R30,R10
    011F0 8462      LDD	R6,Z+10
    011F1 2477      CLR	R7
    011F2 2488      CLR	R8
    011F3 2499      CLR	R9
    011F4 0143      MOVW	R8,R6
    011F5 2466      CLR	R6
    011F6 2477      CLR	R7
    011F7 2826      OR	R2,R6
    011F8 2837      OR	R3,R7
    011F9 2848      OR	R4,R8
    011FA 2859      OR	R5,R9
    011FB 8461      LDD	R6,Z+9
    011FC 2477      CLR	R7
    011FD 2C76      MOV	R7,R6
    011FE 2466      CLR	R6
    011FF 2488      CLR	R8
    01200 2499      CLR	R9
    01201 2826      OR	R2,R6
    01202 2837      OR	R3,R7
    01203 2848      OR	R4,R8
    01204 2859      OR	R5,R9
    01205 9638      ADIW	R30,0x8
    01206 8060      LD	R6,Z
    01207 2477      CLR	R7
    01208 2488      CLR	R8
    01209 2499      CLR	R9
    0120A 2826      OR	R2,R6
    0120B 2837      OR	R3,R7
    0120C 2848      OR	R4,R8
    0120D 2859      OR	R5,R9
    0120E 8A29      STD	Y+17,R2
    0120F 8A3A      STD	Y+18,R3
    01210 8A4B      STD	Y+19,R4
    01211 8A5C      STD	Y+20,R5
(2075) 			fmt = check_fs(fs, bsect);		/* Check the partition */
    01212 8829      LDD	R2,Y+17
    01213 883A      LDD	R3,Y+18
    01214 884B      LDD	R4,Y+19
    01215 885C      LDD	R5,Y+20
    01216 8248      ST	Y,R4
    01217 8259      STD	Y+1,R5
    01218 0191      MOVW	R18,R2
    01219 A10D      LDD	R16,Y+37
    0121A A11E      LDD	R17,Y+38
    0121B DE73      RCALL	ff.c:check_fs
    0121C 2EA0      MOV	R10,R16
    0121D 2CCA      MOV	R12,R10
(2076) 		}
(2077) 	}
(2078) 	if (fmt == 3) return FR_DISK_ERR;
    0121E 2D8C      MOV	R24,R12
    0121F 3083      CPI	R24,3
    01220 F411      BNE	0x1223
    01221 E001      LDI	R16,1
    01222 C429      RJMP	0x164C
(2079) 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    01223 20CC      TST	R12
    01224 F011      BEQ	0x1227
    01225 E00D      LDI	R16,0xD
    01226 C425      RJMP	0x164C
(2080) 
(2081) 	/* An FAT volume is found. Following code initializes the file system object */
(2082) 
(2083) 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    01227 A1ED      LDD	R30,Y+37
    01228 A1FE      LDD	R31,Y+38
    01229 AC21      LDD	R2,Z+57
    0122A 2433      CLR	R3
    0122B AD82      LDD	R24,Z+58
    0122C 2799      CLR	R25
    0122D 2F98      MOV	R25,R24
    0122E 2788      CLR	R24
    0122F 2982      OR	R24,R2
    01230 2993      OR	R25,R3
    01231 3080      CPI	R24,0
    01232 E0E2      LDI	R30,2
    01233 079E      CPC	R25,R30
    01234 F011      BEQ	0x1237
(2084) 		return FR_NO_FILESYSTEM;
    01235 E00D      LDI	R16,0xD
    01236 C415      RJMP	0x164C
(2085) 
(2086) 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    01237 A1ED      LDD	R30,Y+37
    01238 A1FE      LDD	R31,Y+38
    01239 5BEC      SUBI	R30,0xBC
    0123A 4FFF      SBCI	R31,0xFF
    0123B 8020      LD	R2,Z
    0123C 54E4      SUBI	R30,0x44
    0123D 40F0      SBCI	R31,0
    0123E 2433      CLR	R3
    0123F 5BEB      SUBI	R30,0xBB
    01240 4FFF      SBCI	R31,0xFF
    01241 8040      LD	R4,Z
    01242 2455      CLR	R5
    01243 2C54      MOV	R5,R4
    01244 2444      CLR	R4
    01245 2842      OR	R4,R2
    01246 2853      OR	R5,R3
    01247 0112      MOVW	R2,R4
    01248 2444      CLR	R4
    01249 2455      CLR	R5
    0124A 822D      STD	Y+5,R2
    0124B 823E      STD	Y+6,R3
    0124C 824F      STD	Y+7,R4
    0124D 8658      STD	Y+8,R5
(2087) 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    0124E 802D      LDD	R2,Y+5
    0124F 803E      LDD	R3,Y+6
    01250 804F      LDD	R4,Y+7
    01251 8458      LDD	R5,Y+8
    01252 9488      BCLR	0
    01253 2022      TST	R2
    01254 0432      CPC	R3,R2
    01255 0442      CPC	R4,R2
    01256 0452      CPC	R5,R2
    01257 F009      BEQ	0x1259
    01258 C03C      RJMP	0x1295
    01259 E188      LDI	R24,0x18
    0125A E090      LDI	R25,0
    0125B A1ED      LDD	R30,Y+37
    0125C A1FE      LDD	R31,Y+38
    0125D 5AEB      SUBI	R30,0xAB
    0125E 4FFF      SBCI	R31,0xFF
    0125F 8100      LD	R16,Z
    01260 2711      CLR	R17
    01261 2722      CLR	R18
    01262 2733      CLR	R19
    01263 938A      ST	-Y,R24
    01264 940E 3FEF CALL	lsl32
    01266 0118      MOVW	R2,R16
    01267 0129      MOVW	R4,R18
    01268 A1ED      LDD	R30,Y+37
    01269 A1FE      LDD	R31,Y+38
    0126A 5AEC      SUBI	R30,0xAC
    0126B 4FFF      SBCI	R31,0xFF
    0126C 8060      LD	R6,Z
    0126D 55E4      SUBI	R30,0x54
    0126E 40F0      SBCI	R31,0
    0126F 2477      CLR	R7
    01270 2488      CLR	R8
    01271 2499      CLR	R9
    01272 0143      MOVW	R8,R6
    01273 2466      CLR	R6
    01274 2477      CLR	R7
    01275 2826      OR	R2,R6
    01276 2837      OR	R3,R7
    01277 2848      OR	R4,R8
    01278 2859      OR	R5,R9
    01279 5AED      SUBI	R30,0xAD
    0127A 4FFF      SBCI	R31,0xFF
    0127B 8060      LD	R6,Z
    0127C 55E3      SUBI	R30,0x53
    0127D 40F0      SBCI	R31,0
    0127E 2477      CLR	R7
    0127F 2C76      MOV	R7,R6
    01280 2466      CLR	R6
    01281 2488      CLR	R8
    01282 2499      CLR	R9
    01283 2826      OR	R2,R6
    01284 2837      OR	R3,R7
    01285 2848      OR	R4,R8
    01286 2859      OR	R5,R9
    01287 5AEE      SUBI	R30,0xAE
    01288 4FFF      SBCI	R31,0xFF
    01289 8060      LD	R6,Z
    0128A 2477      CLR	R7
    0128B 2488      CLR	R8
    0128C 2499      CLR	R9
    0128D 2826      OR	R2,R6
    0128E 2837      OR	R3,R7
    0128F 2848      OR	R4,R8
    01290 2859      OR	R5,R9
    01291 822D      STD	Y+5,R2
    01292 823E      STD	Y+6,R3
    01293 824F      STD	Y+7,R4
    01294 8658      STD	Y+8,R5
(2088) 	fs->fsize = fasize;
    01295 802D      LDD	R2,Y+5
    01296 803E      LDD	R3,Y+6
    01297 804F      LDD	R4,Y+7
    01298 8458      LDD	R5,Y+8
    01299 A1ED      LDD	R30,Y+37
    0129A A1FE      LDD	R31,Y+38
    0129B 8E22      STD	Z+26,R2
    0129C 8E33      STD	Z+27,R3
    0129D 8E44      STD	Z+28,R4
    0129E 8E55      STD	Z+29,R5
(2089) 
(2090) 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    0129F ACA6      LDD	R10,Z+62
    012A0 2CEA      MOV	R14,R10
    012A1 82A3      STD	Z+3,R10
(2091) 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    012A2 2D8E      MOV	R24,R14
    012A3 3081      CPI	R24,1
    012A4 F021      BEQ	0x12A9
    012A5 3082      CPI	R24,2
    012A6 F011      BEQ	0x12A9
    012A7 E00D      LDI	R16,0xD
    012A8 C3A3      RJMP	0x164C
(2092) 	fasize *= b;										/* Number of sectors for FAT area */
    012A9 2C2E      MOV	R2,R14
    012AA 2433      CLR	R3
    012AB 2444      CLR	R4
    012AC 2455      CLR	R5
    012AD 810D      LDD	R16,Y+5
    012AE 811E      LDD	R17,Y+6
    012AF 812F      LDD	R18,Y+7
    012B0 8538      LDD	R19,Y+8
    012B1 925A      ST	-Y,R5
    012B2 924A      ST	-Y,R4
    012B3 923A      ST	-Y,R3
    012B4 922A      ST	-Y,R2
    012B5 940E 3F19 CALL	empy32u|empy32s
    012B7 830D      STD	Y+5,R16
    012B8 831E      STD	Y+6,R17
    012B9 832F      STD	Y+7,R18
    012BA 8738      STD	Y+8,R19
(2093) 
(2094) 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    012BB A1ED      LDD	R30,Y+37
    012BC A1FE      LDD	R31,Y+38
    012BD ACA3      LDD	R10,Z+59
    012BE 2CEA      MOV	R14,R10
    012BF 82A2      STD	Z+2,R10
(2095) 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    012C0 20AA      TST	R10
    012C1 F029      BEQ	0x12C7
    012C2 2D8E      MOV	R24,R14
    012C3 5081      SUBI	R24,1
    012C4 2C2E      MOV	R2,R14
    012C5 2228      AND	R2,R24
    012C6 F011      BEQ	0x12C9
    012C7 E00D      LDI	R16,0xD
    012C8 C383      RJMP	0x164C
(2096) 
(2097) 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    012C9 A1ED      LDD	R30,Y+37
    012CA A1FE      LDD	R31,Y+38
    012CB AC27      LDD	R2,Z+63
    012CC 2433      CLR	R3
    012CD 5CE0      SUBI	R30,0xC0
    012CE 4FFF      SBCI	R31,0xFF
    012CF 8040      LD	R4,Z
    012D0 54E0      SUBI	R30,0x40
    012D1 40F0      SBCI	R31,0
    012D2 2455      CLR	R5
    012D3 2C54      MOV	R5,R4
    012D4 2444      CLR	R4
    012D5 2842      OR	R4,R2
    012D6 2853      OR	R5,R3
    012D7 8651      STD	Z+9,R5
    012D8 8640      STD	Z+8,R4
(2098) 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    012D9 8580      LDD	R24,Z+8
    012DA 8591      LDD	R25,Z+9
    012DB 708F      ANDI	R24,0xF
    012DC 7090      ANDI	R25,0
    012DD 3080      CPI	R24,0
    012DE 0789      CPC	R24,R25
    012DF F011      BEQ	0x12E2
    012E0 E00D      LDI	R16,0xD
    012E1 C36A      RJMP	0x164C
(2099) 
(2100) 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    012E2 A1ED      LDD	R30,Y+37
    012E3 A1FE      LDD	R31,Y+38
    012E4 5BEF      SUBI	R30,0xBF
    012E5 4FFF      SBCI	R31,0xFF
    012E6 8020      LD	R2,Z
    012E7 54E1      SUBI	R30,0x41
    012E8 40F0      SBCI	R31,0
    012E9 2433      CLR	R3
    012EA 5BEE      SUBI	R30,0xBE
    012EB 4FFF      SBCI	R31,0xFF
    012EC 8040      LD	R4,Z
    012ED 2455      CLR	R5
    012EE 2C54      MOV	R5,R4
    012EF 2444      CLR	R4
    012F0 2842      OR	R4,R2
    012F1 2853      OR	R5,R3
    012F2 0112      MOVW	R2,R4
    012F3 2444      CLR	R4
    012F4 2455      CLR	R5
    012F5 862D      STD	Y+13,R2
    012F6 863E      STD	Y+14,R3
    012F7 864F      STD	Y+15,R4
    012F8 8A58      STD	Y+16,R5
(2101) 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    012F9 842D      LDD	R2,Y+13
    012FA 843E      LDD	R3,Y+14
    012FB 844F      LDD	R4,Y+15
    012FC 8858      LDD	R5,Y+16
    012FD 9488      BCLR	0
    012FE 2022      TST	R2
    012FF 0432      CPC	R3,R2
    01300 0442      CPC	R4,R2
    01301 0452      CPC	R5,R2
    01302 F009      BEQ	0x1304
    01303 C03C      RJMP	0x1340
    01304 E188      LDI	R24,0x18
    01305 E090      LDI	R25,0
    01306 A1ED      LDD	R30,Y+37
    01307 A1FE      LDD	R31,Y+38
    01308 5AEF      SUBI	R30,0xAF
    01309 4FFF      SBCI	R31,0xFF
    0130A 8100      LD	R16,Z
    0130B 2711      CLR	R17
    0130C 2722      CLR	R18
    0130D 2733      CLR	R19
    0130E 938A      ST	-Y,R24
    0130F 940E 3FEF CALL	lsl32
    01311 0118      MOVW	R2,R16
    01312 0129      MOVW	R4,R18
    01313 A1ED      LDD	R30,Y+37
    01314 A1FE      LDD	R31,Y+38
    01315 5BE0      SUBI	R30,0xB0
    01316 4FFF      SBCI	R31,0xFF
    01317 8060      LD	R6,Z
    01318 55E0      SUBI	R30,0x50
    01319 40F0      SBCI	R31,0
    0131A 2477      CLR	R7
    0131B 2488      CLR	R8
    0131C 2499      CLR	R9
    0131D 0143      MOVW	R8,R6
    0131E 2466      CLR	R6
    0131F 2477      CLR	R7
    01320 2826      OR	R2,R6
    01321 2837      OR	R3,R7
    01322 2848      OR	R4,R8
    01323 2859      OR	R5,R9
    01324 5BE1      SUBI	R30,0xB1
    01325 4FFF      SBCI	R31,0xFF
    01326 8060      LD	R6,Z
    01327 54EF      SUBI	R30,0x4F
    01328 40F0      SBCI	R31,0
    01329 2477      CLR	R7
    0132A 2C76      MOV	R7,R6
    0132B 2466      CLR	R6
    0132C 2488      CLR	R8
    0132D 2499      CLR	R9
    0132E 2826      OR	R2,R6
    0132F 2837      OR	R3,R7
    01330 2848      OR	R4,R8
    01331 2859      OR	R5,R9
    01332 5BE2      SUBI	R30,0xB2
    01333 4FFF      SBCI	R31,0xFF
    01334 8060      LD	R6,Z
    01335 2477      CLR	R7
    01336 2488      CLR	R8
    01337 2499      CLR	R9
    01338 2826      OR	R2,R6
    01339 2837      OR	R3,R7
    0133A 2848      OR	R4,R8
    0133B 2859      OR	R5,R9
    0133C 862D      STD	Y+13,R2
    0133D 863E      STD	Y+14,R3
    0133E 864F      STD	Y+15,R4
    0133F 8A58      STD	Y+16,R5
(2102) 
(2103) 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    01340 A1ED      LDD	R30,Y+37
    01341 A1FE      LDD	R31,Y+38
    01342 AC24      LDD	R2,Z+60
    01343 2433      CLR	R3
    01344 ACE5      LDD	R14,Z+61
    01345 24FF      CLR	R15
    01346 2CFE      MOV	R15,R14
    01347 24EE      CLR	R14
    01348 28E2      OR	R14,R2
    01349 28F3      OR	R15,R3
(2104) 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    0134A 20EE      TST	R14
    0134B F421      BNE	0x1350
    0134C 20FF      TST	R15
    0134D F411      BNE	0x1350
    0134E E00D      LDI	R16,0xD
    0134F C2FC      RJMP	0x164C
(2105) 
(2106) 	/* Determine the FAT sub type */
(2107) 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    01350 802D      LDD	R2,Y+5
    01351 803E      LDD	R3,Y+6
    01352 804F      LDD	R4,Y+7
    01353 8458      LDD	R5,Y+8
    01354 0137      MOVW	R6,R14
    01355 2488      CLR	R8
    01356 2499      CLR	R9
    01357 0C62      ADD	R6,R2
    01358 1C73      ADC	R7,R3
    01359 1C84      ADC	R8,R4
    0135A 1C95      ADC	R9,R5
    0135B A1ED      LDD	R30,Y+37
    0135C A1FE      LDD	R31,Y+38
    0135D 9638      ADIW	R30,0x8
    0135E 8020      LD	R2,Z
    0135F 8031      LDD	R3,Z+1
    01360 9436      LSR	R3
    01361 9427      ROR	R2
    01362 9436      LSR	R3
    01363 9427      ROR	R2
    01364 9436      LSR	R3
    01365 9427      ROR	R2
    01366 9436      LSR	R3
    01367 9427      ROR	R2
    01368 2444      CLR	R4
    01369 2455      CLR	R5
    0136A 0C62      ADD	R6,R2
    0136B 1C73      ADC	R7,R3
    0136C 1C84      ADC	R8,R4
    0136D 1C95      ADC	R9,R5
    0136E 8A6D      STD	Y+21,R6
    0136F 8A7E      STD	Y+22,R7
    01370 8A8F      STD	Y+23,R8
    01371 8E98      STD	Y+24,R9
(2108) 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    01372 882D      LDD	R2,Y+21
    01373 883E      LDD	R3,Y+22
    01374 884F      LDD	R4,Y+23
    01375 8C58      LDD	R5,Y+24
    01376 846D      LDD	R6,Y+13
    01377 847E      LDD	R7,Y+14
    01378 848F      LDD	R8,Y+15
    01379 8898      LDD	R9,Y+16
    0137A 1462      CP	R6,R2
    0137B 0473      CPC	R7,R3
    0137C 0484      CPC	R8,R4
    0137D 0495      CPC	R9,R5
    0137E F410      BCC	0x1381
    0137F E00D      LDI	R16,0xD
    01380 C2CB      RJMP	0x164C
(2109) 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    01381 882D      LDD	R2,Y+21
    01382 883E      LDD	R3,Y+22
    01383 884F      LDD	R4,Y+23
    01384 8C58      LDD	R5,Y+24
    01385 850D      LDD	R16,Y+13
    01386 851E      LDD	R17,Y+14
    01387 852F      LDD	R18,Y+15
    01388 8938      LDD	R19,Y+16
    01389 1902      SUB	R16,R2
    0138A 0913      SBC	R17,R3
    0138B 0924      SBC	R18,R4
    0138C 0935      SBC	R19,R5
    0138D A1ED      LDD	R30,Y+37
    0138E A1FE      LDD	R31,Y+38
    0138F 9632      ADIW	R30,2
    01390 8020      LD	R2,Z
    01391 2433      CLR	R3
    01392 2444      CLR	R4
    01393 2455      CLR	R5
    01394 925A      ST	-Y,R5
    01395 924A      ST	-Y,R4
    01396 923A      ST	-Y,R3
    01397 922A      ST	-Y,R2
    01398 940E 3E73 CALL	div32u
    0139A 8709      STD	Y+9,R16
    0139B 871A      STD	Y+10,R17
    0139C 872B      STD	Y+11,R18
    0139D 873C      STD	Y+12,R19
(2110) 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    0139E 8429      LDD	R2,Y+9
    0139F 843A      LDD	R3,Y+10
    013A0 844B      LDD	R4,Y+11
    013A1 845C      LDD	R5,Y+12
    013A2 9488      BCLR	0
    013A3 2022      TST	R2
    013A4 0432      CPC	R3,R2
    013A5 0442      CPC	R4,R2
    013A6 0452      CPC	R5,R2
    013A7 F411      BNE	0x13AA
    013A8 E00D      LDI	R16,0xD
    013A9 C2A2      RJMP	0x164C
(2111) 	fmt = FS_FAT12;
    013AA 24CC      CLR	R12
    013AB 94C3      INC	R12
(2112) 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    013AC EF46      LDI	R20,0xF6
    013AD E05F      LDI	R21,0xF
    013AE E060      LDI	R22,0
    013AF E070      LDI	R23,0
    013B0 8429      LDD	R2,Y+9
    013B1 843A      LDD	R3,Y+10
    013B2 844B      LDD	R4,Y+11
    013B3 845C      LDD	R5,Y+12
    013B4 1624      CP	R2,R20
    013B5 0635      CPC	R3,R21
    013B6 0646      CPC	R4,R22
    013B7 0657      CPC	R5,R23
    013B8 F010      BCS	0x13BB
    013B9 E082      LDI	R24,2
    013BA 2EC8      MOV	R12,R24
(2113) 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    013BB EF46      LDI	R20,0xF6
    013BC EF5F      LDI	R21,0xFF
    013BD E060      LDI	R22,0
    013BE E070      LDI	R23,0
    013BF 8429      LDD	R2,Y+9
    013C0 843A      LDD	R3,Y+10
    013C1 844B      LDD	R4,Y+11
    013C2 845C      LDD	R5,Y+12
    013C3 1624      CP	R2,R20
    013C4 0635      CPC	R3,R21
    013C5 0646      CPC	R4,R22
    013C6 0657      CPC	R5,R23
    013C7 F010      BCS	0x13CA
    013C8 E083      LDI	R24,3
    013C9 2EC8      MOV	R12,R24
(2114) 
(2115) 	/* Boundaries and Limits */
(2116) 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    013CA E042      LDI	R20,2
    013CB E050      LDI	R21,0
    013CC E060      LDI	R22,0
    013CD E070      LDI	R23,0
    013CE 8429      LDD	R2,Y+9
    013CF 843A      LDD	R3,Y+10
    013D0 844B      LDD	R4,Y+11
    013D1 845C      LDD	R5,Y+12
    013D2 0E24      ADD	R2,R20
    013D3 1E35      ADC	R3,R21
    013D4 1E46      ADC	R4,R22
    013D5 1E57      ADC	R5,R23
    013D6 A1ED      LDD	R30,Y+37
    013D7 A1FE      LDD	R31,Y+38
    013D8 9676      ADIW	R30,0x16
    013D9 8220      ST	Z,R2
    013DA 8231      STD	Z+1,R3
    013DB 8242      STD	Z+2,R4
    013DC 8253      STD	Z+3,R5
(2117) 	fs->database = bsect + sysect;						/* Data start sector */
    013DD 882D      LDD	R2,Y+21
    013DE 883E      LDD	R3,Y+22
    013DF 884F      LDD	R4,Y+23
    013E0 8C58      LDD	R5,Y+24
    013E1 8869      LDD	R6,Y+17
    013E2 887A      LDD	R7,Y+18
    013E3 888B      LDD	R8,Y+19
    013E4 889C      LDD	R9,Y+20
    013E5 0C62      ADD	R6,R2
    013E6 1C73      ADC	R7,R3
    013E7 1C84      ADC	R8,R4
    013E8 1C95      ADC	R9,R5
    013E9 A1ED      LDD	R30,Y+37
    013EA A1FE      LDD	R31,Y+38
    013EB 96B6      ADIW	R30,0x26
    013EC 8260      ST	Z,R6
    013ED 8271      STD	Z+1,R7
    013EE 8282      STD	Z+2,R8
    013EF 8293      STD	Z+3,R9
(2118) 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    013F0 0117      MOVW	R2,R14
    013F1 2444      CLR	R4
    013F2 2455      CLR	R5
    013F3 8869      LDD	R6,Y+17
    013F4 887A      LDD	R7,Y+18
    013F5 888B      LDD	R8,Y+19
    013F6 889C      LDD	R9,Y+20
    013F7 0C62      ADD	R6,R2
    013F8 1C73      ADC	R7,R3
    013F9 1C84      ADC	R8,R4
    013FA 1C95      ADC	R9,R5
    013FB A1ED      LDD	R30,Y+37
    013FC A1FE      LDD	R31,Y+38
    013FD 8E66      STD	Z+30,R6
    013FE 8E77      STD	Z+31,R7
    013FF A280      STD	Z+32,R8
    01400 A291      STD	Z+33,R9
(2119) 	if (fmt == FS_FAT32) {
    01401 2D8C      MOV	R24,R12
    01402 3083      CPI	R24,3
    01403 F009      BEQ	0x1405
    01404 C055      RJMP	0x145A
(2120) 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    01405 8420      LDD	R2,Z+8
    01406 8431      LDD	R3,Z+9
    01407 2022      TST	R2
    01408 F411      BNE	0x140B
    01409 2033      TST	R3
    0140A F011      BEQ	0x140D
    0140B E00D      LDI	R16,0xD
    0140C C23F      RJMP	0x164C
(2121) 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    0140D E188      LDI	R24,0x18
    0140E E090      LDI	R25,0
    0140F A1ED      LDD	R30,Y+37
    01410 A1FE      LDD	R31,Y+38
    01411 5AE3      SUBI	R30,0xA3
    01412 4FFF      SBCI	R31,0xFF
    01413 8100      LD	R16,Z
    01414 2711      CLR	R17
    01415 2722      CLR	R18
    01416 2733      CLR	R19
    01417 938A      ST	-Y,R24
    01418 940E 3FEF CALL	lsl32
    0141A 0118      MOVW	R2,R16
    0141B 0129      MOVW	R4,R18
    0141C A1ED      LDD	R30,Y+37
    0141D A1FE      LDD	R31,Y+38
    0141E 5AE4      SUBI	R30,0xA4
    0141F 4FFF      SBCI	R31,0xFF
    01420 8060      LD	R6,Z
    01421 55EC      SUBI	R30,0x5C
    01422 40F0      SBCI	R31,0
    01423 2477      CLR	R7
    01424 2488      CLR	R8
    01425 2499      CLR	R9
    01426 0143      MOVW	R8,R6
    01427 2466      CLR	R6
    01428 2477      CLR	R7
    01429 2826      OR	R2,R6
    0142A 2837      OR	R3,R7
    0142B 2848      OR	R4,R8
    0142C 2859      OR	R5,R9
    0142D 5AE5      SUBI	R30,0xA5
    0142E 4FFF      SBCI	R31,0xFF
    0142F 8060      LD	R6,Z
    01430 55EB      SUBI	R30,0x5B
    01431 40F0      SBCI	R31,0
    01432 2477      CLR	R7
    01433 2C76      MOV	R7,R6
    01434 2466      CLR	R6
    01435 2488      CLR	R8
    01436 2499      CLR	R9
    01437 2826      OR	R2,R6
    01438 2837      OR	R3,R7
    01439 2848      OR	R4,R8
    0143A 2859      OR	R5,R9
    0143B 5AE6      SUBI	R30,0xA6
    0143C 4FFF      SBCI	R31,0xFF
    0143D 8060      LD	R6,Z
    0143E 55EA      SUBI	R30,0x5A
    0143F 40F0      SBCI	R31,0
    01440 2477      CLR	R7
    01441 2488      CLR	R8
    01442 2499      CLR	R9
    01443 2826      OR	R2,R6
    01444 2837      OR	R3,R7
    01445 2848      OR	R4,R8
    01446 2859      OR	R5,R9
    01447 A222      STD	Z+34,R2
    01448 A233      STD	Z+35,R3
    01449 A244      STD	Z+36,R4
    0144A A255      STD	Z+37,R5
(2122) 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    0144B E082      LDI	R24,2
    0144C E090      LDI	R25,0
    0144D 9676      ADIW	R30,0x16
    0144E 8100      LD	R16,Z
    0144F 8111      LDD	R17,Z+1
    01450 8122      LDD	R18,Z+2
    01451 8133      LDD	R19,Z+3
    01452 938A      ST	-Y,R24
    01453 940E 3FEF CALL	lsl32
    01455 8F09      STD	Y+25,R16
    01456 8F1A      STD	Y+26,R17
    01457 8F2B      STD	Y+27,R18
    01458 8F3C      STD	Y+28,R19
(2123) 	} else {
    01459 C06A      RJMP	0x14C4
(2124) 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    0145A A1ED      LDD	R30,Y+37
    0145B A1FE      LDD	R31,Y+38
    0145C 8420      LDD	R2,Z+8
    0145D 8431      LDD	R3,Z+9
    0145E 2022      TST	R2
    0145F F421      BNE	0x1464
    01460 2033      TST	R3
    01461 F411      BNE	0x1464
    01462 E00D      LDI	R16,0xD
    01463 C1E8      RJMP	0x164C
(2125) 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    01464 802D      LDD	R2,Y+5
    01465 803E      LDD	R3,Y+6
    01466 804F      LDD	R4,Y+7
    01467 8458      LDD	R5,Y+8
    01468 A1ED      LDD	R30,Y+37
    01469 A1FE      LDD	R31,Y+38
    0146A 8C66      LDD	R6,Z+30
    0146B 8C77      LDD	R7,Z+31
    0146C A080      LDD	R8,Z+32
    0146D A091      LDD	R9,Z+33
    0146E 0C62      ADD	R6,R2
    0146F 1C73      ADC	R7,R3
    01470 1C84      ADC	R8,R4
    01471 1C95      ADC	R9,R5
    01472 A262      STD	Z+34,R6
    01473 A273      STD	Z+35,R7
    01474 A284      STD	Z+36,R8
    01475 A295      STD	Z+37,R9
(2126) 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    01476 2D8C      MOV	R24,R12
    01477 3082      CPI	R24,2
    01478 F471      BNE	0x1487
    01479 9676      ADIW	R30,0x16
    0147A 8020      LD	R2,Z
    0147B 8031      LDD	R3,Z+1
    0147C 8042      LDD	R4,Z+2
    0147D 8053      LDD	R5,Z+3
    0147E 0C22      LSL	R2
    0147F 1C33      ROL	R3
    01480 1C44      ROL	R4
    01481 1C55      ROL	R5
    01482 8E2D      STD	Y+29,R2
    01483 8E3E      STD	Y+30,R3
    01484 8E4F      STD	Y+31,R4
    01485 A258      STD	Y+32,R5
    01486 C035      RJMP	0x14BC
    01487 A1ED      LDD	R30,Y+37
    01488 A1FE      LDD	R31,Y+38
    01489 9676      ADIW	R30,0x16
    0148A 8020      LD	R2,Z
    0148B 8031      LDD	R3,Z+1
    0148C 8042      LDD	R4,Z+2
    0148D 8053      LDD	R5,Z+3
    0148E A229      STD	Y+33,R2
    0148F A23A      STD	Y+34,R3
    01490 A24B      STD	Y+35,R4
    01491 A25C      STD	Y+36,R5
    01492 E041      LDI	R20,1
    01493 E050      LDI	R21,0
    01494 E060      LDI	R22,0
    01495 E070      LDI	R23,0
    01496 A029      LDD	R2,Y+33
    01497 A03A      LDD	R3,Y+34
    01498 A04B      LDD	R4,Y+35
    01499 A05C      LDD	R5,Y+36
    0149A 2224      AND	R2,R20
    0149B 2235      AND	R3,R21
    0149C 2246      AND	R4,R22
    0149D 2257      AND	R5,R23
    0149E A069      LDD	R6,Y+33
    0149F A07A      LDD	R7,Y+34
    014A0 A08B      LDD	R8,Y+35
    014A1 A09C      LDD	R9,Y+36
    014A2 E043      LDI	R20,3
    014A3 E050      LDI	R21,0
    014A4 E060      LDI	R22,0
    014A5 E070      LDI	R23,0
    014A6 929A      ST	-Y,R9
    014A7 928A      ST	-Y,R8
    014A8 927A      ST	-Y,R7
    014A9 926A      ST	-Y,R6
    014AA 018A      MOVW	R16,R20
    014AB 019B      MOVW	R18,R22
    014AC 940E 3F19 CALL	empy32u|empy32s
    014AE 0138      MOVW	R6,R16
    014AF 0149      MOVW	R8,R18
    014B0 9496      LSR	R9
    014B1 9487      ROR	R8
    014B2 9477      ROR	R7
    014B3 9467      ROR	R6
    014B4 0C62      ADD	R6,R2
    014B5 1C73      ADC	R7,R3
    014B6 1C84      ADC	R8,R4
    014B7 1C95      ADC	R9,R5
    014B8 8E6D      STD	Y+29,R6
    014B9 8E7E      STD	Y+30,R7
    014BA 8E8F      STD	Y+31,R8
    014BB A298      STD	Y+32,R9
    014BC 8C2D      LDD	R2,Y+29
    014BD 8C3E      LDD	R3,Y+30
    014BE 8C4F      LDD	R4,Y+31
    014BF A058      LDD	R5,Y+32
    014C0 8E29      STD	Y+25,R2
    014C1 8E3A      STD	Y+26,R3
    014C2 8E4B      STD	Y+27,R4
    014C3 8E5C      STD	Y+28,R5
(2127) 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
(2128) 	}
(2129) 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    014C4 EF4F      LDI	R20,0xFF
    014C5 E051      LDI	R21,1
    014C6 E060      LDI	R22,0
    014C7 E070      LDI	R23,0
    014C8 8D09      LDD	R16,Y+25
    014C9 8D1A      LDD	R17,Y+26
    014CA 8D2B      LDD	R18,Y+27
    014CB 8D3C      LDD	R19,Y+28
    014CC 0F04      ADD	R16,R20
    014CD 1F15      ADC	R17,R21
    014CE 1F26      ADC	R18,R22
    014CF 1F37      ADC	R19,R23
    014D0 E089      LDI	R24,0x9
    014D1 E090      LDI	R25,0
    014D2 938A      ST	-Y,R24
    014D3 940E 4008 CALL	lsr32
    014D5 A1ED      LDD	R30,Y+37
    014D6 A1FE      LDD	R31,Y+38
    014D7 8C22      LDD	R2,Z+26
    014D8 8C33      LDD	R3,Z+27
    014D9 8C44      LDD	R4,Z+28
    014DA 8C55      LDD	R5,Z+29
    014DB 1620      CP	R2,R16
    014DC 0631      CPC	R3,R17
    014DD 0642      CPC	R4,R18
    014DE 0653      CPC	R5,R19
    014DF F410      BCC	0x14E2
(2130) 		return FR_NO_FILESYSTEM;
    014E0 E00D      LDI	R16,0xD
    014E1 C16A      RJMP	0x164C
(2131) 
(2132) #if !_FS_READONLY
(2133) 	/* Initialize cluster allocation information */
(2134) 	fs->free_clust = 0xFFFFFFFF;
    014E2 A1ED      LDD	R30,Y+37
    014E3 A1FE      LDD	R31,Y+38
    014E4 963E      ADIW	R30,0xE
    014E5 EF8F      LDI	R24,0xFF
    014E6 8380      ST	Z,R24
    014E7 8381      STD	Z+1,R24
    014E8 8382      STD	Z+2,R24
    014E9 8383      STD	Z+3,R24
(2135) 	fs->last_clust = 0;
    014EA A1ED      LDD	R30,Y+37
    014EB A1FE      LDD	R31,Y+38
    014EC 963A      ADIW	R30,0xA
    014ED E080      LDI	R24,0
    014EE 8380      ST	Z,R24
    014EF 8381      STD	Z+1,R24
    014F0 8382      STD	Z+2,R24
    014F1 8383      STD	Z+3,R24
(2136) 
(2137) 	/* Get fsinfo if available */
(2138) 	if (fmt == FS_FAT32) {
    014F2 2D8C      MOV	R24,R12
    014F3 3083      CPI	R24,3
    014F4 F009      BEQ	0x14F6
    014F5 C13C      RJMP	0x1632
(2139) 	 	fs->fsi_flag = 0;
    014F6 2422      CLR	R2
    014F7 A1ED      LDD	R30,Y+37
    014F8 A1FE      LDD	R31,Y+38
    014F9 8225      STD	Z+5,R2
(2140) 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    014FA 5AE2      SUBI	R30,0xA2
    014FB 4FFF      SBCI	R31,0xFF
    014FC 8020      LD	R2,Z
    014FD 55EE      SUBI	R30,0x5E
    014FE 40F0      SBCI	R31,0
    014FF 2433      CLR	R3
    01500 5AE1      SUBI	R30,0xA1
    01501 4FFF      SBCI	R31,0xFF
    01502 8040      LD	R4,Z
    01503 2455      CLR	R5
    01504 2C54      MOV	R5,R4
    01505 2444      CLR	R4
    01506 2842      OR	R4,R2
    01507 2853      OR	R5,R3
    01508 0112      MOVW	R2,R4
    01509 2444      CLR	R4
    0150A 2455      CLR	R5
    0150B 8869      LDD	R6,Y+17
    0150C 887A      LDD	R7,Y+18
    0150D 888B      LDD	R8,Y+19
    0150E 889C      LDD	R9,Y+20
    0150F 0C62      ADD	R6,R2
    01510 1C73      ADC	R7,R3
    01511 1C84      ADC	R8,R4
    01512 1C95      ADC	R9,R5
    01513 A1ED      LDD	R30,Y+37
    01514 A1FE      LDD	R31,Y+38
    01515 8A62      STD	Z+18,R6
    01516 8A73      STD	Z+19,R7
    01517 8A84      STD	Z+20,R8
    01518 8A95      STD	Z+21,R9
(2141) 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    01519 E081      LDI	R24,1
    0151A 838C      STD	Y+4,R24
    0151B 8822      LDD	R2,Z+18
    0151C 8833      LDD	R3,Z+19
    0151D 8844      LDD	R4,Z+20
    0151E 8855      LDD	R5,Z+21
    0151F 8228      ST	Y,R2
    01520 8239      STD	Y+1,R3
    01521 824A      STD	Y+2,R4
    01522 825B      STD	Y+3,R5
    01523 019F      MOVW	R18,R30
    01524 5D22      SUBI	R18,0xD2
    01525 4F3F      SBCI	R19,0xFF
    01526 8101      LDD	R16,Z+1
    01527 940E 029E CALL	_disk_read
    01529 2EE0      MOV	R14,R16
    0152A 2300      TST	R16
    0152B F009      BEQ	0x152D
    0152C C105      RJMP	0x1632
    0152D A1ED      LDD	R30,Y+37
    0152E A1FE      LDD	R31,Y+38
    0152F 5DE4      SUBI	R30,0xD4
    01530 4FFD      SBCI	R31,0xFD
    01531 8020      LD	R2,Z
    01532 52EC      SUBI	R30,0x2C
    01533 40F2      SBCI	R31,2
    01534 2433      CLR	R3
    01535 5DE3      SUBI	R30,0xD3
    01536 4FFD      SBCI	R31,0xFD
    01537 8180      LD	R24,Z
    01538 52ED      SUBI	R30,0x2D
    01539 40F2      SBCI	R31,2
    0153A 2799      CLR	R25
    0153B 2F98      MOV	R25,R24
    0153C 2788      CLR	R24
    0153D 2982      OR	R24,R2
    0153E 2993      OR	R25,R3
    0153F 3585      CPI	R24,0x55
    01540 EAAA      LDI	R26,0xAA
    01541 079A      CPC	R25,R26
    01542 F009      BEQ	0x1544
    01543 C0EE      RJMP	0x1632
    01544 E188      LDI	R24,0x18
    01545 E090      LDI	R25,0
    01546 A901      LDD	R16,Z+49
    01547 2711      CLR	R17
    01548 2722      CLR	R18
    01549 2733      CLR	R19
    0154A 938A      ST	-Y,R24
    0154B 940E 3FEF CALL	lsl32
    0154D 0118      MOVW	R2,R16
    0154E 0129      MOVW	R4,R18
    0154F A1ED      LDD	R30,Y+37
    01550 A1FE      LDD	R31,Y+38
    01551 A860      LDD	R6,Z+48
    01552 2477      CLR	R7
    01553 2488      CLR	R8
    01554 2499      CLR	R9
    01555 0143      MOVW	R8,R6
    01556 2466      CLR	R6
    01557 2477      CLR	R7
    01558 2826      OR	R2,R6
    01559 2837      OR	R3,R7
    0155A 2848      OR	R4,R8
    0155B 2859      OR	R5,R9
    0155C A467      LDD	R6,Z+47
    0155D 2477      CLR	R7
    0155E 2C76      MOV	R7,R6
    0155F 2466      CLR	R6
    01560 2488      CLR	R8
    01561 2499      CLR	R9
    01562 2826      OR	R2,R6
    01563 2837      OR	R3,R7
    01564 2848      OR	R4,R8
    01565 2859      OR	R5,R9
    01566 A466      LDD	R6,Z+46
    01567 2477      CLR	R7
    01568 2488      CLR	R8
    01569 2499      CLR	R9
    0156A 2826      OR	R2,R6
    0156B 2837      OR	R3,R7
    0156C 2848      OR	R4,R8
    0156D 2859      OR	R5,R9
    0156E E542      LDI	R20,0x52
    0156F E552      LDI	R21,0x52
    01570 E661      LDI	R22,0x61
    01571 E471      LDI	R23,0x41
    01572 1624      CP	R2,R20
    01573 0635      CPC	R3,R21
    01574 0646      CPC	R4,R22
    01575 0657      CPC	R5,R23
    01576 F009      BEQ	0x1578
    01577 C0BA      RJMP	0x1632
    01578 E188      LDI	R24,0x18
    01579 E090      LDI	R25,0
    0157A 5EEB      SUBI	R30,0xEB
    0157B 4FFD      SBCI	R31,0xFD
    0157C 8100      LD	R16,Z
    0157D 2711      CLR	R17
    0157E 2722      CLR	R18
    0157F 2733      CLR	R19
    01580 938A      ST	-Y,R24
    01581 940E 3FEF CALL	lsl32
    01583 0118      MOVW	R2,R16
    01584 0129      MOVW	R4,R18
    01585 A1ED      LDD	R30,Y+37
    01586 A1FE      LDD	R31,Y+38
    01587 5EEC      SUBI	R30,0xEC
    01588 4FFD      SBCI	R31,0xFD
    01589 8060      LD	R6,Z
    0158A 51E4      SUBI	R30,0x14
    0158B 40F2      SBCI	R31,2
    0158C 2477      CLR	R7
    0158D 2488      CLR	R8
    0158E 2499      CLR	R9
    0158F 0143      MOVW	R8,R6
    01590 2466      CLR	R6
    01591 2477      CLR	R7
    01592 2826      OR	R2,R6
    01593 2837      OR	R3,R7
    01594 2848      OR	R4,R8
    01595 2859      OR	R5,R9
    01596 5EED      SUBI	R30,0xED
    01597 4FFD      SBCI	R31,0xFD
    01598 8060      LD	R6,Z
    01599 51E3      SUBI	R30,0x13
    0159A 40F2      SBCI	R31,2
    0159B 2477      CLR	R7
    0159C 2C76      MOV	R7,R6
    0159D 2466      CLR	R6
    0159E 2488      CLR	R8
    0159F 2499      CLR	R9
    015A0 2826      OR	R2,R6
    015A1 2837      OR	R3,R7
    015A2 2848      OR	R4,R8
    015A3 2859      OR	R5,R9
    015A4 5EEE      SUBI	R30,0xEE
    015A5 4FFD      SBCI	R31,0xFD
    015A6 8060      LD	R6,Z
    015A7 51E2      SUBI	R30,0x12
    015A8 40F2      SBCI	R31,2
    015A9 2477      CLR	R7
    015AA 2488      CLR	R8
    015AB 2499      CLR	R9
    015AC 2826      OR	R2,R6
    015AD 2837      OR	R3,R7
    015AE 2848      OR	R4,R8
    015AF 2859      OR	R5,R9
    015B0 E742      LDI	R20,0x72
    015B1 E752      LDI	R21,0x72
    015B2 E461      LDI	R22,0x41
    015B3 E671      LDI	R23,0x61
    015B4 1624      CP	R2,R20
    015B5 0635      CPC	R3,R21
    015B6 0646      CPC	R4,R22
    015B7 0657      CPC	R5,R23
    015B8 F009      BEQ	0x15BA
    015B9 C078      RJMP	0x1632
(2142) 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
(2143) 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
(2144) 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
(2145) 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    015BA E188      LDI	R24,0x18
    015BB E090      LDI	R25,0
    015BC 5EE3      SUBI	R30,0xE3
    015BD 4FFD      SBCI	R31,0xFD
    015BE 8100      LD	R16,Z
    015BF 2711      CLR	R17
    015C0 2722      CLR	R18
    015C1 2733      CLR	R19
    015C2 938A      ST	-Y,R24
    015C3 940E 3FEF CALL	lsl32
    015C5 0118      MOVW	R2,R16
    015C6 0129      MOVW	R4,R18
    015C7 A1ED      LDD	R30,Y+37
    015C8 A1FE      LDD	R31,Y+38
    015C9 5EE4      SUBI	R30,0xE4
    015CA 4FFD      SBCI	R31,0xFD
    015CB 8060      LD	R6,Z
    015CC 51EC      SUBI	R30,0x1C
    015CD 40F2      SBCI	R31,2
    015CE 2477      CLR	R7
    015CF 2488      CLR	R8
    015D0 2499      CLR	R9
    015D1 0143      MOVW	R8,R6
    015D2 2466      CLR	R6
    015D3 2477      CLR	R7
    015D4 2826      OR	R2,R6
    015D5 2837      OR	R3,R7
    015D6 2848      OR	R4,R8
    015D7 2859      OR	R5,R9
    015D8 5EE5      SUBI	R30,0xE5
    015D9 4FFD      SBCI	R31,0xFD
    015DA 8060      LD	R6,Z
    015DB 51EB      SUBI	R30,0x1B
    015DC 40F2      SBCI	R31,2
    015DD 2477      CLR	R7
    015DE 2C76      MOV	R7,R6
    015DF 2466      CLR	R6
    015E0 2488      CLR	R8
    015E1 2499      CLR	R9
    015E2 2826      OR	R2,R6
    015E3 2837      OR	R3,R7
    015E4 2848      OR	R4,R8
    015E5 2859      OR	R5,R9
    015E6 5EE6      SUBI	R30,0xE6
    015E7 4FFD      SBCI	R31,0xFD
    015E8 8060      LD	R6,Z
    015E9 51EA      SUBI	R30,0x1A
    015EA 40F2      SBCI	R31,2
    015EB 2477      CLR	R7
    015EC 2488      CLR	R8
    015ED 2499      CLR	R9
    015EE 2826      OR	R2,R6
    015EF 2837      OR	R3,R7
    015F0 2848      OR	R4,R8
    015F1 2859      OR	R5,R9
    015F2 8622      STD	Z+10,R2
    015F3 8633      STD	Z+11,R3
    015F4 8644      STD	Z+12,R4
    015F5 8655      STD	Z+13,R5
(2146) 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    015F6 E188      LDI	R24,0x18
    015F7 E090      LDI	R25,0
    015F8 5EE7      SUBI	R30,0xE7
    015F9 4FFD      SBCI	R31,0xFD
    015FA 8100      LD	R16,Z
    015FB 2711      CLR	R17
    015FC 2722      CLR	R18
    015FD 2733      CLR	R19
    015FE 938A      ST	-Y,R24
    015FF 940E 3FEF CALL	lsl32
    01601 0118      MOVW	R2,R16
    01602 0129      MOVW	R4,R18
    01603 A1ED      LDD	R30,Y+37
    01604 A1FE      LDD	R31,Y+38
    01605 5EE8      SUBI	R30,0xE8
    01606 4FFD      SBCI	R31,0xFD
    01607 8060      LD	R6,Z
    01608 51E8      SUBI	R30,0x18
    01609 40F2      SBCI	R31,2
    0160A 2477      CLR	R7
    0160B 2488      CLR	R8
    0160C 2499      CLR	R9
    0160D 0143      MOVW	R8,R6
    0160E 2466      CLR	R6
    0160F 2477      CLR	R7
    01610 2826      OR	R2,R6
    01611 2837      OR	R3,R7
    01612 2848      OR	R4,R8
    01613 2859      OR	R5,R9
    01614 5EE9      SUBI	R30,0xE9
    01615 4FFD      SBCI	R31,0xFD
    01616 8060      LD	R6,Z
    01617 51E7      SUBI	R30,0x17
    01618 40F2      SBCI	R31,2
    01619 2477      CLR	R7
    0161A 2C76      MOV	R7,R6
    0161B 2466      CLR	R6
    0161C 2488      CLR	R8
    0161D 2499      CLR	R9
    0161E 2826      OR	R2,R6
    0161F 2837      OR	R3,R7
    01620 2848      OR	R4,R8
    01621 2859      OR	R5,R9
    01622 5EEA      SUBI	R30,0xEA
    01623 4FFD      SBCI	R31,0xFD
    01624 8060      LD	R6,Z
    01625 51E6      SUBI	R30,0x16
    01626 40F2      SBCI	R31,2
    01627 2477      CLR	R7
    01628 2488      CLR	R8
    01629 2499      CLR	R9
    0162A 2826      OR	R2,R6
    0162B 2837      OR	R3,R7
    0162C 2848      OR	R4,R8
    0162D 2859      OR	R5,R9
    0162E 8626      STD	Z+14,R2
    0162F 8637      STD	Z+15,R3
    01630 8A40      STD	Z+16,R4
    01631 8A51      STD	Z+17,R5
(2147) 		}
(2148) 	}
(2149) #endif
(2150) 	fs->fs_type = fmt;		/* FAT sub-type */
    01632 A1ED      LDD	R30,Y+37
    01633 A1FE      LDD	R31,Y+38
    01634 82C0      ST	Z,R12
(2151) 	fs->id = ++Fsid;		/* File system mount ID */
    01635 9180 04EE LDS	R24,ff.c:Fsid
    01637 9190 04EF LDS	R25,ff.c:Fsid+1
    01639 9601      ADIW	R24,1
    0163A 016C      MOVW	R12,R24
    0163B 92D0 04EF STS	ff.c:Fsid+1,R13
    0163D 92C0 04EE STS	ff.c:Fsid,R12
    0163F 82D7      STD	Z+7,R13
    01640 82C6      STD	Z+6,R12
(2152) 	fs->winsect = 0;		/* Invalidate sector cache */
    01641 96BA      ADIW	R30,0x2A
    01642 E080      LDI	R24,0
    01643 8380      ST	Z,R24
    01644 8381      STD	Z+1,R24
    01645 8382      STD	Z+2,R24
    01646 8383      STD	Z+3,R24
(2153) 	fs->wflag = 0;
    01647 2422      CLR	R2
    01648 A1ED      LDD	R30,Y+37
    01649 A1FE      LDD	R31,Y+38
    0164A 8224      STD	Z+4,R2
(2154) #if _FS_RPATH
(2155) 	fs->cdir = 0;			/* Current directory (root dir) */
(2156) #endif
(2157) #if _FS_SHARE				/* Clear file lock semaphores */
(2158) 	clear_lock(fs);
(2159) #endif
(2160) 
(2161) 	return FR_OK;
    0164B 2700      CLR	R16
    0164C 96A7      ADIW	R28,0x27
    0164D 940E 3F62 CALL	pop_xgsetF0FC
    0164F 9622      ADIW	R28,2
    01650 9508      RET
ff.c:validate:
  id                   --> R10
  fs                   --> R20
    01651 940E 3F78 CALL	push_xgset300C
    01653 0159      MOVW	R10,R18
    01654 01A8      MOVW	R20,R16
(2162) }
(2163) 
(2164) 
(2165) 
(2166) 
(2167) /*-----------------------------------------------------------------------*/
(2168) /* Check if the file/dir object is valid or not                          */
(2169) /*-----------------------------------------------------------------------*/
(2170) 
(2171) static
(2172) FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
(2173) 	FATFS *fs,		/* Pointer to the file system object */
(2174) 	WORD id			/* Member id of the target object to be checked */
(2175) )
(2176) {
(2177) 	if (!fs || !fs->fs_type || fs->id != id)
    01655 3040      CPI	R20,0
    01656 0745      CPC	R20,R21
    01657 F049      BEQ	0x1661
    01658 01FA      MOVW	R30,R20
    01659 8020      LD	R2,Z
    0165A 2022      TST	R2
    0165B F029      BEQ	0x1661
    0165C 8026      LDD	R2,Z+6
    0165D 8037      LDD	R3,Z+7
    0165E 142A      CP	R2,R10
    0165F 043B      CPC	R3,R11
    01660 F011      BEQ	0x1663
(2178) 		return FR_INVALID_OBJECT;
    01661 E009      LDI	R16,0x9
    01662 C009      RJMP	0x166C
(2179) 
(2180) 	ENTER_FF(fs);		/* Lock file system */
(2181) 
(2182) 	if (disk_status(fs->drv) & STA_NOINIT)
    01663 01FA      MOVW	R30,R20
    01664 8101      LDD	R16,Z+1
    01665 940E 0298 CALL	_disk_status
    01667 FF00      SBRS	R16,0
    01668 C002      RJMP	0x166B
(2183) 		return FR_NOT_READY;
    01669 E003      LDI	R16,3
    0166A C001      RJMP	0x166C
(2184) 
(2185) 	return FR_OK;
    0166B 2700      CLR	R16
    0166C 940C 3F7D JMP	pop_xgset300C
_f_mount:
  rfs                  --> R10
  fs                   --> R18
  vol                  --> R16
    0166E 92AA      ST	-Y,R10
    0166F 92BA      ST	-Y,R11
(2186) }
(2187) 
(2188) 
(2189) 
(2190) 
(2191) /*--------------------------------------------------------------------------
(2192) 
(2193)    Public Functions
(2194) 
(2195) --------------------------------------------------------------------------*/
(2196) 
(2197) 
(2198) 
(2199) /*-----------------------------------------------------------------------*/
(2200) /* Mount/Unmount a Logical Drive                                         */
(2201) /*-----------------------------------------------------------------------*/
(2202) 
(2203) FRESULT f_mount (
(2204) 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
(2205) 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
(2206) )
(2207) {
(2208) 	FATFS *rfs;
(2209) 
(2210) 
(2211) 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    01670 3001      CPI	R16,1
    01671 F010      BCS	0x1674
(2212) 		return FR_INVALID_DRIVE;
    01672 E00B      LDI	R16,0xB
    01673 C022      RJMP	0x1696
(2213) 	rfs = FatFs[vol];			/* Get current fs object */
    01674 EF80      LDI	R24,0xF0
    01675 E094      LDI	R25,4
    01676 2FE0      MOV	R30,R16
    01677 27FF      CLR	R31
    01678 0FEE      LSL	R30
    01679 1FFF      ROL	R31
    0167A 0FE8      ADD	R30,R24
    0167B 1FF9      ADC	R31,R25
    0167C 80A0      LD	R10,Z
    0167D 80B1      LDD	R11,Z+1
(2214) 
(2215) 	if (rfs) {
    0167E 20AA      TST	R10
    0167F F411      BNE	0x1682
    01680 20BB      TST	R11
    01681 F019      BEQ	0x1685
(2216) #if _FS_SHARE
(2217) 		clear_lock(rfs);
(2218) #endif
(2219) #if _FS_REENTRANT				/* Discard sync object of the current volume */
(2220) 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
(2221) #endif
(2222) 		rfs->fs_type = 0;		/* Clear old fs object */
    01682 2422      CLR	R2
    01683 01F5      MOVW	R30,R10
    01684 8220      ST	Z,R2
(2223) 	}
(2224) 
(2225) 	if (fs) {
    01685 3020      CPI	R18,0
    01686 0723      CPC	R18,R19
    01687 F019      BEQ	0x168B
(2226) 		fs->fs_type = 0;		/* Clear new fs object */
    01688 2422      CLR	R2
    01689 01F9      MOVW	R30,R18
    0168A 8220      ST	Z,R2
(2227) #if _FS_REENTRANT				/* Create sync object for the new volume */
(2228) 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
(2229) #endif
(2230) 	}
(2231) 	FatFs[vol] = fs;			/* Register new fs object */
    0168B EF80      LDI	R24,0xF0
    0168C E094      LDI	R25,4
    0168D 2FE0      MOV	R30,R16
    0168E 27FF      CLR	R31
    0168F 0FEE      LSL	R30
    01690 1FFF      ROL	R31
    01691 0FE8      ADD	R30,R24
    01692 1FF9      ADC	R31,R25
    01693 8331      STD	Z+1,R19
    01694 8320      ST	Z,R18
(2232) 
(2233) 	return FR_OK;
    01695 2700      CLR	R16
    01696 90B9      LD	R11,Y+
    01697 90A9      LD	R10,Y+
    01698 9508      RET
_f_open:
  cl                   --> Y,+40
  dw                   --> Y,+36
  sfn                  --> Y,+24
  dj                   --> Y,+2
  res                  --> R10
  dir                  --> R14
  mode                 --> Y,+58
  path                 --> Y,+56
  fp                   --> Y,+54
    01699 940E 3E28 CALL	push_arg4
    0169B 940E 3F6D CALL	push_xgsetF0FC
    0169D 97AC      SBIW	R28,0x2C
(2234) }
(2235) 
(2236) 
(2237) 
(2238) 
(2239) /*-----------------------------------------------------------------------*/
(2240) /* Open or Create a File                                                 */
(2241) /*-----------------------------------------------------------------------*/
(2242) 
(2243) FRESULT f_open (
(2244) 	FIL *fp,			/* Pointer to the blank file object */
(2245) 	const TCHAR *path,	/* Pointer to the file name */
(2246) 	BYTE mode			/* Access mode and file open mode flags */
(2247) )
(2248) {
(2249) 	FRESULT res;
(2250) 	DIR dj;
(2251) 	BYTE *dir;
(2252) 	DEF_NAMEBUF;
(2253) 
(2254) 
(2255) 	fp->fs = 0;			/* Clear file object */
    0169E 2422      CLR	R2
    0169F 2433      CLR	R3
    016A0 A9EE      LDD	R30,Y+54
    016A1 A9FF      LDD	R31,Y+55
    016A2 8231      STD	Z+1,R3
    016A3 8220      ST	Z,R2
(2256) 
(2257) #if !_FS_READONLY
(2258) 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    016A4 AD8A      LDD	R24,Y+58
    016A5 718F      ANDI	R24,0x1F
    016A6 AF8A      STD	Y+58,R24
(2259) 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    016A7 2799      CLR	R25
    016A8 7F8E      ANDI	R24,0xFE
    016A9 8388      ST	Y,R24
    016AA 019E      MOVW	R18,R28
    016AB 5F2E      SUBI	R18,0xFE
    016AC 4F3F      SBCI	R19,0xFF
    016AD 018E      MOVW	R16,R28
    016AE 5C08      SUBI	R16,0xC8
    016AF 4F1F      SBCI	R17,0xFF
    016B0 DAA6      RCALL	ff.c:chk_mounted
    016B1 2EA0      MOV	R10,R16
(2260) #else
(2261) 	mode &= FA_READ;
(2262) 	res = chk_mounted(&path, &dj.fs, 0);
(2263) #endif
(2264) 	INIT_BUF(dj);
    016B2 01CE      MOVW	R24,R28
    016B3 9648      ADIW	R24,0x18
    016B4 8B9F      STD	Y+23,R25
    016B5 8B8E      STD	Y+22,R24
(2265) 	if (res == FR_OK)
    016B6 2300      TST	R16
    016B7 F439      BNE	0x16BF
(2266) 		res = follow_path(&dj, path);	/* Follow the file path */
    016B8 AD28      LDD	R18,Y+56
    016B9 AD39      LDD	R19,Y+57
    016BA 018E      MOVW	R16,R28
    016BB 5F0E      SUBI	R16,0xFE
    016BC 4F1F      SBCI	R17,0xFF
    016BD D94D      RCALL	ff.c:follow_path
    016BE 2EA0      MOV	R10,R16
(2267) 	dir = dj.dir;
    016BF 88EC      LDD	R14,Y+20
    016C0 88FD      LDD	R15,Y+21
(2268) 
(2269) #if !_FS_READONLY	/* R/W configuration */
(2270) 	if (res == FR_OK) {
    016C1 20AA      TST	R10
    016C2 F431      BNE	0x16C9
(2271) 		if (!dir)	/* Current dir itself */
    016C3 20EE      TST	R14
    016C4 F421      BNE	0x16C9
    016C5 20FF      TST	R15
    016C6 F411      BNE	0x16C9
(2272) 			res = FR_INVALID_NAME;
    016C7 E086      LDI	R24,6
    016C8 2EA8      MOV	R10,R24
(2273) #if _FS_SHARE
(2274) 		else
(2275) 			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2276) #endif
(2277) 	}
(2278) 	/* Create or Open a file */
(2279) 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    016C9 AD8A      LDD	R24,Y+58
    016CA 718C      ANDI	R24,0x1C
    016CB F409      BNE	0x16CD
    016CC C0C0      RJMP	0x178D
(2280) 		DWORD dw, cl;
(2281) 
(2282) 		if (res != FR_OK) {					/* No file, create new */
    016CD 20AA      TST	R10
    016CE F081      BEQ	0x16DF
(2283) 			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    016CF 2D8A      MOV	R24,R10
    016D0 3084      CPI	R24,4
    016D1 F439      BNE	0x16D9
(2284) #if _FS_SHARE
(2285) 				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
(2286) #else
(2287) 				res = dir_register(&dj);
    016D2 018E      MOVW	R16,R28
    016D3 5F0E      SUBI	R16,0xFE
    016D4 4F1F      SBCI	R17,0xFF
    016D5 940E 0DFD CALL	ff.c:dir_register
    016D7 2EC0      MOV	R12,R16
    016D8 2CAC      MOV	R10,R12
(2288) #endif
(2289) 			mode |= FA_CREATE_ALWAYS;		/* File is created */
    016D9 AD8A      LDD	R24,Y+58
    016DA 6088      ORI	R24,0x8
    016DB AF8A      STD	Y+58,R24
(2290) 			dir = dj.dir;					/* New entry */
    016DC 88EC      LDD	R14,Y+20
    016DD 88FD      LDD	R15,Y+21
(2291) 		}
    016DE C00C      RJMP	0x16EB
(2292) 		else {								/* Any object is already existing */
(2293) 			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    016DF 01F7      MOVW	R30,R14
    016E0 8583      LDD	R24,Z+11
    016E1 7181      ANDI	R24,0x11
    016E2 F019      BEQ	0x16E6
(2294) 				res = FR_DENIED;
    016E3 E087      LDI	R24,7
    016E4 2EA8      MOV	R10,R24
(2295) 			} else {
    016E5 C005      RJMP	0x16EB
(2296) 				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    016E6 AC0A      LDD	R0,Y+58
    016E7 FE02      SBRS	R0,2
    016E8 C002      RJMP	0x16EB
(2297) 					res = FR_EXIST;
    016E9 E088      LDI	R24,0x8
    016EA 2EA8      MOV	R10,R24
(2298) 			}
(2299) 		}
(2300) 		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    016EB 20AA      TST	R10
    016EC F009      BEQ	0x16EE
    016ED C0B1      RJMP	0x179F
    016EE AC0A      LDD	R0,Y+58
    016EF FE03      SBRS	R0,3
    016F0 C0AE      RJMP	0x179F
(2301) 			dw = get_fattime();					/* Created time */
    016F1 940E 02DB CALL	_get_fattime
    016F3 A30C      STD	Y+36,R16
    016F4 A31D      STD	Y+37,R17
    016F5 A32E      STD	Y+38,R18
    016F6 A33F      STD	Y+39,R19
(2302) 			ST_DWORD(dir+DIR_CrtTime, dw);
    016F7 A02C      LDD	R2,Y+36
    016F8 A03D      LDD	R3,Y+37
    016F9 A04E      LDD	R4,Y+38
    016FA A05F      LDD	R5,Y+39
    016FB 01F7      MOVW	R30,R14
    016FC 8626      STD	Z+14,R2
    016FD 2C23      MOV	R2,R3
    016FE 2433      CLR	R3
    016FF 963F      ADIW	R30,0xF
    01700 8220      ST	Z,R2
    01701 A02C      LDD	R2,Y+36
    01702 A03D      LDD	R3,Y+37
    01703 A04E      LDD	R4,Y+38
    01704 A05F      LDD	R5,Y+39
    01705 0112      MOVW	R2,R4
    01706 2444      CLR	R4
    01707 2455      CLR	R5
    01708 01F7      MOVW	R30,R14
    01709 9670      ADIW	R30,0x10
    0170A 8220      ST	Z,R2
    0170B E188      LDI	R24,0x18
    0170C E090      LDI	R25,0
    0170D A10C      LDD	R16,Y+36
    0170E A11D      LDD	R17,Y+37
    0170F A12E      LDD	R18,Y+38
    01710 A13F      LDD	R19,Y+39
    01711 938A      ST	-Y,R24
    01712 940E 4008 CALL	lsr32
    01714 01F7      MOVW	R30,R14
    01715 8B01      STD	Z+17,R16
(2303) 			dir[DIR_Attr] = 0;					/* Reset attribute */
    01716 2422      CLR	R2
    01717 8623      STD	Z+11,R2
(2304) 			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    01718 8E24      STD	Z+28,R2
    01719 8E25      STD	Z+29,R2
    0171A 8E26      STD	Z+30,R2
    0171B 8E27      STD	Z+31,R2
(2305) 			cl = LD_CLUST(dir);					/* Get start cluster */
    0171C 8C22      LDD	R2,Z+26
    0171D 2433      CLR	R3
    0171E 8C43      LDD	R4,Z+27
    0171F 2455      CLR	R5
    01720 2C54      MOV	R5,R4
    01721 2444      CLR	R4
    01722 2842      OR	R4,R2
    01723 2853      OR	R5,R3
    01724 0112      MOVW	R2,R4
    01725 2444      CLR	R4
    01726 2455      CLR	R5
    01727 8864      LDD	R6,Z+20
    01728 2477      CLR	R7
    01729 9675      ADIW	R30,0x15
    0172A 8080      LD	R8,Z
    0172B 2499      CLR	R9
    0172C 2C98      MOV	R9,R8
    0172D 2488      CLR	R8
    0172E 2886      OR	R8,R6
    0172F 2897      OR	R9,R7
    01730 0134      MOVW	R6,R8
    01731 2488      CLR	R8
    01732 2499      CLR	R9
    01733 0143      MOVW	R8,R6
    01734 2466      CLR	R6
    01735 2477      CLR	R7
    01736 2862      OR	R6,R2
    01737 2873      OR	R7,R3
    01738 2884      OR	R8,R4
    01739 2895      OR	R9,R5
    0173A A668      STD	Y+40,R6
    0173B A679      STD	Y+41,R7
    0173C A68A      STD	Y+42,R8
    0173D A69B      STD	Y+43,R9
(2306) 			ST_CLUST(dir, 0);					/* cluster = 0 */
    0173E 2422      CLR	R2
    0173F 01F7      MOVW	R30,R14
    01740 8E22      STD	Z+26,R2
    01741 8E23      STD	Z+27,R2
    01742 8A24      STD	Z+20,R2
    01743 8A25      STD	Z+21,R2
(2307) 			dj.fs->wflag = 1;
    01744 E081      LDI	R24,1
    01745 81EA      LDD	R30,Y+2
    01746 81FB      LDD	R31,Y+3
    01747 9634      ADIW	R30,4
    01748 8380      ST	Z,R24
(2308) 			if (cl) {							/* Remove the cluster chain if exist */
    01749 A428      LDD	R2,Y+40
    0174A A439      LDD	R3,Y+41
    0174B A44A      LDD	R4,Y+42
    0174C A45B      LDD	R5,Y+43
    0174D 9488      BCLR	0
    0174E 2022      TST	R2
    0174F 0432      CPC	R3,R2
    01750 0442      CPC	R4,R2
    01751 0452      CPC	R5,R2
    01752 F409      BNE	0x1754
    01753 C04B      RJMP	0x179F
(2309) 				dw = dj.fs->winsect;
    01754 81EA      LDD	R30,Y+2
    01755 81FB      LDD	R31,Y+3
    01756 A422      LDD	R2,Z+42
    01757 A433      LDD	R3,Z+43
    01758 A444      LDD	R4,Z+44
    01759 A455      LDD	R5,Z+45
    0175A A22C      STD	Y+36,R2
    0175B A23D      STD	Y+37,R3
    0175C A24E      STD	Y+38,R4
    0175D A25F      STD	Y+39,R5
(2310) 				res = remove_chain(dj.fs, cl);
    0175E A428      LDD	R2,Y+40
    0175F A439      LDD	R3,Y+41
    01760 A44A      LDD	R4,Y+42
    01761 A45B      LDD	R5,Y+43
    01762 8248      ST	Y,R4
    01763 8259      STD	Y+1,R5
    01764 0191      MOVW	R18,R2
    01765 810A      LDD	R16,Y+2
    01766 811B      LDD	R17,Y+3
    01767 940E 0811 CALL	ff.c:remove_chain
    01769 2EC0      MOV	R12,R16
    0176A 2CAC      MOV	R10,R12
(2311) 				if (res == FR_OK) {
    0176B 2300      TST	R16
    0176C F591      BNE	0x179F
(2312) 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    0176D E041      LDI	R20,1
    0176E E050      LDI	R21,0
    0176F E060      LDI	R22,0
    01770 E070      LDI	R23,0
    01771 A428      LDD	R2,Y+40
    01772 A439      LDD	R3,Y+41
    01773 A44A      LDD	R4,Y+42
    01774 A45B      LDD	R5,Y+43
    01775 1A24      SUB	R2,R20
    01776 0A35      SBC	R3,R21
    01777 0A46      SBC	R4,R22
    01778 0A57      SBC	R5,R23
    01779 81EA      LDD	R30,Y+2
    0177A 81FB      LDD	R31,Y+3
    0177B 8622      STD	Z+10,R2
    0177C 8633      STD	Z+11,R3
    0177D 8644      STD	Z+12,R4
    0177E 8655      STD	Z+13,R5
(2313) 					res = move_window(dj.fs, dw);
    0177F A02C      LDD	R2,Y+36
    01780 A03D      LDD	R3,Y+37
    01781 A04E      LDD	R4,Y+38
    01782 A05F      LDD	R5,Y+39
    01783 8248      ST	Y,R4
    01784 8259      STD	Y+1,R5
    01785 0191      MOVW	R18,R2
    01786 810A      LDD	R16,Y+2
    01787 811B      LDD	R17,Y+3
    01788 940E 0339 CALL	ff.c:move_window
    0178A 2EC0      MOV	R12,R16
    0178B 2CAC      MOV	R10,R12
(2314) 				}
(2315) 			}
(2316) 		}
(2317) 	}
    0178C C012      RJMP	0x179F
(2318) 	else {	/* Open an existing file */
(2319) 		if (res == FR_OK) {						/* Follow succeeded */
    0178D 20AA      TST	R10
    0178E F481      BNE	0x179F
(2320) 			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    0178F 01F7      MOVW	R30,R14
    01790 8423      LDD	R2,Z+11
    01791 FE24      SBRS	R2,4
    01792 C003      RJMP	0x1796
(2321) 				res = FR_NO_FILE;
    01793 E084      LDI	R24,4
    01794 2EA8      MOV	R10,R24
(2322) 			} else {
    01795 C009      RJMP	0x179F
(2323) 				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    01796 AC0A      LDD	R0,Y+58
    01797 FE01      SBRS	R0,1
    01798 C006      RJMP	0x179F
    01799 01F7      MOVW	R30,R14
    0179A 8423      LDD	R2,Z+11
    0179B FE20      SBRS	R2,0
    0179C C002      RJMP	0x179F
(2324) 					res = FR_DENIED;
    0179D E087      LDI	R24,7
    0179E 2EA8      MOV	R10,R24
(2325) 			}
(2326) 		}
(2327) 	}
(2328) 	if (res == FR_OK) {
    0179F 20AA      TST	R10
    017A0 F4A1      BNE	0x17B5
(2329) 		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    017A1 AC0A      LDD	R0,Y+58
    017A2 FE03      SBRS	R0,3
    017A3 C003      RJMP	0x17A7
(2330) 			mode |= FA__WRITTEN;
    017A4 2D80      MOV	R24,R0
    017A5 6280      ORI	R24,0x20
    017A6 AF8A      STD	Y+58,R24
(2331) 		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    017A7 81EA      LDD	R30,Y+2
    017A8 81FB      LDD	R31,Y+3
    017A9 A422      LDD	R2,Z+42
    017AA A433      LDD	R3,Z+43
    017AB A444      LDD	R4,Z+44
    017AC A455      LDD	R5,Z+45
    017AD A9EE      LDD	R30,Y+54
    017AE A9FF      LDD	R31,Y+55
    017AF 8E22      STD	Z+26,R2
    017B0 8E33      STD	Z+27,R3
    017B1 8E44      STD	Z+28,R4
    017B2 8E55      STD	Z+29,R5
(2332) 		fp->dir_ptr = dir;
    017B3 8EF7      STD	Z+31,R15
    017B4 8EE6      STD	Z+30,R14
(2333) #if _FS_SHARE
(2334) 		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2335) 		if (!fp->lockid) res = FR_INT_ERR;
(2336) #endif
(2337) 	}
(2338) 
(2339) #else				/* R/O configuration */
(2340) 	if (res == FR_OK) {					/* Follow succeeded */
(2341) 		if (!dir) {						/* Current dir itself */
(2342) 			res = FR_INVALID_NAME;
(2343) 		} else {
(2344) 			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
(2345) 				res = FR_NO_FILE;
(2346) 		}
(2347) 	}
(2348) #endif
(2349) 	FREE_BUF();
(2350) 
(2351) 	if (res == FR_OK) {
    017B5 20AA      TST	R10
    017B6 F009      BEQ	0x17B8
    017B7 C077      RJMP	0x182F
(2352) 		fp->flag = mode;					/* File access mode */
    017B8 A9EE      LDD	R30,Y+54
    017B9 A9FF      LDD	R31,Y+55
    017BA AC0A      LDD	R0,Y+58
    017BB 8204      STD	Z+4,R0
(2353) 		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    017BC 01F7      MOVW	R30,R14
    017BD 8C22      LDD	R2,Z+26
    017BE 2433      CLR	R3
    017BF 8C43      LDD	R4,Z+27
    017C0 2455      CLR	R5
    017C1 2C54      MOV	R5,R4
    017C2 2444      CLR	R4
    017C3 2842      OR	R4,R2
    017C4 2853      OR	R5,R3
    017C5 0112      MOVW	R2,R4
    017C6 2444      CLR	R4
    017C7 2455      CLR	R5
    017C8 8864      LDD	R6,Z+20
    017C9 2477      CLR	R7
    017CA 8885      LDD	R8,Z+21
    017CB 2499      CLR	R9
    017CC 2C98      MOV	R9,R8
    017CD 2488      CLR	R8
    017CE 2886      OR	R8,R6
    017CF 2897      OR	R9,R7
    017D0 0134      MOVW	R6,R8
    017D1 2488      CLR	R8
    017D2 2499      CLR	R9
    017D3 0143      MOVW	R8,R6
    017D4 2466      CLR	R6
    017D5 2477      CLR	R7
    017D6 2862      OR	R6,R2
    017D7 2873      OR	R7,R3
    017D8 2884      OR	R8,R4
    017D9 2895      OR	R9,R5
    017DA A9EE      LDD	R30,Y+54
    017DB A9FF      LDD	R31,Y+55
    017DC 8666      STD	Z+14,R6
    017DD 8677      STD	Z+15,R7
    017DE 8A80      STD	Z+16,R8
    017DF 8A91      STD	Z+17,R9
(2354) 		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    017E0 E188      LDI	R24,0x18
    017E1 E090      LDI	R25,0
    017E2 01F7      MOVW	R30,R14
    017E3 8D07      LDD	R16,Z+31
    017E4 2711      CLR	R17
    017E5 2722      CLR	R18
    017E6 2733      CLR	R19
    017E7 938A      ST	-Y,R24
    017E8 940E 3FEF CALL	lsl32
    017EA 0118      MOVW	R2,R16
    017EB 0129      MOVW	R4,R18
    017EC 01F7      MOVW	R30,R14
    017ED 8C66      LDD	R6,Z+30
    017EE 2477      CLR	R7
    017EF 2488      CLR	R8
    017F0 2499      CLR	R9
    017F1 0143      MOVW	R8,R6
    017F2 2466      CLR	R6
    017F3 2477      CLR	R7
    017F4 2826      OR	R2,R6
    017F5 2837      OR	R3,R7
    017F6 2848      OR	R4,R8
    017F7 2859      OR	R5,R9
    017F8 8C65      LDD	R6,Z+29
    017F9 2477      CLR	R7
    017FA 2C76      MOV	R7,R6
    017FB 2466      CLR	R6
    017FC 2488      CLR	R8
    017FD 2499      CLR	R9
    017FE 2826      OR	R2,R6
    017FF 2837      OR	R3,R7
    01800 2848      OR	R4,R8
    01801 2859      OR	R5,R9
    01802 8C64      LDD	R6,Z+28
    01803 2477      CLR	R7
    01804 2488      CLR	R8
    01805 2499      CLR	R9
    01806 2826      OR	R2,R6
    01807 2837      OR	R3,R7
    01808 2848      OR	R4,R8
    01809 2859      OR	R5,R9
    0180A A9EE      LDD	R30,Y+54
    0180B A9FF      LDD	R31,Y+55
    0180C 8622      STD	Z+10,R2
    0180D 8633      STD	Z+11,R3
    0180E 8644      STD	Z+12,R4
    0180F 8655      STD	Z+13,R5
(2355) 		fp->fptr = 0;						/* File pointer */
    01810 9636      ADIW	R30,6
    01811 E080      LDI	R24,0
    01812 8380      ST	Z,R24
    01813 8381      STD	Z+1,R24
    01814 8382      STD	Z+2,R24
    01815 8383      STD	Z+3,R24
(2356) 		fp->dsect = 0;
    01816 A9EE      LDD	R30,Y+54
    01817 A9FF      LDD	R31,Y+55
    01818 9676      ADIW	R30,0x16
    01819 E080      LDI	R24,0
    0181A 8380      ST	Z,R24
    0181B 8381      STD	Z+1,R24
    0181C 8382      STD	Z+2,R24
    0181D 8383      STD	Z+3,R24
(2357) #if _USE_FASTSEEK
(2358) 		fp->cltbl = 0;						/* Normal seek mode */
    0181E 2422      CLR	R2
    0181F 2433      CLR	R3
    01820 A9EE      LDD	R30,Y+54
    01821 A9FF      LDD	R31,Y+55
    01822 A231      STD	Z+33,R3
    01823 A220      STD	Z+32,R2
(2359) #endif
(2360) 		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    01824 802A      LDD	R2,Y+2
    01825 803B      LDD	R3,Y+3
    01826 8231      STD	Z+1,R3
    01827 8220      ST	Z,R2
    01828 01F1      MOVW	R30,R2
    01829 8026      LDD	R2,Z+6
    0182A 8037      LDD	R3,Z+7
    0182B A9EE      LDD	R30,Y+54
    0182C A9FF      LDD	R31,Y+55
    0182D 8233      STD	Z+3,R3
    0182E 8222      STD	Z+2,R2
(2361) 	}
(2362) 
(2363) 	LEAVE_FF(dj.fs, res);
    0182F 2D0A      MOV	R16,R10
    01830 96AC      ADIW	R28,0x2C
    01831 940E 3F62 CALL	pop_xgsetF0FC
    01833 9624      ADIW	R28,4
    01834 9508      RET
_f_read:
  remain               --> Y,+13
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  rbuff                --> R14
  sect                 --> Y,+5
  rcnt                 --> R12
  br                   --> Y,+33
  btr                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01835 940E 3E28 CALL	push_arg4
    01837 940E 3F6D CALL	push_xgsetF0FC
    01839 0159      MOVW	R10,R18
    0183A 9761      SBIW	R28,0x11
(2364) }
(2365) 
(2366) 
(2367) 
(2368) 
(2369) /*-----------------------------------------------------------------------*/
(2370) /* Read File                                                             */
(2371) /*-----------------------------------------------------------------------*/
(2372) 
(2373) FRESULT f_read (
(2374) 	FIL *fp, 		/* Pointer to the file object */
(2375) 	void *buff,		/* Pointer to data buffer */
(2376) 	UINT btr,		/* Number of bytes to read */
(2377) 	UINT *br		/* Pointer to number of bytes read */
(2378) )
(2379) {
(2380) 	FRESULT res;
(2381) 	DWORD clst, sect, remain;
(2382) 	UINT rcnt, cc;
(2383) 	BYTE csect, *rbuff = buff;
    0183B 0175      MOVW	R14,R10
(2384) 
(2385) 	memset(buff,0,512);
    0183C E080      LDI	R24,0
    0183D E092      LDI	R25,2
    0183E 8399      STD	Y+1,R25
    0183F 8388      ST	Y,R24
    01840 2722      CLR	R18
    01841 2733      CLR	R19
    01842 0185      MOVW	R16,R10
    01843 940E 3E04 CALL	_memset
(2386) 
(2387) 	*br = 0;	/* Initialize byte counter */
    01845 2422      CLR	R2
    01846 2433      CLR	R3
    01847 A1E9      LDD	R30,Y+33
    01848 A1FA      LDD	R31,Y+34
    01849 8231      STD	Z+1,R3
    0184A 8220      ST	Z,R2
(2388) 
(2389) 	res = validate(fp->fs, fp->id);				/* Check validity */
    0184B 8DEB      LDD	R30,Y+27
    0184C 8DFC      LDD	R31,Y+28
    0184D 8122      LDD	R18,Z+2
    0184E 8133      LDD	R19,Z+3
    0184F 8100      LD	R16,Z
    01850 8111      LDD	R17,Z+1
    01851 DDFF      RCALL	ff.c:validate
    01852 2EA0      MOV	R10,R16
(2390) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01853 2300      TST	R16
    01854 F009      BEQ	0x1856
    01855 C245      RJMP	0x1A9B
(2391) 	if (fp->flag & FA__ERROR)					/* Aborted file? */
    01856 8DEB      LDD	R30,Y+27
    01857 8DFC      LDD	R31,Y+28
    01858 8024      LDD	R2,Z+4
    01859 FE27      SBRS	R2,7
    0185A C002      RJMP	0x185D
(2392) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    0185B E002      LDI	R16,2
    0185C C23E      RJMP	0x1A9B
(2393) 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    0185D 8DEB      LDD	R30,Y+27
    0185E 8DFC      LDD	R31,Y+28
    0185F 8024      LDD	R2,Z+4
    01860 FC20      SBRC	R2,0
    01861 C002      RJMP	0x1864
(2394) 		LEAVE_FF(fp->fs, FR_DENIED);
    01862 E007      LDI	R16,7
    01863 C237      RJMP	0x1A9B
(2395) 	remain = fp->fsize - fp->fptr;
    01864 8DEB      LDD	R30,Y+27
    01865 8DFC      LDD	R31,Y+28
    01866 8026      LDD	R2,Z+6
    01867 8037      LDD	R3,Z+7
    01868 8440      LDD	R4,Z+8
    01869 8451      LDD	R5,Z+9
    0186A 963A      ADIW	R30,0xA
    0186B 8060      LD	R6,Z
    0186C 8071      LDD	R7,Z+1
    0186D 8082      LDD	R8,Z+2
    0186E 8093      LDD	R9,Z+3
    0186F 1862      SUB	R6,R2
    01870 0873      SBC	R7,R3
    01871 0884      SBC	R8,R4
    01872 0895      SBC	R9,R5
    01873 866D      STD	Y+13,R6
    01874 867E      STD	Y+14,R7
    01875 868F      STD	Y+15,R8
    01876 8A98      STD	Y+16,R9
(2396) 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    01877 842D      LDD	R2,Y+13
    01878 843E      LDD	R3,Y+14
    01879 844F      LDD	R4,Y+15
    0187A 8858      LDD	R5,Y+16
    0187B 8C6F      LDD	R6,Y+31
    0187C A078      LDD	R7,Y+32
    0187D 2488      CLR	R8
    0187E 2499      CLR	R9
    0187F 1426      CP	R2,R6
    01880 0437      CPC	R3,R7
    01881 0448      CPC	R4,R8
    01882 0459      CPC	R5,R9
    01883 F008      BCS	0x1885
    01884 C20D      RJMP	0x1A92
    01885 A238      STD	Y+32,R3
    01886 8E2F      STD	Y+31,R2
(2397) 
(2398) 	for ( ;  btr;								/* Repeat until all data read */
    01887 C20A      RJMP	0x1A92
(2399) 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
(2400) 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    01888 EF4F      LDI	R20,0xFF
    01889 E051      LDI	R21,1
    0188A E060      LDI	R22,0
    0188B E070      LDI	R23,0
    0188C 8DEB      LDD	R30,Y+27
    0188D 8DFC      LDD	R31,Y+28
    0188E 9636      ADIW	R30,6
    0188F 8020      LD	R2,Z
    01890 8031      LDD	R3,Z+1
    01891 8042      LDD	R4,Z+2
    01892 8053      LDD	R5,Z+3
    01893 2224      AND	R2,R20
    01894 2235      AND	R3,R21
    01895 2246      AND	R4,R22
    01896 2257      AND	R5,R23
    01897 9488      BCLR	0
    01898 2022      TST	R2
    01899 0432      CPC	R3,R2
    0189A 0442      CPC	R4,R2
    0189B 0452      CPC	R5,R2
    0189C F009      BEQ	0x189E
    0189D C180      RJMP	0x1A1E
(2401) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    0189E E089      LDI	R24,0x9
    0189F E090      LDI	R25,0
    018A0 8DEB      LDD	R30,Y+27
    018A1 8DFC      LDD	R31,Y+28
    018A2 8106      LDD	R16,Z+6
    018A3 8117      LDD	R17,Z+7
    018A4 8520      LDD	R18,Z+8
    018A5 8531      LDD	R19,Z+9
    018A6 938A      ST	-Y,R24
    018A7 940E 4008 CALL	lsr32
    018A9 0118      MOVW	R2,R16
    018AA 0129      MOVW	R4,R18
    018AB 8DEB      LDD	R30,Y+27
    018AC 8DFC      LDD	R31,Y+28
    018AD 93AF      PUSH	R26
    018AE 93BF      PUSH	R27
    018AF 81A0      LD	R26,Z
    018B0 81B1      LDD	R27,Z+1
    018B1 01FD      MOVW	R30,R26
    018B2 91BF      POP	R27
    018B3 91AF      POP	R26
    018B4 8182      LDD	R24,Z+2
    018B5 2799      CLR	R25
    018B6 9701      SBIW	R24,1
    018B7 013C      MOVW	R6,R24
    018B8 2488      CLR	R8
    018B9 FC77      SBRC	R7,7
    018BA 9480      COM	R8
    018BB 2499      CLR	R9
    018BC FC87      SBRC	R8,7
    018BD 9490      COM	R9
    018BE 2026      AND	R2,R6
    018BF 2037      AND	R3,R7
    018C0 2048      AND	R4,R8
    018C1 2059      AND	R5,R9
    018C2 2CC2      MOV	R12,R2
(2402) 			if (!csect) {						/* On the cluster boundary? */
    018C3 2022      TST	R2
    018C4 F009      BEQ	0x18C6
    018C5 C078      RJMP	0x193E
(2403) 				if (fp->fptr == 0) {			/* On the top of the file? */
    018C6 8DEB      LDD	R30,Y+27
    018C7 8DFC      LDD	R31,Y+28
    018C8 9636      ADIW	R30,6
    018C9 8020      LD	R2,Z
    018CA 8031      LDD	R3,Z+1
    018CB 8042      LDD	R4,Z+2
    018CC 8053      LDD	R5,Z+3
    018CD 9488      BCLR	0
    018CE 2022      TST	R2
    018CF 0432      CPC	R3,R2
    018D0 0442      CPC	R4,R2
    018D1 0452      CPC	R5,R2
    018D2 F461      BNE	0x18DF
(2404) 					clst = fp->sclust;			/* Follow from the origin */
    018D3 8DEB      LDD	R30,Y+27
    018D4 8DFC      LDD	R31,Y+28
    018D5 963E      ADIW	R30,0xE
    018D6 8020      LD	R2,Z
    018D7 8031      LDD	R3,Z+1
    018D8 8042      LDD	R4,Z+2
    018D9 8053      LDD	R5,Z+3
    018DA 8629      STD	Y+9,R2
    018DB 863A      STD	Y+10,R3
    018DC 864B      STD	Y+11,R4
    018DD 865C      STD	Y+12,R5
(2405) 				} else {						/* Middle or end of the file */
    018DE C028      RJMP	0x1907
(2406) #if _USE_FASTSEEK
(2407) 					if (fp->cltbl)
    018DF 8DEB      LDD	R30,Y+27
    018E0 8DFC      LDD	R31,Y+28
    018E1 A020      LDD	R2,Z+32
    018E2 A031      LDD	R3,Z+33
    018E3 2022      TST	R2
    018E4 F411      BNE	0x18E7
    018E5 2033      TST	R3
    018E6 F079      BEQ	0x18F6
(2408) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    018E7 8026      LDD	R2,Z+6
    018E8 8037      LDD	R3,Z+7
    018E9 8440      LDD	R4,Z+8
    018EA 8451      LDD	R5,Z+9
    018EB 8248      ST	Y,R4
    018EC 8259      STD	Y+1,R5
    018ED 0191      MOVW	R18,R2
    018EE 018F      MOVW	R16,R30
    018EF 940E 0A3C CALL	ff.c:clmt_clust
    018F1 8709      STD	Y+9,R16
    018F2 871A      STD	Y+10,R17
    018F3 872B      STD	Y+11,R18
    018F4 873C      STD	Y+12,R19
    018F5 C011      RJMP	0x1907
(2409) 					else
(2410) #endif
(2411) 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    018F6 8DEB      LDD	R30,Y+27
    018F7 8DFC      LDD	R31,Y+28
    018F8 8822      LDD	R2,Z+18
    018F9 8833      LDD	R3,Z+19
    018FA 8844      LDD	R4,Z+20
    018FB 8855      LDD	R5,Z+21
    018FC 8248      ST	Y,R4
    018FD 8259      STD	Y+1,R5
    018FE 0191      MOVW	R18,R2
    018FF 8100      LD	R16,Z
    01900 8111      LDD	R17,Z+1
    01901 940E 0502 CALL	_get_fat
    01903 8709      STD	Y+9,R16
    01904 871A      STD	Y+10,R17
    01905 872B      STD	Y+11,R18
    01906 873C      STD	Y+12,R19
(2412) 				}
(2413) 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    01907 E042      LDI	R20,2
    01908 E050      LDI	R21,0
    01909 E060      LDI	R22,0
    0190A E070      LDI	R23,0
    0190B 8429      LDD	R2,Y+9
    0190C 843A      LDD	R3,Y+10
    0190D 844B      LDD	R4,Y+11
    0190E 845C      LDD	R5,Y+12
    0190F 1624      CP	R2,R20
    01910 0635      CPC	R3,R21
    01911 0646      CPC	R4,R22
    01912 0657      CPC	R5,R23
    01913 F448      BCC	0x191D
    01914 8D8B      LDD	R24,Y+27
    01915 8D9C      LDD	R25,Y+28
    01916 9604      ADIW	R24,4
    01917 01FC      MOVW	R30,R24
    01918 8180      LD	R24,Z
    01919 6880      ORI	R24,0x80
    0191A 8380      ST	Z,R24
    0191B E002      LDI	R16,2
    0191C C17E      RJMP	0x1A9B
(2414) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    0191D EF4F      LDI	R20,0xFF
    0191E EF5F      LDI	R21,0xFF
    0191F EF6F      LDI	R22,0xFF
    01920 EF7F      LDI	R23,0xFF
    01921 8429      LDD	R2,Y+9
    01922 843A      LDD	R3,Y+10
    01923 844B      LDD	R4,Y+11
    01924 845C      LDD	R5,Y+12
    01925 1624      CP	R2,R20
    01926 0635      CPC	R3,R21
    01927 0646      CPC	R4,R22
    01928 0657      CPC	R5,R23
    01929 F451      BNE	0x1934
    0192A 8D8B      LDD	R24,Y+27
    0192B 8D9C      LDD	R25,Y+28
    0192C 9604      ADIW	R24,4
    0192D 015C      MOVW	R10,R24
    0192E 01FC      MOVW	R30,R24
    0192F 8180      LD	R24,Z
    01930 6880      ORI	R24,0x80
    01931 8380      ST	Z,R24
    01932 E001      LDI	R16,1
    01933 C167      RJMP	0x1A9B
(2415) 				fp->clust = clst;				/* Update current cluster */
    01934 8429      LDD	R2,Y+9
    01935 843A      LDD	R3,Y+10
    01936 844B      LDD	R4,Y+11
    01937 845C      LDD	R5,Y+12
    01938 8DEB      LDD	R30,Y+27
    01939 8DFC      LDD	R31,Y+28
    0193A 8A22      STD	Z+18,R2
    0193B 8A33      STD	Z+19,R3
    0193C 8A44      STD	Z+20,R4
    0193D 8A55      STD	Z+21,R5
(2416) 			}
(2417) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    0193E 8DEB      LDD	R30,Y+27
    0193F 8DFC      LDD	R31,Y+28
    01940 8822      LDD	R2,Z+18
    01941 8833      LDD	R3,Z+19
    01942 8844      LDD	R4,Z+20
    01943 8855      LDD	R5,Z+21
    01944 8248      ST	Y,R4
    01945 8259      STD	Y+1,R5
    01946 0191      MOVW	R18,R2
    01947 8100      LD	R16,Z
    01948 8111      LDD	R17,Z+1
    01949 940E 04B0 CALL	_clust2sect
    0194B 830D      STD	Y+5,R16
    0194C 831E      STD	Y+6,R17
    0194D 832F      STD	Y+7,R18
    0194E 8738      STD	Y+8,R19
(2418) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    0194F 802D      LDD	R2,Y+5
    01950 803E      LDD	R3,Y+6
    01951 804F      LDD	R4,Y+7
    01952 8458      LDD	R5,Y+8
    01953 9488      BCLR	0
    01954 2022      TST	R2
    01955 0432      CPC	R3,R2
    01956 0442      CPC	R4,R2
    01957 0452      CPC	R5,R2
    01958 F451      BNE	0x1963
    01959 8D8B      LDD	R24,Y+27
    0195A 8D9C      LDD	R25,Y+28
    0195B 9604      ADIW	R24,4
    0195C 015C      MOVW	R10,R24
    0195D 01FC      MOVW	R30,R24
    0195E 8180      LD	R24,Z
    0195F 6880      ORI	R24,0x80
    01960 8380      ST	Z,R24
    01961 E002      LDI	R16,2
    01962 C138      RJMP	0x1A9B
(2419) 			sect += csect;
    01963 2C2C      MOV	R2,R12
    01964 2433      CLR	R3
    01965 2444      CLR	R4
    01966 2455      CLR	R5
    01967 806D      LDD	R6,Y+5
    01968 807E      LDD	R7,Y+6
    01969 808F      LDD	R8,Y+7
    0196A 8498      LDD	R9,Y+8
    0196B 0C62      ADD	R6,R2
    0196C 1C73      ADC	R7,R3
    0196D 1C84      ADC	R8,R4
    0196E 1C95      ADC	R9,R5
    0196F 826D      STD	Y+5,R6
    01970 827E      STD	Y+6,R7
    01971 828F      STD	Y+7,R8
    01972 8698      STD	Y+8,R9
(2420) 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    01973 E029      LDI	R18,0x9
    01974 E030      LDI	R19,0
    01975 8D0F      LDD	R16,Y+31
    01976 A118      LDD	R17,Y+32
    01977 940E 4001 CALL	lsr16
    01979 0158      MOVW	R10,R16
(2421) 			if (cc) {							/* Read maximum contiguous sectors directly */
    0197A 3000      CPI	R16,0
    0197B 0701      CPC	R16,R17
    0197C F409      BNE	0x197E
    0197D C096      RJMP	0x1A14
(2422) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    0197E 2C2C      MOV	R2,R12
    0197F 2433      CLR	R3
    01980 0E20      ADD	R2,R16
    01981 1E31      ADC	R3,R17
    01982 8DEB      LDD	R30,Y+27
    01983 8DFC      LDD	R31,Y+28
    01984 93AF      PUSH	R26
    01985 93BF      PUSH	R27
    01986 81A0      LD	R26,Z
    01987 81B1      LDD	R27,Z+1
    01988 01FD      MOVW	R30,R26
    01989 91BF      POP	R27
    0198A 91AF      POP	R26
    0198B 8042      LDD	R4,Z+2
    0198C 2455      CLR	R5
    0198D 1442      CP	R4,R2
    0198E 0453      CPC	R5,R3
    0198F F478      BCC	0x199F
(2423) 					cc = fp->fs->csize - csect;
    01990 2C2C      MOV	R2,R12
    01991 2433      CLR	R3
    01992 8DEB      LDD	R30,Y+27
    01993 8DFC      LDD	R31,Y+28
    01994 93AF      PUSH	R26
    01995 93BF      PUSH	R27
    01996 81A0      LD	R26,Z
    01997 81B1      LDD	R27,Z+1
    01998 01FD      MOVW	R30,R26
    01999 91BF      POP	R27
    0199A 91AF      POP	R26
    0199B 80A2      LDD	R10,Z+2
    0199C 24BB      CLR	R11
    0199D 18A2      SUB	R10,R2
    0199E 08B3      SBC	R11,R3
(2424) 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    0199F 82AC      STD	Y+4,R10
    019A0 802D      LDD	R2,Y+5
    019A1 803E      LDD	R3,Y+6
    019A2 804F      LDD	R4,Y+7
    019A3 8458      LDD	R5,Y+8
    019A4 8228      ST	Y,R2
    019A5 8239      STD	Y+1,R3
    019A6 824A      STD	Y+2,R4
    019A7 825B      STD	Y+3,R5
    019A8 0197      MOVW	R18,R14
    019A9 8DEB      LDD	R30,Y+27
    019AA 8DFC      LDD	R31,Y+28
    019AB 93AF      PUSH	R26
    019AC 93BF      PUSH	R27
    019AD 81A0      LD	R26,Z
    019AE 81B1      LDD	R27,Z+1
    019AF 01FD      MOVW	R30,R26
    019B0 91BF      POP	R27
    019B1 91AF      POP	R26
    019B2 8101      LDD	R16,Z+1
    019B3 940E 029E CALL	_disk_read
    019B5 2EC0      MOV	R12,R16
    019B6 2300      TST	R16
    019B7 F051      BEQ	0x19C2
(2425) 					ABORT(fp->fs, FR_DISK_ERR);
    019B8 8D8B      LDD	R24,Y+27
    019B9 8D9C      LDD	R25,Y+28
    019BA 9604      ADIW	R24,4
    019BB 016C      MOVW	R12,R24
    019BC 01FC      MOVW	R30,R24
    019BD 8180      LD	R24,Z
    019BE 6880      ORI	R24,0x80
    019BF 8380      ST	Z,R24
    019C0 E001      LDI	R16,1
    019C1 C0D9      RJMP	0x1A9B
(2426) #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
(2427) #if _FS_TINY
(2428) 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    019C2 8DEB      LDD	R30,Y+27
    019C3 8DFC      LDD	R31,Y+28
    019C4 80C0      LD	R12,Z
    019C5 80D1      LDD	R13,Z+1
    019C6 01F6      MOVW	R30,R12
    019C7 9634      ADIW	R30,4
    019C8 8020      LD	R2,Z
    019C9 2022      TST	R2
    019CA F409      BNE	0x19CC
    019CB C041      RJMP	0x1A0D
    019CC 802D      LDD	R2,Y+5
    019CD 803E      LDD	R3,Y+6
    019CE 804F      LDD	R4,Y+7
    019CF 8458      LDD	R5,Y+8
    019D0 01F6      MOVW	R30,R12
    019D1 A462      LDD	R6,Z+42
    019D2 A473      LDD	R7,Z+43
    019D3 A484      LDD	R8,Z+44
    019D4 A495      LDD	R9,Z+45
    019D5 1862      SUB	R6,R2
    019D6 0873      SBC	R7,R3
    019D7 0884      SBC	R8,R4
    019D8 0895      SBC	R9,R5
    019D9 0115      MOVW	R2,R10
    019DA 2444      CLR	R4
    019DB 2455      CLR	R5
    019DC 1462      CP	R6,R2
    019DD 0473      CPC	R7,R3
    019DE 0484      CPC	R8,R4
    019DF 0495      CPC	R9,R5
    019E0 F560      BCC	0x1A0D
(2429) 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
    019E1 E080      LDI	R24,0
    019E2 E092      LDI	R25,2
    019E3 8399      STD	Y+1,R25
    019E4 8388      ST	Y,R24
    019E5 8DEB      LDD	R30,Y+27
    019E6 8DFC      LDD	R31,Y+28
    019E7 80C0      LD	R12,Z
    019E8 80D1      LDD	R13,Z+1
    019E9 0196      MOVW	R18,R12
    019EA 5D22      SUBI	R18,0xD2
    019EB 4F3F      SBCI	R19,0xFF
    019EC 802D      LDD	R2,Y+5
    019ED 803E      LDD	R3,Y+6
    019EE 804F      LDD	R4,Y+7
    019EF 8458      LDD	R5,Y+8
    019F0 01F6      MOVW	R30,R12
    019F1 A462      LDD	R6,Z+42
    019F2 A473      LDD	R7,Z+43
    019F3 A484      LDD	R8,Z+44
    019F4 A495      LDD	R9,Z+45
    019F5 1862      SUB	R6,R2
    019F6 0873      SBC	R7,R3
    019F7 0884      SBC	R8,R4
    019F8 0895      SBC	R9,R5
    019F9 E040      LDI	R20,0
    019FA E052      LDI	R21,2
    019FB E060      LDI	R22,0
    019FC E070      LDI	R23,0
    019FD 932F      PUSH	R18
    019FE 933F      PUSH	R19
    019FF 929A      ST	-Y,R9
    01A00 928A      ST	-Y,R8
    01A01 927A      ST	-Y,R7
    01A02 926A      ST	-Y,R6
    01A03 018A      MOVW	R16,R20
    01A04 019B      MOVW	R18,R22
    01A05 940E 3F19 CALL	empy32u|empy32s
    01A07 913F      POP	R19
    01A08 912F      POP	R18
    01A09 0D0E      ADD	R16,R14
    01A0A 1D1F      ADC	R17,R15
    01A0B 940E 02E0 CALL	ff.c:mem_cpy
(2430) #else
(2431) 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
(2432) 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
(2433) #endif
(2434) #endif
(2435) 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    01A0D E000      LDI	R16,0
    01A0E E012      LDI	R17,2
    01A0F 0195      MOVW	R18,R10
    01A10 940E 3F09 CALL	empy16s
    01A12 0168      MOVW	R12,R16
(2436) 				continue;
    01A13 C05A      RJMP	0x1A6E
(2437) 			}
(2438) #if !_FS_TINY
(2439) 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
(2440) #if !_FS_READONLY
(2441) 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2442) 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2443) 						ABORT(fp->fs, FR_DISK_ERR);
(2444) 					fp->flag &= ~FA__DIRTY;
(2445) 				}
(2446) #endif
(2447) 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
(2448) 					ABORT(fp->fs, FR_DISK_ERR);
(2449) 			}
(2450) #endif
(2451) 			fp->dsect = sect;
    01A14 802D      LDD	R2,Y+5
    01A15 803E      LDD	R3,Y+6
    01A16 804F      LDD	R4,Y+7
    01A17 8458      LDD	R5,Y+8
    01A18 8DEB      LDD	R30,Y+27
    01A19 8DFC      LDD	R31,Y+28
    01A1A 8A26      STD	Z+22,R2
    01A1B 8A37      STD	Z+23,R3
    01A1C 8E40      STD	Z+24,R4
    01A1D 8E51      STD	Z+25,R5
(2452) 		}
(2453) 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    01A1E EF4F      LDI	R20,0xFF
    01A1F E051      LDI	R21,1
    01A20 E060      LDI	R22,0
    01A21 E070      LDI	R23,0
    01A22 8DEB      LDD	R30,Y+27
    01A23 8DFC      LDD	R31,Y+28
    01A24 8026      LDD	R2,Z+6
    01A25 8037      LDD	R3,Z+7
    01A26 8440      LDD	R4,Z+8
    01A27 8451      LDD	R5,Z+9
    01A28 2224      AND	R2,R20
    01A29 2235      AND	R3,R21
    01A2A 2246      AND	R4,R22
    01A2B 2257      AND	R5,R23
    01A2C E040      LDI	R20,0
    01A2D E052      LDI	R21,2
    01A2E E060      LDI	R22,0
    01A2F E070      LDI	R23,0
    01A30 1942      SUB	R20,R2
    01A31 0953      SBC	R21,R3
    01A32 0964      SBC	R22,R4
    01A33 0975      SBC	R23,R5
    01A34 016A      MOVW	R12,R20
(2454) 		if (rcnt > btr) rcnt = btr;
    01A35 8C0F      LDD	R0,Y+31
    01A36 A018      LDD	R1,Y+32
    01A37 1604      CP	R0,R20
    01A38 0615      CPC	R1,R21
    01A39 F408      BCC	0x1A3B
    01A3A 0160      MOVW	R12,R0
(2455) #if _FS_TINY
(2456) 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    01A3B 8DEB      LDD	R30,Y+27
    01A3C 8DFC      LDD	R31,Y+28
    01A3D 8826      LDD	R2,Z+22
    01A3E 8837      LDD	R3,Z+23
    01A3F 8C40      LDD	R4,Z+24
    01A40 8C51      LDD	R5,Z+25
    01A41 8248      ST	Y,R4
    01A42 8259      STD	Y+1,R5
    01A43 0191      MOVW	R18,R2
    01A44 8100      LD	R16,Z
    01A45 8111      LDD	R17,Z+1
    01A46 940E 0339 CALL	ff.c:move_window
    01A48 2EA0      MOV	R10,R16
    01A49 2300      TST	R16
    01A4A F051      BEQ	0x1A55
(2457) 			ABORT(fp->fs, FR_DISK_ERR);
    01A4B 8D8B      LDD	R24,Y+27
    01A4C 8D9C      LDD	R25,Y+28
    01A4D 9604      ADIW	R24,4
    01A4E 015C      MOVW	R10,R24
    01A4F 01FC      MOVW	R30,R24
    01A50 8180      LD	R24,Z
    01A51 6880      ORI	R24,0x80
    01A52 8380      ST	Z,R24
    01A53 E001      LDI	R16,1
    01A54 C046      RJMP	0x1A9B
(2458) 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    01A55 82D9      STD	Y+1,R13
    01A56 82C8      ST	Y,R12
    01A57 EF4F      LDI	R20,0xFF
    01A58 E051      LDI	R21,1
    01A59 E060      LDI	R22,0
    01A5A E070      LDI	R23,0
    01A5B 8DEB      LDD	R30,Y+27
    01A5C 8DFC      LDD	R31,Y+28
    01A5D 8026      LDD	R2,Z+6
    01A5E 8037      LDD	R3,Z+7
    01A5F 8440      LDD	R4,Z+8
    01A60 8451      LDD	R5,Z+9
    01A61 2224      AND	R2,R20
    01A62 2235      AND	R3,R21
    01A63 2246      AND	R4,R22
    01A64 2257      AND	R5,R23
    01A65 0191      MOVW	R18,R2
    01A66 8180      LD	R24,Z
    01A67 8191      LDD	R25,Z+1
    01A68 968E      ADIW	R24,0x2E
    01A69 0F28      ADD	R18,R24
    01A6A 1F39      ADC	R19,R25
    01A6B 0187      MOVW	R16,R14
    01A6C 940E 02E0 CALL	ff.c:mem_cpy
    01A6E 0CEC      ADD	R14,R12
    01A6F 1CFD      ADC	R15,R13
    01A70 8D8B      LDD	R24,Y+27
    01A71 8D9C      LDD	R25,Y+28
    01A72 9606      ADIW	R24,6
    01A73 015C      MOVW	R10,R24
    01A74 0116      MOVW	R2,R12
    01A75 2444      CLR	R4
    01A76 2455      CLR	R5
    01A77 01FC      MOVW	R30,R24
    01A78 8060      LD	R6,Z
    01A79 8071      LDD	R7,Z+1
    01A7A 8082      LDD	R8,Z+2
    01A7B 8093      LDD	R9,Z+3
    01A7C 0C62      ADD	R6,R2
    01A7D 1C73      ADC	R7,R3
    01A7E 1C84      ADC	R8,R4
    01A7F 1C95      ADC	R9,R5
    01A80 8260      ST	Z,R6
    01A81 8271      STD	Z+1,R7
    01A82 8282      STD	Z+2,R8
    01A83 8293      STD	Z+3,R9
    01A84 A1E9      LDD	R30,Y+33
    01A85 A1FA      LDD	R31,Y+34
    01A86 8020      LD	R2,Z
    01A87 8031      LDD	R3,Z+1
    01A88 0C2C      ADD	R2,R12
    01A89 1C3D      ADC	R3,R13
    01A8A 8231      STD	Z+1,R3
    01A8B 8220      ST	Z,R2
    01A8C 8C0F      LDD	R0,Y+31
    01A8D A018      LDD	R1,Y+32
    01A8E 180C      SUB	R0,R12
    01A8F 081D      SBC	R1,R13
    01A90 A218      STD	Y+32,R1
    01A91 8E0F      STD	Y+31,R0
    01A92 8C0F      LDD	R0,Y+31
    01A93 A018      LDD	R1,Y+32
    01A94 2000      TST	R0
    01A95 F009      BEQ	0x1A97
    01A96 CDF1      RJMP	0x1888
    01A97 2011      TST	R1
    01A98 F009      BEQ	0x1A9A
    01A99 CDEE      RJMP	0x1888
(2459) #else
(2460) 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
(2461) #endif
(2462) 	}
(2463) 
(2464) 	LEAVE_FF(fp->fs, FR_OK);
    01A9A 2700      CLR	R16
    01A9B 9661      ADIW	R28,0x11
    01A9C 940E 3F62 CALL	pop_xgsetF0FC
    01A9E 9624      ADIW	R28,4
    01A9F 9508      RET
_f_write:
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  wbuff                --> R14
  sect                 --> Y,+5
  wcnt                 --> R12
  bw                   --> Y,+33
  btw                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01AA0 940E 3E28 CALL	push_arg4
    01AA2 940E 3F6D CALL	push_xgsetF0FC
    01AA4 0159      MOVW	R10,R18
    01AA5 9761      SBIW	R28,0x11
(2465) }
(2466) 
(2467) 
(2468) 
(2469) 
(2470) #if !_FS_READONLY
(2471) /*-----------------------------------------------------------------------*/
(2472) /* Write File                                                            */
(2473) /*-----------------------------------------------------------------------*/
(2474) 
(2475) FRESULT f_write (
(2476) 	FIL *fp,			/* Pointer to the file object */
(2477) 	const void *buff,	/* Pointer to the data to be written */
(2478) 	UINT btw,			/* Number of bytes to write */
(2479) 	UINT *bw			/* Pointer to number of bytes written */
(2480) )
(2481) {
(2482) 	FRESULT res;
(2483) 	DWORD clst, sect;
(2484) 	UINT wcnt, cc;
(2485) 	const BYTE *wbuff = buff;
    01AA6 0175      MOVW	R14,R10
(2486) 	BYTE csect;
(2487) 
(2488) 
(2489) 	*bw = 0;	/* Initialize byte counter */
    01AA7 2422      CLR	R2
    01AA8 2433      CLR	R3
    01AA9 A1E9      LDD	R30,Y+33
    01AAA A1FA      LDD	R31,Y+34
    01AAB 8231      STD	Z+1,R3
    01AAC 8220      ST	Z,R2
(2490) 
(2491) 	res = validate(fp->fs, fp->id);			/* Check validity */
    01AAD 8DEB      LDD	R30,Y+27
    01AAE 8DFC      LDD	R31,Y+28
    01AAF 8122      LDD	R18,Z+2
    01AB0 8133      LDD	R19,Z+3
    01AB1 8100      LD	R16,Z
    01AB2 8111      LDD	R17,Z+1
    01AB3 DB9D      RCALL	ff.c:validate
    01AB4 2EA0      MOV	R10,R16
(2492) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01AB5 2300      TST	R16
    01AB6 F009      BEQ	0x1AB8
    01AB7 C2FC      RJMP	0x1DB4
(2493) 	if (fp->flag & FA__ERROR)				/* Aborted file? */
    01AB8 8DEB      LDD	R30,Y+27
    01AB9 8DFC      LDD	R31,Y+28
    01ABA 8024      LDD	R2,Z+4
    01ABB FE27      SBRS	R2,7
    01ABC C002      RJMP	0x1ABF
(2494) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01ABD E002      LDI	R16,2
    01ABE C2F5      RJMP	0x1DB4
(2495) 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    01ABF 8DEB      LDD	R30,Y+27
    01AC0 8DFC      LDD	R31,Y+28
    01AC1 8024      LDD	R2,Z+4
    01AC2 FC21      SBRC	R2,1
    01AC3 C002      RJMP	0x1AC6
(2496) 		LEAVE_FF(fp->fs, FR_DENIED);
    01AC4 E007      LDI	R16,7
    01AC5 C2EE      RJMP	0x1DB4
(2497) 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    01AC6 8DEB      LDD	R30,Y+27
    01AC7 8DFC      LDD	R31,Y+28
    01AC8 963A      ADIW	R30,0xA
    01AC9 8020      LD	R2,Z
    01ACA 8031      LDD	R3,Z+1
    01ACB 8042      LDD	R4,Z+2
    01ACC 8053      LDD	R5,Z+3
    01ACD 862D      STD	Y+13,R2
    01ACE 863E      STD	Y+14,R3
    01ACF 864F      STD	Y+15,R4
    01AD0 8A58      STD	Y+16,R5
    01AD1 8C2F      LDD	R2,Y+31
    01AD2 A038      LDD	R3,Y+32
    01AD3 2444      CLR	R4
    01AD4 2455      CLR	R5
    01AD5 846D      LDD	R6,Y+13
    01AD6 847E      LDD	R7,Y+14
    01AD7 848F      LDD	R8,Y+15
    01AD8 8898      LDD	R9,Y+16
    01AD9 0C62      ADD	R6,R2
    01ADA 1C73      ADC	R7,R3
    01ADB 1C84      ADC	R8,R4
    01ADC 1C95      ADC	R9,R5
    01ADD 842D      LDD	R2,Y+13
    01ADE 843E      LDD	R3,Y+14
    01ADF 844F      LDD	R4,Y+15
    01AE0 8858      LDD	R5,Y+16
    01AE1 1462      CP	R6,R2
    01AE2 0473      CPC	R7,R3
    01AE3 0484      CPC	R8,R4
    01AE4 0495      CPC	R9,R5
    01AE5 F008      BCS	0x1AE7
    01AE6 C2A5      RJMP	0x1D8C
    01AE7 2400      CLR	R0
    01AE8 2411      CLR	R1
    01AE9 A218      STD	Y+32,R1
    01AEA 8E0F      STD	Y+31,R0
(2498) 
(2499) 	for ( ;  btw;							/* Repeat until all data written */
    01AEB C2A0      RJMP	0x1D8C
(2500) 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
(2501) 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    01AEC EF4F      LDI	R20,0xFF
    01AED E051      LDI	R21,1
    01AEE E060      LDI	R22,0
    01AEF E070      LDI	R23,0
    01AF0 8DEB      LDD	R30,Y+27
    01AF1 8DFC      LDD	R31,Y+28
    01AF2 9636      ADIW	R30,6
    01AF3 8020      LD	R2,Z
    01AF4 8031      LDD	R3,Z+1
    01AF5 8042      LDD	R4,Z+2
    01AF6 8053      LDD	R5,Z+3
    01AF7 2224      AND	R2,R20
    01AF8 2235      AND	R3,R21
    01AF9 2246      AND	R4,R22
    01AFA 2257      AND	R5,R23
    01AFB 9488      BCLR	0
    01AFC 2022      TST	R2
    01AFD 0432      CPC	R3,R2
    01AFE 0442      CPC	R4,R2
    01AFF 0452      CPC	R5,R2
    01B00 F009      BEQ	0x1B02
    01B01 C20B      RJMP	0x1D0D
(2502) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01B02 E089      LDI	R24,0x9
    01B03 E090      LDI	R25,0
    01B04 8DEB      LDD	R30,Y+27
    01B05 8DFC      LDD	R31,Y+28
    01B06 8106      LDD	R16,Z+6
    01B07 8117      LDD	R17,Z+7
    01B08 8520      LDD	R18,Z+8
    01B09 8531      LDD	R19,Z+9
    01B0A 938A      ST	-Y,R24
    01B0B 940E 4008 CALL	lsr32
    01B0D 0118      MOVW	R2,R16
    01B0E 0129      MOVW	R4,R18
    01B0F 8DEB      LDD	R30,Y+27
    01B10 8DFC      LDD	R31,Y+28
    01B11 93AF      PUSH	R26
    01B12 93BF      PUSH	R27
    01B13 81A0      LD	R26,Z
    01B14 81B1      LDD	R27,Z+1
    01B15 01FD      MOVW	R30,R26
    01B16 91BF      POP	R27
    01B17 91AF      POP	R26
    01B18 8182      LDD	R24,Z+2
    01B19 2799      CLR	R25
    01B1A 9701      SBIW	R24,1
    01B1B 013C      MOVW	R6,R24
    01B1C 2488      CLR	R8
    01B1D FC77      SBRC	R7,7
    01B1E 9480      COM	R8
    01B1F 2499      CLR	R9
    01B20 FC87      SBRC	R8,7
    01B21 9490      COM	R9
    01B22 2026      AND	R2,R6
    01B23 2037      AND	R3,R7
    01B24 2048      AND	R4,R8
    01B25 2059      AND	R5,R9
    01B26 2CC2      MOV	R12,R2
(2503) 			if (!csect) {					/* On the cluster boundary? */
    01B27 2022      TST	R2
    01B28 F009      BEQ	0x1B2A
    01B29 C0A5      RJMP	0x1BCF
(2504) 				if (fp->fptr == 0) {		/* On the top of the file? */
    01B2A 8DEB      LDD	R30,Y+27
    01B2B 8DFC      LDD	R31,Y+28
    01B2C 9636      ADIW	R30,6
    01B2D 8020      LD	R2,Z
    01B2E 8031      LDD	R3,Z+1
    01B2F 8042      LDD	R4,Z+2
    01B30 8053      LDD	R5,Z+3
    01B31 9488      BCLR	0
    01B32 2022      TST	R2
    01B33 0432      CPC	R3,R2
    01B34 0442      CPC	R4,R2
    01B35 0452      CPC	R5,R2
    01B36 F571      BNE	0x1B65
(2505) 					clst = fp->sclust;		/* Follow from the origin */
    01B37 8DEB      LDD	R30,Y+27
    01B38 8DFC      LDD	R31,Y+28
    01B39 963E      ADIW	R30,0xE
    01B3A 8020      LD	R2,Z
    01B3B 8031      LDD	R3,Z+1
    01B3C 8042      LDD	R4,Z+2
    01B3D 8053      LDD	R5,Z+3
    01B3E 8629      STD	Y+9,R2
    01B3F 863A      STD	Y+10,R3
    01B40 864B      STD	Y+11,R4
    01B41 865C      STD	Y+12,R5
(2506) 					if (clst == 0)			/* When no cluster is allocated, */
    01B42 8429      LDD	R2,Y+9
    01B43 843A      LDD	R3,Y+10
    01B44 844B      LDD	R4,Y+11
    01B45 845C      LDD	R5,Y+12
    01B46 9488      BCLR	0
    01B47 2022      TST	R2
    01B48 0432      CPC	R3,R2
    01B49 0442      CPC	R4,R2
    01B4A 0452      CPC	R5,R2
    01B4B F009      BEQ	0x1B4D
    01B4C C040      RJMP	0x1B8D
(2507) 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    01B4D E040      LDI	R20,0
    01B4E E050      LDI	R21,0
    01B4F E060      LDI	R22,0
    01B50 E070      LDI	R23,0
    01B51 8368      ST	Y,R22
    01B52 8379      STD	Y+1,R23
    01B53 019A      MOVW	R18,R20
    01B54 8DEB      LDD	R30,Y+27
    01B55 8DFC      LDD	R31,Y+28
    01B56 8100      LD	R16,Z
    01B57 8111      LDD	R17,Z+1
    01B58 940E 08C4 CALL	ff.c:create_chain
    01B5A 8709      STD	Y+9,R16
    01B5B 871A      STD	Y+10,R17
    01B5C 872B      STD	Y+11,R18
    01B5D 873C      STD	Y+12,R19
    01B5E 8DEB      LDD	R30,Y+27
    01B5F 8DFC      LDD	R31,Y+28
    01B60 8706      STD	Z+14,R16
    01B61 8717      STD	Z+15,R17
    01B62 8B20      STD	Z+16,R18
    01B63 8B31      STD	Z+17,R19
(2508) 				} else {					/* Middle or end of the file */
    01B64 C028      RJMP	0x1B8D
(2509) #if _USE_FASTSEEK
(2510) 					if (fp->cltbl)
    01B65 8DEB      LDD	R30,Y+27
    01B66 8DFC      LDD	R31,Y+28
    01B67 A020      LDD	R2,Z+32
    01B68 A031      LDD	R3,Z+33
    01B69 2022      TST	R2
    01B6A F411      BNE	0x1B6D
    01B6B 2033      TST	R3
    01B6C F079      BEQ	0x1B7C
(2511) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    01B6D 8026      LDD	R2,Z+6
    01B6E 8037      LDD	R3,Z+7
    01B6F 8440      LDD	R4,Z+8
    01B70 8451      LDD	R5,Z+9
    01B71 8248      ST	Y,R4
    01B72 8259      STD	Y+1,R5
    01B73 0191      MOVW	R18,R2
    01B74 018F      MOVW	R16,R30
    01B75 940E 0A3C CALL	ff.c:clmt_clust
    01B77 8709      STD	Y+9,R16
    01B78 871A      STD	Y+10,R17
    01B79 872B      STD	Y+11,R18
    01B7A 873C      STD	Y+12,R19
    01B7B C011      RJMP	0x1B8D
(2512) 					else
(2513) #endif
(2514) 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    01B7C 8DEB      LDD	R30,Y+27
    01B7D 8DFC      LDD	R31,Y+28
    01B7E 8822      LDD	R2,Z+18
    01B7F 8833      LDD	R3,Z+19
    01B80 8844      LDD	R4,Z+20
    01B81 8855      LDD	R5,Z+21
    01B82 8248      ST	Y,R4
    01B83 8259      STD	Y+1,R5
    01B84 0191      MOVW	R18,R2
    01B85 8100      LD	R16,Z
    01B86 8111      LDD	R17,Z+1
    01B87 940E 08C4 CALL	ff.c:create_chain
    01B89 8709      STD	Y+9,R16
    01B8A 871A      STD	Y+10,R17
    01B8B 872B      STD	Y+11,R18
    01B8C 873C      STD	Y+12,R19
(2515) 				}
(2516) 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    01B8D 8429      LDD	R2,Y+9
    01B8E 843A      LDD	R3,Y+10
    01B8F 844B      LDD	R4,Y+11
    01B90 845C      LDD	R5,Y+12
    01B91 9488      BCLR	0
    01B92 2022      TST	R2
    01B93 0432      CPC	R3,R2
    01B94 0442      CPC	R4,R2
    01B95 0452      CPC	R5,R2
    01B96 F409      BNE	0x1B98
    01B97 C1FC      RJMP	0x1D94
(2517) 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    01B98 E041      LDI	R20,1
    01B99 E050      LDI	R21,0
    01B9A E060      LDI	R22,0
    01B9B E070      LDI	R23,0
    01B9C 8429      LDD	R2,Y+9
    01B9D 843A      LDD	R3,Y+10
    01B9E 844B      LDD	R4,Y+11
    01B9F 845C      LDD	R5,Y+12
    01BA0 1624      CP	R2,R20
    01BA1 0635      CPC	R3,R21
    01BA2 0646      CPC	R4,R22
    01BA3 0657      CPC	R5,R23
    01BA4 F449      BNE	0x1BAE
    01BA5 8D8B      LDD	R24,Y+27
    01BA6 8D9C      LDD	R25,Y+28
    01BA7 9604      ADIW	R24,4
    01BA8 01FC      MOVW	R30,R24
    01BA9 8180      LD	R24,Z
    01BAA 6880      ORI	R24,0x80
    01BAB 8380      ST	Z,R24
    01BAC E002      LDI	R16,2
    01BAD C206      RJMP	0x1DB4
(2518) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01BAE EF4F      LDI	R20,0xFF
    01BAF EF5F      LDI	R21,0xFF
    01BB0 EF6F      LDI	R22,0xFF
    01BB1 EF7F      LDI	R23,0xFF
    01BB2 8429      LDD	R2,Y+9
    01BB3 843A      LDD	R3,Y+10
    01BB4 844B      LDD	R4,Y+11
    01BB5 845C      LDD	R5,Y+12
    01BB6 1624      CP	R2,R20
    01BB7 0635      CPC	R3,R21
    01BB8 0646      CPC	R4,R22
    01BB9 0657      CPC	R5,R23
    01BBA F451      BNE	0x1BC5
    01BBB 8D8B      LDD	R24,Y+27
    01BBC 8D9C      LDD	R25,Y+28
    01BBD 9604      ADIW	R24,4
    01BBE 015C      MOVW	R10,R24
    01BBF 01FC      MOVW	R30,R24
    01BC0 8180      LD	R24,Z
    01BC1 6880      ORI	R24,0x80
    01BC2 8380      ST	Z,R24
    01BC3 E001      LDI	R16,1
    01BC4 C1EF      RJMP	0x1DB4
(2519) 				fp->clust = clst;			/* Update current cluster */
    01BC5 8429      LDD	R2,Y+9
    01BC6 843A      LDD	R3,Y+10
    01BC7 844B      LDD	R4,Y+11
    01BC8 845C      LDD	R5,Y+12
    01BC9 8DEB      LDD	R30,Y+27
    01BCA 8DFC      LDD	R31,Y+28
    01BCB 8A22      STD	Z+18,R2
    01BCC 8A33      STD	Z+19,R3
    01BCD 8A44      STD	Z+20,R4
    01BCE 8A55      STD	Z+21,R5
(2520) 			}
(2521) #if _FS_TINY
(2522) 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
    01BCF 8DEB      LDD	R30,Y+27
    01BD0 8DFC      LDD	R31,Y+28
    01BD1 80A0      LD	R10,Z
    01BD2 80B1      LDD	R11,Z+1
    01BD3 8826      LDD	R2,Z+22
    01BD4 8837      LDD	R3,Z+23
    01BD5 8C40      LDD	R4,Z+24
    01BD6 8C51      LDD	R5,Z+25
    01BD7 01F5      MOVW	R30,R10
    01BD8 A462      LDD	R6,Z+42
    01BD9 A473      LDD	R7,Z+43
    01BDA A484      LDD	R8,Z+44
    01BDB A495      LDD	R9,Z+45
    01BDC 1462      CP	R6,R2
    01BDD 0473      CPC	R7,R3
    01BDE 0484      CPC	R8,R4
    01BDF 0495      CPC	R9,R5
    01BE0 F4B9      BNE	0x1BF8
    01BE1 E040      LDI	R20,0
    01BE2 E050      LDI	R21,0
    01BE3 E060      LDI	R22,0
    01BE4 E070      LDI	R23,0
    01BE5 8368      ST	Y,R22
    01BE6 8379      STD	Y+1,R23
    01BE7 019A      MOVW	R18,R20
    01BE8 018F      MOVW	R16,R30
    01BE9 940E 0339 CALL	ff.c:move_window
    01BEB 2EA0      MOV	R10,R16
    01BEC 2300      TST	R16
    01BED F051      BEQ	0x1BF8
(2523) 				ABORT(fp->fs, FR_DISK_ERR);
    01BEE 8D8B      LDD	R24,Y+27
    01BEF 8D9C      LDD	R25,Y+28
    01BF0 9604      ADIW	R24,4
    01BF1 015C      MOVW	R10,R24
    01BF2 01FC      MOVW	R30,R24
    01BF3 8180      LD	R24,Z
    01BF4 6880      ORI	R24,0x80
    01BF5 8380      ST	Z,R24
    01BF6 E001      LDI	R16,1
    01BF7 C1BC      RJMP	0x1DB4
(2524) #else
(2525) 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
(2526) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2527) 					ABORT(fp->fs, FR_DISK_ERR);
(2528) 				fp->flag &= ~FA__DIRTY;
(2529) 			}
(2530) #endif
(2531) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01BF8 8DEB      LDD	R30,Y+27
    01BF9 8DFC      LDD	R31,Y+28
    01BFA 8822      LDD	R2,Z+18
    01BFB 8833      LDD	R3,Z+19
    01BFC 8844      LDD	R4,Z+20
    01BFD 8855      LDD	R5,Z+21
    01BFE 8248      ST	Y,R4
    01BFF 8259      STD	Y+1,R5
    01C00 0191      MOVW	R18,R2
    01C01 8100      LD	R16,Z
    01C02 8111      LDD	R17,Z+1
    01C03 940E 04B0 CALL	_clust2sect
    01C05 830D      STD	Y+5,R16
    01C06 831E      STD	Y+6,R17
    01C07 832F      STD	Y+7,R18
    01C08 8738      STD	Y+8,R19
(2532) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01C09 802D      LDD	R2,Y+5
    01C0A 803E      LDD	R3,Y+6
    01C0B 804F      LDD	R4,Y+7
    01C0C 8458      LDD	R5,Y+8
    01C0D 9488      BCLR	0
    01C0E 2022      TST	R2
    01C0F 0432      CPC	R3,R2
    01C10 0442      CPC	R4,R2
    01C11 0452      CPC	R5,R2
    01C12 F451      BNE	0x1C1D
    01C13 8D8B      LDD	R24,Y+27
    01C14 8D9C      LDD	R25,Y+28
    01C15 9604      ADIW	R24,4
    01C16 015C      MOVW	R10,R24
    01C17 01FC      MOVW	R30,R24
    01C18 8180      LD	R24,Z
    01C19 6880      ORI	R24,0x80
    01C1A 8380      ST	Z,R24
    01C1B E002      LDI	R16,2
    01C1C C197      RJMP	0x1DB4
(2533) 			sect += csect;
    01C1D 2C2C      MOV	R2,R12
    01C1E 2433      CLR	R3
    01C1F 2444      CLR	R4
    01C20 2455      CLR	R5
    01C21 806D      LDD	R6,Y+5
    01C22 807E      LDD	R7,Y+6
    01C23 808F      LDD	R8,Y+7
    01C24 8498      LDD	R9,Y+8
    01C25 0C62      ADD	R6,R2
    01C26 1C73      ADC	R7,R3
    01C27 1C84      ADC	R8,R4
    01C28 1C95      ADC	R9,R5
    01C29 826D      STD	Y+5,R6
    01C2A 827E      STD	Y+6,R7
    01C2B 828F      STD	Y+7,R8
    01C2C 8698      STD	Y+8,R9
(2534) 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    01C2D E029      LDI	R18,0x9
    01C2E E030      LDI	R19,0
    01C2F 8D0F      LDD	R16,Y+31
    01C30 A118      LDD	R17,Y+32
    01C31 940E 4001 CALL	lsr16
    01C33 0158      MOVW	R10,R16
(2535) 			if (cc) {						/* Write maximum contiguous sectors directly */
    01C34 3000      CPI	R16,0
    01C35 0701      CPC	R16,R17
    01C36 F409      BNE	0x1C38
    01C37 C097      RJMP	0x1CCF
(2536) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01C38 2C2C      MOV	R2,R12
    01C39 2433      CLR	R3
    01C3A 0E20      ADD	R2,R16
    01C3B 1E31      ADC	R3,R17
    01C3C 8DEB      LDD	R30,Y+27
    01C3D 8DFC      LDD	R31,Y+28
    01C3E 93AF      PUSH	R26
    01C3F 93BF      PUSH	R27
    01C40 81A0      LD	R26,Z
    01C41 81B1      LDD	R27,Z+1
    01C42 01FD      MOVW	R30,R26
    01C43 91BF      POP	R27
    01C44 91AF      POP	R26
    01C45 8042      LDD	R4,Z+2
    01C46 2455      CLR	R5
    01C47 1442      CP	R4,R2
    01C48 0453      CPC	R5,R3
    01C49 F478      BCC	0x1C59
(2537) 					cc = fp->fs->csize - csect;
    01C4A 2C2C      MOV	R2,R12
    01C4B 2433      CLR	R3
    01C4C 8DEB      LDD	R30,Y+27
    01C4D 8DFC      LDD	R31,Y+28
    01C4E 93AF      PUSH	R26
    01C4F 93BF      PUSH	R27
    01C50 81A0      LD	R26,Z
    01C51 81B1      LDD	R27,Z+1
    01C52 01FD      MOVW	R30,R26
    01C53 91BF      POP	R27
    01C54 91AF      POP	R26
    01C55 80A2      LDD	R10,Z+2
    01C56 24BB      CLR	R11
    01C57 18A2      SUB	R10,R2
    01C58 08B3      SBC	R11,R3
(2538) 				if (disk_write(fp->fs->drv,(char*)wbuff, sect, (BYTE)cc) != RES_OK)
    01C59 82AC      STD	Y+4,R10
    01C5A 802D      LDD	R2,Y+5
    01C5B 803E      LDD	R3,Y+6
    01C5C 804F      LDD	R4,Y+7
    01C5D 8458      LDD	R5,Y+8
    01C5E 8228      ST	Y,R2
    01C5F 8239      STD	Y+1,R3
    01C60 824A      STD	Y+2,R4
    01C61 825B      STD	Y+3,R5
    01C62 0197      MOVW	R18,R14
    01C63 8DEB      LDD	R30,Y+27
    01C64 8DFC      LDD	R31,Y+28
    01C65 93AF      PUSH	R26
    01C66 93BF      PUSH	R27
    01C67 81A0      LD	R26,Z
    01C68 81B1      LDD	R27,Z+1
    01C69 01FD      MOVW	R30,R26
    01C6A 91BF      POP	R27
    01C6B 91AF      POP	R26
    01C6C 8101      LDD	R16,Z+1
    01C6D 940E 02BE CALL	_disk_write
    01C6F 2EC0      MOV	R12,R16
    01C70 2300      TST	R16
    01C71 F051      BEQ	0x1C7C
(2539) 					ABORT(fp->fs, FR_DISK_ERR);
    01C72 8D8B      LDD	R24,Y+27
    01C73 8D9C      LDD	R25,Y+28
    01C74 9604      ADIW	R24,4
    01C75 016C      MOVW	R12,R24
    01C76 01FC      MOVW	R30,R24
    01C77 8180      LD	R24,Z
    01C78 6880      ORI	R24,0x80
    01C79 8380      ST	Z,R24
    01C7A E001      LDI	R16,1
    01C7B C138      RJMP	0x1DB4
(2540) #if _FS_TINY
(2541) 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
    01C7C 802D      LDD	R2,Y+5
    01C7D 803E      LDD	R3,Y+6
    01C7E 804F      LDD	R4,Y+7
    01C7F 8458      LDD	R5,Y+8
    01C80 8DEB      LDD	R30,Y+27
    01C81 8DFC      LDD	R31,Y+28
    01C82 81A0      LD	R26,Z
    01C83 81B1      LDD	R27,Z+1
    01C84 969A      ADIW	R26,0x2A
    01C85 906D      LD	R6,X+
    01C86 907D      LD	R7,X+
    01C87 908D      LD	R8,X+
    01C88 909C      LD	R9,X
    01C89 1862      SUB	R6,R2
    01C8A 0873      SBC	R7,R3
    01C8B 0884      SBC	R8,R4
    01C8C 0895      SBC	R9,R5
    01C8D 0115      MOVW	R2,R10
    01C8E 2444      CLR	R4
    01C8F 2455      CLR	R5
    01C90 1462      CP	R6,R2
    01C91 0473      CPC	R7,R3
    01C92 0484      CPC	R8,R4
    01C93 0495      CPC	R9,R5
    01C94 F008      BCS	0x1C96
    01C95 C032      RJMP	0x1CC8
(2542) 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
    01C96 E080      LDI	R24,0
    01C97 E092      LDI	R25,2
    01C98 8399      STD	Y+1,R25
    01C99 8388      ST	Y,R24
    01C9A 80C0      LD	R12,Z
    01C9B 80D1      LDD	R13,Z+1
    01C9C 802D      LDD	R2,Y+5
    01C9D 803E      LDD	R3,Y+6
    01C9E 804F      LDD	R4,Y+7
    01C9F 8458      LDD	R5,Y+8
    01CA0 01F6      MOVW	R30,R12
    01CA1 A462      LDD	R6,Z+42
    01CA2 A473      LDD	R7,Z+43
    01CA3 A484      LDD	R8,Z+44
    01CA4 A495      LDD	R9,Z+45
    01CA5 1862      SUB	R6,R2
    01CA6 0873      SBC	R7,R3
    01CA7 0884      SBC	R8,R4
    01CA8 0895      SBC	R9,R5
    01CA9 E040      LDI	R20,0
    01CAA E052      LDI	R21,2
    01CAB E060      LDI	R22,0
    01CAC E070      LDI	R23,0
    01CAD 929A      ST	-Y,R9
    01CAE 928A      ST	-Y,R8
    01CAF 927A      ST	-Y,R7
    01CB0 926A      ST	-Y,R6
    01CB1 018A      MOVW	R16,R20
    01CB2 019B      MOVW	R18,R22
    01CB3 940E 3F19 CALL	empy32u|empy32s
    01CB5 0198      MOVW	R18,R16
    01CB6 0D2E      ADD	R18,R14
    01CB7 1D3F      ADC	R19,R15
    01CB8 0186      MOVW	R16,R12
    01CB9 5D02      SUBI	R16,0xD2
    01CBA 4F1F      SBCI	R17,0xFF
    01CBB 940E 02E0 CALL	ff.c:mem_cpy
(2543) 					fp->fs->wflag = 0;
    01CBD 2422      CLR	R2
    01CBE 8DEB      LDD	R30,Y+27
    01CBF 8DFC      LDD	R31,Y+28
    01CC0 93AF      PUSH	R26
    01CC1 93BF      PUSH	R27
    01CC2 81A0      LD	R26,Z
    01CC3 81B1      LDD	R27,Z+1
    01CC4 01FD      MOVW	R30,R26
    01CC5 91BF      POP	R27
    01CC6 91AF      POP	R26
    01CC7 8224      STD	Z+4,R2
(2544) 				}
(2545) #else
(2546) 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
(2547) 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
(2548) 					fp->flag &= ~FA__DIRTY;
(2549) 				}
(2550) #endif
(2551) 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    01CC8 E000      LDI	R16,0
    01CC9 E012      LDI	R17,2
    01CCA 0195      MOVW	R18,R10
    01CCB 940E 3F09 CALL	empy16s
    01CCD 0168      MOVW	R12,R16
(2552) 				continue;
    01CCE C099      RJMP	0x1D68
(2553) 			}
(2554) #if _FS_TINY
(2555) 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
    01CCF 8DEB      LDD	R30,Y+27
    01CD0 8DFC      LDD	R31,Y+28
    01CD1 8422      LDD	R2,Z+10
    01CD2 8433      LDD	R3,Z+11
    01CD3 8444      LDD	R4,Z+12
    01CD4 8455      LDD	R5,Z+13
    01CD5 8066      LDD	R6,Z+6
    01CD6 8077      LDD	R7,Z+7
    01CD7 8480      LDD	R8,Z+8
    01CD8 8491      LDD	R9,Z+9
    01CD9 1462      CP	R6,R2
    01CDA 0473      CPC	R7,R3
    01CDB 0484      CPC	R8,R4
    01CDC 0495      CPC	R9,R5
    01CDD F128      BCS	0x1D03
(2556) 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    01CDE E040      LDI	R20,0
    01CDF E050      LDI	R21,0
    01CE0 E060      LDI	R22,0
    01CE1 E070      LDI	R23,0
    01CE2 8368      ST	Y,R22
    01CE3 8379      STD	Y+1,R23
    01CE4 019A      MOVW	R18,R20
    01CE5 8100      LD	R16,Z
    01CE6 8111      LDD	R17,Z+1
    01CE7 940E 0339 CALL	ff.c:move_window
    01CE9 2EA0      MOV	R10,R16
    01CEA 2300      TST	R16
    01CEB F051      BEQ	0x1CF6
    01CEC 8D8B      LDD	R24,Y+27
    01CED 8D9C      LDD	R25,Y+28
    01CEE 9604      ADIW	R24,4
    01CEF 015C      MOVW	R10,R24
    01CF0 01FC      MOVW	R30,R24
    01CF1 8180      LD	R24,Z
    01CF2 6880      ORI	R24,0x80
    01CF3 8380      ST	Z,R24
    01CF4 E001      LDI	R16,1
    01CF5 C0BE      RJMP	0x1DB4
(2557) 				fp->fs->winsect = sect;
    01CF6 802D      LDD	R2,Y+5
    01CF7 803E      LDD	R3,Y+6
    01CF8 804F      LDD	R4,Y+7
    01CF9 8458      LDD	R5,Y+8
    01CFA 8DEB      LDD	R30,Y+27
    01CFB 8DFC      LDD	R31,Y+28
    01CFC 81A0      LD	R26,Z
    01CFD 81B1      LDD	R27,Z+1
    01CFE 969A      ADIW	R26,0x2A
    01CFF 922D      ST	X+,R2
    01D00 923D      ST	X+,R3
    01D01 924D      ST	X+,R4
    01D02 925C      ST	X,R5
(2558) 			}
(2559) #else
(2560) 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
(2561) 				if (fp->fptr < fp->fsize &&
(2562) 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
(2563) 						ABORT(fp->fs, FR_DISK_ERR);
(2564) 			}
(2565) #endif
(2566) 			fp->dsect = sect;
    01D03 802D      LDD	R2,Y+5
    01D04 803E      LDD	R3,Y+6
    01D05 804F      LDD	R4,Y+7
    01D06 8458      LDD	R5,Y+8
    01D07 8DEB      LDD	R30,Y+27
    01D08 8DFC      LDD	R31,Y+28
    01D09 8A26      STD	Z+22,R2
    01D0A 8A37      STD	Z+23,R3
    01D0B 8E40      STD	Z+24,R4
    01D0C 8E51      STD	Z+25,R5
(2567) 		}
(2568) 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    01D0D EF4F      LDI	R20,0xFF
    01D0E E051      LDI	R21,1
    01D0F E060      LDI	R22,0
    01D10 E070      LDI	R23,0
    01D11 8DEB      LDD	R30,Y+27
    01D12 8DFC      LDD	R31,Y+28
    01D13 8026      LDD	R2,Z+6
    01D14 8037      LDD	R3,Z+7
    01D15 8440      LDD	R4,Z+8
    01D16 8451      LDD	R5,Z+9
    01D17 2224      AND	R2,R20
    01D18 2235      AND	R3,R21
    01D19 2246      AND	R4,R22
    01D1A 2257      AND	R5,R23
    01D1B E040      LDI	R20,0
    01D1C E052      LDI	R21,2
    01D1D E060      LDI	R22,0
    01D1E E070      LDI	R23,0
    01D1F 1942      SUB	R20,R2
    01D20 0953      SBC	R21,R3
    01D21 0964      SBC	R22,R4
    01D22 0975      SBC	R23,R5
    01D23 016A      MOVW	R12,R20
(2569) 		if (wcnt > btw) wcnt = btw;
    01D24 8C0F      LDD	R0,Y+31
    01D25 A018      LDD	R1,Y+32
    01D26 1604      CP	R0,R20
    01D27 0615      CPC	R1,R21
    01D28 F408      BCC	0x1D2A
    01D29 0160      MOVW	R12,R0
(2570) #if _FS_TINY
(2571) 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
    01D2A 8DEB      LDD	R30,Y+27
    01D2B 8DFC      LDD	R31,Y+28
    01D2C 8826      LDD	R2,Z+22
    01D2D 8837      LDD	R3,Z+23
    01D2E 8C40      LDD	R4,Z+24
    01D2F 8C51      LDD	R5,Z+25
    01D30 8248      ST	Y,R4
    01D31 8259      STD	Y+1,R5
    01D32 0191      MOVW	R18,R2
    01D33 8100      LD	R16,Z
    01D34 8111      LDD	R17,Z+1
    01D35 940E 0339 CALL	ff.c:move_window
    01D37 2EA0      MOV	R10,R16
    01D38 2300      TST	R16
    01D39 F051      BEQ	0x1D44
(2572) 			ABORT(fp->fs, FR_DISK_ERR);
    01D3A 8D8B      LDD	R24,Y+27
    01D3B 8D9C      LDD	R25,Y+28
    01D3C 9604      ADIW	R24,4
    01D3D 015C      MOVW	R10,R24
    01D3E 01FC      MOVW	R30,R24
    01D3F 8180      LD	R24,Z
    01D40 6880      ORI	R24,0x80
    01D41 8380      ST	Z,R24
    01D42 E001      LDI	R16,1
    01D43 C070      RJMP	0x1DB4
(2573) 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    01D44 82D9      STD	Y+1,R13
    01D45 82C8      ST	Y,R12
    01D46 0197      MOVW	R18,R14
    01D47 EF4F      LDI	R20,0xFF
    01D48 E051      LDI	R21,1
    01D49 E060      LDI	R22,0
    01D4A E070      LDI	R23,0
    01D4B 8DEB      LDD	R30,Y+27
    01D4C 8DFC      LDD	R31,Y+28
    01D4D 8026      LDD	R2,Z+6
    01D4E 8037      LDD	R3,Z+7
    01D4F 8440      LDD	R4,Z+8
    01D50 8451      LDD	R5,Z+9
    01D51 2224      AND	R2,R20
    01D52 2235      AND	R3,R21
    01D53 2246      AND	R4,R22
    01D54 2257      AND	R5,R23
    01D55 0181      MOVW	R16,R2
    01D56 8180      LD	R24,Z
    01D57 8191      LDD	R25,Z+1
    01D58 968E      ADIW	R24,0x2E
    01D59 0F08      ADD	R16,R24
    01D5A 1F19      ADC	R17,R25
    01D5B 940E 02E0 CALL	ff.c:mem_cpy
(2574) 		fp->fs->wflag = 1;
    01D5D E081      LDI	R24,1
    01D5E 8DEB      LDD	R30,Y+27
    01D5F 8DFC      LDD	R31,Y+28
    01D60 93AF      PUSH	R26
    01D61 93BF      PUSH	R27
    01D62 81A0      LD	R26,Z
    01D63 81B1      LDD	R27,Z+1
    01D64 01FD      MOVW	R30,R26
    01D65 91BF      POP	R27
    01D66 91AF      POP	R26
    01D67 8384      STD	Z+4,R24
    01D68 0CEC      ADD	R14,R12
    01D69 1CFD      ADC	R15,R13
    01D6A 8D8B      LDD	R24,Y+27
    01D6B 8D9C      LDD	R25,Y+28
    01D6C 9606      ADIW	R24,6
    01D6D 015C      MOVW	R10,R24
    01D6E 0116      MOVW	R2,R12
    01D6F 2444      CLR	R4
    01D70 2455      CLR	R5
    01D71 01FC      MOVW	R30,R24
    01D72 8060      LD	R6,Z
    01D73 8071      LDD	R7,Z+1
    01D74 8082      LDD	R8,Z+2
    01D75 8093      LDD	R9,Z+3
    01D76 0C62      ADD	R6,R2
    01D77 1C73      ADC	R7,R3
    01D78 1C84      ADC	R8,R4
    01D79 1C95      ADC	R9,R5
    01D7A 8260      ST	Z,R6
    01D7B 8271      STD	Z+1,R7
    01D7C 8282      STD	Z+2,R8
    01D7D 8293      STD	Z+3,R9
    01D7E A1E9      LDD	R30,Y+33
    01D7F A1FA      LDD	R31,Y+34
    01D80 8020      LD	R2,Z
    01D81 8031      LDD	R3,Z+1
    01D82 0C2C      ADD	R2,R12
    01D83 1C3D      ADC	R3,R13
    01D84 8231      STD	Z+1,R3
    01D85 8220      ST	Z,R2
    01D86 8C0F      LDD	R0,Y+31
    01D87 A018      LDD	R1,Y+32
    01D88 180C      SUB	R0,R12
    01D89 081D      SBC	R1,R13
    01D8A A218      STD	Y+32,R1
    01D8B 8E0F      STD	Y+31,R0
    01D8C 8C0F      LDD	R0,Y+31
    01D8D A018      LDD	R1,Y+32
    01D8E 2000      TST	R0
    01D8F F009      BEQ	0x1D91
    01D90 CD5B      RJMP	0x1AEC
    01D91 2011      TST	R1
    01D92 F009      BEQ	0x1D94
    01D93 CD58      RJMP	0x1AEC
(2575) #else
(2576) 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
(2577) 		fp->flag |= FA__DIRTY;
(2578) #endif
(2579) 	}
(2580) 
(2581) 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    01D94 8DEB      LDD	R30,Y+27
    01D95 8DFC      LDD	R31,Y+28
    01D96 8422      LDD	R2,Z+10
    01D97 8433      LDD	R3,Z+11
    01D98 8444      LDD	R4,Z+12
    01D99 8455      LDD	R5,Z+13
    01D9A 8066      LDD	R6,Z+6
    01D9B 8077      LDD	R7,Z+7
    01D9C 8480      LDD	R8,Z+8
    01D9D 8491      LDD	R9,Z+9
    01D9E 1426      CP	R2,R6
    01D9F 0437      CPC	R3,R7
    01DA0 0448      CPC	R4,R8
    01DA1 0459      CPC	R5,R9
    01DA2 F440      BCC	0x1DAB
    01DA3 8026      LDD	R2,Z+6
    01DA4 8037      LDD	R3,Z+7
    01DA5 8440      LDD	R4,Z+8
    01DA6 8451      LDD	R5,Z+9
    01DA7 8622      STD	Z+10,R2
    01DA8 8633      STD	Z+11,R3
    01DA9 8644      STD	Z+12,R4
    01DAA 8655      STD	Z+13,R5
(2582) 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    01DAB 8D8B      LDD	R24,Y+27
    01DAC 8D9C      LDD	R25,Y+28
    01DAD 9604      ADIW	R24,4
    01DAE 015C      MOVW	R10,R24
    01DAF 01FC      MOVW	R30,R24
    01DB0 8180      LD	R24,Z
    01DB1 6280      ORI	R24,0x20
    01DB2 8380      ST	Z,R24
(2583) 
(2584) 	LEAVE_FF(fp->fs, FR_OK);
    01DB3 2700      CLR	R16
    01DB4 9661      ADIW	R28,0x11
    01DB5 940E 3F62 CALL	pop_xgsetF0FC
    01DB7 9624      ADIW	R28,4
    01DB8 9508      RET
_f_sync:
  tim                  --> Y,+2
  dir                  --> R22
  res                  --> R10
  fp                   --> R20
    01DB9 940E 3FA8 CALL	push_xgsetF03C
    01DBB 01A8      MOVW	R20,R16
    01DBC 9726      SBIW	R28,6
(2585) }
(2586) 
(2587) 
(2588) 
(2589) 
(2590) /*-----------------------------------------------------------------------*/
(2591) /* Synchronize the File Object                                           */
(2592) /*-----------------------------------------------------------------------*/
(2593) 
(2594) FRESULT f_sync (
(2595) 	FIL *fp		/* Pointer to the file object */
(2596) )
(2597) {
(2598) 	FRESULT res;
(2599) 	DWORD tim;
(2600) 	BYTE *dir;
(2601) 
(2602) 
(2603) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01DBD 01FA      MOVW	R30,R20
    01DBE 8122      LDD	R18,Z+2
    01DBF 8133      LDD	R19,Z+3
    01DC0 8100      LD	R16,Z
    01DC1 8111      LDD	R17,Z+1
    01DC2 D88E      RCALL	ff.c:validate
    01DC3 2EA0      MOV	R10,R16
(2604) 	if (res == FR_OK) {
    01DC4 2300      TST	R16
    01DC5 F009      BEQ	0x1DC7
    01DC6 C09F      RJMP	0x1E66
(2605) 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    01DC7 01FA      MOVW	R30,R20
    01DC8 8024      LDD	R2,Z+4
    01DC9 FE25      SBRS	R2,5
    01DCA C09B      RJMP	0x1E66
(2606) #if !_FS_TINY	/* Write-back dirty buffer */
(2607) 			if (fp->flag & FA__DIRTY) {
(2608) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2609) 					LEAVE_FF(fp->fs, FR_DISK_ERR);
(2610) 				fp->flag &= ~FA__DIRTY;
(2611) 			}
(2612) #endif
(2613) 			/* Update the directory entry */
(2614) 			res = move_window(fp->fs, fp->dir_sect);
    01DCB 8C22      LDD	R2,Z+26
    01DCC 8C33      LDD	R3,Z+27
    01DCD 8C44      LDD	R4,Z+28
    01DCE 8C55      LDD	R5,Z+29
    01DCF 8248      ST	Y,R4
    01DD0 8259      STD	Y+1,R5
    01DD1 0191      MOVW	R18,R2
    01DD2 8100      LD	R16,Z
    01DD3 8111      LDD	R17,Z+1
    01DD4 940E 0339 CALL	ff.c:move_window
    01DD6 2EA0      MOV	R10,R16
(2615) 			if (res == FR_OK) {
    01DD7 2300      TST	R16
    01DD8 F009      BEQ	0x1DDA
    01DD9 C08C      RJMP	0x1E66
(2616) 				dir = fp->dir_ptr;
    01DDA 01FA      MOVW	R30,R20
    01DDB 8D66      LDD	R22,Z+30
    01DDC 8D77      LDD	R23,Z+31
(2617) 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    01DDD 01CB      MOVW	R24,R22
    01DDE 960B      ADIW	R24,0xB
    01DDF 01FC      MOVW	R30,R24
    01DE0 8180      LD	R24,Z
    01DE1 6280      ORI	R24,0x20
    01DE2 8380      ST	Z,R24
(2618) 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    01DE3 01FA      MOVW	R30,R20
    01DE4 8422      LDD	R2,Z+10
    01DE5 8433      LDD	R3,Z+11
    01DE6 8444      LDD	R4,Z+12
    01DE7 8455      LDD	R5,Z+13
    01DE8 01FB      MOVW	R30,R22
    01DE9 8E24      STD	Z+28,R2
    01DEA 01FA      MOVW	R30,R20
    01DEB 8422      LDD	R2,Z+10
    01DEC 8433      LDD	R3,Z+11
    01DED 2C23      MOV	R2,R3
    01DEE 2433      CLR	R3
    01DEF 01FB      MOVW	R30,R22
    01DF0 8E25      STD	Z+29,R2
    01DF1 01FA      MOVW	R30,R20
    01DF2 8422      LDD	R2,Z+10
    01DF3 8433      LDD	R3,Z+11
    01DF4 8444      LDD	R4,Z+12
    01DF5 8455      LDD	R5,Z+13
    01DF6 0112      MOVW	R2,R4
    01DF7 2444      CLR	R4
    01DF8 2455      CLR	R5
    01DF9 01FB      MOVW	R30,R22
    01DFA 8E26      STD	Z+30,R2
    01DFB E188      LDI	R24,0x18
    01DFC E090      LDI	R25,0
    01DFD 01FA      MOVW	R30,R20
    01DFE 8502      LDD	R16,Z+10
    01DFF 8513      LDD	R17,Z+11
    01E00 8524      LDD	R18,Z+12
    01E01 8535      LDD	R19,Z+13
    01E02 938A      ST	-Y,R24
    01E03 940E 4008 CALL	lsr32
    01E05 01FB      MOVW	R30,R22
    01E06 8F07      STD	Z+31,R16
(2619) 				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    01E07 01FA      MOVW	R30,R20
    01E08 8426      LDD	R2,Z+14
    01E09 8437      LDD	R3,Z+15
    01E0A 8840      LDD	R4,Z+16
    01E0B 8851      LDD	R5,Z+17
    01E0C 01FB      MOVW	R30,R22
    01E0D 8E22      STD	Z+26,R2
    01E0E 01FA      MOVW	R30,R20
    01E0F 8426      LDD	R2,Z+14
    01E10 8437      LDD	R3,Z+15
    01E11 2C23      MOV	R2,R3
    01E12 2433      CLR	R3
    01E13 01FB      MOVW	R30,R22
    01E14 8E23      STD	Z+27,R2
    01E15 01FA      MOVW	R30,R20
    01E16 8426      LDD	R2,Z+14
    01E17 8437      LDD	R3,Z+15
    01E18 8840      LDD	R4,Z+16
    01E19 8851      LDD	R5,Z+17
    01E1A 0112      MOVW	R2,R4
    01E1B 2444      CLR	R4
    01E1C 2455      CLR	R5
    01E1D 01FB      MOVW	R30,R22
    01E1E 8A24      STD	Z+20,R2
    01E1F 01FA      MOVW	R30,R20
    01E20 8426      LDD	R2,Z+14
    01E21 8437      LDD	R3,Z+15
    01E22 8840      LDD	R4,Z+16
    01E23 8851      LDD	R5,Z+17
    01E24 0112      MOVW	R2,R4
    01E25 2C23      MOV	R2,R3
    01E26 2433      CLR	R3
    01E27 01FB      MOVW	R30,R22
    01E28 8A25      STD	Z+21,R2
(2620) 				tim = get_fattime();						/* Update updated time */
    01E29 940E 02DB CALL	_get_fattime
    01E2B 830A      STD	Y+2,R16
    01E2C 831B      STD	Y+3,R17
    01E2D 832C      STD	Y+4,R18
    01E2E 833D      STD	Y+5,R19
(2621) 				ST_DWORD(dir+DIR_WrtTime, tim);
    01E2F 802A      LDD	R2,Y+2
    01E30 803B      LDD	R3,Y+3
    01E31 804C      LDD	R4,Y+4
    01E32 805D      LDD	R5,Y+5
    01E33 01FB      MOVW	R30,R22
    01E34 8A26      STD	Z+22,R2
    01E35 2C23      MOV	R2,R3
    01E36 2433      CLR	R3
    01E37 9677      ADIW	R30,0x17
    01E38 8220      ST	Z,R2
    01E39 802A      LDD	R2,Y+2
    01E3A 803B      LDD	R3,Y+3
    01E3B 804C      LDD	R4,Y+4
    01E3C 805D      LDD	R5,Y+5
    01E3D 0112      MOVW	R2,R4
    01E3E 2444      CLR	R4
    01E3F 2455      CLR	R5
    01E40 01FB      MOVW	R30,R22
    01E41 9678      ADIW	R30,0x18
    01E42 8220      ST	Z,R2
    01E43 E188      LDI	R24,0x18
    01E44 E090      LDI	R25,0
    01E45 810A      LDD	R16,Y+2
    01E46 811B      LDD	R17,Y+3
    01E47 812C      LDD	R18,Y+4
    01E48 813D      LDD	R19,Y+5
    01E49 938A      ST	-Y,R24
    01E4A 940E 4008 CALL	lsr32
    01E4C 01FB      MOVW	R30,R22
    01E4D 8F01      STD	Z+25,R16
(2622) 				fp->flag &= ~FA__WRITTEN;
    01E4E 01BA      MOVW	R22,R20
    01E4F 5F6C      SUBI	R22,0xFC
    01E50 4F7F      SBCI	R23,0xFF
    01E51 01FB      MOVW	R30,R22
    01E52 8180      LD	R24,Z
    01E53 7D8F      ANDI	R24,0xDF
    01E54 8380      ST	Z,R24
(2623) 				fp->fs->wflag = 1;
    01E55 E081      LDI	R24,1
    01E56 01FA      MOVW	R30,R20
    01E57 93AF      PUSH	R26
    01E58 93BF      PUSH	R27
    01E59 81A0      LD	R26,Z
    01E5A 81B1      LDD	R27,Z+1
    01E5B 01FD      MOVW	R30,R26
    01E5C 91BF      POP	R27
    01E5D 91AF      POP	R26
    01E5E 8384      STD	Z+4,R24
(2624) 				res = sync(fp->fs);
    01E5F 01FA      MOVW	R30,R20
    01E60 8100      LD	R16,Z
    01E61 8111      LDD	R17,Z+1
    01E62 940E 03DB CALL	ff.c:sync
    01E64 2EC0      MOV	R12,R16
    01E65 2CAC      MOV	R10,R12
(2625) 			}
(2626) 		}
(2627) 	}
(2628) 
(2629) 	LEAVE_FF(fp->fs, res);
    01E66 2D0A      MOV	R16,R10
    01E67 9626      ADIW	R28,6
    01E68 940C 3FB1 JMP	pop_xgsetF03C
_f_close:
  res                  --> R10
  fp                   --> R12
    01E6A 940E 3F73 CALL	push_xgset003C
    01E6C 0168      MOVW	R12,R16
(2630) }
(2631) 
(2632) #endif /* !_FS_READONLY */
(2633) 
(2634) 
(2635) 
(2636) 
(2637) /*-----------------------------------------------------------------------*/
(2638) /* Close File                                                            */
(2639) /*-----------------------------------------------------------------------*/
(2640) 
(2641) FRESULT f_close (
(2642) 	FIL *fp		/* Pointer to the file object to be closed */
(2643) )
(2644) {
(2645) 	FRESULT res;
(2646) 
(2647) #if _FS_READONLY
(2648) 	FATFS *fs = fp->fs;
(2649) 	res = validate(fs, fp->id);
(2650) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
(2651) 	LEAVE_FF(fs, res);
(2652) 
(2653) #else
(2654) 	res = f_sync(fp);		/* Flush cached data */
    01E6D 0186      MOVW	R16,R12
    01E6E DF4A      RCALL	_f_sync
    01E6F 2EA0      MOV	R10,R16
(2655) #if _FS_SHARE
(2656) 	if (res == FR_OK) {		/* Decrement open counter */
(2657) #if _FS_REENTRANT
(2658) 		res = validate(fp->fs, fp->id);
(2659) 		if (res == FR_OK) {
(2660) 			res = dec_lock(fp->lockid);	
(2661) 			unlock_fs(fp->fs, FR_OK);
(2662) 		}
(2663) #else
(2664) 		res = dec_lock(fp->lockid);
(2665) #endif
(2666) 	}
(2667) #endif
(2668) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    01E70 2300      TST	R16
    01E71 F429      BNE	0x1E77
    01E72 2422      CLR	R2
    01E73 2433      CLR	R3
    01E74 01F6      MOVW	R30,R12
    01E75 8231      STD	Z+1,R3
    01E76 8220      ST	Z,R2
(2669) 	return res;
    01E77 2D0A      MOV	R16,R10
    01E78 940C 3F4D JMP	pop_xgset003C
_f_lseek:
  ifptr                --> Y,+14
  nsect                --> Y,+10
  bcs                  --> Y,+6
  clst                 --> Y,+2
  dsc                  --> Y,+26
  tlen                 --> Y,+22
  tbl                  --> R14
  tcl                  --> Y,+18
  ulen                 --> Y,+14
  ncl                  --> Y,+10
  pcl                  --> Y,+6
  cl                   --> Y,+2
  res                  --> R10
  ofs                  --> Y,+42
  fp                   --> Y,+40
    01E7A 940E 3E28 CALL	push_arg4
    01E7C 940E 3F6D CALL	push_xgsetF0FC
    01E7E 976E      SBIW	R28,0x1E
(2670) #endif
(2671) }
(2672) 
(2673) 
(2674) 
(2675) 
(2676) /*-----------------------------------------------------------------------*/
(2677) /* Current Drive/Directory Handlings                                     */
(2678) /*-----------------------------------------------------------------------*/
(2679) 
(2680) #if _FS_RPATH >= 1
(2681) 
(2682) FRESULT f_chdrive (
(2683) 	BYTE drv		/* Drive number */
(2684) )
(2685) {
(2686) 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
(2687) 
(2688) 	CurrVol = drv;
(2689) 
(2690) 	return FR_OK;
(2691) }
(2692) 
(2693) 
(2694) 
(2695) FRESULT f_chdir (
(2696) 	const TCHAR *path	/* Pointer to the directory path */
(2697) )
(2698) {
(2699) 	FRESULT res;
(2700) 	DIR dj;
(2701) 	DEF_NAMEBUF;
(2702) 
(2703) 
(2704) 	res = chk_mounted(&path, &dj.fs, 0);
(2705) 	if (res == FR_OK) {
(2706) 		INIT_BUF(dj);
(2707) 		res = follow_path(&dj, path);		/* Follow the path */
(2708) 		FREE_BUF();
(2709) 		if (res == FR_OK) {					/* Follow completed */
(2710) 			if (!dj.dir) {
(2711) 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
(2712) 			} else {
(2713) 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
(2714) 					dj.fs->cdir = LD_CLUST(dj.dir);
(2715) 				else
(2716) 					res = FR_NO_PATH;		/* Reached but a file */
(2717) 			}
(2718) 		}
(2719) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
(2720) 	}
(2721) 
(2722) 	LEAVE_FF(dj.fs, res);
(2723) }
(2724) 
(2725) 
(2726) #if _FS_RPATH >= 2
(2727) FRESULT f_getcwd (
(2728) 	TCHAR *path,	/* Pointer to the directory path */
(2729) 	UINT sz_path	/* Size of path */
(2730) )
(2731) {
(2732) 	FRESULT res;
(2733) 	DIR dj;
(2734) 	UINT i, n;
(2735) 	DWORD ccl;
(2736) 	TCHAR *tp;
(2737) 	FILINFO fno;
(2738) 	DEF_NAMEBUF;
(2739) 
(2740) 
(2741) 	*path = 0;
(2742) 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
(2743) 	if (res == FR_OK) {
(2744) 		INIT_BUF(dj);
(2745) 		i = sz_path;		/* Bottom of buffer (dir stack base) */
(2746) 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
(2747) 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
(2748) 			res = dir_sdi(&dj, 1);			/* Get parent dir */
(2749) 			if (res != FR_OK) break;
(2750) 			res = dir_read(&dj);
(2751) 			if (res != FR_OK) break;
(2752) 			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
(2753) 			res = dir_sdi(&dj, 0);
(2754) 			if (res != FR_OK) break;
(2755) 			do {							/* Find the entry links to the child dir */
(2756) 				res = dir_read(&dj);
(2757) 				if (res != FR_OK) break;
(2758) 				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
(2759) 				res = dir_next(&dj, 0);	
(2760) 			} while (res == FR_OK);
(2761) 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
(2762) 			if (res != FR_OK) break;
(2763) #if _USE_LFN
(2764) 			fno.lfname = path;
(2765) 			fno.lfsize = i;
(2766) #endif
(2767) 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
(2768) 			tp = fno.fname;
(2769) 			if (_USE_LFN && *path) tp = path;
(2770) 			for (n = 0; tp[n]; n++) ;
(2771) 			if (i < n + 3) {
(2772) 				res = FR_NOT_ENOUGH_CORE; break;
(2773) 			}
(2774) 			while (n) path[--i] = tp[--n];
(2775) 			path[--i] = '/';
(2776) 		}
(2777) 		tp = path;
(2778) 		if (res == FR_OK) {
(2779) 			*tp++ = '0' + CurrVol;			/* Put drive number */
(2780) 			*tp++ = ':';
(2781) 			if (i == sz_path) {				/* Root-dir */
(2782) 				*tp++ = '/';
(2783) 			} else {						/* Sub-dir */
(2784) 				do		/* Add stacked path str */
(2785) 					*tp++ = path[i++];
(2786) 				while (i < sz_path);
(2787) 			}
(2788) 		}
(2789) 		*tp = 0;
(2790) 		FREE_BUF();
(2791) 	}
(2792) 
(2793) 	LEAVE_FF(dj.fs, res);
(2794) }
(2795) #endif /* _FS_RPATH >= 2 */
(2796) #endif /* _FS_RPATH >= 1 */
(2797) 
(2798) 
(2799) 
(2800) #if _FS_MINIMIZE <= 2
(2801) /*-----------------------------------------------------------------------*/
(2802) /* Seek File R/W Pointer                                                 */
(2803) /*-----------------------------------------------------------------------*/
(2804) 
(2805) FRESULT f_lseek (
(2806) 	FIL *fp,		/* Pointer to the file object */
(2807) 	DWORD ofs		/* File pointer from top of file */
(2808) )
(2809) {
(2810) 	FRESULT res;
(2811) 
(2812) 
(2813) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01E7F A5E8      LDD	R30,Y+40
    01E80 A5F9      LDD	R31,Y+41
    01E81 8122      LDD	R18,Z+2
    01E82 8133      LDD	R19,Z+3
    01E83 8100      LD	R16,Z
    01E84 8111      LDD	R17,Z+1
    01E85 940E 1651 CALL	ff.c:validate
    01E87 2EA0      MOV	R10,R16
(2814) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01E88 2300      TST	R16
    01E89 F009      BEQ	0x1E8B
    01E8A C4A7      RJMP	0x2332
(2815) 	if (fp->flag & FA__ERROR)			/* Check abort flag */
    01E8B A5E8      LDD	R30,Y+40
    01E8C A5F9      LDD	R31,Y+41
    01E8D 8024      LDD	R2,Z+4
    01E8E FE27      SBRS	R2,7
    01E8F C002      RJMP	0x1E92
(2816) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01E90 E002      LDI	R16,2
    01E91 C4A0      RJMP	0x2332
(2817) 
(2818) #if _USE_FASTSEEK
(2819) 	if (fp->cltbl) {	/* Fast seek */
    01E92 A5E8      LDD	R30,Y+40
    01E93 A5F9      LDD	R31,Y+41
    01E94 96B0      ADIW	R30,0x20
    01E95 8020      LD	R2,Z
    01E96 8031      LDD	R3,Z+1
    01E97 2022      TST	R2
    01E98 F419      BNE	0x1E9C
    01E99 2033      TST	R3
    01E9A F409      BNE	0x1E9C
    01E9B C1E3      RJMP	0x207F
(2820) 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
(2821) 
(2822) 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
    01E9C EF4F      LDI	R20,0xFF
    01E9D EF5F      LDI	R21,0xFF
    01E9E EF6F      LDI	R22,0xFF
    01E9F EF7F      LDI	R23,0xFF
    01EA0 A42A      LDD	R2,Y+42
    01EA1 A43B      LDD	R3,Y+43
    01EA2 A44C      LDD	R4,Y+44
    01EA3 A45D      LDD	R5,Y+45
    01EA4 1624      CP	R2,R20
    01EA5 0635      CPC	R3,R21
    01EA6 0646      CPC	R4,R22
    01EA7 0657      CPC	R5,R23
    01EA8 F009      BEQ	0x1EAA
    01EA9 C109      RJMP	0x1FB3
(2823) 			tbl = fp->cltbl;
    01EAA A5E8      LDD	R30,Y+40
    01EAB A5F9      LDD	R31,Y+41
    01EAC A0E0      LDD	R14,Z+32
    01EAD A0F1      LDD	R15,Z+33
(2824) 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
    01EAE 01F7      MOVW	R30,R14
    01EAF 9021      LD	R2,Z+
    01EB0 9031      LD	R3,Z+
    01EB1 9041      LD	R4,Z+
    01EB2 9051      LD	R5,Z+
    01EB3 017F      MOVW	R14,R30
    01EB4 8A2E      STD	Y+22,R2
    01EB5 8A3F      STD	Y+23,R3
    01EB6 8E48      STD	Y+24,R4
    01EB7 8E59      STD	Y+25,R5
    01EB8 E082      LDI	R24,2
    01EB9 878E      STD	Y+14,R24
    01EBA E080      LDI	R24,0
    01EBB 878F      STD	Y+15,R24
    01EBC 8B88      STD	Y+16,R24
    01EBD 8B89      STD	Y+17,R24
(2825) 			cl = fp->sclust;			/* Top of the chain */
    01EBE A5E8      LDD	R30,Y+40
    01EBF A5F9      LDD	R31,Y+41
    01EC0 963E      ADIW	R30,0xE
    01EC1 8020      LD	R2,Z
    01EC2 8031      LDD	R3,Z+1
    01EC3 8042      LDD	R4,Z+2
    01EC4 8053      LDD	R5,Z+3
    01EC5 822A      STD	Y+2,R2
    01EC6 823B      STD	Y+3,R3
    01EC7 824C      STD	Y+4,R4
    01EC8 825D      STD	Y+5,R5
(2826) 			if (cl) {
    01EC9 802A      LDD	R2,Y+2
    01ECA 803B      LDD	R3,Y+3
    01ECB 804C      LDD	R4,Y+4
    01ECC 805D      LDD	R5,Y+5
    01ECD 9488      BCLR	0
    01ECE 2022      TST	R2
    01ECF 0432      CPC	R3,R2
    01ED0 0442      CPC	R4,R2
    01ED1 0452      CPC	R5,R2
    01ED2 F409      BNE	0x1ED4
    01ED3 C0BB      RJMP	0x1F8F
(2827) 				do {
(2828) 					/* Get a fragment */
(2829) 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
    01ED4 802A      LDD	R2,Y+2
    01ED5 803B      LDD	R3,Y+3
    01ED6 804C      LDD	R4,Y+4
    01ED7 805D      LDD	R5,Y+5
    01ED8 8A2A      STD	Y+18,R2
    01ED9 8A3B      STD	Y+19,R3
    01EDA 8A4C      STD	Y+20,R4
    01EDB 8A5D      STD	Y+21,R5
    01EDC E080      LDI	R24,0
    01EDD 878A      STD	Y+10,R24
    01EDE 878B      STD	Y+11,R24
    01EDF 878C      STD	Y+12,R24
    01EE0 878D      STD	Y+13,R24
    01EE1 E042      LDI	R20,2
    01EE2 E050      LDI	R21,0
    01EE3 E060      LDI	R22,0
    01EE4 E070      LDI	R23,0
    01EE5 842E      LDD	R2,Y+14
    01EE6 843F      LDD	R3,Y+15
    01EE7 8848      LDD	R4,Y+16
    01EE8 8859      LDD	R5,Y+17
    01EE9 0E24      ADD	R2,R20
    01EEA 1E35      ADC	R3,R21
    01EEB 1E46      ADC	R4,R22
    01EEC 1E57      ADC	R5,R23
    01EED 862E      STD	Y+14,R2
    01EEE 863F      STD	Y+15,R3
    01EEF 8A48      STD	Y+16,R4
    01EF0 8A59      STD	Y+17,R5
(2830) 					do {
(2831) 						pcl = cl; ncl++;
    01EF1 802A      LDD	R2,Y+2
    01EF2 803B      LDD	R3,Y+3
    01EF3 804C      LDD	R4,Y+4
    01EF4 805D      LDD	R5,Y+5
    01EF5 822E      STD	Y+6,R2
    01EF6 823F      STD	Y+7,R3
    01EF7 8648      STD	Y+8,R4
    01EF8 8659      STD	Y+9,R5
    01EF9 E041      LDI	R20,1
    01EFA E050      LDI	R21,0
    01EFB E060      LDI	R22,0
    01EFC E070      LDI	R23,0
    01EFD 842A      LDD	R2,Y+10
    01EFE 843B      LDD	R3,Y+11
    01EFF 844C      LDD	R4,Y+12
    01F00 845D      LDD	R5,Y+13
    01F01 0E24      ADD	R2,R20
    01F02 1E35      ADC	R3,R21
    01F03 1E46      ADC	R4,R22
    01F04 1E57      ADC	R5,R23
    01F05 862A      STD	Y+10,R2
    01F06 863B      STD	Y+11,R3
    01F07 864C      STD	Y+12,R4
    01F08 865D      STD	Y+13,R5
(2832) 						cl = get_fat(fp->fs, cl);
    01F09 802A      LDD	R2,Y+2
    01F0A 803B      LDD	R3,Y+3
    01F0B 804C      LDD	R4,Y+4
    01F0C 805D      LDD	R5,Y+5
    01F0D 8248      ST	Y,R4
    01F0E 8259      STD	Y+1,R5
    01F0F 0191      MOVW	R18,R2
    01F10 A5E8      LDD	R30,Y+40
    01F11 A5F9      LDD	R31,Y+41
    01F12 8100      LD	R16,Z
    01F13 8111      LDD	R17,Z+1
    01F14 940E 0502 CALL	_get_fat
    01F16 830A      STD	Y+2,R16
    01F17 831B      STD	Y+3,R17
    01F18 832C      STD	Y+4,R18
    01F19 833D      STD	Y+5,R19
(2833) 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
    01F1A E041      LDI	R20,1
    01F1B E050      LDI	R21,0
    01F1C E060      LDI	R22,0
    01F1D E070      LDI	R23,0
    01F1E 802A      LDD	R2,Y+2
    01F1F 803B      LDD	R3,Y+3
    01F20 804C      LDD	R4,Y+4
    01F21 805D      LDD	R5,Y+5
    01F22 1542      CP	R20,R2
    01F23 0553      CPC	R21,R3
    01F24 0564      CPC	R22,R4
    01F25 0575      CPC	R23,R5
    01F26 F048      BCS	0x1F30
    01F27 A588      LDD	R24,Y+40
    01F28 A599      LDD	R25,Y+41
    01F29 9604      ADIW	R24,4
    01F2A 01FC      MOVW	R30,R24
    01F2B 8180      LD	R24,Z
    01F2C 6880      ORI	R24,0x80
    01F2D 8380      ST	Z,R24
    01F2E E002      LDI	R16,2
    01F2F C402      RJMP	0x2332
(2834) 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01F30 EF4F      LDI	R20,0xFF
    01F31 EF5F      LDI	R21,0xFF
    01F32 EF6F      LDI	R22,0xFF
    01F33 EF7F      LDI	R23,0xFF
    01F34 802A      LDD	R2,Y+2
    01F35 803B      LDD	R3,Y+3
    01F36 804C      LDD	R4,Y+4
    01F37 805D      LDD	R5,Y+5
    01F38 1624      CP	R2,R20
    01F39 0635      CPC	R3,R21
    01F3A 0646      CPC	R4,R22
    01F3B 0657      CPC	R5,R23
    01F3C F451      BNE	0x1F47
    01F3D A588      LDD	R24,Y+40
    01F3E A599      LDD	R25,Y+41
    01F3F 9604      ADIW	R24,4
    01F40 016C      MOVW	R12,R24
    01F41 01FC      MOVW	R30,R24
    01F42 8180      LD	R24,Z
    01F43 6880      ORI	R24,0x80
    01F44 8380      ST	Z,R24
    01F45 E001      LDI	R16,1
    01F46 C3EB      RJMP	0x2332
(2835) 					} while (cl == pcl + 1);
    01F47 E041      LDI	R20,1
    01F48 E050      LDI	R21,0
    01F49 E060      LDI	R22,0
    01F4A E070      LDI	R23,0
    01F4B 802E      LDD	R2,Y+6
    01F4C 803F      LDD	R3,Y+7
    01F4D 8448      LDD	R4,Y+8
    01F4E 8459      LDD	R5,Y+9
    01F4F 0E24      ADD	R2,R20
    01F50 1E35      ADC	R3,R21
    01F51 1E46      ADC	R4,R22
    01F52 1E57      ADC	R5,R23
    01F53 806A      LDD	R6,Y+2
    01F54 807B      LDD	R7,Y+3
    01F55 808C      LDD	R8,Y+4
    01F56 809D      LDD	R9,Y+5
    01F57 1462      CP	R6,R2
    01F58 0473      CPC	R7,R3
    01F59 0484      CPC	R8,R4
    01F5A 0495      CPC	R9,R5
    01F5B F409      BNE	0x1F5D
    01F5C CF94      RJMP	0x1EF1
(2836) 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
    01F5D 882E      LDD	R2,Y+22
    01F5E 883F      LDD	R3,Y+23
    01F5F 8C48      LDD	R4,Y+24
    01F60 8C59      LDD	R5,Y+25
    01F61 846E      LDD	R6,Y+14
    01F62 847F      LDD	R7,Y+15
    01F63 8888      LDD	R8,Y+16
    01F64 8899      LDD	R9,Y+17
    01F65 1426      CP	R2,R6
    01F66 0437      CPC	R3,R7
    01F67 0448      CPC	R4,R8
    01F68 0459      CPC	R5,R9
    01F69 F090      BCS	0x1F7C
(2837) 						*tbl++ = ncl; *tbl++ = tcl;
    01F6A 842A      LDD	R2,Y+10
    01F6B 843B      LDD	R3,Y+11
    01F6C 844C      LDD	R4,Y+12
    01F6D 845D      LDD	R5,Y+13
    01F6E 01F7      MOVW	R30,R14
    01F6F 9221      ST	Z+,R2
    01F70 9231      ST	Z+,R3
    01F71 9241      ST	Z+,R4
    01F72 9251      ST	Z+,R5
    01F73 882A      LDD	R2,Y+18
    01F74 883B      LDD	R3,Y+19
    01F75 884C      LDD	R4,Y+20
    01F76 885D      LDD	R5,Y+21
    01F77 9221      ST	Z+,R2
    01F78 9231      ST	Z+,R3
    01F79 9241      ST	Z+,R4
    01F7A 9251      ST	Z+,R5
    01F7B 017F      MOVW	R14,R30
(2838) 					}
(2839) 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
    01F7C A5E8      LDD	R30,Y+40
    01F7D A5F9      LDD	R31,Y+41
    01F7E 81A0      LD	R26,Z
    01F7F 81B1      LDD	R27,Z+1
    01F80 9656      ADIW	R26,0x16
    01F81 902D      LD	R2,X+
    01F82 903D      LD	R3,X+
    01F83 904D      LD	R4,X+
    01F84 905C      LD	R5,X
    01F85 806A      LDD	R6,Y+2
    01F86 807B      LDD	R7,Y+3
    01F87 808C      LDD	R8,Y+4
    01F88 809D      LDD	R9,Y+5
    01F89 1462      CP	R6,R2
    01F8A 0473      CPC	R7,R3
    01F8B 0484      CPC	R8,R4
    01F8C 0495      CPC	R9,R5
    01F8D F408      BCC	0x1F8F
    01F8E CF45      RJMP	0x1ED4
(2840) 			}
(2841) 			*fp->cltbl = ulen;	/* Number of items used */
    01F8F 842E      LDD	R2,Y+14
    01F90 843F      LDD	R3,Y+15
    01F91 8848      LDD	R4,Y+16
    01F92 8859      LDD	R5,Y+17
    01F93 A5E8      LDD	R30,Y+40
    01F94 A5F9      LDD	R31,Y+41
    01F95 96B0      ADIW	R30,0x20
    01F96 81A0      LD	R26,Z
    01F97 81B1      LDD	R27,Z+1
    01F98 922D      ST	X+,R2
    01F99 923D      ST	X+,R3
    01F9A 924D      ST	X+,R4
    01F9B 925C      ST	X,R5
(2842) 			if (ulen <= tlen)
    01F9C 882E      LDD	R2,Y+22
    01F9D 883F      LDD	R3,Y+23
    01F9E 8C48      LDD	R4,Y+24
    01F9F 8C59      LDD	R5,Y+25
    01FA0 846E      LDD	R6,Y+14
    01FA1 847F      LDD	R7,Y+15
    01FA2 8888      LDD	R8,Y+16
    01FA3 8899      LDD	R9,Y+17
    01FA4 1426      CP	R2,R6
    01FA5 0437      CPC	R3,R7
    01FA6 0448      CPC	R4,R8
    01FA7 0459      CPC	R5,R9
    01FA8 F038      BCS	0x1FB0
(2843) 				*tbl = 0;		/* Terminate table */
    01FA9 01F7      MOVW	R30,R14
    01FAA E080      LDI	R24,0
    01FAB 8380      ST	Z,R24
    01FAC 8381      STD	Z+1,R24
    01FAD 8382      STD	Z+2,R24
    01FAE 8383      STD	Z+3,R24
    01FAF C381      RJMP	0x2331
(2844) 			else
(2845) 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
    01FB0 E181      LDI	R24,0x11
    01FB1 2EA8      MOV	R10,R24
(2846) 
(2847) 		} else {						/* Fast seek */
    01FB2 C37E      RJMP	0x2331
(2848) 			if (ofs > fp->fsize)		/* Clip offset at the file size */
    01FB3 A5E8      LDD	R30,Y+40
    01FB4 A5F9      LDD	R31,Y+41
    01FB5 963A      ADIW	R30,0xA
    01FB6 8020      LD	R2,Z
    01FB7 8031      LDD	R3,Z+1
    01FB8 8042      LDD	R4,Z+2
    01FB9 8053      LDD	R5,Z+3
    01FBA A46A      LDD	R6,Y+42
    01FBB A47B      LDD	R7,Y+43
    01FBC A48C      LDD	R8,Y+44
    01FBD A49D      LDD	R9,Y+45
    01FBE 1426      CP	R2,R6
    01FBF 0437      CPC	R3,R7
    01FC0 0448      CPC	R4,R8
    01FC1 0459      CPC	R5,R9
    01FC2 F458      BCC	0x1FCE
(2849) 				ofs = fp->fsize;
    01FC3 A5E8      LDD	R30,Y+40
    01FC4 A5F9      LDD	R31,Y+41
    01FC5 963A      ADIW	R30,0xA
    01FC6 8020      LD	R2,Z
    01FC7 8031      LDD	R3,Z+1
    01FC8 8042      LDD	R4,Z+2
    01FC9 8053      LDD	R5,Z+3
    01FCA A62A      STD	Y+42,R2
    01FCB A63B      STD	Y+43,R3
    01FCC A64C      STD	Y+44,R4
    01FCD A65D      STD	Y+45,R5
(2850) 			fp->fptr = ofs;				/* Set file pointer */
    01FCE A42A      LDD	R2,Y+42
    01FCF A43B      LDD	R3,Y+43
    01FD0 A44C      LDD	R4,Y+44
    01FD1 A45D      LDD	R5,Y+45
    01FD2 A5E8      LDD	R30,Y+40
    01FD3 A5F9      LDD	R31,Y+41
    01FD4 9636      ADIW	R30,6
    01FD5 8220      ST	Z,R2
    01FD6 8231      STD	Z+1,R3
    01FD7 8242      STD	Z+2,R4
    01FD8 8253      STD	Z+3,R5
(2851) 			if (ofs) {
    01FD9 9488      BCLR	0
    01FDA 2022      TST	R2
    01FDB 0432      CPC	R3,R2
    01FDC 0442      CPC	R4,R2
    01FDD 0452      CPC	R5,R2
    01FDE F409      BNE	0x1FE0
    01FDF C351      RJMP	0x2331
(2852) 				fp->clust = clmt_clust(fp, ofs - 1);
    01FE0 E041      LDI	R20,1
    01FE1 E050      LDI	R21,0
    01FE2 E060      LDI	R22,0
    01FE3 E070      LDI	R23,0
    01FE4 1A24      SUB	R2,R20
    01FE5 0A35      SBC	R3,R21
    01FE6 0A46      SBC	R4,R22
    01FE7 0A57      SBC	R5,R23
    01FE8 8248      ST	Y,R4
    01FE9 8259      STD	Y+1,R5
    01FEA 0191      MOVW	R18,R2
    01FEB A508      LDD	R16,Y+40
    01FEC A519      LDD	R17,Y+41
    01FED 940E 0A3C CALL	ff.c:clmt_clust
    01FEF A5E8      LDD	R30,Y+40
    01FF0 A5F9      LDD	R31,Y+41
    01FF1 8B02      STD	Z+18,R16
    01FF2 8B13      STD	Z+19,R17
    01FF3 8B24      STD	Z+20,R18
    01FF4 8B35      STD	Z+21,R19
(2853) 				dsc = clust2sect(fp->fs, fp->clust);
    01FF5 8822      LDD	R2,Z+18
    01FF6 8833      LDD	R3,Z+19
    01FF7 8844      LDD	R4,Z+20
    01FF8 8855      LDD	R5,Z+21
    01FF9 8248      ST	Y,R4
    01FFA 8259      STD	Y+1,R5
    01FFB 0191      MOVW	R18,R2
    01FFC 8100      LD	R16,Z
    01FFD 8111      LDD	R17,Z+1
    01FFE 940E 04B0 CALL	_clust2sect
    02000 8F0A      STD	Y+26,R16
    02001 8F1B      STD	Y+27,R17
    02002 8F2C      STD	Y+28,R18
    02003 8F3D      STD	Y+29,R19
(2854) 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
    02004 8C2A      LDD	R2,Y+26
    02005 8C3B      LDD	R3,Y+27
    02006 8C4C      LDD	R4,Y+28
    02007 8C5D      LDD	R5,Y+29
    02008 9488      BCLR	0
    02009 2022      TST	R2
    0200A 0432      CPC	R3,R2
    0200B 0442      CPC	R4,R2
    0200C 0452      CPC	R5,R2
    0200D F451      BNE	0x2018
    0200E A588      LDD	R24,Y+40
    0200F A599      LDD	R25,Y+41
    02010 9604      ADIW	R24,4
    02011 017C      MOVW	R14,R24
    02012 01FC      MOVW	R30,R24
    02013 8180      LD	R24,Z
    02014 6880      ORI	R24,0x80
    02015 8380      ST	Z,R24
    02016 E002      LDI	R16,2
    02017 C31A      RJMP	0x2332
(2855) 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
    02018 E041      LDI	R20,1
    02019 E050      LDI	R21,0
    0201A E060      LDI	R22,0
    0201B E070      LDI	R23,0
    0201C A50A      LDD	R16,Y+42
    0201D A51B      LDD	R17,Y+43
    0201E A52C      LDD	R18,Y+44
    0201F A53D      LDD	R19,Y+45
    02020 1B04      SUB	R16,R20
    02021 0B15      SBC	R17,R21
    02022 0B26      SBC	R18,R22
    02023 0B37      SBC	R19,R23
    02024 E089      LDI	R24,0x9
    02025 E090      LDI	R25,0
    02026 938A      ST	-Y,R24
    02027 940E 4008 CALL	lsr32
    02029 0118      MOVW	R2,R16
    0202A 0129      MOVW	R4,R18
    0202B A5E8      LDD	R30,Y+40
    0202C A5F9      LDD	R31,Y+41
    0202D 93AF      PUSH	R26
    0202E 93BF      PUSH	R27
    0202F 81A0      LD	R26,Z
    02030 81B1      LDD	R27,Z+1
    02031 01FD      MOVW	R30,R26
    02032 91BF      POP	R27
    02033 91AF      POP	R26
    02034 9632      ADIW	R30,2
    02035 8180      LD	R24,Z
    02036 2799      CLR	R25
    02037 9701      SBIW	R24,1
    02038 013C      MOVW	R6,R24
    02039 2488      CLR	R8
    0203A FC77      SBRC	R7,7
    0203B 9480      COM	R8
    0203C 2499      CLR	R9
    0203D FC87      SBRC	R8,7
    0203E 9490      COM	R9
    0203F 2026      AND	R2,R6
    02040 2037      AND	R3,R7
    02041 2048      AND	R4,R8
    02042 2059      AND	R5,R9
    02043 8C6A      LDD	R6,Y+26
    02044 8C7B      LDD	R7,Y+27
    02045 8C8C      LDD	R8,Y+28
    02046 8C9D      LDD	R9,Y+29
    02047 0C62      ADD	R6,R2
    02048 1C73      ADC	R7,R3
    02049 1C84      ADC	R8,R4
    0204A 1C95      ADC	R9,R5
    0204B 8E6A      STD	Y+26,R6
    0204C 8E7B      STD	Y+27,R7
    0204D 8E8C      STD	Y+28,R8
    0204E 8E9D      STD	Y+29,R9
(2856) 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
    0204F EF4F      LDI	R20,0xFF
    02050 E051      LDI	R21,1
    02051 E060      LDI	R22,0
    02052 E070      LDI	R23,0
    02053 A5E8      LDD	R30,Y+40
    02054 A5F9      LDD	R31,Y+41
    02055 9636      ADIW	R30,6
    02056 8020      LD	R2,Z
    02057 8031      LDD	R3,Z+1
    02058 8042      LDD	R4,Z+2
    02059 8053      LDD	R5,Z+3
    0205A 2224      AND	R2,R20
    0205B 2235      AND	R3,R21
    0205C 2246      AND	R4,R22
    0205D 2257      AND	R5,R23
    0205E 9488      BCLR	0
    0205F 2022      TST	R2
    02060 0432      CPC	R3,R2
    02061 0442      CPC	R4,R2
    02062 0452      CPC	R5,R2
    02063 F409      BNE	0x2065
    02064 C2CC      RJMP	0x2331
    02065 A5E8      LDD	R30,Y+40
    02066 A5F9      LDD	R31,Y+41
    02067 9676      ADIW	R30,0x16
    02068 8020      LD	R2,Z
    02069 8031      LDD	R3,Z+1
    0206A 8042      LDD	R4,Z+2
    0206B 8053      LDD	R5,Z+3
    0206C 8C6A      LDD	R6,Y+26
    0206D 8C7B      LDD	R7,Y+27
    0206E 8C8C      LDD	R8,Y+28
    0206F 8C9D      LDD	R9,Y+29
    02070 1462      CP	R6,R2
    02071 0473      CPC	R7,R3
    02072 0484      CPC	R8,R4
    02073 0495      CPC	R9,R5
    02074 F409      BNE	0x2076
    02075 C2BB      RJMP	0x2331
(2857) #if !_FS_TINY
(2858) #if !_FS_READONLY
(2859) 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2860) 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2861) 							ABORT(fp->fs, FR_DISK_ERR);
(2862) 						fp->flag &= ~FA__DIRTY;
(2863) 					}
(2864) #endif
(2865) 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
(2866) 						ABORT(fp->fs, FR_DISK_ERR);
(2867) #endif
(2868) 					fp->dsect = dsc;
    02076 0113      MOVW	R2,R6
    02077 0124      MOVW	R4,R8
    02078 A5E8      LDD	R30,Y+40
    02079 A5F9      LDD	R31,Y+41
    0207A 8A26      STD	Z+22,R2
    0207B 8A37      STD	Z+23,R3
    0207C 8E40      STD	Z+24,R4
    0207D 8E51      STD	Z+25,R5
(2869) 				}
(2870) 			}
(2871) 		}
(2872) 	} else
    0207E C2B2      RJMP	0x2331
(2873) #endif
(2874) 
(2875) 	/* Normal Seek */
(2876) 	{
(2877) 		DWORD clst, bcs, nsect, ifptr;
(2878) 
(2879) 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    0207F A5E8      LDD	R30,Y+40
    02080 A5F9      LDD	R31,Y+41
    02081 963A      ADIW	R30,0xA
    02082 8020      LD	R2,Z
    02083 8031      LDD	R3,Z+1
    02084 8042      LDD	R4,Z+2
    02085 8053      LDD	R5,Z+3
    02086 A46A      LDD	R6,Y+42
    02087 A47B      LDD	R7,Y+43
    02088 A48C      LDD	R8,Y+44
    02089 A49D      LDD	R9,Y+45
    0208A 1426      CP	R2,R6
    0208B 0437      CPC	R3,R7
    0208C 0448      CPC	R4,R8
    0208D 0459      CPC	R5,R9
    0208E F470      BCC	0x209D
    0208F A5E8      LDD	R30,Y+40
    02090 A5F9      LDD	R31,Y+41
    02091 8024      LDD	R2,Z+4
    02092 FC21      SBRC	R2,1
    02093 C009      RJMP	0x209D
(2880) #if !_FS_READONLY
(2881) 			 && !(fp->flag & FA_WRITE)
(2882) #endif
(2883) 			) ofs = fp->fsize;
    02094 963A      ADIW	R30,0xA
    02095 8020      LD	R2,Z
    02096 8031      LDD	R3,Z+1
    02097 8042      LDD	R4,Z+2
    02098 8053      LDD	R5,Z+3
    02099 A62A      STD	Y+42,R2
    0209A A63B      STD	Y+43,R3
    0209B A64C      STD	Y+44,R4
    0209C A65D      STD	Y+45,R5
(2884) 
(2885) 		ifptr = fp->fptr;
    0209D A5E8      LDD	R30,Y+40
    0209E A5F9      LDD	R31,Y+41
    0209F 9636      ADIW	R30,6
    020A0 8020      LD	R2,Z
    020A1 8031      LDD	R3,Z+1
    020A2 8042      LDD	R4,Z+2
    020A3 8053      LDD	R5,Z+3
    020A4 862E      STD	Y+14,R2
    020A5 863F      STD	Y+15,R3
    020A6 8A48      STD	Y+16,R4
    020A7 8A59      STD	Y+17,R5
(2886) 		fp->fptr = nsect = 0;
    020A8 E080      LDI	R24,0
    020A9 878A      STD	Y+10,R24
    020AA 878B      STD	Y+11,R24
    020AB 878C      STD	Y+12,R24
    020AC 878D      STD	Y+13,R24
    020AD A5E8      LDD	R30,Y+40
    020AE A5F9      LDD	R31,Y+41
    020AF 9636      ADIW	R30,6
    020B0 E080      LDI	R24,0
    020B1 8380      ST	Z,R24
    020B2 8381      STD	Z+1,R24
    020B3 8382      STD	Z+2,R24
    020B4 8383      STD	Z+3,R24
(2887) 		if (ofs) {
    020B5 A42A      LDD	R2,Y+42
    020B6 A43B      LDD	R3,Y+43
    020B7 A44C      LDD	R4,Y+44
    020B8 A45D      LDD	R5,Y+45
    020B9 9488      BCLR	0
    020BA 2022      TST	R2
    020BB 0432      CPC	R3,R2
    020BC 0442      CPC	R4,R2
    020BD 0452      CPC	R5,R2
    020BE F409      BNE	0x20C0
    020BF C226      RJMP	0x22E6
(2888) 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    020C0 A5E8      LDD	R30,Y+40
    020C1 A5F9      LDD	R31,Y+41
    020C2 93AF      PUSH	R26
    020C3 93BF      PUSH	R27
    020C4 81A0      LD	R26,Z
    020C5 81B1      LDD	R27,Z+1
    020C6 01FD      MOVW	R30,R26
    020C7 91BF      POP	R27
    020C8 91AF      POP	R26
    020C9 9632      ADIW	R30,2
    020CA 8020      LD	R2,Z
    020CB 2433      CLR	R3
    020CC 2444      CLR	R4
    020CD 2455      CLR	R5
    020CE E040      LDI	R20,0
    020CF E052      LDI	R21,2
    020D0 E060      LDI	R22,0
    020D1 E070      LDI	R23,0
    020D2 925A      ST	-Y,R5
    020D3 924A      ST	-Y,R4
    020D4 923A      ST	-Y,R3
    020D5 922A      ST	-Y,R2
    020D6 018A      MOVW	R16,R20
    020D7 019B      MOVW	R18,R22
    020D8 940E 3F19 CALL	empy32u|empy32s
    020DA 830E      STD	Y+6,R16
    020DB 831F      STD	Y+7,R17
    020DC 8728      STD	Y+8,R18
    020DD 8739      STD	Y+9,R19
(2889) 			if (ifptr > 0 &&
    020DE 842E      LDD	R2,Y+14
    020DF 843F      LDD	R3,Y+15
    020E0 8848      LDD	R4,Y+16
    020E1 8859      LDD	R5,Y+17
    020E2 9488      BCLR	0
    020E3 2022      TST	R2
    020E4 0432      CPC	R3,R2
    020E5 0442      CPC	R4,R2
    020E6 0452      CPC	R5,R2
    020E7 F409      BNE	0x20E9
    020E8 C075      RJMP	0x215E
    020E9 E041      LDI	R20,1
    020EA E050      LDI	R21,0
    020EB E060      LDI	R22,0
    020EC E070      LDI	R23,0
    020ED 0181      MOVW	R16,R2
    020EE 0192      MOVW	R18,R4
    020EF 1B04      SUB	R16,R20
    020F0 0B15      SBC	R17,R21
    020F1 0B26      SBC	R18,R22
    020F2 0B37      SBC	R19,R23
    020F3 802E      LDD	R2,Y+6
    020F4 803F      LDD	R3,Y+7
    020F5 8448      LDD	R4,Y+8
    020F6 8459      LDD	R5,Y+9
    020F7 925A      ST	-Y,R5
    020F8 924A      ST	-Y,R4
    020F9 923A      ST	-Y,R3
    020FA 922A      ST	-Y,R2
    020FB 940E 3E73 CALL	div32u
    020FD 0118      MOVW	R2,R16
    020FE 0129      MOVW	R4,R18
    020FF E041      LDI	R20,1
    02100 E050      LDI	R21,0
    02101 E060      LDI	R22,0
    02102 E070      LDI	R23,0
    02103 A50A      LDD	R16,Y+42
    02104 A51B      LDD	R17,Y+43
    02105 A52C      LDD	R18,Y+44
    02106 A53D      LDD	R19,Y+45
    02107 1B04      SUB	R16,R20
    02108 0B15      SBC	R17,R21
    02109 0B26      SBC	R18,R22
    0210A 0B37      SBC	R19,R23
    0210B 806E      LDD	R6,Y+6
    0210C 807F      LDD	R7,Y+7
    0210D 8488      LDD	R8,Y+8
    0210E 8499      LDD	R9,Y+9
    0210F 929A      ST	-Y,R9
    02110 928A      ST	-Y,R8
    02111 927A      ST	-Y,R7
    02112 926A      ST	-Y,R6
    02113 940E 3E73 CALL	div32u
    02115 1502      CP	R16,R2
    02116 0513      CPC	R17,R3
    02117 0524      CPC	R18,R4
    02118 0535      CPC	R19,R5
    02119 F408      BCC	0x211B
    0211A C043      RJMP	0x215E
(2890) 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
(2891) 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    0211B E041      LDI	R20,1
    0211C E050      LDI	R21,0
    0211D E060      LDI	R22,0
    0211E E070      LDI	R23,0
    0211F 802E      LDD	R2,Y+6
    02120 803F      LDD	R3,Y+7
    02121 8448      LDD	R4,Y+8
    02122 8459      LDD	R5,Y+9
    02123 1A24      SUB	R2,R20
    02124 0A35      SBC	R3,R21
    02125 0A46      SBC	R4,R22
    02126 0A57      SBC	R5,R23
    02127 9420      COM	R2
    02128 9430      COM	R3
    02129 9440      COM	R4
    0212A 9450      COM	R5
    0212B E041      LDI	R20,1
    0212C E050      LDI	R21,0
    0212D E060      LDI	R22,0
    0212E E070      LDI	R23,0
    0212F 846E      LDD	R6,Y+14
    02130 847F      LDD	R7,Y+15
    02131 8888      LDD	R8,Y+16
    02132 8899      LDD	R9,Y+17
    02133 1A64      SUB	R6,R20
    02134 0A75      SBC	R7,R21
    02135 0A86      SBC	R8,R22
    02136 0A97      SBC	R9,R23
    02137 2062      AND	R6,R2
    02138 2073      AND	R7,R3
    02139 2084      AND	R8,R4
    0213A 2095      AND	R9,R5
    0213B A5E8      LDD	R30,Y+40
    0213C A5F9      LDD	R31,Y+41
    0213D 8266      STD	Z+6,R6
    0213E 8277      STD	Z+7,R7
    0213F 8680      STD	Z+8,R8
    02140 8691      STD	Z+9,R9
(2892) 				ofs -= fp->fptr;
    02141 9636      ADIW	R30,6
    02142 8020      LD	R2,Z
    02143 8031      LDD	R3,Z+1
    02144 8042      LDD	R4,Z+2
    02145 8053      LDD	R5,Z+3
    02146 A46A      LDD	R6,Y+42
    02147 A47B      LDD	R7,Y+43
    02148 A48C      LDD	R8,Y+44
    02149 A49D      LDD	R9,Y+45
    0214A 1862      SUB	R6,R2
    0214B 0873      SBC	R7,R3
    0214C 0884      SBC	R8,R4
    0214D 0895      SBC	R9,R5
    0214E A66A      STD	Y+42,R6
    0214F A67B      STD	Y+43,R7
    02150 A68C      STD	Y+44,R8
    02151 A69D      STD	Y+45,R9
(2893) 				clst = fp->clust;
    02152 A5E8      LDD	R30,Y+40
    02153 A5F9      LDD	R31,Y+41
    02154 9672      ADIW	R30,0x12
    02155 8020      LD	R2,Z
    02156 8031      LDD	R3,Z+1
    02157 8042      LDD	R4,Z+2
    02158 8053      LDD	R5,Z+3
    02159 822A      STD	Y+2,R2
    0215A 823B      STD	Y+3,R3
    0215B 824C      STD	Y+4,R4
    0215C 825D      STD	Y+5,R5
(2894) 			} else {									/* When seek to back cluster, */
    0215D C069      RJMP	0x21C7
(2895) 				clst = fp->sclust;						/* start from the first cluster */
    0215E A5E8      LDD	R30,Y+40
    0215F A5F9      LDD	R31,Y+41
    02160 963E      ADIW	R30,0xE
    02161 8020      LD	R2,Z
    02162 8031      LDD	R3,Z+1
    02163 8042      LDD	R4,Z+2
    02164 8053      LDD	R5,Z+3
    02165 822A      STD	Y+2,R2
    02166 823B      STD	Y+3,R3
    02167 824C      STD	Y+4,R4
    02168 825D      STD	Y+5,R5
(2896) #if !_FS_READONLY
(2897) 				if (clst == 0) {						/* If no cluster chain, create a new chain */
    02169 802A      LDD	R2,Y+2
    0216A 803B      LDD	R3,Y+3
    0216B 804C      LDD	R4,Y+4
    0216C 805D      LDD	R5,Y+5
    0216D 9488      BCLR	0
    0216E 2022      TST	R2
    0216F 0432      CPC	R3,R2
    02170 0442      CPC	R4,R2
    02171 0452      CPC	R5,R2
    02172 F009      BEQ	0x2174
    02173 C049      RJMP	0x21BD
(2898) 					clst = create_chain(fp->fs, 0);
    02174 E040      LDI	R20,0
    02175 E050      LDI	R21,0
    02176 E060      LDI	R22,0
    02177 E070      LDI	R23,0
    02178 8368      ST	Y,R22
    02179 8379      STD	Y+1,R23
    0217A 019A      MOVW	R18,R20
    0217B A5E8      LDD	R30,Y+40
    0217C A5F9      LDD	R31,Y+41
    0217D 8100      LD	R16,Z
    0217E 8111      LDD	R17,Z+1
    0217F 940E 08C4 CALL	ff.c:create_chain
    02181 830A      STD	Y+2,R16
    02182 831B      STD	Y+3,R17
    02183 832C      STD	Y+4,R18
    02184 833D      STD	Y+5,R19
(2899) 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    02185 E041      LDI	R20,1
    02186 E050      LDI	R21,0
    02187 E060      LDI	R22,0
    02188 E070      LDI	R23,0
    02189 802A      LDD	R2,Y+2
    0218A 803B      LDD	R3,Y+3
    0218B 804C      LDD	R4,Y+4
    0218C 805D      LDD	R5,Y+5
    0218D 1624      CP	R2,R20
    0218E 0635      CPC	R3,R21
    0218F 0646      CPC	R4,R22
    02190 0657      CPC	R5,R23
    02191 F451      BNE	0x219C
    02192 A588      LDD	R24,Y+40
    02193 A599      LDD	R25,Y+41
    02194 9604      ADIW	R24,4
    02195 017C      MOVW	R14,R24
    02196 01FC      MOVW	R30,R24
    02197 8180      LD	R24,Z
    02198 6880      ORI	R24,0x80
    02199 8380      ST	Z,R24
    0219A E002      LDI	R16,2
    0219B C196      RJMP	0x2332
(2900) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    0219C EF4F      LDI	R20,0xFF
    0219D EF5F      LDI	R21,0xFF
    0219E EF6F      LDI	R22,0xFF
    0219F EF7F      LDI	R23,0xFF
    021A0 802A      LDD	R2,Y+2
    021A1 803B      LDD	R3,Y+3
    021A2 804C      LDD	R4,Y+4
    021A3 805D      LDD	R5,Y+5
    021A4 1624      CP	R2,R20
    021A5 0635      CPC	R3,R21
    021A6 0646      CPC	R4,R22
    021A7 0657      CPC	R5,R23
    021A8 F451      BNE	0x21B3
    021A9 A588      LDD	R24,Y+40
    021AA A599      LDD	R25,Y+41
    021AB 9604      ADIW	R24,4
    021AC 017C      MOVW	R14,R24
    021AD 01FC      MOVW	R30,R24
    021AE 8180      LD	R24,Z
    021AF 6880      ORI	R24,0x80
    021B0 8380      ST	Z,R24
    021B1 E001      LDI	R16,1
    021B2 C17F      RJMP	0x2332
(2901) 					fp->sclust = clst;
    021B3 802A      LDD	R2,Y+2
    021B4 803B      LDD	R3,Y+3
    021B5 804C      LDD	R4,Y+4
    021B6 805D      LDD	R5,Y+5
    021B7 A5E8      LDD	R30,Y+40
    021B8 A5F9      LDD	R31,Y+41
    021B9 8626      STD	Z+14,R2
    021BA 8637      STD	Z+15,R3
    021BB 8A40      STD	Z+16,R4
    021BC 8A51      STD	Z+17,R5
(2902) 				}
(2903) #endif
(2904) 				fp->clust = clst;
    021BD 802A      LDD	R2,Y+2
    021BE 803B      LDD	R3,Y+3
    021BF 804C      LDD	R4,Y+4
    021C0 805D      LDD	R5,Y+5
    021C1 A5E8      LDD	R30,Y+40
    021C2 A5F9      LDD	R31,Y+41
    021C3 8A22      STD	Z+18,R2
    021C4 8A33      STD	Z+19,R3
    021C5 8A44      STD	Z+20,R4
    021C6 8A55      STD	Z+21,R5
(2905) 			}
(2906) 			if (clst != 0) {
    021C7 802A      LDD	R2,Y+2
    021C8 803B      LDD	R3,Y+3
    021C9 804C      LDD	R4,Y+4
    021CA 805D      LDD	R5,Y+5
    021CB 9488      BCLR	0
    021CC 2022      TST	R2
    021CD 0432      CPC	R3,R2
    021CE 0442      CPC	R4,R2
    021CF 0452      CPC	R5,R2
    021D0 F409      BNE	0x21D2
    021D1 C114      RJMP	0x22E6
    021D2 C0A7      RJMP	0x227A
(2907) 				while (ofs > bcs) {						/* Cluster following loop */
(2908) #if !_FS_READONLY
(2909) 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    021D3 A5E8      LDD	R30,Y+40
    021D4 A5F9      LDD	R31,Y+41
    021D5 9634      ADIW	R30,4
    021D6 8020      LD	R2,Z
    021D7 FE21      SBRS	R2,1
    021D8 C024      RJMP	0x21FD
(2910) 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    021D9 802A      LDD	R2,Y+2
    021DA 803B      LDD	R3,Y+3
    021DB 804C      LDD	R4,Y+4
    021DC 805D      LDD	R5,Y+5
    021DD 8248      ST	Y,R4
    021DE 8259      STD	Y+1,R5
    021DF 0191      MOVW	R18,R2
    021E0 A5E8      LDD	R30,Y+40
    021E1 A5F9      LDD	R31,Y+41
    021E2 8100      LD	R16,Z
    021E3 8111      LDD	R17,Z+1
    021E4 940E 08C4 CALL	ff.c:create_chain
    021E6 830A      STD	Y+2,R16
    021E7 831B      STD	Y+3,R17
    021E8 832C      STD	Y+4,R18
    021E9 833D      STD	Y+5,R19
(2911) 						if (clst == 0) {				/* When disk gets full, clip file size */
    021EA 802A      LDD	R2,Y+2
    021EB 803B      LDD	R3,Y+3
    021EC 804C      LDD	R4,Y+4
    021ED 805D      LDD	R5,Y+5
    021EE 9488      BCLR	0
    021EF 2022      TST	R2
    021F0 0432      CPC	R3,R2
    021F1 0442      CPC	R4,R2
    021F2 0452      CPC	R5,R2
    021F3 F4D1      BNE	0x220E
(2912) 							ofs = bcs; break;
    021F4 802E      LDD	R2,Y+6
    021F5 803F      LDD	R3,Y+7
    021F6 8448      LDD	R4,Y+8
    021F7 8459      LDD	R5,Y+9
    021F8 A62A      STD	Y+42,R2
    021F9 A63B      STD	Y+43,R3
    021FA A64C      STD	Y+44,R4
    021FB A65D      STD	Y+45,R5
    021FC C08B      RJMP	0x2288
(2913) 						}
(2914) 					} else
(2915) #endif
(2916) 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    021FD 802A      LDD	R2,Y+2
    021FE 803B      LDD	R3,Y+3
    021FF 804C      LDD	R4,Y+4
    02200 805D      LDD	R5,Y+5
    02201 8248      ST	Y,R4
    02202 8259      STD	Y+1,R5
    02203 0191      MOVW	R18,R2
    02204 A5E8      LDD	R30,Y+40
    02205 A5F9      LDD	R31,Y+41
    02206 8100      LD	R16,Z
    02207 8111      LDD	R17,Z+1
    02208 940E 0502 CALL	_get_fat
    0220A 830A      STD	Y+2,R16
    0220B 831B      STD	Y+3,R17
    0220C 832C      STD	Y+4,R18
    0220D 833D      STD	Y+5,R19
(2917) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    0220E EF4F      LDI	R20,0xFF
    0220F EF5F      LDI	R21,0xFF
    02210 EF6F      LDI	R22,0xFF
    02211 EF7F      LDI	R23,0xFF
    02212 802A      LDD	R2,Y+2
    02213 803B      LDD	R3,Y+3
    02214 804C      LDD	R4,Y+4
    02215 805D      LDD	R5,Y+5
    02216 1624      CP	R2,R20
    02217 0635      CPC	R3,R21
    02218 0646      CPC	R4,R22
    02219 0657      CPC	R5,R23
    0221A F451      BNE	0x2225
    0221B A588      LDD	R24,Y+40
    0221C A599      LDD	R25,Y+41
    0221D 9604      ADIW	R24,4
    0221E 017C      MOVW	R14,R24
    0221F 01FC      MOVW	R30,R24
    02220 8180      LD	R24,Z
    02221 6880      ORI	R24,0x80
    02222 8380      ST	Z,R24
    02223 E001      LDI	R16,1
    02224 C10D      RJMP	0x2332
(2918) 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    02225 E041      LDI	R20,1
    02226 E050      LDI	R21,0
    02227 E060      LDI	R22,0
    02228 E070      LDI	R23,0
    02229 802A      LDD	R2,Y+2
    0222A 803B      LDD	R3,Y+3
    0222B 804C      LDD	R4,Y+4
    0222C 805D      LDD	R5,Y+5
    0222D 1542      CP	R20,R2
    0222E 0553      CPC	R21,R3
    0222F 0564      CPC	R22,R4
    02230 0575      CPC	R23,R5
    02231 F490      BCC	0x2244
    02232 A5E8      LDD	R30,Y+40
    02233 A5F9      LDD	R31,Y+41
    02234 81A0      LD	R26,Z
    02235 81B1      LDD	R27,Z+1
    02236 9656      ADIW	R26,0x16
    02237 902D      LD	R2,X+
    02238 903D      LD	R3,X+
    02239 904D      LD	R4,X+
    0223A 905C      LD	R5,X
    0223B 806A      LDD	R6,Y+2
    0223C 807B      LDD	R7,Y+3
    0223D 808C      LDD	R8,Y+4
    0223E 809D      LDD	R9,Y+5
    0223F 1462      CP	R6,R2
    02240 0473      CPC	R7,R3
    02241 0484      CPC	R8,R4
    02242 0495      CPC	R9,R5
    02243 F050      BCS	0x224E
    02244 A588      LDD	R24,Y+40
    02245 A599      LDD	R25,Y+41
    02246 9604      ADIW	R24,4
    02247 017C      MOVW	R14,R24
    02248 01FC      MOVW	R30,R24
    02249 8180      LD	R24,Z
    0224A 6880      ORI	R24,0x80
    0224B 8380      ST	Z,R24
    0224C E002      LDI	R16,2
    0224D C0E4      RJMP	0x2332
(2919) 					fp->clust = clst;
    0224E 802A      LDD	R2,Y+2
    0224F 803B      LDD	R3,Y+3
    02250 804C      LDD	R4,Y+4
    02251 805D      LDD	R5,Y+5
    02252 A5E8      LDD	R30,Y+40
    02253 A5F9      LDD	R31,Y+41
    02254 9672      ADIW	R30,0x12
    02255 8220      ST	Z,R2
    02256 8231      STD	Z+1,R3
    02257 8242      STD	Z+2,R4
    02258 8253      STD	Z+3,R5
(2920) 					fp->fptr += bcs;
    02259 A588      LDD	R24,Y+40
    0225A A599      LDD	R25,Y+41
    0225B 9606      ADIW	R24,6
    0225C 017C      MOVW	R14,R24
    0225D 802E      LDD	R2,Y+6
    0225E 803F      LDD	R3,Y+7
    0225F 8448      LDD	R4,Y+8
    02260 8459      LDD	R5,Y+9
    02261 01FC      MOVW	R30,R24
    02262 8060      LD	R6,Z
    02263 8071      LDD	R7,Z+1
    02264 8082      LDD	R8,Z+2
    02265 8093      LDD	R9,Z+3
    02266 0C62      ADD	R6,R2
    02267 1C73      ADC	R7,R3
    02268 1C84      ADC	R8,R4
    02269 1C95      ADC	R9,R5
    0226A 8260      ST	Z,R6
    0226B 8271      STD	Z+1,R7
    0226C 8282      STD	Z+2,R8
    0226D 8293      STD	Z+3,R9
(2921) 					ofs -= bcs;
    0226E A46A      LDD	R6,Y+42
    0226F A47B      LDD	R7,Y+43
    02270 A48C      LDD	R8,Y+44
    02271 A49D      LDD	R9,Y+45
    02272 1862      SUB	R6,R2
    02273 0873      SBC	R7,R3
    02274 0884      SBC	R8,R4
    02275 0895      SBC	R9,R5
    02276 A66A      STD	Y+42,R6
    02277 A67B      STD	Y+43,R7
    02278 A68C      STD	Y+44,R8
    02279 A69D      STD	Y+45,R9
    0227A 802E      LDD	R2,Y+6
    0227B 803F      LDD	R3,Y+7
    0227C 8448      LDD	R4,Y+8
    0227D 8459      LDD	R5,Y+9
    0227E A46A      LDD	R6,Y+42
    0227F A47B      LDD	R7,Y+43
    02280 A48C      LDD	R8,Y+44
    02281 A49D      LDD	R9,Y+45
    02282 1426      CP	R2,R6
    02283 0437      CPC	R3,R7
    02284 0448      CPC	R4,R8
    02285 0459      CPC	R5,R9
    02286 F408      BCC	0x2288
    02287 CF4B      RJMP	0x21D3
(2922) 				}
(2923) 				fp->fptr += ofs;
    02288 A588      LDD	R24,Y+40
    02289 A599      LDD	R25,Y+41
    0228A 9606      ADIW	R24,6
    0228B 017C      MOVW	R14,R24
    0228C A42A      LDD	R2,Y+42
    0228D A43B      LDD	R3,Y+43
    0228E A44C      LDD	R4,Y+44
    0228F A45D      LDD	R5,Y+45
    02290 01FC      MOVW	R30,R24
    02291 8060      LD	R6,Z
    02292 8071      LDD	R7,Z+1
    02293 8082      LDD	R8,Z+2
    02294 8093      LDD	R9,Z+3
    02295 0C62      ADD	R6,R2
    02296 1C73      ADC	R7,R3
    02297 1C84      ADC	R8,R4
    02298 1C95      ADC	R9,R5
    02299 8260      ST	Z,R6
    0229A 8271      STD	Z+1,R7
    0229B 8282      STD	Z+2,R8
    0229C 8293      STD	Z+3,R9
(2924) 				if (ofs % SS(fp->fs)) {
    0229D EF4F      LDI	R20,0xFF
    0229E E051      LDI	R21,1
    0229F E060      LDI	R22,0
    022A0 E070      LDI	R23,0
    022A1 2224      AND	R2,R20
    022A2 2235      AND	R3,R21
    022A3 2246      AND	R4,R22
    022A4 2257      AND	R5,R23
    022A5 9488      BCLR	0
    022A6 2022      TST	R2
    022A7 0432      CPC	R3,R2
    022A8 0442      CPC	R4,R2
    022A9 0452      CPC	R5,R2
    022AA F409      BNE	0x22AC
    022AB C03A      RJMP	0x22E6
(2925) 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    022AC 802A      LDD	R2,Y+2
    022AD 803B      LDD	R3,Y+3
    022AE 804C      LDD	R4,Y+4
    022AF 805D      LDD	R5,Y+5
    022B0 8248      ST	Y,R4
    022B1 8259      STD	Y+1,R5
    022B2 0191      MOVW	R18,R2
    022B3 A5E8      LDD	R30,Y+40
    022B4 A5F9      LDD	R31,Y+41
    022B5 8100      LD	R16,Z
    022B6 8111      LDD	R17,Z+1
    022B7 940E 04B0 CALL	_clust2sect
    022B9 870A      STD	Y+10,R16
    022BA 871B      STD	Y+11,R17
    022BB 872C      STD	Y+12,R18
    022BC 873D      STD	Y+13,R19
(2926) 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    022BD 842A      LDD	R2,Y+10
    022BE 843B      LDD	R3,Y+11
    022BF 844C      LDD	R4,Y+12
    022C0 845D      LDD	R5,Y+13
    022C1 9488      BCLR	0
    022C2 2022      TST	R2
    022C3 0432      CPC	R3,R2
    022C4 0442      CPC	R4,R2
    022C5 0452      CPC	R5,R2
    022C6 F451      BNE	0x22D1
    022C7 A588      LDD	R24,Y+40
    022C8 A599      LDD	R25,Y+41
    022C9 9604      ADIW	R24,4
    022CA 017C      MOVW	R14,R24
    022CB 01FC      MOVW	R30,R24
    022CC 8180      LD	R24,Z
    022CD 6880      ORI	R24,0x80
    022CE 8380      ST	Z,R24
    022CF E002      LDI	R16,2
    022D0 C061      RJMP	0x2332
(2927) 					nsect += ofs / SS(fp->fs);
    022D1 E089      LDI	R24,0x9
    022D2 E090      LDI	R25,0
    022D3 A50A      LDD	R16,Y+42
    022D4 A51B      LDD	R17,Y+43
    022D5 A52C      LDD	R18,Y+44
    022D6 A53D      LDD	R19,Y+45
    022D7 938A      ST	-Y,R24
    022D8 940E 4008 CALL	lsr32
    022DA 842A      LDD	R2,Y+10
    022DB 843B      LDD	R3,Y+11
    022DC 844C      LDD	R4,Y+12
    022DD 845D      LDD	R5,Y+13
    022DE 0E20      ADD	R2,R16
    022DF 1E31      ADC	R3,R17
    022E0 1E42      ADC	R4,R18
    022E1 1E53      ADC	R5,R19
    022E2 862A      STD	Y+10,R2
    022E3 863B      STD	Y+11,R3
    022E4 864C      STD	Y+12,R4
    022E5 865D      STD	Y+13,R5
(2928) 				}
(2929) 			}
(2930) 		}
(2931) 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    022E6 EF4F      LDI	R20,0xFF
    022E7 E051      LDI	R21,1
    022E8 E060      LDI	R22,0
    022E9 E070      LDI	R23,0
    022EA A5E8      LDD	R30,Y+40
    022EB A5F9      LDD	R31,Y+41
    022EC 9636      ADIW	R30,6
    022ED 8020      LD	R2,Z
    022EE 8031      LDD	R3,Z+1
    022EF 8042      LDD	R4,Z+2
    022F0 8053      LDD	R5,Z+3
    022F1 2224      AND	R2,R20
    022F2 2235      AND	R3,R21
    022F3 2246      AND	R4,R22
    022F4 2257      AND	R5,R23
    022F5 9488      BCLR	0
    022F6 2022      TST	R2
    022F7 0432      CPC	R3,R2
    022F8 0442      CPC	R4,R2
    022F9 0452      CPC	R5,R2
    022FA F0C1      BEQ	0x2313
    022FB A5E8      LDD	R30,Y+40
    022FC A5F9      LDD	R31,Y+41
    022FD 9676      ADIW	R30,0x16
    022FE 8020      LD	R2,Z
    022FF 8031      LDD	R3,Z+1
    02300 8042      LDD	R4,Z+2
    02301 8053      LDD	R5,Z+3
    02302 846A      LDD	R6,Y+10
    02303 847B      LDD	R7,Y+11
    02304 848C      LDD	R8,Y+12
    02305 849D      LDD	R9,Y+13
    02306 1462      CP	R6,R2
    02307 0473      CPC	R7,R3
    02308 0484      CPC	R8,R4
    02309 0495      CPC	R9,R5
    0230A F041      BEQ	0x2313
(2932) #if !_FS_TINY
(2933) #if !_FS_READONLY
(2934) 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
(2935) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2936) 					ABORT(fp->fs, FR_DISK_ERR);
(2937) 				fp->flag &= ~FA__DIRTY;
(2938) 			}
(2939) #endif
(2940) 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
(2941) 				ABORT(fp->fs, FR_DISK_ERR);
(2942) #endif
(2943) 			fp->dsect = nsect;
    0230B 0113      MOVW	R2,R6
    0230C 0124      MOVW	R4,R8
    0230D A5E8      LDD	R30,Y+40
    0230E A5F9      LDD	R31,Y+41
    0230F 8A26      STD	Z+22,R2
    02310 8A37      STD	Z+23,R3
    02311 8E40      STD	Z+24,R4
    02312 8E51      STD	Z+25,R5
(2944) 		}
(2945) #if !_FS_READONLY
(2946) 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    02313 A5E8      LDD	R30,Y+40
    02314 A5F9      LDD	R31,Y+41
    02315 8422      LDD	R2,Z+10
    02316 8433      LDD	R3,Z+11
    02317 8444      LDD	R4,Z+12
    02318 8455      LDD	R5,Z+13
    02319 8066      LDD	R6,Z+6
    0231A 8077      LDD	R7,Z+7
    0231B 8480      LDD	R8,Z+8
    0231C 8491      LDD	R9,Z+9
    0231D 1426      CP	R2,R6
    0231E 0437      CPC	R3,R7
    0231F 0448      CPC	R4,R8
    02320 0459      CPC	R5,R9
    02321 F478      BCC	0x2331
(2947) 			fp->fsize = fp->fptr;
    02322 8026      LDD	R2,Z+6
    02323 8037      LDD	R3,Z+7
    02324 8440      LDD	R4,Z+8
    02325 8451      LDD	R5,Z+9
    02326 8622      STD	Z+10,R2
    02327 8633      STD	Z+11,R3
    02328 8644      STD	Z+12,R4
    02329 8655      STD	Z+13,R5
(2948) 			fp->flag |= FA__WRITTEN;
    0232A 01CF      MOVW	R24,R30
    0232B 9604      ADIW	R24,4
    0232C 016C      MOVW	R12,R24
    0232D 01FC      MOVW	R30,R24
    0232E 8180      LD	R24,Z
    0232F 6280      ORI	R24,0x20
    02330 8380      ST	Z,R24
(2949) 		}
(2950) #endif
(2951) 	}
(2952) 
(2953) 	LEAVE_FF(fp->fs, res);
    02331 2D0A      MOV	R16,R10
    02332 966E      ADIW	R28,0x1E
    02333 940E 3F62 CALL	pop_xgsetF0FC
    02335 9624      ADIW	R28,4
    02336 9508      RET
_f_opendir:
  sfn                  --> Y,+1
  res                  --> R20
  path                 --> Y,+19
  dj                   --> R22
    02337 933A      ST	-Y,R19
    02338 932A      ST	-Y,R18
    02339 940E 3F8C CALL	push_xgsetF00C
    0233B 01B8      MOVW	R22,R16
    0233C 972D      SBIW	R28,0xD
(2954) }
(2955) 
(2956) 
(2957) 
(2958) #if _FS_MINIMIZE <= 1
(2959) /*-----------------------------------------------------------------------*/
(2960) /* Create a Directroy Object                                             */
(2961) /*-----------------------------------------------------------------------*/
(2962) 
(2963) FRESULT f_opendir (
(2964) 	DIR *dj,			/* Pointer to directory object to create */
(2965) 	const TCHAR *path	/* Pointer to the directory path */
(2966) )
(2967) {
(2968) 	FRESULT res;
(2969) 	DEF_NAMEBUF;
(2970) 
(2971) 
(2972) 	res = chk_mounted(&path, &dj->fs, 0);
    0233D 2422      CLR	R2
    0233E 8228      ST	Y,R2
    0233F 019B      MOVW	R18,R22
    02340 018E      MOVW	R16,R28
    02341 5E0D      SUBI	R16,0xED
    02342 4F1F      SBCI	R17,0xFF
    02343 940E 1157 CALL	ff.c:chk_mounted
    02345 2F40      MOV	R20,R16
(2973) 	if (res == FR_OK) {
    02346 2300      TST	R16
    02347 F009      BEQ	0x2349
    02348 C05C      RJMP	0x23A5
(2974) 		INIT_BUF(*dj);
    02349 01CE      MOVW	R24,R28
    0234A 9601      ADIW	R24,1
    0234B 01FB      MOVW	R30,R22
    0234C 8B95      STD	Z+21,R25
    0234D 8B84      STD	Z+20,R24
(2975) 		res = follow_path(dj, path);			/* Follow the path to the directory */
    0234E 892B      LDD	R18,Y+19
    0234F 893C      LDD	R19,Y+20
    02350 018F      MOVW	R16,R30
    02351 940E 100B CALL	ff.c:follow_path
    02353 2F40      MOV	R20,R16
(2976) 		FREE_BUF();
(2977) 		if (res == FR_OK) {						/* Follow completed */
    02354 2300      TST	R16
    02355 F009      BEQ	0x2357
    02356 C04B      RJMP	0x23A2
(2978) 			if (dj->dir) {						/* It is not the root dir */
    02357 01FB      MOVW	R30,R22
    02358 8822      LDD	R2,Z+18
    02359 8833      LDD	R3,Z+19
    0235A 2022      TST	R2
    0235B F419      BNE	0x235F
    0235C 2033      TST	R3
    0235D F409      BNE	0x235F
    0235E C032      RJMP	0x2391
(2979) 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    0235F 93AF      PUSH	R26
    02360 93BF      PUSH	R27
    02361 89A2      LDD	R26,Z+18
    02362 89B3      LDD	R27,Z+19
    02363 01FD      MOVW	R30,R26
    02364 91BF      POP	R27
    02365 91AF      POP	R26
    02366 8423      LDD	R2,Z+11
    02367 FE24      SBRS	R2,4
    02368 C027      RJMP	0x2390
(2980) 					dj->sclust = LD_CLUST(dj->dir);
    02369 01FB      MOVW	R30,R22
    0236A 88A2      LDD	R10,Z+18
    0236B 88B3      LDD	R11,Z+19
    0236C 01F5      MOVW	R30,R10
    0236D 8C22      LDD	R2,Z+26
    0236E 2433      CLR	R3
    0236F 8C43      LDD	R4,Z+27
    02370 2455      CLR	R5
    02371 2C54      MOV	R5,R4
    02372 2444      CLR	R4
    02373 2842      OR	R4,R2
    02374 2853      OR	R5,R3
    02375 0112      MOVW	R2,R4
    02376 2444      CLR	R4
    02377 2455      CLR	R5
    02378 8864      LDD	R6,Z+20
    02379 2477      CLR	R7
    0237A 8885      LDD	R8,Z+21
    0237B 2499      CLR	R9
    0237C 2C98      MOV	R9,R8
    0237D 2488      CLR	R8
    0237E 2886      OR	R8,R6
    0237F 2897      OR	R9,R7
    02380 0134      MOVW	R6,R8
    02381 2488      CLR	R8
    02382 2499      CLR	R9
    02383 0143      MOVW	R8,R6
    02384 2466      CLR	R6
    02385 2477      CLR	R7
    02386 2862      OR	R6,R2
    02387 2873      OR	R7,R3
    02388 2884      OR	R8,R4
    02389 2895      OR	R9,R5
    0238A 01FB      MOVW	R30,R22
    0238B 8266      STD	Z+6,R6
    0238C 8277      STD	Z+7,R7
    0238D 8680      STD	Z+8,R8
    0238E 8691      STD	Z+9,R9
(2981) 				} else {						/* The object is not a directory */
    0238F C001      RJMP	0x2391
(2982) 					res = FR_NO_PATH;
    02390 E045      LDI	R20,5
(2983) 				}
(2984) 			}
(2985) 			if (res == FR_OK) {
    02391 2344      TST	R20
    02392 F479      BNE	0x23A2
(2986) 				dj->id = dj->fs->id;
    02393 01FB      MOVW	R30,R22
    02394 81A0      LD	R26,Z
    02395 81B1      LDD	R27,Z+1
    02396 9616      ADIW	R26,6
    02397 902D      LD	R2,X+
    02398 903C      LD	R3,X
    02399 8233      STD	Z+3,R3
    0239A 8222      STD	Z+2,R2
(2987) 				res = dir_sdi(dj, 0);			/* Rewind dir */
    0239B 2722      CLR	R18
    0239C 2733      CLR	R19
    0239D 018F      MOVW	R16,R30
    0239E 940E 0AB5 CALL	ff.c:dir_sdi
    023A0 2EA0      MOV	R10,R16
    023A1 2D4A      MOV	R20,R10
(2988) 			}
(2989) 		}
(2990) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
    023A2 3044      CPI	R20,4
    023A3 F409      BNE	0x23A5
    023A4 E045      LDI	R20,5
(2991) 	}
(2992) 
(2993) 	LEAVE_FF(dj->fs, res);
    023A5 2F04      MOV	R16,R20
    023A6 962D      ADIW	R28,0xD
    023A7 940E 3F93 CALL	pop_xgsetF00C
    023A9 9622      ADIW	R28,2
    023AA 9508      RET
_f_readdir:
  sfn                  --> Y,+0
  res                  --> R20
  fno                  --> R10
  dj                   --> R22
    023AB 940E 3FA8 CALL	push_xgsetF03C
    023AD 0159      MOVW	R10,R18
    023AE 01B8      MOVW	R22,R16
    023AF 972C      SBIW	R28,0xC
(2994) }
(2995) 
(2996) 
(2997) 
(2998) 
(2999) /*-----------------------------------------------------------------------*/
(3000) /* Read Directory Entry in Sequense                                      */
(3001) /*-----------------------------------------------------------------------*/
(3002) 
(3003) FRESULT f_readdir (
(3004) 	DIR *dj,			/* Pointer to the open directory object */
(3005) 	FILINFO *fno		/* Pointer to file information to return */
(3006) )
(3007) {
(3008) 	FRESULT res;
(3009) 	DEF_NAMEBUF;
(3010) 
(3011) 
(3012) 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    023B0 01FB      MOVW	R30,R22
    023B1 8122      LDD	R18,Z+2
    023B2 8133      LDD	R19,Z+3
    023B3 8100      LD	R16,Z
    023B4 8111      LDD	R17,Z+1
    023B5 940E 1651 CALL	ff.c:validate
    023B7 2F40      MOV	R20,R16
(3013) 	if (res == FR_OK) {
    023B8 2300      TST	R16
    023B9 F009      BEQ	0x23BB
    023BA C035      RJMP	0x23F0
(3014) 		if (!fno) {
    023BB 20AA      TST	R10
    023BC F449      BNE	0x23C6
    023BD 20BB      TST	R11
    023BE F439      BNE	0x23C6
(3015) 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    023BF 2722      CLR	R18
    023C0 2733      CLR	R19
    023C1 018B      MOVW	R16,R22
    023C2 940E 0AB5 CALL	ff.c:dir_sdi
    023C4 2F40      MOV	R20,R16
(3016) 		} else {
    023C5 C02A      RJMP	0x23F0
(3017) 			INIT_BUF(*dj);
    023C6 01CE      MOVW	R24,R28
    023C7 01FB      MOVW	R30,R22
    023C8 8B95      STD	Z+21,R25
    023C9 8B84      STD	Z+20,R24
(3018) 			res = dir_read(dj);				/* Read an directory item */
    023CA 018F      MOVW	R16,R30
    023CB 940E 0DB2 CALL	ff.c:dir_read
    023CD 2EC0      MOV	R12,R16
    023CE 2D4C      MOV	R20,R12
(3019) 			if (res == FR_NO_FILE) {		/* Reached end of dir */
    023CF 3004      CPI	R16,4
    023D0 F441      BNE	0x23D9
(3020) 				dj->sect = 0;
    023D1 01FB      MOVW	R30,R22
    023D2 963E      ADIW	R30,0xE
    023D3 E080      LDI	R24,0
    023D4 8380      ST	Z,R24
    023D5 8381      STD	Z+1,R24
    023D6 8382      STD	Z+2,R24
    023D7 8383      STD	Z+3,R24
(3021) 				res = FR_OK;
    023D8 2744      CLR	R20
(3022) 			}
(3023) 			if (res == FR_OK) {				/* A valid entry is found */
    023D9 2344      TST	R20
    023DA F4A9      BNE	0x23F0
(3024) 				get_fileinfo(dj, fno);		/* Get the object information */
    023DB 0195      MOVW	R18,R10
    023DC 018B      MOVW	R16,R22
    023DD 940E 0F68 CALL	ff.c:get_fileinfo
(3025) 				res = dir_next(dj, 0);		/* Increment index for next */
    023DF 2722      CLR	R18
    023E0 2733      CLR	R19
    023E1 018B      MOVW	R16,R22
    023E2 940E 0BBF CALL	ff.c:dir_next
    023E4 2EA0      MOV	R10,R16
    023E5 2D4A      MOV	R20,R10
(3026) 				if (res == FR_NO_FILE) {
    023E6 3004      CPI	R16,4
    023E7 F441      BNE	0x23F0
(3027) 					dj->sect = 0;
    023E8 01FB      MOVW	R30,R22
    023E9 963E      ADIW	R30,0xE
    023EA E080      LDI	R24,0
    023EB 8380      ST	Z,R24
    023EC 8381      STD	Z+1,R24
    023ED 8382      STD	Z+2,R24
    023EE 8383      STD	Z+3,R24
(3028) 					res = FR_OK;
    023EF 2744      CLR	R20
(3029) 				}
(3030) 			}
(3031) 			FREE_BUF();
(3032) 		}
(3033) 	}
(3034) 
(3035) 	LEAVE_FF(dj->fs, res);
    023F0 2F04      MOV	R16,R20
    023F1 962C      ADIW	R28,0xC
    023F2 940C 3FB1 JMP	pop_xgsetF03C
FILE: D:\LQD\software\master\software_src\delay.c
(0001) /*******************************
(0002)  function ：延时函数
(0003) Clock F  :7.3728M 
(0004) Software : ICCAVR7.14C
(0005) ********************************/
(0006) /*---------------------------------------------------------------------------------
(0007)      延时程序计算方法
(0008)      计数个数j = 延时时间/6*晶振频率 - 1
(0009) ---------------------------------------------------------------------------------*/
(0010) void delayus(unsigned int tttt)   // 1.2us 延时子函数   
(0011) { 
(0012)    do
(0013)    {
(0014)        tttt--;
_delayus:
  tttt                 --> R16
    023F4 5001      SUBI	R16,1
    023F5 4010      SBCI	R17,0
(0015)    }
(0016)    while(tttt>1);
    023F6 E081      LDI	R24,1
    023F7 E090      LDI	R25,0
    023F8 1780      CP	R24,R16
    023F9 0791      CPC	R25,R17
    023FA F3C8      BCS	0x23F4
    023FB 9508      RET
_delayms:
  j                    --> R20
  i                    --> R16
    023FC 934A      ST	-Y,R20
    023FD 935A      ST	-Y,R21
(0017) }
(0018) void delayms(unsigned int i)                 //1ms延时
(0019)    {
    023FE C00A      RJMP	0x2409
(0020)     while(i--)
(0021)     {                          
(0022) 	    unsigned int j;                
(0023)         for(j=1;j<=1227;j++)   
    023FF E041      LDI	R20,1
    02400 E050      LDI	R21,0
    02401 C002      RJMP	0x2404
    02402 5F4F      SUBI	R20,0xFF
    02403 4F5F      SBCI	R21,0xFF
    02404 EC8B      LDI	R24,0xCB
    02405 E094      LDI	R25,4
    02406 1784      CP	R24,R20
    02407 0795      CPC	R25,R21
    02408 F7C8      BCC	0x2402
    02409 0118      MOVW	R2,R16
    0240A 5001      SUBI	R16,1
    0240B 4010      SBCI	R17,0
    0240C 2022      TST	R2
    0240D F789      BNE	0x23FF
    0240E 2033      TST	R3
    0240F F779      BNE	0x23FF
    02410 9159      LD	R21,Y+
    02411 9149      LD	R20,Y+
    02412 9508      RET
_initDevices:
    02413 940E 3F73 CALL	push_xgset003C
FILE: D:\LQD\software\master\software_src\main.c
(0001) #include "config.h"
(0002) #define  N_per_Second  (2.72*60)
(0003) const char tab[]="\t\0";
(0004) const char enter[]="\n\0";
(0005) char buffer[512];
(0006) char TempChar[80]; //存放临时字串
(0007) struct DATA Result;
(0008) struct tm t;
(0009) unsigned long now =0; 
(0010) void debug(UINT8 *str,UINT8 val);
(0011) void WriteSDFile(void);
(0012) struct CONFIG config;
(0013) void initDevices(void){
(0014) 	 DDRA=0XFF;
    02415 EF8F      LDI	R24,0xFF
    02416 BB8A      OUT	0x1A,R24
(0015) 	 PORTA=0XFF;
    02417 BB8B      OUT	0x1B,R24
(0016) 	 DDRB=0XFF;
    02418 BB87      OUT	0x17,R24
(0017) 	 PORTB=0XFF; 	 
    02419 BB88      OUT	0x18,R24
(0018) 	 DDRC=0XFF;
    0241A BB84      OUT	0x14,R24
(0019) 	 PORTC=0XFF;
    0241B BB85      OUT	0x15,R24
(0020) 	 DDRG=0XFF;
    0241C 9380 0064 STS	0x64,R24
(0021) 	 PORTG=0XFF;	 
    0241E 9380 0065 STS	0x65,R24
(0022) 	 SPI_IO_Init(); 
    02420 940E 3788 CALL	_SPI_IO_Init
(0023) 	 SD_Init();
    02422 940E 2B54 CALL	_SD_Init
(0024) 	 uart1_init();
    02424 940E 35B2 CALL	_uart1_init
(0025) 	 LCD_INT();delayms(50);LCD_INT();
    02426 940E 37A6 CALL	_LCD_INT
    02428 E302      LDI	R16,0x32
    02429 E010      LDI	R17,0
    0242A 940E 23FC CALL	_delayms
    0242C 940E 37A6 CALL	_LCD_INT
(0026) 	 LCD_SW(1);
    0242E E001      LDI	R16,1
    0242F 940E 379C CALL	_LCD_SW
(0027) 	 config.THRESHOLD_delta_sec=10; //一次检测用时
    02431 E08A      LDI	R24,0xA
    02432 9380 07B6 STS	config+4,R24
    02434 E080      LDI	R24,0
    02435 9380 07B7 STS	config+5,R24
    02437 9380 07B8 STS	config+6,R24
    02439 9380 07B9 STS	config+7,R24
(0028) 	 config.autocheck=0;
    0243B 2422      CLR	R2
    0243C 9220 07C2 STS	config+16,R2
    0243E 940C 3F4D JMP	pop_xgset003C
_main:
  keycode              --> Y,+1
  tmp                  --> Y,+1
  i                    --> R10
  buf512               --> Y,+14
  filename             --> Y,+0
    02440 97EF      SBIW	R28,0x3F
    02441 97EF      SBIW	R28,0x3F
    02442 97EF      SBIW	R28,0x3F
    02443 97EF      SBIW	R28,0x3F
    02444 97EF      SBIW	R28,0x3F
    02445 97EF      SBIW	R28,0x3F
    02446 97EF      SBIW	R28,0x3F
    02447 97EF      SBIW	R28,0x3F
    02448 9767      SBIW	R28,0x17
(0029) 	 config.checkDeltaTime=20;  //自动检测模式 时间间隔
(0030) }
(0031) 
(0032) ////////////////////////////////////////////////////////////////
(0033) void main(void){
(0034) 	 UINT8 tmp,keycode;
(0035) 	 UINT8 buf512[513];
(0036) 	 char filename[]="201302.xls\0\0\0";
    02449 E189      LDI	R24,0x19
    0244A E091      LDI	R25,1
    0244B 01FE      MOVW	R30,R28
    0244C E00E      LDI	R16,0xE
    0244D E010      LDI	R17,0
    0244E 93FA      ST	-Y,R31
    0244F 93EA      ST	-Y,R30
    02450 939A      ST	-Y,R25
    02451 938A      ST	-Y,R24
    02452 940E 4014 CALL	asgnblk
(0037) 	 int i=0;
    02454 24AA      CLR	R10
    02455 24BB      CLR	R11
(0038) 	 initDevices();
    02456 DFBC      RCALL	_initDevices
(0039) 	 dateRefresh(1);
    02457 E001      LDI	R16,1
    02458 940E 3466 CALL	_dateRefresh
(0040) 	 WriteFileHead();
    0245A D104      RCALL	_WriteFileHead
(0041)      Result.Index=findIndex(get_name(filename),buf512);
    0245B 018E      MOVW	R16,R28
    0245C D5CD      RCALL	_get_name
    0245D 019E      MOVW	R18,R28
    0245E 5F22      SUBI	R18,0xF2
    0245F 4F3F      SBCI	R19,0xFF
    02460 D241      RCALL	_findIndex
    02461 0118      MOVW	R2,R16
    02462 2444      CLR	R4
    02463 2455      CLR	R5
    02464 9230 054D STS	Result+11,R3
    02466 9220 054C STS	Result+10,R2
    02468 9250 054F STS	Result+13,R5
    0246A 9240 054E STS	Result+12,R4
    0246C C02E      RJMP	0x249B
(0042) 	 selfTest();
(0043) 	 while(1){
    0246D D394      RCALL	_check
(0044) 	    tmp=GUI_mainmeu();
    0246E E001      LDI	R16,1
    0246F 940E 3466 CALL	_dateRefresh
(0045) 		switch(tmp){
    02471 D50F      RCALL	_StructToChar
(0046) 		    case 3 : GUI_check(); break; 
    02472 D168      RCALL	_WriteSDFile
(0047) 			case 4 : GUI_set_time(); break ;
    02473 9040 054E LDS	R4,Result+12
    02475 9050 054F LDS	R5,Result+13
    02477 9020 054C LDS	R2,Result+10
    02479 9030 054D LDS	R3,Result+11
    0247B 2D22      MOV	R18,R2
    0247C E40A      LDI	R16,0x4A
    0247D E012      LDI	R17,2
    0247E D686      RCALL	_debug
(0048) 			//case 5 : GUI_read_back(); break;
    0247F E081      LDI	R24,1
    02480 E090      LDI	R25,0
    02481 E0A0      LDI	R26,0
    02482 E0B0      LDI	R27,0
    02483 9040 054E LDS	R4,Result+12
    02485 9050 054F LDS	R5,Result+13
    02487 9020 054C LDS	R2,Result+10
    02489 9030 054D LDS	R3,Result+11
    0248B 0E28      ADD	R2,R24
    0248C 1E39      ADC	R3,R25
    0248D 1E4A      ADC	R4,R26
    0248E 1E5B      ADC	R5,R27
    0248F 9230 054D STS	Result+11,R3
    02491 9220 054C STS	Result+10,R2
    02493 9250 054F STS	Result+13,R5
    02495 9240 054E STS	Result+12,R4
(0049) 			//case 6 : GUI_send_date();
(0050) 			case 7 : selfTest(); break ;
    02497 E001      LDI	R16,1
    02498 E010      LDI	R17,0
    02499 940E 23FC CALL	_delayms
    0249B CFD1      RJMP	0x246D
    0249C 96EF      ADIW	R28,0x3F
    0249D 96EF      ADIW	R28,0x3F
    0249E 96EF      ADIW	R28,0x3F
    0249F 96EF      ADIW	R28,0x3F
    024A0 96EF      ADIW	R28,0x3F
    024A1 96EF      ADIW	R28,0x3F
    024A2 96EF      ADIW	R28,0x3F
    024A3 96EF      ADIW	R28,0x3F
    024A4 9667      ADIW	R28,0x17
    024A5 9508      RET
_selfTest:
  str2                 --> Y,+12
  str1                 --> Y,+6
  tmp                  --> Y,+2
    024A6 9762      SBIW	R28,0x12
(0051) 			default : break;
(0052) 	   }
(0053) 	   delayms(100);
(0054) 	 }
(0055) 
(0056) }
(0057) void selfTest(void){
(0058) 	float tmp=0;                                                                
    024A7 EB04      LDI	R16,0xB4
    024A8 E010      LDI	R17,0
    024A9 940E 3EF5 CALL	elpm32
    024AB 830A      STD	Y+2,R16
    024AC 831B      STD	Y+3,R17
    024AD 832C      STD	Y+4,R18
    024AE 833D      STD	Y+5,R19
(0059) 	char str1[6],str2[6];
(0060) 	
(0061) 	 //自检程序
(0062) 	lp("自检程序");delayms(500);
    024AF E401      LDI	R16,0x41
    024B0 E012      LDI	R17,2
    024B1 940E 3AD5 CALL	_lp
    024B3 EF04      LDI	R16,0xF4
    024B4 E011      LDI	R17,1
    024B5 940E 23FC CALL	_delayms
(0063) 	lp("外部温度 ");
    024B7 E307      LDI	R16,0x37
    024B8 E012      LDI	R17,2
    024B9 940E 3AD5 CALL	_lp
(0064) 	tmp=read_T_NUM(0);
    024BB 2700      CLR	R16
    024BC 940E 3D08 CALL	_read_T_NUM
    024BE 830A      STD	Y+2,R16
    024BF 831B      STD	Y+3,R17
    024C0 832C      STD	Y+4,R18
    024C1 833D      STD	Y+5,R19
(0065) 	ftochr(tmp,str1);
    024C2 01CE      MOVW	R24,R28
    024C3 9606      ADIW	R24,6
    024C4 8399      STD	Y+1,R25
    024C5 8388      ST	Y,R24
    024C6 810A      LDD	R16,Y+2
    024C7 811B      LDD	R17,Y+3
    024C8 812C      LDD	R18,Y+4
    024C9 813D      LDD	R19,Y+5
    024CA D465      RCALL	_ftochr
(0066) 	str1[6]=0;
    024CB 2422      CLR	R2
    024CC 862C      STD	Y+12,R2
(0067) 	lp(str1);
    024CD 018E      MOVW	R16,R28
    024CE 5F0A      SUBI	R16,0xFA
    024CF 4F1F      SBCI	R17,0xFF
    024D0 940E 3AD5 CALL	_lp
(0068) 	delayms(500);
    024D2 EF04      LDI	R16,0xF4
    024D3 E011      LDI	R17,1
    024D4 940E 23FC CALL	_delayms
(0069) 	lp("内部温度");
    024D6 E20E      LDI	R16,0x2E
    024D7 E012      LDI	R17,2
    024D8 940E 3AD5 CALL	_lp
(0070) 	tmp=read_T_NUM(1);
    024DA E001      LDI	R16,1
    024DB 940E 3D08 CALL	_read_T_NUM
    024DD 830A      STD	Y+2,R16
    024DE 831B      STD	Y+3,R17
    024DF 832C      STD	Y+4,R18
    024E0 833D      STD	Y+5,R19
(0071) 	ftochr(tmp,str2);
    024E1 01CE      MOVW	R24,R28
    024E2 960C      ADIW	R24,0xC
    024E3 8399      STD	Y+1,R25
    024E4 8388      ST	Y,R24
    024E5 810A      LDD	R16,Y+2
    024E6 811B      LDD	R17,Y+3
    024E7 812C      LDD	R18,Y+4
    024E8 813D      LDD	R19,Y+5
    024E9 D446      RCALL	_ftochr
(0072) 	str2[6]=0;
    024EA 2422      CLR	R2
    024EB 8A2A      STD	Y+18,R2
(0073) 	lp(str2);
    024EC 018E      MOVW	R16,R28
    024ED 5F04      SUBI	R16,0xF4
    024EE 4F1F      SBCI	R17,0xFF
    024EF 940E 3AD5 CALL	_lp
(0074) 	delayms(500);
    024F1 EF04      LDI	R16,0xF4
    024F2 E011      LDI	R17,1
    024F3 940E 23FC CALL	_delayms
(0075) 	lp("风速脉冲：");delayms(500);
    024F5 E203      LDI	R16,0x23
    024F6 E012      LDI	R17,2
    024F7 940E 3AD5 CALL	_lp
    024F9 EF04      LDI	R16,0xF4
    024FA E011      LDI	R17,1
    024FB 940E 23FC CALL	_delayms
(0076) 	lp("蜂鸣器"); beep(2,2);delayms(500);
    024FD E10C      LDI	R16,0x1C
    024FE E012      LDI	R17,2
    024FF 940E 3AD5 CALL	_lp
    02501 E022      LDI	R18,2
    02502 E002      LDI	R16,2
    02503 940E 3B4B CALL	_beep
    02505 EF04      LDI	R16,0xF4
    02506 E011      LDI	R17,1
    02507 940E 23FC CALL	_delayms
(0077) 	lp("power 指示灯");
    02509 E00F      LDI	R16,0xF
    0250A E012      LDI	R17,2
    0250B 940E 3AD5 CALL	_lp
(0078) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    0250D 9AA7      SBI	0x14,7
    0250E 98AF      CBI	0x15,7
    0250F E604      LDI	R16,0x64
    02510 E010      LDI	R17,0
    02511 940E 23FC CALL	_delayms
    02513 9AA7      SBI	0x14,7
    02514 9AAF      SBI	0x15,7
    02515 E604      LDI	R16,0x64
    02516 E010      LDI	R17,0
    02517 940E 23FC CALL	_delayms
(0079) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02519 9AA7      SBI	0x14,7
    0251A 98AF      CBI	0x15,7
    0251B E604      LDI	R16,0x64
    0251C E010      LDI	R17,0
    0251D 940E 23FC CALL	_delayms
    0251F 9AA7      SBI	0x14,7
    02520 9AAF      SBI	0x15,7
    02521 E604      LDI	R16,0x64
    02522 E010      LDI	R17,0
    02523 940E 23FC CALL	_delayms
(0080) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02525 9AA7      SBI	0x14,7
    02526 98AF      CBI	0x15,7
    02527 E604      LDI	R16,0x64
    02528 E010      LDI	R17,0
    02529 940E 23FC CALL	_delayms
    0252B 9AA7      SBI	0x14,7
    0252C 9AAF      SBI	0x15,7
    0252D E604      LDI	R16,0x64
    0252E E010      LDI	R17,0
    0252F 940E 23FC CALL	_delayms
(0081) 	delayms(500);
    02531 EF04      LDI	R16,0xF4
    02532 E011      LDI	R17,1
    02533 940E 23FC CALL	_delayms
(0082) 	lp("加热开关");
    02535 E006      LDI	R16,6
    02536 E012      LDI	R17,2
    02537 940E 3AD5 CALL	_lp
(0083) 	RELAY_ON();delayms(100);  
    02539 9AAD      SBI	0x15,5
    0253A E604      LDI	R16,0x64
    0253B E010      LDI	R17,0
    0253C 940E 23FC CALL	_delayms
(0084) 	RELAY_OFF();delayms(100);
    0253E 98AD      CBI	0x15,5
    0253F E604      LDI	R16,0x64
    02540 E010      LDI	R17,0
    02541 940E 23FC CALL	_delayms
(0085) 	RELAY_ON();delayms(100);
    02543 9AAD      SBI	0x15,5
    02544 E604      LDI	R16,0x64
    02545 E010      LDI	R17,0
    02546 940E 23FC CALL	_delayms
(0086) 	RELAY_OFF();delayms(100);
    02548 98AD      CBI	0x15,5
    02549 E604      LDI	R16,0x64
    0254A E010      LDI	R17,0
    0254B 940E 23FC CALL	_delayms
(0087) 	lp("  ");delayms(500);
    0254D E003      LDI	R16,3
    0254E E012      LDI	R17,2
    0254F 940E 3AD5 CALL	_lp
    02551 EF04      LDI	R16,0xF4
    02552 E011      LDI	R17,1
    02553 940E 23FC CALL	_delayms
(0088) 	lp("完成自检");delayms(500);
    02555 EF0A      LDI	R16,0xFA
    02556 E011      LDI	R17,1
    02557 940E 3AD5 CALL	_lp
    02559 EF04      LDI	R16,0xF4
    0255A E011      LDI	R17,1
    0255B 940E 23FC CALL	_delayms
    0255D 9662      ADIW	R28,0x12
    0255E 9508      RET
_WriteFileHead:
  fs                   --> Y,+177
  bw                   --> Y,+175
  fnamep               --> Y,+161
  itam                 --> Y,+38
  file                 --> Y,+4
  res                  --> R10
    0255F 940E 3F73 CALL	push_xgset003C
    02561 97EF      SBIW	R28,0x3F
    02562 97EF      SBIW	R28,0x3F
    02563 97EF      SBIW	R28,0x3F
    02564 97EF      SBIW	R28,0x3F
    02565 97EF      SBIW	R28,0x3F
    02566 97EF      SBIW	R28,0x3F
    02567 97EF      SBIW	R28,0x3F
    02568 97EF      SBIW	R28,0x3F
    02569 97EF      SBIW	R28,0x3F
    0256A 97EF      SBIW	R28,0x3F
    0256B 97EF      SBIW	R28,0x3F
    0256C 97AA      SBIW	R28,0x2A
(0089) 	  
(0090) }
(0091) void WriteFileHead(void)   
(0092) {
(0093)  	 unsigned int bw;
(0094) 	 FRESULT res;
(0095) 	 FATFS fs;
(0096) 	 FIL file;
(0097) 	 char fnamep[]="201201.xls\0\0\0"; 
    0256D E287      LDI	R24,0x27
    0256E E091      LDI	R25,1
    0256F 01FE      MOVW	R30,R28
    02570 55EF      SUBI	R30,0x5F
    02571 4FFF      SBCI	R31,0xFF
    02572 E00E      LDI	R16,0xE
    02573 E010      LDI	R17,0
    02574 93FA      ST	-Y,R31
    02575 93EA      ST	-Y,R30
    02576 939A      ST	-Y,R25
    02577 938A      ST	-Y,R24
    02578 940E 4014 CALL	asgnblk
(0098) 	 UINT8 itam[]="DEV000001\t\t\t\t\t\t\t\t\t\t\r\n序号\t日期\t时分\t温度\t风速\t风冷指数\t等价制冷温度\t相当温度\t冻伤危害性\t安静作业\t中等强度作业\t高强度作业\n\0";
    0257A E385      LDI	R24,0x35
    0257B E091      LDI	R25,1
    0257C 01FE      MOVW	R30,R28
    0257D 96B6      ADIW	R30,0x26
    0257E E70B      LDI	R16,0x7B
    0257F E010      LDI	R17,0
    02580 93FA      ST	-Y,R31
    02581 93EA      ST	-Y,R30
    02582 939A      ST	-Y,R25
    02583 938A      ST	-Y,R24
    02584 940E 4014 CALL	asgnblk
(0099) 	 res=disk_initialize(0);
    02586 2700      CLR	R16
    02587 940E 0282 CALL	_disk_initialize
    02589 2EA0      MOV	R10,R16
(0100) 	 #ifdef _DEBUG
(0101) 	 debug("dinit",res);
    0258A 2D2A      MOV	R18,R10
    0258B EF04      LDI	R16,0xF4
    0258C E011      LDI	R17,1
    0258D D577      RCALL	_debug
(0102) 	 #endif
(0103) 	 res = f_mount(0, &fs);
    0258E 019E      MOVW	R18,R28
    0258F 542F      SUBI	R18,0x4F
    02590 4F3F      SBCI	R19,0xFF
    02591 2700      CLR	R16
    02592 940E 166E CALL	_f_mount
    02594 2EA0      MOV	R10,R16
(0104) 	 #ifdef _DEBUG
(0105)  	 debug("dmnt",res);
    02595 2D2A      MOV	R18,R10
    02596 EE0F      LDI	R16,0xEF
    02597 E011      LDI	R17,1
    02598 D56C      RCALL	_debug
(0106) 	 #endif
(0107) 	 //get_name(fnamep)
(0108) 	 res = f_open(&file, get_name(fnamep) , FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    02599 018E      MOVW	R16,R28
    0259A 550F      SUBI	R16,0x5F
    0259B 4F1F      SBCI	R17,0xFF
    0259C D48D      RCALL	_get_name
    0259D 0168      MOVW	R12,R16
    0259E E182      LDI	R24,0x12
    0259F 8388      ST	Y,R24
    025A0 0196      MOVW	R18,R12
    025A1 018E      MOVW	R16,R28
    025A2 5F0C      SUBI	R16,0xFC
    025A3 4F1F      SBCI	R17,0xFF
    025A4 940E 1699 CALL	_f_open
    025A6 2EC0      MOV	R12,R16
    025A7 2CAC      MOV	R10,R12
(0109) 	 #ifdef _DEBUG
(0110) 	 debug("fopen",res);
    025A8 2D2A      MOV	R18,R10
    025A9 EE09      LDI	R16,0xE9
    025AA E011      LDI	R17,1
    025AB D559      RCALL	_debug
(0111) 	 #endif
(0112) 	 res = f_write(&file,itam,sizeof(itam),&bw);   //bw 已写入字节数
    025AC 01CE      MOVW	R24,R28
    025AD 5581      SUBI	R24,0x51
    025AE 4F9F      SBCI	R25,0xFF
    025AF 839B      STD	Y+3,R25
    025B0 838A      STD	Y+2,R24
    025B1 E78B      LDI	R24,0x7B
    025B2 E090      LDI	R25,0
    025B3 8399      STD	Y+1,R25
    025B4 8388      ST	Y,R24
    025B5 019E      MOVW	R18,R28
    025B6 5D2A      SUBI	R18,0xDA
    025B7 4F3F      SBCI	R19,0xFF
    025B8 018E      MOVW	R16,R28
    025B9 5F0C      SUBI	R16,0xFC
    025BA 4F1F      SBCI	R17,0xFF
    025BB 940E 1AA0 CALL	_f_write
    025BD 2EC0      MOV	R12,R16
    025BE 2CAC      MOV	R10,R12
(0113) 	 #ifdef _DEBUG
(0114) 	 debug("fwrite",res);
    025BF 2D2A      MOV	R18,R10
    025C0 EE02      LDI	R16,0xE2
    025C1 E011      LDI	R17,1
    025C2 D542      RCALL	_debug
(0115) 	 #endif
(0116) 	 f_close(&file);
    025C3 018E      MOVW	R16,R28
    025C4 5F0C      SUBI	R16,0xFC
    025C5 4F1F      SBCI	R17,0xFF
    025C6 940E 1E6A CALL	_f_close
(0117) 	 f_mount(0, NULL);
    025C8 2722      CLR	R18
    025C9 2733      CLR	R19
    025CA 2700      CLR	R16
    025CB 940E 166E CALL	_f_mount
    025CD 96EF      ADIW	R28,0x3F
    025CE 96EF      ADIW	R28,0x3F
    025CF 96EF      ADIW	R28,0x3F
    025D0 96EF      ADIW	R28,0x3F
    025D1 96EF      ADIW	R28,0x3F
    025D2 96EF      ADIW	R28,0x3F
    025D3 96EF      ADIW	R28,0x3F
    025D4 96EF      ADIW	R28,0x3F
    025D5 96EF      ADIW	R28,0x3F
    025D6 96EF      ADIW	R28,0x3F
    025D7 96EF      ADIW	R28,0x3F
    025D8 96AA      ADIW	R28,0x2A
    025D9 940C 3F4D JMP	pop_xgset003C
_WriteSDFile:
  fnamep               --> Y,+602
  fs                   --> Y,+44
  bw                   --> Y,+42
  lenth                --> Y,+38
  res                  --> R10
  file                 --> Y,+4
    025DB 92AA      ST	-Y,R10
    025DC 92CA      ST	-Y,R12
    025DD 97EF      SBIW	R28,0x3F
    025DE 97EF      SBIW	R28,0x3F
    025DF 97EF      SBIW	R28,0x3F
    025E0 97EF      SBIW	R28,0x3F
    025E1 97EF      SBIW	R28,0x3F
    025E2 97EF      SBIW	R28,0x3F
    025E3 97EF      SBIW	R28,0x3F
    025E4 97EF      SBIW	R28,0x3F
    025E5 97EF      SBIW	R28,0x3F
    025E6 97E0      SBIW	R28,0x30
(0118) } /////////////////////////////////////////////////
(0119) //       写入文件函数 
(0120) //(创建)打开文件 
(0121) // data 指向欲写入的的字符串 64byt 
(0122) //////////////////////////////////////////////// 
(0123) void WriteSDFile(void)   
(0124) {
(0125)     unsigned int bw;
(0126) 	FRESULT res;
(0127) 	FATFS fs;
(0128)     FIL file;
(0129) 	char fnamep[13];
(0130) 	long lenth=0;
    025E7 E080      LDI	R24,0
    025E8 A38E      STD	Y+38,R24
    025E9 A38F      STD	Y+39,R24
    025EA A788      STD	Y+40,R24
    025EB A789      STD	Y+41,R24
(0131) 	disk_initialize(0);
    025EC 2700      CLR	R16
    025ED 940E 0282 CALL	_disk_initialize
(0132) 	res = f_mount(0, &fs);
    025EF 019E      MOVW	R18,R28
    025F0 5D24      SUBI	R18,0xD4
    025F1 4F3F      SBCI	R19,0xFF
    025F2 2700      CLR	R16
    025F3 940E 166E CALL	_f_mount
(0133) 	res = f_open(&file,get_name(fnamep), FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    025F5 018E      MOVW	R16,R28
    025F6 5A06      SUBI	R16,0xA6
    025F7 4F1D      SBCI	R17,0xFD
    025F8 D431      RCALL	_get_name
    025F9 E182      LDI	R24,0x12
    025FA 8388      ST	Y,R24
    025FB 0198      MOVW	R18,R16
    025FC 018E      MOVW	R16,R28
    025FD 5F0C      SUBI	R16,0xFC
    025FE 4F1F      SBCI	R17,0xFF
    025FF 940E 1699 CALL	_f_open
(0134) 	lenth=file.fsize;   
    02601 842E      LDD	R2,Y+14
    02602 843F      LDD	R3,Y+15
    02603 8848      LDD	R4,Y+16
    02604 8859      LDD	R5,Y+17
    02605 A22E      STD	Y+38,R2
    02606 A23F      STD	Y+39,R3
    02607 A648      STD	Y+40,R4
    02608 A659      STD	Y+41,R5
(0135) 	res = f_lseek (&file,lenth);	 
    02609 A02E      LDD	R2,Y+38
    0260A A03F      LDD	R3,Y+39
    0260B A448      LDD	R4,Y+40
    0260C A459      LDD	R5,Y+41
    0260D 8248      ST	Y,R4
    0260E 8259      STD	Y+1,R5
    0260F 0191      MOVW	R18,R2
    02610 018E      MOVW	R16,R28
    02611 5F0C      SUBI	R16,0xFC
    02612 4F1F      SBCI	R17,0xFF
    02613 940E 1E7A CALL	_f_lseek
(0136) 	res = f_write(&file,TempChar,64,&bw);   //bw 已写入字节数
    02615 01CE      MOVW	R24,R28
    02616 968A      ADIW	R24,0x2A
    02617 839B      STD	Y+3,R25
    02618 838A      STD	Y+2,R24
    02619 E480      LDI	R24,0x40
    0261A E090      LDI	R25,0
    0261B 8399      STD	Y+1,R25
    0261C 8388      ST	Y,R24
    0261D EF22      LDI	R18,0xF2
    0261E E034      LDI	R19,4
    0261F 018E      MOVW	R16,R28
    02620 5F0C      SUBI	R16,0xFC
    02621 4F1F      SBCI	R17,0xFF
    02622 940E 1AA0 CALL	_f_write
    02624 2EC0      MOV	R12,R16
    02625 2CAC      MOV	R10,R12
(0137) 	f_close(&file);
    02626 018E      MOVW	R16,R28
    02627 5F0C      SUBI	R16,0xFC
    02628 4F1F      SBCI	R17,0xFF
    02629 940E 1E6A CALL	_f_close
(0138) 	f_mount(0, NULL);
    0262B 2722      CLR	R18
    0262C 2733      CLR	R19
    0262D 2700      CLR	R16
    0262E 940E 166E CALL	_f_mount
    02630 96EF      ADIW	R28,0x3F
    02631 96EF      ADIW	R28,0x3F
    02632 96EF      ADIW	R28,0x3F
    02633 96EF      ADIW	R28,0x3F
    02634 96EF      ADIW	R28,0x3F
    02635 96EF      ADIW	R28,0x3F
    02636 96EF      ADIW	R28,0x3F
    02637 96EF      ADIW	R28,0x3F
    02638 96EF      ADIW	R28,0x3F
    02639 96E0      ADIW	R28,0x30
    0263A 90C9      LD	R12,Y+
    0263B 90A9      LD	R10,Y+
    0263C 9508      RET
_ReadSDFile:
  fs                   --> Y,+53
  bw                   --> Y,+51
  fnamep               --> Y,+38
  file                 --> Y,+4
  res                  --> R20
  data                 --> R10
  index                --> R22
    0263D 940E 3FA8 CALL	push_xgsetF03C
    0263F 0159      MOVW	R10,R18
    02640 01B8      MOVW	R22,R16
    02641 97EF      SBIW	R28,0x3F
    02642 97EF      SBIW	R28,0x3F
    02643 97EF      SBIW	R28,0x3F
    02644 97EF      SBIW	R28,0x3F
    02645 97EF      SBIW	R28,0x3F
    02646 97EF      SBIW	R28,0x3F
    02647 97EF      SBIW	R28,0x3F
    02648 97EF      SBIW	R28,0x3F
    02649 97EF      SBIW	R28,0x3F
    0264A 97AC      SBIW	R28,0x2C
(0139) }
(0140) /////////////////////////////////////////////////
(0141) //       读取文件函数
(0142) //以64byte为一块 读取
(0143) //index数据偏移量   data读出后存放地
(0144) //////////////////////////////////////////////// 
(0145) char ReadSDFile(unsigned int index,char *data)
(0146) {
(0147)  	unsigned int bw;
(0148) 	char res;
(0149) 	FATFS fs;
(0150)     FIL file;
(0151) 	char fnamep[13];
(0152)     get_name(fnamep); 
    0264B 018E      MOVW	R16,R28
    0264C 5D0A      SUBI	R16,0xDA
    0264D 4F1F      SBCI	R17,0xFF
    0264E D3DB      RCALL	_get_name
(0153)     disk_initialize(0);
    0264F 2700      CLR	R16
    02650 940E 0282 CALL	_disk_initialize
(0154)     res = f_mount(0, &fs);
    02652 019E      MOVW	R18,R28
    02653 5C2B      SUBI	R18,0xCB
    02654 4F3F      SBCI	R19,0xFF
    02655 2700      CLR	R16
    02656 940E 166E CALL	_f_mount
(0155)     res = f_open(&file,fnamep,FA_READ);  
    02658 E081      LDI	R24,1
    02659 8388      ST	Y,R24
    0265A 019E      MOVW	R18,R28
    0265B 5D2A      SUBI	R18,0xDA
    0265C 4F3F      SBCI	R19,0xFF
    0265D 018E      MOVW	R16,R28
    0265E 5F0C      SUBI	R16,0xFC
    0265F 4F1F      SBCI	R17,0xFF
    02660 940E 1699 CALL	_f_open
    02662 2F40      MOV	R20,R16
(0156)     if(res==FR_NO_FILE) {data=NULL;
    02663 3004      CPI	R16,4
    02664 F419      BNE	0x2668
    02665 24AA      CLR	R10
    02666 24BB      CLR	R11
(0157)     #if _debug >= 1 
(0158)     debug_out("now file",255);
(0159) 	debug_out(filename,res);
(0160) 	debug_out("file is no exist....",255);
(0161)     #endif 
(0162)     return res;
    02667 C02E      RJMP	0x2696
(0163)     }   
(0164)     res = f_lseek (&file,(index+2)*64);	 //前两个字节数据为文件头空间 所以从第三块读/写起
    02668 019B      MOVW	R18,R22
    02669 5F2E      SUBI	R18,0xFE
    0266A 4F3F      SBCI	R19,0xFF
    0266B E400      LDI	R16,0x40
    0266C E010      LDI	R17,0
    0266D 940E 3F09 CALL	empy16s
    0266F 0118      MOVW	R2,R16
    02670 2444      CLR	R4
    02671 2455      CLR	R5
    02672 8248      ST	Y,R4
    02673 8259      STD	Y+1,R5
    02674 0191      MOVW	R18,R2
    02675 018E      MOVW	R16,R28
    02676 5F0C      SUBI	R16,0xFC
    02677 4F1F      SBCI	R17,0xFF
    02678 940E 1E7A CALL	_f_lseek
    0267A 2EC0      MOV	R12,R16
(0165)     res = f_read(&file,data,64,&bw);
    0267B 01CE      MOVW	R24,R28
    0267C 96C3      ADIW	R24,0x33
    0267D 839B      STD	Y+3,R25
    0267E 838A      STD	Y+2,R24
    0267F E480      LDI	R24,0x40
    02680 E090      LDI	R25,0
    02681 8399      STD	Y+1,R25
    02682 8388      ST	Y,R24
    02683 0195      MOVW	R18,R10
    02684 018E      MOVW	R16,R28
    02685 5F0C      SUBI	R16,0xFC
    02686 4F1F      SBCI	R17,0xFF
    02687 940E 1835 CALL	_f_read
    02689 2EA0      MOV	R10,R16
    0268A 2D4A      MOV	R20,R10
(0166)     f_close(&file);
    0268B 018E      MOVW	R16,R28
    0268C 5F0C      SUBI	R16,0xFC
    0268D 4F1F      SBCI	R17,0xFF
    0268E 940E 1E6A CALL	_f_close
(0167) 	f_mount(0, NULL);
    02690 2722      CLR	R18
    02691 2733      CLR	R19
    02692 2700      CLR	R16
    02693 940E 166E CALL	_f_mount
(0168) 	return res;
    02695 2F04      MOV	R16,R20
    02696 96EF      ADIW	R28,0x3F
    02697 96EF      ADIW	R28,0x3F
    02698 96EF      ADIW	R28,0x3F
    02699 96EF      ADIW	R28,0x3F
    0269A 96EF      ADIW	R28,0x3F
    0269B 96EF      ADIW	R28,0x3F
    0269C 96EF      ADIW	R28,0x3F
    0269D 96EF      ADIW	R28,0x3F
    0269E 96EF      ADIW	R28,0x3F
    0269F 96AC      ADIW	R28,0x2C
    026A0 940C 3FB1 JMP	pop_xgsetF03C
_findIndex:
  fs                   --> Y,+48
  bw                   --> Y,+46
  fnamep               --> R14
  readsize             --> R10
  res                  --> R12
  file                 --> Y,+12
  lenth                --> Y,+8
  index                --> Y,+4
  is_first_end         --> Y,+606
  tmp                  --> R10
  buf                  --> Y,+617
  filename             --> R10
    026A2 933A      ST	-Y,R19
    026A3 932A      ST	-Y,R18
    026A4 940E 3F6D CALL	push_xgsetF0FC
    026A6 0158      MOVW	R10,R16
    026A7 97EF      SBIW	R28,0x3F
    026A8 97EF      SBIW	R28,0x3F
    026A9 97EF      SBIW	R28,0x3F
    026AA 97EF      SBIW	R28,0x3F
    026AB 97EF      SBIW	R28,0x3F
    026AC 97EF      SBIW	R28,0x3F
    026AD 97EF      SBIW	R28,0x3F
    026AE 97EF      SBIW	R28,0x3F
    026AF 97EF      SBIW	R28,0x3F
    026B0 97A8      SBIW	R28,0x28
(0169) } 
(0170) //////////////////////////////////
(0171) //   find index
(0172) // 检查当前文件尺寸，根据倒数第二个
(0173) //'\n'及其后面的index确定当前index值
(0174) //////////////////////////////////
(0175) unsigned int findIndex(char *filename,char *buf){
(0176)     unsigned int bw,tmp;
(0177) 	long index =0;
    026B1 E080      LDI	R24,0
    026B2 838C      STD	Y+4,R24
    026B3 838D      STD	Y+5,R24
    026B4 838E      STD	Y+6,R24
    026B5 838F      STD	Y+7,R24
(0178) 	unsigned char is_first_end=0;
    026B6 2400      CLR	R0
    026B7 01DE      MOVW	R26,R28
    026B8 5AA2      SUBI	R26,0xA2
    026B9 4FBD      SBCI	R27,0xFD
    026BA 920C      ST	X,R0
(0179) 	char *fnamep=filename;
    026BB 0175      MOVW	R14,R10
(0180) 	FRESULT res;
(0181) 	FATFS fs;
(0182) 	FIL file;
(0183) 	long lenth=0;
    026BC E080      LDI	R24,0
    026BD 8788      STD	Y+8,R24
    026BE 8789      STD	Y+9,R24
    026BF 878A      STD	Y+10,R24
    026C0 878B      STD	Y+11,R24
(0184) 	int readsize=0;
    026C1 24AA      CLR	R10
    026C2 24BB      CLR	R11
(0185) 	//PrintString_n(fnamep);
(0186) 	res = f_mount(0, &fs);
    026C3 019E      MOVW	R18,R28
    026C4 5D20      SUBI	R18,0xD0
    026C5 4F3F      SBCI	R19,0xFF
    026C6 2700      CLR	R16
    026C7 940E 166E CALL	_f_mount
(0187) 	res = f_open(&file,fnamep, FA_OPEN_ALWAYS | FA_READ );  //创建一个新的文件
    026C9 E181      LDI	R24,0x11
    026CA 8388      ST	Y,R24
    026CB 0197      MOVW	R18,R14
    026CC 018E      MOVW	R16,R28
    026CD 5F04      SUBI	R16,0xF4
    026CE 4F1F      SBCI	R17,0xFF
    026CF 940E 1699 CALL	_f_open
    026D1 2EC0      MOV	R12,R16
(0188) 	if(res !=  FR_OK){ //openerror
    026D2 2300      TST	R16
    026D3 F011      BEQ	0x26D6
(0189) 	    return res;}
    026D4 2711      CLR	R17
    026D5 C11E      RJMP	0x27F4
(0190) 	lenth=file.fsize;   //文件尾部为 file.size 
    026D6 882E      LDD	R2,Y+22
    026D7 883F      LDD	R3,Y+23
    026D8 8C48      LDD	R4,Y+24
    026D9 8C59      LDD	R5,Y+25
    026DA 8628      STD	Y+8,R2
    026DB 8639      STD	Y+9,R3
    026DC 864A      STD	Y+10,R4
    026DD 865B      STD	Y+11,R5
(0191) 	//debug("size=",0xff);
(0192) 	//PrintLong(lenth);
(0193) 	if(lenth > 512) {
    026DE E040      LDI	R20,0
    026DF E052      LDI	R21,2
    026E0 E060      LDI	R22,0
    026E1 E070      LDI	R23,0
    026E2 8428      LDD	R2,Y+8
    026E3 8439      LDD	R3,Y+9
    026E4 844A      LDD	R4,Y+10
    026E5 845B      LDD	R5,Y+11
    026E6 1542      CP	R20,R2
    026E7 0553      CPC	R21,R3
    026E8 0564      CPC	R22,R4
    026E9 0575      CPC	R23,R5
    026EA F464      BGE	0x26F7
(0194) 	    readsize=512;
    026EB E080      LDI	R24,0
    026EC E092      LDI	R25,2
    026ED 015C      MOVW	R10,R24
(0195) 		lenth=file.fsize;
    026EE 882E      LDD	R2,Y+22
    026EF 883F      LDD	R3,Y+23
    026F0 8C48      LDD	R4,Y+24
    026F1 8C59      LDD	R5,Y+25
    026F2 8628      STD	Y+8,R2
    026F3 8639      STD	Y+9,R3
    026F4 864A      STD	Y+10,R4
    026F5 865B      STD	Y+11,R5
(0196) 	}
    026F6 C007      RJMP	0x26FE
(0197) 	else {
(0198) 	    readsize =file.fsize;
    026F7 88AE      LDD	R10,Y+22
    026F8 88BF      LDD	R11,Y+23
(0199) 		lenth=0;
    026F9 E080      LDI	R24,0
    026FA 8788      STD	Y+8,R24
    026FB 8789      STD	Y+9,R24
    026FC 878A      STD	Y+10,R24
    026FD 878B      STD	Y+11,R24
(0200) 	}
(0201) 	res = f_lseek (&file,file.fsize-readsize);
    026FE 0115      MOVW	R2,R10
    026FF 2444      CLR	R4
    02700 FC37      SBRC	R3,7
    02701 9440      COM	R4
    02702 2455      CLR	R5
    02703 FC47      SBRC	R4,7
    02704 9450      COM	R5
    02705 886E      LDD	R6,Y+22
    02706 887F      LDD	R7,Y+23
    02707 8C88      LDD	R8,Y+24
    02708 8C99      LDD	R9,Y+25
    02709 1862      SUB	R6,R2
    0270A 0873      SBC	R7,R3
    0270B 0884      SBC	R8,R4
    0270C 0895      SBC	R9,R5
    0270D 8288      ST	Y,R8
    0270E 8299      STD	Y+1,R9
    0270F 0193      MOVW	R18,R6
    02710 018E      MOVW	R16,R28
    02711 5F04      SUBI	R16,0xF4
    02712 4F1F      SBCI	R17,0xFF
    02713 940E 1E7A CALL	_f_lseek
(0202) 	//debug("readSIZE=",0x00);
(0203) 	//PrintLong((file.fsize-readsize));
(0204) 	res = f_read(&file,buf,readsize,&bw);
    02715 01CE      MOVW	R24,R28
    02716 968E      ADIW	R24,0x2E
    02717 839B      STD	Y+3,R25
    02718 838A      STD	Y+2,R24
    02719 82B9      STD	Y+1,R11
    0271A 82A8      ST	Y,R10
    0271B 01FE      MOVW	R30,R28
    0271C 59E7      SUBI	R30,0x97
    0271D 4FFD      SBCI	R31,0xFD
    0271E 8120      LD	R18,Z
    0271F 8131      LDD	R19,Z+1
    02720 018E      MOVW	R16,R28
    02721 5F04      SUBI	R16,0xF4
    02722 4F1F      SBCI	R17,0xFF
    02723 940E 1835 CALL	_f_read
    02725 2EE0      MOV	R14,R16
    02726 2CCE      MOV	R12,R14
(0205) 	f_close(&file);
    02727 018E      MOVW	R16,R28
    02728 5F04      SUBI	R16,0xF4
    02729 4F1F      SBCI	R17,0xFF
    0272A 940E 1E6A CALL	_f_close
(0206) 	//debug("readRES=",res);
(0207) 	//debug("readbw=",0X00);
(0208) 	//PrintLong(bw);
(0209) 	//PrintString_n(buf);
(0210) 	for(tmp=readsize;tmp>0;tmp--){
    0272C C04E      RJMP	0x277B
(0211) 		//debug("buf index",buf[tmp]);
(0212) 		//PrintLong(tmp);
(0213) 		if(buf[tmp] == '\n') Usart_Transmit('@');						  
    0272D 01F5      MOVW	R30,R10
    0272E 01DE      MOVW	R26,R28
    0272F 59A7      SUBI	R26,0x97
    02730 4FBD      SBCI	R27,0xFD
    02731 900D      LD	R0,X+
    02732 901C      LD	R1,X
    02733 0DE0      ADD	R30,R0
    02734 1DF1      ADC	R31,R1
    02735 8180      LD	R24,Z
    02736 308A      CPI	R24,0xA
    02737 F419      BNE	0x273B
    02738 E400      LDI	R16,0x40
    02739 940E 35CC CALL	_Usart_Transmit
(0214) 		if(buf[tmp] == '\n' && is_first_end== 0){
    0273B 01F5      MOVW	R30,R10
    0273C 01DE      MOVW	R26,R28
    0273D 59A7      SUBI	R26,0x97
    0273E 4FBD      SBCI	R27,0xFD
    0273F 900D      LD	R0,X+
    02740 901C      LD	R1,X
    02741 0DE0      ADD	R30,R0
    02742 1DF1      ADC	R31,R1
    02743 8180      LD	R24,Z
    02744 308A      CPI	R24,0xA
    02745 F469      BNE	0x2753
    02746 01FE      MOVW	R30,R28
    02747 5AE2      SUBI	R30,0xA2
    02748 4FFD      SBCI	R31,0xFD
    02749 8000      LD	R0,Z
    0274A 2000      TST	R0
    0274B F439      BNE	0x2753
(0215) 		    is_first_end=1; 	
    0274C 2400      CLR	R0
    0274D 9403      INC	R0
    0274E 01FE      MOVW	R30,R28
    0274F 5AE2      SUBI	R30,0xA2
    02750 4FFD      SBCI	R31,0xFD
    02751 8200      ST	Z,R0
(0216) 			//debug("first=",0xf0);					      
(0217) 		}
    02752 C025      RJMP	0x2778
(0218) 		else if(buf[tmp] == '\n' && is_first_end== 1){
    02753 01F5      MOVW	R30,R10
    02754 01DE      MOVW	R26,R28
    02755 59A7      SUBI	R26,0x97
    02756 4FBD      SBCI	R27,0xFD
    02757 900D      LD	R0,X+
    02758 901C      LD	R1,X
    02759 0DE0      ADD	R30,R0
    0275A 1DF1      ADC	R31,R1
    0275B 8180      LD	R24,Z
    0275C 308A      CPI	R24,0xA
    0275D F4D1      BNE	0x2778
    0275E 01DE      MOVW	R26,R28
    0275F 5AA2      SUBI	R26,0xA2
    02760 4FBD      SBCI	R27,0xFD
    02761 918C      LD	R24,X
    02762 3081      CPI	R24,1
    02763 F4A1      BNE	0x2778
(0219) 		    lenth -= (512-tmp);
    02764 E080      LDI	R24,0
    02765 E092      LDI	R25,2
    02766 011C      MOVW	R2,R24
    02767 182A      SUB	R2,R10
    02768 083B      SBC	R3,R11
    02769 2444      CLR	R4
    0276A 2455      CLR	R5
    0276B 8468      LDD	R6,Y+8
    0276C 8479      LDD	R7,Y+9
    0276D 848A      LDD	R8,Y+10
    0276E 849B      LDD	R9,Y+11
    0276F 1862      SUB	R6,R2
    02770 0873      SBC	R7,R3
    02771 0884      SBC	R8,R4
    02772 0895      SBC	R9,R5
    02773 8668      STD	Y+8,R6
    02774 8679      STD	Y+9,R7
    02775 868A      STD	Y+10,R8
    02776 869B      STD	Y+11,R9
(0220) 			break;
    02777 C009      RJMP	0x2781
    02778 01C5      MOVW	R24,R10
    02779 9701      SBIW	R24,1
    0277A 015C      MOVW	R10,R24
    0277B 20AA      TST	R10
    0277C F009      BEQ	0x277E
    0277D CFAF      RJMP	0x272D
    0277E 20BB      TST	R11
    0277F F009      BEQ	0x2781
    02780 CFAC      RJMP	0x272D
(0221) 		} 						
(0222) 	}
(0223) 	//debug("start=",0X00); PrintLong(lenth);
(0224) 	if(lenth < 118 ){ 
    02781 E746      LDI	R20,0x76
    02782 E050      LDI	R21,0
    02783 E060      LDI	R22,0
    02784 E070      LDI	R23,0
    02785 8428      LDD	R2,Y+8
    02786 8439      LDD	R3,Y+9
    02787 844A      LDD	R4,Y+10
    02788 845B      LDD	R5,Y+11
    02789 1624      CP	R2,R20
    0278A 0635      CPC	R3,R21
    0278B 0646      CPC	R4,R22
    0278C 0657      CPC	R5,R23
    0278D F434      BGE	0x2794
(0225)  		return 1;
    0278E E001      LDI	R16,1
    0278F E010      LDI	R17,0
    02790 C063      RJMP	0x27F4
(0226) 	}
(0227) 	else {
(0228) 		 //debug(">128 ",0X00);
(0229) 		 while(buf[tmp] <= '0' || buf[tmp] >= '9') tmp++;
    02791 01C5      MOVW	R24,R10
    02792 9601      ADIW	R24,1
    02793 015C      MOVW	R10,R24
    02794 01F5      MOVW	R30,R10
    02795 01DE      MOVW	R26,R28
    02796 59A7      SUBI	R26,0x97
    02797 4FBD      SBCI	R27,0xFD
    02798 900D      LD	R0,X+
    02799 901C      LD	R1,X
    0279A 0DE0      ADD	R30,R0
    0279B 1DF1      ADC	R31,R1
    0279C 80E0      LD	R14,Z
    0279D 24FF      CLR	R15
    0279E E380      LDI	R24,0x30
    0279F 158E      CP	R24,R14
    027A0 F780      BCC	0x2791
    027A1 2D8E      MOV	R24,R14
    027A2 3389      CPI	R24,0x39
    027A3 F768      BCC	0x2791
    027A4 C02F      RJMP	0x27D4
(0230) 		 //debug("nozero ",bw); PrintLong(tmp);
(0231) 		 while(buf[tmp] != 't' && buf[tmp] >= '0' && buf[tmp] <= '9'){
(0232) 		     index=index*10+(buf[tmp]-'0');
    027A5 01F5      MOVW	R30,R10
    027A6 01DE      MOVW	R26,R28
    027A7 59A7      SUBI	R26,0x97
    027A8 4FBD      SBCI	R27,0xFD
    027A9 900D      LD	R0,X+
    027AA 901C      LD	R1,X
    027AB 0DE0      ADD	R30,R0
    027AC 1DF1      ADC	R31,R1
    027AD 8180      LD	R24,Z
    027AE 2799      CLR	R25
    027AF 97C0      SBIW	R24,0x30
    027B0 011C      MOVW	R2,R24
    027B1 2444      CLR	R4
    027B2 FC37      SBRC	R3,7
    027B3 9440      COM	R4
    027B4 2455      CLR	R5
    027B5 FC47      SBRC	R4,7
    027B6 9450      COM	R5
    027B7 806C      LDD	R6,Y+4
    027B8 807D      LDD	R7,Y+5
    027B9 808E      LDD	R8,Y+6
    027BA 809F      LDD	R9,Y+7
    027BB E04A      LDI	R20,0xA
    027BC E050      LDI	R21,0
    027BD E060      LDI	R22,0
    027BE E070      LDI	R23,0
    027BF 929A      ST	-Y,R9
    027C0 928A      ST	-Y,R8
    027C1 927A      ST	-Y,R7
    027C2 926A      ST	-Y,R6
    027C3 018A      MOVW	R16,R20
    027C4 019B      MOVW	R18,R22
    027C5 940E 3F19 CALL	empy32u|empy32s
    027C7 0138      MOVW	R6,R16
    027C8 0149      MOVW	R8,R18
    027C9 0C62      ADD	R6,R2
    027CA 1C73      ADC	R7,R3
    027CB 1C84      ADC	R8,R4
    027CC 1C95      ADC	R9,R5
    027CD 826C      STD	Y+4,R6
    027CE 827D      STD	Y+5,R7
    027CF 828E      STD	Y+6,R8
    027D0 829F      STD	Y+7,R9
(0233) 		 	 //Usart_Transmit(buf[tmp]);	
(0234) 		 	 tmp++;
    027D1 01C5      MOVW	R24,R10
    027D2 9601      ADIW	R24,1
    027D3 015C      MOVW	R10,R24
    027D4 01F5      MOVW	R30,R10
    027D5 01DE      MOVW	R26,R28
    027D6 59A7      SUBI	R26,0x97
    027D7 4FBD      SBCI	R27,0xFD
    027D8 900D      LD	R0,X+
    027D9 901C      LD	R1,X
    027DA 0DE0      ADD	R30,R0
    027DB 1DF1      ADC	R31,R1
    027DC 80E0      LD	R14,Z
    027DD 24FF      CLR	R15
    027DE 2D8E      MOV	R24,R14
    027DF 3784      CPI	R24,0x74
    027E0 F031      BEQ	0x27E7
    027E1 3380      CPI	R24,0x30
    027E2 F020      BCS	0x27E7
    027E3 E389      LDI	R24,0x39
    027E4 158E      CP	R24,R14
    027E5 F008      BCS	0x27E7
    027E6 CFBE      RJMP	0x27A5
(0235) 		 }
(0236) 	}
(0237) 	//debug("index=",0X00);
(0238) 	//PrintLong(index+1);
(0239) 	return index+1;
    027E7 E041      LDI	R20,1
    027E8 E050      LDI	R21,0
    027E9 E060      LDI	R22,0
    027EA E070      LDI	R23,0
    027EB 802C      LDD	R2,Y+4
    027EC 803D      LDD	R3,Y+5
    027ED 804E      LDD	R4,Y+6
    027EE 805F      LDD	R5,Y+7
    027EF 0E24      ADD	R2,R20
    027F0 1E35      ADC	R3,R21
    027F1 1E46      ADC	R4,R22
    027F2 1E57      ADC	R5,R23
    027F3 0181      MOVW	R16,R2
    027F4 96EF      ADIW	R28,0x3F
    027F5 96EF      ADIW	R28,0x3F
    027F6 96EF      ADIW	R28,0x3F
    027F7 96EF      ADIW	R28,0x3F
    027F8 96EF      ADIW	R28,0x3F
    027F9 96EF      ADIW	R28,0x3F
    027FA 96EF      ADIW	R28,0x3F
    027FB 96EF      ADIW	R28,0x3F
    027FC 96EF      ADIW	R28,0x3F
    027FD 96A8      ADIW	R28,0x28
    027FE 940E 3F62 CALL	pop_xgsetF0FC
    02800 9622      ADIW	R28,2
    02801 9508      RET
_check:
  WScounter            --> R10
  tmp                  --> R12
    02802 940E 3F73 CALL	push_xgset003C
    02804 9722      SBIW	R28,2
(0240) }
(0241) void check( void )
(0242) {
(0243)  unsigned char tmp;
(0244)  unsigned int WScounter;
(0245)  //检测风速
(0246)  //读计数器1 此步需严格按手册进行。
(0247)  tmp=SREG;
    02805 B6CF      IN	R12,0x3F
(0248)  CLI();
    02806 94F8      BCLR	7
(0249)  WScounter=TCNT1H*256+TCNT1L;
    02807 B52D      IN	R18,0x2D
    02808 2733      CLR	R19
    02809 E000      LDI	R16,0
    0280A E011      LDI	R17,1
    0280B 940E 3F09 CALL	empy16s
    0280D 0158      MOVW	R10,R16
    0280E B42C      IN	R2,0x2C
    0280F 2433      CLR	R3
    02810 0CA2      ADD	R10,R2
    02811 1CB3      ADC	R11,R3
(0250)  SREG=tmp;
    02812 BECF      OUT	0x3F,R12
(0251)  SEI();
    02813 9478      BSET	7
(0252)  //计算风速
(0253)  Result.WindSpeed=WScounter/N_per_Second;
    02814 0185      MOVW	R16,R10
    02815 940E 40C7 CALL	uint2fp
    02817 0118      MOVW	R2,R16
    02818 0129      MOVW	R4,R18
    02819 EB00      LDI	R16,0xB0
    0281A E010      LDI	R17,0
    0281B 940E 3EF5 CALL	elpm32
    0281D 933A      ST	-Y,R19
    0281E 932A      ST	-Y,R18
    0281F 931A      ST	-Y,R17
    02820 930A      ST	-Y,R16
    02821 0181      MOVW	R16,R2
    02822 0192      MOVW	R18,R4
    02823 940E 40F4 CALL	fpdiv2
    02825 9310 0576 STS	Result+52,R17
    02827 9300 0575 STS	Result+51,R16
    02829 9330 0578 STS	Result+54,R19
    0282B 9320 0577 STS	Result+53,R18
(0254)  //温度
(0255)  Result.Temperature=read_T_NUM(1);
    0282D E001      LDI	R16,1
    0282E 940E 3D08 CALL	_read_T_NUM
    02830 9310 056C STS	Result+42,R17
    02832 9300 056B STS	Result+41,R16
    02834 9330 056E STS	Result+44,R19
    02836 9320 056D STS	Result+43,R18
(0256)  //WCI风冷指数
(0257)   Result.WCI = 4.18 *(10*SquareRootFloat(Result.WindSpeed) + 10.45 -  Result.WindSpeed  ) *( 33 - Result.Temperature );
    02838 9120 0577 LDS	R18,Result+53
    0283A 9130 0578 LDS	R19,Result+54
    0283C 9100 0575 LDS	R16,Result+51
    0283E 9110 0576 LDS	R17,Result+52
    02840 D228      RCALL	_SquareRootFloat
    02841 0118      MOVW	R2,R16
    02842 0129      MOVW	R4,R18
    02843 EA0C      LDI	R16,0xAC
    02844 E010      LDI	R17,0
    02845 940E 3EF5 CALL	elpm32
    02847 0138      MOVW	R6,R16
    02848 0149      MOVW	R8,R18
    02849 EA08      LDI	R16,0xA8
    0284A E010      LDI	R17,0
    0284B 940E 3EF5 CALL	elpm32
    0284D 925A      ST	-Y,R5
    0284E 924A      ST	-Y,R4
    0284F 923A      ST	-Y,R3
    02850 922A      ST	-Y,R2
    02851 940E 426E CALL	fpmule2
    02853 0118      MOVW	R2,R16
    02854 0129      MOVW	R4,R18
    02855 EA04      LDI	R16,0xA4
    02856 E010      LDI	R17,0
    02857 940E 3EF5 CALL	elpm32
    02859 933A      ST	-Y,R19
    0285A 932A      ST	-Y,R18
    0285B 931A      ST	-Y,R17
    0285C 930A      ST	-Y,R16
    0285D 0181      MOVW	R16,R2
    0285E 0192      MOVW	R18,R4
    0285F 940E 4096 CALL	fpadd2
    02861 E785      LDI	R24,0x75
    02862 E095      LDI	R25,5
    02863 939A      ST	-Y,R25
    02864 938A      ST	-Y,R24
    02865 940E 40AC CALL	fpsub1x
    02867 0183      MOVW	R16,R6
    02868 0194      MOVW	R18,R8
    02869 940E 426E CALL	fpmule2
    0286B 0118      MOVW	R2,R16
    0286C 0129      MOVW	R4,R18
    0286D EA00      LDI	R16,0xA0
    0286E E010      LDI	R17,0
    0286F 940E 3EF5 CALL	elpm32
    02871 E68B      LDI	R24,0x6B
    02872 E095      LDI	R25,5
    02873 939A      ST	-Y,R25
    02874 938A      ST	-Y,R24
    02875 940E 40AC CALL	fpsub1x
    02877 0181      MOVW	R16,R2
    02878 0192      MOVW	R18,R4
    02879 940E 426E CALL	fpmule2
    0287B 9310 057F STS	Result+61,R17
    0287D 9300 057E STS	Result+60,R16
    0287F 9330 0581 STS	Result+63,R19
    02881 9320 0580 STS	Result+62,R18
(0258)  //ECT等价制冷温度
(0259)  Result.ECT = 33 - 0.01085 * Result.WCI;
    02883 E90C      LDI	R16,0x9C
    02884 E010      LDI	R17,0
    02885 940E 3EF5 CALL	elpm32
    02887 0118      MOVW	R2,R16
    02888 0129      MOVW	R4,R18
    02889 E908      LDI	R16,0x98
    0288A E010      LDI	R17,0
    0288B 940E 3EF5 CALL	elpm32
    0288D E78E      LDI	R24,0x7E
    0288E E095      LDI	R25,5
    0288F 939A      ST	-Y,R25
    02890 938A      ST	-Y,R24
    02891 940E 4279 CALL	fpmule1x
    02893 0181      MOVW	R16,R2
    02894 0192      MOVW	R18,R4
    02895 940E 40A1 CALL	fpsub2
    02897 9310 0589 STS	Result+71,R17
    02899 9300 0588 STS	Result+70,R16
    0289B 9330 058B STS	Result+73,R19
    0289D 9320 058A STS	Result+72,R18
(0260)  //TEQ 相当温度
(0261)  Result.Teq = Result.Temperature +( (Result.Temperature -36)/10 ) * Result.WindSpeed ;
    0289F 9040 056D LDS	R4,Result+43
    028A1 9050 056E LDS	R5,Result+44
    028A3 9020 056B LDS	R2,Result+41
    028A5 9030 056C LDS	R3,Result+42
    028A7 0131      MOVW	R6,R2
    028A8 0142      MOVW	R8,R4
    028A9 E904      LDI	R16,0x94
    028AA E010      LDI	R17,0
    028AB 940E 3EF5 CALL	elpm32
    028AD 933A      ST	-Y,R19
    028AE 932A      ST	-Y,R18
    028AF 931A      ST	-Y,R17
    028B0 930A      ST	-Y,R16
    028B1 0183      MOVW	R16,R6
    028B2 0194      MOVW	R18,R8
    028B3 940E 40A1 CALL	fpsub2
    028B5 0138      MOVW	R6,R16
    028B6 0149      MOVW	R8,R18
    028B7 EA08      LDI	R16,0xA8
    028B8 E010      LDI	R17,0
    028B9 940E 3EF5 CALL	elpm32
    028BB 933A      ST	-Y,R19
    028BC 932A      ST	-Y,R18
    028BD 931A      ST	-Y,R17
    028BE 930A      ST	-Y,R16
    028BF 0183      MOVW	R16,R6
    028C0 0194      MOVW	R18,R8
    028C1 940E 40F4 CALL	fpdiv2
    028C3 E785      LDI	R24,0x75
    028C4 E095      LDI	R25,5
    028C5 939A      ST	-Y,R25
    028C6 938A      ST	-Y,R24
    028C7 940E 4279 CALL	fpmule1x
    028C9 0181      MOVW	R16,R2
    028CA 0192      MOVW	R18,R4
    028CB 940E 4096 CALL	fpadd2
    028CD 9310 0593 STS	Result+81,R17
    028CF 9300 0592 STS	Result+80,R16
    028D1 9330 0595 STS	Result+83,R19
    028D3 9320 0594 STS	Result+82,R18
(0262) //将数据转换成字符串
(0263)  
(0264) ftochr(Result.WindSpeed,Result.WSChar);
    028D5 E789      LDI	R24,0x79
    028D6 E095      LDI	R25,5
    028D7 8399      STD	Y+1,R25
    028D8 8388      ST	Y,R24
    028D9 9120 0577 LDS	R18,Result+53
    028DB 9130 0578 LDS	R19,Result+54
    028DD 9100 0575 LDS	R16,Result+51
    028DF 9110 0576 LDS	R17,Result+52
    028E1 D04E      RCALL	_ftochr
(0265) ftochr(Result.Temperature,Result.TempChar);
    028E2 E68F      LDI	R24,0x6F
    028E3 E095      LDI	R25,5
    028E4 8399      STD	Y+1,R25
    028E5 8388      ST	Y,R24
    028E6 9120 056D LDS	R18,Result+43
    028E8 9130 056E LDS	R19,Result+44
    028EA 9100 056B LDS	R16,Result+41
    028EC 9110 056C LDS	R17,Result+42
    028EE D041      RCALL	_ftochr
(0266) ftochr(Result.WCI,Result.WCIChar);
    028EF E882      LDI	R24,0x82
    028F0 E095      LDI	R25,5
    028F1 8399      STD	Y+1,R25
    028F2 8388      ST	Y,R24
    028F3 9120 0580 LDS	R18,Result+62
    028F5 9130 0581 LDS	R19,Result+63
    028F7 9100 057E LDS	R16,Result+60
    028F9 9110 057F LDS	R17,Result+61
    028FB D034      RCALL	_ftochr
(0267) ftochr(Result.ECT,Result.ECTChar);
    028FC E88C      LDI	R24,0x8C
    028FD E095      LDI	R25,5
    028FE 8399      STD	Y+1,R25
    028FF 8388      ST	Y,R24
    02900 9120 058A LDS	R18,Result+72
    02902 9130 058B LDS	R19,Result+73
    02904 9100 0588 LDS	R16,Result+70
    02906 9110 0589 LDS	R17,Result+71
    02908 D027      RCALL	_ftochr
(0268) ftochr(Result.Teq,Result.TeqChar);
    02909 E986      LDI	R24,0x96
    0290A E095      LDI	R25,5
    0290B 8399      STD	Y+1,R25
    0290C 8388      ST	Y,R24
    0290D 9120 0594 LDS	R18,Result+82
    0290F 9130 0595 LDS	R19,Result+83
    02911 9100 0592 LDS	R16,Result+80
    02913 9110 0593 LDS	R17,Result+81
    02915 D01A      RCALL	_ftochr
(0269) itoa(Result.IndexChar,Result.Index,10);
    02916 E08A      LDI	R24,0xA
    02917 E090      LDI	R25,0
    02918 8399      STD	Y+1,R25
    02919 8388      ST	Y,R24
    0291A 9120 054C LDS	R18,Result+10
    0291C 9130 054D LDS	R19,Result+11
    0291E E500      LDI	R16,0x50
    0291F E015      LDI	R17,5
    02920 940E 429F CALL	_itoa
(0270) Result.TempChar[6]='\0';
    02922 2422      CLR	R2
    02923 9220 0575 STS	Result+51,R2
(0271) Result.WSChar[5]='\0';
    02925 9220 057E STS	Result+60,R2
(0272) Result.WCIChar[6]='\0';
    02927 9220 0588 STS	Result+70,R2
(0273) Result.ECTChar[6]='\0';
    02929 9220 0592 STS	Result+80,R2
(0274) Result.TeqChar[6]='\0';
    0292B 9220 059C STS	Result+90,R2
(0275)  return ;
    0292D 9622      ADIW	R28,2
    0292E 940C 3F4D JMP	pop_xgset003C
_ftochr:
  status               --> Y,+2
  j                    --> R12
  lenth                --> R20
  res                  --> R12
  i                    --> R10
  dest                 --> R14
  a                    --> Y,+12
    02930 940E 3E28 CALL	push_arg4
    02932 940E 3F6F CALL	push_xgset30FC
    02934 9724      SBIW	R28,4
    02935 88E8      LDD	R14,Y+16
    02936 88F9      LDD	R15,Y+17
(0276) }
(0277) ////////////////////////////////////////////
(0278) //				字符串转换函数
(0279) //   浮点 到  字符串
(0280) ////////////////////////////////////////////
(0281) void ftochr(float a,char * dest){//float
(0282) char i=0,j=0,lenth;
(0283) int status;
(0284) char *res;
(0285)  res=ftoa(a,&status);  //float to ascii
    02937 01CE      MOVW	R24,R28
    02938 9602      ADIW	R24,2
    02939 8399      STD	Y+1,R25
    0293A 8388      ST	Y,R24
    0293B 850C      LDD	R16,Y+12
    0293C 851D      LDD	R17,Y+13
    0293D 852E      LDD	R18,Y+14
    0293E 853F      LDD	R19,Y+15
    0293F 940E 43C2 CALL	_ftoa
    02941 0168      MOVW	R12,R16
(0286) lenth=strlen(res);
    02942 940E 3E1C CALL	_strlen
    02944 2F40      MOV	R20,R16
(0287) 
(0288) for(i=0;i <lenth;i++) 
    02945 24AA      CLR	R10
    02946 C023      RJMP	0x296A
(0289)        {
(0290) 	   	dest[i]=res[i];
    02947 2DEA      MOV	R30,R10
    02948 27FF      CLR	R31
    02949 0DEC      ADD	R30,R12
    0294A 1DFD      ADC	R31,R13
    0294B 8020      LD	R2,Z
    0294C 2DEA      MOV	R30,R10
    0294D 27FF      CLR	R31
    0294E 0DEE      ADD	R30,R14
    0294F 1DFF      ADC	R31,R15
    02950 8220      ST	Z,R2
(0291) 
(0292) 		if( res[i]=='.'  ) 
    02951 2DEA      MOV	R30,R10
    02952 27FF      CLR	R31
    02953 0DEC      ADD	R30,R12
    02954 1DFD      ADC	R31,R13
    02955 8180      LD	R24,Z
    02956 328E      CPI	R24,0x2E
    02957 F489      BNE	0x2969
(0293) 			{
(0294) 				dest[i+1]=res[i+1];
    02958 2DEA      MOV	R30,R10
    02959 27FF      CLR	R31
    0295A 0DEC      ADD	R30,R12
    0295B 1DFD      ADC	R31,R13
    0295C 8021      LDD	R2,Z+1
    0295D 2DEA      MOV	R30,R10
    0295E 27FF      CLR	R31
    0295F 0DEE      ADD	R30,R14
    02960 1DFF      ADC	R31,R15
    02961 8221      STD	Z+1,R2
(0295) 					dest[i+2]='\0';
    02962 2DEA      MOV	R30,R10
    02963 27FF      CLR	R31
    02964 0DEE      ADD	R30,R14
    02965 1DFF      ADC	R31,R15
    02966 2422      CLR	R2
    02967 8222      STD	Z+2,R2
(0296) 						return ;    
    02968 C003      RJMP	0x296C
    02969 94A3      INC	R10
    0296A 16A4      CP	R10,R20
    0296B F2D8      BCS	0x2947
    0296C 9624      ADIW	R28,4
    0296D 940E 3F59 CALL	pop_xgset30FC
    0296F 9624      ADIW	R28,4
    02970 9508      RET
_itochr:
  dest                 --> R10
  a                    --> R12
    02971 940E 3F73 CALL	push_xgset003C
    02973 0159      MOVW	R10,R18
    02974 0168      MOVW	R12,R16
    02975 9722      SBIW	R28,2
(0297) 		    }
(0298)  
(0299)  		}
(0300) }
(0301) //////////////////////////////////////////////////////
(0302) //              整型数据变字符串
(0303) //    a  到  dest
(0304) ///////////////////////////////////////////////////////
(0305) void itochr(int a,char * dest){ //int to ascii
(0306) 	 itoa(dest,a,10); 
    02976 E08A      LDI	R24,0xA
    02977 E090      LDI	R25,0
    02978 8399      STD	Y+1,R25
    02979 8388      ST	Y,R24
    0297A 0196      MOVW	R18,R12
    0297B 0185      MOVW	R16,R10
    0297C 940E 429F CALL	_itoa
    0297E 9622      ADIW	R28,2
    0297F 940C 3F4D JMP	pop_xgset003C
_StructToChar:
  otherbyte            --> Y,+16
  ary                  --> Y,+0
  i                    --> R10
    02981 92AA      ST	-Y,R10
    02982 9768      SBIW	R28,0x18
(0307) }
(0308) //////////////////////////////////////////////////////
(0309) //                  结构体 变字符串
(0310) // 将目前存于结构体的数据转换到Temp_Char中。
(0311) ///////////////////////////////////////////////////////
(0312) void  StructToChar(void)
(0313) { 
(0314)   unsigned char i;
(0315)   char otherbyte[]="0\t0\t0\t0";
    02983 EB80      LDI	R24,0xB0
    02984 E091      LDI	R25,1
    02985 01FE      MOVW	R30,R28
    02986 9670      ADIW	R30,0x10
    02987 E008      LDI	R16,0x8
    02988 E010      LDI	R17,0
    02989 93FA      ST	-Y,R31
    0298A 93EA      ST	-Y,R30
    0298B 939A      ST	-Y,R25
    0298C 938A      ST	-Y,R24
    0298D 940E 4014 CALL	asgnblk
(0316)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    0298F EB88      LDI	R24,0xB8
    02990 E091      LDI	R25,1
    02991 01FE      MOVW	R30,R28
    02992 E100      LDI	R16,0x10
    02993 E010      LDI	R17,0
    02994 93FA      ST	-Y,R31
    02995 93EA      ST	-Y,R30
    02996 939A      ST	-Y,R25
    02997 938A      ST	-Y,R24
    02998 940E 4014 CALL	asgnblk
(0317)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0318) 				Result.TeqChar
(0319) 			   };  //指向数组首地址的指针
(0320)   //strcat(Temp_Char,Result.Name);
(0321)   for(i=0;i<=80;i++) TempChar[i]='\0';  //清空数组
    0299A 24AA      CLR	R10
    0299B C009      RJMP	0x29A5
    0299C EF82      LDI	R24,0xF2
    0299D E094      LDI	R25,4
    0299E 2DEA      MOV	R30,R10
    0299F 27FF      CLR	R31
    029A0 0FE8      ADD	R30,R24
    029A1 1FF9      ADC	R31,R25
    029A2 2422      CLR	R2
    029A3 8220      ST	Z,R2
    029A4 94A3      INC	R10
    029A5 E580      LDI	R24,0x50
    029A6 158A      CP	R24,R10
    029A7 F7A0      BCC	0x299C
(0322)     for(i=0;i<=7;i++){
    029A8 24AA      CLR	R10
    029A9 C014      RJMP	0x29BE
(0323) 		strcat(TempChar,ary[i]);  // 按顺序复制字符串
    029AA 01CE      MOVW	R24,R28
    029AB 2DEA      MOV	R30,R10
    029AC 27FF      CLR	R31
    029AD 0FEE      LSL	R30
    029AE 1FFF      ROL	R31
    029AF 0FE8      ADD	R30,R24
    029B0 1FF9      ADC	R31,R25
    029B1 8120      LD	R18,Z
    029B2 8131      LDD	R19,Z+1
    029B3 EF02      LDI	R16,0xF2
    029B4 E014      LDI	R17,4
    029B5 940E 3E0F CALL	_strcat
(0324) 		strcat(TempChar,tab);     // 字串结尾加上制表符
    029B7 E02F      LDI	R18,0xF
    029B8 E031      LDI	R19,1
    029B9 EF02      LDI	R16,0xF2
    029BA E014      LDI	R17,4
    029BB 940E 3E0F CALL	_strcat
    029BD 94A3      INC	R10
    029BE E087      LDI	R24,7
    029BF 158A      CP	R24,R10
    029C0 F748      BCC	0x29AA
(0325)     }
(0326) 				 
(0327) 				 otherbyte[0]=otherbyte[0]+Result.WeiHai;
    029C1 9020 059C LDS	R2,Result+90
    029C3 8838      LDD	R3,Y+16
    029C4 0C32      ADD	R3,R2
    029C5 8A38      STD	Y+16,R3
(0328) 				 otherbyte[2]=otherbyte[0]+Result.LowLabor;
    029C6 9020 059D LDS	R2,Result+91
    029C8 0C32      ADD	R3,R2
    029C9 8A3A      STD	Y+18,R3
(0329) 				 otherbyte[4]=otherbyte[0]+Result.MidLabor;
    029CA 9020 059E LDS	R2,Result+92
    029CC 8838      LDD	R3,Y+16
    029CD 0C32      ADD	R3,R2
    029CE 8A3C      STD	Y+20,R3
(0330) 				 otherbyte[6]=otherbyte[0]+Result.HighLabor;
    029CF 9020 059F LDS	R2,Result+93
    029D1 8838      LDD	R3,Y+16
    029D2 0C32      ADD	R3,R2
    029D3 8A3E      STD	Y+22,R3
(0331)  
(0332)   strcat(TempChar,otherbyte);  
    029D4 019E      MOVW	R18,R28
    029D5 5F20      SUBI	R18,0xF0
    029D6 4F3F      SBCI	R19,0xFF
    029D7 EF02      LDI	R16,0xF2
    029D8 E014      LDI	R17,4
    029D9 940E 3E0F CALL	_strcat
(0333)   strcat(TempChar,enter);  
    029DB E122      LDI	R18,0x12
    029DC E031      LDI	R19,1
    029DD EF02      LDI	R16,0xF2
    029DE E014      LDI	R17,4
    029DF 940E 3E0F CALL	_strcat
(0334)   strcat(TempChar,"\0\0");
    029E1 ED2F      LDI	R18,0xDF
    029E2 E031      LDI	R19,1
    029E3 EF02      LDI	R16,0xF2
    029E4 E014      LDI	R17,4
    029E5 940E 3E0F CALL	_strcat
    029E7 9668      ADIW	R28,0x18
    029E8 90A9      LD	R10,Y+
    029E9 9508      RET
_CharToStruct:
  Temp_Char            --> Y,+16
  i                    --> R20
  ary                  --> Y,+0
  j                    --> R14
  p                    --> R10
  q                    --> R12
    029EA 940E 3F6F CALL	push_xgset30FC
    029EC 97EF      SBIW	R28,0x3F
    029ED 97A1      SBIW	R28,0x21
(0335) }
(0336) 
(0337) //////////////////////////////////////////////////////
(0338) //               字符串  变  结构体
(0339) // 
(0340) ///////////////////////////////////////////////////////
(0341) void CharToStruct(void)
(0342) {
(0343)   unsigned char i=0,j=0;
    029EE 2744      CLR	R20
    029EF 24EE      CLR	R14
(0344)   unsigned char *p,*q;
(0345)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    029F0 EC88      LDI	R24,0xC8
    029F1 E091      LDI	R25,1
    029F2 01FE      MOVW	R30,R28
    029F3 E100      LDI	R16,0x10
    029F4 E010      LDI	R17,0
    029F5 93FA      ST	-Y,R31
    029F6 93EA      ST	-Y,R30
    029F7 939A      ST	-Y,R25
    029F8 938A      ST	-Y,R24
    029F9 940E 4014 CALL	asgnblk
(0346)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0347) 				Result.TeqChar
(0348) 			   };  //指向数组首地址的指针
(0349)   char Temp_Char[80];
(0350)     p=ary[j];
    029FB 01CE      MOVW	R24,R28
    029FC 2DEE      MOV	R30,R14
    029FD 27FF      CLR	R31
    029FE 0FEE      LSL	R30
    029FF 1FFF      ROL	R31
    02A00 0FE8      ADD	R30,R24
    02A01 1FF9      ADC	R31,R25
    02A02 80A0      LD	R10,Z
    02A03 80B1      LDD	R11,Z+1
(0351) 	q=Temp_Char;
    02A04 01CE      MOVW	R24,R28
    02A05 9640      ADIW	R24,0x10
    02A06 016C      MOVW	R12,R24
    02A07 C01D      RJMP	0x2A25
(0352) 	while(1){
(0353)     if(*q =='\n') {*p='\0'; return;} ;
    02A08 01F6      MOVW	R30,R12
    02A09 8180      LD	R24,Z
    02A0A 308A      CPI	R24,0xA
    02A0B F421      BNE	0x2A10
    02A0C 2422      CLR	R2
    02A0D 01F5      MOVW	R30,R10
    02A0E 8220      ST	Z,R2
    02A0F C016      RJMP	0x2A26
(0354) 	if(*q =='\t') {j++;p=ary[j];i=0;}
    02A10 01F6      MOVW	R30,R12
    02A11 8180      LD	R24,Z
    02A12 3089      CPI	R24,0x9
    02A13 F459      BNE	0x2A1F
    02A14 94E3      INC	R14
    02A15 01CE      MOVW	R24,R28
    02A16 2DEE      MOV	R30,R14
    02A17 27FF      CLR	R31
    02A18 0FEE      LSL	R30
    02A19 1FFF      ROL	R31
    02A1A 0FE8      ADD	R30,R24
    02A1B 1FF9      ADC	R31,R25
    02A1C 80A0      LD	R10,Z
    02A1D 80B1      LDD	R11,Z+1
    02A1E 2744      CLR	R20
(0355)     *p++=*q++;
    02A1F 01F6      MOVW	R30,R12
    02A20 01D5      MOVW	R26,R10
    02A21 9001      LD	R0,Z+
    02A22 016F      MOVW	R12,R30
    02A23 920D      ST	X+,R0
    02A24 015D      MOVW	R10,R26
    02A25 CFE2      RJMP	0x2A08
    02A26 96EF      ADIW	R28,0x3F
    02A27 96A1      ADIW	R28,0x21
    02A28 940C 3F59 JMP	pop_xgset30FC
_get_name:
  i                    --> R20
  filenamep            --> R16
    02A2A 940E 3F82 CALL	push_xgsetF000
(0356) 	}
(0357)   }
(0358)  
(0359)  ////////////////////////////////////////////
(0360) //				根据当前日期获取文件名
(0361) //   
(0362) ////////////////////////////////////////////
(0363) char *get_name( char filenamep[] ){     
(0364) 	  unsigned char i=0;
(0365)  	  for(i=0;i<6;i++) {
    02A2C 2744      CLR	R20
    02A2D C00D      RJMP	0x2A3B
(0366) 	  				    *(filenamep+i)=Result.Date[i];
    02A2E E588      LDI	R24,0x58
    02A2F E095      LDI	R25,5
    02A30 2FE4      MOV	R30,R20
    02A31 27FF      CLR	R31
    02A32 0FE8      ADD	R30,R24
    02A33 1FF9      ADC	R31,R25
    02A34 8020      LD	R2,Z
    02A35 2FE4      MOV	R30,R20
    02A36 27FF      CLR	R31
    02A37 0FE0      ADD	R30,R16
    02A38 1FF1      ADC	R31,R17
    02A39 8220      ST	Z,R2
    02A3A 9543      INC	R20
    02A3B 3046      CPI	R20,6
    02A3C F388      BCS	0x2A2E
(0367) 	  				   } 
(0368) 	 	*(filenamep+(i++))='.';
    02A3D 2E24      MOV	R2,R20
    02A3E 2433      CLR	R3
    02A3F 5F4F      SUBI	R20,0xFF
    02A40 2DE2      MOV	R30,R2
    02A41 27FF      CLR	R31
    02A42 0FE0      ADD	R30,R16
    02A43 1FF1      ADC	R31,R17
    02A44 E28E      LDI	R24,0x2E
    02A45 8380      ST	Z,R24
(0369) 		*(filenamep+(i++))='x';
    02A46 2E24      MOV	R2,R20
    02A47 2433      CLR	R3
    02A48 5F4F      SUBI	R20,0xFF
    02A49 2DE2      MOV	R30,R2
    02A4A 27FF      CLR	R31
    02A4B 0FE0      ADD	R30,R16
    02A4C 1FF1      ADC	R31,R17
    02A4D E788      LDI	R24,0x78
    02A4E 8380      ST	Z,R24
(0370) 		*(filenamep+(i++))='l';
    02A4F 2F64      MOV	R22,R20
    02A50 2777      CLR	R23
    02A51 5F4F      SUBI	R20,0xFF
    02A52 2FE6      MOV	R30,R22
    02A53 27FF      CLR	R31
    02A54 0FE0      ADD	R30,R16
    02A55 1FF1      ADC	R31,R17
    02A56 E68C      LDI	R24,0x6C
    02A57 8380      ST	Z,R24
(0371) 		*(filenamep+(i++))='s';
    02A58 2F64      MOV	R22,R20
    02A59 2777      CLR	R23
    02A5A 5F4F      SUBI	R20,0xFF
    02A5B 2FE6      MOV	R30,R22
    02A5C 27FF      CLR	R31
    02A5D 0FE0      ADD	R30,R16
    02A5E 1FF1      ADC	R31,R17
    02A5F E783      LDI	R24,0x73
    02A60 8380      ST	Z,R24
(0372) 		*(filenamep+(i))='\0';
    02A61 2FE4      MOV	R30,R20
    02A62 27FF      CLR	R31
    02A63 0FE0      ADD	R30,R16
    02A64 1FF1      ADC	R31,R17
    02A65 2422      CLR	R2
    02A66 8220      ST	Z,R2
(0373) 					   
(0374)       return filenamep;
    02A67 940C 3F87 JMP	pop_xgsetF000
_SquareRootFloat:
  f                    --> Y,+12
  x                    --> Y,+8
  i                    --> Y,+4
  y                    --> Y,+0
  number               --> Y,+20
    02A69 940E 3E28 CALL	push_arg4
    02A6B 940E 3F82 CALL	push_xgsetF000
    02A6D 9760      SBIW	R28,0x10
(0375) } 
(0376) float SquareRootFloat(float number)
(0377) {
(0378)     long i;
(0379)     float x, y;
(0380)     const float f = 1.5F;
    02A6E E900      LDI	R16,0x90
    02A6F E010      LDI	R17,0
    02A70 940E 3EF5 CALL	elpm32
    02A72 870C      STD	Y+12,R16
    02A73 871D      STD	Y+13,R17
    02A74 872E      STD	Y+14,R18
    02A75 873F      STD	Y+15,R19
(0381)     x = number * 0.5F;
    02A76 E80C      LDI	R16,0x8C
    02A77 E010      LDI	R17,0
    02A78 940E 3EF5 CALL	elpm32
    02A7A 01CE      MOVW	R24,R28
    02A7B 9644      ADIW	R24,0x14
    02A7C 939A      ST	-Y,R25
    02A7D 938A      ST	-Y,R24
    02A7E 940E 4264 CALL	fpmule1
    02A80 8708      STD	Y+8,R16
    02A81 8719      STD	Y+9,R17
    02A82 872A      STD	Y+10,R18
    02A83 873B      STD	Y+11,R19
(0382)     y  = number;
    02A84 882C      LDD	R2,Y+20
    02A85 883D      LDD	R3,Y+21
    02A86 884E      LDD	R4,Y+22
    02A87 885F      LDD	R5,Y+23
    02A88 8228      ST	Y,R2
    02A89 8239      STD	Y+1,R3
    02A8A 824A      STD	Y+2,R4
    02A8B 825B      STD	Y+3,R5
(0383)     i  = * ( long * ) &y;
    02A8C 01FE      MOVW	R30,R28
    02A8D 8020      LD	R2,Z
    02A8E 8031      LDD	R3,Z+1
    02A8F 8042      LDD	R4,Z+2
    02A90 8053      LDD	R5,Z+3
    02A91 822C      STD	Y+4,R2
    02A92 823D      STD	Y+5,R3
    02A93 824E      STD	Y+6,R4
    02A94 825F      STD	Y+7,R5
(0384)     i  = 0x5f3759df - ( i >> 1 );  //卡马克
    02A95 802C      LDD	R2,Y+4
    02A96 803D      LDD	R3,Y+5
    02A97 804E      LDD	R4,Y+6
    02A98 805F      LDD	R5,Y+7
    02A99 9455      ASR	R5
    02A9A 9447      ROR	R4
    02A9B 9437      ROR	R3
    02A9C 9427      ROR	R2
    02A9D ED4F      LDI	R20,0xDF
    02A9E E559      LDI	R21,0x59
    02A9F E367      LDI	R22,0x37
    02AA0 E57F      LDI	R23,0x5F
    02AA1 1942      SUB	R20,R2
    02AA2 0953      SBC	R21,R3
    02AA3 0964      SBC	R22,R4
    02AA4 0975      SBC	R23,R5
    02AA5 834C      STD	Y+4,R20
    02AA6 835D      STD	Y+5,R21
    02AA7 836E      STD	Y+6,R22
    02AA8 837F      STD	Y+7,R23
(0385)   //i  = 0x5f375a86 - ( i >> 1 );  //Lomont
(0386)     y  = * ( float * ) &i;
    02AA9 01FE      MOVW	R30,R28
    02AAA 9634      ADIW	R30,4
    02AAB 8020      LD	R2,Z
    02AAC 8031      LDD	R3,Z+1
    02AAD 8042      LDD	R4,Z+2
    02AAE 8053      LDD	R5,Z+3
    02AAF 8228      ST	Y,R2
    02AB0 8239      STD	Y+1,R3
    02AB1 824A      STD	Y+2,R4
    02AB2 825B      STD	Y+3,R5
(0387)     y  = y * ( f - ( x * y * y ) );
    02AB3 8028      LD	R2,Y
    02AB4 8039      LDD	R3,Y+1
    02AB5 804A      LDD	R4,Y+2
    02AB6 805B      LDD	R5,Y+3
    02AB7 846C      LDD	R6,Y+12
    02AB8 847D      LDD	R7,Y+13
    02AB9 848E      LDD	R8,Y+14
    02ABA 849F      LDD	R9,Y+15
    02ABB 8508      LDD	R16,Y+8
    02ABC 8519      LDD	R17,Y+9
    02ABD 852A      LDD	R18,Y+10
    02ABE 853B      LDD	R19,Y+11
    02ABF 01CE      MOVW	R24,R28
    02AC0 939A      ST	-Y,R25
    02AC1 938A      ST	-Y,R24
    02AC2 940E 4264 CALL	fpmule1
    02AC4 01CE      MOVW	R24,R28
    02AC5 939A      ST	-Y,R25
    02AC6 938A      ST	-Y,R24
    02AC7 940E 4279 CALL	fpmule1x
    02AC9 0183      MOVW	R16,R6
    02ACA 0194      MOVW	R18,R8
    02ACB 940E 40B9 CALL	fpsub2x
    02ACD 0181      MOVW	R16,R2
    02ACE 0192      MOVW	R18,R4
    02ACF 940E 426E CALL	fpmule2
    02AD1 8308      ST	Y,R16
    02AD2 8319      STD	Y+1,R17
    02AD3 832A      STD	Y+2,R18
    02AD4 833B      STD	Y+3,R19
(0388)     y  = y * ( f - ( x * y * y ) );
    02AD5 8028      LD	R2,Y
    02AD6 8039      LDD	R3,Y+1
    02AD7 804A      LDD	R4,Y+2
    02AD8 805B      LDD	R5,Y+3
    02AD9 846C      LDD	R6,Y+12
    02ADA 847D      LDD	R7,Y+13
    02ADB 848E      LDD	R8,Y+14
    02ADC 849F      LDD	R9,Y+15
    02ADD 8508      LDD	R16,Y+8
    02ADE 8519      LDD	R17,Y+9
    02ADF 852A      LDD	R18,Y+10
    02AE0 853B      LDD	R19,Y+11
    02AE1 01CE      MOVW	R24,R28
    02AE2 939A      ST	-Y,R25
    02AE3 938A      ST	-Y,R24
    02AE4 940E 4264 CALL	fpmule1
    02AE6 01CE      MOVW	R24,R28
    02AE7 939A      ST	-Y,R25
    02AE8 938A      ST	-Y,R24
    02AE9 940E 4279 CALL	fpmule1x
    02AEB 0183      MOVW	R16,R6
    02AEC 0194      MOVW	R18,R8
    02AED 940E 40B9 CALL	fpsub2x
    02AEF 0181      MOVW	R16,R2
    02AF0 0192      MOVW	R18,R4
    02AF1 940E 426E CALL	fpmule2
    02AF3 8308      ST	Y,R16
    02AF4 8319      STD	Y+1,R17
    02AF5 832A      STD	Y+2,R18
    02AF6 833B      STD	Y+3,R19
(0389)     return number * y;
    02AF7 890C      LDD	R16,Y+20
    02AF8 891D      LDD	R17,Y+21
    02AF9 892E      LDD	R18,Y+22
    02AFA 893F      LDD	R19,Y+23
    02AFB 01CE      MOVW	R24,R28
    02AFC 939A      ST	-Y,R25
    02AFD 938A      ST	-Y,R24
    02AFE 940E 4264 CALL	fpmule1
    02B00 9660      ADIW	R28,0x10
    02B01 940E 3F87 CALL	pop_xgsetF000
    02B03 9624      ADIW	R28,4
    02B04 9508      RET
_debug:
  str2                 --> Y,+0
  val                  --> R10
  str                  --> R12
    02B05 940E 3F73 CALL	push_xgset003C
    02B07 2EA2      MOV	R10,R18
    02B08 0168      MOVW	R12,R16
    02B09 9724      SBIW	R28,4
(0390) } 
(0391) //
(0392) //###############################################################//
(0393) //debug
(0394) void debug(UINT8 *str,UINT8 val)
(0395) {
(0396)  UINT8 str2[4]={0,0,0,0};
    02B0A ED88      LDI	R24,0xD8
    02B0B E091      LDI	R25,1
    02B0C 01FE      MOVW	R30,R28
    02B0D E004      LDI	R16,4
    02B0E E010      LDI	R17,0
    02B0F 93FA      ST	-Y,R31
    02B10 93EA      ST	-Y,R30
    02B11 939A      ST	-Y,R25
    02B12 938A      ST	-Y,R24
    02B13 940E 4014 CALL	asgnblk
(0397)  str=str;
(0398)  val=val;
(0399)  #ifdef _UARTDEBUG
(0400)  PrintString("\r\n");
    02B15 ED0C      LDI	R16,0xDC
    02B16 E011      LDI	R17,1
    02B17 940E 35FE CALL	_PrintString
(0401)  PrintString(str);
    02B19 0186      MOVW	R16,R12
    02B1A 940E 35FE CALL	_PrintString
(0402)  PrintChar(val);
    02B1C 2D0A      MOV	R16,R10
    02B1D 940E 3768 CALL	_PrintChar
    02B1F 9624      ADIW	R28,4
    02B20 940C 3F4D JMP	pop_xgset003C
_SD_Write_cmd:
  k                    --> R22
  temp                 --> R20
  p                    --> R20
    02B22 940E 3F82 CALL	push_xgsetF000
    02B24 01A8      MOVW	R20,R16
FILE: D:\LQD\software\master\software_src\sd.c
(0001) //*****************************************************************************//
(0002) //*								数码相框
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SD卡控制
(0006) //*修改者：  桃子
(0007) //*****************************************************************************//
(0008) #include "sd.h"
(0009) 
(0010) //****************************************************************
(0011) //*隶属模块：SD卡控制
(0012) //*函数功能：写6字节数据
(0013) //****************************************************************
(0014) UINT8 SD_Write_cmd(UINT8 *p)
(0015) {	
(0016) 	UINT16 temp,k=0;
    02B25 2766      CLR	R22
    02B26 2777      CLR	R23
(0017) 	SD_CS_DIS();//禁止SPI
    02B27 9AC0      SBI	0x18,0
(0018) 	SPI_Read();//空读一字节
    02B28 940E 3796 CALL	_SPI_Read
(0019) 	SD_CS_EN();//使能SPI
    02B2A 98C0      CBI	0x18,0
(0020) 
(0021) 	SPI_Write(p[0]);
    02B2B 01FA      MOVW	R30,R20
    02B2C 8100      LD	R16,Z
    02B2D 940E 3792 CALL	_SPI_Write
(0022) 	SPI_Write(p[1]);
    02B2F 01FA      MOVW	R30,R20
    02B30 8101      LDD	R16,Z+1
    02B31 940E 3792 CALL	_SPI_Write
(0023) 	SPI_Write(p[2]);
    02B33 01FA      MOVW	R30,R20
    02B34 8102      LDD	R16,Z+2
    02B35 940E 3792 CALL	_SPI_Write
(0024) 	SPI_Write(p[3]);
    02B37 01FA      MOVW	R30,R20
    02B38 8103      LDD	R16,Z+3
    02B39 940E 3792 CALL	_SPI_Write
(0025) 	SPI_Write(p[4]);
    02B3B 01FA      MOVW	R30,R20
    02B3C 8104      LDD	R16,Z+4
    02B3D 940E 3792 CALL	_SPI_Write
(0026) 	SPI_Write(p[5]);
    02B3F 01FA      MOVW	R30,R20
    02B40 8105      LDD	R16,Z+5
    02B41 940E 3792 CALL	_SPI_Write
(0027) 
(0028) 	do 
(0029)  	{  
(0030)   		temp = SPI_Read();//一直读，直到读到的不是0xff或超时
    02B43 940E 3796 CALL	_SPI_Read
    02B45 2F40      MOV	R20,R16
    02B46 2755      CLR	R21
(0031)  		k++;
    02B47 5F6F      SUBI	R22,0xFF
    02B48 4F7F      SBCI	R23,0xFF
(0032)  	}while((temp==0xff)&&(k<TRY_TIME)); 
    02B49 3F4F      CPI	R20,0xFF
    02B4A E0E0      LDI	R30,0
    02B4B 075E      CPC	R21,R30
    02B4C F421      BNE	0x2B51
    02B4D 3164      CPI	R22,0x14
    02B4E E0E0      LDI	R30,0
    02B4F 077E      CPC	R23,R30
    02B50 F390      BCS	0x2B43
(0033) 
(0034) 	return temp;
    02B51 2F04      MOV	R16,R20
    02B52 940C 3F87 JMP	pop_xgsetF000
_SD_Init:
  pcmd                 --> Y,+0
  temp                 --> R22
  time                 --> R20
    02B54 940E 3F8C CALL	push_xgsetF00C
    02B56 9726      SBIW	R28,6
(0035) }
(0036) //****************************************************************
(0037) //*隶属模块：SD卡控制
(0038) //*函数功能：初始化
(0039) //****************************************************************
(0040) UINT8 SD_Init(void)	
(0041) {  
(0042) 	UINT8 time=0,temp=0;
    02B57 2744      CLR	R20
    02B58 2766      CLR	R22
(0043) 	UINT8 pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; //命令0的字节序列
    02B59 E581      LDI	R24,0x51
    02B5A E092      LDI	R25,2
    02B5B 01FE      MOVW	R30,R28
    02B5C E006      LDI	R16,6
    02B5D E010      LDI	R17,0
    02B5E 93FA      ST	-Y,R31
    02B5F 93EA      ST	-Y,R30
    02B60 939A      ST	-Y,R25
    02B61 938A      ST	-Y,R24
    02B62 940E 4014 CALL	asgnblk
(0044) 	if(SD_DET()==0) return 0x02; //no disk
    02B64 B181      IN	R24,0x01
    02B65 9586      LSR	R24
    02B66 9586      LSR	R24
    02B67 9586      LSR	R24
    02B68 9586      LSR	R24
    02B69 9586      LSR	R24
    02B6A 7081      ANDI	R24,1
    02B6B F421      BNE	0x2B70
    02B6C E081      LDI	R24,1
    02B6D E090      LDI	R25,0
    02B6E 015C      MOVW	R10,R24
    02B6F C002      RJMP	0x2B72
    02B70 24AA      CLR	R10
    02B71 24BB      CLR	R11
    02B72 20AA      TST	R10
    02B73 F421      BNE	0x2B78
    02B74 20BB      TST	R11
    02B75 F411      BNE	0x2B78
    02B76 E002      LDI	R16,2
    02B77 C039      RJMP	0x2BB1
(0045) 	SD_PORT |= (1<<SD_CS);
    02B78 9AC0      SBI	0x18,0
(0046) 	SD_DDR |= (1<<SD_CS);
    02B79 9AB8      SBI	0x17,0
(0047) 
(0048) 	SPI_IO_Init();
    02B7A 940E 3788 CALL	_SPI_IO_Init
(0049) 	SPI_Low();
    02B7C E582      LDI	R24,0x52
    02B7D B98D      OUT	0x0D,R24
    02B7E B18E      IN	R24,0x0E
    02B7F 7F8F      ANDI	R24,0xFF
    02B80 B98E      OUT	0x0E,R24
(0050) 
(0051) 	SD_CS_DIS();  //关闭片选 
    02B81 9AC0      SBI	0x18,0
(0052) 	for(time=0;time<10;time++) //初始时，首先要发送最少74个时钟信号，这是必须的！！！
    02B82 2744      CLR	R20
    02B83 C003      RJMP	0x2B87
(0053) 	{
(0054)   		SPI_Read(); 
    02B84 940E 3796 CALL	_SPI_Read
    02B86 9543      INC	R20
    02B87 304A      CPI	R20,0xA
    02B88 F3D8      BCS	0x2B84
(0055) 	}
(0056) 	SD_CS_EN(); //打开片选
    02B89 98C0      CBI	0x18,0
(0057) 	time = 0;
    02B8A 2744      CLR	R20
(0058) 	do
(0059) 	{ 
(0060) 		temp=SD_Write_cmd(pcmd);//写入CMD0
    02B8B 018E      MOVW	R16,R28
    02B8C DF95      RCALL	_SD_Write_cmd
    02B8D 2F60      MOV	R22,R16
(0061) 	 	time++;
    02B8E 9543      INC	R20
(0062) 	 	if(time==TRY_TIME) 
    02B8F 3144      CPI	R20,0x14
    02B90 F419      BNE	0x2B94
(0063) 	 	{ 
(0064) 	  		SD_CS_DIS(); //关闭片选
    02B91 9AC0      SBI	0x18,0
(0065) 	  		return(INIT_CMD0_ERROR);//CMD0写入失败
    02B92 E001      LDI	R16,1
    02B93 C01D      RJMP	0x2BB1
(0066) 	 	}
(0067) 	 }while(temp!=0x01);
    02B94 3061      CPI	R22,1
    02B95 F7A9      BNE	0x2B8B
(0068) 
(0069) 	SD_CS_DIS(); //关闭片选
    02B96 9AC0      SBI	0x18,0
(0070) 	SPI_Read(); //按照SD卡的操作时序在这里补8个时钟 
    02B97 940E 3796 CALL	_SPI_Read
(0071) 	SD_CS_EN(); //打开片选
    02B99 98C0      CBI	0x18,0
(0072) 
(0073) 	pcmd[0]=0x41,pcmd[5]=0xff;
    02B9A E481      LDI	R24,0x41
    02B9B 8388      ST	Y,R24
    02B9C EF8F      LDI	R24,0xFF
    02B9D 838D      STD	Y+5,R24
(0074) 	time = 0;
    02B9E 2744      CLR	R20
(0075) 	do
(0076) 	{ 
(0077) 		temp=SD_Write_cmd(pcmd);
    02B9F 018E      MOVW	R16,R28
    02BA0 DF81      RCALL	_SD_Write_cmd
    02BA1 2F60      MOV	R22,R16
(0078) 		time++;
    02BA2 9543      INC	R20
(0079) 		if(time==TRY_TIME) 
    02BA3 3144      CPI	R20,0x14
    02BA4 F419      BNE	0x2BA8
(0080) 		{ 
(0081) 		 	SD_CS_DIS(); //关闭片选
    02BA5 9AC0      SBI	0x18,0
(0082) 			 return(INIT_CMD1_ERROR);//CMD1写入失败
    02BA6 E002      LDI	R16,2
    02BA7 C009      RJMP	0x2BB1
(0083) 		 }
(0084) 	 }while(temp!=0);
    02BA8 2366      TST	R22
    02BA9 F7A9      BNE	0x2B9F
(0085)   
(0086) 	 SPI_High();  
    02BAA E580      LDI	R24,0x50
    02BAB B98D      OUT	0x0D,R24
    02BAC 9A70      SBI	0x0E,0
(0087) 	 SD_CS_DIS();  //关闭片选 
    02BAD 9AC0      SBI	0x18,0
(0088) 	 SPI_Read(); //按照SD卡的操作时序在这里补8个时钟
    02BAE 940E 3796 CALL	_SPI_Read
(0089) 	 return SD_TURE; //返回0,说明初始化操作成功
    02BB0 2700      CLR	R16
    02BB1 9626      ADIW	R28,6
    02BB2 940C 3F93 JMP	pop_xgsetF00C
_SD_Write_Sector:
  pcmd                 --> Y,+0
  time                 --> R12
  temp                 --> R20
  i                    --> R22
  buffer               --> R10
  addr                 --> Y,+14
    02BB4 940E 3E28 CALL	push_arg4
    02BB6 940E 3FA8 CALL	push_xgsetF03C
    02BB8 9726      SBIW	R28,6
    02BB9 88AA      LDD	R10,Y+18
    02BBA 88BB      LDD	R11,Y+19
(0090) } 
(0091) //****************************************************************
(0092) //*隶属模块：SD卡控制
(0093) //*函数功能：写512字节数据（一扇区字节）
(0094) //****************************************************************
(0095) UINT16 SD_Write_Sector(UINT32 addr,UINT8 *buffer)
(0096) {  
(0097) 	UINT8 temp=0,time=0;
    02BBB 2744      CLR	R20
    02BBC 24CC      CLR	R12
(0098) 	UINT16 i=0;
    02BBD 2766      CLR	R22
    02BBE 2777      CLR	R23
(0099) 	UINT8 pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //向SD卡中单个块（512字节，一个扇区）写入数据，用CMD24
    02BBF E587      LDI	R24,0x57
    02BC0 E092      LDI	R25,2
    02BC1 01FE      MOVW	R30,R28
    02BC2 E006      LDI	R16,6
    02BC3 E010      LDI	R17,0
    02BC4 93FA      ST	-Y,R31
    02BC5 93EA      ST	-Y,R30
    02BC6 939A      ST	-Y,R25
    02BC7 938A      ST	-Y,R24
    02BC8 940E 4014 CALL	asgnblk
(0100) 
(0101) 	 addr<<=9; //将块地址（扇区地址）转为字节地址 ［这里就限制了SD卡的最大容量为4G］
    02BCA E089      LDI	R24,0x9
    02BCB E090      LDI	R25,0
    02BCC 850E      LDD	R16,Y+14
    02BCD 851F      LDD	R17,Y+15
    02BCE 8928      LDD	R18,Y+16
    02BCF 8939      LDD	R19,Y+17
    02BD0 938A      ST	-Y,R24
    02BD1 940E 3FEF CALL	lsl32
    02BD3 870E      STD	Y+14,R16
    02BD4 871F      STD	Y+15,R17
    02BD5 8B28      STD	Y+16,R18
    02BD6 8B39      STD	Y+17,R19
(0102) 
(0103) 	 pcmd[1]=(addr>>24); //将字节地址写入到CMD24字节序列中
    02BD7 E188      LDI	R24,0x18
    02BD8 E090      LDI	R25,0
    02BD9 850E      LDD	R16,Y+14
    02BDA 851F      LDD	R17,Y+15
    02BDB 8928      LDD	R18,Y+16
    02BDC 8939      LDD	R19,Y+17
    02BDD 938A      ST	-Y,R24
    02BDE 940E 4008 CALL	lsr32
    02BE0 8309      STD	Y+1,R16
(0104) 	 pcmd[2]=(addr>>16);
    02BE1 842E      LDD	R2,Y+14
    02BE2 843F      LDD	R3,Y+15
    02BE3 8848      LDD	R4,Y+16
    02BE4 8859      LDD	R5,Y+17
    02BE5 0112      MOVW	R2,R4
    02BE6 2444      CLR	R4
    02BE7 2455      CLR	R5
    02BE8 822A      STD	Y+2,R2
(0105) 	 pcmd[3]=(addr>>8);
    02BE9 E088      LDI	R24,0x8
    02BEA E090      LDI	R25,0
    02BEB 850E      LDD	R16,Y+14
    02BEC 851F      LDD	R17,Y+15
    02BED 8928      LDD	R18,Y+16
    02BEE 8939      LDD	R19,Y+17
    02BEF 938A      ST	-Y,R24
    02BF0 940E 4008 CALL	lsr32
    02BF2 830B      STD	Y+3,R16
(0106) 	// pcmd[4]=offset;	
(0107) 	 SD_CS_EN();//打开SD卡片选
    02BF3 98C0      CBI	0x18,0
(0108) 
(0109) 	 do
(0110) 	 {  
(0111) 		temp=SD_Write_cmd(pcmd);
    02BF4 018E      MOVW	R16,R28
    02BF5 DF2C      RCALL	_SD_Write_cmd
    02BF6 2F40      MOV	R20,R16
(0112)   		time++;
    02BF7 94C3      INC	R12
(0113)   		if(time==TRY_TIME) 
    02BF8 2D8C      MOV	R24,R12
    02BF9 3184      CPI	R24,0x14
    02BFA F419      BNE	0x2BFE
(0114)   		{ 
(0115)    			SD_CS_DIS(); //关闭片选
    02BFB 9AC0      SBI	0x18,0
(0116)    			return(temp); //命令写入失败
    02BFC 2711      CLR	R17
    02BFD C037      RJMP	0x2C35
(0117)   		}
(0118) 	}while(temp!=0); 
    02BFE 2344      TST	R20
    02BFF F7A1      BNE	0x2BF4
(0119) 
(0120) 	for(i=0;i<100;i++) //这里要插入若干时钟信号
    02C00 2766      CLR	R22
    02C01 2777      CLR	R23
    02C02 C004      RJMP	0x2C07
(0121)   		SPI_Read();
    02C03 940E 3796 CALL	_SPI_Read
    02C05 5F6F      SUBI	R22,0xFF
    02C06 4F7F      SBCI	R23,0xFF
    02C07 3664      CPI	R22,0x64
    02C08 E0E0      LDI	R30,0
    02C09 077E      CPC	R23,R30
    02C0A F3C0      BCS	0x2C03
(0122) 	
(0123) 	SPI_Write(0xfe);//写入开始字节 0xfe，后面就是要写入的512个字节的数据	
    02C0B EF0E      LDI	R16,0xFE
    02C0C 940E 3792 CALL	_SPI_Write
(0124) 	
(0125) 	for(i=0;i<512;i++) //将缓冲区中要写入的512个字节写入SD卡
    02C0E 2766      CLR	R22
    02C0F 2777      CLR	R23
    02C10 C007      RJMP	0x2C18
(0126) 		SPI_Write(*buffer++);
    02C11 01F5      MOVW	R30,R10
    02C12 9101      LD	R16,Z+
    02C13 015F      MOVW	R10,R30
    02C14 940E 3792 CALL	_SPI_Write
    02C16 5F6F      SUBI	R22,0xFF
    02C17 4F7F      SBCI	R23,0xFF
    02C18 3060      CPI	R22,0
    02C19 E0E2      LDI	R30,2
    02C1A 077E      CPC	R23,R30
    02C1B F3A8      BCS	0x2C11
(0127)   
(0128) 	SPI_Read(); 
    02C1C 940E 3796 CALL	_SPI_Read
(0129) 	SPI_Read(); //两个字节的CRC校验码，不用关心
    02C1E 940E 3796 CALL	_SPI_Read
(0130)    
(0131)     
(0132) 	temp=SPI_Read();   //读取返回值
    02C20 940E 3796 CALL	_SPI_Read
    02C22 2F40      MOV	R20,R16
(0133) 	if((temp&0x1F)!=0x05) //如果返回值是 XXX00101说明数据已经被SD卡接受了
    02C23 2F84      MOV	R24,R20
    02C24 718F      ANDI	R24,0x1F
    02C25 3085      CPI	R24,5
    02C26 F021      BEQ	0x2C2B
(0134) 	{
(0135)  		SD_CS_DIS();
    02C27 9AC0      SBI	0x18,0
(0136)  		return(WRITE_BLOCK_ERROR); //写块数据失败
    02C28 E003      LDI	R16,3
    02C29 E010      LDI	R17,0
    02C2A C00A      RJMP	0x2C35
(0137) 	}
(0138)  
(0139) 	while(SPI_Read()!=0xff);//等到SD卡不忙（数据被接受以后，SD卡要将这些数据写入到自身的FLASH中，需要一个时间）
    02C2B 940E 3796 CALL	_SPI_Read
    02C2D 2F40      MOV	R20,R16
    02C2E 3F0F      CPI	R16,0xFF
    02C2F F7D9      BNE	0x2C2B
(0140) 						    //忙时，读回来的值为0x00,不忙时，为0xff
(0141) 
(0142) 	SD_CS_DIS(); //关闭片选
    02C30 9AC0      SBI	0x18,0
(0143) 
(0144) 	SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02C31 940E 3796 CALL	_SPI_Read
(0145) 	return SD_TURE;		 //返回0,说明写扇区操作成功
    02C33 2700      CLR	R16
    02C34 2711      CLR	R17
    02C35 9626      ADIW	R28,6
    02C36 940E 3FB1 CALL	pop_xgsetF03C
    02C38 9624      ADIW	R28,4
    02C39 9508      RET
_SD_Read_Sector:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  buffer               --> R10
  addr                 --> Y,+14
    02C3A 940E 3E28 CALL	push_arg4
    02C3C 940E 3FA8 CALL	push_xgsetF03C
    02C3E 9726      SBIW	R28,6
    02C3F 88AA      LDD	R10,Y+18
    02C40 88BB      LDD	R11,Y+19
(0146) } 
(0147) //****************************************************************
(0148) //*隶属模块：SD卡控制
(0149) //*函数功能：读512字节数据（一扇区字节）
(0150) //****************************************************************
(0151) UINT16 SD_Read_Sector(UINT32 addr,UINT8 *buffer)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0152) {
(0153) 
(0154) 	 UINT16 j=0;
    02C41 2744      CLR	R20
    02C42 2755      CLR	R21
(0155) 	 UINT8 time=0,temp=0;
    02C43 2766      CLR	R22
    02C44 24CC      CLR	R12
(0156) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02C45 E58D      LDI	R24,0x5D
    02C46 E092      LDI	R25,2
    02C47 01FE      MOVW	R30,R28
    02C48 E006      LDI	R16,6
    02C49 E010      LDI	R17,0
    02C4A 93FA      ST	-Y,R31
    02C4B 93EA      ST	-Y,R30
    02C4C 939A      ST	-Y,R25
    02C4D 938A      ST	-Y,R24
    02C4E 940E 4014 CALL	asgnblk
(0157) 
(0158) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02C50 E089      LDI	R24,0x9
    02C51 E090      LDI	R25,0
    02C52 850E      LDD	R16,Y+14
    02C53 851F      LDD	R17,Y+15
    02C54 8928      LDD	R18,Y+16
    02C55 8939      LDD	R19,Y+17
    02C56 938A      ST	-Y,R24
    02C57 940E 3FEF CALL	lsl32
    02C59 870E      STD	Y+14,R16
    02C5A 871F      STD	Y+15,R17
    02C5B 8B28      STD	Y+16,R18
    02C5C 8B39      STD	Y+17,R19
(0159) 
(0160) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02C5D E188      LDI	R24,0x18
    02C5E E090      LDI	R25,0
    02C5F 850E      LDD	R16,Y+14
    02C60 851F      LDD	R17,Y+15
    02C61 8928      LDD	R18,Y+16
    02C62 8939      LDD	R19,Y+17
    02C63 938A      ST	-Y,R24
    02C64 940E 4008 CALL	lsr32
    02C66 8309      STD	Y+1,R16
(0161) 	 pcmd[2] = (addr>>16);
    02C67 842E      LDD	R2,Y+14
    02C68 843F      LDD	R3,Y+15
    02C69 8848      LDD	R4,Y+16
    02C6A 8859      LDD	R5,Y+17
    02C6B 0112      MOVW	R2,R4
    02C6C 2444      CLR	R4
    02C6D 2455      CLR	R5
    02C6E 822A      STD	Y+2,R2
(0162) 	 pcmd[3] =(addr>>8);
    02C6F E088      LDI	R24,0x8
    02C70 E090      LDI	R25,0
    02C71 850E      LDD	R16,Y+14
    02C72 851F      LDD	R17,Y+15
    02C73 8928      LDD	R18,Y+16
    02C74 8939      LDD	R19,Y+17
    02C75 938A      ST	-Y,R24
    02C76 940E 4008 CALL	lsr32
    02C78 830B      STD	Y+3,R16
(0163) 	// pcmd[4] = offset;
(0164) 
(0165) 	 SD_CS_EN();//打开片选 
    02C79 98C0      CBI	0x18,0
(0166) 
(0167) 	 do
(0168) 	 {  
(0169) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02C7A 018E      MOVW	R16,R28
    02C7B DEA6      RCALL	_SD_Write_cmd
    02C7C 2EC0      MOV	R12,R16
(0170) 		  time++;
    02C7D 9563      INC	R22
(0171) 		  if(time==TRY_TIME) 
    02C7E 3164      CPI	R22,0x14
    02C7F F421      BNE	0x2C84
(0172) 		  {
(0173) 		   SD_CS_DIS();
    02C80 9AC0      SBI	0x18,0
(0174) 		   return(READ_BLOCK_ERROR); //读块失败
    02C81 E004      LDI	R16,4
    02C82 E010      LDI	R17,0
    02C83 C01F      RJMP	0x2CA3
(0175) 		  }
(0176) 	 }while(temp!=0); 
    02C84 20CC      TST	R12
    02C85 F7A1      BNE	0x2C7A
(0177)    			
(0178) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02C86 940E 3796 CALL	_SPI_Read
    02C88 3F0E      CPI	R16,0xFE
    02C89 F7E1      BNE	0x2C86
(0179)  		   	   	
(0180) 	 for(j=0;j<512;j++)	 //将数据写入到数据缓冲区中
    02C8A 2744      CLR	R20
    02C8B 2755      CLR	R21
    02C8C C009      RJMP	0x2C96
(0181) 	 {	
(0182) 	    buffer[j]=SPI_Read();
    02C8D 940E 3796 CALL	_SPI_Read
    02C8F 2EC0      MOV	R12,R16
    02C90 01FA      MOVW	R30,R20
    02C91 0DEA      ADD	R30,R10
    02C92 1DFB      ADC	R31,R11
    02C93 82C0      ST	Z,R12
    02C94 5F4F      SUBI	R20,0xFF
    02C95 4F5F      SBCI	R21,0xFF
    02C96 3040      CPI	R20,0
    02C97 E0E2      LDI	R30,2
    02C98 075E      CPC	R21,R30
    02C99 F398      BCS	0x2C8D
(0183) 	 }
(0184) 
(0185) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02C9A 940E 3796 CALL	_SPI_Read
(0186) 	 SPI_Read();
    02C9C 940E 3796 CALL	_SPI_Read
(0187) 
(0188) 	 SD_CS_DIS();  //SD卡关闭片选 
    02C9E 9AC0      SBI	0x18,0
(0189) 
(0190) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02C9F 940E 3796 CALL	_SPI_Read
(0191) 
(0192) 	 return SD_TURE;
    02CA1 2700      CLR	R16
    02CA2 2711      CLR	R17
    02CA3 9626      ADIW	R28,6
    02CA4 940E 3FB1 CALL	pop_xgsetF03C
    02CA6 9624      ADIW	R28,4
    02CA7 9508      RET
_SD_Read_Sector_ndata:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  len                  --> R14
  offset               --> R10
  buffer               --> Y,+20
  addr                 --> Y,+16
    02CA8 940E 3E28 CALL	push_arg4
    02CAA 940E 3F6D CALL	push_xgsetF0FC
    02CAC 9726      SBIW	R28,6
    02CAD 88AE      LDD	R10,Y+22
    02CAE 88BF      LDD	R11,Y+23
    02CAF 8CE8      LDD	R14,Y+24
    02CB0 8CF9      LDD	R15,Y+25
(0193) }
(0194) //****************************************************************
(0195) //*隶属模块：SD卡控制
(0196) //*函数功能：写多扇区数据（多扇区字节）
(0197) //****************************************************************
(0198) UINT16 SD_Read_Sector_ndata(UINT32 addr,UINT8 *buffer,UINT16 offset,UINT16 len)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0199) {
(0200) 
(0201) 	 UINT16 j=0;
    02CB1 2744      CLR	R20
    02CB2 2755      CLR	R21
(0202) 	 UINT8 time=0,temp=0;
    02CB3 2766      CLR	R22
    02CB4 24CC      CLR	R12
(0203) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02CB5 E683      LDI	R24,0x63
    02CB6 E092      LDI	R25,2
    02CB7 01FE      MOVW	R30,R28
    02CB8 E006      LDI	R16,6
    02CB9 E010      LDI	R17,0
    02CBA 93FA      ST	-Y,R31
    02CBB 93EA      ST	-Y,R30
    02CBC 939A      ST	-Y,R25
    02CBD 938A      ST	-Y,R24
    02CBE 940E 4014 CALL	asgnblk
(0204) 
(0205) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02CC0 E089      LDI	R24,0x9
    02CC1 E090      LDI	R25,0
    02CC2 8908      LDD	R16,Y+16
    02CC3 8919      LDD	R17,Y+17
    02CC4 892A      LDD	R18,Y+18
    02CC5 893B      LDD	R19,Y+19
    02CC6 938A      ST	-Y,R24
    02CC7 940E 3FEF CALL	lsl32
    02CC9 8B08      STD	Y+16,R16
    02CCA 8B19      STD	Y+17,R17
    02CCB 8B2A      STD	Y+18,R18
    02CCC 8B3B      STD	Y+19,R19
(0206) 
(0207) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02CCD E188      LDI	R24,0x18
    02CCE E090      LDI	R25,0
    02CCF 8908      LDD	R16,Y+16
    02CD0 8919      LDD	R17,Y+17
    02CD1 892A      LDD	R18,Y+18
    02CD2 893B      LDD	R19,Y+19
    02CD3 938A      ST	-Y,R24
    02CD4 940E 4008 CALL	lsr32
    02CD6 8309      STD	Y+1,R16
(0208) 	 pcmd[2] = (addr>>16);
    02CD7 8828      LDD	R2,Y+16
    02CD8 8839      LDD	R3,Y+17
    02CD9 884A      LDD	R4,Y+18
    02CDA 885B      LDD	R5,Y+19
    02CDB 0112      MOVW	R2,R4
    02CDC 2444      CLR	R4
    02CDD 2455      CLR	R5
    02CDE 822A      STD	Y+2,R2
(0209) 	 pcmd[3] =(addr>>8);
    02CDF E088      LDI	R24,0x8
    02CE0 E090      LDI	R25,0
    02CE1 8908      LDD	R16,Y+16
    02CE2 8919      LDD	R17,Y+17
    02CE3 892A      LDD	R18,Y+18
    02CE4 893B      LDD	R19,Y+19
    02CE5 938A      ST	-Y,R24
    02CE6 940E 4008 CALL	lsr32
    02CE8 830B      STD	Y+3,R16
(0210) 	// pcmd[4] = offset;
(0211) 
(0212) 	 SD_CS_EN();//打开片选 
    02CE9 98C0      CBI	0x18,0
(0213) 
(0214) 	 do
(0215) 	 {  
(0216) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02CEA 018E      MOVW	R16,R28
    02CEB DE36      RCALL	_SD_Write_cmd
    02CEC 2EC0      MOV	R12,R16
(0217) 		  time++;
    02CED 9563      INC	R22
(0218) 		  if(time==TRY_TIME) 
    02CEE 3164      CPI	R22,0x14
    02CEF F421      BNE	0x2CF4
(0219) 		  {
(0220) 		   SD_CS_DIS();
    02CF0 9AC0      SBI	0x18,0
(0221) 		   return(READ_BLOCK_ERROR); //读块失败
    02CF1 E004      LDI	R16,4
    02CF2 E010      LDI	R17,0
    02CF3 C034      RJMP	0x2D28
(0222) 		  }
(0223) 	 }while(temp!=0); 
    02CF4 20CC      TST	R12
    02CF5 F7A1      BNE	0x2CEA
(0224)    			
(0225) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02CF6 940E 3796 CALL	_SPI_Read
    02CF8 3F0E      CPI	R16,0xFE
    02CF9 F7E1      BNE	0x2CF6
(0226)  		   	   	
(0227) 	 for(j=0;j<offset;j++)	 //将数据写入到数据缓冲区中
    02CFA 2744      CLR	R20
    02CFB 2755      CLR	R21
    02CFC C004      RJMP	0x2D01
(0228) 	    SPI_Read();
    02CFD 940E 3796 CALL	_SPI_Read
    02CFF 5F4F      SUBI	R20,0xFF
    02D00 4F5F      SBCI	R21,0xFF
    02D01 154A      CP	R20,R10
    02D02 055B      CPC	R21,R11
    02D03 F3C8      BCS	0x2CFD
(0229) 	 for(;j<offset+len;j++)	 
    02D04 C00B      RJMP	0x2D10
(0230) 		buffer[j]=SPI_Read();
    02D05 940E 3796 CALL	_SPI_Read
    02D07 2F60      MOV	R22,R16
    02D08 01FA      MOVW	R30,R20
    02D09 880C      LDD	R0,Y+20
    02D0A 881D      LDD	R1,Y+21
    02D0B 0DE0      ADD	R30,R0
    02D0C 1DF1      ADC	R31,R1
    02D0D 8360      ST	Z,R22
    02D0E 5F4F      SUBI	R20,0xFF
    02D0F 4F5F      SBCI	R21,0xFF
    02D10 0115      MOVW	R2,R10
    02D11 0C2E      ADD	R2,R14
    02D12 1C3F      ADC	R3,R15
    02D13 1542      CP	R20,R2
    02D14 0553      CPC	R21,R3
    02D15 F378      BCS	0x2D05
(0231) 	 for(;j<512;j++)	 
    02D16 C004      RJMP	0x2D1B
(0232) 		SPI_Read();
    02D17 940E 3796 CALL	_SPI_Read
    02D19 5F4F      SUBI	R20,0xFF
    02D1A 4F5F      SBCI	R21,0xFF
    02D1B 3040      CPI	R20,0
    02D1C E0E2      LDI	R30,2
    02D1D 075E      CPC	R21,R30
    02D1E F3C0      BCS	0x2D17
(0233) 
(0234) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02D1F 940E 3796 CALL	_SPI_Read
(0235) 	 SPI_Read();
    02D21 940E 3796 CALL	_SPI_Read
(0236) 
(0237) 	 SD_CS_DIS();  //SD卡关闭片选 
    02D23 9AC0      SBI	0x18,0
(0238) 
(0239) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02D24 940E 3796 CALL	_SPI_Read
(0240) 
(0241) 	 return SD_TURE;
    02D26 2700      CLR	R16
    02D27 2711      CLR	R17
    02D28 9626      ADIW	R28,6
    02D29 940E 3F62 CALL	pop_xgsetF0FC
    02D2B 9624      ADIW	R28,4
    02D2C 9508      RET
_GUI_mainmeu:
  key                  --> R22
  select               --> R20
    02D2D 934A      ST	-Y,R20
    02D2E 936A      ST	-Y,R22
    02D2F 9723      SBIW	R28,3
FILE: D:\LQD\software\master\software_src\gui.c
(0001) #include "config.h"
(0002) const char labelH[]="高强度作业：\0";
(0003) const char labelM[]="中等强度作业：\0";
(0004) const char labelL[]="低强度作业：\0";
(0005) const char H01[]="加强劳动监督；\0";
(0006) const char H02[]="增加饮水;\0" ;
(0007) const char H03[]="保持干燥禁裸露。\0";
(0008) #define M01 H01
(0009) #define M02 H03
(0010) const char M03[]="戴面罩。\0";
(0011) const char M04[]="禁油彩。\0";
(0012) #define L01 M03
(0013) #define L02 M04
(0014) const char L03[]="缩短作业时间。";
(0015) //-----//
(0016) #define H11 M04
(0017) #define H12 H03
(0018) const char H13[]="休息注意保暖。\0";
(0019) #define M11 H01
(0020) const char M12[]="减少非必须作业；\0";
(0021) const char M13[]="劳动时间<30min。\0";
(0022) const char L11[]="取消非必须的作业\0";
(0023) const char L12[]="劳动时间<15min；\0";
(0024) #define L13 H03
(0025) //-----//
(0026) #define H21 L11
(0027) #define H22 L12
(0028) #define H23 H03
(0029) const char M21[]="取消户外作业。"; 
(0030) #define L21 M21
(0031) 
(0032) //#define LEDON   PORTC&=~(1<<7)					   
(0033) //#define LEDOFF  PINC|=(1<<7)
(0034) char GUI_date[17]="09月19日18:00:00\0";
(0035) 
(0036) // 主菜单
(0037) unsigned char GUI_mainmeu( void ){
(0038)  	unsigned char key=0; //init= nokey
    02D30 2766      CLR	R22
(0039) 	unsigned char select=3;
    02D31 E043      LDI	R20,3
(0040) 	LCD_CLR();
    02D32 940E 3876 CALL	_LCD_CLR
(0041)  	Set_White(1,1,8,1);
    02D34 E081      LDI	R24,1
    02D35 838A      STD	Y+2,R24
    02D36 E088      LDI	R24,0x8
    02D37 8388      ST	Y,R24
    02D38 E021      LDI	R18,1
    02D39 E001      LDI	R16,1
    02D3A 940E 3900 CALL	_Set_White
(0042) 	Set_White(1,2,8,1);
    02D3C E081      LDI	R24,1
    02D3D 838A      STD	Y+2,R24
    02D3E E088      LDI	R24,0x8
    02D3F 8388      ST	Y,R24
    02D40 E022      LDI	R18,2
    02D41 E001      LDI	R16,1
    02D42 940E 3900 CALL	_Set_White
(0043) 	Set_White(1,3,8,1);
    02D44 E081      LDI	R24,1
    02D45 838A      STD	Y+2,R24
    02D46 E088      LDI	R24,0x8
    02D47 8388      ST	Y,R24
    02D48 E023      LDI	R18,3
    02D49 E001      LDI	R16,1
    02D4A 940E 3900 CALL	_Set_White
(0044) 	Set_White(1,4,8,1);
    02D4C E081      LDI	R24,1
    02D4D 838A      STD	Y+2,R24
    02D4E E088      LDI	R24,0x8
    02D4F 8388      ST	Y,R24
    02D50 E024      LDI	R18,4
    02D51 E001      LDI	R16,1
    02D52 940E 3900 CALL	_Set_White
(0045) 	LCD_const_disp(2,1,"  检测  时钟调整");
    02D54 EB89      LDI	R24,0xB9
    02D55 E094      LDI	R25,4
    02D56 8399      STD	Y+1,R25
    02D57 8388      ST	Y,R24
    02D58 E021      LDI	R18,1
    02D59 E002      LDI	R16,2
    02D5A 940E 37D0 CALL	_LCD_const_disp
(0046) 	LCD_const_disp(3,1,"  查询  数据传输");
    02D5C EA88      LDI	R24,0xA8
    02D5D E094      LDI	R25,4
    02D5E 8399      STD	Y+1,R25
    02D5F 8388      ST	Y,R24
    02D60 E021      LDI	R18,1
    02D61 E003      LDI	R16,3
    02D62 940E 37D0 CALL	_LCD_const_disp
(0047) 	LCD_const_disp(4,1,"  初始化");
    02D64 E98F      LDI	R24,0x9F
    02D65 E094      LDI	R25,4
    02D66 8399      STD	Y+1,R25
    02D67 8388      ST	Y,R24
    02D68 E021      LDI	R18,1
    02D69 E004      LDI	R16,4
    02D6A 940E 37D0 CALL	_LCD_const_disp
(0048) 	Set_White(1,1,8,1);
    02D6C E081      LDI	R24,1
    02D6D 838A      STD	Y+2,R24
    02D6E E088      LDI	R24,0x8
    02D6F 8388      ST	Y,R24
    02D70 E021      LDI	R18,1
    02D71 E001      LDI	R16,1
    02D72 940E 3900 CALL	_Set_White
(0049) 	Set_White(1,2,8,1);
    02D74 E081      LDI	R24,1
    02D75 838A      STD	Y+2,R24
    02D76 E088      LDI	R24,0x8
    02D77 8388      ST	Y,R24
    02D78 E022      LDI	R18,2
    02D79 E001      LDI	R16,1
    02D7A 940E 3900 CALL	_Set_White
(0050) 	Set_White(1,3,8,1);
    02D7C E081      LDI	R24,1
    02D7D 838A      STD	Y+2,R24
    02D7E E088      LDI	R24,0x8
    02D7F 8388      ST	Y,R24
    02D80 E023      LDI	R18,3
    02D81 E001      LDI	R16,1
    02D82 940E 3900 CALL	_Set_White
(0051) 	Set_White(1,4,8,1);
    02D84 E081      LDI	R24,1
    02D85 838A      STD	Y+2,R24
    02D86 E088      LDI	R24,0x8
    02D87 8388      ST	Y,R24
    02D88 E024      LDI	R18,4
    02D89 E001      LDI	R16,1
    02D8A 940E 3900 CALL	_Set_White
(0052) 	set_white_n(select,0);
    02D8C 2722      CLR	R18
    02D8D 2F04      MOV	R16,R20
    02D8E 940E 3992 CALL	_set_white_n
    02D90 C07F      RJMP	0x2E10
(0053) 	while(1)
(0054) 	{
(0055) 	 	key=kbscan();
    02D91 940E 3DBF CALL	_kbscan
    02D93 2F60      MOV	R22,R16
(0056) 		dateRefresh(1); //更新系统时间
    02D94 E001      LDI	R16,1
    02D95 D6D0      RCALL	_dateRefresh
(0057) 		LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02D96 D459      RCALL	_GUI_get_date
    02D97 8319      STD	Y+1,R17
    02D98 8308      ST	Y,R16
    02D99 E021      LDI	R18,1
    02D9A E001      LDI	R16,1
    02D9B 940E 37D0 CALL	_LCD_const_disp
(0058) 		if((select>3) && ( key==up ) ){
    02D9D E083      LDI	R24,3
    02D9E 1784      CP	R24,R20
    02D9F F4F8      BCC	0x2DBF
    02DA0 316E      CPI	R22,0x1E
    02DA1 F4E9      BNE	0x2DBF
(0059) 		 Set_White(1,2,8,1);
    02DA2 E081      LDI	R24,1
    02DA3 838A      STD	Y+2,R24
    02DA4 E088      LDI	R24,0x8
    02DA5 8388      ST	Y,R24
    02DA6 E022      LDI	R18,2
    02DA7 E001      LDI	R16,1
    02DA8 940E 3900 CALL	_Set_White
(0060) 		 Set_White(1,3,8,1);
    02DAA E081      LDI	R24,1
    02DAB 838A      STD	Y+2,R24
    02DAC E088      LDI	R24,0x8
    02DAD 8388      ST	Y,R24
    02DAE E023      LDI	R18,3
    02DAF E001      LDI	R16,1
    02DB0 940E 3900 CALL	_Set_White
(0061) 		 Set_White(1,4,8,1);
    02DB2 E081      LDI	R24,1
    02DB3 838A      STD	Y+2,R24
    02DB4 E088      LDI	R24,0x8
    02DB5 8388      ST	Y,R24
    02DB6 E024      LDI	R18,4
    02DB7 E001      LDI	R16,1
    02DB8 940E 3900 CALL	_Set_White
(0062) 		 select--;
    02DBA 954A      DEC	R20
(0063) 		 set_white_n(select,0);
    02DBB 2722      CLR	R18
    02DBC 2F04      MOV	R16,R20
    02DBD 940E 3992 CALL	_set_white_n
(0064) 		}
(0065) 		if((select<7) && ( key==down ) ){
    02DBF 3047      CPI	R20,7
    02DC0 F538      BCC	0x2DE8
    02DC1 316D      CPI	R22,0x1D
    02DC2 F529      BNE	0x2DE8
(0066) 		 Set_White(1,1,8,1);
    02DC3 E081      LDI	R24,1
    02DC4 838A      STD	Y+2,R24
    02DC5 E088      LDI	R24,0x8
    02DC6 8388      ST	Y,R24
    02DC7 E021      LDI	R18,1
    02DC8 E001      LDI	R16,1
    02DC9 940E 3900 CALL	_Set_White
(0067) 		 Set_White(1,2,8,1);
    02DCB E081      LDI	R24,1
    02DCC 838A      STD	Y+2,R24
    02DCD E088      LDI	R24,0x8
    02DCE 8388      ST	Y,R24
    02DCF E022      LDI	R18,2
    02DD0 E001      LDI	R16,1
    02DD1 940E 3900 CALL	_Set_White
(0068) 		 Set_White(1,3,8,1);
    02DD3 E081      LDI	R24,1
    02DD4 838A      STD	Y+2,R24
    02DD5 E088      LDI	R24,0x8
    02DD6 8388      ST	Y,R24
    02DD7 E023      LDI	R18,3
    02DD8 E001      LDI	R16,1
    02DD9 940E 3900 CALL	_Set_White
(0069) 		 Set_White(1,4,8,1);
    02DDB E081      LDI	R24,1
    02DDC 838A      STD	Y+2,R24
    02DDD E088      LDI	R24,0x8
    02DDE 8388      ST	Y,R24
    02DDF E024      LDI	R18,4
    02DE0 E001      LDI	R16,1
    02DE1 940E 3900 CALL	_Set_White
(0070) 		 select++;
    02DE3 9543      INC	R20
(0071) 		 set_white_n(select,0);
    02DE4 2722      CLR	R18
    02DE5 2F04      MOV	R16,R20
    02DE6 940E 3992 CALL	_set_white_n
(0072) 		}
(0073) 		if(key == left ){
    02DE8 316B      CPI	R22,0x1B
    02DE9 F531      BNE	0x2E10
(0074) 		 Set_White(1,1,8,1);
    02DEA E081      LDI	R24,1
    02DEB 838A      STD	Y+2,R24
    02DEC E088      LDI	R24,0x8
    02DED 8388      ST	Y,R24
    02DEE E021      LDI	R18,1
    02DEF E001      LDI	R16,1
    02DF0 940E 3900 CALL	_Set_White
(0075) 		 Set_White(1,2,8,1);
    02DF2 E081      LDI	R24,1
    02DF3 838A      STD	Y+2,R24
    02DF4 E088      LDI	R24,0x8
    02DF5 8388      ST	Y,R24
    02DF6 E022      LDI	R18,2
    02DF7 E001      LDI	R16,1
    02DF8 940E 3900 CALL	_Set_White
(0076) 		 Set_White(1,3,8,1);
    02DFA E081      LDI	R24,1
    02DFB 838A      STD	Y+2,R24
    02DFC E088      LDI	R24,0x8
    02DFD 8388      ST	Y,R24
    02DFE E023      LDI	R18,3
    02DFF E001      LDI	R16,1
    02E00 940E 3900 CALL	_Set_White
(0077) 		 Set_White(1,4,8,1);
    02E02 E081      LDI	R24,1
    02E03 838A      STD	Y+2,R24
    02E04 E088      LDI	R24,0x8
    02E05 8388      ST	Y,R24
    02E06 E024      LDI	R18,4
    02E07 E001      LDI	R16,1
    02E08 940E 3900 CALL	_Set_White
(0078) 		 beep(3,select);
    02E0A 2F24      MOV	R18,R20
    02E0B E003      LDI	R16,3
    02E0C 940E 3B4B CALL	_beep
(0079) 		 return select;
    02E0E 2F04      MOV	R16,R20
    02E0F C001      RJMP	0x2E11
    02E10 CF80      RJMP	0x2D91
    02E11 9623      ADIW	R28,3
    02E12 9169      LD	R22,Y+
    02E13 9149      LD	R20,Y+
    02E14 9508      RET
_GUI_check:
  next_step_time       --> Y,+3
  selectCheckMode      --> R10
  page                 --> Y,+7
  is_on                --> R12
  key                  --> R14
    02E15 940E 3F6D CALL	push_xgsetF0FC
    02E17 9728      SBIW	R28,0x8
(0080) 		}
(0081)     }
(0082) 	return 0xff; //error
(0083) 	
(0084) }
(0085) 
(0086) //”检测 “菜单
(0087) void GUI_check(void)
(0088) {
(0089)     char key;
(0090) 	char page=0,is_on=0;
    02E18 2400      CLR	R0
    02E19 820F      STD	Y+7,R0
    02E1A 24CC      CLR	R12
(0091) 	long next_step_time=0;
    02E1B E080      LDI	R24,0
    02E1C 838B      STD	Y+3,R24
    02E1D 838C      STD	Y+4,R24
    02E1E 838D      STD	Y+5,R24
    02E1F 838E      STD	Y+6,R24
(0092) 	char selectCheckMode=config.autocheck; //自动检测开关
    02E20 90A0 07C2 LDS	R10,config+16
(0093) 	LCD_CLR();
    02E22 940E 3876 CALL	_LCD_CLR
(0094) 	LCD_const_disp(1,1,"菜单/ 检测");
    02E24 E984      LDI	R24,0x94
    02E25 E094      LDI	R25,4
    02E26 8399      STD	Y+1,R25
    02E27 8388      ST	Y,R24
    02E28 E021      LDI	R18,1
    02E29 E001      LDI	R16,1
    02E2A 940E 37D0 CALL	_LCD_const_disp
(0095) 	LCD_const_disp(2,3,"自动");		 
    02E2C E88F      LDI	R24,0x8F
    02E2D E094      LDI	R25,4
    02E2E 8399      STD	Y+1,R25
    02E2F 8388      ST	Y,R24
    02E30 E023      LDI	R18,3
    02E31 E002      LDI	R16,2
    02E32 940E 37D0 CALL	_LCD_const_disp
(0096) 	LCD_const_disp(3,3,"手动");
    02E34 E88A      LDI	R24,0x8A
    02E35 E094      LDI	R25,4
    02E36 8399      STD	Y+1,R25
    02E37 8388      ST	Y,R24
    02E38 E023      LDI	R18,3
    02E39 E003      LDI	R16,3
    02E3A 940E 37D0 CALL	_LCD_const_disp
(0097) 	if(selectCheckMode==1) {
    02E3C 2D8A      MOV	R24,R10
    02E3D 3081      CPI	R24,1
    02E3E F489      BNE	0x2E50
(0098) 	    Set_White(1,2,8,0);
    02E3F 2422      CLR	R2
    02E40 822A      STD	Y+2,R2
    02E41 E088      LDI	R24,0x8
    02E42 8388      ST	Y,R24
    02E43 E022      LDI	R18,2
    02E44 E001      LDI	R16,1
    02E45 940E 3900 CALL	_Set_White
(0099) 		Set_White(1,3,8,1);
    02E47 E081      LDI	R24,1
    02E48 838A      STD	Y+2,R24
    02E49 E088      LDI	R24,0x8
    02E4A 8388      ST	Y,R24
    02E4B E023      LDI	R18,3
    02E4C E001      LDI	R16,1
    02E4D 940E 3900 CALL	_Set_White
(0100) 	}
    02E4F C05F      RJMP	0x2EAF
(0101) 	else {
(0102) 		 Set_White(1,2,8,1);
    02E50 E081      LDI	R24,1
    02E51 838A      STD	Y+2,R24
    02E52 E088      LDI	R24,0x8
    02E53 8388      ST	Y,R24
    02E54 E022      LDI	R18,2
    02E55 E001      LDI	R16,1
    02E56 940E 3900 CALL	_Set_White
(0103) 		 Set_White(1,3,8,0);
    02E58 2422      CLR	R2
    02E59 822A      STD	Y+2,R2
    02E5A E088      LDI	R24,0x8
    02E5B 8388      ST	Y,R24
    02E5C E023      LDI	R18,3
    02E5D E001      LDI	R16,1
    02E5E 940E 3900 CALL	_Set_White
(0104) 	}
    02E60 C04E      RJMP	0x2EAF
(0105) //<<菜单/检测/手（自）动>>
(0106) while(1){
(0107)  	key=kbscan();
    02E61 940E 3DBF CALL	_kbscan
    02E63 2EE0      MOV	R14,R16
(0108) 	//上键短按 选择
(0109) 	if(key==up && selectCheckMode == 1){  
    02E64 310E      CPI	R16,0x1E
    02E65 F4A1      BNE	0x2E7A
    02E66 2D8A      MOV	R24,R10
    02E67 3081      CPI	R24,1
    02E68 F489      BNE	0x2E7A
(0110) 		    selectCheckMode=0;
    02E69 24AA      CLR	R10
(0111) 			Set_White(1,2,8,0);
    02E6A 2422      CLR	R2
    02E6B 822A      STD	Y+2,R2
    02E6C E088      LDI	R24,0x8
    02E6D 8388      ST	Y,R24
    02E6E E022      LDI	R18,2
    02E6F E001      LDI	R16,1
    02E70 940E 3900 CALL	_Set_White
(0112)  			Set_White(1,3,8,1);
    02E72 E081      LDI	R24,1
    02E73 838A      STD	Y+2,R24
    02E74 E088      LDI	R24,0x8
    02E75 8388      ST	Y,R24
    02E76 E023      LDI	R18,3
    02E77 E001      LDI	R16,1
    02E78 940E 3900 CALL	_Set_White
(0113) 			//delayms(500);
(0114) 	}
(0115) 	//下键短按	选择
(0116) 	if(key==down && selectCheckMode == 0){  
    02E7A 2D8E      MOV	R24,R14
    02E7B 318D      CPI	R24,0x1D
    02E7C F4A1      BNE	0x2E91
    02E7D 20AA      TST	R10
    02E7E F491      BNE	0x2E91
(0117) 		selectCheckMode=1;
    02E7F 24AA      CLR	R10
    02E80 94A3      INC	R10
(0118) 		Set_White(1,2,8,1);
    02E81 E081      LDI	R24,1
    02E82 838A      STD	Y+2,R24
    02E83 E088      LDI	R24,0x8
    02E84 8388      ST	Y,R24
    02E85 E022      LDI	R18,2
    02E86 E001      LDI	R16,1
    02E87 940E 3900 CALL	_Set_White
(0119)  		Set_White(1,3,8,0);
    02E89 2422      CLR	R2
    02E8A 822A      STD	Y+2,R2
    02E8B E088      LDI	R24,0x8
    02E8C 8388      ST	Y,R24
    02E8D E023      LDI	R18,3
    02E8E E001      LDI	R16,1
    02E8F 940E 3900 CALL	_Set_White
(0120) 	    //delayms(500);
(0121) 	}
(0122) 	//左键短按  进入
(0123) 	if(key == left) {
    02E91 2D8E      MOV	R24,R14
    02E92 318B      CPI	R24,0x1B
    02E93 F4B9      BNE	0x2EAB
(0124) 		config.autocheck=selectCheckMode; 
    02E94 92A0 07C2 STS	config+16,R10
(0125) 		Set_White(1,2,8,1);
    02E96 E081      LDI	R24,1
    02E97 838A      STD	Y+2,R24
    02E98 E088      LDI	R24,0x8
    02E99 8388      ST	Y,R24
    02E9A E022      LDI	R18,2
    02E9B E001      LDI	R16,1
    02E9C 940E 3900 CALL	_Set_White
(0126)  		Set_White(1,3,8,1);
    02E9E E081      LDI	R24,1
    02E9F 838A      STD	Y+2,R24
    02EA0 E088      LDI	R24,0x8
    02EA1 8388      ST	Y,R24
    02EA2 E023      LDI	R18,3
    02EA3 E001      LDI	R16,1
    02EA4 940E 3900 CALL	_Set_White
(0127) 		delayms(500);
    02EA6 EF04      LDI	R16,0xF4
    02EA7 E011      LDI	R17,1
    02EA8 940E 23FC CALL	_delayms
(0128) 		break ;		
    02EAA C005      RJMP	0x2EB0
(0129) 	}
(0130) 	//右键短按  返回
(0131) 	if(key == right) {
    02EAB 2D8E      MOV	R24,R14
    02EAC 3187      CPI	R24,0x17
    02EAD F409      BNE	0x2EAF
(0132) 		return ;		
    02EAE C12D      RJMP	0x2FDC
    02EAF CFB1      RJMP	0x2E61
(0133) 	}
(0134) } //end of while
(0135) if(config.autocheck == 1) {
    02EB0 9180 07C2 LDS	R24,config+16
    02EB2 3081      CPI	R24,1
    02EB3 F009      BEQ	0x2EB5
    02EB4 C126      RJMP	0x2FDB
(0136)     next_step_time=now+config.checkDeltaTime;
    02EB5 9020 07C3 LDS	R2,config+17
    02EB7 9030 07C4 LDS	R3,config+18
    02EB9 2444      CLR	R4
    02EBA FC37      SBRC	R3,7
    02EBB 9440      COM	R4
    02EBC 2455      CLR	R5
    02EBD FC47      SBRC	R4,7
    02EBE 9450      COM	R5
    02EBF 9080 0117 LDS	R8,now+2
    02EC1 9090 0118 LDS	R9,now+3
    02EC3 9060 0115 LDS	R6,now
    02EC5 9070 0116 LDS	R7,now+1
    02EC7 0C62      ADD	R6,R2
    02EC8 1C73      ADC	R7,R3
    02EC9 1C84      ADC	R8,R4
    02ECA 1C95      ADC	R9,R5
    02ECB 826B      STD	Y+3,R6
    02ECC 827C      STD	Y+4,R7
    02ECD 828D      STD	Y+5,R8
    02ECE 829E      STD	Y+6,R9
(0137) }
    02ECF C10B      RJMP	0x2FDB
(0138) while(1){
(0139) 	key=kbscan();
    02ED0 940E 3DBF CALL	_kbscan
    02ED2 2EE0      MOV	R14,R16
(0140) 	_GUI_datashow(1,page);
    02ED3 812F      LDD	R18,Y+7
    02ED4 E001      LDI	R16,1
    02ED5 D109      RCALL	__GUI_datashow
(0141) 	if(config.autocheck == 1 && now > next_step_time ){
    02ED6 9180 07C2 LDS	R24,config+16
    02ED8 3081      CPI	R24,1
    02ED9 F571      BNE	0x2F08
    02EDA 802B      LDD	R2,Y+3
    02EDB 803C      LDD	R3,Y+4
    02EDC 804D      LDD	R4,Y+5
    02EDD 805E      LDD	R5,Y+6
    02EDE 9080 0117 LDS	R8,now+2
    02EE0 9090 0118 LDS	R9,now+3
    02EE2 9060 0115 LDS	R6,now
    02EE4 9070 0116 LDS	R7,now+1
    02EE6 1426      CP	R2,R6
    02EE7 0437      CPC	R3,R7
    02EE8 0448      CPC	R4,R8
    02EE9 0459      CPC	R5,R9
    02EEA F4E8      BCC	0x2F08
(0142) 	    next_step_time=now+config.checkDeltaTime; //更新下一步操作时间
    02EEB 9020 07C3 LDS	R2,config+17
    02EED 9030 07C4 LDS	R3,config+18
    02EEF 2444      CLR	R4
    02EF0 FC37      SBRC	R3,7
    02EF1 9440      COM	R4
    02EF2 2455      CLR	R5
    02EF3 FC47      SBRC	R4,7
    02EF4 9450      COM	R5
    02EF5 0C62      ADD	R6,R2
    02EF6 1C73      ADC	R7,R3
    02EF7 1C84      ADC	R8,R4
    02EF8 1C95      ADC	R9,R5
    02EF9 826B      STD	Y+3,R6
    02EFA 827C      STD	Y+4,R7
    02EFB 828D      STD	Y+5,R8
    02EFC 829E      STD	Y+6,R9
(0143) 		if(page < 5) page++ ;
    02EFD 818F      LDD	R24,Y+7
    02EFE 3085      CPI	R24,5
    02EFF F420      BCC	0x2F04
    02F00 2E08      MOV	R0,R24
    02F01 9403      INC	R0
    02F02 820F      STD	Y+7,R0
    02F03 C004      RJMP	0x2F08
(0144) 		else {
(0145) 			page=0; //返回起始页面
    02F04 2400      CLR	R0
    02F05 820F      STD	Y+7,R0
(0146) 			key=left; //模拟开始检测按键
    02F06 E18B      LDI	R24,0x1B
    02F07 2EE8      MOV	R14,R24
(0147) 		}
(0148) 	}
(0149) 	//LCD_print2num(4,4,is_on);
(0150) 	if(key==left && is_on==0){ //按left键开始测量
    02F08 2D8E      MOV	R24,R14
    02F09 318B      CPI	R24,0x1B
    02F0A F521      BNE	0x2F2F
    02F0B 20CC      TST	R12
    02F0C F511      BNE	0x2F2F
(0151) 	  			 beep(1,0);
    02F0D 2722      CLR	R18
    02F0E E001      LDI	R16,1
    02F0F 940E 3B4B CALL	_beep
(0152) 	  			 //fwrite; 
(0153) 				 config.time1=config.now+config.THRESHOLD_delta_sec;
    02F11 9040 07B8 LDS	R4,config+6
    02F13 9050 07B9 LDS	R5,config+7
    02F15 9020 07B6 LDS	R2,config+4
    02F17 9030 07B7 LDS	R3,config+5
    02F19 9080 07C0 LDS	R8,config+14
    02F1B 9090 07C1 LDS	R9,config+15
    02F1D 9060 07BE LDS	R6,config+12
    02F1F 9070 07BF LDS	R7,config+13
    02F21 0C62      ADD	R6,R2
    02F22 1C73      ADC	R7,R3
    02F23 1C84      ADC	R8,R4
    02F24 1C95      ADC	R9,R5
    02F25 9270 07BB STS	config+9,R7
    02F27 9260 07BA STS	config+8,R6
    02F29 9290 07BD STS	config+11,R9
    02F2B 9280 07BC STS	config+10,R8
(0154) 				 is_on=1; //start count
    02F2D 24CC      CLR	R12
    02F2E 94C3      INC	R12
(0155) 	 //			 timer1_init(); //计数
(0156) 				}
(0157) 	if(is_on == 1 ){
    02F2F 2D8C      MOV	R24,R12
    02F30 3081      CPI	R24,1
    02F31 F4C9      BNE	0x2F4B
(0158) 	    LCD_const_disp(4,1,"倒计时: ");
    02F32 E881      LDI	R24,0x81
    02F33 E094      LDI	R25,4
    02F34 8399      STD	Y+1,R25
    02F35 8388      ST	Y,R24
    02F36 E021      LDI	R18,1
    02F37 E004      LDI	R16,4
    02F38 940E 37D0 CALL	_LCD_const_disp
(0159) 	    LCD_print4num(4,5,config.time1-config.now);
    02F3A 9020 07BE LDS	R2,config+12
    02F3C 9030 07BF LDS	R3,config+13
    02F3E 9040 07BA LDS	R4,config+8
    02F40 9050 07BB LDS	R5,config+9
    02F42 1842      SUB	R4,R2
    02F43 0853      SBC	R5,R3
    02F44 8259      STD	Y+1,R5
    02F45 8248      ST	Y,R4
    02F46 E025      LDI	R18,5
    02F47 E004      LDI	R16,4
    02F48 940E 3A92 CALL	_LCD_print4num
(0160) 	}
    02F4A C008      RJMP	0x2F53
(0161) 	else {
(0162) 	   LCD_const_disp(4,1,"            ");
    02F4B E784      LDI	R24,0x74
    02F4C E094      LDI	R25,4
    02F4D 8399      STD	Y+1,R25
    02F4E 8388      ST	Y,R24
    02F4F E021      LDI	R18,1
    02F50 E004      LDI	R16,4
    02F51 940E 37D0 CALL	_LCD_const_disp
(0163) 	}						
(0164) 	if(is_on == 1 && config.now>=config.time1 ){
    02F53 2D8C      MOV	R24,R12
    02F54 3081      CPI	R24,1
    02F55 F5A1      BNE	0x2F8A
    02F56 9040 07BC LDS	R4,config+10
    02F58 9050 07BD LDS	R5,config+11
    02F5A 9020 07BA LDS	R2,config+8
    02F5C 9030 07BB LDS	R3,config+9
    02F5E 9080 07C0 LDS	R8,config+14
    02F60 9090 07C1 LDS	R9,config+15
    02F62 9060 07BE LDS	R6,config+12
    02F64 9070 07BF LDS	R7,config+13
    02F66 1462      CP	R6,R2
    02F67 0473      CPC	R7,R3
    02F68 0484      CPC	R8,R4
    02F69 0495      CPC	R9,R5
    02F6A F0FC      BLT	0x2F8A
(0165) 	    is_on=0;
    02F6B 24CC      CLR	R12
(0166) 	 	check(); //检测
    02F6C 940E 2802 CALL	_check
(0167) 		StructToChar(); //转成字符串
    02F6E 940E 2981 CALL	_StructToChar
(0168) 		WriteSDFile();  //写入sd卡
    02F70 940E 25DB CALL	_WriteSDFile
(0169) 		//zigbee_send(); //发送
(0170) 	 	Result.Index++; //索引自增一
    02F72 E041      LDI	R20,1
    02F73 E050      LDI	R21,0
    02F74 E060      LDI	R22,0
    02F75 E070      LDI	R23,0
    02F76 9040 054E LDS	R4,Result+12
    02F78 9050 054F LDS	R5,Result+13
    02F7A 9020 054C LDS	R2,Result+10
    02F7C 9030 054D LDS	R3,Result+11
    02F7E 0E24      ADD	R2,R20
    02F7F 1E35      ADC	R3,R21
    02F80 1E46      ADC	R4,R22
    02F81 1E57      ADC	R5,R23
    02F82 9230 054D STS	Result+11,R3
    02F84 9220 054C STS	Result+10,R2
    02F86 9250 054F STS	Result+13,R5
    02F88 9240 054E STS	Result+12,R4
(0171)  	} 	
(0172)     if(key==left){ //左键 : 页面减 
    02F8A 2D8E      MOV	R24,R14
    02F8B 318B      CPI	R24,0x1B
    02F8C F451      BNE	0x2F97
(0173) 	    if(page>0) page--;
    02F8D E080      LDI	R24,0
    02F8E 800F      LDD	R0,Y+7
    02F8F 1580      CP	R24,R0
    02F90 F410      BCC	0x2F93
    02F91 940A      DEC	R0
    02F92 820F      STD	Y+7,R0
(0174) 	    LCD_CLR();
    02F93 940E 3876 CALL	_LCD_CLR
(0175) 	    LCD_Init();
    02F95 940E 3844 CALL	_LCD_Init
(0176) 	}
(0177) 	if(key==right){ //右键 ： 页面加
    02F97 2D8E      MOV	R24,R14
    02F98 3187      CPI	R24,0x17
    02F99 F469      BNE	0x2FA7
(0178) 	    if(page<5) page++;
    02F9A 818F      LDD	R24,Y+7
    02F9B 3085      CPI	R24,5
    02F9C F420      BCC	0x2FA1
    02F9D 2E08      MOV	R0,R24
    02F9E 9403      INC	R0
    02F9F 820F      STD	Y+7,R0
    02FA0 C002      RJMP	0x2FA3
(0179) 	  	else page = 0;
    02FA1 2400      CLR	R0
    02FA2 820F      STD	Y+7,R0
(0180) 	    LCD_CLR();
    02FA3 940E 3876 CALL	_LCD_CLR
(0181) 	    LCD_Init();
    02FA5 940E 3844 CALL	_LCD_Init
(0182) 	}
(0183) 	if(key==down && is_on==0){	//长安右键 退出
    02FA7 2D8E      MOV	R24,R14
    02FA8 318D      CPI	R24,0x1D
    02FA9 F569      BNE	0x2FD7
    02FAA 20CC      TST	R12
    02FAB F559      BNE	0x2FD7
(0184) 	    LCD_CLR();
    02FAC 940E 3876 CALL	_LCD_CLR
(0185) 	 	LCD_Init();	  
    02FAE 940E 3844 CALL	_LCD_Init
(0186)  	 	LCD_const_disp(4,5,"退出    "); 
    02FB0 E68B      LDI	R24,0x6B
    02FB1 E094      LDI	R25,4
    02FB2 8399      STD	Y+1,R25
    02FB3 8388      ST	Y,R24
    02FB4 E025      LDI	R18,5
    02FB5 E004      LDI	R16,4
    02FB6 940E 37D0 CALL	_LCD_const_disp
(0187) 	 	delayms(200);
    02FB8 EC08      LDI	R16,0xC8
    02FB9 E010      LDI	R17,0
    02FBA 940E 23FC CALL	_delayms
(0188) 	 	LCD_const_disp(4,7,".."); 
    02FBC E688      LDI	R24,0x68
    02FBD E094      LDI	R25,4
    02FBE 8399      STD	Y+1,R25
    02FBF 8388      ST	Y,R24
    02FC0 E027      LDI	R18,7
    02FC1 E004      LDI	R16,4
    02FC2 940E 37D0 CALL	_LCD_const_disp
(0189) 	 	delayms(200);
    02FC4 EC08      LDI	R16,0xC8
    02FC5 E010      LDI	R17,0
    02FC6 940E 23FC CALL	_delayms
(0190) 	 	LCD_const_disp(4,8,".."); 	
    02FC8 E688      LDI	R24,0x68
    02FC9 E094      LDI	R25,4
    02FCA 8399      STD	Y+1,R25
    02FCB 8388      ST	Y,R24
    02FCC E028      LDI	R18,0x8
    02FCD E004      LDI	R16,4
    02FCE 940E 37D0 CALL	_LCD_const_disp
(0191) 	 	delayms(500);
    02FD0 EF04      LDI	R16,0xF4
    02FD1 E011      LDI	R17,1
    02FD2 940E 23FC CALL	_delayms
(0192) 	 	LCD_CLR();
    02FD4 940E 3876 CALL	_LCD_CLR
(0193) 	 	return ;
    02FD6 C005      RJMP	0x2FDC
(0194) 	}
(0195)     delayms(30); 
    02FD7 E10E      LDI	R16,0x1E
    02FD8 E010      LDI	R17,0
    02FD9 940E 23FC CALL	_delayms
    02FDB CEF4      RJMP	0x2ED0
    02FDC 9628      ADIW	R28,0x8
    02FDD 940C 3F62 JMP	pop_xgsetF0FC
__GUI_datashow:
  page                 --> R20
  clockfresh           --> R10
    02FDF 940E 3F8C CALL	push_xgsetF00C
    02FE1 2F42      MOV	R20,R18
    02FE2 2EA0      MOV	R10,R16
    02FE3 9722      SBIW	R28,2
(0196) }//end while
(0197) }//end function
(0198) void _GUI_datashow(unsigned char clockfresh,char page){
(0199) 	if( clockfresh ) dateRefresh(clockfresh); //时钟刷新
    02FE4 20AA      TST	R10
    02FE5 F011      BEQ	0x2FE8
    02FE6 2D0A      MOV	R16,R10
    02FE7 D47E      RCALL	_dateRefresh
(0200) 	if(page == 0){
    02FE8 2344      TST	R20
    02FE9 F539      BNE	0x3011
(0201)  	//显示日期时间
(0202) 	    LCD_var_disp(1,1,GUI_get_date());
    02FEA D205      RCALL	_GUI_get_date
    02FEB 8319      STD	Y+1,R17
    02FEC 8308      ST	Y,R16
    02FED E021      LDI	R18,1
    02FEE E001      LDI	R16,1
    02FEF 940E 37FD CALL	_LCD_var_disp
(0203) 	//显示温度
(0204) 	 	LCD_const_disp(2,1,"温度 (℃):");
    02FF1 E58D      LDI	R24,0x5D
    02FF2 E094      LDI	R25,4
    02FF3 8399      STD	Y+1,R25
    02FF4 8388      ST	Y,R24
    02FF5 E021      LDI	R18,1
    02FF6 E002      LDI	R16,2
    02FF7 940E 37D0 CALL	_LCD_const_disp
(0205) 	 	LCD_var_disp(2,6,Result.TempChar);
    02FF9 E68F      LDI	R24,0x6F
    02FFA E095      LDI	R25,5
    02FFB 8399      STD	Y+1,R25
    02FFC 8388      ST	Y,R24
    02FFD E026      LDI	R18,6
    02FFE E002      LDI	R16,2
    02FFF 940E 37FD CALL	_LCD_var_disp
(0206) 	//显示风速
(0207) 	    LCD_const_disp(3,1,"风速(m/s): ");
    03001 E581      LDI	R24,0x51
    03002 E094      LDI	R25,4
    03003 8399      STD	Y+1,R25
    03004 8388      ST	Y,R24
    03005 E021      LDI	R18,1
    03006 E003      LDI	R16,3
    03007 940E 37D0 CALL	_LCD_const_disp
(0208) 	 	LCD_const_disp(3,6,Result.WSChar);
    03009 E789      LDI	R24,0x79
    0300A E095      LDI	R25,5
    0300B 8399      STD	Y+1,R25
    0300C 8388      ST	Y,R24
    0300D E026      LDI	R18,6
    0300E E003      LDI	R16,3
    0300F 940E 37D0 CALL	_LCD_const_disp
(0209) 
(0210) 	 } 
(0211) 	 if(page == 1){
    03011 3041      CPI	R20,1
    03012 F5B9      BNE	0x304A
(0212) 	     LCD_var_disp(1,1,GUI_get_date());
    03013 D1DC      RCALL	_GUI_get_date
    03014 8319      STD	Y+1,R17
    03015 8308      ST	Y,R16
    03016 E021      LDI	R18,1
    03017 E001      LDI	R16,1
    03018 940E 37FD CALL	_LCD_var_disp
(0213) 		 LCD_const_disp(2,1,"风冷指数: ");
    0301A E486      LDI	R24,0x46
    0301B E094      LDI	R25,4
    0301C 8399      STD	Y+1,R25
    0301D 8388      ST	Y,R24
    0301E E021      LDI	R18,1
    0301F E002      LDI	R16,2
    03020 940E 37D0 CALL	_LCD_const_disp
(0214) 		 LCD_var_disp(2,6,Result.WCIChar);						
    03022 E882      LDI	R24,0x82
    03023 E095      LDI	R25,5
    03024 8399      STD	Y+1,R25
    03025 8388      ST	Y,R24
    03026 E026      LDI	R18,6
    03027 E002      LDI	R16,2
    03028 940E 37FD CALL	_LCD_var_disp
(0215) 		 LCD_const_disp(3,1,"等价温度: ");
    0302A E38B      LDI	R24,0x3B
    0302B E094      LDI	R25,4
    0302C 8399      STD	Y+1,R25
    0302D 8388      ST	Y,R24
    0302E E021      LDI	R18,1
    0302F E003      LDI	R16,3
    03030 940E 37D0 CALL	_LCD_const_disp
(0216) 		 LCD_var_disp(3,6,Result.ECTChar);	 
    03032 E88C      LDI	R24,0x8C
    03033 E095      LDI	R25,5
    03034 8399      STD	Y+1,R25
    03035 8388      ST	Y,R24
    03036 E026      LDI	R18,6
    03037 E003      LDI	R16,3
    03038 940E 37FD CALL	_LCD_var_disp
(0217) 		 LCD_const_disp(4,1,"相当温度: ");
    0303A E380      LDI	R24,0x30
    0303B E094      LDI	R25,4
    0303C 8399      STD	Y+1,R25
    0303D 8388      ST	Y,R24
    0303E E021      LDI	R18,1
    0303F E004      LDI	R16,4
    03040 940E 37D0 CALL	_LCD_const_disp
(0218) 		 LCD_var_disp(4,6,Result.TeqChar);	
    03042 E986      LDI	R24,0x96
    03043 E095      LDI	R25,5
    03044 8399      STD	Y+1,R25
    03045 8388      ST	Y,R24
    03046 E026      LDI	R18,6
    03047 E004      LDI	R16,4
    03048 940E 37FD CALL	_LCD_var_disp
(0219) 	 }
(0220) 	 if(page == 2){
    0304A 3042      CPI	R20,2
    0304B F009      BEQ	0x304D
    0304C C03F      RJMP	0x308C
(0221) 	     LCD_var_disp(1,1,GUI_get_date());
    0304D D1A2      RCALL	_GUI_get_date
    0304E 0158      MOVW	R10,R16
    0304F 82B9      STD	Y+1,R11
    03050 82A8      ST	Y,R10
    03051 E021      LDI	R18,1
    03052 E001      LDI	R16,1
    03053 940E 37FD CALL	_LCD_var_disp
(0222) 		 LCD_const_disp(2,1,"冻伤危害性:");
    03055 E284      LDI	R24,0x24
    03056 E094      LDI	R25,4
    03057 8399      STD	Y+1,R25
    03058 8388      ST	Y,R24
    03059 E021      LDI	R18,1
    0305A E002      LDI	R16,2
    0305B 940E 37D0 CALL	_LCD_const_disp
(0223) 	 if(Result.WeiHai==0){LCD_const_disp(3,1,"  冻伤危害性小");			 }
    0305D 9020 059C LDS	R2,Result+90
    0305F 2022      TST	R2
    03060 F449      BNE	0x306A
    03061 E185      LDI	R24,0x15
    03062 E094      LDI	R25,4
    03063 8399      STD	Y+1,R25
    03064 8388      ST	Y,R24
    03065 E021      LDI	R18,1
    03066 E003      LDI	R16,3
    03067 940E 37D0 CALL	_LCD_const_disp
    03069 C022      RJMP	0x308C
(0224) 	 else if(Result.WeiHai==1){	LCD_const_disp(3,1,"  冻伤危害性较大");	 }
    0306A 9180 059C LDS	R24,Result+90
    0306C 3081      CPI	R24,1
    0306D F449      BNE	0x3077
    0306E E084      LDI	R24,4
    0306F E094      LDI	R25,4
    03070 8399      STD	Y+1,R25
    03071 8388      ST	Y,R24
    03072 E021      LDI	R18,1
    03073 E003      LDI	R16,3
    03074 940E 37D0 CALL	_LCD_const_disp
    03076 C015      RJMP	0x308C
(0225) 	 else if(Result.WeiHai==2){	LCD_const_disp(3,1,"  冻伤危害性很大");	 }
    03077 9180 059C LDS	R24,Result+90
    03079 3082      CPI	R24,2
    0307A F449      BNE	0x3084
    0307B EF83      LDI	R24,0xF3
    0307C E093      LDI	R25,3
    0307D 8399      STD	Y+1,R25
    0307E 8388      ST	Y,R24
    0307F E021      LDI	R18,1
    03080 E003      LDI	R16,3
    03081 940E 37D0 CALL	_LCD_const_disp
    03083 C008      RJMP	0x308C
(0226) 	 else LCD_const_disp(3,1,"冻伤危害性小。");
    03084 EE84      LDI	R24,0xE4
    03085 E093      LDI	R25,3
    03086 8399      STD	Y+1,R25
    03087 8388      ST	Y,R24
    03088 E021      LDI	R18,1
    03089 E003      LDI	R16,3
    0308A 940E 37D0 CALL	_LCD_const_disp
(0227) 	 }	  
(0228) 	 if(page==3){
    0308C 3043      CPI	R20,3
    0308D F009      BEQ	0x308F
    0308E C061      RJMP	0x30F0
(0229) 	     LCD_const_disp(1,1,labelH);		
    0308F E689      LDI	R24,0x69
    03090 E092      LDI	R25,2
    03091 8399      STD	Y+1,R25
    03092 8388      ST	Y,R24
    03093 E021      LDI	R18,1
    03094 E001      LDI	R16,1
    03095 940E 37D0 CALL	_LCD_const_disp
(0230) 	 	 switch( Result.WeiHai ){
    03097 9160 059C LDS	R22,Result+90
    03099 2777      CLR	R23
    0309A 3060      CPI	R22,0
    0309B 0767      CPC	R22,R23
    0309C F049      BEQ	0x30A6
    0309D 3061      CPI	R22,1
    0309E E0E0      LDI	R30,0
    0309F 077E      CPC	R23,R30
    030A0 F0F1      BEQ	0x30BF
    030A1 3062      CPI	R22,2
    030A2 E0E0      LDI	R30,0
    030A3 077E      CPC	R23,R30
    030A4 F199      BEQ	0x30D8
    030A5 C04A      RJMP	0x30F0
(0231) 			case 0 :
(0232) 			LCD_const_disp(2,1,H01);
    030A6 E985      LDI	R24,0x95
    030A7 E092      LDI	R25,2
    030A8 8399      STD	Y+1,R25
    030A9 8388      ST	Y,R24
    030AA E021      LDI	R18,1
    030AB E002      LDI	R16,2
    030AC 940E 37D0 CALL	_LCD_const_disp
(0233) 			LCD_const_disp(3,1,H02);
    030AE EA85      LDI	R24,0xA5
    030AF E092      LDI	R25,2
    030B0 8399      STD	Y+1,R25
    030B1 8388      ST	Y,R24
    030B2 E021      LDI	R18,1
    030B3 E003      LDI	R16,3
    030B4 940E 37D0 CALL	_LCD_const_disp
(0234) 			LCD_const_disp(4,1,H03);
    030B6 EB80      LDI	R24,0xB0
    030B7 E092      LDI	R25,2
    030B8 8399      STD	Y+1,R25
    030B9 8388      ST	Y,R24
    030BA E021      LDI	R18,1
    030BB E004      LDI	R16,4
    030BC 940E 37D0 CALL	_LCD_const_disp
(0235) 			break;
    030BE C031      RJMP	0x30F0
(0236) 			case 1 : 
(0237) 			LCD_const_disp(2,1,H11);
    030BF EC8C      LDI	R24,0xCC
    030C0 E092      LDI	R25,2
    030C1 8399      STD	Y+1,R25
    030C2 8388      ST	Y,R24
    030C3 E021      LDI	R18,1
    030C4 E002      LDI	R16,2
    030C5 940E 37D0 CALL	_LCD_const_disp
(0238) 			LCD_const_disp(3,1,H12);
    030C7 EB80      LDI	R24,0xB0
    030C8 E092      LDI	R25,2
    030C9 8399      STD	Y+1,R25
    030CA 8388      ST	Y,R24
    030CB E021      LDI	R18,1
    030CC E003      LDI	R16,3
    030CD 940E 37D0 CALL	_LCD_const_disp
(0239) 			LCD_const_disp(4,1,H13);
    030CF EE85      LDI	R24,0xE5
    030D0 E092      LDI	R25,2
    030D1 8399      STD	Y+1,R25
    030D2 8388      ST	Y,R24
    030D3 E021      LDI	R18,1
    030D4 E004      LDI	R16,4
    030D5 940E 37D0 CALL	_LCD_const_disp
(0240) 			break ;	
    030D7 C018      RJMP	0x30F0
(0241) 			case 2 :
(0242) 			LCD_const_disp(2,1,H21);
    030D8 E189      LDI	R24,0x19
    030D9 E093      LDI	R25,3
    030DA 8399      STD	Y+1,R25
    030DB 8388      ST	Y,R24
    030DC E021      LDI	R18,1
    030DD E002      LDI	R16,2
    030DE 940E 37D0 CALL	_LCD_const_disp
(0243) 			LCD_const_disp(3,1,H22);
    030E0 E28B      LDI	R24,0x2B
    030E1 E093      LDI	R25,3
    030E2 8399      STD	Y+1,R25
    030E3 8388      ST	Y,R24
    030E4 E021      LDI	R18,1
    030E5 E003      LDI	R16,3
    030E6 940E 37D0 CALL	_LCD_const_disp
(0244) 			LCD_const_disp(4,1,H23);
    030E8 EB80      LDI	R24,0xB0
    030E9 E092      LDI	R25,2
    030EA 8399      STD	Y+1,R25
    030EB 8388      ST	Y,R24
    030EC E021      LDI	R18,1
    030ED E004      LDI	R16,4
    030EE 940E 37D0 CALL	_LCD_const_disp
(0245) 			break;
(0246) 			default : ;
(0247) 		}
(0248) 	 } 
(0249) 	 if(page==4){
    030F0 3044      CPI	R20,4
    030F1 F009      BEQ	0x30F3
    030F2 C086      RJMP	0x3179
(0250) 	 		LCD_const_disp(1,1,labelM);		
    030F3 E787      LDI	R24,0x77
    030F4 E092      LDI	R25,2
    030F5 8399      STD	Y+1,R25
    030F6 8388      ST	Y,R24
    030F7 E021      LDI	R18,1
    030F8 E001      LDI	R16,1
    030F9 940E 37D0 CALL	_LCD_const_disp
(0251) 	 		switch( Result.WeiHai ){
    030FB 9160 059C LDS	R22,Result+90
    030FD 2777      CLR	R23
    030FE 3060      CPI	R22,0
    030FF 0767      CPC	R22,R23
    03100 F059      BEQ	0x310C
    03101 3061      CPI	R22,1
    03102 E0E0      LDI	R30,0
    03103 077E      CPC	R23,R30
    03104 F409      BNE	0x3106
    03105 C052      RJMP	0x3158
    03106 3062      CPI	R22,2
    03107 E0E0      LDI	R30,0
    03108 077E      CPC	R23,R30
    03109 F409      BNE	0x310B
    0310A C066      RJMP	0x3171
    0310B C06D      RJMP	0x3179
(0252) 	 			case 0 :
(0253) 				LCD_const_disp(2,1,M01);
    0310C E985      LDI	R24,0x95
    0310D E092      LDI	R25,2
    0310E 8399      STD	Y+1,R25
    0310F 8388      ST	Y,R24
    03110 E021      LDI	R18,1
    03111 E002      LDI	R16,2
    03112 940E 37D0 CALL	_LCD_const_disp
(0254) 				LCD_const_disp(3,1,M02);
    03114 EB80      LDI	R24,0xB0
    03115 E092      LDI	R25,2
    03116 8399      STD	Y+1,R25
    03117 8388      ST	Y,R24
    03118 E021      LDI	R18,1
    03119 E003      LDI	R16,3
    0311A 940E 37D0 CALL	_LCD_const_disp
(0255) 				if(Result.Temperature < 17.7){
    0311C 9040 056D LDS	R4,Result+43
    0311E 9050 056E LDS	R5,Result+44
    03120 9020 056B LDS	R2,Result+41
    03122 9030 056C LDS	R3,Result+42
    03124 EC00      LDI	R16,0xC0
    03125 E010      LDI	R17,0
    03126 940E 3EF5 CALL	elpm32
    03128 933A      ST	-Y,R19
    03129 932A      ST	-Y,R18
    0312A 931A      ST	-Y,R17
    0312B 930A      ST	-Y,R16
    0312C 0181      MOVW	R16,R2
    0312D 0192      MOVW	R18,R4
    0312E 940E 4293 CALL	fpcmp2
    03130 F44C      BGE	0x313A
(0256) 				    LCD_const_disp(4,1,"戴面罩；禁油彩。");
    03131 ED83      LDI	R24,0xD3
    03132 E093      LDI	R25,3
    03133 8399      STD	Y+1,R25
    03134 8388      ST	Y,R24
    03135 E021      LDI	R18,1
    03136 E004      LDI	R16,4
    03137 940E 37D0 CALL	_LCD_const_disp
(0257) 				}
    03139 C03F      RJMP	0x3179
(0258) 				else if(Result.Temperature < 12){
    0313A 9040 056D LDS	R4,Result+43
    0313C 9050 056E LDS	R5,Result+44
    0313E 9020 056B LDS	R2,Result+41
    03140 9030 056C LDS	R3,Result+42
    03142 EB0C      LDI	R16,0xBC
    03143 E010      LDI	R17,0
    03144 940E 3EF5 CALL	elpm32
    03146 933A      ST	-Y,R19
    03147 932A      ST	-Y,R18
    03148 931A      ST	-Y,R17
    03149 930A      ST	-Y,R16
    0314A 0181      MOVW	R16,R2
    0314B 0192      MOVW	R18,R4
    0314C 940E 4293 CALL	fpcmp2
    0314E F554      BGE	0x3179
(0259) 				    LCD_const_disp(4,1,"禁油彩。        \0");
    0314F EC81      LDI	R24,0xC1
    03150 E093      LDI	R25,3
    03151 8399      STD	Y+1,R25
    03152 8388      ST	Y,R24
    03153 E021      LDI	R18,1
    03154 E004      LDI	R16,4
    03155 940E 37D0 CALL	_LCD_const_disp
(0260) 				}
(0261) 				break;
    03157 C021      RJMP	0x3179
(0262) 				case 1 : 
(0263) 			    LCD_const_disp(2,1,M11);
    03158 E985      LDI	R24,0x95
    03159 E092      LDI	R25,2
    0315A 8399      STD	Y+1,R25
    0315B 8388      ST	Y,R24
    0315C E021      LDI	R18,1
    0315D E002      LDI	R16,2
    0315E 940E 37D0 CALL	_LCD_const_disp
(0264) 				LCD_const_disp(3,1,M12);
    03160 EF85      LDI	R24,0xF5
    03161 E092      LDI	R25,2
    03162 8399      STD	Y+1,R25
    03163 8388      ST	Y,R24
    03164 E021      LDI	R18,1
    03165 E003      LDI	R16,3
    03166 940E 37D0 CALL	_LCD_const_disp
(0265) 				LCD_const_disp(4,1,M13);
    03168 E087      LDI	R24,7
    03169 E093      LDI	R25,3
    0316A 8399      STD	Y+1,R25
    0316B 8388      ST	Y,R24
    0316C E021      LDI	R18,1
    0316D E004      LDI	R16,4
    0316E 940E 37D0 CALL	_LCD_const_disp
(0266) 				break ;
    03170 C008      RJMP	0x3179
(0267) 				case 2 :
(0268) 				LCD_const_disp(2,1,M21);
    03171 E38D      LDI	R24,0x3D
    03172 E093      LDI	R25,3
    03173 8399      STD	Y+1,R25
    03174 8388      ST	Y,R24
    03175 E021      LDI	R18,1
    03176 E002      LDI	R16,2
    03177 940E 37D0 CALL	_LCD_const_disp
(0269) 				break ;
(0270) 				default :;
(0271) 	 		}
(0272) 	 }
(0273) 	 if(page==5){
    03179 3045      CPI	R20,5
    0317A F009      BEQ	0x317C
    0317B C071      RJMP	0x31ED
(0274) 	     LCD_const_disp(1,1,labelL);		
    0317C E887      LDI	R24,0x87
    0317D E092      LDI	R25,2
    0317E 8399      STD	Y+1,R25
    0317F 8388      ST	Y,R24
    03180 E021      LDI	R18,1
    03181 E001      LDI	R16,1
    03182 940E 37D0 CALL	_LCD_const_disp
(0275) 	 	 switch( Result.WeiHai ){	
    03184 9140 059C LDS	R20,Result+90
    03186 2755      CLR	R21
    03187 3040      CPI	R20,0
    03188 0745      CPC	R20,R21
    03189 F059      BEQ	0x3195
    0318A 3041      CPI	R20,1
    0318B E0E0      LDI	R30,0
    0318C 075E      CPC	R21,R30
    0318D F409      BNE	0x318F
    0318E C03D      RJMP	0x31CC
    0318F 3042      CPI	R20,2
    03190 E0E0      LDI	R30,0
    03191 075E      CPC	R21,R30
    03192 F409      BNE	0x3194
    03193 C051      RJMP	0x31E5
    03194 C058      RJMP	0x31ED
(0276) 		     case 0 :
(0277) 			 LCD_const_disp(2,1,L01);
    03195 EC82      LDI	R24,0xC2
    03196 E092      LDI	R25,2
    03197 8399      STD	Y+1,R25
    03198 8388      ST	Y,R24
    03199 E021      LDI	R18,1
    0319A E002      LDI	R16,2
    0319B 940E 37D0 CALL	_LCD_const_disp
(0278) 			 if(Result.Temperature < -12) {
    0319D 9040 056D LDS	R4,Result+43
    0319F 9050 056E LDS	R5,Result+44
    031A1 9020 056B LDS	R2,Result+41
    031A3 9030 056C LDS	R3,Result+42
    031A5 EB08      LDI	R16,0xB8
    031A6 E010      LDI	R17,0
    031A7 940E 3EF5 CALL	elpm32
    031A9 933A      ST	-Y,R19
    031AA 932A      ST	-Y,R18
    031AB 931A      ST	-Y,R17
    031AC 930A      ST	-Y,R16
    031AD 0181      MOVW	R16,R2
    031AE 0192      MOVW	R18,R4
    031AF 940E 4293 CALL	fpcmp2
    031B1 F48C      BGE	0x31C3
(0279) 			 LCD_const_disp(3,1,L02);
    031B2 EC8C      LDI	R24,0xCC
    031B3 E092      LDI	R25,2
    031B4 8399      STD	Y+1,R25
    031B5 8388      ST	Y,R24
    031B6 E021      LDI	R18,1
    031B7 E003      LDI	R16,3
    031B8 940E 37D0 CALL	_LCD_const_disp
(0280) 			 LCD_const_disp(4,1,L03);
    031BA ED86      LDI	R24,0xD6
    031BB E092      LDI	R25,2
    031BC 8399      STD	Y+1,R25
    031BD 8388      ST	Y,R24
    031BE E021      LDI	R18,1
    031BF E004      LDI	R16,4
    031C0 940E 37D0 CALL	_LCD_const_disp
(0281) 			 } 
    031C2 C02A      RJMP	0x31ED
(0282) 			 else {
(0283) 			 LCD_const_disp(3,1,L03);
    031C3 ED86      LDI	R24,0xD6
    031C4 E092      LDI	R25,2
    031C5 8399      STD	Y+1,R25
    031C6 8388      ST	Y,R24
    031C7 E021      LDI	R18,1
    031C8 E003      LDI	R16,3
    031C9 940E 37D0 CALL	_LCD_const_disp
(0284) 			 }
(0285) 			 break;
    031CB C021      RJMP	0x31ED
(0286) 			 case 1: 
(0287) 			 LCD_const_disp(2,1,L11);
    031CC E189      LDI	R24,0x19
    031CD E093      LDI	R25,3
    031CE 8399      STD	Y+1,R25
    031CF 8388      ST	Y,R24
    031D0 E021      LDI	R18,1
    031D1 E002      LDI	R16,2
    031D2 940E 37D0 CALL	_LCD_const_disp
(0288) 			 LCD_const_disp(3,1,L12);
    031D4 E28B      LDI	R24,0x2B
    031D5 E093      LDI	R25,3
    031D6 8399      STD	Y+1,R25
    031D7 8388      ST	Y,R24
    031D8 E021      LDI	R18,1
    031D9 E003      LDI	R16,3
    031DA 940E 37D0 CALL	_LCD_const_disp
(0289) 			 LCD_const_disp(3,1,L13);
    031DC EB80      LDI	R24,0xB0
    031DD E092      LDI	R25,2
    031DE 8399      STD	Y+1,R25
    031DF 8388      ST	Y,R24
    031E0 E021      LDI	R18,1
    031E1 E003      LDI	R16,3
    031E2 940E 37D0 CALL	_LCD_const_disp
(0290) 			 break ;
    031E4 C008      RJMP	0x31ED
(0291) 			 case 2 :
(0292) 			 LCD_const_disp(2,1,L21);
    031E5 E38D      LDI	R24,0x3D
    031E6 E093      LDI	R25,3
    031E7 8399      STD	Y+1,R25
    031E8 8388      ST	Y,R24
    031E9 E021      LDI	R18,1
    031EA E002      LDI	R16,2
    031EB 940E 37D0 CALL	_LCD_const_disp
(0293) 			 break;
(0294) 			 default : ;
(0295) 		} //end switch
(0296) 	}  //end if
    031ED 9622      ADIW	R28,2
    031EE 940C 3F93 JMP	pop_xgsetF00C
(0297) }
(0298) char * GUI_get_date(void) {  
(0299)   //格式：2012年12月11日19:00:00
(0300)     GUI_date[0]=Result.Date[4]; 
_GUI_get_date:
    031F0 9020 055C LDS	R2,Result+26
    031F2 9220 034C STS	GUI_date,R2
(0301)     GUI_date[1]=Result.Date[5];
    031F4 9020 055D LDS	R2,Result+27
    031F6 9220 034D STS	GUI_date+1,R2
(0302)     GUI_date[4]=Result.Date[6];
    031F8 9020 055E LDS	R2,Result+28
    031FA 9220 0350 STS	GUI_date+4,R2
(0303)     GUI_date[5]=Result.Date[7];
    031FC 9020 055F LDS	R2,Result+29
    031FE 9220 0351 STS	GUI_date+5,R2
(0304)     GUI_date[8]=Result.Time[0];
    03200 9020 0561 LDS	R2,Result+31
    03202 9220 0354 STS	GUI_date+8,R2
(0305)     GUI_date[9]=Result.Time[1];
    03204 9020 0562 LDS	R2,Result+32
    03206 9220 0355 STS	GUI_date+9,R2
(0306)     GUI_date[11]=Result.Time[4];
    03208 9020 0565 LDS	R2,Result+35
    0320A 9220 0357 STS	GUI_date+11,R2
(0307)     GUI_date[12]=Result.Time[5];
    0320C 9020 0566 LDS	R2,Result+36
    0320E 9220 0358 STS	GUI_date+12,R2
(0308)     GUI_date[14]=Result.Time[8];
    03210 9020 0569 LDS	R2,Result+39
    03212 9220 035A STS	GUI_date+14,R2
(0309)     GUI_date[15]=Result.Time[9];
    03214 9020 056A LDS	R2,Result+40
    03216 9220 035B STS	GUI_date+15,R2
(0310)     GUI_date[16]='\0';
    03218 2422      CLR	R2
    03219 9220 035C STS	GUI_date+16,R2
(0311)     return GUI_date;
    0321B E40C      LDI	R16,0x4C
    0321C E013      LDI	R17,3
    0321D 9508      RET
_GUI_set_time:
  GUI_down             --> Y,+5
  GUI_up               --> Y,+2
  pT                   --> R14
  ary                  --> R12
  p                    --> Y,+10
  i                    --> R20
  keyc                 --> R22
  pD                   --> Y,+8
    0321E 940E 3F6D CALL	push_xgsetF0FC
    03220 972B      SBIW	R28,0xB
(0312) }
(0313) //设置时间 菜单 
(0314) void GUI_set_time(void){
(0315)     unsigned char p=2;
    03221 E082      LDI	R24,2
    03222 878A      STD	Y+10,R24
(0316) 	char GUI_up[]= "↑";
    03223 E58D      LDI	R24,0x5D
    03224 E093      LDI	R25,3
    03225 01FE      MOVW	R30,R28
    03226 9632      ADIW	R30,2
    03227 E003      LDI	R16,3
    03228 E010      LDI	R17,0
    03229 93FA      ST	-Y,R31
    0322A 93EA      ST	-Y,R30
    0322B 939A      ST	-Y,R25
    0322C 938A      ST	-Y,R24
    0322D 940E 4014 CALL	asgnblk
(0317) 	char GUI_down[]= "↓";
    0322F E680      LDI	R24,0x60
    03230 E093      LDI	R25,3
    03231 01FE      MOVW	R30,R28
    03232 9635      ADIW	R30,5
    03233 E003      LDI	R16,3
    03234 E010      LDI	R17,0
    03235 93FA      ST	-Y,R31
    03236 93EA      ST	-Y,R30
    03237 939A      ST	-Y,R25
    03238 938A      ST	-Y,R24
    03239 940E 4014 CALL	asgnblk
(0318) 	char *pD=NULL,*pT=NULL;
    0323B 2400      CLR	R0
    0323C 2411      CLR	R1
    0323D 8619      STD	Y+9,R1
    0323E 8608      STD	Y+8,R0
(0319) 	char *ary=GUI_up;
    0323F 01CE      MOVW	R24,R28
    03240 9602      ADIW	R24,2
    03241 016C      MOVW	R12,R24
(0320) 	unsigned char i=0,keyc=NO_KEY;
    03242 2744      CLR	R20
    03243 2766      CLR	R22
(0321) 	LCD_CLR(); //清屏
    03244 940E 3876 CALL	_LCD_CLR
(0322) 	pD="2012年12月31日\0";
    03246 EB81      LDI	R24,0xB1
    03247 E093      LDI	R25,3
    03248 8799      STD	Y+9,R25
    03249 8788      STD	Y+8,R24
(0323) 	pT=Result.Time;
    0324A E681      LDI	R24,0x61
    0324B E095      LDI	R25,5
    0324C 017C      MOVW	R14,R24
(0324) 	LCD_const_disp(1,1,"时间设置:       ");
    0324D EA80      LDI	R24,0xA0
    0324E E093      LDI	R25,3
    0324F 8399      STD	Y+1,R25
    03250 8388      ST	Y,R24
    03251 E021      LDI	R18,1
    03252 E001      LDI	R16,1
    03253 940E 37D0 CALL	_LCD_const_disp
(0325) 	LCD_const_disp(4,7,"保存");
    03255 E98B      LDI	R24,0x9B
    03256 E093      LDI	R25,3
    03257 8399      STD	Y+1,R25
    03258 8388      ST	Y,R24
    03259 E027      LDI	R18,7
    0325A E004      LDI	R16,4
    0325B 940E 37D0 CALL	_LCD_const_disp
(0326) 	LCD_var_disp(3,p,ary);
    0325D 82D9      STD	Y+1,R13
    0325E 82C8      ST	Y,R12
    0325F 852A      LDD	R18,Y+10
    03260 E003      LDI	R16,3
    03261 940E 37FD CALL	_LCD_var_disp
(0327) 	LCD_var_disp(2,1,pD);
    03263 8408      LDD	R0,Y+8
    03264 8419      LDD	R1,Y+9
    03265 8219      STD	Y+1,R1
    03266 8208      ST	Y,R0
    03267 E021      LDI	R18,1
    03268 E002      LDI	R16,2
    03269 940E 37FD CALL	_LCD_var_disp
(0328) 	LCD_var_disp(4,1,pT);
    0326B 82F9      STD	Y+1,R15
    0326C 82E8      ST	Y,R14
    0326D E021      LDI	R18,1
    0326E E004      LDI	R16,4
    0326F 940E 37FD CALL	_LCD_var_disp
(0329) 	delayms(250);
    03271 EF0A      LDI	R16,0xFA
    03272 E010      LDI	R17,0
    03273 940E 23FC CALL	_delayms
    03275 C1EC      RJMP	0x3462
(0330) 	while(1){
(0331) 	    keyc=kbscan();
    03276 940E 3DBF CALL	_kbscan
    03278 2F60      MOV	R22,R16
(0332) 		pD[2]=Result.Date[2];
    03279 9020 055A LDS	R2,Result+24
    0327B 85E8      LDD	R30,Y+8
    0327C 85F9      LDD	R31,Y+9
    0327D 8222      STD	Z+2,R2
(0333) 		pD[3]=Result.Date[3];
    0327E 9020 055B LDS	R2,Result+25
    03280 8223      STD	Z+3,R2
(0334) 		pD[6]=Result.Date[4];
    03281 9020 055C LDS	R2,Result+26
    03283 8226      STD	Z+6,R2
(0335) 		pD[7]=Result.Date[5];
    03284 9020 055D LDS	R2,Result+27
    03286 8227      STD	Z+7,R2
(0336) 		pD[10]=Result.Date[6];
    03287 9020 055E LDS	R2,Result+28
    03289 8622      STD	Z+10,R2
(0337) 		pD[11]=Result.Date[7];  
    0328A 9020 055F LDS	R2,Result+29
    0328C 8623      STD	Z+11,R2
(0338) 
(0339) 		switch(i){
    0328D 2EA4      MOV	R10,R20
    0328E 24BB      CLR	R11
    0328F 20AA      TST	R10
    03290 F411      BNE	0x3293
    03291 20BB      TST	R11
    03292 F0D9      BEQ	0x32AE
    03293 01C5      MOVW	R24,R10
    03294 3081      CPI	R24,1
    03295 E0E0      LDI	R30,0
    03296 079E      CPC	R25,R30
    03297 F409      BNE	0x3299
    03298 C049      RJMP	0x32E2
    03299 3082      CPI	R24,2
    0329A E0E0      LDI	R30,0
    0329B 079E      CPC	R25,R30
    0329C F409      BNE	0x329E
    0329D C07D      RJMP	0x331B
    0329E 3083      CPI	R24,3
    0329F E0E0      LDI	R30,0
    032A0 079E      CPC	R25,R30
    032A1 F409      BNE	0x32A3
    032A2 C0C1      RJMP	0x3364
    032A3 3084      CPI	R24,4
    032A4 E0E0      LDI	R30,0
    032A5 079E      CPC	R25,R30
    032A6 F409      BNE	0x32A8
    032A7 C0F6      RJMP	0x339E
    032A8 3085      CPI	R24,5
    032A9 E0E0      LDI	R30,0
    032AA 079E      CPC	R25,R30
    032AB F409      BNE	0x32AD
    032AC C12A      RJMP	0x33D7
    032AD C165      RJMP	0x3413
(0340)             case 0: p=2;ary=GUI_up;  //年
    032AE E082      LDI	R24,2
    032AF 878A      STD	Y+10,R24
    032B0 01CE      MOVW	R24,R28
    032B1 9602      ADIW	R24,2
    032B2 016C      MOVW	R12,R24
(0341) 		 	  	 if(keyc==up){
    032B3 316E      CPI	R22,0x1E
    032B4 F491      BNE	0x32C7
(0342) 				     if(time_buf[1]<0x99){ 
    032B5 9180 04E7 LDS	R24,time_buf+1
    032B7 3989      CPI	R24,0x99
    032B8 F008      BCS	0x32BA
    032B9 C159      RJMP	0x3413
(0343) 					     time_buf[1]++;
    032BA 5F8F      SUBI	R24,0xFF
    032BB 9380 04E7 STS	time_buf+1,R24
(0344) 						 if((time_buf[1]&0x0f)==0x0a) 
    032BD 708F      ANDI	R24,0xF
    032BE 308A      CPI	R24,0xA
    032BF F009      BEQ	0x32C1
    032C0 C152      RJMP	0x3413
(0345) 						     time_buf[1]=time_buf[1]+6;
    032C1 9180 04E7 LDS	R24,time_buf+1
    032C3 5F8A      SUBI	R24,0xFA
    032C4 9380 04E7 STS	time_buf+1,R24
(0346) 					 }
(0347) 												     
(0348) 				}				  
    032C6 C14C      RJMP	0x3413
(0349)  					        
(0350) 			    else if(keyc==down){ 
    032C7 316D      CPI	R22,0x1D
    032C8 F4A1      BNE	0x32DD
(0351) 				    if(time_buf[1]>0x00){
    032C9 E080      LDI	R24,0
    032CA 9020 04E7 LDS	R2,time_buf+1
    032CC 1582      CP	R24,R2
    032CD F008      BCS	0x32CF
    032CE C144      RJMP	0x3413
(0352) 				        time_buf[1]--;
    032CF 2D82      MOV	R24,R2
    032D0 5081      SUBI	R24,1
    032D1 9380 04E7 STS	time_buf+1,R24
(0353) 						if((time_buf[1]&0x0f)==0x0f) 
    032D3 708F      ANDI	R24,0xF
    032D4 308F      CPI	R24,0xF
    032D5 F009      BEQ	0x32D7
    032D6 C13C      RJMP	0x3413
(0354) 						    time_buf[1]=time_buf[1]-6;
    032D7 9180 04E7 LDS	R24,time_buf+1
    032D9 5086      SUBI	R24,6
    032DA 9380 04E7 STS	time_buf+1,R24
(0355) 		 	  	 		 }
(0356) 												   
(0357) 					}			   		
    032DC C136      RJMP	0x3413
(0358) 				else if(keyc==right) {i=1;}
    032DD 3167      CPI	R22,0x17
    032DE F009      BEQ	0x32E0
    032DF C133      RJMP	0x3413
    032E0 E041      LDI	R20,1
(0359) 				break;
    032E1 C131      RJMP	0x3413
(0360) 		 case 1:p=4;ary=GUI_up;  //月
    032E2 E084      LDI	R24,4
    032E3 878A      STD	Y+10,R24
    032E4 01CE      MOVW	R24,R28
    032E5 9602      ADIW	R24,2
    032E6 016C      MOVW	R12,R24
(0361) 		  	  	if(keyc==up){
    032E7 316E      CPI	R22,0x1E
    032E8 F499      BNE	0x32FC
(0362) 				    if(time_buf[2]<0x12){  
    032E9 9180 04E8 LDS	R24,time_buf+2
    032EB 3182      CPI	R24,0x12
    032EC F460      BCC	0x32F9
(0363) 					    time_buf[2]++;	
    032ED 5F8F      SUBI	R24,0xFF
    032EE 9380 04E8 STS	time_buf+2,R24
(0364) 						if((time_buf[2]&0x0f)==0x0a) time_buf[2]+=6;
    032F0 708F      ANDI	R24,0xF
    032F1 308A      CPI	R24,0xA
    032F2 F449      BNE	0x32FC
    032F3 9180 04E8 LDS	R24,time_buf+2
    032F5 5F8A      SUBI	R24,0xFA
    032F6 9380 04E8 STS	time_buf+2,R24
(0365) 					}
    032F8 C003      RJMP	0x32FC
(0366) 					else 
(0367) 					    time_buf[2]=0x01;
    032F9 E081      LDI	R24,1
    032FA 9380 04E8 STS	time_buf+2,R24
(0368) 				}						 
(0369) 				if(keyc==down){ 
    032FC 316D      CPI	R22,0x1D
    032FD F4A9      BNE	0x3313
(0370) 				    if(time_buf[2]>0x01){  
    032FE E081      LDI	R24,1
    032FF 9020 04E8 LDS	R2,time_buf+2
    03301 1582      CP	R24,R2
    03302 F468      BCC	0x3310
(0371) 					    time_buf[2]--;	
    03303 2D82      MOV	R24,R2
    03304 5081      SUBI	R24,1
    03305 9380 04E8 STS	time_buf+2,R24
(0372) 						if((time_buf[2]&0x0f)==0x0f) 
    03307 708F      ANDI	R24,0xF
    03308 308F      CPI	R24,0xF
    03309 F449      BNE	0x3313
(0373) 						    time_buf[2]-=6;
    0330A 9180 04E8 LDS	R24,time_buf+2
    0330C 5086      SUBI	R24,6
    0330D 9380 04E8 STS	time_buf+2,R24
(0374) 			  		}
    0330F C003      RJMP	0x3313
(0375) 				    else 
(0376) 					    time_buf[2]=0x12;						
    03310 E182      LDI	R24,0x12
    03311 9380 04E8 STS	time_buf+2,R24
(0377) 				}						 							
(0378) 				if(keyc==left){
    03313 316B      CPI	R22,0x1B
    03314 F409      BNE	0x3316
(0379) 				    i=0;   
    03315 2744      CLR	R20
(0380) 				}									
(0381) 				if(keyc==right){
    03316 3167      CPI	R22,0x17
    03317 F009      BEQ	0x3319
    03318 C0FA      RJMP	0x3413
(0382) 				    i=2;   
    03319 E042      LDI	R20,2
(0383) 				}  
(0384) 				break;
    0331A C0F8      RJMP	0x3413
(0385) 	 	 case 2: p=6;ary=GUI_up;
    0331B E086      LDI	R24,6
    0331C 878A      STD	Y+10,R24
    0331D 01CE      MOVW	R24,R28
    0331E 9602      ADIW	R24,2
    0331F 016C      MOVW	R12,R24
(0386) 		 	  	 if(keyc==up){ 
    03320 316E      CPI	R22,0x1E
    03321 F519      BNE	0x3345
(0387) 				     if(time_buf[3]<0x31){ 
    03322 9180 04E9 LDS	R24,time_buf+3
    03324 3381      CPI	R24,0x31
    03325 F5B0      BCC	0x335C
(0388) 				         time_buf[3]++;
    03326 5F8F      SUBI	R24,0xFF
    03327 9380 04E9 STS	time_buf+3,R24
(0389) 						 if ((time_buf[3]&0x0f)==0x0a) time_buf[3]=time_buf[3]+6;
    03329 708F      ANDI	R24,0xF
    0332A 308A      CPI	R24,0xA
    0332B F429      BNE	0x3331
    0332C 9180 04E9 LDS	R24,time_buf+3
    0332E 5F8A      SUBI	R24,0xFA
    0332F 9380 04E9 STS	time_buf+3,R24
(0390) 						 if(  //2 4 6 9 11 月最大30天
(0391) 						  ( ((time_buf[2]==0x02) || (time_buf[2]==0x04)|| (time_buf[2]==0x06)||
    03331 9180 04E8 LDS	R24,time_buf+2
    03333 3082      CPI	R24,2
    03334 F041      BEQ	0x333D
    03335 3084      CPI	R24,4
    03336 F031      BEQ	0x333D
    03337 3086      CPI	R24,6
    03338 F021      BEQ	0x333D
    03339 3089      CPI	R24,0x9
    0333A F011      BEQ	0x333D
    0333B 3181      CPI	R24,0x11
    0333C F4F9      BNE	0x335C
    0333D 9180 04E9 LDS	R24,time_buf+3
    0333F 3381      CPI	R24,0x31
    03340 F4D9      BNE	0x335C
(0392) 						  (time_buf[2]==0x09)||(time_buf[2]==0x11))&&(time_buf[3]==0x31))){
(0393) 						      time_buf[3]=0x30;
    03341 E380      LDI	R24,0x30
    03342 9380 04E9 STS	time_buf+3,R24
(0394) 						}
(0395) 				     }
(0396)  									  
(0397)  				 }
    03344 C017      RJMP	0x335C
(0398) 			     else if(keyc==down){ 
    03345 316D      CPI	R22,0x1D
    03346 F4A9      BNE	0x335C
(0399) 				      if(time_buf[3]>0x01){  
    03347 E081      LDI	R24,1
    03348 9020 04E9 LDS	R2,time_buf+3
    0334A 1582      CP	R24,R2
    0334B F468      BCC	0x3359
(0400) 					     time_buf[3]--;
    0334C 2D82      MOV	R24,R2
    0334D 5081      SUBI	R24,1
    0334E 9380 04E9 STS	time_buf+3,R24
(0401) 				 	  	 if((time_buf[3]&0x0f)==0x0f) time_buf[3]=time_buf[3]-6;
    03350 708F      ANDI	R24,0xF
    03351 308F      CPI	R24,0xF
    03352 F449      BNE	0x335C
    03353 9180 04E9 LDS	R24,time_buf+3
    03355 5086      SUBI	R24,6
    03356 9380 04E9 STS	time_buf+3,R24
(0402) 		 	  	 	 }
    03358 C003      RJMP	0x335C
(0403) 					 else time_buf[3]=0x31;						
    03359 E381      LDI	R24,0x31
    0335A 9380 04E9 STS	time_buf+3,R24
(0404) 											   
(0405) 				}
(0406) 				if(keyc==left) {i=1;  }						 			   		
    0335C 316B      CPI	R22,0x1B
    0335D F409      BNE	0x335F
    0335E E041      LDI	R20,1
(0407) 				if(keyc==right) {i=3;    }  	
    0335F 3167      CPI	R22,0x17
    03360 F009      BEQ	0x3362
    03361 C0B1      RJMP	0x3413
    03362 E043      LDI	R20,3
(0408) 				break;
    03363 C0AF      RJMP	0x3413
(0409) 		case 3:p=1;ary=GUI_down;
    03364 2400      CLR	R0
    03365 9403      INC	R0
    03366 860A      STD	Y+10,R0
    03367 01CE      MOVW	R24,R28
    03368 9605      ADIW	R24,5
    03369 016C      MOVW	R12,R24
(0410)  	  	if(keyc==up){ if(time_buf[4]<0x23){  time_buf[4]++;	
    0336A 316E      CPI	R22,0x1E
    0336B F499      BNE	0x337F
    0336C 9180 04EA LDS	R24,time_buf+4
    0336E 3283      CPI	R24,0x23
    0336F F460      BCC	0x337C
    03370 5F8F      SUBI	R24,0xFF
    03371 9380 04EA STS	time_buf+4,R24
(0411) 													if((time_buf[4]&0x0f)==0x0a) time_buf[4]+=6;
    03373 708F      ANDI	R24,0xF
    03374 308A      CPI	R24,0xA
    03375 F449      BNE	0x337F
    03376 9180 04EA LDS	R24,time_buf+4
    03378 5F8A      SUBI	R24,0xFA
    03379 9380 04EA STS	time_buf+4,R24
(0412) 													 
(0413) 													
(0414) 												 }
    0337B C003      RJMP	0x337F
(0415) 							else time_buf[4]=0x00;
    0337C 2422      CLR	R2
    0337D 9220 04EA STS	time_buf+4,R2
(0416) 						  }						 
(0417) 				if(keyc==down){ if(time_buf[4]>0x00){  time_buf[4]--;	
    0337F 316D      CPI	R22,0x1D
    03380 F4A9      BNE	0x3396
    03381 E080      LDI	R24,0
    03382 9020 04EA LDS	R2,time_buf+4
    03384 1582      CP	R24,R2
    03385 F468      BCC	0x3393
    03386 2D82      MOV	R24,R2
    03387 5081      SUBI	R24,1
    03388 9380 04EA STS	time_buf+4,R24
(0418) 													if((time_buf[4]&0x0f)==0x0f) time_buf[4]-=6;
    0338A 708F      ANDI	R24,0xF
    0338B 308F      CPI	R24,0xF
    0338C F449      BNE	0x3396
    0338D 9180 04EA LDS	R24,time_buf+4
    0338F 5086      SUBI	R24,6
    03390 9380 04EA STS	time_buf+4,R24
(0419) 													
(0420) 												 }
    03392 C003      RJMP	0x3396
(0421) 							 else time_buf[4]=0x23;						
    03393 E283      LDI	R24,0x23
    03394 9380 04EA STS	time_buf+4,R24
(0422) 						  }	
(0423) 		if(keyc==left ) {i=2;   } 				  
    03396 316B      CPI	R22,0x1B
    03397 F409      BNE	0x3399
    03398 E042      LDI	R20,2
(0424) 		if(keyc==right) {i=4;    } 
    03399 3167      CPI	R22,0x17
    0339A F009      BEQ	0x339C
    0339B C077      RJMP	0x3413
    0339C E044      LDI	R20,4
(0425) 		break;						  					 			
    0339D C075      RJMP	0x3413
(0426)  case 4:p=3;ary=GUI_down;
    0339E E083      LDI	R24,3
    0339F 878A      STD	Y+10,R24
    033A0 01CE      MOVW	R24,R28
    033A1 9605      ADIW	R24,5
    033A2 016C      MOVW	R12,R24
(0427)  	  	if(keyc==up){ if(time_buf[5]<0x59){  time_buf[5]++;	
    033A3 316E      CPI	R22,0x1E
    033A4 F499      BNE	0x33B8
    033A5 9180 04EB LDS	R24,time_buf+5
    033A7 3589      CPI	R24,0x59
    033A8 F460      BCC	0x33B5
    033A9 5F8F      SUBI	R24,0xFF
    033AA 9380 04EB STS	time_buf+5,R24
(0428) 											 if((time_buf[5]&0x0f)==0x0a) time_buf[5]+=6;
    033AC 708F      ANDI	R24,0xF
    033AD 308A      CPI	R24,0xA
    033AE F449      BNE	0x33B8
    033AF 9180 04EB LDS	R24,time_buf+5
    033B1 5F8A      SUBI	R24,0xFA
    033B2 9380 04EB STS	time_buf+5,R24
(0429) 										  }
    033B4 C003      RJMP	0x33B8
(0430) 					  else time_buf[5]=0x00;
    033B5 2422      CLR	R2
    033B6 9220 04EB STS	time_buf+5,R2
(0431) 					}						 
(0432) 		if(keyc==down){ if(time_buf[5]>0x00){  time_buf[5]--;	
    033B8 316D      CPI	R22,0x1D
    033B9 F4A9      BNE	0x33CF
    033BA E080      LDI	R24,0
    033BB 9020 04EB LDS	R2,time_buf+5
    033BD 1582      CP	R24,R2
    033BE F468      BCC	0x33CC
    033BF 2D82      MOV	R24,R2
    033C0 5081      SUBI	R24,1
    033C1 9380 04EB STS	time_buf+5,R24
(0433) 												if((time_buf[5]&0x0f)==0x0f) time_buf[5]-=6;
    033C3 708F      ANDI	R24,0xF
    033C4 308F      CPI	R24,0xF
    033C5 F449      BNE	0x33CF
    033C6 9180 04EB LDS	R24,time_buf+5
    033C8 5086      SUBI	R24,6
    033C9 9380 04EB STS	time_buf+5,R24
(0434) 											}
    033CB C003      RJMP	0x33CF
(0435) 						else time_buf[5]=0x59;						
    033CC E589      LDI	R24,0x59
    033CD 9380 04EB STS	time_buf+5,R24
(0436) 					  }
(0437) 		if(keyc==left ) {i=3;    } 		  						 								  			
    033CF 316B      CPI	R22,0x1B
    033D0 F409      BNE	0x33D2
    033D1 E043      LDI	R20,3
(0438)  		if(keyc==right) {i=5;   }	
    033D2 3167      CPI	R22,0x17
    033D3 F009      BEQ	0x33D5
    033D4 C03E      RJMP	0x3413
    033D5 E045      LDI	R20,5
(0439) 		break;			   
    033D6 C03C      RJMP	0x3413
(0440)  case 5:p=5;ary=GUI_down;
    033D7 E085      LDI	R24,5
    033D8 878A      STD	Y+10,R24
    033D9 01CE      MOVW	R24,R28
    033DA 9605      ADIW	R24,5
    033DB 016C      MOVW	R12,R24
(0441)  	  	if(keyc==up){ if(time_buf[6]<0x59){  time_buf[6]++;	
    033DC 316E      CPI	R22,0x1E
    033DD F499      BNE	0x33F1
    033DE 9180 04EC LDS	R24,time_buf+6
    033E0 3589      CPI	R24,0x59
    033E1 F460      BCC	0x33EE
    033E2 5F8F      SUBI	R24,0xFF
    033E3 9380 04EC STS	time_buf+6,R24
(0442) 											 if((time_buf[6]&0x0f)==0x0a) time_buf[6]+=6;
    033E5 708F      ANDI	R24,0xF
    033E6 308A      CPI	R24,0xA
    033E7 F449      BNE	0x33F1
    033E8 9180 04EC LDS	R24,time_buf+6
    033EA 5F8A      SUBI	R24,0xFA
    033EB 9380 04EC STS	time_buf+6,R24
(0443) 										 }
    033ED C003      RJMP	0x33F1
(0444) 					  else time_buf[6]=0x00;
    033EE 2422      CLR	R2
    033EF 9220 04EC STS	time_buf+6,R2
(0445) 					}						 
(0446) 		if(keyc==down){ if(time_buf[6]>0x00){  time_buf[6]--;	
    033F1 316D      CPI	R22,0x1D
    033F2 F4A9      BNE	0x3408
    033F3 E080      LDI	R24,0
    033F4 9020 04EC LDS	R2,time_buf+6
    033F6 1582      CP	R24,R2
    033F7 F468      BCC	0x3405
    033F8 2D82      MOV	R24,R2
    033F9 5081      SUBI	R24,1
    033FA 9380 04EC STS	time_buf+6,R24
(0447) 						if((time_buf[6]&0x0f)==0x0f) time_buf[6]-=6;
    033FC 708F      ANDI	R24,0xF
    033FD 308F      CPI	R24,0xF
    033FE F449      BNE	0x3408
    033FF 9180 04EC LDS	R24,time_buf+6
    03401 5086      SUBI	R24,6
    03402 9380 04EC STS	time_buf+6,R24
(0448) 					  }
    03404 C003      RJMP	0x3408
(0449) 		else time_buf[6]=0x59;		}				
    03405 E589      LDI	R24,0x59
    03406 9380 04EC STS	time_buf+6,R24
(0450) 		if(keyc==left ) {i=4;    } 		  				 														   
    03408 316B      CPI	R22,0x1B
    03409 F409      BNE	0x340B
    0340A E044      LDI	R20,4
(0451) 		if(keyc==right) {i=6;p=1;ary=NULL;}  
    0340B 3167      CPI	R22,0x17
    0340C F431      BNE	0x3413
    0340D E046      LDI	R20,6
    0340E 2400      CLR	R0
    0340F 9403      INC	R0
    03410 860A      STD	Y+10,R0
    03411 24CC      CLR	R12
    03412 24DD      CLR	R13
(0452) 		break;           
(0453) 							 
(0454) 		 }//endcase
(0455)  		 dateRefresh(0);
    03413 2700      CLR	R16
    03414 D051      RCALL	_dateRefresh
(0456) 		 
(0457) 		 LCD_const_disp(3,1,"                "); //清空箭头 
    03415 E88A      LDI	R24,0x8A
    03416 E093      LDI	R25,3
    03417 8399      STD	Y+1,R25
    03418 8388      ST	Y,R24
    03419 E021      LDI	R18,1
    0341A E003      LDI	R16,3
    0341B 940E 37D0 CALL	_LCD_const_disp
(0458)  		 LCD_var_disp(3,p,ary); //显示箭头 
    0341D 82D9      STD	Y+1,R13
    0341E 82C8      ST	Y,R12
    0341F 852A      LDD	R18,Y+10
    03420 E003      LDI	R16,3
    03421 940E 37FD CALL	_LCD_var_disp
(0459)  		 LCD_var_disp(2,1,pD);  //显示日期
    03423 8408      LDD	R0,Y+8
    03424 8419      LDD	R1,Y+9
    03425 8219      STD	Y+1,R1
    03426 8208      ST	Y,R0
    03427 E021      LDI	R18,1
    03428 E002      LDI	R16,2
    03429 940E 37FD CALL	_LCD_var_disp
(0460)  		 LCD_var_disp(4,1,pT);  //显示时间
    0342B 82F9      STD	Y+1,R15
    0342C 82E8      ST	Y,R14
    0342D E021      LDI	R18,1
    0342E E004      LDI	R16,4
    0342F 940E 37FD CALL	_LCD_var_disp
(0461)  if(keyc==lright) {		  
    03431 3967      CPI	R22,0x97
    03432 F479      BNE	0x3442
(0462)  		  LCD_const_disp(3,1,"        放弃修改"); 
    03433 E789      LDI	R24,0x79
    03434 E093      LDI	R25,3
    03435 8399      STD	Y+1,R25
    03436 8388      ST	Y,R24
    03437 E021      LDI	R18,1
    03438 E003      LDI	R16,3
    03439 940E 37D0 CALL	_LCD_const_disp
(0463) 		  delayms(500);
    0343B EF04      LDI	R16,0xF4
    0343C E011      LDI	R17,1
    0343D 940E 23FC CALL	_delayms
(0464) 		  LCD_CLR(); //清屏
    0343F 940E 3876 CALL	_LCD_CLR
(0465) 		  return ;} 
    03441 C021      RJMP	0x3463
(0466)  keyc=NO_KEY;
    03442 2766      CLR	R22
(0467)  if(i==6){    //各值改变完成后 显示已保存 清屏 返回
    03443 3046      CPI	R20,6
    03444 F4C9      BNE	0x345E
(0468) 		  ds1302_write_time(); 
    03445 940E 3D72 CALL	_ds1302_write_time
(0469)           LCD_const_disp(4,7,"    ");		  
    03447 E784      LDI	R24,0x74
    03448 E093      LDI	R25,3
    03449 8399      STD	Y+1,R25
    0344A 8388      ST	Y,R24
    0344B E027      LDI	R18,7
    0344C E004      LDI	R16,4
    0344D 940E 37D0 CALL	_LCD_const_disp
(0470) 		  LCD_const_disp(3,1,"          已保存"); 
    0344F E683      LDI	R24,0x63
    03450 E093      LDI	R25,3
    03451 8399      STD	Y+1,R25
    03452 8388      ST	Y,R24
    03453 E021      LDI	R18,1
    03454 E003      LDI	R16,3
    03455 940E 37D0 CALL	_LCD_const_disp
(0471) 		  delayms(500);
    03457 EF04      LDI	R16,0xF4
    03458 E011      LDI	R17,1
    03459 940E 23FC CALL	_delayms
(0472) 		  LCD_CLR(); //清屏
    0345B 940E 3876 CALL	_LCD_CLR
(0473) 		  return ;
    0345D C005      RJMP	0x3463
(0474) 		  }
(0475)  delayms(2);	  
    0345E E002      LDI	R16,2
    0345F E010      LDI	R17,0
    03460 940E 23FC CALL	_delayms
    03462 CE13      RJMP	0x3276
    03463 962B      ADIW	R28,0xB
    03464 940C 3F62 JMP	pop_xgsetF0FC
_dateRefresh:
  readhardware         --> R20
    03466 934A      ST	-Y,R20
    03467 2F40      MOV	R20,R16
(0476) }//endwhile(1)
(0477) 
(0478) 
(0479) }
(0480) ////////////////////////////////////
(0481) //  函数作用
(0482) //   将ds1302中缓存的时钟数据转换进结构体中
(0483) ////////////////////////////////////
(0484) void dateRefresh(unsigned char readhardware)
(0485) {	
(0486) 	if( readhardware==1 ){
    03468 3041      CPI	R20,1
    03469 F411      BNE	0x346C
(0487) 		ds1302_read_time();
    0346A 940E 3D97 CALL	_ds1302_read_time
(0488) 	}
(0489) 	t.tm_sec=(((time_buf[6]&0x70)>>4)*10)+(time_buf[6]&0x0f);
    0346C 9110 04EC LDS	R17,time_buf+6
    0346E 7710      ANDI	R17,0x70
    0346F 9512      SWAP	R17
    03470 701F      ANDI	R17,0xF
    03471 E00A      LDI	R16,0xA
    03472 0301      MULSU	R16,R17
    03473 0110      MOVW	R2,R0
    03474 9180 04EC LDS	R24,time_buf+6
    03476 2799      CLR	R25
    03477 708F      ANDI	R24,0xF
    03478 7090      ANDI	R25,0
    03479 0E28      ADD	R2,R24
    0347A 1E39      ADC	R3,R25
    0347B 9230 07A1 STS	t+1,R3
    0347D 9220 07A0 STS	t,R2
(0490) 	t.tm_min=  (((time_buf[5]&0x70)>>4)*10)+(time_buf[5]&0x0f);
    0347F 9110 04EB LDS	R17,time_buf+5
    03481 7710      ANDI	R17,0x70
    03482 9512      SWAP	R17
    03483 701F      ANDI	R17,0xF
    03484 0301      MULSU	R16,R17
    03485 0110      MOVW	R2,R0
    03486 9180 04EB LDS	R24,time_buf+5
    03488 2799      CLR	R25
    03489 708F      ANDI	R24,0xF
    0348A 7090      ANDI	R25,0
    0348B 0E28      ADD	R2,R24
    0348C 1E39      ADC	R3,R25
    0348D 9230 07A3 STS	t+3,R3
    0348F 9220 07A2 STS	t+2,R2
(0491) 	t.tm_hour=  (((time_buf[4]&0x70)>>4)*10)+(time_buf[4]&0x0f);
    03491 9110 04EA LDS	R17,time_buf+4
    03493 7710      ANDI	R17,0x70
    03494 9512      SWAP	R17
    03495 701F      ANDI	R17,0xF
    03496 0301      MULSU	R16,R17
    03497 0110      MOVW	R2,R0
    03498 9180 04EA LDS	R24,time_buf+4
    0349A 2799      CLR	R25
    0349B 708F      ANDI	R24,0xF
    0349C 7090      ANDI	R25,0
    0349D 0E28      ADD	R2,R24
    0349E 1E39      ADC	R3,R25
    0349F 9230 07A5 STS	t+5,R3
    034A1 9220 07A4 STS	t+4,R2
(0492) 	t.tm_mday=	(((time_buf[3]&0x70)>>4)*10)+(time_buf[3]&0x0f);
    034A3 9110 04E9 LDS	R17,time_buf+3
    034A5 7710      ANDI	R17,0x70
    034A6 9512      SWAP	R17
    034A7 701F      ANDI	R17,0xF
    034A8 0301      MULSU	R16,R17
    034A9 0110      MOVW	R2,R0
    034AA 9180 04E9 LDS	R24,time_buf+3
    034AC 2799      CLR	R25
    034AD 708F      ANDI	R24,0xF
    034AE 7090      ANDI	R25,0
    034AF 0E28      ADD	R2,R24
    034B0 1E39      ADC	R3,R25
    034B1 9230 07A7 STS	t+7,R3
    034B3 9220 07A6 STS	t+6,R2
(0493) 	t.tm_mon= (((time_buf[2]&0x70)>>4)*10)+(time_buf[2]&0x0f);
    034B5 9110 04E8 LDS	R17,time_buf+2
    034B7 7710      ANDI	R17,0x70
    034B8 9512      SWAP	R17
    034B9 701F      ANDI	R17,0xF
    034BA 0301      MULSU	R16,R17
    034BB 0110      MOVW	R2,R0
    034BC 9180 04E8 LDS	R24,time_buf+2
    034BE 2799      CLR	R25
    034BF 708F      ANDI	R24,0xF
    034C0 7090      ANDI	R25,0
    034C1 0E28      ADD	R2,R24
    034C2 1E39      ADC	R3,R25
    034C3 9230 07A9 STS	t+9,R3
    034C5 9220 07A8 STS	t+8,R2
(0494) 	t.tm_wday=	(time_buf[7]&0x0f);
    034C7 9180 04ED LDS	R24,time_buf+7
    034C9 2799      CLR	R25
    034CA 708F      ANDI	R24,0xF
    034CB 7090      ANDI	R25,0
    034CC 9390 07AD STS	t+13,R25
    034CE 9380 07AC STS	t+12,R24
(0495)     t.tm_year=	(((time_buf[1]&0x70)>>4)*10)+(time_buf[1]&0x0f);
    034D0 9110 04E7 LDS	R17,time_buf+1
    034D2 7710      ANDI	R17,0x70
    034D3 9512      SWAP	R17
    034D4 701F      ANDI	R17,0xF
    034D5 0301      MULSU	R16,R17
    034D6 0110      MOVW	R2,R0
    034D7 9180 04E7 LDS	R24,time_buf+1
    034D9 2799      CLR	R25
    034DA 708F      ANDI	R24,0xF
    034DB 7090      ANDI	R25,0
    034DC 0E28      ADD	R2,R24
    034DD 1E39      ADC	R3,R25
    034DE 9230 07AB STS	t+11,R3
    034E0 9220 07AA STS	t+10,R2
(0496) 	Result.Date[0]='2';
    034E2 E382      LDI	R24,0x32
    034E3 9380 0558 STS	Result+22,R24
(0497) 	Result.Date[1]='0';
    034E5 E380      LDI	R24,0x30
    034E6 9380 0559 STS	Result+23,R24
(0498) 	Result.Date[2]=t.tm_year/10+'0';
    034E8 E02A      LDI	R18,0xA
    034E9 E030      LDI	R19,0
    034EA 0181      MOVW	R16,R2
    034EB 940E 3E3D CALL	div16s
    034ED 01C8      MOVW	R24,R16
    034EE 96C0      ADIW	R24,0x30
    034EF 9380 055A STS	Result+24,R24
(0499) 	Result.Date[3]=t.tm_year%10+'0';
    034F1 E02A      LDI	R18,0xA
    034F2 E030      LDI	R19,0
    034F3 9100 07AA LDS	R16,t+10
    034F5 9110 07AB LDS	R17,t+11
    034F7 940E 3E39 CALL	mod16s
    034F9 01C8      MOVW	R24,R16
    034FA 96C0      ADIW	R24,0x30
    034FB 9380 055B STS	Result+25,R24
(0500) 	Result.Date[4]=t.tm_mon/10+'0';
    034FD E02A      LDI	R18,0xA
    034FE E030      LDI	R19,0
    034FF 9100 07A8 LDS	R16,t+8
    03501 9110 07A9 LDS	R17,t+9
    03503 940E 3E3D CALL	div16s
    03505 01C8      MOVW	R24,R16
    03506 96C0      ADIW	R24,0x30
    03507 9380 055C STS	Result+26,R24
(0501) 	Result.Date[5]=t.tm_mon%10+'0';
    03509 E02A      LDI	R18,0xA
    0350A E030      LDI	R19,0
    0350B 9100 07A8 LDS	R16,t+8
    0350D 9110 07A9 LDS	R17,t+9
    0350F 940E 3E39 CALL	mod16s
    03511 01C8      MOVW	R24,R16
    03512 96C0      ADIW	R24,0x30
    03513 9380 055D STS	Result+27,R24
(0502) 	Result.Date[6]=t.tm_mday/10+'0';
    03515 E02A      LDI	R18,0xA
    03516 E030      LDI	R19,0
    03517 9100 07A6 LDS	R16,t+6
    03519 9110 07A7 LDS	R17,t+7
    0351B 940E 3E3D CALL	div16s
    0351D 01C8      MOVW	R24,R16
    0351E 96C0      ADIW	R24,0x30
    0351F 9380 055E STS	Result+28,R24
(0503) 	Result.Date[7]=t.tm_mday%10+'0';
    03521 E02A      LDI	R18,0xA
    03522 E030      LDI	R19,0
    03523 9100 07A6 LDS	R16,t+6
    03525 9110 07A7 LDS	R17,t+7
    03527 940E 3E39 CALL	mod16s
    03529 01C8      MOVW	R24,R16
    0352A 96C0      ADIW	R24,0x30
    0352B 9380 055F STS	Result+29,R24
(0504)     Result.Date[8]='\0';
    0352D 2422      CLR	R2
    0352E 9220 0560 STS	Result+30,R2
(0505) 	Result.Time[0]=t.tm_hour/10+'0';
    03530 E02A      LDI	R18,0xA
    03531 E030      LDI	R19,0
    03532 9100 07A4 LDS	R16,t+4
    03534 9110 07A5 LDS	R17,t+5
    03536 940E 3E3D CALL	div16s
    03538 01C8      MOVW	R24,R16
    03539 96C0      ADIW	R24,0x30
    0353A 9380 0561 STS	Result+31,R24
(0506) 	Result.Time[1]=t.tm_hour%10+'0';
    0353C E02A      LDI	R18,0xA
    0353D E030      LDI	R19,0
    0353E 9100 07A4 LDS	R16,t+4
    03540 9110 07A5 LDS	R17,t+5
    03542 940E 3E39 CALL	mod16s
    03544 01C8      MOVW	R24,R16
    03545 96C0      ADIW	R24,0x30
    03546 9380 0562 STS	Result+32,R24
(0507) 	Result.Time[2]=':';
    03548 E38A      LDI	R24,0x3A
    03549 9380 0563 STS	Result+33,R24
(0508) 	Result.Time[3]=' ';
    0354B E280      LDI	R24,0x20
    0354C 9380 0564 STS	Result+34,R24
(0509) 	Result.Time[4]=t.tm_min/10+'0';
    0354E E02A      LDI	R18,0xA
    0354F E030      LDI	R19,0
    03550 9100 07A2 LDS	R16,t+2
    03552 9110 07A3 LDS	R17,t+3
    03554 940E 3E3D CALL	div16s
    03556 01C8      MOVW	R24,R16
    03557 96C0      ADIW	R24,0x30
    03558 9380 0565 STS	Result+35,R24
(0510) 	Result.Time[5]=t.tm_min%10+'0';
    0355A E02A      LDI	R18,0xA
    0355B E030      LDI	R19,0
    0355C 9100 07A2 LDS	R16,t+2
    0355E 9110 07A3 LDS	R17,t+3
    03560 940E 3E39 CALL	mod16s
    03562 01C8      MOVW	R24,R16
    03563 96C0      ADIW	R24,0x30
    03564 9380 0566 STS	Result+36,R24
(0511) 	Result.Time[6]=':';
    03566 E38A      LDI	R24,0x3A
    03567 9380 0567 STS	Result+37,R24
(0512) 	Result.Time[7]=' ';
    03569 E280      LDI	R24,0x20
    0356A 9380 0568 STS	Result+38,R24
(0513) 	Result.Time[8]=t.tm_sec/10+'0';
    0356C E02A      LDI	R18,0xA
    0356D E030      LDI	R19,0
    0356E 9100 07A0 LDS	R16,t
    03570 9110 07A1 LDS	R17,t+1
    03572 940E 3E3D CALL	div16s
    03574 01C8      MOVW	R24,R16
    03575 96C0      ADIW	R24,0x30
    03576 9380 0569 STS	Result+39,R24
(0514) 	Result.Time[9]=t.tm_sec%10+'0';
    03578 E02A      LDI	R18,0xA
    03579 E030      LDI	R19,0
    0357A 9100 07A0 LDS	R16,t
    0357C 9110 07A1 LDS	R17,t+1
    0357E 940E 3E39 CALL	mod16s
    03580 01C8      MOVW	R24,R16
    03581 96C0      ADIW	R24,0x30
    03582 9380 056A STS	Result+40,R24
(0515) 	Result.Time[10]='\0'; 
    03584 2422      CLR	R2
    03585 9220 056B STS	Result+41,R2
(0516) 	//
(0517) 	config.now =t.tm_hour*3600 + t.tm_min*60 + t.tm_sec;
    03587 9120 07A2 LDS	R18,t+2
    03589 9130 07A3 LDS	R19,t+3
    0358B E30C      LDI	R16,0x3C
    0358C E010      LDI	R17,0
    0358D 940E 3F09 CALL	empy16s
    0358F 0118      MOVW	R2,R16
    03590 9120 07A4 LDS	R18,t+4
    03592 9130 07A5 LDS	R19,t+5
    03594 E100      LDI	R16,0x10
    03595 E01E      LDI	R17,0xE
    03596 940E 3F09 CALL	empy16s
    03598 0128      MOVW	R4,R16
    03599 0C42      ADD	R4,R2
    0359A 1C53      ADC	R5,R3
    0359B 9020 07A0 LDS	R2,t
    0359D 9030 07A1 LDS	R3,t+1
    0359F 0C42      ADD	R4,R2
    035A0 1C53      ADC	R5,R3
    035A1 0112      MOVW	R2,R4
    035A2 2444      CLR	R4
    035A3 FC37      SBRC	R3,7
    035A4 9440      COM	R4
    035A5 2455      CLR	R5
    035A6 FC47      SBRC	R4,7
    035A7 9450      COM	R5
    035A8 9230 07BF STS	config+13,R3
    035AA 9220 07BE STS	config+12,R2
    035AC 9250 07C1 STS	config+15,R5
    035AE 9240 07C0 STS	config+14,R4
    035B0 9149      LD	R20,Y+
    035B1 9508      RET
FILE: D:\LQD\software\master\software_src\usart.c
(0001) #include "config.h"
(0002) 
(0003) 
(0004) #define fosc 7372800UL //晶振7.3728MHZ
(0005) #define baud 38400  //波特率
(0006) //串口通信初始化  MEGA128
(0007) //UART1 initialize
(0008) // desired baud rate:38400
(0009) // actual baud rate:38400 (0.0%)
(0010) // char size: 8 bit
(0011) // parity: Disabled
(0012) void uart1_init(void)
(0013) {
(0014)  	 UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    035B2 2422      CLR	R2
    035B3 9220 009A STS	0x9A,R2
(0015)      UCSR1A = 0x00;
    035B5 9220 009B STS	0x9B,R2
(0016)      UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//8bit+1bit stop
    035B7 E086      LDI	R24,6
    035B8 9380 009D STS	0x9D,R24
(0017)      UBRR1L=(fosc/16/(baud+1))%256;
    035BA E08B      LDI	R24,0xB
    035BB 9380 0099 STS	0x99,R24
(0018)      UBRR1H=(fosc/16/(baud+1))/256;
    035BD 9220 0098 STS	0x98,R2
(0019)      UCSR1B =(1<<RXEN1)|(1<<TXEN1);//RXCEN TXCEN
    035BF E188      LDI	R24,0x18
    035C0 9380 009A STS	0x9A,R24
    035C2 9508      RET
_uart1_rx_isr:
  tmp                  --> R16
    035C3 930A      ST	-Y,R16
    035C4 B70F      IN	R16,0x3F
    035C5 930A      ST	-Y,R16
(0020) }
(0021) 
(0022) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0023) void uart1_rx_isr(void){   
(0024) 	 char tmp;
(0025) 	 tmp=UDR1;
    035C6 9100 009C LDS	R16,0x9C
    035C8 9109      LD	R16,Y+
    035C9 BF0F      OUT	0x3F,R16
    035CA 9109      LD	R16,Y+
    035CB 9518      RETI
(0026) }
(0027) 
(0028) void Usart_Transmit(char c)
(0029) {
(0030)  	 while (!(UCSR1A&(1<<UDRE1)));//表明发送器一准备就绪
_Usart_Transmit:
  c                    --> R16
    035CC 9020 009B LDS	R2,0x9B
    035CE FE25      SBRS	R2,5
    035CF CFFC      RJMP	_Usart_Transmit
(0031) 	 UDR1=c;
    035D0 9300 009C STS	0x9C,R16
    035D2 9508      RET
_Puts:
  s                    --> R20
    035D3 934A      ST	-Y,R20
    035D4 935A      ST	-Y,R21
    035D5 01A8      MOVW	R20,R16
(0032) }
(0033) 
(0034) //串口输出字符串
(0035) void Puts( unsigned char *s)
(0036) { 
    035D6 C00B      RJMP	0x35E2
(0037) 	 while (*s) 
(0038)       { 
(0039) 	  //为数据间的隔断创造一个串口能显示的隔断字符 即'/t'  ->  ' '
(0040) 	  if(*s==0x09)  
    035D7 01FA      MOVW	R30,R20
    035D8 8180      LD	R24,Z
    035D9 3089      CPI	R24,0x9
    035DA F411      BNE	0x35DD
(0041) 	  {   Usart_Transmit(' ');    }
    035DB E200      LDI	R16,0x20
    035DC DFEF      RCALL	_Usart_Transmit
(0042) 	 Usart_Transmit(*s);
    035DD 01FA      MOVW	R30,R20
    035DE 8100      LD	R16,Z
    035DF DFEC      RCALL	_Usart_Transmit
(0043) 	 s++;
    035E0 5F4F      SUBI	R20,0xFF
    035E1 4F5F      SBCI	R21,0xFF
    035E2 01FA      MOVW	R30,R20
    035E3 8020      LD	R2,Z
    035E4 2022      TST	R2
    035E5 F789      BNE	0x35D7
    035E6 9159      LD	R21,Y+
    035E7 9149      LD	R20,Y+
    035E8 9508      RET
_Send_nByte:
  i                    --> R20
  len                  --> R10
  p                    --> R12
    035E9 940E 3F9A CALL	push_xgset303C
    035EB 2EA2      MOV	R10,R18
    035EC 0168      MOVW	R12,R16
(0044) 	
(0045) 	
(0046)       }
(0047) }
(0048) 
(0049) 
(0050) 
(0051) void Send_nByte(unsigned char *p, unsigned char len)
(0052) { 
(0053)   int i = 0;
(0054)   for(i=0;i<len;i++)
    035ED 2744      CLR	R20
    035EE 2755      CLR	R21
    035EF C007      RJMP	0x35F7
(0055)   {
(0056)    	Usart_Transmit(*(p+i));
    035F0 01FA      MOVW	R30,R20
    035F1 0DEC      ADD	R30,R12
    035F2 1DFD      ADC	R31,R13
    035F3 8100      LD	R16,Z
    035F4 DFD7      RCALL	_Usart_Transmit
    035F5 5F4F      SUBI	R20,0xFF
    035F6 4F5F      SBCI	R21,0xFF
    035F7 2C2A      MOV	R2,R10
    035F8 2433      CLR	R3
    035F9 1542      CP	R20,R2
    035FA 0553      CPC	R21,R3
    035FB F3A4      BLT	0x35F0
    035FC 940C 3FA1 JMP	pop_xgset303C
_PrintString:
  str                  --> R10
    035FE 92AA      ST	-Y,R10
    035FF 92BA      ST	-Y,R11
    03600 0158      MOVW	R10,R16
(0057)   }
(0058) }
(0059) 
(0060) void  PrintString(const unsigned char *str)
(0061) {    
    03601 C004      RJMP	0x3606
(0062) 	while(*str!=0)	Usart_Transmit(*str++);
    03602 01F5      MOVW	R30,R10
    03603 9101      LD	R16,Z+
    03604 015F      MOVW	R10,R30
    03605 DFC6      RCALL	_Usart_Transmit
    03606 01F5      MOVW	R30,R10
    03607 8020      LD	R2,Z
    03608 2022      TST	R2
    03609 F7C1      BNE	0x3602
    0360A 90B9      LD	R11,Y+
    0360B 90A9      LD	R10,Y+
    0360C 9508      RET
_PrintString_n:
  str                  --> R10
    0360D 92AA      ST	-Y,R10
    0360E 92BA      ST	-Y,R11
    0360F 0158      MOVW	R10,R16
(0063) }
(0064) void  PrintString_n(const unsigned char *str)
(0065) {   
(0066) 	Usart_Transmit('\r');
    03610 E00D      LDI	R16,0xD
    03611 DFBA      RCALL	_Usart_Transmit
(0067) 	Usart_Transmit('\n'); 
    03612 E00A      LDI	R16,0xA
    03613 DFB8      RCALL	_Usart_Transmit
    03614 C004      RJMP	0x3619
(0068) 	while(*str!=0)	Usart_Transmit(*str++);
    03615 01F5      MOVW	R30,R10
    03616 9101      LD	R16,Z+
    03617 015F      MOVW	R10,R30
    03618 DFB3      RCALL	_Usart_Transmit
    03619 01F5      MOVW	R30,R10
    0361A 8020      LD	R2,Z
    0361B 2022      TST	R2
    0361C F7C1      BNE	0x3615
    0361D 90B9      LD	R11,Y+
    0361E 90A9      LD	R10,Y+
    0361F 9508      RET
_PrintLong:
  i                    --> R20
  da                   --> Y,+0
  data                 --> Y,+9
    03620 940E 3E28 CALL	push_arg4
    03622 934A      ST	-Y,R20
    03623 9728      SBIW	R28,0x8
(0069) 
(0070) } 
(0071)  
(0072) void PrintLong(unsigned long data)
(0073) {
(0074)  
(0075) 	unsigned char da[8];
(0076) 	unsigned char i;
(0077) 	for(i=0;i<8;i++)	da[i]=0;
    03624 2744      CLR	R20
    03625 C008      RJMP	0x362E
    03626 01CE      MOVW	R24,R28
    03627 2FE4      MOV	R30,R20
    03628 27FF      CLR	R31
    03629 0FE8      ADD	R30,R24
    0362A 1FF9      ADC	R31,R25
    0362B 2422      CLR	R2
    0362C 8220      ST	Z,R2
    0362D 9543      INC	R20
    0362E 3048      CPI	R20,0x8
    0362F F3B0      BCS	0x3626
    03630 C013      RJMP	0x3644
(0078) 	while(data>=10000000L){ ++da[7];data-=10000000L;}
    03631 818F      LDD	R24,Y+7
    03632 5F8F      SUBI	R24,0xFF
    03633 838F      STD	Y+7,R24
    03634 E880      LDI	R24,0x80
    03635 E996      LDI	R25,0x96
    03636 E9A8      LDI	R26,0x98
    03637 E0B0      LDI	R27,0
    03638 8429      LDD	R2,Y+9
    03639 843A      LDD	R3,Y+10
    0363A 844B      LDD	R4,Y+11
    0363B 845C      LDD	R5,Y+12
    0363C 1A28      SUB	R2,R24
    0363D 0A39      SBC	R3,R25
    0363E 0A4A      SBC	R4,R26
    0363F 0A5B      SBC	R5,R27
    03640 8629      STD	Y+9,R2
    03641 863A      STD	Y+10,R3
    03642 864B      STD	Y+11,R4
    03643 865C      STD	Y+12,R5
    03644 E880      LDI	R24,0x80
    03645 E996      LDI	R25,0x96
    03646 E9A8      LDI	R26,0x98
    03647 E0B0      LDI	R27,0
    03648 8429      LDD	R2,Y+9
    03649 843A      LDD	R3,Y+10
    0364A 844B      LDD	R4,Y+11
    0364B 845C      LDD	R5,Y+12
    0364C 1628      CP	R2,R24
    0364D 0639      CPC	R3,R25
    0364E 064A      CPC	R4,R26
    0364F 065B      CPC	R5,R27
    03650 F700      BCC	0x3631
(0079) 	if(da[7])	i=0;
    03651 802F      LDD	R2,Y+7
    03652 2022      TST	R2
    03653 F009      BEQ	0x3655
    03654 2744      CLR	R20
(0080) 	if(i==0)	Usart_Transmit('0'+da[7]);
    03655 2344      TST	R20
    03656 F4B9      BNE	0x366E
    03657 810F      LDD	R16,Y+7
    03658 5D00      SUBI	R16,0xD0
    03659 DF72      RCALL	_Usart_Transmit
    0365A C013      RJMP	0x366E
(0081) 	while(data>=1000000L) { ++da[6];data-=1000000L;}
    0365B 818E      LDD	R24,Y+6
    0365C 5F8F      SUBI	R24,0xFF
    0365D 838E      STD	Y+6,R24
    0365E E480      LDI	R24,0x40
    0365F E492      LDI	R25,0x42
    03660 E0AF      LDI	R26,0xF
    03661 E0B0      LDI	R27,0
    03662 8429      LDD	R2,Y+9
    03663 843A      LDD	R3,Y+10
    03664 844B      LDD	R4,Y+11
    03665 845C      LDD	R5,Y+12
    03666 1A28      SUB	R2,R24
    03667 0A39      SBC	R3,R25
    03668 0A4A      SBC	R4,R26
    03669 0A5B      SBC	R5,R27
    0366A 8629      STD	Y+9,R2
    0366B 863A      STD	Y+10,R3
    0366C 864B      STD	Y+11,R4
    0366D 865C      STD	Y+12,R5
    0366E E480      LDI	R24,0x40
    0366F E492      LDI	R25,0x42
    03670 E0AF      LDI	R26,0xF
    03671 E0B0      LDI	R27,0
    03672 8429      LDD	R2,Y+9
    03673 843A      LDD	R3,Y+10
    03674 844B      LDD	R4,Y+11
    03675 845C      LDD	R5,Y+12
    03676 1628      CP	R2,R24
    03677 0639      CPC	R3,R25
    03678 064A      CPC	R4,R26
    03679 065B      CPC	R5,R27
    0367A F700      BCC	0x365B
(0082) 	if(da[6])	i=0;
    0367B 802E      LDD	R2,Y+6
    0367C 2022      TST	R2
    0367D F009      BEQ	0x367F
    0367E 2744      CLR	R20
(0083) 	if(i==0)	Usart_Transmit('0'+da[6]);
    0367F 2344      TST	R20
    03680 F4B9      BNE	0x3698
    03681 810E      LDD	R16,Y+6
    03682 5D00      SUBI	R16,0xD0
    03683 DF48      RCALL	_Usart_Transmit
    03684 C013      RJMP	0x3698
(0084) 	while(data>=100000L)  { ++da[5];data-=100000L;}
    03685 818D      LDD	R24,Y+5
    03686 5F8F      SUBI	R24,0xFF
    03687 838D      STD	Y+5,R24
    03688 EA80      LDI	R24,0xA0
    03689 E896      LDI	R25,0x86
    0368A E0A1      LDI	R26,1
    0368B E0B0      LDI	R27,0
    0368C 8429      LDD	R2,Y+9
    0368D 843A      LDD	R3,Y+10
    0368E 844B      LDD	R4,Y+11
    0368F 845C      LDD	R5,Y+12
    03690 1A28      SUB	R2,R24
    03691 0A39      SBC	R3,R25
    03692 0A4A      SBC	R4,R26
    03693 0A5B      SBC	R5,R27
    03694 8629      STD	Y+9,R2
    03695 863A      STD	Y+10,R3
    03696 864B      STD	Y+11,R4
    03697 865C      STD	Y+12,R5
    03698 EA80      LDI	R24,0xA0
    03699 E896      LDI	R25,0x86
    0369A E0A1      LDI	R26,1
    0369B E0B0      LDI	R27,0
    0369C 8429      LDD	R2,Y+9
    0369D 843A      LDD	R3,Y+10
    0369E 844B      LDD	R4,Y+11
    0369F 845C      LDD	R5,Y+12
    036A0 1628      CP	R2,R24
    036A1 0639      CPC	R3,R25
    036A2 064A      CPC	R4,R26
    036A3 065B      CPC	R5,R27
    036A4 F700      BCC	0x3685
(0085) 	if(da[5])	i=0;
    036A5 802D      LDD	R2,Y+5
    036A6 2022      TST	R2
    036A7 F009      BEQ	0x36A9
    036A8 2744      CLR	R20
(0086) 	if(i==0)	Usart_Transmit('0'+da[5]);
    036A9 2344      TST	R20
    036AA F4B9      BNE	0x36C2
    036AB 810D      LDD	R16,Y+5
    036AC 5D00      SUBI	R16,0xD0
    036AD DF1E      RCALL	_Usart_Transmit
    036AE C013      RJMP	0x36C2
(0087) 	while(data>=10000L)   { ++da[4];data-=10000L;}
    036AF 818C      LDD	R24,Y+4
    036B0 5F8F      SUBI	R24,0xFF
    036B1 838C      STD	Y+4,R24
    036B2 E180      LDI	R24,0x10
    036B3 E297      LDI	R25,0x27
    036B4 E0A0      LDI	R26,0
    036B5 E0B0      LDI	R27,0
    036B6 8429      LDD	R2,Y+9
    036B7 843A      LDD	R3,Y+10
    036B8 844B      LDD	R4,Y+11
    036B9 845C      LDD	R5,Y+12
    036BA 1A28      SUB	R2,R24
    036BB 0A39      SBC	R3,R25
    036BC 0A4A      SBC	R4,R26
    036BD 0A5B      SBC	R5,R27
    036BE 8629      STD	Y+9,R2
    036BF 863A      STD	Y+10,R3
    036C0 864B      STD	Y+11,R4
    036C1 865C      STD	Y+12,R5
    036C2 E180      LDI	R24,0x10
    036C3 E297      LDI	R25,0x27
    036C4 E0A0      LDI	R26,0
    036C5 E0B0      LDI	R27,0
    036C6 8429      LDD	R2,Y+9
    036C7 843A      LDD	R3,Y+10
    036C8 844B      LDD	R4,Y+11
    036C9 845C      LDD	R5,Y+12
    036CA 1628      CP	R2,R24
    036CB 0639      CPC	R3,R25
    036CC 064A      CPC	R4,R26
    036CD 065B      CPC	R5,R27
    036CE F700      BCC	0x36AF
(0088) 	if(da[4])	i=0;
    036CF 802C      LDD	R2,Y+4
    036D0 2022      TST	R2
    036D1 F009      BEQ	0x36D3
    036D2 2744      CLR	R20
(0089) 	if(i==0)	Usart_Transmit('0'+da[4]);
    036D3 2344      TST	R20
    036D4 F4B9      BNE	0x36EC
    036D5 810C      LDD	R16,Y+4
    036D6 5D00      SUBI	R16,0xD0
    036D7 DEF4      RCALL	_Usart_Transmit
    036D8 C013      RJMP	0x36EC
(0090) 	while(data>=1000L)    { ++da[3];data-=1000L;}
    036D9 818B      LDD	R24,Y+3
    036DA 5F8F      SUBI	R24,0xFF
    036DB 838B      STD	Y+3,R24
    036DC EE88      LDI	R24,0xE8
    036DD E093      LDI	R25,3
    036DE E0A0      LDI	R26,0
    036DF E0B0      LDI	R27,0
    036E0 8429      LDD	R2,Y+9
    036E1 843A      LDD	R3,Y+10
    036E2 844B      LDD	R4,Y+11
    036E3 845C      LDD	R5,Y+12
    036E4 1A28      SUB	R2,R24
    036E5 0A39      SBC	R3,R25
    036E6 0A4A      SBC	R4,R26
    036E7 0A5B      SBC	R5,R27
    036E8 8629      STD	Y+9,R2
    036E9 863A      STD	Y+10,R3
    036EA 864B      STD	Y+11,R4
    036EB 865C      STD	Y+12,R5
    036EC EE88      LDI	R24,0xE8
    036ED E093      LDI	R25,3
    036EE E0A0      LDI	R26,0
    036EF E0B0      LDI	R27,0
    036F0 8429      LDD	R2,Y+9
    036F1 843A      LDD	R3,Y+10
    036F2 844B      LDD	R4,Y+11
    036F3 845C      LDD	R5,Y+12
    036F4 1628      CP	R2,R24
    036F5 0639      CPC	R3,R25
    036F6 064A      CPC	R4,R26
    036F7 065B      CPC	R5,R27
    036F8 F700      BCC	0x36D9
(0091) 	if(da[3])	i=0;
    036F9 802B      LDD	R2,Y+3
    036FA 2022      TST	R2
    036FB F009      BEQ	0x36FD
    036FC 2744      CLR	R20
(0092) 	if(i==0)	Usart_Transmit('0'+da[3]);
    036FD 2344      TST	R20
    036FE F4B9      BNE	0x3716
    036FF 810B      LDD	R16,Y+3
    03700 5D00      SUBI	R16,0xD0
    03701 DECA      RCALL	_Usart_Transmit
    03702 C013      RJMP	0x3716
(0093) 	while(data>=100L)     { ++da[2];data-=100L;}
    03703 818A      LDD	R24,Y+2
    03704 5F8F      SUBI	R24,0xFF
    03705 838A      STD	Y+2,R24
    03706 E684      LDI	R24,0x64
    03707 E090      LDI	R25,0
    03708 E0A0      LDI	R26,0
    03709 E0B0      LDI	R27,0
    0370A 8429      LDD	R2,Y+9
    0370B 843A      LDD	R3,Y+10
    0370C 844B      LDD	R4,Y+11
    0370D 845C      LDD	R5,Y+12
    0370E 1A28      SUB	R2,R24
    0370F 0A39      SBC	R3,R25
    03710 0A4A      SBC	R4,R26
    03711 0A5B      SBC	R5,R27
    03712 8629      STD	Y+9,R2
    03713 863A      STD	Y+10,R3
    03714 864B      STD	Y+11,R4
    03715 865C      STD	Y+12,R5
    03716 E684      LDI	R24,0x64
    03717 E090      LDI	R25,0
    03718 E0A0      LDI	R26,0
    03719 E0B0      LDI	R27,0
    0371A 8429      LDD	R2,Y+9
    0371B 843A      LDD	R3,Y+10
    0371C 844B      LDD	R4,Y+11
    0371D 845C      LDD	R5,Y+12
    0371E 1628      CP	R2,R24
    0371F 0639      CPC	R3,R25
    03720 064A      CPC	R4,R26
    03721 065B      CPC	R5,R27
    03722 F700      BCC	0x3703
(0094) 	if(da[2])	i=0;
    03723 802A      LDD	R2,Y+2
    03724 2022      TST	R2
    03725 F009      BEQ	0x3727
    03726 2744      CLR	R20
(0095) 	if(i==0)	Usart_Transmit('0'+da[2]);
    03727 2344      TST	R20
    03728 F4B9      BNE	0x3740
    03729 810A      LDD	R16,Y+2
    0372A 5D00      SUBI	R16,0xD0
    0372B DEA0      RCALL	_Usart_Transmit
    0372C C013      RJMP	0x3740
(0096) 	while(data>=10L)      { ++da[1];data-=10L;}
    0372D 8189      LDD	R24,Y+1
    0372E 5F8F      SUBI	R24,0xFF
    0372F 8389      STD	Y+1,R24
    03730 E08A      LDI	R24,0xA
    03731 E090      LDI	R25,0
    03732 E0A0      LDI	R26,0
    03733 E0B0      LDI	R27,0
    03734 8429      LDD	R2,Y+9
    03735 843A      LDD	R3,Y+10
    03736 844B      LDD	R4,Y+11
    03737 845C      LDD	R5,Y+12
    03738 1A28      SUB	R2,R24
    03739 0A39      SBC	R3,R25
    0373A 0A4A      SBC	R4,R26
    0373B 0A5B      SBC	R5,R27
    0373C 8629      STD	Y+9,R2
    0373D 863A      STD	Y+10,R3
    0373E 864B      STD	Y+11,R4
    0373F 865C      STD	Y+12,R5
    03740 E08A      LDI	R24,0xA
    03741 E090      LDI	R25,0
    03742 E0A0      LDI	R26,0
    03743 E0B0      LDI	R27,0
    03744 8429      LDD	R2,Y+9
    03745 843A      LDD	R3,Y+10
    03746 844B      LDD	R4,Y+11
    03747 845C      LDD	R5,Y+12
    03748 1628      CP	R2,R24
    03749 0639      CPC	R3,R25
    0374A 064A      CPC	R4,R26
    0374B 065B      CPC	R5,R27
    0374C F700      BCC	0x372D
(0097) 	if(da[1])	i=0;
    0374D 8029      LDD	R2,Y+1
    0374E 2022      TST	R2
    0374F F009      BEQ	0x3751
    03750 2744      CLR	R20
(0098) 	if(i==0)	Usart_Transmit('0'+da[1]);
    03751 2344      TST	R20
    03752 F419      BNE	0x3756
    03753 8109      LDD	R16,Y+1
    03754 5D00      SUBI	R16,0xD0
    03755 DE76      RCALL	_Usart_Transmit
(0099) 	Usart_Transmit('0'+data);
    03756 E380      LDI	R24,0x30
    03757 E090      LDI	R25,0
    03758 E0A0      LDI	R26,0
    03759 E0B0      LDI	R27,0
    0375A 8429      LDD	R2,Y+9
    0375B 843A      LDD	R3,Y+10
    0375C 844B      LDD	R4,Y+11
    0375D 845C      LDD	R5,Y+12
    0375E 0E28      ADD	R2,R24
    0375F 1E39      ADC	R3,R25
    03760 1E4A      ADC	R4,R26
    03761 1E5B      ADC	R5,R27
    03762 2D02      MOV	R16,R2
    03763 DE68      RCALL	_Usart_Transmit
    03764 9628      ADIW	R28,0x8
    03765 9149      LD	R20,Y+
    03766 9624      ADIW	R28,4
    03767 9508      RET
_PrintChar:
  h                    --> R20
  d                    --> R22
    03768 934A      ST	-Y,R20
    03769 936A      ST	-Y,R22
    0376A 2F60      MOV	R22,R16
(0100)  
(0101) }
(0102)  
(0103) void PrintChar(unsigned char d)
(0104) {
(0105) 	unsigned char h=(d&0xF0)>>4;
    0376B 2F46      MOV	R20,R22
    0376C 7F40      ANDI	R20,0xF0
    0376D 9542      SWAP	R20
    0376E 704F      ANDI	R20,0xF
(0106) 	if(h<10)	Usart_Transmit('0'+h);
    0376F 304A      CPI	R20,0xA
    03770 F420      BCC	0x3775
    03771 2F04      MOV	R16,R20
    03772 5D00      SUBI	R16,0xD0
    03773 DE58      RCALL	_Usart_Transmit
    03774 C003      RJMP	0x3778
(0107) 	else		Usart_Transmit('A'-10+h);
    03775 2F04      MOV	R16,R20
    03776 5C09      SUBI	R16,0xC9
    03777 DE54      RCALL	_Usart_Transmit
(0108) 	h=d&0x0f;
    03778 2F46      MOV	R20,R22
    03779 704F      ANDI	R20,0xF
(0109) 	if(h<10)	Usart_Transmit('0'+h);
    0377A 304A      CPI	R20,0xA
    0377B F420      BCC	0x3780
    0377C 2F04      MOV	R16,R20
    0377D 5D00      SUBI	R16,0xD0
    0377E DE4D      RCALL	_Usart_Transmit
    0377F C003      RJMP	0x3783
(0110) 	else		Usart_Transmit('A'-10+h);
    03780 2F04      MOV	R16,R20
    03781 5C09      SUBI	R16,0xC9
    03782 DE49      RCALL	_Usart_Transmit
(0111) 	Usart_Transmit(' ');
    03783 E200      LDI	R16,0x20
    03784 DE47      RCALL	_Usart_Transmit
    03785 9169      LD	R22,Y+
    03786 9149      LD	R20,Y+
    03787 9508      RET
FILE: D:\LQD\software\master\software_src\SPI.c
(0001) //*****************************************************************************//
(0002) //*								 
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SPI接口控制
(0006) //*****************************************************************************//
(0007) #include "SPI.h"
(0008) 
(0009) /******************************************************************
(0010) SPI接口函数初始化
(0011) ******************************************************************/
(0012) void SPI_IO_Init(void)
(0013) {
(0014) 	SPI_PORT |= (1<<SS);////拉高CS
_SPI_IO_Init:
    03788 9AC0      SBI	0x18,0
(0015) 	SPI_DDR |= (1<<SCLK)|(1<<MOSI)|(1<<SS);////CS,CLK,MOSI设为输出
    03789 B387      IN	R24,0x17
    0378A 6087      ORI	R24,7
    0378B BB87      OUT	0x17,R24
(0016) 	SPI_DDR &=~(1<<MISO);//MISO设为输入
    0378C 98BB      CBI	0x17,3
(0017) 	SPI_PORT |= (1<<SCLK);//拉高CLK
    0378D 9AC1      SBI	0x18,1
(0018) 	SPI_High();//SPI高通
    0378E E580      LDI	R24,0x50
    0378F B98D      OUT	0x0D,R24
    03790 9A70      SBI	0x0E,0
    03791 9508      RET
(0019) }
(0020) /******************************************************************
(0021) SPI写一个字节
(0022) ******************************************************************/
(0023) void SPI_Write(UINT8 data)
(0024) {
(0025) 	SPDR = data;
_SPI_Write:
  data                 --> R16
    03792 B90F      OUT	0x0F,R16
(0026) 	while ((SPSR&(1<<SPIF))==0);
    03793 9B77      SBIS	0x0E,7
    03794 CFFE      RJMP	0x3793
    03795 9508      RET
(0027) 	//loop_until_bit_is_set(SPSR,SPIF);
(0028) }
(0029) /******************************************************************
(0030) SPI读一个字节
(0031) ******************************************************************/
(0032) unsigned char SPI_Read(void)
(0033) {
(0034) 	SPDR = 0xFF;//写0xFF启动SPI
_SPI_Read:
    03796 EF8F      LDI	R24,0xFF
    03797 B98F      OUT	0x0F,R24
(0035) 	while ((SPSR&(1<<SPIF))==0);
    03798 9B77      SBIS	0x0E,7
    03799 CFFE      RJMP	0x3798
(0036) 	//loop_until_bit_is_set(SPSR,SPIF);//等待SPIF为高电平
(0037) 	return  SPDR;//返回读取值
    0379A B10F      IN	R16,0x0F
    0379B 9508      RET
FILE: D:\LQD\software\master\software_src\lcd.c
(0001) #include "config.h"
(0002) 
(0003) //此硬件引脚适合冷强度检测仪第2版电路  mega128
(0004) #define LCD_PIN_CS   4
(0005) #define LCD_PIN_SID  3
(0006) #define LCD_PIN_SCLK 2
(0007) #define LCD_PIN_RST  1
(0008) #define LCD_BACKLIGHT_SW		0
(0009) #define LCD_PORT PORTC
(0010) #define LCD_PIN_DDR DDRC
(0011) #define Set_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT |= (1<<LCD_PIN_CS) 
(0012) #define Set_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT |= (1<<LCD_PIN_SID) 
(0013) #define Set_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT |= (1<<LCD_PIN_SCLK) 
(0014) #define LCD_LIGHT_ON()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT |= (1<<LCD_BACKLIGHT_SW) 
(0015) #define Set_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT |= (1<<LCD_PIN_RST) 
(0016) 
(0017) #define Clr_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT &=~(1<<LCD_PIN_CS) 
(0018) #define Clr_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT &=~(1<<LCD_PIN_SID) 
(0019) #define Clr_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT &=~(1<<LCD_PIN_SCLK) 
(0020) #define LCD_LIGHT_OFF()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT &=~(1<<LCD_BACKLIGHT_SW) 
(0021) #define Clr_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT &=~(1<<LCD_PIN_RST) 
(0022)  
(0023) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data); 
(0024) void Write_8bits(unsigned int W_bits); 
(0025) void LCD_Init(void); 
(0026) unsigned char LCD_INT(void); 
(0027) 
(0028) unsigned char LCD_SW(unsigned char i)
(0029) {
(0030)  if(i==0){
_LCD_SW:
  i                    --> R16
    0379C 2300      TST	R16
    0379D F421      BNE	0x37A2
(0031)  LCD_LIGHT_OFF();
    0379E 9AA0      SBI	0x14,0
    0379F 98A8      CBI	0x15,0
(0032)  return 0;
    037A0 2700      CLR	R16
    037A1 C003      RJMP	0x37A5
(0033)  }
(0034)  else{
(0035)  LCD_LIGHT_ON();
    037A2 9AA0      SBI	0x14,0
    037A3 9AA8      SBI	0x15,0
(0036)  return 1;
    037A4 E001      LDI	R16,1
    037A5 9508      RET
(0037)  }
(0038)  
(0039) }
(0040)  
(0041) unsigned char LCD_INT(void) 
(0042) { 
(0043)   Clr_CS(); 
_LCD_INT:
    037A6 9AA4      SBI	0x14,4
    037A7 98AC      CBI	0x15,4
(0044)   Clr_SID(); 
    037A8 9AA3      SBI	0x14,3
    037A9 98AB      CBI	0x15,3
(0045)   Clr_SCLK(); 
    037AA 9AA2      SBI	0x14,2
    037AB 98AA      CBI	0x15,2
(0046)   LCD_Init(); 
    037AC D097      RCALL	_LCD_Init
(0047)   return (0);
    037AD 2700      CLR	R16
    037AE 9508      RET
_address:
  a                    --> R20
  y                    --> R18
  x                    --> R16
    037AF 940E 3F82 CALL	push_xgsetF000
(0048) } 
(0049)   
(0050) /******************************************************************** 
(0051) 函数 名：address
(0052) 入口参数：地址转换
(0053) 出口参数：无 
(0054) 函数作用： 
(0055) 说        明： 
(0056) ********************************************************************/ 
(0057) unsigned char address(unsigned char x,unsigned char y)
(0058) {  
(0059)  unsigned char a;
(0060) 
(0061) switch(x) 
    037B1 2F60      MOV	R22,R16
    037B2 2777      CLR	R23
    037B3 3061      CPI	R22,1
    037B4 E0E0      LDI	R30,0
    037B5 077E      CPC	R23,R30
    037B6 F069      BEQ	0x37C4
    037B7 3062      CPI	R22,2
    037B8 E0E0      LDI	R30,0
    037B9 077E      CPC	R23,R30
    037BA F059      BEQ	0x37C6
    037BB 3063      CPI	R22,3
    037BC E0E0      LDI	R30,0
    037BD 077E      CPC	R23,R30
    037BE F049      BEQ	0x37C8
    037BF 3064      CPI	R22,4
    037C0 E0E0      LDI	R30,0
    037C1 077E      CPC	R23,R30
    037C2 F039      BEQ	0x37CA
    037C3 C007      RJMP	0x37CB
(0062) { 
(0063) case 1: 
(0064) {a=0x80;break;} 
    037C4 E840      LDI	R20,0x80
    037C5 C005      RJMP	0x37CB
(0065) case 2: 
(0066) {a=0x90;break;} 
    037C6 E940      LDI	R20,0x90
    037C7 C003      RJMP	0x37CB
(0067)   case 3: 
(0068) {a=0x88;break;} 
    037C8 E848      LDI	R20,0x88
    037C9 C001      RJMP	0x37CB
(0069)   case 4: 
(0070) {a=0x98;break;} 
    037CA E948      LDI	R20,0x98
(0071) } 
(0072) a=a+y-1;
    037CB 0F42      ADD	R20,R18
    037CC 5041      SUBI	R20,1
(0073) 
(0074) return a;
    037CD 2F04      MOV	R16,R20
    037CE 940C 3F87 JMP	pop_xgsetF000
_LCD_const_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    037D0 940E 3F6F CALL	push_xgset30FC
    037D2 2EE2      MOV	R14,R18
    037D3 2EC0      MOV	R12,R16
    037D4 9721      SBIW	R28,1
    037D5 84A9      LDD	R10,Y+9
    037D6 84BA      LDD	R11,Y+10
(0075) }
(0076)  
(0077) //////////////////////////////////////////////////////////////
(0078) 
(0079) /******************************************************************** 
(0080) 函数 名：LCD_const_disp
(0081) 入口参数：x y  *single_data
(0082) 出口参数：无 
(0083) 函数作用：负责 显示一串常量
(0084) 说        明： 
(0085) ********************************************************************/ 
(0086) void LCD_const_disp(unsigned char x, unsigned char y, const unsigned char *single_data) 
(0087) { 
(0088) unsigned char  a,i; 
(0089) a=address(x,y);
    037D7 2D2E      MOV	R18,R14
    037D8 2D0C      MOV	R16,R12
    037D9 DFD5      RCALL	_address
    037DA 2EC0      MOV	R12,R16
(0090) W_1byte(0,0,a);     //显示的地址 
    037DB 82C8      ST	Y,R12
    037DC 2722      CLR	R18
    037DD 2700      CLR	R16
    037DE D0B7      RCALL	_W_1byte
(0091)    for(i=0; single_data[i]!='\0';i++) 
    037DF 2744      CLR	R20
    037E0 C00D      RJMP	0x37EE
(0092)    {
(0093)     if(i>=16) break; 
    037E1 3140      CPI	R20,0x10
    037E2 F008      BCS	0x37E4
    037E3 C011      RJMP	0x37F5
(0094)     W_1byte(0,1,single_data[i]); 
    037E4 2FE4      MOV	R30,R20
    037E5 27FF      CLR	R31
    037E6 0DEA      ADD	R30,R10
    037E7 1DFB      ADC	R31,R11
    037E8 8020      LD	R2,Z
    037E9 8228      ST	Y,R2
    037EA E021      LDI	R18,1
    037EB 2700      CLR	R16
    037EC D0A9      RCALL	_W_1byte
    037ED 9543      INC	R20
    037EE 2FE4      MOV	R30,R20
    037EF 27FF      CLR	R31
    037F0 0DEA      ADD	R30,R10
    037F1 1DFB      ADC	R31,R11
    037F2 8020      LD	R2,Z
    037F3 2022      TST	R2
    037F4 F761      BNE	0x37E1
(0095)     
(0096)    } 
(0097)    W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    037F5 EF8F      LDI	R24,0xFF
    037F6 8388      ST	Y,R24
    037F7 2722      CLR	R18
    037F8 2700      CLR	R16
    037F9 D09C      RCALL	_W_1byte
    037FA 9621      ADIW	R28,1
    037FB 940C 3F59 JMP	pop_xgset30FC
_LCD_var_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    037FD 940E 3F6F CALL	push_xgset30FC
    037FF 2EE2      MOV	R14,R18
    03800 2EC0      MOV	R12,R16
    03801 9721      SBIW	R28,1
    03802 84A9      LDD	R10,Y+9
    03803 84BA      LDD	R11,Y+10
(0098)  
(0099) } 
(0100) 
(0101) /******************************************************************** 
(0102) 函数 名：LCD_var_disp
(0103) 入口参数：single_row single_line  *single_data
(0104) 出口参数：无 
(0105) 函数作用：负责 显示一串变量
(0106) 说        明： 
(0107) ********************************************************************/ 
(0108) 
(0109) void LCD_var_disp(unsigned char x, unsigned char y, unsigned char *single_data) 
(0110) { 
(0111) unsigned char  a,i; 
(0112) 
(0113) #if _debug == 1 
(0114) 	PrintString_n(single_data);
(0115) #endif 
(0116) 
(0117) a=address( x,y);
    03804 2D2E      MOV	R18,R14
    03805 2D0C      MOV	R16,R12
    03806 DFA8      RCALL	_address
    03807 2EC0      MOV	R12,R16
(0118) W_1byte(0,0,a);     //显示的地址0x88 
    03808 82C8      ST	Y,R12
    03809 2722      CLR	R18
    0380A 2700      CLR	R16
    0380B D08A      RCALL	_W_1byte
(0119) 
(0120) for(i=0; single_data[i]!='\0';i++) 
    0380C 2744      CLR	R20
    0380D C00D      RJMP	0x381B
(0121)    { 
(0122)     if(i>=16) break;
    0380E 3140      CPI	R20,0x10
    0380F F008      BCS	0x3811
    03810 C011      RJMP	0x3822
(0123)     W_1byte(0,1,single_data[i]); 
    03811 2FE4      MOV	R30,R20
    03812 27FF      CLR	R31
    03813 0DEA      ADD	R30,R10
    03814 1DFB      ADC	R31,R11
    03815 8020      LD	R2,Z
    03816 8228      ST	Y,R2
    03817 E021      LDI	R18,1
    03818 2700      CLR	R16
    03819 D07C      RCALL	_W_1byte
    0381A 9543      INC	R20
    0381B 2FE4      MOV	R30,R20
    0381C 27FF      CLR	R31
    0381D 0DEA      ADD	R30,R10
    0381E 1DFB      ADC	R31,R11
    0381F 8020      LD	R2,Z
    03820 2022      TST	R2
    03821 F761      BNE	0x380E
(0124) 	} 
(0125)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03822 EF8F      LDI	R24,0xFF
    03823 8388      ST	Y,R24
    03824 2722      CLR	R18
    03825 2700      CLR	R16
    03826 D06F      RCALL	_W_1byte
    03827 9621      ADIW	R28,1
    03828 940C 3F59 JMP	pop_xgset30FC
_LCD_char_disp:
  a                    --> R12
  data                 --> R10
  y                    --> R14
  x                    --> R12
    0382A 940E 3F71 CALL	push_xgset00FC
    0382C 2EE2      MOV	R14,R18
    0382D 2EC0      MOV	R12,R16
    0382E 9721      SBIW	R28,1
    0382F 80AF      LDD	R10,Y+7
(0126) } 
(0127) /******************************************************************** 
(0128) 函数 名：LCD_char_disp
(0129) 入口参数：single_row single_line  data
(0130) 出口参数：无 
(0131) 函数作用：负责 显示一个 变量
(0132) 说        明： 
(0133) ********************************************************************/ 
(0134) 
(0135) void LCD_char_disp(unsigned char x, unsigned char y, unsigned char data) 
(0136) { 
(0137) unsigned char a; 
(0138) a=address(x,y);
    03830 2D2E      MOV	R18,R14
    03831 2D0C      MOV	R16,R12
    03832 DF7C      RCALL	_address
    03833 2EC0      MOV	R12,R16
(0139) W_1byte(0,0,a);     //显示的地址 
    03834 82C8      ST	Y,R12
    03835 2722      CLR	R18
    03836 2700      CLR	R16
    03837 D05E      RCALL	_W_1byte
(0140) W_1byte(0,1,data);  //显示内容
    03838 82A8      ST	Y,R10
    03839 E021      LDI	R18,1
    0383A 2700      CLR	R16
    0383B D05A      RCALL	_W_1byte
(0141)  
(0142)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    0383C EF8F      LDI	R24,0xFF
    0383D 8388      ST	Y,R24
    0383E 2722      CLR	R18
    0383F 2700      CLR	R16
    03840 D055      RCALL	_W_1byte
    03841 9621      ADIW	R28,1
    03842 940C 3F52 JMP	pop_xgset00FC
_LCD_Init:
  cmd                  --> R20
    03844 934A      ST	-Y,R20
    03845 9721      SBIW	R28,1
(0143) } 
(0144) 
(0145) /******************************************************************** 
(0146) 函数 名：LCD_Init
(0147) 入口参数：无
(0148) 出口参数：unsigned char  0/1
(0149) 函数作用：负责 清空液晶显示
(0150) 说        明： 
(0151) ********************************************************************/ 
(0152) void LCD_Init(void) 
(0153) { 
(0154)    unsigned char cmd; 
(0155)    cmd=0x30;      //功能设置 8 位数据，基本指令 
    03846 E340      LDI	R20,0x30
(0156)   W_1byte(0,0,cmd); 
    03847 8348      ST	Y,R20
    03848 2722      CLR	R18
    03849 2700      CLR	R16
    0384A D04B      RCALL	_W_1byte
(0157)   delayms(2); 
    0384B E002      LDI	R16,2
    0384C E010      LDI	R17,0
    0384D 940E 23FC CALL	_delayms
(0158)   cmd=0x0C;      //显示状态 ON，游标OFF，反白OFF 
    0384F E04C      LDI	R20,0xC
(0159)   W_1byte(0,0,cmd); //写指令 
    03850 8348      ST	Y,R20
    03851 2722      CLR	R18
    03852 2700      CLR	R16
    03853 D042      RCALL	_W_1byte
(0160)   delayms(2); 
    03854 E002      LDI	R16,2
    03855 E010      LDI	R17,0
    03856 940E 23FC CALL	_delayms
(0161)   cmd=0x01;      //清除显示 
    03858 E041      LDI	R20,1
(0162)   W_1byte(0,0,cmd); //写指令 
    03859 8348      ST	Y,R20
    0385A 2722      CLR	R18
    0385B 2700      CLR	R16
    0385C D039      RCALL	_W_1byte
(0163)   delayms(2); 
    0385D E002      LDI	R16,2
    0385E E010      LDI	R17,0
    0385F 940E 23FC CALL	_delayms
(0164)   cmd=0x02;      //地址归位 
    03861 E042      LDI	R20,2
(0165)   W_1byte(0,0,cmd); //写指令 
    03862 8348      ST	Y,R20
    03863 2722      CLR	R18
    03864 2700      CLR	R16
    03865 D030      RCALL	_W_1byte
(0166)   delayms(2); 
    03866 E002      LDI	R16,2
    03867 E010      LDI	R17,0
    03868 940E 23FC CALL	_delayms
(0167)   cmd=0x80;      //设置DDRAM 地址 
    0386A E840      LDI	R20,0x80
(0168)   W_1byte(0,0,cmd); //写指令 
    0386B 8348      ST	Y,R20
    0386C 2722      CLR	R18
    0386D 2700      CLR	R16
    0386E D027      RCALL	_W_1byte
(0169)   delayms(2);     //延时 
    0386F E002      LDI	R16,2
    03870 E010      LDI	R17,0
    03871 940E 23FC CALL	_delayms
    03873 9621      ADIW	R28,1
    03874 9149      LD	R20,Y+
    03875 9508      RET
_LCD_CLR:
  cmd                  --> R20
    03876 934A      ST	-Y,R20
    03877 9721      SBIW	R28,1
(0170) } 
(0171) 
(0172) void LCD_CLR(void)
(0173) {
(0174) unsigned char cmd;
(0175)   cmd=0x01;      //清除显示 
    03878 E041      LDI	R20,1
(0176)   W_1byte(0,0,cmd); //写指令 
    03879 8348      ST	Y,R20
    0387A 2722      CLR	R18
    0387B 2700      CLR	R16
    0387C D019      RCALL	_W_1byte
(0177)   delayms(1); 
    0387D E001      LDI	R16,1
    0387E E010      LDI	R17,0
    0387F 940E 23FC CALL	_delayms
(0178)   cmd=0x02;      //地址归位 
    03881 E042      LDI	R20,2
(0179)   W_1byte(0,0,cmd); //写指令 
    03882 8348      ST	Y,R20
    03883 2722      CLR	R18
    03884 2700      CLR	R16
    03885 D010      RCALL	_W_1byte
(0180)   delayms(1); 
    03886 E001      LDI	R16,1
    03887 E010      LDI	R17,0
    03888 940E 23FC CALL	_delayms
(0181)   cmd=0x80;      //设置DDRAM 地址 
    0388A E840      LDI	R20,0x80
(0182)   W_1byte(0,0,cmd); //写指令 
    0388B 8348      ST	Y,R20
    0388C 2722      CLR	R18
    0388D 2700      CLR	R16
    0388E D007      RCALL	_W_1byte
(0183)   delayms(1);     //延时
    0388F E001      LDI	R16,1
    03890 E010      LDI	R17,0
    03891 940E 23FC CALL	_delayms
    03893 9621      ADIW	R28,1
    03894 9149      LD	R20,Y+
    03895 9508      RET
_W_1byte:
  H_data               --> R22
  S_ID                 --> R10
  L_data               --> R20
  W_data               --> R12
  RS                   --> R14
  RW                   --> R20
    03896 940E 3F6D CALL	push_xgsetF0FC
    03898 2EE2      MOV	R14,R18
    03899 2F40      MOV	R20,R16
    0389A 84CA      LDD	R12,Y+10
(0184) 
(0185) }
(0186)  
(0187) /*******************************************************************
(0188) 函 数 名：W_1byte
(0189) 入口参数：RW、RS、W_data
(0190) 出口参数：无
(0191) 建立日期：2007年3月3日
(0192) 修改日期：
(0193) 函数作用：写一个字节的数据到12864液晶，包括指令和数据
(0194) 说    明：RW=1，从液晶读数据到MCU；RW=0，写一个数据到液晶；
(0195) 		 （一般RW都设为0，即只向液晶写数据，不读数据）
(0196)           RS=1，写入的是数据；RS=0，写入的是指令；
(0197) 		  一般模式：RW=0，RS=1;写数据
(0198) 		  			RW=0，RS=0;写指令
(0199) ********************************************************************/
(0200) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data)
(0201) {
(0202) 	unsigned int H_data,L_data,S_ID = 0xf8;	 //11111RWRS0
    0389B EF88      LDI	R24,0xF8
    0389C E090      LDI	R25,0
    0389D 015C      MOVW	R10,R24
(0203) 	if(RW == 0)
    0389E 2344      TST	R20
    0389F F419      BNE	0x38A3
(0204) 	{
(0205) 	 	S_ID &=~ 0x04;
    038A0 7F8B      ANDI	R24,0xFB
    038A1 015C      MOVW	R10,R24
(0206) 	}
    038A2 C003      RJMP	0x38A6
(0207) 	else					//if(RW==1)
(0208) 	{
(0209) 	 	S_ID |= 0X04;
    038A3 01C5      MOVW	R24,R10
    038A4 6084      ORI	R24,4
    038A5 015C      MOVW	R10,R24
(0210) 	}
(0211) 	if(RS == 0)
    038A6 20EE      TST	R14
    038A7 F421      BNE	0x38AC
(0212) 	{
(0213) 	 	S_ID &=~ 0x02;
    038A8 01C5      MOVW	R24,R10
    038A9 7F8D      ANDI	R24,0xFD
    038AA 015C      MOVW	R10,R24
(0214) 	}
    038AB C003      RJMP	0x38AF
(0215) 	else					//if(RS==1)
(0216) 	{
(0217) 	 	S_ID |= 0X02;
    038AC 01C5      MOVW	R24,R10
    038AD 6082      ORI	R24,2
    038AE 015C      MOVW	R10,R24
(0218) 	}
(0219) 	H_data = W_data;
    038AF 2D6C      MOV	R22,R12
    038B0 2777      CLR	R23
(0220) 	H_data &= 0xf0;			//屏蔽低4位的数据
    038B1 7F60      ANDI	R22,0xF0
    038B2 7070      ANDI	R23,0
(0221) 	L_data = W_data;	   	//xxxx0000格式
    038B3 2D4C      MOV	R20,R12
    038B4 2755      CLR	R21
(0222) 	L_data &= 0x0f;			//屏蔽高4位的数据
    038B5 704F      ANDI	R20,0xF
    038B6 7050      ANDI	R21,0
(0223) 	L_data <<= 4;			//xxxx0000格式
    038B7 0F44      LSL	R20
    038B8 1F55      ROL	R21
    038B9 0F44      LSL	R20
    038BA 1F55      ROL	R21
    038BB 0F44      LSL	R20
    038BC 1F55      ROL	R21
    038BD 0F44      LSL	R20
    038BE 1F55      ROL	R21
(0224) 	Set_CS();
    038BF 9AA4      SBI	0x14,4
    038C0 9AAC      SBI	0x15,4
(0225) 	Write_8bits(S_ID); 		//发送S_ID
    038C1 0185      MOVW	R16,R10
    038C2 D00C      RCALL	_Write_8bits
(0226) 	Write_8bits(H_data);	//发送H_data
    038C3 018B      MOVW	R16,R22
    038C4 D00A      RCALL	_Write_8bits
(0227) 	Write_8bits(L_data);	//发送L_data
    038C5 018A      MOVW	R16,R20
    038C6 D008      RCALL	_Write_8bits
(0228) 	Clr_CS();	Clr_CS();	Clr_CS();	
    038C7 9AA4      SBI	0x14,4
    038C8 98AC      CBI	0x15,4
    038C9 9AA4      SBI	0x14,4
    038CA 98AC      CBI	0x15,4
    038CB 9AA4      SBI	0x14,4
    038CC 98AC      CBI	0x15,4
    038CD 940C 3F62 JMP	pop_xgsetF0FC
_Write_8bits:
  Temp_data            --> R12
  i                    --> R20
  W_bits               --> R10
    038CF 940E 3F9A CALL	push_xgset303C
    038D1 0158      MOVW	R10,R16
(0229) 	 
(0230) 
(0231) }
(0232) /********************************************************************
(0233) 函 数 名：Write_8bits
(0234) 入口参数：W_bits
(0235) 出口参数：无
(0236) 建立日期：2007年3月3日
(0237) 修改日期：
(0238) 函数作用：负责串行输出8个bit位
(0239) 说    明：
(0240) ********************************************************************/
(0241) void Write_8bits(unsigned int W_bits)
(0242) {
(0243) 	unsigned int i,Temp_data;
(0244) 	for(i=0; i<8; i++)
    038D2 2744      CLR	R20
    038D3 2755      CLR	R21
    038D4 C019      RJMP	0x38EE
(0245) 	{
(0246) 		Temp_data = W_bits;
    038D5 0165      MOVW	R12,R10
(0247) 		Temp_data <<= i;
    038D6 019A      MOVW	R18,R20
    038D7 0186      MOVW	R16,R12
    038D8 940E 3FE8 CALL	lsl16
    038DA 0168      MOVW	R12,R16
(0248) 		if((Temp_data&0x80)==0) 
    038DB FD07      SBRC	R16,7
    038DC C003      RJMP	0x38E0
(0249) 		{
(0250) 		 	Clr_SID();
    038DD 9AA3      SBI	0x14,3
    038DE 98AB      CBI	0x15,3
(0251) 		}
    038DF C002      RJMP	0x38E2
(0252) 		else
(0253) 		{
(0254) 		 	Set_SID();
    038E0 9AA3      SBI	0x14,3
    038E1 9AAB      SBI	0x15,3
(0255) 		} 
(0256) 		NOP();
    038E2 0000      NOP
(0257) 		Set_SCLK();
    038E3 9AA2      SBI	0x14,2
    038E4 9AAA      SBI	0x15,2
(0258) 		NOP();
    038E5 0000      NOP
(0259) 		NOP();
    038E6 0000      NOP
(0260) 		Clr_SCLK();
    038E7 9AA2      SBI	0x14,2
    038E8 98AA      CBI	0x15,2
(0261) 		NOP();
    038E9 0000      NOP
(0262) 		Clr_SID();
    038EA 9AA3      SBI	0x14,3
    038EB 98AB      CBI	0x15,3
    038EC 5F4F      SUBI	R20,0xFF
    038ED 4F5F      SBCI	R21,0xFF
    038EE 3048      CPI	R20,0x8
    038EF E0E0      LDI	R30,0
    038F0 075E      CPC	R21,R30
    038F1 F318      BCS	0x38D5
    038F2 940C 3FA1 JMP	pop_xgset303C
_Set_Draw:
    038F4 9721      SBIW	R28,1
(0263) 	}
(0264) }
(0265)  
(0266) /********************************************************************
(0267) 函 数 名：Set_Draw(
(0268) 入口参数：无
(0269) 出口参数：无
(0270) 函数作用：设置为绘图模式
(0271) 说    明：
(0272) ********************************************************************/
(0273) void Set_Draw(void)
(0274) {  	
(0275) 	//W_1byte(0,0,0x34);			//8BIT控制界面，扩充指令集,，绘图显示OFF
(0276) 	W_1byte(0,0,0x36);
    038F5 E386      LDI	R24,0x36
    038F6 8388      ST	Y,R24
    038F7 2722      CLR	R18
    038F8 2700      CLR	R16
    038F9 DF9C      RCALL	_W_1byte
(0277) 	delayms(1);					//延时
    038FA E001      LDI	R16,1
    038FB E010      LDI	R17,0
    038FC 940E 23FC CALL	_delayms
    038FE 9621      ADIW	R28,1
    038FF 9508      RET
_Set_White:
  clr_y                --> R10
  clr_x                --> R20
  white_y              --> Y,+2
  white_x              --> Y,+1
  i                    --> R22
  white_end_x          --> R12
  j                    --> R14
  clear                --> Y,+15
  end_x                --> R12
  y                    --> R14
  x                    --> R22
    03900 940E 3F6D CALL	push_xgsetF0FC
    03902 2EE2      MOV	R14,R18
    03903 2F60      MOV	R22,R16
    03904 9723      SBIW	R28,3
    03905 84CD      LDD	R12,Y+13
(0278) } 
(0279)  
(0280) 
(0281) /******************************************************************** 
(0282) 函数 名：Set_White 
(0283) 入口参数：  x,   y,  end_x,  clear
(0284) 出口参数：无 
(0285) 函数作用： 设置反显
(0286) 说        明： 
(0287) ********************************************************************/ 
(0288) void Set_White(unsigned char x,unsigned char y,unsigned char end_x,unsigned char clear)
(0289) {
(0290)  
(0291) 	unsigned char i, j, white_x, white_y,white_end_x,clr_x,clr_y ;		//
(0292)   
(0293) 	W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03906 E386      LDI	R24,0x36
    03907 8388      ST	Y,R24
    03908 2722      CLR	R18
    03909 2700      CLR	R16
    0390A DF8B      RCALL	_W_1byte
(0294) 	delayus(20);					//延时
    0390B E104      LDI	R16,0x14
    0390C E010      LDI	R17,0
    0390D 940E 23F4 CALL	_delayus
(0295)  
(0296) 	white_end_x = (end_x-x+1);
    0390F 2D8C      MOV	R24,R12
    03910 1B86      SUB	R24,R22
    03911 5F8F      SUBI	R24,0xFF
    03912 2EC8      MOV	R12,R24
(0297) 	white_end_x <<= 1;
    03913 0CCC      LSL	R12
(0298) 	if(y==1)   //x,1  a=80+x-1                   
    03914 2D8E      MOV	R24,R14
    03915 3081      CPI	R24,1
    03916 F449      BNE	0x3920
(0299) 	{
(0300) 	 	white_x = (0x80+x-1); 
    03917 2F86      MOV	R24,R22
    03918 5880      SUBI	R24,0x80
    03919 5081      SUBI	R24,1
    0391A 8389      STD	Y+1,R24
(0301) 		white_y = 0x80;
    0391B E880      LDI	R24,0x80
    0391C 838A      STD	Y+2,R24
(0302) 		clr_x = 0x80;
    0391D E840      LDI	R20,0x80
(0303) 		clr_y = 0x80;
    0391E 2EA8      MOV	R10,R24
(0304) 	}
    0391F C023      RJMP	0x3943
(0305) 	else if(y==2)
    03920 2D8E      MOV	R24,R14
    03921 3082      CPI	R24,2
    03922 F449      BNE	0x392C
(0306) 	{
(0307) 	 	white_x = (0x80+x-1);
    03923 2F86      MOV	R24,R22
    03924 5880      SUBI	R24,0x80
    03925 5081      SUBI	R24,1
    03926 8389      STD	Y+1,R24
(0308) 		white_y = 0x90;
    03927 E980      LDI	R24,0x90
    03928 838A      STD	Y+2,R24
(0309) 		clr_x = 0x80;
    03929 E840      LDI	R20,0x80
(0310) 		clr_y = 0x90;
    0392A 2EA8      MOV	R10,R24
(0311) 	}
    0392B C017      RJMP	0x3943
(0312) 	else if(y==3)
    0392C 2D8E      MOV	R24,R14
    0392D 3083      CPI	R24,3
    0392E F449      BNE	0x3938
(0313) 	{
(0314) 	 	white_x = (0x88+x-1);
    0392F 2F86      MOV	R24,R22
    03930 5788      SUBI	R24,0x78
    03931 5081      SUBI	R24,1
    03932 8389      STD	Y+1,R24
(0315) 		white_y = 0x80;
    03933 E880      LDI	R24,0x80
    03934 838A      STD	Y+2,R24
(0316) 		clr_x = 0x88;
    03935 E848      LDI	R20,0x88
(0317) 		clr_y = 0x80;
    03936 2EA8      MOV	R10,R24
(0318) 	}
    03937 C00B      RJMP	0x3943
(0319) 	else if(y==4)
    03938 2D8E      MOV	R24,R14
    03939 3084      CPI	R24,4
    0393A F441      BNE	0x3943
(0320) 	{
(0321) 	 	white_x = (0x88+x-1);
    0393B 2F86      MOV	R24,R22
    0393C 5788      SUBI	R24,0x78
    0393D 5081      SUBI	R24,1
    0393E 8389      STD	Y+1,R24
(0322) 		white_y = 0x90;
    0393F E980      LDI	R24,0x90
    03940 838A      STD	Y+2,R24
(0323) 		clr_x = 0x88;
    03941 E848      LDI	R20,0x88
(0324) 		clr_y = 0x90;
    03942 2EA8      MOV	R10,R24
(0325) 	}
(0326)   if(clear==0)//要反白时，先将整行的液晶全部清成不反白（此处行指y）
    03943 840F      LDD	R0,Y+15
    03944 2000      TST	R0
    03945 F4E9      BNE	0x3963
(0327) 	{
(0328) 	 	for(i=0;i<16;i++ )			//16行
    03946 2766      CLR	R22
    03947 C019      RJMP	0x3961
(0329) 		{
(0330) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03948 2C2A      MOV	R2,R10
    03949 2D82      MOV	R24,R2
    0394A 5F8F      SUBI	R24,0xFF
    0394B 2EA8      MOV	R10,R24
    0394C 8228      ST	Y,R2
    0394D 2722      CLR	R18
    0394E 2700      CLR	R16
    0394F DF46      RCALL	_W_1byte
(0331) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03950 8348      ST	Y,R20
    03951 2722      CLR	R18
    03952 2700      CLR	R16
    03953 DF42      RCALL	_W_1byte
(0332) 			for(j=0;j<16;j++)		//
    03954 24EE      CLR	R14
    03955 C007      RJMP	0x395D
(0333) 			{
(0334) 			 	W_1byte(0,1,0x00);	//清成不反白
    03956 2422      CLR	R2
    03957 8228      ST	Y,R2
    03958 E021      LDI	R18,1
    03959 2700      CLR	R16
    0395A DF3B      RCALL	_W_1byte
(0335) 			 	nop();
    0395B 0000      NOP
    0395C 94E3      INC	R14
    0395D 2D8E      MOV	R24,R14
    0395E 3180      CPI	R24,0x10
    0395F F3B0      BCS	0x3956
    03960 9563      INC	R22
    03961 3160      CPI	R22,0x10
    03962 F328      BCS	0x3948
(0336) 			}
(0337) 		}
(0338) 	}
(0339) 	nop();
    03963 0000      NOP
(0340) //	
(0341) 	for(i=0;i<16;i++ )				//16行，因为是16*16汉字
    03964 2766      CLR	R22
    03965 C022      RJMP	0x3988
(0342) 	{
(0343) 		W_1byte(0,0,white_y++);		//设置绘图区的Y地址坐标0
    03966 802A      LDD	R2,Y+2
    03967 2D82      MOV	R24,R2
    03968 5F8F      SUBI	R24,0xFF
    03969 838A      STD	Y+2,R24
    0396A 8228      ST	Y,R2
    0396B 2722      CLR	R18
    0396C 2700      CLR	R16
    0396D DF28      RCALL	_W_1byte
(0344) 		W_1byte(0,0,white_x);		//设置绘图区的X地址坐标0
    0396E 8009      LDD	R0,Y+1
    0396F 8208      ST	Y,R0
    03970 2722      CLR	R18
    03971 2700      CLR	R16
    03972 DF23      RCALL	_W_1byte
(0345) 		for(j=0;j<white_end_x;j++)	//
    03973 24EE      CLR	R14
    03974 C010      RJMP	0x3985
(0346) 		{
(0347) 			 if(clear==1)
    03975 858F      LDD	R24,Y+15
    03976 3081      CPI	R24,1
    03977 F431      BNE	0x397E
(0348) 			 {
(0349) 			  	W_1byte(0,1,0x00); //取消这一行的8个点的反白，液晶地址自动加1
    03978 2422      CLR	R2
    03979 8228      ST	Y,R2
    0397A E021      LDI	R18,1
    0397B 2700      CLR	R16
    0397C DF19      RCALL	_W_1byte
(0350) 								   //（此处行指一个一个液晶点所组成的行）
(0351) 			 }
    0397D C005      RJMP	0x3983
(0352) 			 else
(0353) 			 {
(0354) 				W_1byte(0,1,0xff); //反白这一行的8个点，液晶地址自动加1
    0397E EF8F      LDI	R24,0xFF
    0397F 8388      ST	Y,R24
    03980 E021      LDI	R18,1
    03981 2700      CLR	R16
    03982 DF13      RCALL	_W_1byte
(0355) 								   //（此处行指一个一个液晶点所组成的行）
(0356) 			 }
(0357) 			nop();
    03983 0000      NOP
    03984 94E3      INC	R14
    03985 14EC      CP	R14,R12
    03986 F370      BCS	0x3975
    03987 9563      INC	R22
    03988 3160      CPI	R22,0x10
    03989 F2E0      BCS	0x3966
(0358) 		}
(0359) 	}
(0360) 	W_1byte(0,0,0x30);		//基本指令集,，绘图显示OFF
    0398A E380      LDI	R24,0x30
    0398B 8388      ST	Y,R24
    0398C 2722      CLR	R18
    0398D 2700      CLR	R16
    0398E DF07      RCALL	_W_1byte
    0398F 9623      ADIW	R28,3
    03990 940C 3F62 JMP	pop_xgsetF0FC
_set_white_n:
  tempendx             --> R10
  tempy                --> R22
  tempx                --> R20
  clear                --> R12
  n                    --> R14
    03992 940E 3F6D CALL	push_xgsetF0FC
    03994 2EC2      MOV	R12,R18
    03995 2EE0      MOV	R14,R16
    03996 9723      SBIW	R28,3
(0361)  }
(0362) 
(0363) /******************************************************************** 
(0364) 函数 名：set_white_n
(0365) 入口参数： n ,  clear
(0366) 出口参数：无 
(0367) 函数作用：   将四行分成八个位置。n代表位置1-8。本函数用于反显或取消反显
(0368)           某一位置的文字。
(0369) 说        明： 例如 set_white_n(1,0); 表示反显第一行前四个字
(0370) ********************************************************************/ 
(0371) void set_white_n(unsigned char n,unsigned char clear)
(0372) {
(0373) unsigned char tempx,tempy,tempendx;
(0374) if(n==1) {tempx=1;tempy=1;tempendx=4;}
    03997 2D8E      MOV	R24,R14
    03998 3081      CPI	R24,1
    03999 F429      BNE	0x399F
    0399A E041      LDI	R20,1
    0399B E061      LDI	R22,1
    0399C E084      LDI	R24,4
    0399D 2EA8      MOV	R10,R24
    0399E C037      RJMP	0x39D6
(0375) else if(n==2) {tempx=5;tempy=1;tempendx=8;}
    0399F 2D8E      MOV	R24,R14
    039A0 3082      CPI	R24,2
    039A1 F429      BNE	0x39A7
    039A2 E045      LDI	R20,5
    039A3 E061      LDI	R22,1
    039A4 E088      LDI	R24,0x8
    039A5 2EA8      MOV	R10,R24
    039A6 C02F      RJMP	0x39D6
(0376) else if(n==3) {tempx=1;tempy=2;tempendx=4;}
    039A7 2D8E      MOV	R24,R14
    039A8 3083      CPI	R24,3
    039A9 F429      BNE	0x39AF
    039AA E041      LDI	R20,1
    039AB E062      LDI	R22,2
    039AC E084      LDI	R24,4
    039AD 2EA8      MOV	R10,R24
    039AE C027      RJMP	0x39D6
(0377) else if(n==4) {tempx=5;tempy=2;tempendx=8;}
    039AF 2D8E      MOV	R24,R14
    039B0 3084      CPI	R24,4
    039B1 F429      BNE	0x39B7
    039B2 E045      LDI	R20,5
    039B3 E062      LDI	R22,2
    039B4 E088      LDI	R24,0x8
    039B5 2EA8      MOV	R10,R24
    039B6 C01F      RJMP	0x39D6
(0378) else if(n==5) {tempx=1;tempy=3;tempendx=4;}
    039B7 2D8E      MOV	R24,R14
    039B8 3085      CPI	R24,5
    039B9 F429      BNE	0x39BF
    039BA E041      LDI	R20,1
    039BB E063      LDI	R22,3
    039BC E084      LDI	R24,4
    039BD 2EA8      MOV	R10,R24
    039BE C017      RJMP	0x39D6
(0379) else if(n==6) {tempx=5;tempy=3;tempendx=8;}
    039BF 2D8E      MOV	R24,R14
    039C0 3086      CPI	R24,6
    039C1 F429      BNE	0x39C7
    039C2 E045      LDI	R20,5
    039C3 E063      LDI	R22,3
    039C4 E088      LDI	R24,0x8
    039C5 2EA8      MOV	R10,R24
    039C6 C00F      RJMP	0x39D6
(0380) else if(n==7) {tempx=1;tempy=4;tempendx=4;}
    039C7 2D8E      MOV	R24,R14
    039C8 3087      CPI	R24,7
    039C9 F429      BNE	0x39CF
    039CA E041      LDI	R20,1
    039CB E064      LDI	R22,4
    039CC E084      LDI	R24,4
    039CD 2EA8      MOV	R10,R24
    039CE C007      RJMP	0x39D6
(0381) else if(n==8) {tempx=5;tempy=4;tempendx=8;}
    039CF 2D8E      MOV	R24,R14
    039D0 3088      CPI	R24,0x8
    039D1 F421      BNE	0x39D6
    039D2 E045      LDI	R20,5
    039D3 E064      LDI	R22,4
    039D4 E088      LDI	R24,0x8
    039D5 2EA8      MOV	R10,R24
(0382) Set_White(tempx,tempy,tempendx,clear);
    039D6 82CA      STD	Y+2,R12
    039D7 82A8      ST	Y,R10
    039D8 2F26      MOV	R18,R22
    039D9 2F04      MOV	R16,R20
    039DA DF25      RCALL	_Set_White
    039DB 9623      ADIW	R28,3
    039DC 940C 3F62 JMP	pop_xgsetF0FC
_clr_white:
  clr_x                --> R10
  clr_y                --> R20
  i                    --> R22
  j                    --> R12
    039DE 940E 3F6D CALL	push_xgsetF0FC
    039E0 9721      SBIW	R28,1
(0383) 
(0384) }
(0385)  
(0386) /******************************************************************** 
(0387) 函数 名：clr_white
(0388) 入口参数： 清所有 反白
(0389) 出口参数：无 
(0390) 函数作用： 
(0391) 说        明： 
(0392) ********************************************************************/ 
(0393) void clr_white(void)
(0394) {      unsigned char i,j;
(0395) 
(0396)        unsigned char  clr_y=0x80;
    039E1 E840      LDI	R20,0x80
(0397) 	   unsigned char  clr_x=0x80;
    039E2 E880      LDI	R24,0x80
    039E3 2EA8      MOV	R10,R24
(0398) 	   W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    039E4 E386      LDI	R24,0x36
    039E5 8388      ST	Y,R24
    039E6 2722      CLR	R18
    039E7 2700      CLR	R16
    039E8 DEAD      RCALL	_W_1byte
(0399) 	 	for(i=0;i<16;i++ )			//16行
    039E9 2766      CLR	R22
    039EA C017      RJMP	0x3A02
(0400) 		{
(0401) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    039EB 2E24      MOV	R2,R20
    039EC 5F4F      SUBI	R20,0xFF
    039ED 8228      ST	Y,R2
    039EE 2722      CLR	R18
    039EF 2700      CLR	R16
    039F0 DEA5      RCALL	_W_1byte
(0402) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    039F1 82A8      ST	Y,R10
    039F2 2722      CLR	R18
    039F3 2700      CLR	R16
    039F4 DEA1      RCALL	_W_1byte
(0403) 			for(j=0;j<16;j++)		//
    039F5 24CC      CLR	R12
    039F6 C007      RJMP	0x39FE
(0404) 			{
(0405) 			 	W_1byte(0,1,0x00);	//清成不反白
    039F7 2422      CLR	R2
    039F8 8228      ST	Y,R2
    039F9 E021      LDI	R18,1
    039FA 2700      CLR	R16
    039FB DE9A      RCALL	_W_1byte
(0406) 			 	nop();
    039FC 0000      NOP
    039FD 94C3      INC	R12
    039FE 2D8C      MOV	R24,R12
    039FF 3180      CPI	R24,0x10
    03A00 F3B0      BCS	0x39F7
    03A01 9563      INC	R22
    03A02 3160      CPI	R22,0x10
    03A03 F338      BCS	0x39EB
(0407) 			}
(0408) 		}
(0409) 	
(0410) 	    clr_y=0x80;
    03A04 E840      LDI	R20,0x80
(0411) 	    clr_x=0x90;
    03A05 E980      LDI	R24,0x90
    03A06 2EA8      MOV	R10,R24
(0412) 		 	for(i=0;i<16;i++ )			//16行
    03A07 2766      CLR	R22
    03A08 C017      RJMP	0x3A20
(0413) 		{
(0414) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03A09 2E24      MOV	R2,R20
    03A0A 5F4F      SUBI	R20,0xFF
    03A0B 8228      ST	Y,R2
    03A0C 2722      CLR	R18
    03A0D 2700      CLR	R16
    03A0E DE87      RCALL	_W_1byte
(0415) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03A0F 82A8      ST	Y,R10
    03A10 2722      CLR	R18
    03A11 2700      CLR	R16
    03A12 DE83      RCALL	_W_1byte
(0416) 			for(j=0;j<16;j++)		//
    03A13 24CC      CLR	R12
    03A14 C007      RJMP	0x3A1C
(0417) 			{
(0418) 			 	W_1byte(0,1,0x00);	//清成不反白
    03A15 2422      CLR	R2
    03A16 8228      ST	Y,R2
    03A17 E021      LDI	R18,1
    03A18 2700      CLR	R16
    03A19 DE7C      RCALL	_W_1byte
(0419) 			 	nop();
    03A1A 0000      NOP
    03A1B 94C3      INC	R12
    03A1C 2D8C      MOV	R24,R12
    03A1D 3180      CPI	R24,0x10
    03A1E F3B0      BCS	0x3A15
    03A1F 9563      INC	R22
    03A20 3160      CPI	R22,0x10
    03A21 F338      BCS	0x3A09
(0420) 			}
(0421) 		}   
(0422) 	   
(0423) 	     clr_y=0x88;
    03A22 E848      LDI	R20,0x88
(0424) 	     clr_x=0x80;
    03A23 E880      LDI	R24,0x80
    03A24 2EA8      MOV	R10,R24
(0425) 		 	for(i=0;i<16;i++ )			//16行
    03A25 2766      CLR	R22
    03A26 C017      RJMP	0x3A3E
(0426) 		{
(0427) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03A27 2EE4      MOV	R14,R20
    03A28 5F4F      SUBI	R20,0xFF
    03A29 82E8      ST	Y,R14
    03A2A 2722      CLR	R18
    03A2B 2700      CLR	R16
    03A2C DE69      RCALL	_W_1byte
(0428) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03A2D 82A8      ST	Y,R10
    03A2E 2722      CLR	R18
    03A2F 2700      CLR	R16
    03A30 DE65      RCALL	_W_1byte
(0429) 			for(j=0;j<16;j++)		//
    03A31 24CC      CLR	R12
    03A32 C007      RJMP	0x3A3A
(0430) 			{
(0431) 			 	W_1byte(0,1,0x00);	//清成不反白
    03A33 2422      CLR	R2
    03A34 8228      ST	Y,R2
    03A35 E021      LDI	R18,1
    03A36 2700      CLR	R16
    03A37 DE5E      RCALL	_W_1byte
(0432) 			 	nop();
    03A38 0000      NOP
    03A39 94C3      INC	R12
    03A3A 2D8C      MOV	R24,R12
    03A3B 3180      CPI	R24,0x10
    03A3C F3B0      BCS	0x3A33
    03A3D 9563      INC	R22
    03A3E 3160      CPI	R22,0x10
    03A3F F338      BCS	0x3A27
(0433) 			}
(0434) 		} 
(0435) 	     clr_y=0x88;
    03A40 E848      LDI	R20,0x88
(0436) 	     clr_x=0x90;
    03A41 E980      LDI	R24,0x90
    03A42 2EA8      MOV	R10,R24
(0437) 		 	for(i=0;i<16;i++ )			//16行
    03A43 2766      CLR	R22
    03A44 C017      RJMP	0x3A5C
(0438) 		{
(0439) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03A45 2EE4      MOV	R14,R20
    03A46 5F4F      SUBI	R20,0xFF
    03A47 82E8      ST	Y,R14
    03A48 2722      CLR	R18
    03A49 2700      CLR	R16
    03A4A DE4B      RCALL	_W_1byte
(0440) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03A4B 82A8      ST	Y,R10
    03A4C 2722      CLR	R18
    03A4D 2700      CLR	R16
    03A4E DE47      RCALL	_W_1byte
(0441) 			for(j=0;j<16;j++)		//
    03A4F 24CC      CLR	R12
    03A50 C007      RJMP	0x3A58
(0442) 			{
(0443) 			 	W_1byte(0,1,0x00);	//清成不反白
    03A51 2422      CLR	R2
    03A52 8228      ST	Y,R2
    03A53 E021      LDI	R18,1
    03A54 2700      CLR	R16
    03A55 DE40      RCALL	_W_1byte
(0444) 			 	nop();
    03A56 0000      NOP
    03A57 94C3      INC	R12
    03A58 2D8C      MOV	R24,R12
    03A59 3180      CPI	R24,0x10
    03A5A F3B0      BCS	0x3A51
    03A5B 9563      INC	R22
    03A5C 3160      CPI	R22,0x10
    03A5D F338      BCS	0x3A45
(0445) 			}
(0446) 		} 		
(0447)   W_1byte(0,0,0x30);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03A5E E380      LDI	R24,0x30
    03A5F 8388      ST	Y,R24
    03A60 2722      CLR	R18
    03A61 2700      CLR	R16
    03A62 DE33      RCALL	_W_1byte
    03A63 9621      ADIW	R28,1
    03A64 940C 3F62 JMP	pop_xgsetF0FC
_LCD_print2num:
  a                    --> R12
  tem                  --> R20
  num                  --> R10
  y                    --> R14
  x                    --> R12
    03A66 940E 3F6F CALL	push_xgset30FC
    03A68 2EE2      MOV	R14,R18
    03A69 2EC0      MOV	R12,R16
    03A6A 9721      SBIW	R28,1
    03A6B 84A9      LDD	R10,Y+9
(0448) 	}
(0449) /******************************************************************** 
(0450) 函数 名：LCD_print2num
(0451) 入口参数： 显示2数字
(0452) 出口参数：无 
(0453) 函数作用： 
(0454) 说        明： 
(0455) ********************************************************************/ 
(0456) void LCD_print2num(unsigned char x,unsigned char y,unsigned char num){
(0457) unsigned char tem;
(0458) unsigned char a; 
(0459) 
(0460) a=address(x,y);
    03A6C 2D2E      MOV	R18,R14
    03A6D 2D0C      MOV	R16,R12
    03A6E DD40      RCALL	_address
    03A6F 2EC0      MOV	R12,R16
(0461) W_1byte(0,0,a);     //显示的地址 
    03A70 82C8      ST	Y,R12
    03A71 2722      CLR	R18
    03A72 2700      CLR	R16
    03A73 DE22      RCALL	_W_1byte
(0462) tem=num/10;
    03A74 E01A      LDI	R17,0xA
    03A75 2D0A      MOV	R16,R10
    03A76 940E 3EDF CALL	div8u
    03A78 2F40      MOV	R20,R16
(0463) W_1byte(0,1,tem+0x30);
    03A79 2F84      MOV	R24,R20
    03A7A 5D80      SUBI	R24,0xD0
    03A7B 8388      ST	Y,R24
    03A7C E021      LDI	R18,1
    03A7D 2700      CLR	R16
    03A7E DE17      RCALL	_W_1byte
(0464) tem=num%10;
    03A7F E01A      LDI	R17,0xA
    03A80 2D0A      MOV	R16,R10
    03A81 940E 3EDD CALL	mod8u
    03A83 2F40      MOV	R20,R16
(0465) W_1byte(0,1,tem+0x30); 
    03A84 2F84      MOV	R24,R20
    03A85 5D80      SUBI	R24,0xD0
    03A86 8388      ST	Y,R24
    03A87 E021      LDI	R18,1
    03A88 2700      CLR	R16
    03A89 DE0C      RCALL	_W_1byte
(0466) W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03A8A EF8F      LDI	R24,0xFF
    03A8B 8388      ST	Y,R24
    03A8C 2722      CLR	R18
    03A8D 2700      CLR	R16
    03A8E DE07      RCALL	_W_1byte
    03A8F 9621      ADIW	R28,1
    03A90 940C 3F59 JMP	pop_xgset30FC
_LCD_print4num:
  tem                  --> R12
  num                  --> R14
  y                    --> R20
  x                    --> R10
    03A92 940E 3F6F CALL	push_xgset30FC
    03A94 2F42      MOV	R20,R18
    03A95 2EA0      MOV	R10,R16
    03A96 9721      SBIW	R28,1
    03A97 84E9      LDD	R14,Y+9
    03A98 84FA      LDD	R15,Y+10
(0467) }
(0468)  
(0469) /******************************************************************** 
(0470) 函数 名：LCD_print4num
(0471) 入口参数： 显示4数字
(0472) 出口参数：无 
(0473) 函数作用： 
(0474) 说        明： 
(0475) ********************************************************************/ 
(0476) void LCD_print4num(unsigned char x,unsigned char y,unsigned int num){
(0477) unsigned char tem;
(0478) tem=num/100;
    03A99 E624      LDI	R18,0x64
    03A9A E030      LDI	R19,0
    03A9B 0187      MOVW	R16,R14
    03A9C 940E 3E59 CALL	div16u
    03A9E 2EC0      MOV	R12,R16
(0479) LCD_print2num(x,y,tem);
    03A9F 82C8      ST	Y,R12
    03AA0 2F24      MOV	R18,R20
    03AA1 2D0A      MOV	R16,R10
    03AA2 DFC3      RCALL	_LCD_print2num
(0480) 
(0481) tem=num%100;   
    03AA3 E624      LDI	R18,0x64
    03AA4 E030      LDI	R19,0
    03AA5 0187      MOVW	R16,R14
    03AA6 940E 3E57 CALL	mod16u
    03AA8 2EC0      MOV	R12,R16
(0482) LCD_print2num(x,y+1,tem);
    03AA9 82C8      ST	Y,R12
    03AAA 2F24      MOV	R18,R20
    03AAB 5F2F      SUBI	R18,0xFF
    03AAC 2D0A      MOV	R16,R10
    03AAD DFB8      RCALL	_LCD_print2num
(0483) 
(0484) 
(0485)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03AAE EF8F      LDI	R24,0xFF
    03AAF 8388      ST	Y,R24
    03AB0 2722      CLR	R18
    03AB1 2700      CLR	R16
    03AB2 DDE3      RCALL	_W_1byte
    03AB3 9621      ADIW	R28,1
    03AB4 940C 3F59 JMP	pop_xgset30FC
_LCD_print:
  a                    --> R12
  ch                   --> R10
  y                    --> R14
  x                    --> R12
    03AB6 940E 3F71 CALL	push_xgset00FC
    03AB8 2EE2      MOV	R14,R18
    03AB9 2EC0      MOV	R12,R16
    03ABA 9721      SBIW	R28,1
    03ABB 80AF      LDD	R10,Y+7
(0486) }
(0487)  
(0488) //////////////////////////////////////////////////////////////
(0489) 
(0490) /******************************************************************** 
(0491) 函数 名：LCD_print 
(0492) 入口参数： 显示1 ascii
(0493) 出口参数：无 
(0494) 函数作用： 
(0495) 说        明： 
(0496) ********************************************************************/ 
(0497) void LCD_print(unsigned char x,unsigned char y,unsigned char ch)
(0498) {  
(0499) unsigned char a; 
(0500) a=address(x,y);
    03ABC 2D2E      MOV	R18,R14
    03ABD 2D0C      MOV	R16,R12
    03ABE DCF0      RCALL	_address
    03ABF 2EC0      MOV	R12,R16
(0501) W_1byte(0,0,a);     //显示的地址 
    03AC0 82C8      ST	Y,R12
    03AC1 2722      CLR	R18
    03AC2 2700      CLR	R16
    03AC3 DDD2      RCALL	_W_1byte
(0502) W_1byte(0,1,ch); 
    03AC4 82A8      ST	Y,R10
    03AC5 E021      LDI	R18,1
    03AC6 2700      CLR	R16
    03AC7 DDCE      RCALL	_W_1byte
    03AC8 9621      ADIW	R28,1
    03AC9 940C 3F52 JMP	pop_xgset00FC
_LCD_print1:
  ch                   --> R10
    03ACB 92AA      ST	-Y,R10
    03ACC 2EA0      MOV	R10,R16
    03ACD 9721      SBIW	R28,1
(0503) 
(0504) 
(0505) 
(0506) }
(0507) /******************************************************************** 
(0508) 函数 名：LCD_print1 
(0509) 入口参数： 显示1 ascii
(0510) 出口参数：无 
(0511) 函数作用：接着上文地址显示，不重设地址 
(0512) 说        明： 
(0513) ********************************************************************/ 
(0514) void LCD_print1(char ch)
(0515) {  
(0516) W_1byte(0,1,ch); 
    03ACE 82A8      ST	Y,R10
    03ACF E021      LDI	R18,1
    03AD0 2700      CLR	R16
    03AD1 DDC4      RCALL	_W_1byte
    03AD2 9621      ADIW	R28,1
    03AD3 90A9      LD	R10,Y+
    03AD4 9508      RET
_lp:
  p                    --> R10
    03AD5 92AA      ST	-Y,R10
    03AD6 92BA      ST	-Y,R11
    03AD7 0158      MOVW	R10,R16
    03AD8 9722      SBIW	R28,2
(0517) }
(0518) //////////////////////////////////////////////////////////////
(0519) 
(0520) 
(0521) 
(0522)  void lp(unsigned char *p)
(0523)  {
(0524)  static unsigned char *p1=" ",*p2=" ",*p3=" ",*p4=" ";
(0525)  p4=p3;
    03AD9 9020 04CE LDS	R2,lcd.c:p3
    03ADB 9030 04CF LDS	R3,lcd.c:p3+1
    03ADD 9230 04D1 STS	lcd.c:p4+1,R3
    03ADF 9220 04D0 STS	lcd.c:p4,R2
(0526)  p3=p2;
    03AE1 9020 04CC LDS	R2,lcd.c:p2
    03AE3 9030 04CD LDS	R3,lcd.c:p2+1
    03AE5 9230 04CF STS	lcd.c:p3+1,R3
    03AE7 9220 04CE STS	lcd.c:p3,R2
(0527)  p2=p1;
    03AE9 9020 04CA LDS	R2,lcd.c:p1
    03AEB 9030 04CB LDS	R3,lcd.c:p1+1
    03AED 9230 04CD STS	lcd.c:p2+1,R3
    03AEF 9220 04CC STS	lcd.c:p2,R2
(0528)  p1=p;
    03AF1 92B0 04CB STS	lcd.c:p1+1,R11
    03AF3 92A0 04CA STS	lcd.c:p1,R10
(0529)   LCD_const_disp(1,1,"                ");
    03AF5 ED82      LDI	R24,0xD2
    03AF6 E094      LDI	R25,4
    03AF7 8399      STD	Y+1,R25
    03AF8 8388      ST	Y,R24
    03AF9 E021      LDI	R18,1
    03AFA E001      LDI	R16,1
    03AFB DCD4      RCALL	_LCD_const_disp
(0530)   LCD_const_disp(2,1,"                ");
    03AFC ED82      LDI	R24,0xD2
    03AFD E094      LDI	R25,4
    03AFE 8399      STD	Y+1,R25
    03AFF 8388      ST	Y,R24
    03B00 E021      LDI	R18,1
    03B01 E002      LDI	R16,2
    03B02 DCCD      RCALL	_LCD_const_disp
(0531)   LCD_const_disp(3,1,"                ");
    03B03 ED82      LDI	R24,0xD2
    03B04 E094      LDI	R25,4
    03B05 8399      STD	Y+1,R25
    03B06 8388      ST	Y,R24
    03B07 E021      LDI	R18,1
    03B08 E003      LDI	R16,3
    03B09 DCC6      RCALL	_LCD_const_disp
(0532)   LCD_const_disp(4,1,"                ");
    03B0A ED82      LDI	R24,0xD2
    03B0B E094      LDI	R25,4
    03B0C 8399      STD	Y+1,R25
    03B0D 8388      ST	Y,R24
    03B0E E021      LDI	R18,1
    03B0F E004      LDI	R16,4
    03B10 DCBF      RCALL	_LCD_const_disp
(0533)   LCD_var_disp(1,1,p4);
    03B11 9020 04D0 LDS	R2,lcd.c:p4
    03B13 9030 04D1 LDS	R3,lcd.c:p4+1
    03B15 8239      STD	Y+1,R3
    03B16 8228      ST	Y,R2
    03B17 E021      LDI	R18,1
    03B18 E001      LDI	R16,1
    03B19 DCE3      RCALL	_LCD_var_disp
(0534)   LCD_var_disp(2,1,p3);
    03B1A 9020 04CE LDS	R2,lcd.c:p3
    03B1C 9030 04CF LDS	R3,lcd.c:p3+1
    03B1E 8239      STD	Y+1,R3
    03B1F 8228      ST	Y,R2
    03B20 E021      LDI	R18,1
    03B21 E002      LDI	R16,2
    03B22 DCDA      RCALL	_LCD_var_disp
(0535)   LCD_var_disp(3,1,p2);
    03B23 9020 04CC LDS	R2,lcd.c:p2
    03B25 9030 04CD LDS	R3,lcd.c:p2+1
    03B27 8239      STD	Y+1,R3
    03B28 8228      ST	Y,R2
    03B29 E021      LDI	R18,1
    03B2A E003      LDI	R16,3
    03B2B DCD1      RCALL	_LCD_var_disp
(0536)   LCD_var_disp(4,1,p1);
    03B2C 9020 04CA LDS	R2,lcd.c:p1
    03B2E 9030 04CB LDS	R3,lcd.c:p1+1
    03B30 8239      STD	Y+1,R3
    03B31 8228      ST	Y,R2
    03B32 E021      LDI	R18,1
    03B33 E004      LDI	R16,4
    03B34 DCC8      RCALL	_LCD_var_disp
(0537)   delayms(300);
    03B35 E20C      LDI	R16,0x2C
    03B36 E011      LDI	R17,1
    03B37 940E 23FC CALL	_delayms
    03B39 9622      ADIW	R28,2
    03B3A 90B9      LD	R11,Y+
    03B3B 90A9      LD	R10,Y+
    03B3C 9508      RET
FILE: D:\LQD\software\master\software_src\relay.c
(0001) #include "config.h"
(0002) /*继电器初始化
(0003) *设置端口
(0004) *初始化关闭
(0005) */
(0006) void relay_init(void){
(0007) 	
(0008) 		RELAY_DDR_SET() ;
_relay_init:
    03B3D 9AA5      SBI	0x14,5
(0009) 		RELAY_OFF();
    03B3E 98AD      CBI	0x15,5
    03B3F 9508      RET
(0010) 		//state.Relay = 0;
(0011) 	}	
(0012) 
(0013) /*继电器控制
(0014) *传入 ： 温度
(0015) *传出 ： 当前继电器状态
(0016) *
(0017) */
(0018) unsigned char  relay(int temp)
(0019) {
(0020) 	if(temp<HEAT_THRESHOLD)
_relay:
  temp                 --> R16
    03B40 3005      CPI	R16,5
    03B41 E0E0      LDI	R30,0
    03B42 071E      CPC	R17,R30
    03B43 F41C      BGE	0x3B47
(0021) 	{
(0022) 	 		RELAY_DDR_SET();
    03B44 9AA5      SBI	0x14,5
(0023) 			RELAY_ON();
    03B45 9AAD      SBI	0x15,5
(0024) 			//state.Relay = 1 ;
(0025) 	}
    03B46 C002      RJMP	0x3B49
(0026) 	else
(0027) 	{
(0028) 	 	RELAY_DDR_SET();
    03B47 9AA5      SBI	0x14,5
(0029) 		RELAY_OFF();
    03B48 98AD      CBI	0x15,5
(0030) 		//state.Relay = 0 ;
(0031) 	}		
(0032) 	//return state.Relay;
(0033) 	return 0;
    03B49 2700      CLR	R16
    03B4A 9508      RET
_beep:
  i                    --> R10
  short_beep           --> R12
  long_beep            --> R14
    03B4B 940E 3F71 CALL	push_xgset00FC
    03B4D 2EC2      MOV	R12,R18
    03B4E 2EE0      MOV	R14,R16
FILE: D:\LQD\software\master\software_src\beep.c
(0001) #include "config.h"
(0002) 
(0003) #define BEEP_PORT	PORTC
(0004) #define BEEP_PIN	6
(0005) #define BEEP_OFF() BEEP_PORT|=(1<<BEEP_PIN)
(0006) #define BEEP_ON()  BEEP_PORT&=~(1<<BEEP_PIN)
(0007) //楦ｅ
(0008) void beep(unsigned char long_beep,unsigned char short_beep)
(0009) { 
(0010) unsigned char i;
(0011) DDRB|=(1<<0);
    03B4F 9AB8      SBI	0x17,0
(0012) for(i=0;i<long_beep;i++)
    03B50 24AA      CLR	R10
    03B51 C00B      RJMP	0x3B5D
(0013) {
(0014) BEEP_ON();  delayms(200);
    03B52 98AE      CBI	0x15,6
    03B53 EC08      LDI	R16,0xC8
    03B54 E010      LDI	R17,0
    03B55 940E 23FC CALL	_delayms
(0015) BEEP_OFF(); delayms(50);
    03B57 9AAE      SBI	0x15,6
    03B58 E302      LDI	R16,0x32
    03B59 E010      LDI	R17,0
    03B5A 940E 23FC CALL	_delayms
    03B5C 94A3      INC	R10
    03B5D 14AE      CP	R10,R14
    03B5E F398      BCS	0x3B52
(0016) }
(0017) delayms(100);
    03B5F E604      LDI	R16,0x64
    03B60 E010      LDI	R17,0
    03B61 940E 23FC CALL	_delayms
(0018) for(i=0;i<short_beep;i++)
    03B63 24AA      CLR	R10
    03B64 C00B      RJMP	0x3B70
(0019) {
(0020) BEEP_ON();  delayms(80);
    03B65 98AE      CBI	0x15,6
    03B66 E500      LDI	R16,0x50
    03B67 E010      LDI	R17,0
    03B68 940E 23FC CALL	_delayms
(0021) BEEP_OFF(); delayms(50);
    03B6A 9AAE      SBI	0x15,6
    03B6B E302      LDI	R16,0x32
    03B6C E010      LDI	R17,0
    03B6D 940E 23FC CALL	_delayms
    03B6F 94A3      INC	R10
    03B70 14AC      CP	R10,R12
    03B71 F398      BCS	0x3B65
    03B72 940C 3F52 JMP	pop_xgset00FC
_Delay_nus:
  i                    --> R20
  n                    --> R16
    03B74 934A      ST	-Y,R20
    03B75 935A      ST	-Y,R21
FILE: D:\LQD\software\master\software_src\DS18B20_driver.c
(0001) //------------------------------------------------------------------------------
(0002) // 文件名：DS18B20_driver.c
(0003) // 说明：  DS18B20驱动头文件
(0004) // 功能：  实现1-wire器件的读写
(0005) // 使用方法：   void Delay_nus(unsigned int n);             //延时n微秒函数
(0006) //              unsigned char reset_18B20(void);            //18B20复位
(0007) //              void write_bit_18B20(char bitval);          //写一位到18B20
(0008) //              unsigned char read_bit_18B20(void);         //读一位从18B20
(0009) //              void write_byte_18B20(unsigned char data);  //写一字节到18B20
(0010) //              unsigned char read_18B20(void);             //读一字节到18B20
(0011) //
(0012) // 运行平台：   AVR 8bit (M16已验证)
(0013) // 依存关系：   DS18B20_driver.h    DS18B20基本驱动头文件（函数声明）
(0014) // 移植人：     
(0015) // 最后修改：   
(0016) //------------------------------------------------------------------------------
(0017) 
(0018) #include "config.h"
(0019) #define DS18B20_PORT PORTG
(0020) #define DS18B20_PIN  PING
(0021) #define DS18B20_DDR  DDRG
(0022) #define CL_DQ   DS18B20_PORT&=~(1<<T_NUM)					   
(0023) #define SET_DQ  DS18B20_PORT|=(1<<T_NUM)			   
(0024) #define SET_OUT DS18B20_DDR|=(1<<T_NUM)				   
(0025) #define SET_IN  DS18B20_DDR&=~(1<<T_NUM)			   
(0026) #define IN_DQ   DS18B20_PIN&(1<<T_NUM)				  
(0027) unsigned char T_NUM=0;
(0028) 
(0029) 
(0030) //------------------------------------------------------------------------------
(0031) // 延时N微秒程序 供控制读写DS18B20时序使用
(0032) //------------------------------------------------------------------------------
(0033) void Delay_nus(unsigned int n)   
(0034) {  unsigned int i;
(0035) 	  for (i=0;i<n;i++) 
    03B76 2744      CLR	R20
    03B77 2755      CLR	R21
    03B78 C005      RJMP	0x3B7E
(0036) 	  		{NOP();
    03B79 0000      NOP
(0037) 						NOP();
    03B7A 0000      NOP
(0038) 						NOP();				        //20--300//比较接近
    03B7B 0000      NOP
    03B7C 5F4F      SUBI	R20,0xFF
    03B7D 4F5F      SBCI	R21,0xFF
    03B7E 1740      CP	R20,R16
    03B7F 0751      CPC	R21,R17
    03B80 F3C0      BCS	0x3B79
    03B81 9159      LD	R21,Y+
    03B82 9149      LD	R20,Y+
    03B83 9508      RET
_reset_18B20:
  bus_flag             --> R10
    03B84 92AA      ST	-Y,R10
(0039) 					}
(0040) }
(0041) 
(0042) 
(0043) //------------------------------------------------------------------------------
(0044) // 1-wire总线复位
(0045) //------------------------------------------------------------------------------
(0046) unsigned char reset_18B20(void)
(0047) {
(0048) 	char bus_flag;
(0049) 	CLI();
    03B85 94F8      BCLR	7
(0050) 	SET_DQ;
    03B86 9110 04E5 LDS	R17,T_NUM
    03B88 E001      LDI	R16,1
    03B89 940E 3FFB CALL	lsl8
    03B8B 9020 0065 LDS	R2,0x65
    03B8D 2A20      OR	R2,R16
    03B8E 9220 0065 STS	0x65,R2
(0051) 	SET_OUT;
    03B90 9110 04E5 LDS	R17,T_NUM
    03B92 E001      LDI	R16,1
    03B93 940E 3FFB CALL	lsl8
    03B95 9020 0064 LDS	R2,0x64
    03B97 2A20      OR	R2,R16
    03B98 9220 0064 STS	0x64,R2
(0052)  	
(0053)   	Delay_nus(1);
    03B9A E001      LDI	R16,1
    03B9B E010      LDI	R17,0
    03B9C DFD7      RCALL	_Delay_nus
(0054)   	CL_DQ;
    03B9D 9110 04E5 LDS	R17,T_NUM
    03B9F E001      LDI	R16,1
    03BA0 940E 3FFB CALL	lsl8
    03BA2 2E20      MOV	R2,R16
    03BA3 9420      COM	R2
    03BA4 9030 0065 LDS	R3,0x65
    03BA6 2032      AND	R3,R2
    03BA7 9230 0065 STS	0x65,R3
(0055)   	Delay_nus(550);		//拉低至少480us时间
    03BA9 E206      LDI	R16,0x26
    03BAA E012      LDI	R17,2
    03BAB DFC8      RCALL	_Delay_nus
(0056)   	SET_DQ;				//释放
    03BAC 9110 04E5 LDS	R17,T_NUM
    03BAE E001      LDI	R16,1
    03BAF 940E 3FFB CALL	lsl8
    03BB1 9020 0065 LDS	R2,0x65
    03BB3 2A20      OR	R2,R16
    03BB4 9220 0065 STS	0x65,R2
(0057) 					NOP();
    03BB6 0000      NOP
(0058) 					NOP();
    03BB7 0000      NOP
(0059)   	SET_IN;				//输入
    03BB8 9110 04E5 LDS	R17,T_NUM
    03BBA E001      LDI	R16,1
    03BBB 940E 3FFB CALL	lsl8
    03BBD 2E20      MOV	R2,R16
    03BBE 9420      COM	R2
    03BBF 9030 0064 LDS	R3,0x64
    03BC1 2032      AND	R3,R2
    03BC2 9230 0064 STS	0x64,R3
(0060)   	Delay_nus(60);
    03BC4 E30C      LDI	R16,0x3C
    03BC5 E010      LDI	R17,0
    03BC6 DFAD      RCALL	_Delay_nus
(0061)   	
(0062) 						//等待回复
(0063)   	bus_flag = IN_DQ;
    03BC7 9110 04E5 LDS	R17,T_NUM
    03BC9 E001      LDI	R16,1
    03BCA 940E 3FFB CALL	lsl8
    03BCC 90A0 0063 LDS	R10,0x63
    03BCE 22A0      AND	R10,R16
(0064)   	
(0065)   	Delay_nus(240);		//回复的低电平在60到240US
    03BCF EF00      LDI	R16,0xF0
    03BD0 E010      LDI	R17,0
    03BD1 DFA2      RCALL	_Delay_nus
(0066)   	SET_OUT;
    03BD2 9110 04E5 LDS	R17,T_NUM
    03BD4 E001      LDI	R16,1
    03BD5 940E 3FFB CALL	lsl8
    03BD7 9020 0064 LDS	R2,0x64
    03BD9 2A20      OR	R2,R16
    03BDA 9220 0064 STS	0x64,R2
(0067) 					NOP();
    03BDC 0000      NOP
(0068) 					NOP();
    03BDD 0000      NOP
(0069)   	SET_DQ;				//回到初始DQ=1；
    03BDE 9110 04E5 LDS	R17,T_NUM
    03BE0 E001      LDI	R16,1
    03BE1 940E 3FFB CALL	lsl8
    03BE3 9020 0065 LDS	R2,0x65
    03BE5 2A20      OR	R2,R16
    03BE6 9220 0065 STS	0x65,R2
(0070) 
(0071)   	SEI();
    03BE8 9478      BSET	7
(0072) 	if(bus_flag){
    03BE9 20AA      TST	R10
    03BEA F011      BEQ	0x3BED
(0073) 		return FALSE;
    03BEB 2700      CLR	R16
    03BEC C001      RJMP	0x3BEE
(0074) 	}else{
(0075) 		return TRUE;
    03BED E001      LDI	R16,1
    03BEE 90A9      LD	R10,Y+
    03BEF 9508      RET
_write_bit_18B20:
  bitval               --> R10
    03BF0 92AA      ST	-Y,R10
    03BF1 2EA0      MOV	R10,R16
(0076) 	}
(0077) 
(0078) }
(0079) 
(0080) //------------------------------------------------------------------------------
(0081) // 写一位到总线
(0082) //------------------------------------------------------------------------------
(0083) void write_bit_18B20(char bitval)
(0084) {
(0085)     SET_OUT;
    03BF2 9110 04E5 LDS	R17,T_NUM
    03BF4 E001      LDI	R16,1
    03BF5 940E 3FFB CALL	lsl8
    03BF7 9020 0064 LDS	R2,0x64
    03BF9 2A20      OR	R2,R16
    03BFA 9220 0064 STS	0x64,R2
(0086) 					NOP();
    03BFC 0000      NOP
(0087) 					NOP();
    03BFD 0000      NOP
(0088) 			 CL_DQ;
    03BFE 9110 04E5 LDS	R17,T_NUM
    03C00 E001      LDI	R16,1
    03C01 940E 3FFB CALL	lsl8
    03C03 2E20      MOV	R2,R16
    03C04 9420      COM	R2
    03C05 9030 0065 LDS	R3,0x65
    03C07 2032      AND	R3,R2
    03C08 9230 0065 STS	0x65,R3
(0089) 	   Delay_nus(1);
    03C0A E001      LDI	R16,1
    03C0B E010      LDI	R17,0
    03C0C DF67      RCALL	_Delay_nus
(0090) 	   if(bitval){    //写数据，从低位开始
    03C0D 20AA      TST	R10
    03C0E F059      BEQ	0x3C1A
(0091) 		     SET_DQ;
    03C0F 9110 04E5 LDS	R17,T_NUM
    03C11 E001      LDI	R16,1
    03C12 940E 3FFB CALL	lsl8
    03C14 9020 0065 LDS	R2,0x65
    03C16 2A20      OR	R2,R16
    03C17 9220 0065 STS	0x65,R2
(0092) 	  }else{
    03C19 C00C      RJMP	0x3C26
(0093) 		     CL_DQ;
    03C1A 9110 04E5 LDS	R17,T_NUM
    03C1C E001      LDI	R16,1
    03C1D 940E 3FFB CALL	lsl8
    03C1F 2E20      MOV	R2,R16
    03C20 9420      COM	R2
    03C21 9030 0065 LDS	R3,0x65
    03C23 2032      AND	R3,R2
    03C24 9230 0065 STS	0x65,R3
(0094) 	  }
(0095) 	Delay_nus(40);		//15~60us
    03C26 E208      LDI	R16,0x28
    03C27 E010      LDI	R17,0
    03C28 DF4B      RCALL	_Delay_nus
(0096) 	SET_DQ;
    03C29 9110 04E5 LDS	R17,T_NUM
    03C2B E001      LDI	R16,1
    03C2C 940E 3FFB CALL	lsl8
    03C2E 9020 0065 LDS	R2,0x65
    03C30 2A20      OR	R2,R16
    03C31 9220 0065 STS	0x65,R2
(0097) 	Delay_nus(10);
    03C33 E00A      LDI	R16,0xA
    03C34 E010      LDI	R17,0
    03C35 DF3E      RCALL	_Delay_nus
    03C36 90A9      LD	R10,Y+
    03C37 9508      RET
_read_bit_18B20:
  k                    --> R10
    03C38 92AA      ST	-Y,R10
(0098) }
(0099) 
(0100) //------------------------------------------------------------------------------
(0101) // 读一位从总线
(0102) //------------------------------------------------------------------------------
(0103) unsigned char read_bit_18B20(void)
(0104) {
(0105) 	unsigned char k;
(0106) 	SET_OUT;
    03C39 9110 04E5 LDS	R17,T_NUM
    03C3B E001      LDI	R16,1
    03C3C 940E 3FFB CALL	lsl8
    03C3E 9020 0064 LDS	R2,0x64
    03C40 2A20      OR	R2,R16
    03C41 9220 0064 STS	0x64,R2
(0107) 	CL_DQ;			//读时间片开始，拉低总线至少1us
    03C43 9110 04E5 LDS	R17,T_NUM
    03C45 E001      LDI	R16,1
    03C46 940E 3FFB CALL	lsl8
    03C48 2E20      MOV	R2,R16
    03C49 9420      COM	R2
    03C4A 9030 0065 LDS	R3,0x65
    03C4C 2032      AND	R3,R2
    03C4D 9230 0065 STS	0x65,R3
(0108) 	Delay_nus(1);
    03C4F E001      LDI	R16,1
    03C50 E010      LDI	R17,0
    03C51 DF22      RCALL	_Delay_nus
(0109) 	
(0110) 					//SET_DQ;	
(0111) 	SET_IN;
    03C52 9110 04E5 LDS	R17,T_NUM
    03C54 E001      LDI	R16,1
    03C55 940E 3FFB CALL	lsl8
    03C57 2E20      MOV	R2,R16
    03C58 9420      COM	R2
    03C59 9030 0064 LDS	R3,0x64
    03C5B 2032      AND	R3,R2
    03C5C 9230 0064 STS	0x64,R3
(0112) 	Delay_nus(4);
    03C5E E004      LDI	R16,4
    03C5F E010      LDI	R17,0
    03C60 DF13      RCALL	_Delay_nus
(0113) 	k=IN_DQ;    	//读数据,从低位开始
    03C61 9110 04E5 LDS	R17,T_NUM
    03C63 E001      LDI	R16,1
    03C64 940E 3FFB CALL	lsl8
    03C66 90A0 0063 LDS	R10,0x63
    03C68 22A0      AND	R10,R16
(0114) 	Delay_nus(10);
    03C69 E00A      LDI	R16,0xA
    03C6A E010      LDI	R17,0
    03C6B DF08      RCALL	_Delay_nus
(0115) 	SET_DQ;	
    03C6C 9110 04E5 LDS	R17,T_NUM
    03C6E E001      LDI	R16,1
    03C6F 940E 3FFB CALL	lsl8
    03C71 9020 0065 LDS	R2,0x65
    03C73 2A20      OR	R2,R16
    03C74 9220 0065 STS	0x65,R2
(0116) 				NOP();
    03C76 0000      NOP
(0117) 				NOP();
    03C77 0000      NOP
(0118) 	SET_OUT;
    03C78 9110 04E5 LDS	R17,T_NUM
    03C7A E001      LDI	R16,1
    03C7B 940E 3FFB CALL	lsl8
    03C7D 9020 0064 LDS	R2,0x64
    03C7F 2A20      OR	R2,R16
    03C80 9220 0064 STS	0x64,R2
(0119) 	    NOP();
    03C82 0000      NOP
(0120) 					NOP();
    03C83 0000      NOP
(0121) 	if(k){
    03C84 20AA      TST	R10
    03C85 F011      BEQ	0x3C88
(0122) 	    return 1;
    03C86 E001      LDI	R16,1
    03C87 C001      RJMP	0x3C89
(0123) 	}else{
(0124) 	    return 0;
    03C88 2700      CLR	R16
    03C89 90A9      LD	R10,Y+
    03C8A 9508      RET
_write_byte_18B20:
  i                    --> R20
  data                 --> R10
    03C8B 92AA      ST	-Y,R10
    03C8C 934A      ST	-Y,R20
    03C8D 2EA0      MOV	R10,R16
(0125) 	}
(0126) 	
(0127) }
(0128) 
(0129) //------------------------------------------------------------------------------
(0130) // 写一个字节到总线
(0131) //------------------------------------------------------------------------------
(0132) void write_byte_18B20(unsigned char data)
(0133) {
(0134) 	unsigned char i;
(0135)    CLI();
    03C8E 94F8      BCLR	7
(0136)     for(i=0;i<8;i++)
    03C8F 2744      CLR	R20
    03C90 C009      RJMP	0x3C9A
(0137)     {
(0138)         write_bit_18B20(data&(1<<i));
    03C91 E001      LDI	R16,1
    03C92 2F14      MOV	R17,R20
    03C93 940E 3FFB CALL	lsl8
    03C95 2E20      MOV	R2,R16
    03C96 2D0A      MOV	R16,R10
    03C97 2102      AND	R16,R2
    03C98 DF57      RCALL	_write_bit_18B20
    03C99 9543      INC	R20
    03C9A 3048      CPI	R20,0x8
    03C9B F3A8      BCS	0x3C91
(0139)         
(0140)     }
(0141)     SET_DQ;
    03C9C 9110 04E5 LDS	R17,T_NUM
    03C9E E001      LDI	R16,1
    03C9F 940E 3FFB CALL	lsl8
    03CA1 9020 0065 LDS	R2,0x65
    03CA3 2A20      OR	R2,R16
    03CA4 9220 0065 STS	0x65,R2
(0142) 				  NOP();
    03CA6 0000      NOP
(0143) 					 NOP();
    03CA7 0000      NOP
(0144)     SEI();
    03CA8 9478      BSET	7
    03CA9 9149      LD	R20,Y+
    03CAA 90A9      LD	R10,Y+
    03CAB 9508      RET
_read_byte_18B20:
  temp                 --> R10
  n                    --> R20
    03CAC 92AA      ST	-Y,R10
    03CAD 934A      ST	-Y,R20
(0145)     
(0146)     //return;
(0147) }
(0148) 
(0149) //------------------------------------------------------------------------------
(0150) // 读一个字节
(0151) //------------------------------------------------------------------------------
(0152) unsigned char read_byte_18B20(void)
(0153) {
(0154) 	unsigned char temp,n;
(0155)     CLI();
    03CAE 94F8      BCLR	7
(0156)   	temp=0;
    03CAF 24AA      CLR	R10
(0157)     for(n=0;n<8;n++)
    03CB0 2744      CLR	R20
    03CB1 C014      RJMP	0x3CC6
(0158)     {
(0159)       	if(read_bit_18B20()){
    03CB2 DF85      RCALL	_read_bit_18B20
    03CB3 2300      TST	R16
    03CB4 F031      BEQ	0x3CBB
(0160)       		temp|=(1<<n);
    03CB5 E001      LDI	R16,1
    03CB6 2F14      MOV	R17,R20
    03CB7 940E 3FFB CALL	lsl8
    03CB9 2AA0      OR	R10,R16
(0161)       	}else{
    03CBA C007      RJMP	0x3CC2
(0162)       		temp&=~(1<<n);
    03CBB E001      LDI	R16,1
    03CBC 2F14      MOV	R17,R20
    03CBD 940E 3FFB CALL	lsl8
    03CBF 2E20      MOV	R2,R16
    03CC0 9420      COM	R2
    03CC1 20A2      AND	R10,R2
(0163)       	}
(0164)       	Delay_nus(70); //60~120us
    03CC2 E406      LDI	R16,0x46
    03CC3 E010      LDI	R17,0
    03CC4 DEAF      RCALL	_Delay_nus
    03CC5 9543      INC	R20
    03CC6 3048      CPI	R20,0x8
    03CC7 F350      BCS	0x3CB2
(0165)       	
(0166)    }
(0167)    SEI();
    03CC8 9478      BSET	7
(0168) 
(0169)    return temp;
    03CC9 2D0A      MOV	R16,R10
    03CCA 9149      LD	R20,Y+
    03CCB 90A9      LD	R10,Y+
    03CCC 9508      RET
(0170) }
(0171) 
(0172) 
(0173) 
(0174) //------------------------------------------------------------------------------
(0175) // 应用函数部分！ 供外部调用
(0176) //------------------------------------------------------------------------------
(0177) //------------------------------------------------------------------------------
(0178) // 单器件/多器件：开始转换
(0179) //------------------------------------------------------------------------------
(0180) void convert_T(void)
(0181) {
(0182) 					if(reset_18B20()){
_convert_T:
    03CCD DEB6      RCALL	_reset_18B20
    03CCE 2300      TST	R16
    03CCF F021      BEQ	0x3CD4
(0183) 					write_byte_18B20(0xcc);
    03CD0 EC0C      LDI	R16,0xCC
    03CD1 DFB9      RCALL	_write_byte_18B20
(0184) 					write_byte_18B20(0x44);
    03CD2 E404      LDI	R16,0x44
    03CD3 DFB7      RCALL	_write_byte_18B20
(0185) 					}
    03CD4 9508      RET
_read_T:
  sign                 --> Y,+1
  tmp                  --> Y,+0
  value                --> R10
    03CD5 940E 3F73 CALL	push_xgset003C
    03CD7 9724      SBIW	R28,4
(0186) }
(0187) 
(0188) //------------------------------------------------------------------------------
(0189) // 单器件：读温度，返回INIT8U型温度数据（原始数据）
(0190) //------------------------------------------------------------------------------
(0191) float read_T(void)
(0192) {
(0193)     unsigned int value=0;
    03CD8 24AA      CLR	R10
    03CD9 24BB      CLR	R11
(0194) 	unsigned char sign;
(0195) 	
(0196) 	float tmp;
(0197)     
(0198)     if(reset_18B20()){
    03CDA DEA9      RCALL	_reset_18B20
    03CDB 2300      TST	R16
    03CDC F021      BEQ	0x3CE1
(0199)     	write_byte_18B20(0xcc);
    03CDD EC0C      LDI	R16,0xCC
    03CDE DFAC      RCALL	_write_byte_18B20
(0200)     	write_byte_18B20(0xbe);
    03CDF EB0E      LDI	R16,0xBE
    03CE0 DFAA      RCALL	_write_byte_18B20
(0201)     }
(0202)     
(0203)     value = (unsigned int)read_byte_18B20();
    03CE1 DFCA      RCALL	_read_byte_18B20
    03CE2 2EA0      MOV	R10,R16
    03CE3 24BB      CLR	R11
(0204)     value += ((unsigned int)(read_byte_18B20()))<<8;
    03CE4 DFC7      RCALL	_read_byte_18B20
    03CE5 2EC0      MOV	R12,R16
    03CE6 2C2C      MOV	R2,R12
    03CE7 2433      CLR	R3
    03CE8 2C32      MOV	R3,R2
    03CE9 2422      CLR	R2
    03CEA 0CA2      ADD	R10,R2
    03CEB 1CB3      ADC	R11,R3
(0205) 	/*   if((value&0x8000)==0x8000) //负温度
(0206) 					{
(0207) 					 sign=0;
(0208) 					 data=(~data)+1;       //补码形式，取反加一
(0209) 					}
(0210) 		elae 
(0211) 					{
(0212) 					 sign=1;
(0213) 					}
(0214) 		 xiaoshu1=(unsigned char) ((data&0x000f)*10/16);
(0215) 		 zhengshu=(unsigned char) (data>>4); 
(0216) 		*/
(0217) 	tmp= ((float)value)*0.0625;
    03CEC EC08      LDI	R16,0xC8
    03CED E010      LDI	R17,0
    03CEE 940E 3EF5 CALL	elpm32
    03CF0 0118      MOVW	R2,R16
    03CF1 0129      MOVW	R4,R18
    03CF2 0185      MOVW	R16,R10
    03CF3 940E 40C7 CALL	uint2fp
    03CF5 933A      ST	-Y,R19
    03CF6 932A      ST	-Y,R18
    03CF7 931A      ST	-Y,R17
    03CF8 930A      ST	-Y,R16
    03CF9 0181      MOVW	R16,R2
    03CFA 0192      MOVW	R18,R4
    03CFB 940E 426E CALL	fpmule2
    03CFD 8308      ST	Y,R16
    03CFE 8319      STD	Y+1,R17
    03CFF 832A      STD	Y+2,R18
    03D00 833B      STD	Y+3,R19
(0218) 	
(0219)     return( tmp);
    03D01 8108      LD	R16,Y
    03D02 8119      LDD	R17,Y+1
    03D03 812A      LDD	R18,Y+2
    03D04 813B      LDD	R19,Y+3
    03D05 9624      ADIW	R28,4
    03D06 940C 3F4D JMP	pop_xgset003C
_read_T_NUM:
  ttemp                --> Y,+0
  NUM                  --> R10
    03D08 92AA      ST	-Y,R10
    03D09 2EA0      MOV	R10,R16
    03D0A 9724      SBIW	R28,4
(0220) }
(0221) 
(0222) float read_T_NUM(unsigned char NUM){
(0223) float ttemp;
(0224) if ( NUM >1) return 123.45;
    03D0B E081      LDI	R24,1
    03D0C 158A      CP	R24,R10
    03D0D F428      BCC	0x3D13
    03D0E EC04      LDI	R16,0xC4
    03D0F E010      LDI	R17,0
    03D10 940E 3EF5 CALL	elpm32
    03D12 C010      RJMP	0x3D23
(0225) T_NUM=NUM;//设置访问器件
    03D13 92A0 04E5 STS	T_NUM,R10
(0226) convert_T();//温度转换
    03D15 DFB7      RCALL	_convert_T
(0227) delayms(800);
    03D16 E200      LDI	R16,0x20
    03D17 E013      LDI	R17,3
    03D18 940E 23FC CALL	_delayms
(0228) ttemp=read_T();
    03D1A DFBA      RCALL	_read_T
    03D1B 8308      ST	Y,R16
    03D1C 8319      STD	Y+1,R17
    03D1D 832A      STD	Y+2,R18
    03D1E 833B      STD	Y+3,R19
(0229) return ttemp;
    03D1F 8108      LD	R16,Y
    03D20 8119      LDD	R17,Y+1
    03D21 812A      LDD	R18,Y+2
    03D22 813B      LDD	R19,Y+3
    03D23 9624      ADIW	R28,4
    03D24 90A9      LD	R10,Y+
    03D25 9508      RET
FILE: D:\LQD\software\master\software_src\ds1302.c
(0001) #include "config.h"
(0002) 
(0003) #define TPORT PORTB
(0004) #define TDDR DDRB
(0005) #define TPIN PINB
(0006) #define PIN_RST	 4
(0007) #define PIN_IO	 5
(0008) #define PIN_SCK	 6
(0009) /******************复位脚*********************/
(0010) #define RST_CLR	TPORT &= ~(1 << PIN_RST)   /*电平置低*/
(0011) #define RST_SET	TPORT |= (1 << PIN_RST)    /*电平置高*/
(0012) #define RST_IN	TDDR &= ~(1 << PIN_RST)    /*方向输入*/
(0013) #define RST_OUT	TDDR |= (1 << PIN_RST)     /*方向输出*/
(0014) 
(0015) /*****************双向数据********************/
(0016) #define IO_CLR	TPORT &= ~(1 << PIN_IO)  /*电平置低*/
(0017) #define IO_SET	TPORT |= (1 << PIN_IO)   /*电平置高*/
(0018) #define IO_R	TPIN & (1 << PIN_IO)     /*电平读取*/
(0019) #define IO_IN	TDDR &= ~(1 << PIN_IO)   /*方向输入*/
(0020) #define IO_OUT	TDDR |= (1 << PIN_IO)    /*方向输出*/
(0021) 
(0022) /*****************时钟信号*******************/
(0023) #define SCK_CLR	TPORT &= ~(1 << PIN_SCK)  /*时钟信号*/
(0024) #define SCK_SET	TPORT |= (1 << PIN_SCK)   /*电平置高*/
(0025) #define SCK_IN	TDDR &= ~(1 << PIN_SCK)   /*方向输入*/
(0026) #define SCK_OUT	TDDR |= (1 << PIN_SCK)    /*方向输出*/
(0027) 
(0028) #define ds1302_sec_add			0x80		//秒数据地址
(0029) #define ds1302_min_add			0x82		//分数据地址
(0030) #define ds1302_hr_add			0x84		//时数据地址
(0031) #define ds1302_date_add			0x86		//日数据地址
(0032) #define ds1302_month_add		0x88		//月数据地址
(0033) #define ds1302_day_add			0x8a		//星期数据地址
(0034) #define ds1302_year_add			0x8c		//年数据地址
(0035) #define ds1302_control_add		0x8e		//控制数据地址
(0036) #define ds1302_charger_add		0x90 					 
(0037) #define ds1302_clkburst_add		0xbe
(0038) 
(0039) unsigned char time_buf[8] = {0x20,0x0c,0x0A,0x1c,0x22,0x46,0x00,0x06};
(0040) /*
(0041)  struct tm {
(0042)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0043)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0044) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0045) 	int tm_mday;  // 日 day of the month, 1 to 31
(0046) 	int tm_mon;   // 月 months since January, 0 to 11
(0047) 	int tm_year;  // 年 years since 1900
(0048) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0049) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0050)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0051)  	};	
(0052) 	*/
(0053) 
(0054) //DS1302初始化函数
(0055) void ds1302_init(void) 
(0056) {
(0057) 	RST_CLR;			/*RST脚置低*/
_ds1302_init:
    03D26 98C4      CBI	0x18,4
(0058) 	SCK_CLR;			/*SCK脚置低*/
    03D27 98C6      CBI	0x18,6
(0059) 	RST_OUT;			/*RST脚设置为输出*/
    03D28 9ABC      SBI	0x17,4
(0060) 	SCK_OUT;			/*SCK脚设置为输出*/
    03D29 9ABE      SBI	0x17,6
    03D2A 9508      RET
_ds1302_write_byte:
  i                    --> R20
  d                    --> R18
  addr                 --> R16
    03D2B 934A      ST	-Y,R20
(0061) }
(0062) 
(0063) //向DS1302写入一字节数据
(0064) void ds1302_write_byte(unsigned char addr, unsigned char d) {
(0065) 
(0066) 	unsigned char i;
(0067) 	RST_SET;					/*启动DS1302总线*/
    03D2C 9AC4      SBI	0x18,4
(0068) 	
(0069) 	/*写入目标地址：addr*/
(0070) 	IO_OUT;
    03D2D 9ABD      SBI	0x17,5
(0071) 	addr = addr & 0xFE;   //最低位置零，寄存器0位为0时写，为1时读
    03D2E 7F0E      ANDI	R16,0xFE
(0072) 	for (i = 0; i < 8; i ++) {
    03D2F 2744      CLR	R20
    03D30 C009      RJMP	0x3D3A
(0073) 		if (addr & 0x01) {
    03D31 FF00      SBRS	R16,0
    03D32 C002      RJMP	0x3D35
(0074) 			IO_SET;
    03D33 9AC5      SBI	0x18,5
(0075) 			}
    03D34 C001      RJMP	0x3D36
(0076) 		else {
(0077) 			IO_CLR;
    03D35 98C5      CBI	0x18,5
(0078) 			}
(0079) 		SCK_SET;      //产生时钟
    03D36 9AC6      SBI	0x18,6
(0080) 		SCK_CLR;
    03D37 98C6      CBI	0x18,6
(0081) 		addr = addr >> 1;
    03D38 9506      LSR	R16
    03D39 9543      INC	R20
    03D3A 3048      CPI	R20,0x8
    03D3B F3A8      BCS	0x3D31
(0082) 		}
(0083) 	
(0084) 	/*写入数据：d*/
(0085) 	IO_OUT;
    03D3C 9ABD      SBI	0x17,5
(0086) 	for (i = 0; i < 8; i ++) {
    03D3D 2744      CLR	R20
    03D3E C009      RJMP	0x3D48
(0087) 		if (d & 0x01) {
    03D3F FF20      SBRS	R18,0
    03D40 C002      RJMP	0x3D43
(0088) 			IO_SET;
    03D41 9AC5      SBI	0x18,5
(0089) 			}
    03D42 C001      RJMP	0x3D44
(0090) 		else {
(0091) 			IO_CLR;
    03D43 98C5      CBI	0x18,5
(0092) 			}
(0093) 		SCK_SET;    //产生时钟
    03D44 9AC6      SBI	0x18,6
(0094) 		SCK_CLR;
    03D45 98C6      CBI	0x18,6
(0095) 		d = d >> 1;
    03D46 9526      LSR	R18
    03D47 9543      INC	R20
    03D48 3048      CPI	R20,0x8
    03D49 F3A8      BCS	0x3D3F
(0096) 		}
(0097) 	RST_CLR;		//停止DS1302总线
    03D4A 98C4      CBI	0x18,4
    03D4B 9149      LD	R20,Y+
    03D4C 9508      RET
_ds1302_read_byte:
  temp                 --> R20
  i                    --> R22
  addr                 --> R16
    03D4D 934A      ST	-Y,R20
    03D4E 936A      ST	-Y,R22
(0098) 	
(0099) }
(0100) 
(0101) //从DS1302读出一字节数据
(0102) unsigned char ds1302_read_byte(unsigned char addr) {
(0103) 
(0104) 	unsigned char i;
(0105) 	unsigned char temp;
(0106) 	RST_SET;					/*启动DS1302总线*/
    03D4F 9AC4      SBI	0x18,4
(0107) 
(0108) 	/*写入目标地址：addr*/
(0109) 	IO_OUT;
    03D50 9ABD      SBI	0x17,5
(0110) 	addr = addr | 0x01;    //最低位置高，寄存器0位为0时写，为1时读
    03D51 6001      ORI	R16,1
(0111) 	for (i = 0; i < 8; i ++) {
    03D52 2766      CLR	R22
    03D53 C009      RJMP	0x3D5D
(0112) 		if (addr & 0x01) {
    03D54 FF00      SBRS	R16,0
    03D55 C002      RJMP	0x3D58
(0113) 			IO_SET;
    03D56 9AC5      SBI	0x18,5
(0114) 			}
    03D57 C001      RJMP	0x3D59
(0115) 		else {
(0116) 			IO_CLR;
    03D58 98C5      CBI	0x18,5
(0117) 			}
(0118) 		SCK_SET;
    03D59 9AC6      SBI	0x18,6
(0119) 		SCK_CLR;
    03D5A 98C6      CBI	0x18,6
(0120) 		addr = addr >> 1;
    03D5B 9506      LSR	R16
    03D5C 9563      INC	R22
    03D5D 3068      CPI	R22,0x8
    03D5E F3A8      BCS	0x3D54
(0121) 		}
(0122) 	
(0123) 	/*输出数据：temp*/
(0124) 	IO_IN;
    03D5F 98BD      CBI	0x17,5
(0125) 	for (i = 0; i < 8; i ++) {
    03D60 2766      CLR	R22
    03D61 C009      RJMP	0x3D6B
(0126) 		temp = temp >> 1;
    03D62 9546      LSR	R20
(0127) 		if (IO_R) {
    03D63 9BB5      SBIS	0x16,5
    03D64 C002      RJMP	0x3D67
(0128) 			temp |= 0x80;
    03D65 6840      ORI	R20,0x80
(0129) 			}
    03D66 C001      RJMP	0x3D68
(0130) 		else {
(0131) 			temp &= 0x7F;
    03D67 774F      ANDI	R20,0x7F
(0132) 			}
(0133) 		SCK_SET;
    03D68 9AC6      SBI	0x18,6
(0134) 		SCK_CLR;
    03D69 98C6      CBI	0x18,6
    03D6A 9563      INC	R22
    03D6B 3068      CPI	R22,0x8
    03D6C F3A8      BCS	0x3D62
(0135) 		}
(0136) 	
(0137) 	RST_CLR;					/*停止DS1302总线*/
    03D6D 98C4      CBI	0x18,4
(0138) 	return temp;
    03D6E 2F04      MOV	R16,R20
    03D6F 9169      LD	R22,Y+
    03D70 9149      LD	R20,Y+
    03D71 9508      RET
(0139) }
(0140) 
(0141) //向DS302写入时钟数据
(0142) void ds1302_write_time(void) {
(0143) 
(0144) 	ds1302_write_byte(ds1302_control_add,0x00);			//关闭写保护 
_ds1302_write_time:
    03D72 2722      CLR	R18
    03D73 E80E      LDI	R16,0x8E
    03D74 DFB6      RCALL	_ds1302_write_byte
(0145) 	ds1302_write_byte(ds1302_sec_add,0x80);				//暂停时钟 
    03D75 E820      LDI	R18,0x80
    03D76 E800      LDI	R16,0x80
    03D77 DFB3      RCALL	_ds1302_write_byte
(0146) 	//ds1302_write_byte(ds1302_charger_add,0xa9);	    //涓流充电 
(0147) 	ds1302_write_byte(ds1302_year_add,time_buf[1]);		//年 
    03D78 9120 04E7 LDS	R18,time_buf+1
    03D7A E80C      LDI	R16,0x8C
    03D7B DFAF      RCALL	_ds1302_write_byte
(0148) 	ds1302_write_byte(ds1302_month_add,time_buf[2]);	//月 
    03D7C 9120 04E8 LDS	R18,time_buf+2
    03D7E E808      LDI	R16,0x88
    03D7F DFAB      RCALL	_ds1302_write_byte
(0149) 	ds1302_write_byte(ds1302_date_add,time_buf[3]);		//日 
    03D80 9120 04E9 LDS	R18,time_buf+3
    03D82 E806      LDI	R16,0x86
    03D83 DFA7      RCALL	_ds1302_write_byte
(0150) 	ds1302_write_byte(ds1302_hr_add,time_buf[4]);		//时 
    03D84 9120 04EA LDS	R18,time_buf+4
    03D86 E804      LDI	R16,0x84
    03D87 DFA3      RCALL	_ds1302_write_byte
(0151) 	ds1302_write_byte(ds1302_min_add,time_buf[5]);		//分
    03D88 9120 04EB LDS	R18,time_buf+5
    03D8A E802      LDI	R16,0x82
    03D8B DF9F      RCALL	_ds1302_write_byte
(0152) 	ds1302_write_byte(ds1302_sec_add,time_buf[6]);		//秒
    03D8C 9120 04EC LDS	R18,time_buf+6
    03D8E E800      LDI	R16,0x80
    03D8F DF9B      RCALL	_ds1302_write_byte
(0153) 	ds1302_write_byte(ds1302_day_add,time_buf[7]);		//周 
    03D90 9120 04ED LDS	R18,time_buf+7
    03D92 E80A      LDI	R16,0x8A
    03D93 DF97      RCALL	_ds1302_write_byte
(0154) 	ds1302_write_byte(ds1302_control_add,0x80);			//打开写保护 
    03D94 E820      LDI	R18,0x80
    03D95 E80E      LDI	R16,0x8E
    03D96 CF94      RJMP	_ds1302_write_byte
_ds1302_read_time:
    03D97 92AA      ST	-Y,R10
    03D98 934A      ST	-Y,R20
(0155) }
(0156) 
(0157) //从DS302读出时钟数据
(0158) void ds1302_read_time(void)  { 
(0159) 	time_buf[1]=ds1302_read_byte(ds1302_year_add);		//年 
    03D99 E80C      LDI	R16,0x8C
    03D9A DFB2      RCALL	_ds1302_read_byte
    03D9B 9300 04E7 STS	time_buf+1,R16
(0160) 	time_buf[2]=ds1302_read_byte(ds1302_month_add);		//月 
    03D9D E808      LDI	R16,0x88
    03D9E DFAE      RCALL	_ds1302_read_byte
    03D9F 9300 04E8 STS	time_buf+2,R16
(0161) 	time_buf[3]=ds1302_read_byte(ds1302_date_add);		//日 
    03DA1 E806      LDI	R16,0x86
    03DA2 DFAA      RCALL	_ds1302_read_byte
    03DA3 2EA0      MOV	R10,R16
    03DA4 92A0 04E9 STS	time_buf+3,R10
(0162) 	time_buf[4]=ds1302_read_byte(ds1302_hr_add);		//时 
    03DA6 E804      LDI	R16,0x84
    03DA7 DFA5      RCALL	_ds1302_read_byte
    03DA8 2EA0      MOV	R10,R16
    03DA9 92A0 04EA STS	time_buf+4,R10
(0163) 	time_buf[5]=ds1302_read_byte(ds1302_min_add);		//分 
    03DAB E802      LDI	R16,0x82
    03DAC DFA0      RCALL	_ds1302_read_byte
    03DAD 2EA0      MOV	R10,R16
    03DAE 92A0 04EB STS	time_buf+5,R10
(0164) 	time_buf[6]=(ds1302_read_byte(ds1302_sec_add))&0x7F;//秒，屏蔽秒的第7位，避免超出59
    03DB0 E800      LDI	R16,0x80
    03DB1 DF9B      RCALL	_ds1302_read_byte
    03DB2 2F40      MOV	R20,R16
    03DB3 2F84      MOV	R24,R20
    03DB4 778F      ANDI	R24,0x7F
    03DB5 9380 04EC STS	time_buf+6,R24
(0165) 	time_buf[7]=ds1302_read_byte(ds1302_day_add);		//周 
    03DB7 E80A      LDI	R16,0x8A
    03DB8 DF94      RCALL	_ds1302_read_byte
    03DB9 2EA0      MOV	R10,R16
    03DBA 92A0 04ED STS	time_buf+7,R10
    03DBC 9149      LD	R20,Y+
    03DBD 90A9      LD	R10,Y+
    03DBE 9508      RET
_kbscan:
  key                  --> R20
  temp                 --> Y,+0
    03DBF 934A      ST	-Y,R20
    03DC0 9724      SBIW	R28,4
FILE: D:\LQD\software\master\software_src\key.c
(0001) #include "config.h"
(0002) //键盘扫描函数
(0003) unsigned char kbscan(void)
(0004)   {
(0005)    unsigned char key;
(0006)    unsigned long temp=0;
    03DC1 E080      LDI	R24,0
    03DC2 8388      ST	Y,R24
    03DC3 8389      STD	Y+1,R24
    03DC4 838A      STD	Y+2,R24
    03DC5 838B      STD	Y+3,R24
(0007)    DDR_SET;
    03DC6 B38A      IN	R24,0x1A
    03DC7 7087      ANDI	R24,7
    03DC8 BB8A      OUT	0x1A,R24
(0008)    
(0009)    if((KEY_PIN) != KEY_MASK)         //检测A口按键引脚电平，如果全是高电平则退出
    03DC9 B389      IN	R24,0x19
    03DCA 718F      ANDI	R24,0x1F
    03DCB 318F      CPI	R24,0x1F
    03DCC F189      BEQ	0x3DFE
(0010)     {
(0011)      delayms(20);           //防抖
    03DCD E104      LDI	R16,0x14
    03DCE E010      LDI	R17,0
    03DCF 940E 23FC CALL	_delayms
(0012)      if((KEY_PIN) != KEY_MASK )      //再次检测A口电平，如果不全是高电平则继续执行程序
    03DD1 B389      IN	R24,0x19
    03DD2 718F      ANDI	R24,0x1F
    03DD3 318F      CPI	R24,0x1F
    03DD4 F159      BEQ	0x3E00
(0013)       {
(0014)        key = KEY_PIN ;          //读取PINA，将其存放在key中
    03DD5 B349      IN	R20,0x19
    03DD6 714F      ANDI	R20,0x1F
    03DD7 C020      RJMP	0x3DF8
(0015)         while((KEY_PIN) != KEY_MASK)
(0016) 		{
(0017) 		 temp++ ;
    03DD8 E081      LDI	R24,1
    03DD9 E090      LDI	R25,0
    03DDA E0A0      LDI	R26,0
    03DDB E0B0      LDI	R27,0
    03DDC 8028      LD	R2,Y
    03DDD 8039      LDD	R3,Y+1
    03DDE 804A      LDD	R4,Y+2
    03DDF 805B      LDD	R5,Y+3
    03DE0 0E28      ADD	R2,R24
    03DE1 1E39      ADC	R3,R25
    03DE2 1E4A      ADC	R4,R26
    03DE3 1E5B      ADC	R5,R27
    03DE4 8228      ST	Y,R2
    03DE5 8239      STD	Y+1,R3
    03DE6 824A      STD	Y+2,R4
    03DE7 825B      STD	Y+3,R5
(0018) 		 if(temp>LONGKEY) 
    03DE8 E880      LDI	R24,0x80
    03DE9 E398      LDI	R25,0x38
    03DEA E0A1      LDI	R26,1
    03DEB E0B0      LDI	R27,0
    03DEC 8028      LD	R2,Y
    03DED 8039      LDD	R3,Y+1
    03DEE 804A      LDD	R4,Y+2
    03DEF 805B      LDD	R5,Y+3
    03DF0 1582      CP	R24,R2
    03DF1 0593      CPC	R25,R3
    03DF2 05A4      CPC	R26,R4
    03DF3 05B5      CPC	R27,R5
    03DF4 F418      BCC	0x3DF8
(0019) 		 {  return key+0x80;  };
    03DF5 2F04      MOV	R16,R20
    03DF6 5800      SUBI	R16,0x80
    03DF7 C009      RJMP	0x3E01
    03DF8 B389      IN	R24,0x19
    03DF9 718F      ANDI	R24,0x1F
    03DFA 318F      CPI	R24,0x1F
    03DFB F6E1      BNE	0x3DD8
(0020) 		}
(0021) 		; //当前有按键处于按下状态，再按其他按键时程序维持当前状态 
(0022)       	
(0023) 		return key;
    03DFC 2F04      MOV	R16,R20
    03DFD C003      RJMP	0x3E01
(0024) 	  
(0025) 	  }
(0026)     }
(0027) 	else return NO_KEY;
    03DFE 2700      CLR	R16
    03DFF C001      RJMP	0x3E01
(0028) 	
(0029) 	return NO_KEY;
FILE: <library>
    03E00 2700      CLR	R16
    03E01 9624      ADIW	R28,4
    03E02 9149      LD	R20,Y+
    03E03 9508      RET
_memset:
    03E04 8188      LD	R24,Y
    03E05 8199      LDD	R25,Y+1
    03E06 3080      CPI	R24,0
    03E07 0789      CPC	R24,R25
    03E08 F029      BEQ	0x3E0E
    03E09 2FE0      MOV	R30,R16
    03E0A 2FF1      MOV	R31,R17
    03E0B 9321      ST	Z+,R18
    03E0C 9701      SBIW	R24,1
    03E0D F7E9      BNE	0x3E0B
    03E0E 9508      RET
_strcat:
    03E0F 2FA0      MOV	R26,R16
    03E10 2FB1      MOV	R27,R17
    03E11 2FE2      MOV	R30,R18
    03E12 2FF3      MOV	R31,R19
    03E13 912D      LD	R18,X+
    03E14 2322      TST	R18
    03E15 F7E9      BNE	0x3E13
    03E16 9711      SBIW	R26,1
    03E17 9121      LD	R18,Z+
    03E18 932D      ST	X+,R18
    03E19 2322      TST	R18
    03E1A F7E1      BNE	0x3E17
    03E1B 9508      RET
_strlen:
    03E1C 2FE0      MOV	R30,R16
    03E1D 2FF1      MOV	R31,R17
    03E1E 27AA      CLR	R26
    03E1F 27BB      CLR	R27
    03E20 9001      LD	R0,Z+
    03E21 2000      TST	R0
    03E22 F011      BEQ	0x3E25
    03E23 9611      ADIW	R26,1
    03E24 CFFB      RJMP	0x3E20
    03E25 2F0A      MOV	R16,R26
    03E26 2F1B      MOV	R17,R27
    03E27 9508      RET
push_arg4:
    03E28 933A      ST	-Y,R19
    03E29 932A      ST	-Y,R18
push_arg2:
    03E2A 931A      ST	-Y,R17
    03E2B 930A      ST	-Y,R16
    03E2C 9508      RET
asr32:
    03E2D 920F      PUSH	R0
    03E2E 9009      LD	R0,Y+
    03E2F 2000      TST	R0
    03E30 F031      BEQ	0x3E37
    03E31 9535      ASR	R19
    03E32 9527      ROR	R18
    03E33 9517      ROR	R17
    03E34 9507      ROR	R16
    03E35 940A      DEC	R0
    03E36 CFF8      RJMP	0x3E2F
    03E37 900F      POP	R0
    03E38 9508      RET
mod16s:
    03E39 9468      BSET	6
    03E3A 92DA      ST	-Y,R13
    03E3B 2ED1      MOV	R13,R17
    03E3C C004      RJMP	0x3E41
div16s:
    03E3D 94E8      BCLR	6
    03E3E 92DA      ST	-Y,R13
    03E3F 2ED1      MOV	R13,R17
    03E40 26D3      EOR	R13,R19
    03E41 FF17      SBRS	R17,7
    03E42 C004      RJMP	0x3E47
    03E43 9510      COM	R17
    03E44 9500      COM	R16
    03E45 5F0F      SUBI	R16,0xFF
    03E46 4F1F      SBCI	R17,0xFF
    03E47 FF37      SBRS	R19,7
    03E48 C004      RJMP	0x3E4D
    03E49 9530      COM	R19
    03E4A 9520      COM	R18
    03E4B 5F2F      SUBI	R18,0xFF
    03E4C 4F3F      SBCI	R19,0xFF
    03E4D 940E 3E5A CALL	xdiv16u
    03E4F FED7      SBRS	R13,7
    03E50 C004      RJMP	0x3E55
    03E51 9510      COM	R17
    03E52 9500      COM	R16
    03E53 5F0F      SUBI	R16,0xFF
    03E54 4F1F      SBCI	R17,0xFF
    03E55 90D9      LD	R13,Y+
    03E56 9508      RET
mod16u:
    03E57 9468      BSET	6
    03E58 C001      RJMP	xdiv16u
div16u:
    03E59 94E8      BCLR	6
xdiv16u:
    03E5A 92EA      ST	-Y,R14
    03E5B 92FA      ST	-Y,R15
    03E5C 938A      ST	-Y,R24
    03E5D 24EE      CLR	R14
    03E5E 24FF      CLR	R15
    03E5F E180      LDI	R24,0x10
    03E60 0F00      LSL	R16
    03E61 1F11      ROL	R17
    03E62 1CEE      ROL	R14
    03E63 1CFF      ROL	R15
    03E64 16E2      CP	R14,R18
    03E65 06F3      CPC	R15,R19
    03E66 F018      BCS	0x3E6A
    03E67 1AE2      SUB	R14,R18
    03E68 0AF3      SBC	R15,R19
    03E69 9503      INC	R16
    03E6A 958A      DEC	R24
    03E6B F7A1      BNE	0x3E60
    03E6C F416      BRTC	0x3E6F
    03E6D 2D0E      MOV	R16,R14
    03E6E 2D1F      MOV	R17,R15
    03E6F 9189      LD	R24,Y+
    03E70 90F9      LD	R15,Y+
    03E71 90E9      LD	R14,Y+
    03E72 9508      RET
div32u:
    03E73 94E8      BCLR	6
    03E74 C001      RJMP	0x3E76
mod32u:
    03E75 9468      BSET	6
    03E76 D030      RCALL	long_div_prolog
    03E77 24CC      CLR	R12
    03E78 C009      RJMP	0x3E82
div32s:
    03E79 94E8      BCLR	6
    03E7A C001      RJMP	0x3E7C
mod32s:
    03E7B 9468      BSET	6
    03E7C D02A      RCALL	long_div_prolog
    03E7D FD37      SBRC	R19,7
    03E7E 940E 3FBA CALL	neg32
    03E80 FDB7      SBRC	R27,7
    03E81 D052      RCALL	neg_R24_R27
    03E82 2477      CLR	R7
    03E83 2488      CLR	R8
    03E84 2499      CLR	R9
    03E85 24AA      CLR	R10
    03E86 24BB      CLR	R11
    03E87 D042      RCALL	tst_R16_R19
    03E88 F0C1      BEQ	0x3EA1
    03E89 D045      RCALL	tst_R24_R27
    03E8A F0B1      BEQ	0x3EA1
    03E8B E2E8      LDI	R30,0x28
    03E8C 0F00      LSL	R16
    03E8D 1F11      ROL	R17
    03E8E 1F22      ROL	R18
    03E8F 1F33      ROL	R19
    03E90 1C77      ROL	R7
    03E91 1C88      ROL	R8
    03E92 1C99      ROL	R9
    03E93 1CAA      ROL	R10
    03E94 1CBB      ROL	R11
    03E95 1688      CP	R8,R24
    03E96 0699      CPC	R9,R25
    03E97 06AA      CPC	R10,R26
    03E98 06BB      CPC	R11,R27
    03E99 F028      BCS	0x3E9F
    03E9A 1A88      SUB	R8,R24
    03E9B 0A99      SBC	R9,R25
    03E9C 0AAA      SBC	R10,R26
    03E9D 0ABB      SBC	R11,R27
    03E9E 9503      INC	R16
    03E9F 95EA      DEC	R30
    03EA0 F759      BNE	0x3E8C
    03EA1 F426      BRTC	0x3EA6
    03EA2 2D08      MOV	R16,R8
    03EA3 2D19      MOV	R17,R9
    03EA4 2D2A      MOV	R18,R10
    03EA5 2D3B      MOV	R19,R11
    03EA6 C013      RJMP	long_div_epilog
long_div_prolog:
    03EA7 927A      ST	-Y,R7
    03EA8 928A      ST	-Y,R8
    03EA9 929A      ST	-Y,R9
    03EAA 92AA      ST	-Y,R10
    03EAB 92BA      ST	-Y,R11
    03EAC 92CA      ST	-Y,R12
    03EAD 93EA      ST	-Y,R30
    03EAE 938A      ST	-Y,R24
    03EAF 939A      ST	-Y,R25
    03EB0 93AA      ST	-Y,R26
    03EB1 93BA      ST	-Y,R27
    03EB2 858B      LDD	R24,Y+11
    03EB3 859C      LDD	R25,Y+12
    03EB4 85AD      LDD	R26,Y+13
    03EB5 85BE      LDD	R27,Y+14
    03EB6 2EC3      MOV	R12,R19
    03EB7 F00E      BRTS	0x3EB9
    03EB8 26CB      EOR	R12,R27
    03EB9 9508      RET
long_div_epilog:
    03EBA FCC7      SBRC	R12,7
    03EBB 940E 3FBA CALL	neg32
    03EBD 91B9      LD	R27,Y+
    03EBE 91A9      LD	R26,Y+
    03EBF 9199      LD	R25,Y+
    03EC0 9189      LD	R24,Y+
    03EC1 91E9      LD	R30,Y+
    03EC2 90C9      LD	R12,Y+
    03EC3 90B9      LD	R11,Y+
    03EC4 90A9      LD	R10,Y+
    03EC5 9099      LD	R9,Y+
    03EC6 9089      LD	R8,Y+
    03EC7 9079      LD	R7,Y+
    03EC8 9624      ADIW	R28,4
    03EC9 9508      RET
tst_R16_R19:
    03ECA 2FE0      MOV	R30,R16
    03ECB 2BE1      OR	R30,R17
    03ECC 2BE2      OR	R30,R18
    03ECD 2BE3      OR	R30,R19
    03ECE 9508      RET
tst_R24_R27:
    03ECF 2FE8      MOV	R30,R24
    03ED0 2BE9      OR	R30,R25
    03ED1 2BEA      OR	R30,R26
    03ED2 2BEB      OR	R30,R27
    03ED3 9508      RET
neg_R24_R27:
    03ED4 9580      COM	R24
    03ED5 9590      COM	R25
    03ED6 95A0      COM	R26
    03ED7 95B0      COM	R27
    03ED8 5F8F      SUBI	R24,0xFF
    03ED9 4F9F      SBCI	R25,0xFF
    03EDA 4FAF      SBCI	R26,0xFF
    03EDB 4FBF      SBCI	R27,0xFF
    03EDC 9508      RET
mod8u:
    03EDD 9468      BSET	6
    03EDE C001      RJMP	xdiv8u
div8u:
    03EDF 94E8      BCLR	6
xdiv8u:
    03EE0 932A      ST	-Y,R18
    03EE1 92FA      ST	-Y,R15
    03EE2 92EA      ST	-Y,R14
    03EE3 24FF      CLR	R15
    03EE4 24EE      CLR	R14
    03EE5 E120      LDI	R18,0x10
    03EE6 0F00      LSL	R16
    03EE7 1CFF      ROL	R15
    03EE8 1CEE      ROL	R14
    03EE9 16E1      CP	R14,R17
    03EEA F010      BCS	0x3EED
    03EEB 1AE1      SUB	R14,R17
    03EEC 9503      INC	R16
    03EED 952A      DEC	R18
    03EEE F7B9      BNE	0x3EE6
    03EEF F40E      BRTC	0x3EF1
    03EF0 2D0E      MOV	R16,R14
    03EF1 90E9      LD	R14,Y+
    03EF2 90F9      LD	R15,Y+
    03EF3 9129      LD	R18,Y+
    03EF4 9508      RET
elpm32:
    03EF5 93EA      ST	-Y,R30
    03EF6 93FA      ST	-Y,R31
    03EF7 920A      ST	-Y,R0
    03EF8 2FE0      MOV	R30,R16
    03EF9 2FF1      MOV	R31,R17
    03EFA 95D8      ELPM
    03EFB 2D00      MOV	R16,R0
    03EFC 9631      ADIW	R30,1
    03EFD 95D8      ELPM
    03EFE 2D10      MOV	R17,R0
    03EFF 9631      ADIW	R30,1
    03F00 95D8      ELPM
    03F01 2D20      MOV	R18,R0
    03F02 9631      ADIW	R30,1
    03F03 95D8      ELPM
    03F04 2D30      MOV	R19,R0
    03F05 9009      LD	R0,Y+
    03F06 91F9      LD	R31,Y+
    03F07 91E9      LD	R30,Y+
    03F08 9508      RET
empy16s:
    03F09 920A      ST	-Y,R0
    03F0A 921A      ST	-Y,R1
    03F0B 938A      ST	-Y,R24
    03F0C 939A      ST	-Y,R25
    03F0D 9F02      MUL	R16,R18
    03F0E 01C0      MOVW	R24,R0
    03F0F 9F12      MUL	R17,R18
    03F10 0D90      ADD	R25,R0
    03F11 9F03      MUL	R16,R19
    03F12 0D90      ADD	R25,R0
    03F13 018C      MOVW	R16,R24
    03F14 9199      LD	R25,Y+
    03F15 9189      LD	R24,Y+
    03F16 9019      LD	R1,Y+
    03F17 9009      LD	R0,Y+
    03F18 9508      RET
empy32u|empy32s:
    03F19 940E 3FC3 CALL	long_prolog
    03F1B 927A      ST	-Y,R7
    03F1C 940E 3FDC CALL	tstzero1
    03F1E F159      BEQ	0x3F4A
    03F1F 2477      CLR	R7
    03F20 940E 3FE2 CALL	tstzero2
    03F22 F419      BNE	0x3F26
    03F23 018C      MOVW	R16,R24
    03F24 019D      MOVW	R18,R26
    03F25 C024      RJMP	0x3F4A
    03F26 920A      ST	-Y,R0
    03F27 921A      ST	-Y,R1
    03F28 9F08      MUL	R16,R24
    03F29 2CB0      MOV	R11,R0
    03F2A 2CA1      MOV	R10,R1
    03F2B 9F28      MUL	R18,R24
    03F2C 2C90      MOV	R9,R0
    03F2D 2C81      MOV	R8,R1
    03F2E 9F18      MUL	R17,R24
    03F2F 0CA0      ADD	R10,R0
    03F30 1C91      ADC	R9,R1
    03F31 1C87      ADC	R8,R7
    03F32 9F09      MUL	R16,R25
    03F33 0CA0      ADD	R10,R0
    03F34 1C91      ADC	R9,R1
    03F35 1C87      ADC	R8,R7
    03F36 9F19      MUL	R17,R25
    03F37 0C90      ADD	R9,R0
    03F38 1C81      ADC	R8,R1
    03F39 9F0A      MUL	R16,R26
    03F3A 0C90      ADD	R9,R0
    03F3B 1C81      ADC	R8,R1
    03F3C 9F38      MUL	R19,R24
    03F3D 0C80      ADD	R8,R0
    03F3E 9F29      MUL	R18,R25
    03F3F 0C80      ADD	R8,R0
    03F40 9F1A      MUL	R17,R26
    03F41 0C80      ADD	R8,R0
    03F42 9F0B      MUL	R16,R27
    03F43 0C80      ADD	R8,R0
    03F44 9019      LD	R1,Y+
    03F45 9009      LD	R0,Y+
    03F46 2D0B      MOV	R16,R11
    03F47 2D1A      MOV	R17,R10
    03F48 2D29      MOV	R18,R9
    03F49 2D38      MOV	R19,R8
    03F4A 9079      LD	R7,Y+
    03F4B 940C 3FD1 JMP	long_epilog
pop_xgset003C:
    03F4D 90A9      LD	R10,Y+
    03F4E 90B9      LD	R11,Y+
    03F4F 90C9      LD	R12,Y+
    03F50 90D9      LD	R13,Y+
    03F51 9508      RET
pop_xgset00FC:
    03F52 90A9      LD	R10,Y+
    03F53 90B9      LD	R11,Y+
    03F54 90C9      LD	R12,Y+
    03F55 90D9      LD	R13,Y+
    03F56 90E9      LD	R14,Y+
    03F57 90F9      LD	R15,Y+
    03F58 9508      RET
pop_xgset30FC:
    03F59 90A9      LD	R10,Y+
    03F5A 90B9      LD	R11,Y+
    03F5B 90C9      LD	R12,Y+
    03F5C 90D9      LD	R13,Y+
    03F5D 90E9      LD	R14,Y+
    03F5E 90F9      LD	R15,Y+
    03F5F 9149      LD	R20,Y+
    03F60 9159      LD	R21,Y+
    03F61 9508      RET
pop_xgsetF0FC:
    03F62 90A9      LD	R10,Y+
    03F63 90B9      LD	R11,Y+
    03F64 90C9      LD	R12,Y+
    03F65 90D9      LD	R13,Y+
    03F66 90E9      LD	R14,Y+
    03F67 90F9      LD	R15,Y+
    03F68 9149      LD	R20,Y+
    03F69 9159      LD	R21,Y+
    03F6A 9169      LD	R22,Y+
    03F6B 9179      LD	R23,Y+
    03F6C 9508      RET
push_xgsetF0FC:
    03F6D 937A      ST	-Y,R23
    03F6E 936A      ST	-Y,R22
push_xgset30FC:
    03F6F 935A      ST	-Y,R21
    03F70 934A      ST	-Y,R20
push_xgset00FC:
    03F71 92FA      ST	-Y,R15
    03F72 92EA      ST	-Y,R14
push_xgset003C:
    03F73 92DA      ST	-Y,R13
    03F74 92CA      ST	-Y,R12
    03F75 92BA      ST	-Y,R11
    03F76 92AA      ST	-Y,R10
    03F77 9508      RET
push_xgset300C:
    03F78 935A      ST	-Y,R21
    03F79 934A      ST	-Y,R20
    03F7A 92BA      ST	-Y,R11
    03F7B 92AA      ST	-Y,R10
    03F7C 9508      RET
pop_xgset300C:
    03F7D 90A9      LD	R10,Y+
    03F7E 90B9      LD	R11,Y+
    03F7F 9149      LD	R20,Y+
    03F80 9159      LD	R21,Y+
    03F81 9508      RET
push_xgsetF000:
    03F82 937A      ST	-Y,R23
    03F83 936A      ST	-Y,R22
    03F84 935A      ST	-Y,R21
    03F85 934A      ST	-Y,R20
    03F86 9508      RET
pop_xgsetF000:
    03F87 9149      LD	R20,Y+
    03F88 9159      LD	R21,Y+
    03F89 9169      LD	R22,Y+
    03F8A 9179      LD	R23,Y+
    03F8B 9508      RET
push_xgsetF00C:
    03F8C 937A      ST	-Y,R23
    03F8D 936A      ST	-Y,R22
    03F8E 935A      ST	-Y,R21
    03F8F 934A      ST	-Y,R20
    03F90 92BA      ST	-Y,R11
    03F91 92AA      ST	-Y,R10
    03F92 9508      RET
pop_xgsetF00C:
    03F93 90A9      LD	R10,Y+
    03F94 90B9      LD	R11,Y+
    03F95 9149      LD	R20,Y+
    03F96 9159      LD	R21,Y+
    03F97 9169      LD	R22,Y+
    03F98 9179      LD	R23,Y+
    03F99 9508      RET
push_xgset303C:
    03F9A 935A      ST	-Y,R21
    03F9B 934A      ST	-Y,R20
    03F9C 92DA      ST	-Y,R13
    03F9D 92CA      ST	-Y,R12
    03F9E 92BA      ST	-Y,R11
    03F9F 92AA      ST	-Y,R10
    03FA0 9508      RET
pop_xgset303C:
    03FA1 90A9      LD	R10,Y+
    03FA2 90B9      LD	R11,Y+
    03FA3 90C9      LD	R12,Y+
    03FA4 90D9      LD	R13,Y+
    03FA5 9149      LD	R20,Y+
    03FA6 9159      LD	R21,Y+
    03FA7 9508      RET
push_xgsetF03C:
    03FA8 937A      ST	-Y,R23
    03FA9 936A      ST	-Y,R22
    03FAA 935A      ST	-Y,R21
    03FAB 934A      ST	-Y,R20
    03FAC 92DA      ST	-Y,R13
    03FAD 92CA      ST	-Y,R12
    03FAE 92BA      ST	-Y,R11
    03FAF 92AA      ST	-Y,R10
    03FB0 9508      RET
pop_xgsetF03C:
    03FB1 90A9      LD	R10,Y+
    03FB2 90B9      LD	R11,Y+
    03FB3 90C9      LD	R12,Y+
    03FB4 90D9      LD	R13,Y+
    03FB5 9149      LD	R20,Y+
    03FB6 9159      LD	R21,Y+
    03FB7 9169      LD	R22,Y+
    03FB8 9179      LD	R23,Y+
    03FB9 9508      RET
neg32:
    03FBA 9500      COM	R16
    03FBB 9510      COM	R17
    03FBC 9520      COM	R18
    03FBD 9530      COM	R19
    03FBE 5F0F      SUBI	R16,0xFF
    03FBF 4F1F      SBCI	R17,0xFF
    03FC0 4F2F      SBCI	R18,0xFF
    03FC1 4F3F      SBCI	R19,0xFF
    03FC2 9508      RET
long_prolog:
    03FC3 928A      ST	-Y,R8
    03FC4 929A      ST	-Y,R9
    03FC5 92AA      ST	-Y,R10
    03FC6 92BA      ST	-Y,R11
    03FC7 93EA      ST	-Y,R30
    03FC8 938A      ST	-Y,R24
    03FC9 939A      ST	-Y,R25
    03FCA 93AA      ST	-Y,R26
    03FCB 93BA      ST	-Y,R27
    03FCC 8589      LDD	R24,Y+9
    03FCD 859A      LDD	R25,Y+10
    03FCE 85AB      LDD	R26,Y+11
    03FCF 85BC      LDD	R27,Y+12
    03FD0 9508      RET
long_epilog:
    03FD1 91B9      LD	R27,Y+
    03FD2 91A9      LD	R26,Y+
    03FD3 9199      LD	R25,Y+
    03FD4 9189      LD	R24,Y+
    03FD5 91E9      LD	R30,Y+
    03FD6 90B9      LD	R11,Y+
    03FD7 90A9      LD	R10,Y+
    03FD8 9099      LD	R9,Y+
    03FD9 9089      LD	R8,Y+
    03FDA 9624      ADIW	R28,4
    03FDB 9508      RET
tstzero1:
    03FDC 27EE      CLR	R30
    03FDD 2BE0      OR	R30,R16
    03FDE 2BE1      OR	R30,R17
    03FDF 2BE2      OR	R30,R18
    03FE0 2BE3      OR	R30,R19
    03FE1 9508      RET
tstzero2:
    03FE2 27EE      CLR	R30
    03FE3 2BE8      OR	R30,R24
    03FE4 2BE9      OR	R30,R25
    03FE5 2BEA      OR	R30,R26
    03FE6 2BEB      OR	R30,R27
    03FE7 9508      RET
lsl16:
    03FE8 2322      TST	R18
    03FE9 F021      BEQ	0x3FEE
    03FEA 0F00      LSL	R16
    03FEB 1F11      ROL	R17
    03FEC 952A      DEC	R18
    03FED CFFA      RJMP	lsl16
    03FEE 9508      RET
lsl32:
    03FEF 920F      PUSH	R0
    03FF0 9009      LD	R0,Y+
    03FF1 2000      TST	R0
    03FF2 F031      BEQ	0x3FF9
    03FF3 0F00      LSL	R16
    03FF4 1F11      ROL	R17
    03FF5 1F22      ROL	R18
    03FF6 1F33      ROL	R19
    03FF7 940A      DEC	R0
    03FF8 CFF8      RJMP	0x3FF1
    03FF9 900F      POP	R0
    03FFA 9508      RET
lsl8:
    03FFB 2311      TST	R17
    03FFC F019      BEQ	0x4000
    03FFD 0F00      LSL	R16
    03FFE 951A      DEC	R17
    03FFF CFFB      RJMP	lsl8
    04000 9508      RET
lsr16:
    04001 2322      TST	R18
    04002 F021      BEQ	0x4007
    04003 9516      LSR	R17
    04004 9507      ROR	R16
    04005 952A      DEC	R18
    04006 CFFA      RJMP	lsr16
    04007 9508      RET
lsr32:
    04008 920F      PUSH	R0
    04009 9009      LD	R0,Y+
    0400A 2000      TST	R0
    0400B F031      BEQ	0x4012
    0400C 9536      LSR	R19
    0400D 9527      ROR	R18
    0400E 9517      ROR	R17
    0400F 9507      ROR	R16
    04010 940A      DEC	R0
    04011 CFF8      RJMP	0x400A
    04012 900F      POP	R0
    04013 9508      RET
asgnblk:
    04014 93AA      ST	-Y,R26
    04015 93BA      ST	-Y,R27
    04016 93EA      ST	-Y,R30
    04017 93FA      ST	-Y,R31
    04018 920A      ST	-Y,R0
    04019 81AF      LDD	R26,Y+7
    0401A 85B8      LDD	R27,Y+8
    0401B 81ED      LDD	R30,Y+5
    0401C 81FE      LDD	R31,Y+6
    0401D 3000      CPI	R16,0
    0401E 0701      CPC	R16,R17
    0401F F029      BEQ	0x4025
    04020 9001      LD	R0,Z+
    04021 920D      ST	X+,R0
    04022 5001      SUBI	R16,1
    04023 4010      SBCI	R17,0
    04024 CFF8      RJMP	0x401D
    04025 9009      LD	R0,Y+
    04026 91F9      LD	R31,Y+
    04027 91E9      LD	R30,Y+
    04028 91B9      LD	R27,Y+
    04029 91A9      LD	R26,Y+
    0402A 9624      ADIW	R28,4
    0402B 9508      RET
fpsub:
    0402C 9468      BSET	6
    0402D C001      RJMP	fpadd_alt
fpadd:
    0402E 94E8      BCLR	6
fpadd_alt:
    0402F 940E 41F3 CALL	saveFPRegs
    04031 940E 4185 CALL	unpacks
    04033 F409      BNE	0x4035
    04034 C048      RJMP	0x407D
    04035 2CE6      MOV	R14,R6
    04036 2CD5      MOV	R13,R5
    04037 2CC4      MOV	R12,R4
    04038 2EB3      MOV	R11,R19
    04039 2EA2      MOV	R10,R18
    0403A 2E91      MOV	R9,R17
    0403B 2E80      MOV	R8,R16
    0403C 8100      LD	R16,Z
    0403D 8111      LDD	R17,Z+1
    0403E 8122      LDD	R18,Z+2
    0403F 8133      LDD	R19,Z+3
    04040 940E 4185 CALL	unpacks
    04042 F409      BNE	0x4044
    04043 C044      RJMP	0x4088
    04044 2D84      MOV	R24,R4
    04045 2D95      MOV	R25,R5
    04046 198C      SUB	R24,R12
    04047 099D      SBC	R25,R13
    04048 F0B9      BEQ	0x4060
    04049 F472      BPL	0x4058
    0404A 9590      COM	R25
    0404B 9580      COM	R24
    0404C 9601      ADIW	R24,1
    0404D 2C4C      MOV	R4,R12
    0404E 2C5D      MOV	R5,R13
    0404F 3188      CPI	R24,0x18
    04050 F5B8      BCC	0x4088
    04051 9535      ASR	R19
    04052 9527      ROR	R18
    04053 9517      ROR	R17
    04054 9507      ROR	R16
    04055 9701      SBIW	R24,1
    04056 F7D1      BNE	0x4051
    04057 C008      RJMP	0x4060
    04058 3188      CPI	R24,0x18
    04059 F518      BCC	0x407D
    0405A 94B5      ASR	R11
    0405B 94A7      ROR	R10
    0405C 9497      ROR	R9
    0405D 9487      ROR	R8
    0405E 9701      SBIW	R24,1
    0405F F7D1      BNE	0x405A
    04060 2466      CLR	R6
    04061 F02E      BRTS	0x4067
    04062 0D08      ADD	R16,R8
    04063 1D19      ADC	R17,R9
    04064 1D2A      ADC	R18,R10
    04065 1D3B      ADC	R19,R11
    04066 C009      RJMP	0x4070
    04067 1A80      SUB	R8,R16
    04068 0A91      SBC	R9,R17
    04069 0AA2      SBC	R10,R18
    0406A 0AB3      SBC	R11,R19
    0406B 2D08      MOV	R16,R8
    0406C 2D19      MOV	R17,R9
    0406D 2D2A      MOV	R18,R10
    0406E 2D3B      MOV	R19,R11
    0406F 2333      TST	R19
    04070 F422      BPL	0x4075
    04071 940E 3FBA CALL	neg32
    04073 E880      LDI	R24,0x80
    04074 2E68      MOV	R6,R24
    04075 940E 41AE CALL	normalize_and_pack
    04077 C002      RJMP	0x407A
    04078 940E 41E3 CALL	pack
    0407A 940E 4202 CALL	restoreFPRegs
    0407C 9508      RET
    0407D 8100      LD	R16,Z
    0407E 8111      LDD	R17,Z+1
    0407F 8122      LDD	R18,Z+2
    04080 8133      LDD	R19,Z+3
    04081 F7C6      BRTC	0x407A
    04082 940E 418D CALL	tstR16_R19
    04084 F3A9      BEQ	0x407A
    04085 E880      LDI	R24,0x80
    04086 2738      EOR	R19,R24
    04087 CFF2      RJMP	0x407A
    04088 2D08      MOV	R16,R8
    04089 2D19      MOV	R17,R9
    0408A 2D2A      MOV	R18,R10
    0408B 2D3B      MOV	R19,R11
    0408C 2C4C      MOV	R4,R12
    0408D 2C5D      MOV	R5,R13
    0408E 2C6E      MOV	R6,R14
    0408F 2333      TST	R19
    04090 F73A      BPL	0x4078
    04091 940E 3FBA CALL	neg32
    04093 E880      LDI	R24,0x80
    04094 2E68      MOV	R6,R24
    04095 CFE2      RJMP	0x4078
fpadd2:
    04096 93FA      ST	-Y,R31
    04097 93EA      ST	-Y,R30
    04098 2FEC      MOV	R30,R28
    04099 2FFD      MOV	R31,R29
    0409A 9632      ADIW	R30,2
    0409B 940E 402E CALL	fpadd
    0409D 91E9      LD	R30,Y+
    0409E 91F9      LD	R31,Y+
    0409F 9624      ADIW	R28,4
    040A0 9508      RET
fpsub2:
    040A1 93FA      ST	-Y,R31
    040A2 93EA      ST	-Y,R30
    040A3 2FEC      MOV	R30,R28
    040A4 2FFD      MOV	R31,R29
    040A5 9632      ADIW	R30,2
    040A6 940E 402C CALL	fpsub
    040A8 91E9      LD	R30,Y+
    040A9 91F9      LD	R31,Y+
    040AA 9624      ADIW	R28,4
    040AB 9508      RET
fpsub1x:
    040AC 93FA      ST	-Y,R31
    040AD 93EA      ST	-Y,R30
    040AE 81EA      LDD	R30,Y+2
    040AF 81FB      LDD	R31,Y+3
    040B0 940E 402C CALL	fpsub
    040B2 91E9      LD	R30,Y+
    040B3 91F9      LD	R31,Y+
    040B4 8339      STD	Y+1,R19
    040B5 8328      ST	Y,R18
    040B6 931A      ST	-Y,R17
    040B7 930A      ST	-Y,R16
    040B8 9508      RET
fpsub2x:
    040B9 93FA      ST	-Y,R31
    040BA 93EA      ST	-Y,R30
    040BB 2FEC      MOV	R30,R28
    040BC 2FFD      MOV	R31,R29
    040BD 9632      ADIW	R30,2
    040BE 940E 402C CALL	fpsub
    040C0 91E9      LD	R30,Y+
    040C1 91F9      LD	R31,Y+
    040C2 833B      STD	Y+3,R19
    040C3 832A      STD	Y+2,R18
    040C4 8319      STD	Y+1,R17
    040C5 8308      ST	Y,R16
    040C6 9508      RET
uint2fp:
    040C7 9468      BSET	6
    040C8 C001      RJMP	0x40CA
int2fp:
    040C9 94E8      BCLR	6
    040CA 2722      CLR	R18
    040CB 2733      CLR	R19
    040CC F046      BRTS	0x40D5
    040CD FD17      SBRC	R17,7
    040CE 9520      COM	R18
    040CF FD17      SBRC	R17,7
    040D0 9530      COM	R19
    040D1 C003      RJMP	0x40D5
ulong2fp:
    040D2 9468      BSET	6
    040D3 C001      RJMP	0x40D5
long2fp:
    040D4 94E8      BCLR	6
    040D5 924A      ST	-Y,R4
    040D6 925A      ST	-Y,R5
    040D7 926A      ST	-Y,R6
    040D8 938A      ST	-Y,R24
    040D9 E187      LDI	R24,0x17
    040DA 2E48      MOV	R4,R24
    040DB 2455      CLR	R5
    040DC 2466      CLR	R6
    040DD F036      BRTS	0x40E4
    040DE 2333      TST	R19
    040DF F422      BPL	0x40E4
    040E0 940E 3FBA CALL	neg32
    040E2 E880      LDI	R24,0x80
    040E3 2E68      MOV	R6,R24
    040E4 940E 41AE CALL	normalize_and_pack
    040E6 9189      LD	R24,Y+
    040E7 9069      LD	R6,Y+
    040E8 9059      LD	R5,Y+
    040E9 9049      LD	R4,Y+
    040EA 9508      RET
fpdiv1:
    040EB 93FA      ST	-Y,R31
    040EC 93EA      ST	-Y,R30
    040ED 81EA      LDD	R30,Y+2
    040EE 81FB      LDD	R31,Y+3
    040EF D027      RCALL	0x4117
    040F0 91E9      LD	R30,Y+
    040F1 91F9      LD	R31,Y+
    040F2 9622      ADIW	R28,2
    040F3 9508      RET
fpdiv2:
    040F4 93FA      ST	-Y,R31
    040F5 93EA      ST	-Y,R30
    040F6 2FEC      MOV	R30,R28
    040F7 2FFD      MOV	R31,R29
    040F8 9632      ADIW	R30,2
    040F9 D01D      RCALL	0x4117
    040FA 91E9      LD	R30,Y+
    040FB 91F9      LD	R31,Y+
    040FC 9624      ADIW	R28,4
    040FD 9508      RET
fpdiv1x:
    040FE 93FA      ST	-Y,R31
    040FF 93EA      ST	-Y,R30
    04100 81EA      LDD	R30,Y+2
    04101 81FB      LDD	R31,Y+3
    04102 D014      RCALL	0x4117
    04103 91E9      LD	R30,Y+
    04104 91F9      LD	R31,Y+
    04105 8339      STD	Y+1,R19
    04106 8328      ST	Y,R18
    04107 931A      ST	-Y,R17
    04108 930A      ST	-Y,R16
    04109 9508      RET
fpdiv2x:
    0410A 93FA      ST	-Y,R31
    0410B 93EA      ST	-Y,R30
    0410C 2FEC      MOV	R30,R28
    0410D 2FFD      MOV	R31,R29
    0410E 9632      ADIW	R30,2
    0410F D007      RCALL	0x4117
    04110 91E9      LD	R30,Y+
    04111 91F9      LD	R31,Y+
    04112 833B      STD	Y+3,R19
    04113 832A      STD	Y+2,R18
    04114 8319      STD	Y+1,R17
    04115 8308      ST	Y,R16
    04116 9508      RET
    04117 920A      ST	-Y,R0
    04118 921A      ST	-Y,R1
    04119 922A      ST	-Y,R2
    0411A 923A      ST	-Y,R3
    0411B 940E 41F3 CALL	saveFPRegs
    0411D 933A      ST	-Y,R19
    0411E 932A      ST	-Y,R18
    0411F 931A      ST	-Y,R17
    04120 930A      ST	-Y,R16
    04121 8100      LD	R16,Z
    04122 8111      LDD	R17,Z+1
    04123 8122      LDD	R18,Z+2
    04124 8133      LDD	R19,Z+3
    04125 940E 4195 CALL	unpacku
    04127 F409      BNE	0x4129
    04128 C057      RJMP	0x4180
    04129 2CE6      MOV	R14,R6
    0412A 2CD5      MOV	R13,R5
    0412B 2CC4      MOV	R12,R4
    0412C 2EB3      MOV	R11,R19
    0412D 2EA2      MOV	R10,R18
    0412E 2E91      MOV	R9,R17
    0412F 2E80      MOV	R8,R16
    04130 9109      LD	R16,Y+
    04131 9119      LD	R17,Y+
    04132 9129      LD	R18,Y+
    04133 9139      LD	R19,Y+
    04134 940E 4195 CALL	unpacku
    04136 F1A1      BEQ	0x416B
    04137 246E      EOR	R6,R14
    04138 184C      SUB	R4,R12
    04139 085D      SBC	R5,R13
    0413A E880      LDI	R24,0x80
    0413B 1648      CP	R4,R24
    0413C 0653      CPC	R5,R19
    0413D F00C      BLT	0x413F
    0413E C033      RJMP	0x4172
    0413F E881      LDI	R24,0x81
    04140 1648      CP	R4,R24
    04141 EF8F      LDI	R24,0xFF
    04142 0658      CPC	R5,R24
    04143 F40C      BGE	0x4145
    04144 C036      RJMP	0x417B
    04145 E280      LDI	R24,0x20
    04146 2433      CLR	R3
    04147 2E23      MOV	R2,R19
    04148 2E12      MOV	R1,R18
    04149 2E01      MOV	R0,R17
    0414A 2F30      MOV	R19,R16
    0414B 2722      CLR	R18
    0414C 2711      CLR	R17
    0414D 2700      CLR	R16
    0414E 9426      LSR	R2
    0414F 9417      ROR	R1
    04150 9407      ROR	R0
    04151 9537      ROR	R19
    04152 9527      ROR	R18
    04153 0F00      LSL	R16
    04154 1F11      ROL	R17
    04155 1F22      ROL	R18
    04156 1F33      ROL	R19
    04157 1C00      ROL	R0
    04158 1C11      ROL	R1
    04159 1C22      ROL	R2
    0415A 1C33      ROL	R3
    0415B F028      BCS	0x4161
    0415C 1808      SUB	R0,R8
    0415D 0819      SBC	R1,R9
    0415E 082A      SBC	R2,R10
    0415F 083B      SBC	R3,R11
    04160 C004      RJMP	0x4165
    04161 0C08      ADD	R0,R8
    04162 1C19      ADC	R1,R9
    04163 1C2A      ADC	R2,R10
    04164 1C3B      ADC	R3,R11
    04165 F00A      BMI	0x4167
    04166 6001      ORI	R16,1
    04167 958A      DEC	R24
    04168 F751      BNE	0x4153
    04169 940E 41AE CALL	normalize_and_pack
    0416B 940E 4202 CALL	restoreFPRegs
    0416D 9039      LD	R3,Y+
    0416E 9029      LD	R2,Y+
    0416F 9019      LD	R1,Y+
    04170 9009      LD	R0,Y+
    04171 9508      RET
    04172 EF0F      LDI	R16,0xFF
    04173 2F10      MOV	R17,R16
    04174 E72F      LDI	R18,0x7F
    04175 E73F      LDI	R19,0x7F
    04176 2066      TST	R6
    04177 F399      BEQ	0x416B
    04178 940E 3FBA CALL	neg32
    0417A CFF0      RJMP	0x416B
    0417B 2700      CLR	R16
    0417C 2F10      MOV	R17,R16
    0417D 2F20      MOV	R18,R16
    0417E 2F30      MOV	R19,R16
    0417F CFEB      RJMP	0x416B
    04180 9109      LD	R16,Y+
    04181 9119      LD	R17,Y+
    04182 9129      LD	R18,Y+
    04183 9139      LD	R19,Y+
    04184 CFED      RJMP	0x4172
unpacks:
    04185 D00F      RCALL	unpacku
    04186 F029      BEQ	0x418C
    04187 2066      TST	R6
    04188 F011      BEQ	0x418B
    04189 940E 3FBA CALL	neg32
    0418B 9498      BCLR	1
    0418C 9508      RET
tstR16_R19:
    0418D 2300      TST	R16
    0418E F429      BNE	0x4194
    0418F 2311      TST	R17
    04190 F419      BNE	0x4194
    04191 2322      TST	R18
    04192 F409      BNE	0x4194
    04193 2333      TST	R19
    04194 9508      RET
unpacku:
    04195 DFF7      RCALL	tstR16_R19
    04196 F099      BEQ	0x41AA
    04197 938A      ST	-Y,R24
    04198 2E63      MOV	R6,R19
    04199 E880      LDI	R24,0x80
    0419A 2268      AND	R6,R24
    0419B 0F22      LSL	R18
    0419C 1F33      ROL	R19
    0419D 2E43      MOV	R4,R19
    0419E E78F      LDI	R24,0x7F
    0419F 1A48      SUB	R4,R24
    041A0 2455      CLR	R5
    041A1 2788      CLR	R24
    041A2 0A58      SBC	R5,R24
    041A3 9526      LSR	R18
    041A4 E830      LDI	R19,0x80
    041A5 2B23      OR	R18,R19
    041A6 2733      CLR	R19
    041A7 9189      LD	R24,Y+
    041A8 9498      BCLR	1
    041A9 9508      RET
    041AA 2444      CLR	R4
    041AB 2455      CLR	R5
    041AC 2466      CLR	R6
    041AD 9508      RET
normalize_and_pack:
    041AE DFDE      RCALL	tstR16_R19
    041AF F409      BNE	0x41B1
    041B0 9508      RET
    041B1 93AA      ST	-Y,R26
    041B2 93BA      ST	-Y,R27
    041B3 01D2      MOVW	R26,R4
    041B4 939A      ST	-Y,R25
    041B5 938A      ST	-Y,R24
    041B6 E78E      LDI	R24,0x7E
    041B7 E090      LDI	R25,0
    041B8 2333      TST	R19
    041B9 F049      BEQ	0x41C3
    041BA 9536      LSR	R19
    041BB 9527      ROR	R18
    041BC 9517      ROR	R17
    041BD 9507      ROR	R16
    041BE 17A8      CP	R26,R24
    041BF 07B9      CPC	R27,R25
    041C0 F4CC      BGE	0x41DA
    041C1 9611      ADIW	R26,1
    041C2 CFF5      RJMP	0x41B8
    041C3 9580      COM	R24
    041C4 9590      COM	R25
    041C5 9601      ADIW	R24,1
    041C6 2322      TST	R18
    041C7 F0BA      BMI	0x41DF
    041C8 0F00      LSL	R16
    041C9 1F11      ROL	R17
    041CA 1F22      ROL	R18
    041CB 17A8      CP	R26,R24
    041CC 07B9      CPC	R27,R25
    041CD F014      BLT	0x41D0
    041CE 9711      SBIW	R26,1
    041CF CFF6      RJMP	0x41C6
    041D0 2700      CLR	R16
    041D1 2711      CLR	R17
    041D2 2722      CLR	R18
    041D3 2733      CLR	R19
    041D4 9189      LD	R24,Y+
    041D5 9199      LD	R25,Y+
    041D6 012D      MOVW	R4,R26
    041D7 91B9      LD	R27,Y+
    041D8 91A9      LD	R26,Y+
    041D9 9508      RET
    041DA 2733      CLR	R19
    041DB EF0F      LDI	R16,0xFF
    041DC 2F10      MOV	R17,R16
    041DD E72F      LDI	R18,0x7F
    041DE 2F32      MOV	R19,R18
    041DF 9189      LD	R24,Y+
    041E0 9199      LD	R25,Y+
    041E1 012D      MOVW	R4,R26
    041E2 C002      RJMP	0x41E5
pack:
    041E3 93AA      ST	-Y,R26
    041E4 93BA      ST	-Y,R27
    041E5 DFA7      RCALL	tstR16_R19
    041E6 F049      BEQ	0x41F0
    041E7 01D2      MOVW	R26,R4
    041E8 58A1      SUBI	R26,0x81
    041E9 4FBF      SBCI	R27,0xFF
    041EA 012D      MOVW	R4,R26
    041EB 2D34      MOV	R19,R4
    041EC 0F22      LSL	R18
    041ED 9536      LSR	R19
    041EE 9527      ROR	R18
    041EF 2936      OR	R19,R6
    041F0 91B9      LD	R27,Y+
    041F1 91A9      LD	R26,Y+
    041F2 9508      RET
saveFPRegs:
    041F3 924A      ST	-Y,R4
    041F4 925A      ST	-Y,R5
    041F5 926A      ST	-Y,R6
    041F6 927A      ST	-Y,R7
    041F7 928A      ST	-Y,R8
    041F8 929A      ST	-Y,R9
    041F9 92AA      ST	-Y,R10
    041FA 92BA      ST	-Y,R11
    041FB 92CA      ST	-Y,R12
    041FC 92DA      ST	-Y,R13
    041FD 92EA      ST	-Y,R14
    041FE 92FA      ST	-Y,R15
    041FF 938A      ST	-Y,R24
    04200 939A      ST	-Y,R25
    04201 9508      RET
restoreFPRegs:
    04202 9199      LD	R25,Y+
    04203 9189      LD	R24,Y+
    04204 90F9      LD	R15,Y+
    04205 90E9      LD	R14,Y+
    04206 90D9      LD	R13,Y+
    04207 90C9      LD	R12,Y+
    04208 90B9      LD	R11,Y+
    04209 90A9      LD	R10,Y+
    0420A 9099      LD	R9,Y+
    0420B 9089      LD	R8,Y+
    0420C 9079      LD	R7,Y+
    0420D 9069      LD	R6,Y+
    0420E 9059      LD	R5,Y+
    0420F 9049      LD	R4,Y+
    04210 9508      RET
fpmule:
    04211 940E 41F3 CALL	saveFPRegs
    04213 93AA      ST	-Y,R26
    04214 93BA      ST	-Y,R27
    04215 940E 4195 CALL	unpacku
    04217 F1E1      BEQ	0x4254
    04218 2CE6      MOV	R14,R6
    04219 2CD5      MOV	R13,R5
    0421A 2CC4      MOV	R12,R4
    0421B 2EB3      MOV	R11,R19
    0421C 2EA2      MOV	R10,R18
    0421D 2E91      MOV	R9,R17
    0421E 2E80      MOV	R8,R16
    0421F 8100      LD	R16,Z
    04220 8111      LDD	R17,Z+1
    04221 8122      LDD	R18,Z+2
    04222 8133      LDD	R19,Z+3
    04223 940E 4195 CALL	unpacku
    04225 F171      BEQ	0x4254
    04226 246E      EOR	R6,R14
    04227 0C4C      ADD	R4,R12
    04228 1C5D      ADC	R5,R13
    04229 E880      LDI	R24,0x80
    0422A 1648      CP	R4,R24
    0422B 0653      CPC	R5,R19
    0422C F564      BGE	0x4259
    0422D E881      LDI	R24,0x81
    0422E 1648      CP	R4,R24
    0422F EF8F      LDI	R24,0xFF
    04230 0658      CPC	R5,R24
    04231 F16C      BLT	0x425F
    04232 9EA2      MUL	R10,R18
    04233 2DB1      MOV	R27,R1
    04234 2DA0      MOV	R26,R0
    04235 9E91      MUL	R9,R17
    04236 2D91      MOV	R25,R1
    04237 2D80      MOV	R24,R0
    04238 9EA0      MUL	R10,R16
    04239 0D80      ADD	R24,R0
    0423A 1D91      ADC	R25,R1
    0423B 1FA3      ADC	R26,R19
    0423C 1FB3      ADC	R27,R19
    0423D 9E82      MUL	R8,R18
    0423E 0D80      ADD	R24,R0
    0423F 1D91      ADC	R25,R1
    04240 1FA3      ADC	R26,R19
    04241 1FB3      ADC	R27,R19
    04242 9E92      MUL	R9,R18
    04243 0D90      ADD	R25,R0
    04244 1DA1      ADC	R26,R1
    04245 1FB3      ADC	R27,R19
    04246 9EA1      MUL	R10,R17
    04247 0D90      ADD	R25,R0
    04248 1DA1      ADC	R26,R1
    04249 1FB3      ADC	R27,R19
    0424A 2F2B      MOV	R18,R27
    0424B 2F1A      MOV	R17,R26
    0424C 2F09      MOV	R16,R25
    0424D 0F88      LSL	R24
    0424E 1F00      ROL	R16
    0424F 1F11      ROL	R17
    04250 1F22      ROL	R18
    04251 1F33      ROL	R19
    04252 940E 41AE CALL	normalize_and_pack
    04254 91B9      LD	R27,Y+
    04255 91A9      LD	R26,Y+
    04256 940E 4202 CALL	restoreFPRegs
    04258 9508      RET
    04259 EF0F      LDI	R16,0xFF
    0425A 2F10      MOV	R17,R16
    0425B E72F      LDI	R18,0x7F
    0425C E78F      LDI	R24,0x7F
    0425D 2E48      MOV	R4,R24
    0425E CFF5      RJMP	0x4254
    0425F 2700      CLR	R16
    04260 2F10      MOV	R17,R16
    04261 2F20      MOV	R18,R16
    04262 2F30      MOV	R19,R16
    04263 CFF0      RJMP	0x4254
fpmule1:
    04264 93FA      ST	-Y,R31
    04265 93EA      ST	-Y,R30
    04266 81EA      LDD	R30,Y+2
    04267 81FB      LDD	R31,Y+3
    04268 940E 4211 CALL	fpmule
    0426A 91E9      LD	R30,Y+
    0426B 91F9      LD	R31,Y+
    0426C 9622      ADIW	R28,2
    0426D 9508      RET
fpmule2:
    0426E 93FA      ST	-Y,R31
    0426F 93EA      ST	-Y,R30
    04270 2FEC      MOV	R30,R28
    04271 2FFD      MOV	R31,R29
    04272 9632      ADIW	R30,2
    04273 940E 4211 CALL	fpmule
    04275 91E9      LD	R30,Y+
    04276 91F9      LD	R31,Y+
    04277 9624      ADIW	R28,4
    04278 9508      RET
fpmule1x:
    04279 93FA      ST	-Y,R31
    0427A 93EA      ST	-Y,R30
    0427B 81EA      LDD	R30,Y+2
    0427C 81FB      LDD	R31,Y+3
    0427D 940E 4211 CALL	fpmule
    0427F 91E9      LD	R30,Y+
    04280 91F9      LD	R31,Y+
    04281 8339      STD	Y+1,R19
    04282 8328      ST	Y,R18
    04283 931A      ST	-Y,R17
    04284 930A      ST	-Y,R16
    04285 9508      RET
fpcmp:
    04286 940E 402C CALL	fpsub
    04288 2333      TST	R19
    04289 F03A      BMI	0x4291
    0428A 940E 418D CALL	tstR16_R19
    0428C F011      BEQ	0x428F
    0428D E001      LDI	R16,1
    0428E 9508      RET
    0428F 2700      CLR	R16
    04290 9508      RET
    04291 EF0F      LDI	R16,0xFF
    04292 9508      RET
fpcmp2:
    04293 93FA      ST	-Y,R31
    04294 93EA      ST	-Y,R30
    04295 2FEC      MOV	R30,R28
    04296 2FFD      MOV	R31,R29
    04297 9632      ADIW	R30,2
    04298 940E 4286 CALL	fpcmp
    0429A 91E9      LD	R30,Y+
    0429B 91F9      LD	R31,Y+
    0429C 9624      ADIW	R28,4
    0429D 2300      TST	R16
    0429E 9508      RET
_itoa:
    0429F 940E 3E28 CALL	push_arg4
    042A1 940E 3F6D CALL	push_xgsetF0FC
    042A3 01A9      MOVW	R20,R18
    042A4 84EE      LDD	R14,Y+14
    042A5 84FF      LDD	R15,Y+15
    042A6 015A      MOVW	R10,R20
    042A7 20AA      TST	R10
    042A8 F451      BNE	0x42B3
    042A9 20BB      TST	R11
    042AA F441      BNE	0x42B3
    042AB E380      LDI	R24,0x30
    042AC 85EA      LDD	R30,Y+10
    042AD 85FB      LDD	R31,Y+11
    042AE 8380      ST	Z,R24
    042AF 2422      CLR	R2
    042B0 8221      STD	Z+1,R2
    042B1 018F      MOVW	R16,R30
    042B2 C053      RJMP	0x4306
    042B3 3040      CPI	R20,0
    042B4 E0E0      LDI	R30,0
    042B5 075E      CPC	R21,R30
    042B6 F46C      BGE	0x42C4
    042B7 01C7      MOVW	R24,R14
    042B8 308A      CPI	R24,0xA
    042B9 E0E0      LDI	R30,0
    042BA 079E      CPC	R25,R30
    042BB F441      BNE	0x42C4
    042BC 24CC      CLR	R12
    042BD 94C3      INC	R12
    042BE 01C5      MOVW	R24,R10
    042BF 9580      COM	R24
    042C0 9590      COM	R25
    042C1 9601      ADIW	R24,1
    042C2 015C      MOVW	R10,R24
    042C3 C001      RJMP	0x42C5
    042C4 24CC      CLR	R12
    042C5 856A      LDD	R22,Y+10
    042C6 857B      LDD	R23,Y+11
    042C7 0197      MOVW	R18,R14
    042C8 0185      MOVW	R16,R10
    042C9 940E 3E57 CALL	mod16u
    042CB 01A8      MOVW	R20,R16
    042CC E089      LDI	R24,0x9
    042CD E090      LDI	R25,0
    042CE 1780      CP	R24,R16
    042CF 0791      CPC	R25,R17
    042D0 F034      BLT	0x42D7
    042D1 01CA      MOVW	R24,R20
    042D2 96C0      ADIW	R24,0x30
    042D3 01FB      MOVW	R30,R22
    042D4 9381      ST	Z+,R24
    042D5 01BF      MOVW	R22,R30
    042D6 C006      RJMP	0x42DD
    042D7 01CA      MOVW	R24,R20
    042D8 5A89      SUBI	R24,0xA9
    042D9 4F9F      SBCI	R25,0xFF
    042DA 01FB      MOVW	R30,R22
    042DB 9381      ST	Z+,R24
    042DC 01BF      MOVW	R22,R30
    042DD 0197      MOVW	R18,R14
    042DE 0185      MOVW	R16,R10
    042DF 940E 3E59 CALL	div16u
    042E1 0158      MOVW	R10,R16
    042E2 20AA      TST	R10
    042E3 F719      BNE	0x42C7
    042E4 20BB      TST	R11
    042E5 F709      BNE	0x42C7
    042E6 20CC      TST	R12
    042E7 F021      BEQ	0x42EC
    042E8 E28D      LDI	R24,0x2D
    042E9 01FB      MOVW	R30,R22
    042EA 9381      ST	Z+,R24
    042EB 01BF      MOVW	R22,R30
    042EC 012B      MOVW	R4,R22
    042ED 5061      SUBI	R22,1
    042EE 4070      SBCI	R23,0
    042EF 2422      CLR	R2
    042F0 01F2      MOVW	R30,R4
    042F1 8220      ST	Z,R2
    042F2 84AA      LDD	R10,Y+10
    042F3 84BB      LDD	R11,Y+11
    042F4 C00C      RJMP	0x4301
    042F5 01F5      MOVW	R30,R10
    042F6 80C0      LD	R12,Z
    042F7 01FB      MOVW	R30,R22
    042F8 8020      LD	R2,Z
    042F9 01F5      MOVW	R30,R10
    042FA 9221      ST	Z+,R2
    042FB 015F      MOVW	R10,R30
    042FC 011B      MOVW	R2,R22
    042FD 5061      SUBI	R22,1
    042FE 4070      SBCI	R23,0
    042FF 01F1      MOVW	R30,R2
    04300 82C0      ST	Z,R12
    04301 16A6      CP	R10,R22
    04302 06B7      CPC	R11,R23
    04303 F388      BCS	0x42F5
    04304 850A      LDD	R16,Y+10
    04305 851B      LDD	R17,Y+11
    04306 940E 3F62 CALL	pop_xgsetF0FC
    04308 9624      ADIW	R28,4
    04309 9508      RET
_ltoa:
    0430A 940E 3E28 CALL	push_arg4
    0430C 940E 3F6D CALL	push_xgsetF0FC
    0430E 9724      SBIW	R28,4
    0430F 8828      LDD	R2,Y+16
    04310 8839      LDD	R3,Y+17
    04311 884A      LDD	R4,Y+18
    04312 885B      LDD	R5,Y+19
    04313 8228      ST	Y,R2
    04314 8239      STD	Y+1,R3
    04315 824A      STD	Y+2,R4
    04316 825B      STD	Y+3,R5
    04317 8828      LDD	R2,Y+16
    04318 8839      LDD	R3,Y+17
    04319 884A      LDD	R4,Y+18
    0431A 885B      LDD	R5,Y+19
    0431B 9488      BCLR	0
    0431C 2022      TST	R2
    0431D 0432      CPC	R3,R2
    0431E 0442      CPC	R4,R2
    0431F 0452      CPC	R5,R2
    04320 F441      BNE	0x4329
    04321 E380      LDI	R24,0x30
    04322 85EE      LDD	R30,Y+14
    04323 85FF      LDD	R31,Y+15
    04324 8380      ST	Z,R24
    04325 2422      CLR	R2
    04326 8221      STD	Z+1,R2
    04327 018F      MOVW	R16,R30
    04328 C094      RJMP	0x43BD
    04329 E040      LDI	R20,0
    0432A E050      LDI	R21,0
    0432B E060      LDI	R22,0
    0432C E070      LDI	R23,0
    0432D 8828      LDD	R2,Y+16
    0432E 8839      LDD	R3,Y+17
    0432F 884A      LDD	R4,Y+18
    04330 885B      LDD	R5,Y+19
    04331 1624      CP	R2,R20
    04332 0635      CPC	R3,R21
    04333 0646      CPC	R4,R22
    04334 0657      CPC	R5,R23
    04335 F4EC      BGE	0x4353
    04336 898C      LDD	R24,Y+20
    04337 899D      LDD	R25,Y+21
    04338 308A      CPI	R24,0xA
    04339 E0A0      LDI	R26,0
    0433A 079A      CPC	R25,R26
    0433B F4B9      BNE	0x4353
    0433C 24AA      CLR	R10
    0433D 94A3      INC	R10
    0433E E041      LDI	R20,1
    0433F E050      LDI	R21,0
    04340 E060      LDI	R22,0
    04341 E070      LDI	R23,0
    04342 8028      LD	R2,Y
    04343 8039      LDD	R3,Y+1
    04344 804A      LDD	R4,Y+2
    04345 805B      LDD	R5,Y+3
    04346 9420      COM	R2
    04347 9430      COM	R3
    04348 9440      COM	R4
    04349 9450      COM	R5
    0434A 0E24      ADD	R2,R20
    0434B 1E35      ADC	R3,R21
    0434C 1E46      ADC	R4,R22
    0434D 1E57      ADC	R5,R23
    0434E 8228      ST	Y,R2
    0434F 8239      STD	Y+1,R3
    04350 824A      STD	Y+2,R4
    04351 825B      STD	Y+3,R5
    04352 C001      RJMP	0x4354
    04353 24AA      CLR	R10
    04354 84CE      LDD	R12,Y+14
    04355 84DF      LDD	R13,Y+15
    04356 882C      LDD	R2,Y+20
    04357 883D      LDD	R3,Y+21
    04358 2444      CLR	R4
    04359 FC37      SBRC	R3,7
    0435A 9440      COM	R4
    0435B 2455      CLR	R5
    0435C FC47      SBRC	R4,7
    0435D 9450      COM	R5
    0435E 8108      LD	R16,Y
    0435F 8119      LDD	R17,Y+1
    04360 812A      LDD	R18,Y+2
    04361 813B      LDD	R19,Y+3
    04362 925A      ST	-Y,R5
    04363 924A      ST	-Y,R4
    04364 923A      ST	-Y,R3
    04365 922A      ST	-Y,R2
    04366 940E 3E75 CALL	mod32u
    04368 0178      MOVW	R14,R16
    04369 E089      LDI	R24,0x9
    0436A E090      LDI	R25,0
    0436B 1780      CP	R24,R16
    0436C 0791      CPC	R25,R17
    0436D F034      BLT	0x4374
    0436E 01C7      MOVW	R24,R14
    0436F 96C0      ADIW	R24,0x30
    04370 01F6      MOVW	R30,R12
    04371 9381      ST	Z+,R24
    04372 016F      MOVW	R12,R30
    04373 C006      RJMP	0x437A
    04374 01C7      MOVW	R24,R14
    04375 5A89      SUBI	R24,0xA9
    04376 4F9F      SBCI	R25,0xFF
    04377 01F6      MOVW	R30,R12
    04378 9381      ST	Z+,R24
    04379 016F      MOVW	R12,R30
    0437A 882C      LDD	R2,Y+20
    0437B 883D      LDD	R3,Y+21
    0437C 2444      CLR	R4
    0437D FC37      SBRC	R3,7
    0437E 9440      COM	R4
    0437F 2455      CLR	R5
    04380 FC47      SBRC	R4,7
    04381 9450      COM	R5
    04382 8108      LD	R16,Y
    04383 8119      LDD	R17,Y+1
    04384 812A      LDD	R18,Y+2
    04385 813B      LDD	R19,Y+3
    04386 925A      ST	-Y,R5
    04387 924A      ST	-Y,R4
    04388 923A      ST	-Y,R3
    04389 922A      ST	-Y,R2
    0438A 940E 3E73 CALL	div32u
    0438C 8308      ST	Y,R16
    0438D 8319      STD	Y+1,R17
    0438E 832A      STD	Y+2,R18
    0438F 833B      STD	Y+3,R19
    04390 8028      LD	R2,Y
    04391 8039      LDD	R3,Y+1
    04392 804A      LDD	R4,Y+2
    04393 805B      LDD	R5,Y+3
    04394 9488      BCLR	0
    04395 2022      TST	R2
    04396 0432      CPC	R3,R2
    04397 0442      CPC	R4,R2
    04398 0452      CPC	R5,R2
    04399 F009      BEQ	0x439B
    0439A CFBB      RJMP	0x4356
    0439B 20AA      TST	R10
    0439C F021      BEQ	0x43A1
    0439D E28D      LDI	R24,0x2D
    0439E 01F6      MOVW	R30,R12
    0439F 9381      ST	Z+,R24
    043A0 016F      MOVW	R12,R30
    043A1 0126      MOVW	R4,R12
    043A2 01C2      MOVW	R24,R4
    043A3 9701      SBIW	R24,1
    043A4 016C      MOVW	R12,R24
    043A5 2422      CLR	R2
    043A6 01F2      MOVW	R30,R4
    043A7 8220      ST	Z,R2
    043A8 84EE      LDD	R14,Y+14
    043A9 84FF      LDD	R15,Y+15
    043AA C00D      RJMP	0x43B8
    043AB 01F7      MOVW	R30,R14
    043AC 80A0      LD	R10,Z
    043AD 01F6      MOVW	R30,R12
    043AE 8020      LD	R2,Z
    043AF 01F7      MOVW	R30,R14
    043B0 9221      ST	Z+,R2
    043B1 017F      MOVW	R14,R30
    043B2 0116      MOVW	R2,R12
    043B3 01C1      MOVW	R24,R2
    043B4 9701      SBIW	R24,1
    043B5 016C      MOVW	R12,R24
    043B6 01F1      MOVW	R30,R2
    043B7 82A0      ST	Z,R10
    043B8 14EC      CP	R14,R12
    043B9 04FD      CPC	R15,R13
    043BA F380      BCS	0x43AB
    043BB 850E      LDD	R16,Y+14
    043BC 851F      LDD	R17,Y+15
    043BD 9624      ADIW	R28,4
    043BE 940E 3F62 CALL	pop_xgsetF0FC
    043C0 9624      ADIW	R28,4
    043C1 9508      RET
_ftoa:
    043C2 940E 3E28 CALL	push_arg4
    043C4 940E 3F6D CALL	push_xgsetF0FC
    043C6 9764      SBIW	R28,0x14
    043C7 A0CA      LDD	R12,Y+34
    043C8 A0DB      LDD	R13,Y+35
    043C9 2422      CLR	R2
    043CA 2433      CLR	R3
    043CB 01F6      MOVW	R30,R12
    043CC 8231      STD	Z+1,R3
    043CD 8220      ST	Z,R2
    043CE 8C2E      LDD	R2,Y+30
    043CF 8C3F      LDD	R3,Y+31
    043D0 A048      LDD	R4,Y+32
    043D1 A059      LDD	R5,Y+33
    043D2 EC0C      LDI	R16,0xCC
    043D3 E010      LDI	R17,0
    043D4 940E 3EF5 CALL	elpm32
    043D6 933A      ST	-Y,R19
    043D7 932A      ST	-Y,R18
    043D8 931A      ST	-Y,R17
    043D9 930A      ST	-Y,R16
    043DA 0181      MOVW	R16,R2
    043DB 0192      MOVW	R18,R4
    043DC 940E 4293 CALL	fpcmp2
    043DE F479      BNE	0x43EE
    043DF E380      LDI	R24,0x30
    043E0 9380 07C3 STS	config+17,R24
    043E2 E28E      LDI	R24,0x2E
    043E3 9380 07C4 STS	config+18,R24
    043E5 E380      LDI	R24,0x30
    043E6 9380 07C5 STS	config+19,R24
    043E8 2422      CLR	R2
    043E9 9220 07C6 STS	config+20,R2
    043EB EC03      LDI	R16,0xC3
    043EC E017      LDI	R17,7
    043ED C15E      RJMP	0x454C
    043EE 8C2E      LDD	R2,Y+30
    043EF 8C3F      LDD	R3,Y+31
    043F0 A048      LDD	R4,Y+32
    043F1 A059      LDD	R5,Y+33
    043F2 8628      STD	Y+8,R2
    043F3 8639      STD	Y+9,R3
    043F4 864A      STD	Y+10,R4
    043F5 865B      STD	Y+11,R5
    043F6 E187      LDI	R24,0x17
    043F7 E090      LDI	R25,0
    043F8 8508      LDD	R16,Y+8
    043F9 8519      LDD	R17,Y+9
    043FA 852A      LDD	R18,Y+10
    043FB 853B      LDD	R19,Y+11
    043FC 938A      ST	-Y,R24
    043FD 940E 3E2D CALL	asr32
    043FF 2F80      MOV	R24,R16
    04400 2799      CLR	R25
    04401 578F      SUBI	R24,0x7F
    04402 4090      SBCI	R25,0
    04403 015C      MOVW	R10,R24
    04404 EF4F      LDI	R20,0xFF
    04405 EF5F      LDI	R21,0xFF
    04406 EF6F      LDI	R22,0xFF
    04407 E070      LDI	R23,0
    04408 8428      LDD	R2,Y+8
    04409 8439      LDD	R3,Y+9
    0440A 844A      LDD	R4,Y+10
    0440B 845B      LDD	R5,Y+11
    0440C 2224      AND	R2,R20
    0440D 2235      AND	R3,R21
    0440E 2246      AND	R4,R22
    0440F 2257      AND	R5,R23
    04410 93EF      PUSH	R30
    04411 2DE4      MOV	R30,R4
    04412 68E0      ORI	R30,0x80
    04413 2E4E      MOV	R4,R30
    04414 91EF      POP	R30
    04415 8A28      STD	Y+16,R2
    04416 8A39      STD	Y+17,R3
    04417 8A4A      STD	Y+18,R4
    04418 8A5B      STD	Y+19,R5
    04419 E080      LDI	R24,0
    0441A 838C      STD	Y+4,R24
    0441B 838D      STD	Y+5,R24
    0441C 838E      STD	Y+6,R24
    0441D 838F      STD	Y+7,R24
    0441E E080      LDI	R24,0
    0441F 878C      STD	Y+12,R24
    04420 878D      STD	Y+13,R24
    04421 878E      STD	Y+14,R24
    04422 878F      STD	Y+15,R24
    04423 01C5      MOVW	R24,R10
    04424 318F      CPI	R24,0x1F
    04425 E0E0      LDI	R30,0
    04426 079E      CPC	R25,R30
    04427 F044      BLT	0x4430
    04428 EF8E      LDI	R24,0xFE
    04429 EF9F      LDI	R25,0xFF
    0442A 01F6      MOVW	R30,R12
    0442B 8391      STD	Z+1,R25
    0442C 8380      ST	Z,R24
    0442D 2700      CLR	R16
    0442E 2711      CLR	R17
    0442F C11C      RJMP	0x454C
    04430 01C5      MOVW	R24,R10
    04431 3E89      CPI	R24,0xE9
    04432 EFEF      LDI	R30,0xFF
    04433 079E      CPC	R25,R30
    04434 F444      BGE	0x443D
    04435 EF8F      LDI	R24,0xFF
    04436 EF9F      LDI	R25,0xFF
    04437 01F6      MOVW	R30,R12
    04438 8391      STD	Z+1,R25
    04439 8380      ST	Z,R24
    0443A 2700      CLR	R16
    0443B 2711      CLR	R17
    0443C C10F      RJMP	0x454C
    0443D 01C5      MOVW	R24,R10
    0443E 3187      CPI	R24,0x17
    0443F E0A0      LDI	R26,0
    04440 079A      CPC	R25,R26
    04441 F06C      BLT	0x444F
    04442 9747      SBIW	R24,0x17
    04443 8908      LDD	R16,Y+16
    04444 8919      LDD	R17,Y+17
    04445 892A      LDD	R18,Y+18
    04446 893B      LDD	R19,Y+19
    04447 938A      ST	-Y,R24
    04448 940E 3FEF CALL	lsl32
    0444A 870C      STD	Y+12,R16
    0444B 871D      STD	Y+13,R17
    0444C 872E      STD	Y+14,R18
    0444D 873F      STD	Y+15,R19
    0444E C045      RJMP	0x4494
    0444F 01C5      MOVW	R24,R10
    04450 3080      CPI	R24,0
    04451 E0A0      LDI	R26,0
    04452 079A      CPC	R25,R26
    04453 F13C      BLT	0x447B
    04454 E187      LDI	R24,0x17
    04455 E090      LDI	R25,0
    04456 198A      SUB	R24,R10
    04457 099B      SBC	R25,R11
    04458 8908      LDD	R16,Y+16
    04459 8919      LDD	R17,Y+17
    0445A 892A      LDD	R18,Y+18
    0445B 893B      LDD	R19,Y+19
    0445C 938A      ST	-Y,R24
    0445D 940E 3E2D CALL	asr32
    0445F 870C      STD	Y+12,R16
    04460 871D      STD	Y+13,R17
    04461 872E      STD	Y+14,R18
    04462 873F      STD	Y+15,R19
    04463 01C5      MOVW	R24,R10
    04464 9601      ADIW	R24,1
    04465 8908      LDD	R16,Y+16
    04466 8919      LDD	R17,Y+17
    04467 892A      LDD	R18,Y+18
    04468 893B      LDD	R19,Y+19
    04469 938A      ST	-Y,R24
    0446A 940E 3FEF CALL	lsl32
    0446C 0118      MOVW	R2,R16
    0446D 0129      MOVW	R4,R18
    0446E EF4F      LDI	R20,0xFF
    0446F EF5F      LDI	R21,0xFF
    04470 EF6F      LDI	R22,0xFF
    04471 E070      LDI	R23,0
    04472 2224      AND	R2,R20
    04473 2235      AND	R3,R21
    04474 2246      AND	R4,R22
    04475 2257      AND	R5,R23
    04476 822C      STD	Y+4,R2
    04477 823D      STD	Y+5,R3
    04478 824E      STD	Y+6,R4
    04479 825F      STD	Y+7,R5
    0447A C019      RJMP	0x4494
    0447B EF4F      LDI	R20,0xFF
    0447C EF5F      LDI	R21,0xFF
    0447D EF6F      LDI	R22,0xFF
    0447E E070      LDI	R23,0
    0447F 8908      LDD	R16,Y+16
    04480 8919      LDD	R17,Y+17
    04481 892A      LDD	R18,Y+18
    04482 893B      LDD	R19,Y+19
    04483 2304      AND	R16,R20
    04484 2315      AND	R17,R21
    04485 2326      AND	R18,R22
    04486 2337      AND	R19,R23
    04487 01C5      MOVW	R24,R10
    04488 9601      ADIW	R24,1
    04489 9580      COM	R24
    0448A 9590      COM	R25
    0448B 5F8F      SUBI	R24,0xFF
    0448C 4F9F      SBCI	R25,0xFF
    0448D 938A      ST	-Y,R24
    0448E 940E 3E2D CALL	asr32
    04490 830C      STD	Y+4,R16
    04491 831D      STD	Y+5,R17
    04492 832E      STD	Y+6,R18
    04493 833F      STD	Y+7,R19
    04494 EC83      LDI	R24,0xC3
    04495 E097      LDI	R25,7
    04496 015C      MOVW	R10,R24
    04497 E040      LDI	R20,0
    04498 E050      LDI	R21,0
    04499 E060      LDI	R22,0
    0449A E070      LDI	R23,0
    0449B 8428      LDD	R2,Y+8
    0449C 8439      LDD	R3,Y+9
    0449D 844A      LDD	R4,Y+10
    0449E 845B      LDD	R5,Y+11
    0449F 1624      CP	R2,R20
    044A0 0635      CPC	R3,R21
    044A1 0646      CPC	R4,R22
    044A2 0657      CPC	R5,R23
    044A3 F424      BGE	0x44A8
    044A4 E28D      LDI	R24,0x2D
    044A5 01F5      MOVW	R30,R10
    044A6 9381      ST	Z+,R24
    044A7 015F      MOVW	R10,R30
    044A8 842C      LDD	R2,Y+12
    044A9 843D      LDD	R3,Y+13
    044AA 844E      LDD	R4,Y+14
    044AB 845F      LDD	R5,Y+15
    044AC 9488      BCLR	0
    044AD 2022      TST	R2
    044AE 0432      CPC	R3,R2
    044AF 0442      CPC	R4,R2
    044B0 0452      CPC	R5,R2
    044B1 F429      BNE	0x44B7
    044B2 E380      LDI	R24,0x30
    044B3 01F5      MOVW	R30,R10
    044B4 9381      ST	Z+,R24
    044B5 015F      MOVW	R10,R30
    044B6 C016      RJMP	0x44CD
    044B7 E08A      LDI	R24,0xA
    044B8 E090      LDI	R25,0
    044B9 839B      STD	Y+3,R25
    044BA 838A      STD	Y+2,R24
    044BB 842C      LDD	R2,Y+12
    044BC 843D      LDD	R3,Y+13
    044BD 844E      LDD	R4,Y+14
    044BE 845F      LDD	R5,Y+15
    044BF 8248      ST	Y,R4
    044C0 8259      STD	Y+1,R5
    044C1 0191      MOVW	R18,R2
    044C2 0185      MOVW	R16,R10
    044C3 940E 430A CALL	_ltoa
    044C5 C003      RJMP	0x44C9
    044C6 01C5      MOVW	R24,R10
    044C7 9601      ADIW	R24,1
    044C8 015C      MOVW	R10,R24
    044C9 01F5      MOVW	R30,R10
    044CA 8020      LD	R2,Z
    044CB 2022      TST	R2
    044CC F7C9      BNE	0x44C6
    044CD E28E      LDI	R24,0x2E
    044CE 01F5      MOVW	R30,R10
    044CF 9381      ST	Z+,R24
    044D0 015F      MOVW	R10,R30
    044D1 802C      LDD	R2,Y+4
    044D2 803D      LDD	R3,Y+5
    044D3 804E      LDD	R4,Y+6
    044D4 805F      LDD	R5,Y+7
    044D5 9488      BCLR	0
    044D6 2022      TST	R2
    044D7 0432      CPC	R3,R2
    044D8 0442      CPC	R4,R2
    044D9 0452      CPC	R5,R2
    044DA F421      BNE	0x44DF
    044DB E380      LDI	R24,0x30
    044DC 9381      ST	Z+,R24
    044DD 015F      MOVW	R10,R30
    044DE C068      RJMP	0x4547
    044DF EC83      LDI	R24,0xC3
    044E0 E097      LDI	R25,7
    044E1 0115      MOVW	R2,R10
    044E2 1A28      SUB	R2,R24
    044E3 0A39      SBC	R3,R25
    044E4 E08F      LDI	R24,0xF
    044E5 E090      LDI	R25,0
    044E6 1982      SUB	R24,R2
    044E7 0993      SBC	R25,R3
    044E8 9701      SBIW	R24,1
    044E9 2EC8      MOV	R12,R24
    044EA E087      LDI	R24,7
    044EB 158C      CP	R24,R12
    044EC F408      BCC	0x44EE
    044ED 2EC8      MOV	R12,R24
    044EE 24EE      CLR	R14
    044EF C042      RJMP	0x4532
    044F0 E083      LDI	R24,3
    044F1 E090      LDI	R25,0
    044F2 810C      LDD	R16,Y+4
    044F3 811D      LDD	R17,Y+5
    044F4 812E      LDD	R18,Y+6
    044F5 813F      LDD	R19,Y+7
    044F6 938A      ST	-Y,R24
    044F7 940E 3FEF CALL	lsl32
    044F9 0118      MOVW	R2,R16
    044FA 0129      MOVW	R4,R18
    044FB 806C      LDD	R6,Y+4
    044FC 807D      LDD	R7,Y+5
    044FD 808E      LDD	R8,Y+6
    044FE 809F      LDD	R9,Y+7
    044FF 0C66      LSL	R6
    04500 1C77      ROL	R7
    04501 1C88      ROL	R8
    04502 1C99      ROL	R9
    04503 0C26      ADD	R2,R6
    04504 1C37      ADC	R3,R7
    04505 1C48      ADC	R4,R8
    04506 1C59      ADC	R5,R9
    04507 822C      STD	Y+4,R2
    04508 823D      STD	Y+5,R3
    04509 824E      STD	Y+6,R4
    0450A 825F      STD	Y+7,R5
    0450B E188      LDI	R24,0x18
    0450C E090      LDI	R25,0
    0450D 810C      LDD	R16,Y+4
    0450E 811D      LDD	R17,Y+5
    0450F 812E      LDD	R18,Y+6
    04510 813F      LDD	R19,Y+7
    04511 938A      ST	-Y,R24
    04512 940E 3E2D CALL	asr32
    04514 0118      MOVW	R2,R16
    04515 0129      MOVW	R4,R18
    04516 E340      LDI	R20,0x30
    04517 E050      LDI	R21,0
    04518 E060      LDI	R22,0
    04519 E070      LDI	R23,0
    0451A 0E24      ADD	R2,R20
    0451B 1E35      ADC	R3,R21
    0451C 1E46      ADC	R4,R22
    0451D 1E57      ADC	R5,R23
    0451E 01F5      MOVW	R30,R10
    0451F 9221      ST	Z+,R2
    04520 015F      MOVW	R10,R30
    04521 EF4F      LDI	R20,0xFF
    04522 EF5F      LDI	R21,0xFF
    04523 EF6F      LDI	R22,0xFF
    04524 E070      LDI	R23,0
    04525 802C      LDD	R2,Y+4
    04526 803D      LDD	R3,Y+5
    04527 804E      LDD	R4,Y+6
    04528 805F      LDD	R5,Y+7
    04529 2224      AND	R2,R20
    0452A 2235      AND	R3,R21
    0452B 2246      AND	R4,R22
    0452C 2257      AND	R5,R23
    0452D 822C      STD	Y+4,R2
    0452E 823D      STD	Y+5,R3
    0452F 824E      STD	Y+6,R4
    04530 825F      STD	Y+7,R5
    04531 94E3      INC	R14
    04532 14EC      CP	R14,R12
    04533 F408      BCC	0x4535
    04534 CFBB      RJMP	0x44F0
    04535 01C5      MOVW	R24,R10
    04536 9701      SBIW	R24,1
    04537 015C      MOVW	R10,R24
    04538 C003      RJMP	0x453C
    04539 01C5      MOVW	R24,R10
    0453A 9701      SBIW	R24,1
    0453B 015C      MOVW	R10,R24
    0453C 01F5      MOVW	R30,R10
    0453D 8180      LD	R24,Z
    0453E 3380      CPI	R24,0x30
    0453F F421      BNE	0x4544
    04540 9731      SBIW	R30,1
    04541 8180      LD	R24,Z
    04542 328E      CPI	R24,0x2E
    04543 F7A9      BNE	0x4539
    04544 01C5      MOVW	R24,R10
    04545 9601      ADIW	R24,1
    04546 015C      MOVW	R10,R24
    04547 2422      CLR	R2
    04548 01F5      MOVW	R30,R10
    04549 8220      ST	Z,R2
    0454A EC03      LDI	R16,0xC3
    0454B E017      LDI	R17,7
    0454C 9664      ADIW	R28,0x14
    0454D 940E 3F62 CALL	pop_xgsetF0FC
    0454F 9624      ADIW	R28,4
    04550 9508      RET
