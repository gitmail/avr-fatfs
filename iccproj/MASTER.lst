Interrupt Vectors
    00000 940C 026E JMP	__start|__text_start
    0003C 940C 3767 JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    0026E EFCF      LDI	R28,0xFF
    0026F E1D0      LDI	R29,0x10
    00270 BFCD      OUT	0x3D,R28
    00271 BFDE      OUT	0x3E,R29
    00272 51CE      SUBI	R28,0x1E
    00273 40D0      SBCI	R29,0
    00274 EA0A      LDI	R16,0xAA
    00275 8308      ST	Y,R16
    00276 2400      CLR	R0
    00277 E0EB      LDI	R30,0xB
    00278 E0F5      LDI	R31,5
    00279 E017      LDI	R17,7
    0027A 3FE2      CPI	R30,0xF2
    0027B 07F1      CPC	R31,R17
    0027C F011      BEQ	0x027F
    0027D 9201      ST	Z+,R0
    0027E CFFB      RJMP	0x027A
    0027F 8300      ST	Z,R16
    00280 EDE0      LDI	R30,0xD0
    00281 E0F0      LDI	R31,0
    00282 E0A0      LDI	R26,0
    00283 E0B1      LDI	R27,1
    00284 E014      LDI	R17,4
    00285 E000      LDI	R16,0
    00286 BF0B      OUT	0x3B,R16
    00287 3DEB      CPI	R30,0xDB
    00288 07F1      CPC	R31,R17
    00289 F021      BEQ	0x028E
    0028A 95C8      LPM
    0028B 9631      ADIW	R30,1
    0028C 920D      ST	X+,R0
    0028D CFF9      RJMP	0x0287
    0028E 940E 245F CALL	_main
_exit:
    00290 CFFF      RJMP	_exit
_disk_initialize:
  state                --> R20
  drv                  --> R10
    00291 92AA      ST	-Y,R10
    00292 934A      ST	-Y,R20
    00293 2EA0      MOV	R10,R16
FILE: D:\LQD\software\master\software_src\diskio.c
(0001) 
(0002) 
(0003) /*-----------------------------------------------------------------------*/
(0004) /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
(0005) /*-----------------------------------------------------------------------*/
(0006) /* This is a stub disk I/O module that acts as front end of the existing */
(0007) /* disk I/O modules and attach it to FatFs module with common interface. */
(0008) /*-----------------------------------------------------------------------*/
(0009) 
(0010) #include "diskio.h"
(0011) #include "sd.h"
(0012) 
(0013) 
(0014) /*-----------------------------------------------------------------------*/
(0015) /* Correspondence between physical drive number and physical drive.      */
(0016) /* Note that Tiny-FatFs supports only single drive and always            */
(0017)                                       
(0018) 
(0019) ////////////////////////////
(0020) /*
(0021)    struct tm {
(0022)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0023)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0024) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0025) 	int tm_mday;  // 日 day of the month, 1 to 31
(0026) 	int tm_mon;   // 月 months since January, 0 to 11
(0027) 	int tm_year;  // 年 years since 1900
(0028) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0029) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0030)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0031)  	};
(0032) */
(0033) /*-----------------------------------------------------------------------*/
(0034) /* Inidialize a Drive                                                    */
(0035) 
(0036) DSTATUS disk_initialize ( 
(0037) BYTE drv				/* Physical drive nmuber (0..) */
(0038) )
(0039) {
(0040)     unsigned char state;
(0041) 
(0042)     if(drv)
    00294 20AA      TST	R10
    00295 F011      BEQ	0x0298
(0043)     {
(0044)         return STA_NOINIT;  //仅支持磁盘0的操作
    00296 E001      LDI	R16,1
    00297 C00C      RJMP	0x02A4
(0045)     }
(0046) 
(0047)     state = SD_Init();
    00298 940E 2B6E CALL	_SD_Init
    0029A 2F40      MOV	R20,R16
(0048)     if(state == STA_NODISK)
    0029B 3002      CPI	R16,2
    0029C F411      BNE	0x029F
(0049)     {
(0050)         return STA_NODISK;
    0029D E002      LDI	R16,2
    0029E C005      RJMP	0x02A4
(0051)     }
(0052)     else if(state != 0)
    0029F 2344      TST	R20
    002A0 F011      BEQ	0x02A3
(0053)     {
(0054)         return STA_NOINIT;  //其他错误：初始化失败
    002A1 E001      LDI	R16,1
    002A2 C001      RJMP	0x02A4
(0055)     }
(0056)     else
(0057)     {
(0058)         return 0;           //初始化成功
    002A3 2700      CLR	R16
    002A4 9149      LD	R20,Y+
    002A5 90A9      LD	R10,Y+
    002A6 9508      RET
(0059)     }
(0060) }
(0061) 
(0062) 
(0063) 
(0064) /*-----------------------------------------------------------------------*/
(0065) /* Return Disk Status                                                    */
(0066) 
(0067) DSTATUS disk_status (
(0068) 	BYTE drv		/* Physical drive nmuber (0..) */
(0069) )
(0070) {
(0071)     if(drv)
_disk_status:
  drv                  --> R16
    002A7 2300      TST	R16
    002A8 F011      BEQ	0x02AB
(0072)     {
(0073)         return STA_NOINIT;  //仅支持磁盘0操作
    002A9 E001      LDI	R16,1
    002AA C001      RJMP	0x02AC
(0074)     }
(0075)     return 0;
    002AB 2700      CLR	R16
    002AC 9508      RET
_disk_read:
  res                  --> R10
  count                --> R20
  sector               --> Y,+10
  buff                 --> R12
  drv                  --> R14
    002AD 940E 4113 CALL	push_xgset30FC
    002AF 0169      MOVW	R12,R18
    002B0 2EE0      MOV	R14,R16
    002B1 9722      SBIW	R28,2
    002B2 854E      LDD	R20,Y+14
(0076) }
(0077) 
(0078) 
(0079) 
(0080) /*-----------------------------------------------------------------------*/
(0081) /* Read Sector(s)                                                        */
(0082) 
(0083) DRESULT disk_read (
(0084) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0085) 	BYTE *buff,		/* Data buffer to store read data */
(0086) 	DWORD sector,	/* Sector address (LBA) */
(0087) 	BYTE count		/* Number of sectors to read (1..255) */
(0088) )
(0089) {
(0090) 	unsigned char res=0;
    002B3 24AA      CLR	R10
(0091)     if (drv || !count)
    002B4 20EE      TST	R14
    002B5 F411      BNE	0x02B8
    002B6 2344      TST	R20
    002B7 F411      BNE	0x02BA
(0092)     {    
(0093)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002B8 E004      LDI	R16,4
    002B9 C010      RJMP	0x02CA
(0094)     }
(0095) 
(0096)     if(count==1)            //1个sector的读操作      
    002BA 3041      CPI	R20,1
    002BB F449      BNE	0x02C5
(0097)     {                                                
(0098)         res = SD_Read_Sector(sector, buff);      
    002BC 82D9      STD	Y+1,R13
    002BD 82C8      ST	Y,R12
    002BE 850A      LDD	R16,Y+10
    002BF 851B      LDD	R17,Y+11
    002C0 852C      LDD	R18,Y+12
    002C1 853D      LDD	R19,Y+13
    002C2 940E 2C54 CALL	_SD_Read_Sector
    002C4 2EA0      MOV	R10,R16
(0099)     }                                                                                                 
(0100) 
(0101)     //处理返回值，将SD_driver.c的返回值转成ff.c的返回值
(0102)     if(res == 0x00)
    002C5 20AA      TST	R10
    002C6 F411      BNE	0x02C9
(0103)     {
(0104)         return RES_OK;
    002C7 2700      CLR	R16
    002C8 C001      RJMP	0x02CA
(0105)     }
(0106)     else
(0107)     {
(0108)         return RES_ERROR;
    002C9 E001      LDI	R16,1
    002CA 9622      ADIW	R28,2
    002CB 940C 40FD JMP	pop_xgset30FC
_disk_write:
  count                --> R12
  sector               --> Y,+8
  buff                 --> R10
  drv                  --> R14
    002CD 940E 4115 CALL	push_xgset00FC
    002CF 0159      MOVW	R10,R18
    002D0 2EE0      MOV	R14,R16
    002D1 9722      SBIW	R28,2
    002D2 84CC      LDD	R12,Y+12
(0109)     }
(0110) }
(0111) 
(0112) 
(0113) 
(0114) /*-----------------------------------------------------------------------*/
(0115) /* Write Sector(s)                                                       */
(0116) 
(0117) #if _READONLY == 0
(0118) DRESULT disk_write (
(0119) 	BYTE drv,			/* Physical drive nmuber (0..) */
(0120) 	BYTE *buff,	        /* Data to be written */
(0121) 	DWORD sector,		/* Sector address (LBA) */
(0122) 	BYTE count			/* Number of sectors to write (1..255) */
(0123) )
(0124) {
(0125)     if (drv || !count)
    002D3 20EE      TST	R14
    002D4 F411      BNE	0x02D7
    002D5 20CC      TST	R12
    002D6 F411      BNE	0x02D9
(0126)     {    
(0127)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002D7 E004      LDI	R16,4
    002D8 C009      RJMP	0x02E2
(0128)     }   
(0129)    // 读写操作
(0130)     SD_Write_Sector(sector,buff);
    002D9 82B9      STD	Y+1,R11
    002DA 82A8      ST	Y,R10
    002DB 8508      LDD	R16,Y+8
    002DC 8519      LDD	R17,Y+9
    002DD 852A      LDD	R18,Y+10
    002DE 853B      LDD	R19,Y+11
    002DF 940E 2BCE CALL	_SD_Write_Sector
(0131) 	  
(0132)     return RES_OK;
    002E1 2700      CLR	R16
    002E2 9622      ADIW	R28,2
    002E3 940C 40F6 JMP	pop_xgset00FC
_disk_ioctl:
  buff                 --> Y,+4
  ctrl                 --> Y,+2
  drv                  --> Y,+0
    002E5 940E 3FCC CALL	push_arg4
(0133) }
(0134) #endif /* _READONLY */
(0135) 
(0136) 
(0137) 
(0138) /*-----------------------------------------------------------------------*/
(0139) /* Miscellaneous Functions                                               */
(0140) DRESULT disk_ioctl (
(0141) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0142) 	BYTE ctrl,		/* Control code */
(0143) 	void *buff		/* Buffer to send/receive control data */
(0144) )
(0145) {
(0146)  	drv=drv;
(0147) 	ctrl=ctrl;
(0148) 	buff=buff;
(0149) 	return 0;
    002E7 2700      CLR	R16
    002E8 9624      ADIW	R28,4
    002E9 9508      RET
(0150) }
(0151) DWORD get_fattime (void)
(0152) {
(0153) 
(0154)   return 1950466005;
_get_fattime:
    002EA ED05      LDI	R16,0xD5
    002EB EB1F      LDI	R17,0xBF
    002EC E421      LDI	R18,0x41
    002ED E734      LDI	R19,0x74
    002EE 9508      RET
ff.c:mem_cpy:
  s                    --> R12
  d                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    002EF 940E 413E CALL	push_xgset303C
    002F1 814E      LDD	R20,Y+6
    002F2 815F      LDD	R21,Y+7
FILE: D:\LQD\software\master\software_src\ff.c
(0001) /*----------------------------------------------------------------------------/
(0002) /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
(0003) /-----------------------------------------------------------------------------/
(0004) / FatFs module is a generic FAT file system module for small embedded systems.
(0005) / This is a free software that opened for education, research and commercial
(0006) / developments under license policy of following terms.
(0007) /
(0008) /  Copyright (C) 2011, ChaN, all right reserved.
(0009) /
(0010) / * The FatFs module is a free software and there is NO WARRANTY.
(0011) / * No restriction on use. You can use, modify and redistribute it for
(0012) /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
(0013) / * Redistributions of source code must retain the above copyright notice.
(0014) /
(0015) /-----------------------------------------------------------------------------/
(0016) / Feb 26,'06 R0.00  Prototype.
(0017) /
(0018) / Apr 29,'06 R0.01  First stable version.
(0019) /
(0020) / Jun 01,'06 R0.02  Added FAT12 support.
(0021) /                   Removed unbuffered mode.
(0022) /                   Fixed a problem on small (<32M) partition.
(0023) / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
(0024) /
(0025) / Sep 22,'06 R0.03  Added f_rename().
(0026) /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
(0027) / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
(0028) /                   Fixed f_mkdir() creates incorrect directory on FAT32.
(0029) /
(0030) / Feb 04,'07 R0.04  Supported multiple drive system.
(0031) /                   Changed some interfaces for multiple drive system.
(0032) /                   Changed f_mountdrv() to f_mount().
(0033) /                   Added f_mkfs().
(0034) / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
(0035) /                   Added a capability of extending file size to f_lseek().
(0036) /                   Added minimization level 3.
(0037) /                   Fixed an endian sensitive code in f_mkfs().
(0038) / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
(0039) /                   Added FSInfo support.
(0040) /                   Fixed DBCS name can result FR_INVALID_NAME.
(0041) /                   Fixed short seek (<= csize) collapses the file object.
(0042) /
(0043) / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
(0044) /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
(0045) /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
(0046) / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
(0047) /                   Fixed off by one error at FAT sub-type determination.
(0048) /                   Fixed btr in f_read() can be mistruncated.
(0049) /                   Fixed cached sector is not flushed when create and close without write.
(0050) /
(0051) / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
(0052) /                   Improved performance of f_lseek() on moving to the same or following cluster.
(0053) /
(0054) / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
(0055) /                   Added long file name feature.
(0056) /                   Added multiple code page feature.
(0057) /                   Added re-entrancy for multitask operation.
(0058) /                   Added auto cluster size selection to f_mkfs().
(0059) /                   Added rewind option to f_readdir().
(0060) /                   Changed result code of critical errors.
(0061) /                   Renamed string functions to avoid name collision.
(0062) / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
(0063) /                   Added multiple sector size feature.
(0064) / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
(0065) /                   Fixed wrong cache control in f_lseek().
(0066) /                   Added relative path feature.
(0067) /                   Added f_chdir() and f_chdrive().
(0068) /                   Added proper case conversion to extended char.
(0069) / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
(0070) /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
(0071) /                   Fixed name matching error on the 13 char boundary.
(0072) /                   Added a configuration option, _LFN_UNICODE.
(0073) /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
(0074) /
(0075) / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
(0076) /                   Added file lock feature. (_FS_SHARE)
(0077) /                   Added fast seek feature. (_USE_FASTSEEK)
(0078) /                   Changed some types on the API, XCHAR->TCHAR.
(0079) /                   Changed fname member in the FILINFO structure on Unicode cfg.
(0080) /                   String functions support UTF-8 encoding files on Unicode cfg.
(0081) / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
(0082) /                   Added sector erase feature. (_USE_ERASE)
(0083) /                   Moved file lock semaphore table from fs object to the bss.
(0084) /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
(0085) /                   Fixed f_mkfs() creates wrong FAT32 volume.
(0086) / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
(0087) /                   f_lseek() reports required table size on creating CLMP.
(0088) /                   Extended format syntax of f_printf function.
(0089) /                   Ignores duplicated directory separators in given path names.
(0090) /
(0091) / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
(0092) /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
(0093) /---------------------------------------------------------------------------*/
(0094) 
(0095) #include "ff.h"			/* FatFs configurations and declarations */
(0096) #include "diskio.h"		/* Declarations of low level disk I/O functions */
(0097) #include <string.h>
(0098) 
(0099) /*--------------------------------------------------------------------------
(0100) 
(0101)    Module Private Definitions
(0102) 
(0103) ---------------------------------------------------------------------------*/
(0104) 
(0105) #if _FATFS != 6502	/* Revision ID */
(0106) #error Wrong include file (ff.h).
(0107) #endif
(0108) 
(0109) 
(0110) /* Definitions on sector size */
(0111) #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
(0112) #error Wrong sector size.
(0113) #endif
(0114) #if _MAX_SS != 512
(0115) #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
(0116) #else
(0117) #define	SS(fs)	512U			/* Fixed sector size */
(0118) #endif
(0119) 
(0120) 
(0121) /* Reentrancy related */
(0122) #if _FS_REENTRANT
(0123) #if _USE_LFN == 1
(0124) #error Static LFN work area must not be used in re-entrant configuration.
(0125) #endif
(0126) #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
(0127) #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
(0128) #else
(0129) #define	ENTER_FF(fs)
(0130) #define LEAVE_FF(fs, res)	return res
(0131) #endif
(0132) 
(0133) #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
(0134) 
(0135) 
(0136) /* File shareing feature */
(0137) #if _FS_SHARE
(0138) #if _FS_READONLY
(0139) #error _FS_SHARE must be 0 on read-only cfg.
(0140) #endif
(0141) typedef struct {
(0142) 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
(0143) 	DWORD clu;				/* File ID 2, directory */
(0144) 	WORD idx;				/* File ID 3, directory index */
(0145) 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
(0146) } FILESEM;
(0147) #endif
(0148) 
(0149) 
(0150) /* Misc definitions */
(0151) #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
(0152) #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
(0153) 
(0154) 
(0155) /* DBCS code ranges and SBCS extend char conversion table */
(0156) 
(0157) #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
(0158) #define _DF1S	0x81	/* DBC 1st byte range 1 start */
(0159) #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
(0160) #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
(0161) #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
(0162) #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
(0163) #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
(0164) #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
(0165) #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
(0166) 
(0167) #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
(0168) #define _DF1S	0x81
(0169) #define _DF1E	0xFE
(0170) #define _DS1S	0x40
(0171) #define _DS1E	0x7E
(0172) #define _DS2S	0x80
(0173) #define _DS2E	0xFE
(0174) 
(0175) #elif _CODE_PAGE == 949	/* Korean */
(0176) #define _DF1S	0x81
(0177) #define _DF1E	0xFE
(0178) #define _DS1S	0x41
(0179) #define _DS1E	0x5A
(0180) #define _DS2S	0x61
(0181) #define _DS2E	0x7A
(0182) #define _DS3S	0x81
(0183) #define _DS3E	0xFE
(0184) 
(0185) #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
(0186) #define _DF1S	0x81
(0187) #define _DF1E	0xFE
(0188) #define _DS1S	0x40
(0189) #define _DS1E	0x7E
(0190) #define _DS2S	0xA1
(0191) #define _DS2E	0xFE
(0192) 
(0193) #elif _CODE_PAGE == 437	/* U.S. (OEM) */
(0194) #define _DF1S	0
(0195) #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0196) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0197) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0198) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0199) 
(0200) #elif _CODE_PAGE == 720	/* Arabic (OEM) */
(0201) #define _DF1S	0
(0202) #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0203) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0204) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0205) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0206) 
(0207) #elif _CODE_PAGE == 737	/* Greek (OEM) */
(0208) #define _DF1S	0
(0209) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
(0210) 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0211) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0212) 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0213) 
(0214) #elif _CODE_PAGE == 775	/* Baltic (OEM) */
(0215) #define _DF1S	0
(0216) #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0217) 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0218) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0219) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0220) 
(0221) #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
(0222) #define _DF1S	0
(0223) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0224) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0225) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0226) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0227) 
(0228) #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
(0229) #define _DF1S	0
(0230) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
(0231) 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
(0232) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0233) 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
(0234) 
(0235) #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
(0236) #define _DF1S	0
(0237) #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
(0238) 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
(0239) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
(0240) 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
(0241) 
(0242) #elif _CODE_PAGE == 857	/* Turkish (OEM) */
(0243) #define _DF1S	0
(0244) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
(0245) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0246) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0247) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0248) 
(0249) #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
(0250) #define _DF1S	0
(0251) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0252) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0253) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0254) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0255) 
(0256) #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
(0257) #define _DF1S	0
(0258) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0259) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0260) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0261) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0262) 
(0263) #elif _CODE_PAGE == 866	/* Russian (OEM) */
(0264) #define _DF1S	0
(0265) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0266) 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0267) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0268) 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0269) 
(0270) #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
(0271) #define _DF1S	0
(0272) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0273) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0274) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0275) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0276) 
(0277) #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
(0278) #define _DF1S	0
(0279) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0280) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
(0281) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0282) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0283) 
(0284) #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
(0285) #define _DF1S	0
(0286) #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0287) 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
(0288) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0289) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
(0290) 
(0291) #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
(0292) #define _DF1S	0
(0293) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
(0294) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0295) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0296) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0297) 
(0298) #elif _CODE_PAGE == 1253 /* Greek (Windows) */
(0299) #define _DF1S	0
(0300) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0301) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0302) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
(0303) 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
(0304) 
(0305) #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
(0306) #define _DF1S	0
(0307) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0308) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0309) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0310) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0311) 
(0312) #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
(0313) #define _DF1S	0
(0314) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0315) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0316) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0317) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0318) 
(0319) #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
(0320) #define _DF1S	0
(0321) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0322) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0323) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0324) 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
(0325) 
(0326) #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
(0327) #define _DF1S	0
(0328) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0329) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
(0330) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0331) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0332) 
(0333) #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
(0334) #define _DF1S	0
(0335) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
(0336) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0337) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0338) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
(0339) 
(0340) #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
(0341) #if _USE_LFN
(0342) #error Cannot use LFN feature without valid code page.
(0343) #endif
(0344) #define _DF1S	0
(0345) 
(0346) #else
(0347) #error Unknown code page
(0348) 
(0349) #endif
(0350) 
(0351) 
(0352) /* Character code support macros */
(0353) #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
(0354) #define IsLower(c)	(((c)>='a')&&((c)<='z'))
(0355) #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
(0356) 
(0357) #if _DF1S		/* Code page is DBCS */
(0358) 
(0359) #ifdef _DF2S	/* Two 1st byte areas */
(0360) #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
(0361) #else			/* One 1st byte area */
(0362) #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
(0363) #endif
(0364) 
(0365) #ifdef _DS3S	/* Three 2nd byte areas */
(0366) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
(0367) #else			/* Two 2nd byte areas */
(0368) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
(0369) #endif
(0370) 
(0371) #else			/* Code page is SBCS */
(0372) 
(0373) #define IsDBCS1(c)	0
(0374) #define IsDBCS2(c)	0
(0375) 
(0376) #endif /* _DF1S */
(0377) 
(0378) 
(0379) /* Name status flags */
(0380) #define NS			11		/* Index of name status byte in fn[] */
(0381) #define NS_LOSS		0x01	/* Out of 8.3 format */
(0382) #define NS_LFN		0x02	/* Force to create LFN entry */
(0383) #define NS_LAST		0x04	/* Last segment */
(0384) #define NS_BODY		0x08	/* Lower case flag (body) */
(0385) #define NS_EXT		0x10	/* Lower case flag (ext) */
(0386) #define NS_DOT		0x20	/* Dot entry */
(0387) 
(0388) 
(0389) /* FAT sub-type boundaries */
(0390) /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
(0391) #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
(0392) #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
(0393) 
(0394) 
(0395) /* FatFs refers the members in the FAT structures as byte array instead of
(0396) / structure member because the structure is not binary compatible between
(0397) / different platforms */
(0398) 
(0399) #define BS_jmpBoot			0	/* Jump instruction (3) */
(0400) #define BS_OEMName			3	/* OEM name (8) */
(0401) #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
(0402) #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
(0403) #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
(0404) #define BPB_NumFATs			16	/* Number of FAT copies (1) */
(0405) #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
(0406) #define BPB_TotSec16		19	/* Volume size [sector] (2) */
(0407) #define BPB_Media			21	/* Media descriptor (1) */
(0408) #define BPB_FATSz16			22	/* FAT size [sector] (2) */
(0409) #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
(0410) #define BPB_NumHeads		26	/* Number of heads (2) */
(0411) #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
(0412) #define BPB_TotSec32		32	/* Volume size [sector] (4) */
(0413) #define BS_DrvNum			36	/* Physical drive number (2) */
(0414) #define BS_BootSig			38	/* Extended boot signature (1) */
(0415) #define BS_VolID			39	/* Volume serial number (4) */
(0416) #define BS_VolLab			43	/* Volume label (8) */
(0417) #define BS_FilSysType		54	/* File system type (1) */
(0418) #define BPB_FATSz32			36	/* FAT size [sector] (4) */
(0419) #define BPB_ExtFlags		40	/* Extended flags (2) */
(0420) #define BPB_FSVer			42	/* File system version (2) */
(0421) #define BPB_RootClus		44	/* Root dir first cluster (4) */
(0422) #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
(0423) #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
(0424) #define BS_DrvNum32			64	/* Physical drive number (2) */
(0425) #define BS_BootSig32		66	/* Extended boot signature (1) */
(0426) #define BS_VolID32			67	/* Volume serial number (4) */
(0427) #define BS_VolLab32			71	/* Volume label (8) */
(0428) #define BS_FilSysType32		82	/* File system type (1) */
(0429) #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
(0430) #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
(0431) #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
(0432) #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
(0433) #define MBR_Table			446	/* MBR: Partition table offset (2) */
(0434) #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
(0435) #define BS_55AA				510	/* Boot sector signature (2) */
(0436) 
(0437) #define	DIR_Name			0	/* Short file name (11) */
(0438) #define	DIR_Attr			11	/* Attribute (1) */
(0439) #define	DIR_NTres			12	/* NT flag (1) */
(0440) #define	DIR_CrtTime			14	/* Created time (2) */
(0441) #define	DIR_CrtDate			16	/* Created date (2) */
(0442) #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
(0443) #define	DIR_WrtTime			22	/* Modified time (2) */
(0444) #define	DIR_WrtDate			24	/* Modified date (2) */
(0445) #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
(0446) #define	DIR_FileSize		28	/* File size (4) */
(0447) #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
(0448) #define	LDIR_Attr			11	/* LFN attribute (1) */
(0449) #define	LDIR_Type			12	/* LFN type (1) */
(0450) #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
(0451) #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
(0452) #define	SZ_DIR				32		/* Size of a directory entry */
(0453) #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
(0454) #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
(0455) #define	NDDE				0x05	/* Replacement of a character collides with DDE */
(0456) 
(0457) 
(0458) /*------------------------------------------------------------*/
(0459) /* Module private work area                                   */
(0460) /*------------------------------------------------------------*/
(0461) /* Note that uninitialized variables with static duration are
(0462) /  zeroed/nulled at start-up. If not, the compiler or start-up
(0463) /  routine is out of ANSI-C standard.
(0464) */
(0465) 
(0466) #if _VOLUMES
(0467) static
(0468) FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
(0469) #else
(0470) #error Number of volumes must not be 0.
(0471) #endif
(0472) 
(0473) static
(0474) WORD Fsid;				/* File system mount ID */
(0475) 
(0476) #if _FS_RPATH
(0477) static
(0478) BYTE CurrVol;			/* Current drive */
(0479) #endif
(0480) 
(0481) #if _FS_SHARE
(0482) static
(0483) FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
(0484) #endif
(0485) 
(0486) #if _USE_LFN == 0			/* No LFN feature */
(0487) #define	DEF_NAMEBUF			BYTE sfn[12]
(0488) #define INIT_BUF(dobj)		(dobj).fn = sfn
(0489) #define	FREE_BUF()
(0490) 
(0491) #elif _USE_LFN == 1			/* LFN feature with static working buffer */
(0492) static WCHAR LfnBuf[_MAX_LFN+1];
(0493) #define	DEF_NAMEBUF			BYTE sfn[12]
(0494) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
(0495) #define	FREE_BUF()
(0496) 
(0497) #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
(0498) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
(0499) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
(0500) #define	FREE_BUF()
(0501) 
(0502) #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
(0503) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
(0504) #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
(0505) 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
(0506) 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
(0507) #define	FREE_BUF()			ff_memfree(lfn)
(0508) 
(0509) #else
(0510) #error Wrong LFN configuration.
(0511) #endif
(0512) 
(0513) 
(0514) 
(0515) 
(0516) /*--------------------------------------------------------------------------
(0517) 
(0518)    Module Private Functions
(0519) 
(0520) ---------------------------------------------------------------------------*/
(0521) 
(0522) 
(0523) /*-----------------------------------------------------------------------*/
(0524) /* String functions                                                      */
(0525) /*-----------------------------------------------------------------------*/
(0526) 
(0527) /* Copy memory to memory */
(0528) static
(0529) void mem_cpy (void* dst, const void* src, UINT cnt) {
(0530) 	BYTE *d = (BYTE*)dst;
    002F3 0158      MOVW	R10,R16
(0531) 	const BYTE *s = (const BYTE*)src;
    002F4 0169      MOVW	R12,R18
    002F5 C006      RJMP	0x02FC
(0532) 
(0533) #if _WORD_ACCESS == 1
(0534) 	while (cnt >= sizeof(int)) {
(0535) 		*(int*)d = *(int*)s;
(0536) 		d += sizeof(int); s += sizeof(int);
(0537) 		cnt -= sizeof(int);
(0538) 	}
(0539) #endif
(0540) 	while (cnt--)
(0541) 		*d++ = *s++;
    002F6 01F6      MOVW	R30,R12
    002F7 01D5      MOVW	R26,R10
    002F8 9001      LD	R0,Z+
    002F9 016F      MOVW	R12,R30
    002FA 920D      ST	X+,R0
    002FB 015D      MOVW	R10,R26
    002FC 011A      MOVW	R2,R20
    002FD 5041      SUBI	R20,1
    002FE 4050      SBCI	R21,0
    002FF 2022      TST	R2
    00300 F7A9      BNE	0x02F6
    00301 2033      TST	R3
    00302 F799      BNE	0x02F6
    00303 940C 4145 JMP	pop_xgset303C
ff.c:mem_set:
  d                    --> R10
  cnt                  --> R20
  val                  --> R18
  dst                  --> R16
    00305 940E 411C CALL	push_xgset300C
    00307 814C      LDD	R20,Y+4
    00308 815D      LDD	R21,Y+5
(0542) }
(0543) 
(0544) /* Fill memory */
(0545) static
(0546) void mem_set (void* dst, int val, UINT cnt) {
(0547) 	BYTE *d = (BYTE*)dst;
    00309 0158      MOVW	R10,R16
    0030A C003      RJMP	0x030E
(0548) 
(0549) 	while (cnt--)
(0550) 		*d++ = (BYTE)val;
    0030B 01F5      MOVW	R30,R10
    0030C 9321      ST	Z+,R18
    0030D 015F      MOVW	R10,R30
    0030E 011A      MOVW	R2,R20
    0030F 5041      SUBI	R20,1
    00310 4050      SBCI	R21,0
    00311 2022      TST	R2
    00312 F7C1      BNE	0x030B
    00313 2033      TST	R3
    00314 F7B1      BNE	0x030B
    00315 940C 4121 JMP	pop_xgset300C
ff.c:mem_cmp:
  s                    --> R14
  d                    --> R12
  r                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    00317 940E 4113 CALL	push_xgset30FC
    00319 8548      LDD	R20,Y+8
    0031A 8559      LDD	R21,Y+9
(0551) }
(0552) 
(0553) /* Compare memory to memory */
(0554) static
(0555) int mem_cmp (const void* dst, const void* src, UINT cnt) {
(0556) 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    0031B 0168      MOVW	R12,R16
    0031C 0179      MOVW	R14,R18
(0557) 	int r = 0;
    0031D 24AA      CLR	R10
    0031E 24BB      CLR	R11
(0558) 
(0559) 	while (cnt-- && (r = *d++ - *s++) == 0) ;
    0031F 011A      MOVW	R2,R20
    00320 5041      SUBI	R20,1
    00321 4050      SBCI	R21,0
    00322 2022      TST	R2
    00323 F411      BNE	0x0326
    00324 2033      TST	R3
    00325 F079      BEQ	0x0335
    00326 01F7      MOVW	R30,R14
    00327 9021      LD	R2,Z+
    00328 017F      MOVW	R14,R30
    00329 2433      CLR	R3
    0032A 01F6      MOVW	R30,R12
    0032B 9041      LD	R4,Z+
    0032C 016F      MOVW	R12,R30
    0032D 2455      CLR	R5
    0032E 1842      SUB	R4,R2
    0032F 0853      SBC	R5,R3
    00330 0152      MOVW	R10,R4
    00331 20AA      TST	R10
    00332 F411      BNE	0x0335
    00333 20BB      TST	R11
    00334 F351      BEQ	0x031F
(0560) 	return r;
    00335 0185      MOVW	R16,R10
    00336 940C 40FD JMP	pop_xgset30FC
(0561) }
(0562) 
(0563) /* Check if chr is contained in the string */
(0564) static
(0565) int chk_chr (const char* str, int chr) {
ff.c:chk_chr:
  chr                  --> R18
  str                  --> R16
    00338 C002      RJMP	0x033B
(0566) 	while (*str && *str != chr) str++;
    00339 5F0F      SUBI	R16,0xFF
    0033A 4F1F      SBCI	R17,0xFF
    0033B 01F8      MOVW	R30,R16
    0033C 8020      LD	R2,Z
    0033D 2433      CLR	R3
    0033E 2022      TST	R2
    0033F F021      BEQ	0x0344
    00340 2433      CLR	R3
    00341 1622      CP	R2,R18
    00342 0633      CPC	R3,R19
    00343 F7A9      BNE	0x0339
(0567) 	return *str;
    00344 01F8      MOVW	R30,R16
    00345 8100      LD	R16,Z
    00346 2711      CLR	R17
    00347 9508      RET
ff.c:move_window:
  nf                   --> R10
  wsect                --> Y,+5
  sector               --> Y,+13
  fs                   --> R20
    00348 933A      ST	-Y,R19
    00349 932A      ST	-Y,R18
    0034A 940E 411C CALL	push_xgset300C
    0034C 01A8      MOVW	R20,R16
    0034D 9729      SBIW	R28,0x9
(0568) }
(0569) 
(0570) 
(0571) 
(0572) /*-----------------------------------------------------------------------*/
(0573) /* Request/Release grant to access the volume                            */
(0574) /*-----------------------------------------------------------------------*/
(0575) #if _FS_REENTRANT
(0576) 
(0577) static
(0578) int lock_fs (
(0579) 	FATFS *fs		/* File system object */
(0580) )
(0581) {
(0582) 	return ff_req_grant(fs->sobj);
(0583) }
(0584) 
(0585) 
(0586) static
(0587) void unlock_fs (
(0588) 	FATFS *fs,		/* File system object */
(0589) 	FRESULT res		/* Result code to be returned */
(0590) )
(0591) {
(0592) 	if (res != FR_NOT_ENABLED &&
(0593) 		res != FR_INVALID_DRIVE &&
(0594) 		res != FR_INVALID_OBJECT &&
(0595) 		res != FR_TIMEOUT) {
(0596) 		ff_rel_grant(fs->sobj);
(0597) 	}
(0598) }
(0599) #endif
(0600) 
(0601) 
(0602) 
(0603) /*-----------------------------------------------------------------------*/
(0604) /* File shareing control functions                                       */
(0605) /*-----------------------------------------------------------------------*/
(0606) #if _FS_SHARE
(0607) 
(0608) static
(0609) FRESULT chk_lock (	/* Check if the file can be accessed */
(0610) 	DIR* dj,		/* Directory object pointing the file to be checked */
(0611) 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
(0612) )
(0613) {
(0614) 	UINT i, be;
(0615) 
(0616) 	/* Search file semaphore table */
(0617) 	for (i = be = 0; i < _FS_SHARE; i++) {
(0618) 		if (Files[i].fs) {	/* Existing entry */
(0619) 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
(0620) 				Files[i].clu == dj->sclust &&
(0621) 				Files[i].idx == dj->index) break;
(0622) 		} else {			/* Blank entry */
(0623) 			be++;
(0624) 		}
(0625) 	}
(0626) 	if (i == _FS_SHARE)	/* The file is not opened */
(0627) 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
(0628) 
(0629) 	/* The file has been opened. Reject any open against writing file and all write mode open */
(0630) 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
(0631) }
(0632) 
(0633) 
(0634) static
(0635) int enq_lock (void)	/* Check if an entry is available for a new file */
(0636) {
(0637) 	UINT i;
(0638) 
(0639) 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0640) 	return (i == _FS_SHARE) ? 0 : 1;
(0641) }
(0642) 
(0643) 
(0644) static
(0645) UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
(0646) 	DIR* dj,	/* Directory object pointing the file to register or increment */
(0647) 	int acc		/* Desired access mode (0:Read, !0:Write) */
(0648) )
(0649) {
(0650) 	UINT i;
(0651) 
(0652) 
(0653) 	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
(0654) 		if (Files[i].fs == dj->fs &&
(0655) 			Files[i].clu == dj->sclust &&
(0656) 			Files[i].idx == dj->index) break;
(0657) 	}
(0658) 
(0659) 	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
(0660) 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0661) 		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
(0662) 		Files[i].fs = dj->fs;
(0663) 		Files[i].clu = dj->sclust;
(0664) 		Files[i].idx = dj->index;
(0665) 		Files[i].ctr = 0;
(0666) 	}
(0667) 
(0668) 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
(0669) 
(0670) 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
(0671) 
(0672) 	return i + 1;
(0673) }
(0674) 
(0675) 
(0676) static
(0677) FRESULT dec_lock (	/* Decrement file open counter */
(0678) 	UINT i			/* Semaphore index */
(0679) )
(0680) {
(0681) 	WORD n;
(0682) 	FRESULT res;
(0683) 
(0684) 
(0685) 	if (--i < _FS_SHARE) {
(0686) 		n = Files[i].ctr;
(0687) 		if (n == 0x100) n = 0;
(0688) 		if (n) n--;
(0689) 		Files[i].ctr = n;
(0690) 		if (!n) Files[i].fs = 0;
(0691) 		res = FR_OK;
(0692) 	} else {
(0693) 		res = FR_INT_ERR;
(0694) 	}
(0695) 	return res;
(0696) }
(0697) 
(0698) 
(0699) static
(0700) void clear_lock (	/* Clear lock entries of the volume */
(0701) 	FATFS *fs
(0702) )
(0703) {
(0704) 	UINT i;
(0705) 
(0706) 	for (i = 0; i < _FS_SHARE; i++) {
(0707) 		if (Files[i].fs == fs) Files[i].fs = 0;
(0708) 	}
(0709) }
(0710) #endif
(0711) 
(0712) 
(0713) 
(0714) /*-----------------------------------------------------------------------*/
(0715) /* Change window offset                                                  */
(0716) /*-----------------------------------------------------------------------*/
(0717) 
(0718) static
(0719) FRESULT move_window (
(0720) 	FATFS *fs,		/* File system object */
(0721) 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
(0722) )					/* Move to zero only writes back dirty window */
(0723) {
(0724) 	DWORD wsect;
(0725) 
(0726) 
(0727) 	wsect = fs->winsect;
    0034E 01FA      MOVW	R30,R20
    0034F 96BA      ADIW	R30,0x2A
    00350 8020      LD	R2,Z
    00351 8031      LDD	R3,Z+1
    00352 8042      LDD	R4,Z+2
    00353 8053      LDD	R5,Z+3
    00354 822D      STD	Y+5,R2
    00355 823E      STD	Y+6,R3
    00356 824F      STD	Y+7,R4
    00357 8658      STD	Y+8,R5
(0728) 	if (wsect != sector) {	/* Changed current window */
    00358 842D      LDD	R2,Y+13
    00359 843E      LDD	R3,Y+14
    0035A 844F      LDD	R4,Y+15
    0035B 8858      LDD	R5,Y+16
    0035C 806D      LDD	R6,Y+5
    0035D 807E      LDD	R7,Y+6
    0035E 808F      LDD	R8,Y+7
    0035F 8498      LDD	R9,Y+8
    00360 1462      CP	R6,R2
    00361 0473      CPC	R7,R3
    00362 0484      CPC	R8,R4
    00363 0495      CPC	R9,R5
    00364 F409      BNE	0x0366
    00365 C07E      RJMP	0x03E4
(0729) #if !_FS_READONLY
(0730) 		if (fs->wflag) {	/* Write back dirty window if needed */
    00366 01FA      MOVW	R30,R20
    00367 8024      LDD	R2,Z+4
    00368 2022      TST	R2
    00369 F409      BNE	0x036B
    0036A C055      RJMP	0x03C0
(0731) 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    0036B E081      LDI	R24,1
    0036C 838C      STD	Y+4,R24
    0036D 0113      MOVW	R2,R6
    0036E 0124      MOVW	R4,R8
    0036F 8228      ST	Y,R2
    00370 8239      STD	Y+1,R3
    00371 824A      STD	Y+2,R4
    00372 825B      STD	Y+3,R5
    00373 019A      MOVW	R18,R20
    00374 5D22      SUBI	R18,0xD2
    00375 4F3F      SBCI	R19,0xFF
    00376 8101      LDD	R16,Z+1
    00377 940E 02CD CALL	_disk_write
    00379 2300      TST	R16
    0037A F011      BEQ	0x037D
(0732) 				return FR_DISK_ERR;
    0037B E001      LDI	R16,1
    0037C C068      RJMP	0x03E5
(0733) 			fs->wflag = 0;
    0037D 2422      CLR	R2
    0037E 01FA      MOVW	R30,R20
    0037F 8224      STD	Z+4,R2
(0734) 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    00380 8C22      LDD	R2,Z+26
    00381 8C33      LDD	R3,Z+27
    00382 8C44      LDD	R4,Z+28
    00383 8C55      LDD	R5,Z+29
    00384 967E      ADIW	R30,0x1E
    00385 8060      LD	R6,Z
    00386 8071      LDD	R7,Z+1
    00387 8082      LDD	R8,Z+2
    00388 8093      LDD	R9,Z+3
    00389 0C62      ADD	R6,R2
    0038A 1C73      ADC	R7,R3
    0038B 1C84      ADC	R8,R4
    0038C 1C95      ADC	R9,R5
    0038D 802D      LDD	R2,Y+5
    0038E 803E      LDD	R3,Y+6
    0038F 804F      LDD	R4,Y+7
    00390 8458      LDD	R5,Y+8
    00391 1426      CP	R2,R6
    00392 0437      CPC	R3,R7
    00393 0448      CPC	R4,R8
    00394 0459      CPC	R5,R9
    00395 F550      BCC	0x03C0
(0735) 				BYTE nf;
(0736) 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    00396 01FA      MOVW	R30,R20
    00397 80A3      LDD	R10,Z+3
    00398 C024      RJMP	0x03BD
(0737) 					wsect += fs->fsize;
    00399 01FA      MOVW	R30,R20
    0039A 967A      ADIW	R30,0x1A
    0039B 8020      LD	R2,Z
    0039C 8031      LDD	R3,Z+1
    0039D 8042      LDD	R4,Z+2
    0039E 8053      LDD	R5,Z+3
    0039F 806D      LDD	R6,Y+5
    003A0 807E      LDD	R7,Y+6
    003A1 808F      LDD	R8,Y+7
    003A2 8498      LDD	R9,Y+8
    003A3 0C62      ADD	R6,R2
    003A4 1C73      ADC	R7,R3
    003A5 1C84      ADC	R8,R4
    003A6 1C95      ADC	R9,R5
    003A7 826D      STD	Y+5,R6
    003A8 827E      STD	Y+6,R7
    003A9 828F      STD	Y+7,R8
    003AA 8698      STD	Y+8,R9
(0738) 					disk_write(fs->drv, fs->win, wsect, 1);
    003AB E081      LDI	R24,1
    003AC 838C      STD	Y+4,R24
    003AD 802D      LDD	R2,Y+5
    003AE 803E      LDD	R3,Y+6
    003AF 804F      LDD	R4,Y+7
    003B0 8458      LDD	R5,Y+8
    003B1 8228      ST	Y,R2
    003B2 8239      STD	Y+1,R3
    003B3 824A      STD	Y+2,R4
    003B4 825B      STD	Y+3,R5
    003B5 019A      MOVW	R18,R20
    003B6 5D22      SUBI	R18,0xD2
    003B7 4F3F      SBCI	R19,0xFF
    003B8 01FA      MOVW	R30,R20
    003B9 8101      LDD	R16,Z+1
    003BA 940E 02CD CALL	_disk_write
    003BC 94AA      DEC	R10
    003BD E081      LDI	R24,1
    003BE 158A      CP	R24,R10
    003BF F2C8      BCS	0x0399
(0739) 				}
(0740) 			}
(0741) 		}
(0742) #endif
(0743) 		if (sector) {
    003C0 842D      LDD	R2,Y+13
    003C1 843E      LDD	R3,Y+14
    003C2 844F      LDD	R4,Y+15
    003C3 8858      LDD	R5,Y+16
    003C4 9488      BCLR	0
    003C5 2022      TST	R2
    003C6 0432      CPC	R3,R2
    003C7 0442      CPC	R4,R2
    003C8 0452      CPC	R5,R2
    003C9 F0D1      BEQ	0x03E4
(0744) 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    003CA E081      LDI	R24,1
    003CB 838C      STD	Y+4,R24
    003CC 8228      ST	Y,R2
    003CD 8239      STD	Y+1,R3
    003CE 824A      STD	Y+2,R4
    003CF 825B      STD	Y+3,R5
    003D0 019A      MOVW	R18,R20
    003D1 5D22      SUBI	R18,0xD2
    003D2 4F3F      SBCI	R19,0xFF
    003D3 01FA      MOVW	R30,R20
    003D4 8101      LDD	R16,Z+1
    003D5 940E 02AD CALL	_disk_read
    003D7 2300      TST	R16
    003D8 F011      BEQ	0x03DB
(0745) 				return FR_DISK_ERR;
    003D9 E001      LDI	R16,1
    003DA C00A      RJMP	0x03E5
(0746) 			fs->winsect = sector;
    003DB 842D      LDD	R2,Y+13
    003DC 843E      LDD	R3,Y+14
    003DD 844F      LDD	R4,Y+15
    003DE 8858      LDD	R5,Y+16
    003DF 01FA      MOVW	R30,R20
    003E0 A622      STD	Z+42,R2
    003E1 A633      STD	Z+43,R3
    003E2 A644      STD	Z+44,R4
    003E3 A655      STD	Z+45,R5
(0747) 		}
(0748) 	}
(0749) 
(0750) 	return FR_OK;
    003E4 2700      CLR	R16
    003E5 9629      ADIW	R28,0x9
    003E6 940E 4121 CALL	pop_xgset300C
    003E8 9622      ADIW	R28,2
    003E9 9508      RET
ff.c:sync:
  res                  --> R20
  fs                   --> R22
    003EA 940E 4126 CALL	push_xgsetF000
    003EC 01B8      MOVW	R22,R16
    003ED 9725      SBIW	R28,5
(0751) }
(0752) 
(0753) 
(0754) 
(0755) 
(0756) /*-----------------------------------------------------------------------*/
(0757) /* Clean-up cached data                                                  */
(0758) /*-----------------------------------------------------------------------*/
(0759) #if !_FS_READONLY
(0760) static
(0761) FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
(0762) 	FATFS *fs	/* File system object */
(0763) )
(0764) {
(0765) 	FRESULT res;
(0766) 
(0767) 
(0768) 	res = move_window(fs, 0);
    003EE E080      LDI	R24,0
    003EF E090      LDI	R25,0
    003F0 E0A0      LDI	R26,0
    003F1 E0B0      LDI	R27,0
    003F2 83A8      ST	Y,R26
    003F3 83B9      STD	Y+1,R27
    003F4 019C      MOVW	R18,R24
    003F5 018B      MOVW	R16,R22
    003F6 DF51      RCALL	ff.c:move_window
    003F7 2F40      MOV	R20,R16
(0769) 	if (res == FR_OK) {
    003F8 2300      TST	R16
    003F9 F009      BEQ	0x03FB
    003FA C0C0      RJMP	0x04BB
(0770) 		/* Update FSInfo sector if needed */
(0771) 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    003FB 01FB      MOVW	R30,R22
    003FC 8180      LD	R24,Z
    003FD 3083      CPI	R24,3
    003FE F009      BEQ	0x0400
    003FF C0AC      RJMP	0x04AC
    00400 8025      LDD	R2,Z+5
    00401 2022      TST	R2
    00402 F409      BNE	0x0404
    00403 C0A8      RJMP	0x04AC
(0772) 			fs->winsect = 0;
    00404 96BA      ADIW	R30,0x2A
    00405 E080      LDI	R24,0
    00406 8380      ST	Z,R24
    00407 8381      STD	Z+1,R24
    00408 8382      STD	Z+2,R24
    00409 8383      STD	Z+3,R24
(0773) 			/* Create FSInfo structure */
(0774) 			mem_set(fs->win, 0, 512);
    0040A E080      LDI	R24,0
    0040B E092      LDI	R25,2
    0040C 8399      STD	Y+1,R25
    0040D 8388      ST	Y,R24
    0040E 2722      CLR	R18
    0040F 2733      CLR	R19
    00410 018B      MOVW	R16,R22
    00411 5D02      SUBI	R16,0xD2
    00412 4F1F      SBCI	R17,0xFF
    00413 DEF1      RCALL	ff.c:mem_set
(0775) 			ST_WORD(fs->win+BS_55AA, 0xAA55);
    00414 E585      LDI	R24,0x55
    00415 01FB      MOVW	R30,R22
    00416 5DE4      SUBI	R30,0xD4
    00417 4FFD      SBCI	R31,0xFD
    00418 8380      ST	Z,R24
    00419 52EC      SUBI	R30,0x2C
    0041A 40F2      SBCI	R31,2
    0041B EA8A      LDI	R24,0xAA
    0041C 5DE3      SUBI	R30,0xD3
    0041D 4FFD      SBCI	R31,0xFD
    0041E 8380      ST	Z,R24
    0041F 52ED      SUBI	R30,0x2D
    00420 40F2      SBCI	R31,2
(0776) 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    00421 E582      LDI	R24,0x52
    00422 A786      STD	Z+46,R24
    00423 A787      STD	Z+47,R24
    00424 E681      LDI	R24,0x61
    00425 AB80      STD	Z+48,R24
    00426 E481      LDI	R24,0x41
    00427 AB81      STD	Z+49,R24
(0777) 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    00428 E782      LDI	R24,0x72
    00429 5EEE      SUBI	R30,0xEE
    0042A 4FFD      SBCI	R31,0xFD
    0042B 8380      ST	Z,R24
    0042C 51E2      SUBI	R30,0x12
    0042D 40F2      SBCI	R31,2
    0042E 5EED      SUBI	R30,0xED
    0042F 4FFD      SBCI	R31,0xFD
    00430 8380      ST	Z,R24
    00431 51E3      SUBI	R30,0x13
    00432 40F2      SBCI	R31,2
    00433 E481      LDI	R24,0x41
    00434 5EEC      SUBI	R30,0xEC
    00435 4FFD      SBCI	R31,0xFD
    00436 8380      ST	Z,R24
    00437 51E4      SUBI	R30,0x14
    00438 40F2      SBCI	R31,2
    00439 E681      LDI	R24,0x61
    0043A 5EEB      SUBI	R30,0xEB
    0043B 4FFD      SBCI	R31,0xFD
    0043C 8380      ST	Z,R24
    0043D 51E5      SUBI	R30,0x15
    0043E 40F2      SBCI	R31,2
(0778) 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    0043F 8426      LDD	R2,Z+14
    00440 8437      LDD	R3,Z+15
    00441 8840      LDD	R4,Z+16
    00442 8851      LDD	R5,Z+17
    00443 5EEA      SUBI	R30,0xEA
    00444 4FFD      SBCI	R31,0xFD
    00445 8220      ST	Z,R2
    00446 51E6      SUBI	R30,0x16
    00447 40F2      SBCI	R31,2
    00448 8426      LDD	R2,Z+14
    00449 8437      LDD	R3,Z+15
    0044A 2C23      MOV	R2,R3
    0044B 2433      CLR	R3
    0044C 5EE9      SUBI	R30,0xE9
    0044D 4FFD      SBCI	R31,0xFD
    0044E 8220      ST	Z,R2
    0044F 51E7      SUBI	R30,0x17
    00450 40F2      SBCI	R31,2
    00451 8426      LDD	R2,Z+14
    00452 8437      LDD	R3,Z+15
    00453 8840      LDD	R4,Z+16
    00454 8851      LDD	R5,Z+17
    00455 0112      MOVW	R2,R4
    00456 2444      CLR	R4
    00457 2455      CLR	R5
    00458 5EE8      SUBI	R30,0xE8
    00459 4FFD      SBCI	R31,0xFD
    0045A 8220      ST	Z,R2
    0045B 51E8      SUBI	R30,0x18
    0045C 40F2      SBCI	R31,2
    0045D E188      LDI	R24,0x18
    0045E E090      LDI	R25,0
    0045F 8506      LDD	R16,Z+14
    00460 8517      LDD	R17,Z+15
    00461 8920      LDD	R18,Z+16
    00462 8931      LDD	R19,Z+17
    00463 938A      ST	-Y,R24
    00464 940E 41AC CALL	lsr32
    00466 01FB      MOVW	R30,R22
    00467 5EE7      SUBI	R30,0xE7
    00468 4FFD      SBCI	R31,0xFD
    00469 8300      ST	Z,R16
    0046A 51E9      SUBI	R30,0x19
    0046B 40F2      SBCI	R31,2
(0779) 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    0046C 8422      LDD	R2,Z+10
    0046D 8433      LDD	R3,Z+11
    0046E 8444      LDD	R4,Z+12
    0046F 8455      LDD	R5,Z+13
    00470 5EE6      SUBI	R30,0xE6
    00471 4FFD      SBCI	R31,0xFD
    00472 8220      ST	Z,R2
    00473 51EA      SUBI	R30,0x1A
    00474 40F2      SBCI	R31,2
    00475 8422      LDD	R2,Z+10
    00476 8433      LDD	R3,Z+11
    00477 2C23      MOV	R2,R3
    00478 2433      CLR	R3
    00479 5EE5      SUBI	R30,0xE5
    0047A 4FFD      SBCI	R31,0xFD
    0047B 8220      ST	Z,R2
    0047C 51EB      SUBI	R30,0x1B
    0047D 40F2      SBCI	R31,2
    0047E 8422      LDD	R2,Z+10
    0047F 8433      LDD	R3,Z+11
    00480 8444      LDD	R4,Z+12
    00481 8455      LDD	R5,Z+13
    00482 0112      MOVW	R2,R4
    00483 2444      CLR	R4
    00484 2455      CLR	R5
    00485 5EE4      SUBI	R30,0xE4
    00486 4FFD      SBCI	R31,0xFD
    00487 8220      ST	Z,R2
    00488 51EC      SUBI	R30,0x1C
    00489 40F2      SBCI	R31,2
    0048A E188      LDI	R24,0x18
    0048B E090      LDI	R25,0
    0048C 8502      LDD	R16,Z+10
    0048D 8513      LDD	R17,Z+11
    0048E 8524      LDD	R18,Z+12
    0048F 8535      LDD	R19,Z+13
    00490 938A      ST	-Y,R24
    00491 940E 41AC CALL	lsr32
    00493 01FB      MOVW	R30,R22
    00494 5EE3      SUBI	R30,0xE3
    00495 4FFD      SBCI	R31,0xFD
    00496 8300      ST	Z,R16
    00497 51ED      SUBI	R30,0x1D
    00498 40F2      SBCI	R31,2
(0780) 			/* Write it into the FSInfo sector */
(0781) 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    00499 E081      LDI	R24,1
    0049A 838C      STD	Y+4,R24
    0049B 8822      LDD	R2,Z+18
    0049C 8833      LDD	R3,Z+19
    0049D 8844      LDD	R4,Z+20
    0049E 8855      LDD	R5,Z+21
    0049F 8228      ST	Y,R2
    004A0 8239      STD	Y+1,R3
    004A1 824A      STD	Y+2,R4
    004A2 825B      STD	Y+3,R5
    004A3 019F      MOVW	R18,R30
    004A4 5D22      SUBI	R18,0xD2
    004A5 4F3F      SBCI	R19,0xFF
    004A6 8101      LDD	R16,Z+1
    004A7 940E 02CD CALL	_disk_write
(0782) 			fs->fsi_flag = 0;
    004A9 2422      CLR	R2
    004AA 01FB      MOVW	R30,R22
    004AB 8225      STD	Z+5,R2
(0783) 		}
(0784) 		/* Make sure that no pending write process in the physical drive */
(0785) 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    004AC 2422      CLR	R2
    004AD 2433      CLR	R3
    004AE 8239      STD	Y+1,R3
    004AF 8228      ST	Y,R2
    004B0 2722      CLR	R18
    004B1 2733      CLR	R19
    004B2 01FB      MOVW	R30,R22
    004B3 8101      LDD	R16,Z+1
    004B4 2711      CLR	R17
    004B5 940E 02E5 CALL	_disk_ioctl
    004B7 3000      CPI	R16,0
    004B8 0701      CPC	R16,R17
    004B9 F009      BEQ	0x04BB
(0786) 			res = FR_DISK_ERR;
    004BA E041      LDI	R20,1
(0787) 	}
(0788) 
(0789) 	return res;
    004BB 2F04      MOV	R16,R20
    004BC 9625      ADIW	R28,5
    004BD 940C 412B JMP	pop_xgsetF000
_clust2sect:
  clst                 --> Y,+6
  fs                   --> R10
    004BF 933A      ST	-Y,R19
    004C0 932A      ST	-Y,R18
    004C1 940E 4130 CALL	push_xgsetF00C
    004C3 0158      MOVW	R10,R16
(0790) }
(0791) #endif
(0792) 
(0793) 
(0794) 
(0795) 
(0796) /*-----------------------------------------------------------------------*/
(0797) /* Get sector# from cluster#                                             */
(0798) /*-----------------------------------------------------------------------*/
(0799) 
(0800) 
(0801) DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
(0802) 	FATFS *fs,		/* File system object */
(0803) 	DWORD clst		/* Cluster# to be converted */
(0804) )
(0805) {
(0806) 	clst -= 2;
    004C4 E042      LDI	R20,2
    004C5 E050      LDI	R21,0
    004C6 E060      LDI	R22,0
    004C7 E070      LDI	R23,0
    004C8 802E      LDD	R2,Y+6
    004C9 803F      LDD	R3,Y+7
    004CA 8448      LDD	R4,Y+8
    004CB 8459      LDD	R5,Y+9
    004CC 1A24      SUB	R2,R20
    004CD 0A35      SBC	R3,R21
    004CE 0A46      SBC	R4,R22
    004CF 0A57      SBC	R5,R23
    004D0 822E      STD	Y+6,R2
    004D1 823F      STD	Y+7,R3
    004D2 8648      STD	Y+8,R4
    004D3 8659      STD	Y+9,R5
(0807) 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    004D4 E042      LDI	R20,2
    004D5 E050      LDI	R21,0
    004D6 E060      LDI	R22,0
    004D7 E070      LDI	R23,0
    004D8 01F5      MOVW	R30,R10
    004D9 9676      ADIW	R30,0x16
    004DA 8020      LD	R2,Z
    004DB 8031      LDD	R3,Z+1
    004DC 8042      LDD	R4,Z+2
    004DD 8053      LDD	R5,Z+3
    004DE 1A24      SUB	R2,R20
    004DF 0A35      SBC	R3,R21
    004E0 0A46      SBC	R4,R22
    004E1 0A57      SBC	R5,R23
    004E2 806E      LDD	R6,Y+6
    004E3 807F      LDD	R7,Y+7
    004E4 8488      LDD	R8,Y+8
    004E5 8499      LDD	R9,Y+9
    004E6 1462      CP	R6,R2
    004E7 0473      CPC	R7,R3
    004E8 0484      CPC	R8,R4
    004E9 0495      CPC	R9,R5
    004EA F028      BCS	0x04F0
    004EB E000      LDI	R16,0
    004EC E010      LDI	R17,0
    004ED E020      LDI	R18,0
    004EE E030      LDI	R19,0
    004EF C01D      RJMP	0x050D
(0808) 	return clst * fs->csize + fs->database;
    004F0 01F5      MOVW	R30,R10
    004F1 9632      ADIW	R30,2
    004F2 8020      LD	R2,Z
    004F3 2433      CLR	R3
    004F4 2444      CLR	R4
    004F5 2455      CLR	R5
    004F6 810E      LDD	R16,Y+6
    004F7 811F      LDD	R17,Y+7
    004F8 8528      LDD	R18,Y+8
    004F9 8539      LDD	R19,Y+9
    004FA 925A      ST	-Y,R5
    004FB 924A      ST	-Y,R4
    004FC 923A      ST	-Y,R3
    004FD 922A      ST	-Y,R2
    004FE 940E 40BD CALL	empy32u|empy32s
    00500 0118      MOVW	R2,R16
    00501 0129      MOVW	R4,R18
    00502 01F5      MOVW	R30,R10
    00503 A066      LDD	R6,Z+38
    00504 A077      LDD	R7,Z+39
    00505 A480      LDD	R8,Z+40
    00506 A491      LDD	R9,Z+41
    00507 0C26      ADD	R2,R6
    00508 1C37      ADC	R3,R7
    00509 1C48      ADC	R4,R8
    0050A 1C59      ADC	R5,R9
    0050B 0181      MOVW	R16,R2
    0050C 0192      MOVW	R18,R4
    0050D 940E 4137 CALL	pop_xgsetF00C
    0050F 9622      ADIW	R28,2
    00510 9508      RET
_get_fat:
  wc                   --> R14
  p                    --> R10
  bc                   --> R10
  clst                 --> Y,+12
  fs                   --> R12
    00511 933A      ST	-Y,R19
    00512 932A      ST	-Y,R18
    00513 940E 4111 CALL	push_xgsetF0FC
    00515 0168      MOVW	R12,R16
    00516 9722      SBIW	R28,2
(0809) }
(0810) 
(0811) 
(0812) 
(0813) 
(0814) /*-----------------------------------------------------------------------*/
(0815) /* FAT access - Read value of a FAT entry                                */
(0816) /*-----------------------------------------------------------------------*/
(0817) 
(0818) 
(0819) DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
(0820) 	FATFS *fs,	/* File system object */
(0821) 	DWORD clst	/* Cluster# to get the link information */
(0822) )
(0823) {
(0824) 	UINT wc, bc;
(0825) 	BYTE *p;
(0826) 
(0827) 
(0828) 	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    00517 E042      LDI	R20,2
    00518 E050      LDI	R21,0
    00519 E060      LDI	R22,0
    0051A E070      LDI	R23,0
    0051B 842C      LDD	R2,Y+12
    0051C 843D      LDD	R3,Y+13
    0051D 844E      LDD	R4,Y+14
    0051E 845F      LDD	R5,Y+15
    0051F 1624      CP	R2,R20
    00520 0635      CPC	R3,R21
    00521 0646      CPC	R4,R22
    00522 0657      CPC	R5,R23
    00523 F078      BCS	0x0533
    00524 01F6      MOVW	R30,R12
    00525 9676      ADIW	R30,0x16
    00526 8020      LD	R2,Z
    00527 8031      LDD	R3,Z+1
    00528 8042      LDD	R4,Z+2
    00529 8053      LDD	R5,Z+3
    0052A 846C      LDD	R6,Y+12
    0052B 847D      LDD	R7,Y+13
    0052C 848E      LDD	R8,Y+14
    0052D 849F      LDD	R9,Y+15
    0052E 1462      CP	R6,R2
    0052F 0473      CPC	R7,R3
    00530 0484      CPC	R8,R4
    00531 0495      CPC	R9,R5
    00532 F028      BCS	0x0538
(0829) 		return 1;
    00533 E001      LDI	R16,1
    00534 E010      LDI	R17,0
    00535 E020      LDI	R18,0
    00536 E030      LDI	R19,0
    00537 C124      RJMP	0x065C
(0830) 
(0831) 	switch (fs->fs_type) {
    00538 01F6      MOVW	R30,R12
    00539 80A0      LD	R10,Z
    0053A 24BB      CLR	R11
    0053B 01C5      MOVW	R24,R10
    0053C 3081      CPI	R24,1
    0053D E0E0      LDI	R30,0
    0053E 079E      CPC	R25,R30
    0053F F059      BEQ	0x054B
    00540 3082      CPI	R24,2
    00541 E0E0      LDI	R30,0
    00542 079E      CPC	R25,R30
    00543 F409      BNE	0x0545
    00544 C06F      RJMP	0x05B4
    00545 3083      CPI	R24,3
    00546 E0E0      LDI	R30,0
    00547 079E      CPC	R25,R30
    00548 F409      BNE	0x054A
    00549 C0A6      RJMP	0x05F0
    0054A C10D      RJMP	0x0658
(0832) 	case FS_FAT12 :
(0833) 		bc = (UINT)clst; bc += bc / 2;
    0054B 84AC      LDD	R10,Y+12
    0054C 84BD      LDD	R11,Y+13
    0054D 0115      MOVW	R2,R10
    0054E 9436      LSR	R3
    0054F 9427      ROR	R2
    00550 0CA2      ADD	R10,R2
    00551 1CB3      ADC	R11,R3
(0834) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00552 E029      LDI	R18,0x9
    00553 E030      LDI	R19,0
    00554 0185      MOVW	R16,R10
    00555 940E 41A5 CALL	lsr16
    00557 0118      MOVW	R2,R16
    00558 2444      CLR	R4
    00559 2455      CLR	R5
    0055A 01F6      MOVW	R30,R12
    0055B 8C66      LDD	R6,Z+30
    0055C 8C77      LDD	R7,Z+31
    0055D A080      LDD	R8,Z+32
    0055E A091      LDD	R9,Z+33
    0055F 0C62      ADD	R6,R2
    00560 1C73      ADC	R7,R3
    00561 1C84      ADC	R8,R4
    00562 1C95      ADC	R9,R5
    00563 8288      ST	Y,R8
    00564 8299      STD	Y+1,R9
    00565 0193      MOVW	R18,R6
    00566 018F      MOVW	R16,R30
    00567 DDE0      RCALL	ff.c:move_window
    00568 2300      TST	R16
    00569 F009      BEQ	0x056B
    0056A C0ED      RJMP	0x0658
(0835) 		wc = fs->win[bc % SS(fs)]; bc++;
    0056B 01C6      MOVW	R24,R12
    0056C 968E      ADIW	R24,0x2E
    0056D 01F5      MOVW	R30,R10
    0056E 70F1      ANDI	R31,1
    0056F 0FE8      ADD	R30,R24
    00570 1FF9      ADC	R31,R25
    00571 80E0      LD	R14,Z
    00572 24FF      CLR	R15
    00573 01C5      MOVW	R24,R10
    00574 9601      ADIW	R24,1
    00575 015C      MOVW	R10,R24
(0836) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00576 E029      LDI	R18,0x9
    00577 E030      LDI	R19,0
    00578 018C      MOVW	R16,R24
    00579 940E 41A5 CALL	lsr16
    0057B 0118      MOVW	R2,R16
    0057C 2444      CLR	R4
    0057D 2455      CLR	R5
    0057E 01F6      MOVW	R30,R12
    0057F 8C66      LDD	R6,Z+30
    00580 8C77      LDD	R7,Z+31
    00581 A080      LDD	R8,Z+32
    00582 A091      LDD	R9,Z+33
    00583 0C62      ADD	R6,R2
    00584 1C73      ADC	R7,R3
    00585 1C84      ADC	R8,R4
    00586 1C95      ADC	R9,R5
    00587 8288      ST	Y,R8
    00588 8299      STD	Y+1,R9
    00589 0193      MOVW	R18,R6
    0058A 018F      MOVW	R16,R30
    0058B DDBC      RCALL	ff.c:move_window
    0058C 2300      TST	R16
    0058D F009      BEQ	0x058F
    0058E C0C9      RJMP	0x0658
(0837) 		wc |= fs->win[bc % SS(fs)] << 8;
    0058F 01C6      MOVW	R24,R12
    00590 968E      ADIW	R24,0x2E
    00591 01F5      MOVW	R30,R10
    00592 70F1      ANDI	R31,1
    00593 0FE8      ADD	R30,R24
    00594 1FF9      ADC	R31,R25
    00595 8020      LD	R2,Z
    00596 2433      CLR	R3
    00597 2C32      MOV	R3,R2
    00598 2422      CLR	R2
    00599 28E2      OR	R14,R2
    0059A 28F3      OR	R15,R3
(0838) 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    0059B 842C      LDD	R2,Y+12
    0059C 843D      LDD	R3,Y+13
    0059D 844E      LDD	R4,Y+14
    0059E 845F      LDD	R5,Y+15
    0059F 2DE2      MOV	R30,R2
    005A0 70E1      ANDI	R30,1
    005A1 F051      BEQ	0x05AC
    005A2 0157      MOVW	R10,R14
    005A3 94B6      LSR	R11
    005A4 94A7      ROR	R10
    005A5 94B6      LSR	R11
    005A6 94A7      ROR	R10
    005A7 94B6      LSR	R11
    005A8 94A7      ROR	R10
    005A9 94B6      LSR	R11
    005AA 94A7      ROR	R10
    005AB C003      RJMP	0x05AF
    005AC 01C7      MOVW	R24,R14
    005AD 709F      ANDI	R25,0xF
    005AE 015C      MOVW	R10,R24
    005AF 0185      MOVW	R16,R10
    005B0 0196      MOVW	R18,R12
    005B1 2722      CLR	R18
    005B2 2733      CLR	R19
    005B3 C0A8      RJMP	0x065C
(0839) 
(0840) 	case FS_FAT16 :
(0841) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    005B4 E088      LDI	R24,0x8
    005B5 E090      LDI	R25,0
    005B6 850C      LDD	R16,Y+12
    005B7 851D      LDD	R17,Y+13
    005B8 852E      LDD	R18,Y+14
    005B9 853F      LDD	R19,Y+15
    005BA 938A      ST	-Y,R24
    005BB 940E 41AC CALL	lsr32
    005BD 01F6      MOVW	R30,R12
    005BE 8C26      LDD	R2,Z+30
    005BF 8C37      LDD	R3,Z+31
    005C0 A040      LDD	R4,Z+32
    005C1 A051      LDD	R5,Z+33
    005C2 0E20      ADD	R2,R16
    005C3 1E31      ADC	R3,R17
    005C4 1E42      ADC	R4,R18
    005C5 1E53      ADC	R5,R19
    005C6 8248      ST	Y,R4
    005C7 8259      STD	Y+1,R5
    005C8 0191      MOVW	R18,R2
    005C9 018F      MOVW	R16,R30
    005CA DD7D      RCALL	ff.c:move_window
    005CB 2EA0      MOV	R10,R16
    005CC 2300      TST	R16
    005CD F009      BEQ	0x05CF
    005CE C089      RJMP	0x0658
(0842) 		p = &fs->win[clst * 2 % SS(fs)];
    005CF EF4F      LDI	R20,0xFF
    005D0 E051      LDI	R21,1
    005D1 E060      LDI	R22,0
    005D2 E070      LDI	R23,0
    005D3 842C      LDD	R2,Y+12
    005D4 843D      LDD	R3,Y+13
    005D5 844E      LDD	R4,Y+14
    005D6 845F      LDD	R5,Y+15
    005D7 0C22      LSL	R2
    005D8 1C33      ROL	R3
    005D9 1C44      ROL	R4
    005DA 1C55      ROL	R5
    005DB 2224      AND	R2,R20
    005DC 2235      AND	R3,R21
    005DD 2246      AND	R4,R22
    005DE 2257      AND	R5,R23
    005DF 0151      MOVW	R10,R2
    005E0 01C6      MOVW	R24,R12
    005E1 968E      ADIW	R24,0x2E
    005E2 0EA8      ADD	R10,R24
    005E3 1EB9      ADC	R11,R25
(0843) 		return LD_WORD(p);
    005E4 01F5      MOVW	R30,R10
    005E5 8020      LD	R2,Z
    005E6 2433      CLR	R3
    005E7 8101      LDD	R16,Z+1
    005E8 2711      CLR	R17
    005E9 2F10      MOV	R17,R16
    005EA 2700      CLR	R16
    005EB 2902      OR	R16,R2
    005EC 2913      OR	R17,R3
    005ED 2722      CLR	R18
    005EE 2733      CLR	R19
    005EF C06C      RJMP	0x065C
(0844) 
(0845) 	case FS_FAT32 :
(0846) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    005F0 E087      LDI	R24,7
    005F1 E090      LDI	R25,0
    005F2 850C      LDD	R16,Y+12
    005F3 851D      LDD	R17,Y+13
    005F4 852E      LDD	R18,Y+14
    005F5 853F      LDD	R19,Y+15
    005F6 938A      ST	-Y,R24
    005F7 940E 41AC CALL	lsr32
    005F9 01F6      MOVW	R30,R12
    005FA 8C26      LDD	R2,Z+30
    005FB 8C37      LDD	R3,Z+31
    005FC A040      LDD	R4,Z+32
    005FD A051      LDD	R5,Z+33
    005FE 0E20      ADD	R2,R16
    005FF 1E31      ADC	R3,R17
    00600 1E42      ADC	R4,R18
    00601 1E53      ADC	R5,R19
    00602 8248      ST	Y,R4
    00603 8259      STD	Y+1,R5
    00604 0191      MOVW	R18,R2
    00605 018F      MOVW	R16,R30
    00606 DD41      RCALL	ff.c:move_window
    00607 2EE0      MOV	R14,R16
    00608 2300      TST	R16
    00609 F009      BEQ	0x060B
    0060A C04D      RJMP	0x0658
(0847) 		p = &fs->win[clst * 4 % SS(fs)];
    0060B E082      LDI	R24,2
    0060C E090      LDI	R25,0
    0060D 850C      LDD	R16,Y+12
    0060E 851D      LDD	R17,Y+13
    0060F 852E      LDD	R18,Y+14
    00610 853F      LDD	R19,Y+15
    00611 938A      ST	-Y,R24
    00612 940E 4193 CALL	lsl32
    00614 0118      MOVW	R2,R16
    00615 0129      MOVW	R4,R18
    00616 EF4F      LDI	R20,0xFF
    00617 E051      LDI	R21,1
    00618 E060      LDI	R22,0
    00619 E070      LDI	R23,0
    0061A 2224      AND	R2,R20
    0061B 2235      AND	R3,R21
    0061C 2246      AND	R4,R22
    0061D 2257      AND	R5,R23
    0061E 0151      MOVW	R10,R2
    0061F 01C6      MOVW	R24,R12
    00620 968E      ADIW	R24,0x2E
    00621 0EA8      ADD	R10,R24
    00622 1EB9      ADC	R11,R25
(0848) 		return LD_DWORD(p) & 0x0FFFFFFF;
    00623 E188      LDI	R24,0x18
    00624 E090      LDI	R25,0
    00625 01F5      MOVW	R30,R10
    00626 8103      LDD	R16,Z+3
    00627 2711      CLR	R17
    00628 2722      CLR	R18
    00629 2733      CLR	R19
    0062A 938A      ST	-Y,R24
    0062B 940E 4193 CALL	lsl32
    0062D 0118      MOVW	R2,R16
    0062E 0129      MOVW	R4,R18
    0062F 01F5      MOVW	R30,R10
    00630 8062      LDD	R6,Z+2
    00631 2477      CLR	R7
    00632 2488      CLR	R8
    00633 2499      CLR	R9
    00634 0143      MOVW	R8,R6
    00635 2466      CLR	R6
    00636 2477      CLR	R7
    00637 2826      OR	R2,R6
    00638 2837      OR	R3,R7
    00639 2848      OR	R4,R8
    0063A 2859      OR	R5,R9
    0063B 8061      LDD	R6,Z+1
    0063C 2477      CLR	R7
    0063D 2C76      MOV	R7,R6
    0063E 2466      CLR	R6
    0063F 2488      CLR	R8
    00640 2499      CLR	R9
    00641 2826      OR	R2,R6
    00642 2837      OR	R3,R7
    00643 2848      OR	R4,R8
    00644 2859      OR	R5,R9
    00645 8060      LD	R6,Z
    00646 2477      CLR	R7
    00647 2488      CLR	R8
    00648 2499      CLR	R9
    00649 2826      OR	R2,R6
    0064A 2837      OR	R3,R7
    0064B 2848      OR	R4,R8
    0064C 2859      OR	R5,R9
    0064D EF4F      LDI	R20,0xFF
    0064E EF5F      LDI	R21,0xFF
    0064F EF6F      LDI	R22,0xFF
    00650 E07F      LDI	R23,0xF
    00651 2224      AND	R2,R20
    00652 2235      AND	R3,R21
    00653 2246      AND	R4,R22
    00654 2257      AND	R5,R23
    00655 0181      MOVW	R16,R2
    00656 0192      MOVW	R18,R4
    00657 C004      RJMP	0x065C
(0849) 	}
(0850) 
(0851) 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    00658 EF0F      LDI	R16,0xFF
    00659 EF1F      LDI	R17,0xFF
    0065A EF2F      LDI	R18,0xFF
    0065B EF3F      LDI	R19,0xFF
    0065C 9622      ADIW	R28,2
    0065D 940E 4106 CALL	pop_xgsetF0FC
    0065F 9622      ADIW	R28,2
    00660 9508      RET
_put_fat:
  bc                   --> R12
  p                    --> R14
  res                  --> Y,+2
  val                  --> Y,+19
  clst                 --> Y,+15
  fs                   --> Y,+13
    00661 940E 3FCC CALL	push_arg4
    00663 940E 4111 CALL	push_xgsetF0FC
    00665 9723      SBIW	R28,3
(0852) }
(0853) 
(0854) 
(0855) 
(0856) 
(0857) /*-----------------------------------------------------------------------*/
(0858) /* FAT access - Change value of a FAT entry                              */
(0859) /*-----------------------------------------------------------------------*/
(0860) #if !_FS_READONLY
(0861) 
(0862) FRESULT put_fat (
(0863) 	FATFS *fs,	/* File system object */
(0864) 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
(0865) 	DWORD val	/* New value to mark the cluster */
(0866) )
(0867) {
(0868) 	UINT bc;
(0869) 	BYTE *p;
(0870) 	FRESULT res;
(0871) 
(0872) 
(0873) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    00666 E042      LDI	R20,2
    00667 E050      LDI	R21,0
    00668 E060      LDI	R22,0
    00669 E070      LDI	R23,0
    0066A 842F      LDD	R2,Y+15
    0066B 8838      LDD	R3,Y+16
    0066C 8849      LDD	R4,Y+17
    0066D 885A      LDD	R5,Y+18
    0066E 1624      CP	R2,R20
    0066F 0635      CPC	R3,R21
    00670 0646      CPC	R4,R22
    00671 0657      CPC	R5,R23
    00672 F080      BCS	0x0683
    00673 85ED      LDD	R30,Y+13
    00674 85FE      LDD	R31,Y+14
    00675 9676      ADIW	R30,0x16
    00676 8020      LD	R2,Z
    00677 8031      LDD	R3,Z+1
    00678 8042      LDD	R4,Z+2
    00679 8053      LDD	R5,Z+3
    0067A 846F      LDD	R6,Y+15
    0067B 8878      LDD	R7,Y+16
    0067C 8889      LDD	R8,Y+17
    0067D 889A      LDD	R9,Y+18
    0067E 1462      CP	R6,R2
    0067F 0473      CPC	R7,R3
    00680 0484      CPC	R8,R4
    00681 0495      CPC	R9,R5
    00682 F018      BCS	0x0686
(0874) 		res = FR_INT_ERR;
    00683 E082      LDI	R24,2
    00684 838A      STD	Y+2,R24
(0875) 
(0876) 	} else {
    00685 C194      RJMP	0x081A
(0877) 		switch (fs->fs_type) {
    00686 85ED      LDD	R30,Y+13
    00687 85FE      LDD	R31,Y+14
    00688 80A0      LD	R10,Z
    00689 24BB      CLR	R11
    0068A 01C5      MOVW	R24,R10
    0068B 3081      CPI	R24,1
    0068C E0E0      LDI	R30,0
    0068D 079E      CPC	R25,R30
    0068E F059      BEQ	0x069A
    0068F 3082      CPI	R24,2
    00690 E0E0      LDI	R30,0
    00691 079E      CPC	R25,R30
    00692 F409      BNE	0x0694
    00693 C0B0      RJMP	0x0744
    00694 3083      CPI	R24,3
    00695 E0E0      LDI	R30,0
    00696 079E      CPC	R25,R30
    00697 F409      BNE	0x0699
    00698 C0E7      RJMP	0x0780
    00699 C17A      RJMP	0x0814
(0878) 		case FS_FAT12 :
(0879) 			bc = clst; bc += bc / 2;
    0069A 84CF      LDD	R12,Y+15
    0069B 88D8      LDD	R13,Y+16
    0069C 0116      MOVW	R2,R12
    0069D 9436      LSR	R3
    0069E 9427      ROR	R2
    0069F 0CC2      ADD	R12,R2
    006A0 1CD3      ADC	R13,R3
(0880) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006A1 E029      LDI	R18,0x9
    006A2 E030      LDI	R19,0
    006A3 0186      MOVW	R16,R12
    006A4 940E 41A5 CALL	lsr16
    006A6 0118      MOVW	R2,R16
    006A7 2444      CLR	R4
    006A8 2455      CLR	R5
    006A9 85ED      LDD	R30,Y+13
    006AA 85FE      LDD	R31,Y+14
    006AB 8C66      LDD	R6,Z+30
    006AC 8C77      LDD	R7,Z+31
    006AD A080      LDD	R8,Z+32
    006AE A091      LDD	R9,Z+33
    006AF 0C62      ADD	R6,R2
    006B0 1C73      ADC	R7,R3
    006B1 1C84      ADC	R8,R4
    006B2 1C95      ADC	R9,R5
    006B3 8288      ST	Y,R8
    006B4 8299      STD	Y+1,R9
    006B5 0193      MOVW	R18,R6
    006B6 018F      MOVW	R16,R30
    006B7 DC90      RCALL	ff.c:move_window
    006B8 830A      STD	Y+2,R16
(0881) 			if (res != FR_OK) break;
    006B9 2E00      MOV	R0,R16
    006BA 2300      TST	R16
    006BB F009      BEQ	0x06BD
    006BC C159      RJMP	0x0816
(0882) 			p = &fs->win[bc % SS(fs)];
    006BD 858D      LDD	R24,Y+13
    006BE 859E      LDD	R25,Y+14
    006BF 968E      ADIW	R24,0x2E
    006C0 01F6      MOVW	R30,R12
    006C1 70F1      ANDI	R31,1
    006C2 017F      MOVW	R14,R30
    006C3 0EE8      ADD	R14,R24
    006C4 1EF9      ADC	R15,R25
(0883) 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    006C5 842F      LDD	R2,Y+15
    006C6 8838      LDD	R3,Y+16
    006C7 8849      LDD	R4,Y+17
    006C8 885A      LDD	R5,Y+18
    006C9 93EF      PUSH	R30
    006CA 2DE2      MOV	R30,R2
    006CB 70E1      ANDI	R30,1
    006CC 91EF      POP	R30
    006CD F0B1      BEQ	0x06E4
    006CE 882B      LDD	R2,Y+19
    006CF 883C      LDD	R3,Y+20
    006D0 884D      LDD	R4,Y+21
    006D1 885E      LDD	R5,Y+22
    006D2 2433      CLR	R3
    006D3 0C22      LSL	R2
    006D4 1C33      ROL	R3
    006D5 0C22      LSL	R2
    006D6 1C33      ROL	R3
    006D7 0C22      LSL	R2
    006D8 1C33      ROL	R3
    006D9 0C22      LSL	R2
    006DA 1C33      ROL	R3
    006DB 01F7      MOVW	R30,R14
    006DC 8180      LD	R24,Z
    006DD 2799      CLR	R25
    006DE 708F      ANDI	R24,0xF
    006DF 7090      ANDI	R25,0
    006E0 015C      MOVW	R10,R24
    006E1 28A2      OR	R10,R2
    006E2 28B3      OR	R11,R3
    006E3 C006      RJMP	0x06EA
    006E4 882B      LDD	R2,Y+19
    006E5 883C      LDD	R3,Y+20
    006E6 884D      LDD	R4,Y+21
    006E7 885E      LDD	R5,Y+22
    006E8 2CA2      MOV	R10,R2
    006E9 24BB      CLR	R11
    006EA 01F7      MOVW	R30,R14
    006EB 82A0      ST	Z,R10
(0884) 			bc++;
    006EC 01C6      MOVW	R24,R12
    006ED 9601      ADIW	R24,1
    006EE 016C      MOVW	R12,R24
(0885) 			fs->wflag = 1;
    006EF E081      LDI	R24,1
    006F0 85ED      LDD	R30,Y+13
    006F1 85FE      LDD	R31,Y+14
    006F2 8384      STD	Z+4,R24
(0886) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006F3 E029      LDI	R18,0x9
    006F4 E030      LDI	R19,0
    006F5 0186      MOVW	R16,R12
    006F6 940E 41A5 CALL	lsr16
    006F8 0118      MOVW	R2,R16
    006F9 2444      CLR	R4
    006FA 2455      CLR	R5
    006FB 85ED      LDD	R30,Y+13
    006FC 85FE      LDD	R31,Y+14
    006FD 8C66      LDD	R6,Z+30
    006FE 8C77      LDD	R7,Z+31
    006FF A080      LDD	R8,Z+32
    00700 A091      LDD	R9,Z+33
    00701 0C62      ADD	R6,R2
    00702 1C73      ADC	R7,R3
    00703 1C84      ADC	R8,R4
    00704 1C95      ADC	R9,R5
    00705 8288      ST	Y,R8
    00706 8299      STD	Y+1,R9
    00707 0193      MOVW	R18,R6
    00708 018F      MOVW	R16,R30
    00709 DC3E      RCALL	ff.c:move_window
    0070A 830A      STD	Y+2,R16
(0887) 			if (res != FR_OK) break;
    0070B 2E00      MOV	R0,R16
    0070C 2300      TST	R16
    0070D F009      BEQ	0x070F
    0070E C107      RJMP	0x0816
(0888) 			p = &fs->win[bc % SS(fs)];
    0070F 858D      LDD	R24,Y+13
    00710 859E      LDD	R25,Y+14
    00711 968E      ADIW	R24,0x2E
    00712 01F6      MOVW	R30,R12
    00713 70F1      ANDI	R31,1
    00714 017F      MOVW	R14,R30
    00715 0EE8      ADD	R14,R24
    00716 1EF9      ADC	R15,R25
(0889) 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    00717 842F      LDD	R2,Y+15
    00718 8838      LDD	R3,Y+16
    00719 8849      LDD	R4,Y+17
    0071A 885A      LDD	R5,Y+18
    0071B 93EF      PUSH	R30
    0071C 2DE2      MOV	R30,R2
    0071D 70E1      ANDI	R30,1
    0071E 91EF      POP	R30
    0071F F061      BEQ	0x072C
    00720 E084      LDI	R24,4
    00721 E090      LDI	R25,0
    00722 890B      LDD	R16,Y+19
    00723 891C      LDD	R17,Y+20
    00724 892D      LDD	R18,Y+21
    00725 893E      LDD	R19,Y+22
    00726 938A      ST	-Y,R24
    00727 940E 41AC CALL	lsr32
    00729 2EC0      MOV	R12,R16
    0072A 24DD      CLR	R13
    0072B C015      RJMP	0x0741
    0072C E088      LDI	R24,0x8
    0072D E090      LDI	R25,0
    0072E 890B      LDD	R16,Y+19
    0072F 891C      LDD	R17,Y+20
    00730 892D      LDD	R18,Y+21
    00731 893E      LDD	R19,Y+22
    00732 938A      ST	-Y,R24
    00733 940E 41AC CALL	lsr32
    00735 2F80      MOV	R24,R16
    00736 2799      CLR	R25
    00737 708F      ANDI	R24,0xF
    00738 7090      ANDI	R25,0
    00739 01F7      MOVW	R30,R14
    0073A 81E0      LD	R30,Z
    0073B 27FF      CLR	R31
    0073C 7FE0      ANDI	R30,0xF0
    0073D 70F0      ANDI	R31,0
    0073E 016F      MOVW	R12,R30
    0073F 2AC8      OR	R12,R24
    00740 2AD9      OR	R13,R25
    00741 01F7      MOVW	R30,R14
    00742 82C0      ST	Z,R12
(0890) 			break;
    00743 C0D2      RJMP	0x0816
(0891) 
(0892) 		case FS_FAT16 :
(0893) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    00744 E088      LDI	R24,0x8
    00745 E090      LDI	R25,0
    00746 850F      LDD	R16,Y+15
    00747 8918      LDD	R17,Y+16
    00748 8929      LDD	R18,Y+17
    00749 893A      LDD	R19,Y+18
    0074A 938A      ST	-Y,R24
    0074B 940E 41AC CALL	lsr32
    0074D 85ED      LDD	R30,Y+13
    0074E 85FE      LDD	R31,Y+14
    0074F 8C26      LDD	R2,Z+30
    00750 8C37      LDD	R3,Z+31
    00751 A040      LDD	R4,Z+32
    00752 A051      LDD	R5,Z+33
    00753 0E20      ADD	R2,R16
    00754 1E31      ADC	R3,R17
    00755 1E42      ADC	R4,R18
    00756 1E53      ADC	R5,R19
    00757 8248      ST	Y,R4
    00758 8259      STD	Y+1,R5
    00759 0191      MOVW	R18,R2
    0075A 018F      MOVW	R16,R30
    0075B DBEC      RCALL	ff.c:move_window
    0075C 2EC0      MOV	R12,R16
    0075D 82CA      STD	Y+2,R12
(0894) 			if (res != FR_OK) break;
    0075E 2C0C      MOV	R0,R12
    0075F 2300      TST	R16
    00760 F009      BEQ	0x0762
    00761 C0B4      RJMP	0x0816
(0895) 			p = &fs->win[clst * 2 % SS(fs)];
    00762 EF4F      LDI	R20,0xFF
    00763 E051      LDI	R21,1
    00764 E060      LDI	R22,0
    00765 E070      LDI	R23,0
    00766 842F      LDD	R2,Y+15
    00767 8838      LDD	R3,Y+16
    00768 8849      LDD	R4,Y+17
    00769 885A      LDD	R5,Y+18
    0076A 0C22      LSL	R2
    0076B 1C33      ROL	R3
    0076C 1C44      ROL	R4
    0076D 1C55      ROL	R5
    0076E 2224      AND	R2,R20
    0076F 2235      AND	R3,R21
    00770 2246      AND	R4,R22
    00771 2257      AND	R5,R23
    00772 0171      MOVW	R14,R2
    00773 858D      LDD	R24,Y+13
    00774 859E      LDD	R25,Y+14
    00775 968E      ADIW	R24,0x2E
    00776 0EE8      ADD	R14,R24
    00777 1EF9      ADC	R15,R25
(0896) 			ST_WORD(p, (WORD)val);
    00778 882B      LDD	R2,Y+19
    00779 883C      LDD	R3,Y+20
    0077A 01F7      MOVW	R30,R14
    0077B 8220      ST	Z,R2
    0077C 2C23      MOV	R2,R3
    0077D 2433      CLR	R3
    0077E 8221      STD	Z+1,R2
(0897) 			break;
    0077F C096      RJMP	0x0816
(0898) 
(0899) 		case FS_FAT32 :
(0900) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    00780 E087      LDI	R24,7
    00781 E090      LDI	R25,0
    00782 850F      LDD	R16,Y+15
    00783 8918      LDD	R17,Y+16
    00784 8929      LDD	R18,Y+17
    00785 893A      LDD	R19,Y+18
    00786 938A      ST	-Y,R24
    00787 940E 41AC CALL	lsr32
    00789 85ED      LDD	R30,Y+13
    0078A 85FE      LDD	R31,Y+14
    0078B 8C26      LDD	R2,Z+30
    0078C 8C37      LDD	R3,Z+31
    0078D A040      LDD	R4,Z+32
    0078E A051      LDD	R5,Z+33
    0078F 0E20      ADD	R2,R16
    00790 1E31      ADC	R3,R17
    00791 1E42      ADC	R4,R18
    00792 1E53      ADC	R5,R19
    00793 8248      ST	Y,R4
    00794 8259      STD	Y+1,R5
    00795 0191      MOVW	R18,R2
    00796 018F      MOVW	R16,R30
    00797 DBB0      RCALL	ff.c:move_window
    00798 2EC0      MOV	R12,R16
    00799 82CA      STD	Y+2,R12
(0901) 			if (res != FR_OK) break;
    0079A 2C0C      MOV	R0,R12
    0079B 2300      TST	R16
    0079C F009      BEQ	0x079E
    0079D C078      RJMP	0x0816
(0902) 			p = &fs->win[clst * 4 % SS(fs)];
    0079E E082      LDI	R24,2
    0079F E090      LDI	R25,0
    007A0 850F      LDD	R16,Y+15
    007A1 8918      LDD	R17,Y+16
    007A2 8929      LDD	R18,Y+17
    007A3 893A      LDD	R19,Y+18
    007A4 938A      ST	-Y,R24
    007A5 940E 4193 CALL	lsl32
    007A7 0118      MOVW	R2,R16
    007A8 0129      MOVW	R4,R18
    007A9 EF4F      LDI	R20,0xFF
    007AA E051      LDI	R21,1
    007AB E060      LDI	R22,0
    007AC E070      LDI	R23,0
    007AD 2224      AND	R2,R20
    007AE 2235      AND	R3,R21
    007AF 2246      AND	R4,R22
    007B0 2257      AND	R5,R23
    007B1 0171      MOVW	R14,R2
    007B2 858D      LDD	R24,Y+13
    007B3 859E      LDD	R25,Y+14
    007B4 968E      ADIW	R24,0x2E
    007B5 0EE8      ADD	R14,R24
    007B6 1EF9      ADC	R15,R25
(0903) 			val |= LD_DWORD(p) & 0xF0000000;
    007B7 E188      LDI	R24,0x18
    007B8 E090      LDI	R25,0
    007B9 01F7      MOVW	R30,R14
    007BA 8103      LDD	R16,Z+3
    007BB 2711      CLR	R17
    007BC 2722      CLR	R18
    007BD 2733      CLR	R19
    007BE 938A      ST	-Y,R24
    007BF 940E 4193 CALL	lsl32
    007C1 0118      MOVW	R2,R16
    007C2 0129      MOVW	R4,R18
    007C3 01F7      MOVW	R30,R14
    007C4 8062      LDD	R6,Z+2
    007C5 2477      CLR	R7
    007C6 2488      CLR	R8
    007C7 2499      CLR	R9
    007C8 0143      MOVW	R8,R6
    007C9 2466      CLR	R6
    007CA 2477      CLR	R7
    007CB 2826      OR	R2,R6
    007CC 2837      OR	R3,R7
    007CD 2848      OR	R4,R8
    007CE 2859      OR	R5,R9
    007CF 8061      LDD	R6,Z+1
    007D0 2477      CLR	R7
    007D1 2C76      MOV	R7,R6
    007D2 2466      CLR	R6
    007D3 2488      CLR	R8
    007D4 2499      CLR	R9
    007D5 2826      OR	R2,R6
    007D6 2837      OR	R3,R7
    007D7 2848      OR	R4,R8
    007D8 2859      OR	R5,R9
    007D9 8060      LD	R6,Z
    007DA 2477      CLR	R7
    007DB 2488      CLR	R8
    007DC 2499      CLR	R9
    007DD 2826      OR	R2,R6
    007DE 2837      OR	R3,R7
    007DF 2848      OR	R4,R8
    007E0 2859      OR	R5,R9
    007E1 E040      LDI	R20,0
    007E2 E050      LDI	R21,0
    007E3 E060      LDI	R22,0
    007E4 EF70      LDI	R23,0xF0
    007E5 2224      AND	R2,R20
    007E6 2235      AND	R3,R21
    007E7 2246      AND	R4,R22
    007E8 2257      AND	R5,R23
    007E9 886B      LDD	R6,Y+19
    007EA 887C      LDD	R7,Y+20
    007EB 888D      LDD	R8,Y+21
    007EC 889E      LDD	R9,Y+22
    007ED 2862      OR	R6,R2
    007EE 2873      OR	R7,R3
    007EF 2884      OR	R8,R4
    007F0 2895      OR	R9,R5
    007F1 8A6B      STD	Y+19,R6
    007F2 8A7C      STD	Y+20,R7
    007F3 8A8D      STD	Y+21,R8
    007F4 8A9E      STD	Y+22,R9
(0904) 			ST_DWORD(p, val);
    007F5 882B      LDD	R2,Y+19
    007F6 883C      LDD	R3,Y+20
    007F7 884D      LDD	R4,Y+21
    007F8 885E      LDD	R5,Y+22
    007F9 8220      ST	Z,R2
    007FA 2C23      MOV	R2,R3
    007FB 2433      CLR	R3
    007FC 9631      ADIW	R30,1
    007FD 8220      ST	Z,R2
    007FE 882B      LDD	R2,Y+19
    007FF 883C      LDD	R3,Y+20
    00800 884D      LDD	R4,Y+21
    00801 885E      LDD	R5,Y+22
    00802 0112      MOVW	R2,R4
    00803 2444      CLR	R4
    00804 2455      CLR	R5
    00805 01F7      MOVW	R30,R14
    00806 9632      ADIW	R30,2
    00807 8220      ST	Z,R2
    00808 E188      LDI	R24,0x18
    00809 E090      LDI	R25,0
    0080A 890B      LDD	R16,Y+19
    0080B 891C      LDD	R17,Y+20
    0080C 892D      LDD	R18,Y+21
    0080D 893E      LDD	R19,Y+22
    0080E 938A      ST	-Y,R24
    0080F 940E 41AC CALL	lsr32
    00811 01F7      MOVW	R30,R14
    00812 8303      STD	Z+3,R16
(0905) 			break;
    00813 C002      RJMP	0x0816
(0906) 
(0907) 		default :
(0908) 			res = FR_INT_ERR;
    00814 E082      LDI	R24,2
    00815 838A      STD	Y+2,R24
(0909) 		}
(0910) 		fs->wflag = 1;
    00816 E081      LDI	R24,1
    00817 85ED      LDD	R30,Y+13
    00818 85FE      LDD	R31,Y+14
    00819 8384      STD	Z+4,R24
(0911) 	}
(0912) 
(0913) 	return res;
    0081A 810A      LDD	R16,Y+2
    0081B 9623      ADIW	R28,3
    0081C 940E 4106 CALL	pop_xgsetF0FC
    0081E 9624      ADIW	R28,4
    0081F 9508      RET
ff.c:remove_chain:
  res                  --> R10
  nxt                  --> Y,+6
  clst                 --> Y,+18
  fs                   --> R12
    00820 933A      ST	-Y,R19
    00821 932A      ST	-Y,R18
    00822 940E 414C CALL	push_xgsetF03C
    00824 0168      MOVW	R12,R16
    00825 972A      SBIW	R28,0xA
(0914) }
(0915) #endif /* !_FS_READONLY */
(0916) 
(0917) 
(0918) 
(0919) 
(0920) /*-----------------------------------------------------------------------*/
(0921) /* FAT handling - Remove a cluster chain                                 */
(0922) /*-----------------------------------------------------------------------*/
(0923) #if !_FS_READONLY
(0924) static
(0925) FRESULT remove_chain (
(0926) 	FATFS *fs,			/* File system object */
(0927) 	DWORD clst			/* Cluster# to remove a chain from */
(0928) )
(0929) {
(0930) 	FRESULT res;
(0931) 	DWORD nxt;
(0932) #if _USE_ERASE
(0933) 	DWORD scl = clst, ecl = clst, resion[2];
(0934) #endif
(0935) 
(0936) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    00826 E042      LDI	R20,2
    00827 E050      LDI	R21,0
    00828 E060      LDI	R22,0
    00829 E070      LDI	R23,0
    0082A 882A      LDD	R2,Y+18
    0082B 883B      LDD	R3,Y+19
    0082C 884C      LDD	R4,Y+20
    0082D 885D      LDD	R5,Y+21
    0082E 1624      CP	R2,R20
    0082F 0635      CPC	R3,R21
    00830 0646      CPC	R4,R22
    00831 0657      CPC	R5,R23
    00832 F078      BCS	0x0842
    00833 01F6      MOVW	R30,R12
    00834 9676      ADIW	R30,0x16
    00835 8020      LD	R2,Z
    00836 8031      LDD	R3,Z+1
    00837 8042      LDD	R4,Z+2
    00838 8053      LDD	R5,Z+3
    00839 886A      LDD	R6,Y+18
    0083A 887B      LDD	R7,Y+19
    0083B 888C      LDD	R8,Y+20
    0083C 889D      LDD	R9,Y+21
    0083D 1462      CP	R6,R2
    0083E 0473      CPC	R7,R3
    0083F 0484      CPC	R8,R4
    00840 0495      CPC	R9,R5
    00841 F018      BCS	0x0845
(0937) 		res = FR_INT_ERR;
    00842 E082      LDI	R24,2
    00843 2EA8      MOV	R10,R24
(0938) 
(0939) 	} else {
    00844 C088      RJMP	0x08CD
(0940) 		res = FR_OK;
    00845 24AA      CLR	R10
    00846 C076      RJMP	0x08BD
(0941) 		while (clst < fs->n_fatent) {			/* Not a last link? */
(0942) 			nxt = get_fat(fs, clst);			/* Get cluster status */
    00847 882A      LDD	R2,Y+18
    00848 883B      LDD	R3,Y+19
    00849 884C      LDD	R4,Y+20
    0084A 885D      LDD	R5,Y+21
    0084B 8248      ST	Y,R4
    0084C 8259      STD	Y+1,R5
    0084D 0191      MOVW	R18,R2
    0084E 0186      MOVW	R16,R12
    0084F DCC1      RCALL	_get_fat
    00850 830E      STD	Y+6,R16
    00851 831F      STD	Y+7,R17
    00852 8728      STD	Y+8,R18
    00853 8739      STD	Y+9,R19
(0943) 			if (nxt == 0) break;				/* Empty cluster? */
    00854 802E      LDD	R2,Y+6
    00855 803F      LDD	R3,Y+7
    00856 8448      LDD	R4,Y+8
    00857 8459      LDD	R5,Y+9
    00858 9488      BCLR	0
    00859 2022      TST	R2
    0085A 0432      CPC	R3,R2
    0085B 0442      CPC	R4,R2
    0085C 0452      CPC	R5,R2
    0085D F409      BNE	0x085F
    0085E C06E      RJMP	0x08CD
(0944) 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    0085F E041      LDI	R20,1
    00860 E050      LDI	R21,0
    00861 E060      LDI	R22,0
    00862 E070      LDI	R23,0
    00863 802E      LDD	R2,Y+6
    00864 803F      LDD	R3,Y+7
    00865 8448      LDD	R4,Y+8
    00866 8459      LDD	R5,Y+9
    00867 1624      CP	R2,R20
    00868 0635      CPC	R3,R21
    00869 0646      CPC	R4,R22
    0086A 0657      CPC	R5,R23
    0086B F419      BNE	0x086F
    0086C E082      LDI	R24,2
    0086D 2EA8      MOV	R10,R24
    0086E C05E      RJMP	0x08CD
(0945) 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    0086F EF4F      LDI	R20,0xFF
    00870 EF5F      LDI	R21,0xFF
    00871 EF6F      LDI	R22,0xFF
    00872 EF7F      LDI	R23,0xFF
    00873 802E      LDD	R2,Y+6
    00874 803F      LDD	R3,Y+7
    00875 8448      LDD	R4,Y+8
    00876 8459      LDD	R5,Y+9
    00877 1624      CP	R2,R20
    00878 0635      CPC	R3,R21
    00879 0646      CPC	R4,R22
    0087A 0657      CPC	R5,R23
    0087B F419      BNE	0x087F
    0087C 24AA      CLR	R10
    0087D 94A3      INC	R10
    0087E C04E      RJMP	0x08CD
(0946) 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    0087F E080      LDI	R24,0
    00880 838A      STD	Y+2,R24
    00881 838B      STD	Y+3,R24
    00882 838C      STD	Y+4,R24
    00883 838D      STD	Y+5,R24
    00884 882A      LDD	R2,Y+18
    00885 883B      LDD	R3,Y+19
    00886 884C      LDD	R4,Y+20
    00887 885D      LDD	R5,Y+21
    00888 8248      ST	Y,R4
    00889 8259      STD	Y+1,R5
    0088A 0191      MOVW	R18,R2
    0088B 0186      MOVW	R16,R12
    0088C DDD4      RCALL	_put_fat
    0088D 2EA0      MOV	R10,R16
(0947) 			if (res != FR_OK) break;
    0088E 2300      TST	R16
    0088F F009      BEQ	0x0891
    00890 C03C      RJMP	0x08CD
(0948) 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    00891 EF4F      LDI	R20,0xFF
    00892 EF5F      LDI	R21,0xFF
    00893 EF6F      LDI	R22,0xFF
    00894 EF7F      LDI	R23,0xFF
    00895 01F6      MOVW	R30,R12
    00896 8426      LDD	R2,Z+14
    00897 8437      LDD	R3,Z+15
    00898 8840      LDD	R4,Z+16
    00899 8851      LDD	R5,Z+17
    0089A 1624      CP	R2,R20
    0089B 0635      CPC	R3,R21
    0089C 0646      CPC	R4,R22
    0089D 0657      CPC	R5,R23
    0089E F0B1      BEQ	0x08B5
(0949) 				fs->free_clust++;
    0089F 01CF      MOVW	R24,R30
    008A0 960E      ADIW	R24,0xE
    008A1 E041      LDI	R20,1
    008A2 E050      LDI	R21,0
    008A3 E060      LDI	R22,0
    008A4 E070      LDI	R23,0
    008A5 01FC      MOVW	R30,R24
    008A6 8020      LD	R2,Z
    008A7 8031      LDD	R3,Z+1
    008A8 8042      LDD	R4,Z+2
    008A9 8053      LDD	R5,Z+3
    008AA 0E24      ADD	R2,R20
    008AB 1E35      ADC	R3,R21
    008AC 1E46      ADC	R4,R22
    008AD 1E57      ADC	R5,R23
    008AE 8220      ST	Z,R2
    008AF 8231      STD	Z+1,R3
    008B0 8242      STD	Z+2,R4
    008B1 8253      STD	Z+3,R5
(0950) 				fs->fsi_flag = 1;
    008B2 E081      LDI	R24,1
    008B3 01F6      MOVW	R30,R12
    008B4 8385      STD	Z+5,R24
(0951) 			}
(0952) #if _USE_ERASE
(0953) 			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
(0954) 				ecl = nxt;
(0955) 			} else {				/* End of contiguous clusters */ 
(0956) 				resion[0] = clust2sect(fs, scl);					/* Start sector */
(0957) 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
(0958) 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
(0959) 				scl = ecl = nxt;
(0960) 			}
(0961) #endif
(0962) 			clst = nxt;	/* Next cluster */
    008B5 802E      LDD	R2,Y+6
    008B6 803F      LDD	R3,Y+7
    008B7 8448      LDD	R4,Y+8
    008B8 8459      LDD	R5,Y+9
    008B9 8A2A      STD	Y+18,R2
    008BA 8A3B      STD	Y+19,R3
    008BB 8A4C      STD	Y+20,R4
    008BC 8A5D      STD	Y+21,R5
    008BD 01F6      MOVW	R30,R12
    008BE 9676      ADIW	R30,0x16
    008BF 8020      LD	R2,Z
    008C0 8031      LDD	R3,Z+1
    008C1 8042      LDD	R4,Z+2
    008C2 8053      LDD	R5,Z+3
    008C3 886A      LDD	R6,Y+18
    008C4 887B      LDD	R7,Y+19
    008C5 888C      LDD	R8,Y+20
    008C6 889D      LDD	R9,Y+21
    008C7 1462      CP	R6,R2
    008C8 0473      CPC	R7,R3
    008C9 0484      CPC	R8,R4
    008CA 0495      CPC	R9,R5
    008CB F408      BCC	0x08CD
    008CC CF7A      RJMP	0x0847
(0963) 		}
(0964) 	}
(0965) 
(0966) 	return res;
    008CD 2D0A      MOV	R16,R10
    008CE 962A      ADIW	R28,0xA
    008CF 940E 4155 CALL	pop_xgsetF03C
    008D1 9622      ADIW	R28,2
    008D2 9508      RET
ff.c:create_chain:
  res                  --> R10
  scl                  --> Y,+14
  cs                   --> Y,+10
  ncl                  --> Y,+6
  clst                 --> Y,+32
  fs                   --> R12
    008D3 933A      ST	-Y,R19
    008D4 932A      ST	-Y,R18
    008D5 940E 4111 CALL	push_xgsetF0FC
    008D7 0168      MOVW	R12,R16
    008D8 9766      SBIW	R28,0x16
(0967) }
(0968) #endif
(0969) 
(0970) 
(0971) 
(0972) 
(0973) /*-----------------------------------------------------------------------*/
(0974) /* FAT handling - Stretch or Create a cluster chain                      */
(0975) /*-----------------------------------------------------------------------*/
(0976) #if !_FS_READONLY
(0977) static
(0978) DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
(0979) 	FATFS *fs,			/* File system object */
(0980) 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
(0981) )
(0982) {
(0983) 	DWORD cs, ncl, scl;
(0984) 	FRESULT res;
(0985) 
(0986) 
(0987) 	if (clst == 0) {		/* Create a new chain */
    008D9 A028      LDD	R2,Y+32
    008DA A039      LDD	R3,Y+33
    008DB A04A      LDD	R4,Y+34
    008DC A05B      LDD	R5,Y+35
    008DD 9488      BCLR	0
    008DE 2022      TST	R2
    008DF 0432      CPC	R3,R2
    008E0 0442      CPC	R4,R2
    008E1 0452      CPC	R5,R2
    008E2 F559      BNE	0x090E
(0988) 		scl = fs->last_clust;			/* Get suggested start point */
    008E3 01F6      MOVW	R30,R12
    008E4 963A      ADIW	R30,0xA
    008E5 8020      LD	R2,Z
    008E6 8031      LDD	R3,Z+1
    008E7 8042      LDD	R4,Z+2
    008E8 8053      LDD	R5,Z+3
    008E9 862E      STD	Y+14,R2
    008EA 863F      STD	Y+15,R3
    008EB 8A48      STD	Y+16,R4
    008EC 8A59      STD	Y+17,R5
(0989) 		if (!scl || scl >= fs->n_fatent) scl = 1;
    008ED 842E      LDD	R2,Y+14
    008EE 843F      LDD	R3,Y+15
    008EF 8848      LDD	R4,Y+16
    008F0 8859      LDD	R5,Y+17
    008F1 9488      BCLR	0
    008F2 2022      TST	R2
    008F3 0432      CPC	R3,R2
    008F4 0442      CPC	R4,R2
    008F5 0452      CPC	R5,R2
    008F6 F081      BEQ	0x0907
    008F7 01F6      MOVW	R30,R12
    008F8 9676      ADIW	R30,0x16
    008F9 8020      LD	R2,Z
    008FA 8031      LDD	R3,Z+1
    008FB 8042      LDD	R4,Z+2
    008FC 8053      LDD	R5,Z+3
    008FD 846E      LDD	R6,Y+14
    008FE 847F      LDD	R7,Y+15
    008FF 8888      LDD	R8,Y+16
    00900 8899      LDD	R9,Y+17
    00901 1462      CP	R6,R2
    00902 0473      CPC	R7,R3
    00903 0484      CPC	R8,R4
    00904 0495      CPC	R9,R5
    00905 F408      BCC	0x0907
    00906 C040      RJMP	0x0947
    00907 E081      LDI	R24,1
    00908 878E      STD	Y+14,R24
    00909 E080      LDI	R24,0
    0090A 878F      STD	Y+15,R24
    0090B 8B88      STD	Y+16,R24
    0090C 8B89      STD	Y+17,R24
(0990) 	}
    0090D C039      RJMP	0x0947
(0991) 	else {					/* Stretch the current chain */
(0992) 		cs = get_fat(fs, clst);			/* Check the cluster status */
    0090E A028      LDD	R2,Y+32
    0090F A039      LDD	R3,Y+33
    00910 A04A      LDD	R4,Y+34
    00911 A05B      LDD	R5,Y+35
    00912 8248      ST	Y,R4
    00913 8259      STD	Y+1,R5
    00914 0191      MOVW	R18,R2
    00915 0186      MOVW	R16,R12
    00916 DBFA      RCALL	_get_fat
    00917 870A      STD	Y+10,R16
    00918 871B      STD	Y+11,R17
    00919 872C      STD	Y+12,R18
    0091A 873D      STD	Y+13,R19
(0993) 		if (cs < 2) return 1;			/* It is an invalid cluster */
    0091B E042      LDI	R20,2
    0091C E050      LDI	R21,0
    0091D E060      LDI	R22,0
    0091E E070      LDI	R23,0
    0091F 842A      LDD	R2,Y+10
    00920 843B      LDD	R3,Y+11
    00921 844C      LDD	R4,Y+12
    00922 845D      LDD	R5,Y+13
    00923 1624      CP	R2,R20
    00924 0635      CPC	R3,R21
    00925 0646      CPC	R4,R22
    00926 0657      CPC	R5,R23
    00927 F428      BCC	0x092D
    00928 E001      LDI	R16,1
    00929 E010      LDI	R17,0
    0092A E020      LDI	R18,0
    0092B E030      LDI	R19,0
    0092C C119      RJMP	0x0A46
(0994) 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    0092D 01F6      MOVW	R30,R12
    0092E 9676      ADIW	R30,0x16
    0092F 8020      LD	R2,Z
    00930 8031      LDD	R3,Z+1
    00931 8042      LDD	R4,Z+2
    00932 8053      LDD	R5,Z+3
    00933 846A      LDD	R6,Y+10
    00934 847B      LDD	R7,Y+11
    00935 848C      LDD	R8,Y+12
    00936 849D      LDD	R9,Y+13
    00937 1462      CP	R6,R2
    00938 0473      CPC	R7,R3
    00939 0484      CPC	R8,R4
    0093A 0495      CPC	R9,R5
    0093B F418      BCC	0x093F
    0093C 0183      MOVW	R16,R6
    0093D 0194      MOVW	R18,R8
    0093E C107      RJMP	0x0A46
(0995) 		scl = clst;
    0093F A028      LDD	R2,Y+32
    00940 A039      LDD	R3,Y+33
    00941 A04A      LDD	R4,Y+34
    00942 A05B      LDD	R5,Y+35
    00943 862E      STD	Y+14,R2
    00944 863F      STD	Y+15,R3
    00945 8A48      STD	Y+16,R4
    00946 8A59      STD	Y+17,R5
(0996) 	}
(0997) 
(0998) 	ncl = scl;				/* Start cluster */
    00947 842E      LDD	R2,Y+14
    00948 843F      LDD	R3,Y+15
    00949 8848      LDD	R4,Y+16
    0094A 8859      LDD	R5,Y+17
    0094B 822E      STD	Y+6,R2
    0094C 823F      STD	Y+7,R3
    0094D 8648      STD	Y+8,R4
    0094E 8659      STD	Y+9,R5
(0999) 	for (;;) {
(1000) 		ncl++;							/* Next cluster */
    0094F E041      LDI	R20,1
    00950 E050      LDI	R21,0
    00951 E060      LDI	R22,0
    00952 E070      LDI	R23,0
    00953 802E      LDD	R2,Y+6
    00954 803F      LDD	R3,Y+7
    00955 8448      LDD	R4,Y+8
    00956 8459      LDD	R5,Y+9
    00957 0E24      ADD	R2,R20
    00958 1E35      ADC	R3,R21
    00959 1E46      ADC	R4,R22
    0095A 1E57      ADC	R5,R23
    0095B 822E      STD	Y+6,R2
    0095C 823F      STD	Y+7,R3
    0095D 8648      STD	Y+8,R4
    0095E 8659      STD	Y+9,R5
(1001) 		if (ncl >= fs->n_fatent) {		/* Wrap around */
    0095F 01F6      MOVW	R30,R12
    00960 9676      ADIW	R30,0x16
    00961 8020      LD	R2,Z
    00962 8031      LDD	R3,Z+1
    00963 8042      LDD	R4,Z+2
    00964 8053      LDD	R5,Z+3
    00965 806E      LDD	R6,Y+6
    00966 807F      LDD	R7,Y+7
    00967 8488      LDD	R8,Y+8
    00968 8499      LDD	R9,Y+9
    00969 1462      CP	R6,R2
    0096A 0473      CPC	R7,R3
    0096B 0484      CPC	R8,R4
    0096C 0495      CPC	R9,R5
    0096D F0C0      BCS	0x0986
(1002) 			ncl = 2;
    0096E E082      LDI	R24,2
    0096F 838E      STD	Y+6,R24
    00970 E080      LDI	R24,0
    00971 838F      STD	Y+7,R24
    00972 8788      STD	Y+8,R24
    00973 8789      STD	Y+9,R24
(1003) 			if (ncl > scl) return 0;	/* No free cluster */
    00974 842E      LDD	R2,Y+14
    00975 843F      LDD	R3,Y+15
    00976 8848      LDD	R4,Y+16
    00977 8859      LDD	R5,Y+17
    00978 806E      LDD	R6,Y+6
    00979 807F      LDD	R7,Y+7
    0097A 8488      LDD	R8,Y+8
    0097B 8499      LDD	R9,Y+9
    0097C 1426      CP	R2,R6
    0097D 0437      CPC	R3,R7
    0097E 0448      CPC	R4,R8
    0097F 0459      CPC	R5,R9
    00980 F428      BCC	0x0986
    00981 E000      LDI	R16,0
    00982 E010      LDI	R17,0
    00983 E020      LDI	R18,0
    00984 E030      LDI	R19,0
    00985 C0C0      RJMP	0x0A46
(1004) 		}
(1005) 		cs = get_fat(fs, ncl);			/* Get the cluster status */
    00986 802E      LDD	R2,Y+6
    00987 803F      LDD	R3,Y+7
    00988 8448      LDD	R4,Y+8
    00989 8459      LDD	R5,Y+9
    0098A 8248      ST	Y,R4
    0098B 8259      STD	Y+1,R5
    0098C 0191      MOVW	R18,R2
    0098D 0186      MOVW	R16,R12
    0098E DB82      RCALL	_get_fat
    0098F 870A      STD	Y+10,R16
    00990 871B      STD	Y+11,R17
    00991 872C      STD	Y+12,R18
    00992 873D      STD	Y+13,R19
(1006) 		if (cs == 0) break;				/* Found a free cluster */
    00993 842A      LDD	R2,Y+10
    00994 843B      LDD	R3,Y+11
    00995 844C      LDD	R4,Y+12
    00996 845D      LDD	R5,Y+13
    00997 9488      BCLR	0
    00998 2022      TST	R2
    00999 0432      CPC	R3,R2
    0099A 0442      CPC	R4,R2
    0099B 0452      CPC	R5,R2
    0099C F409      BNE	0x099E
    0099D C02E      RJMP	0x09CC
(1007) 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    0099E EF4F      LDI	R20,0xFF
    0099F EF5F      LDI	R21,0xFF
    009A0 EF6F      LDI	R22,0xFF
    009A1 EF7F      LDI	R23,0xFF
    009A2 842A      LDD	R2,Y+10
    009A3 843B      LDD	R3,Y+11
    009A4 844C      LDD	R4,Y+12
    009A5 845D      LDD	R5,Y+13
    009A6 1624      CP	R2,R20
    009A7 0635      CPC	R3,R21
    009A8 0646      CPC	R4,R22
    009A9 0657      CPC	R5,R23
    009AA F049      BEQ	0x09B4
    009AB E041      LDI	R20,1
    009AC E050      LDI	R21,0
    009AD E060      LDI	R22,0
    009AE E070      LDI	R23,0
    009AF 1624      CP	R2,R20
    009B0 0635      CPC	R3,R21
    009B1 0646      CPC	R4,R22
    009B2 0657      CPC	R5,R23
    009B3 F429      BNE	0x09B9
(1008) 			return cs;
    009B4 850A      LDD	R16,Y+10
    009B5 851B      LDD	R17,Y+11
    009B6 852C      LDD	R18,Y+12
    009B7 853D      LDD	R19,Y+13
    009B8 C08D      RJMP	0x0A46
(1009) 		if (ncl == scl) return 0;		/* No free cluster */
    009B9 842E      LDD	R2,Y+14
    009BA 843F      LDD	R3,Y+15
    009BB 8848      LDD	R4,Y+16
    009BC 8859      LDD	R5,Y+17
    009BD 806E      LDD	R6,Y+6
    009BE 807F      LDD	R7,Y+7
    009BF 8488      LDD	R8,Y+8
    009C0 8499      LDD	R9,Y+9
    009C1 1462      CP	R6,R2
    009C2 0473      CPC	R7,R3
    009C3 0484      CPC	R8,R4
    009C4 0495      CPC	R9,R5
    009C5 F009      BEQ	0x09C7
    009C6 CF88      RJMP	0x094F
    009C7 E000      LDI	R16,0
    009C8 E010      LDI	R17,0
    009C9 E020      LDI	R18,0
    009CA E030      LDI	R19,0
    009CB C07A      RJMP	0x0A46
(1010) 	}
(1011) 
(1012) 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    009CC EF8F      LDI	R24,0xFF
    009CD 838A      STD	Y+2,R24
    009CE 838B      STD	Y+3,R24
    009CF 838C      STD	Y+4,R24
    009D0 E08F      LDI	R24,0xF
    009D1 838D      STD	Y+5,R24
    009D2 802E      LDD	R2,Y+6
    009D3 803F      LDD	R3,Y+7
    009D4 8448      LDD	R4,Y+8
    009D5 8459      LDD	R5,Y+9
    009D6 8248      ST	Y,R4
    009D7 8259      STD	Y+1,R5
    009D8 0191      MOVW	R18,R2
    009D9 0186      MOVW	R16,R12
    009DA DC86      RCALL	_put_fat
    009DB 2EA0      MOV	R10,R16
(1013) 	if (res == FR_OK && clst != 0) {
    009DC 2300      TST	R16
    009DD F4E1      BNE	0x09FA
    009DE A028      LDD	R2,Y+32
    009DF A039      LDD	R3,Y+33
    009E0 A04A      LDD	R4,Y+34
    009E1 A05B      LDD	R5,Y+35
    009E2 9488      BCLR	0
    009E3 2022      TST	R2
    009E4 0432      CPC	R3,R2
    009E5 0442      CPC	R4,R2
    009E6 0452      CPC	R5,R2
    009E7 F091      BEQ	0x09FA
(1014) 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    009E8 802E      LDD	R2,Y+6
    009E9 803F      LDD	R3,Y+7
    009EA 8448      LDD	R4,Y+8
    009EB 8459      LDD	R5,Y+9
    009EC 822A      STD	Y+2,R2
    009ED 823B      STD	Y+3,R3
    009EE 824C      STD	Y+4,R4
    009EF 825D      STD	Y+5,R5
    009F0 A028      LDD	R2,Y+32
    009F1 A039      LDD	R3,Y+33
    009F2 A04A      LDD	R4,Y+34
    009F3 A05B      LDD	R5,Y+35
    009F4 8248      ST	Y,R4
    009F5 8259      STD	Y+1,R5
    009F6 0191      MOVW	R18,R2
    009F7 0186      MOVW	R16,R12
    009F8 DC68      RCALL	_put_fat
    009F9 2EA0      MOV	R10,R16
(1015) 	}
(1016) 	if (res == FR_OK) {
    009FA 20AA      TST	R10
    009FB F009      BEQ	0x09FD
    009FC C02E      RJMP	0x0A2B
(1017) 		fs->last_clust = ncl;			/* Update FSINFO */
    009FD 802E      LDD	R2,Y+6
    009FE 803F      LDD	R3,Y+7
    009FF 8448      LDD	R4,Y+8
    00A00 8459      LDD	R5,Y+9
    00A01 01F6      MOVW	R30,R12
    00A02 8622      STD	Z+10,R2
    00A03 8633      STD	Z+11,R3
    00A04 8644      STD	Z+12,R4
    00A05 8655      STD	Z+13,R5
(1018) 		if (fs->free_clust != 0xFFFFFFFF) {
    00A06 EF4F      LDI	R20,0xFF
    00A07 EF5F      LDI	R21,0xFF
    00A08 EF6F      LDI	R22,0xFF
    00A09 EF7F      LDI	R23,0xFF
    00A0A 8426      LDD	R2,Z+14
    00A0B 8437      LDD	R3,Z+15
    00A0C 8840      LDD	R4,Z+16
    00A0D 8851      LDD	R5,Z+17
    00A0E 1624      CP	R2,R20
    00A0F 0635      CPC	R3,R21
    00A10 0646      CPC	R4,R22
    00A11 0657      CPC	R5,R23
    00A12 F179      BEQ	0x0A42
(1019) 			fs->free_clust--;
    00A13 01CF      MOVW	R24,R30
    00A14 960E      ADIW	R24,0xE
    00A15 017C      MOVW	R14,R24
    00A16 E041      LDI	R20,1
    00A17 E050      LDI	R21,0
    00A18 E060      LDI	R22,0
    00A19 E070      LDI	R23,0
    00A1A 01FC      MOVW	R30,R24
    00A1B 8020      LD	R2,Z
    00A1C 8031      LDD	R3,Z+1
    00A1D 8042      LDD	R4,Z+2
    00A1E 8053      LDD	R5,Z+3
    00A1F 1A24      SUB	R2,R20
    00A20 0A35      SBC	R3,R21
    00A21 0A46      SBC	R4,R22
    00A22 0A57      SBC	R5,R23
    00A23 8220      ST	Z,R2
    00A24 8231      STD	Z+1,R3
    00A25 8242      STD	Z+2,R4
    00A26 8253      STD	Z+3,R5
(1020) 			fs->fsi_flag = 1;
    00A27 E081      LDI	R24,1
    00A28 01F6      MOVW	R30,R12
    00A29 8385      STD	Z+5,R24
(1021) 		}
(1022) 	} else {
    00A2A C017      RJMP	0x0A42
(1023) 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    00A2B 2D8A      MOV	R24,R10
    00A2C 3081      CPI	R24,1
    00A2D F431      BNE	0x0A34
    00A2E EF8F      LDI	R24,0xFF
    00A2F 8B8A      STD	Y+18,R24
    00A30 8B8B      STD	Y+19,R24
    00A31 8B8C      STD	Y+20,R24
    00A32 8B8D      STD	Y+21,R24
    00A33 C006      RJMP	0x0A3A
    00A34 E081      LDI	R24,1
    00A35 8B8A      STD	Y+18,R24
    00A36 E080      LDI	R24,0
    00A37 8B8B      STD	Y+19,R24
    00A38 8B8C      STD	Y+20,R24
    00A39 8B8D      STD	Y+21,R24
    00A3A 882A      LDD	R2,Y+18
    00A3B 883B      LDD	R3,Y+19
    00A3C 884C      LDD	R4,Y+20
    00A3D 885D      LDD	R5,Y+21
    00A3E 822E      STD	Y+6,R2
    00A3F 823F      STD	Y+7,R3
    00A40 8648      STD	Y+8,R4
    00A41 8659      STD	Y+9,R5
(1024) 	}
(1025) 
(1026) 	return ncl;		/* Return new cluster number or error code */
    00A42 810E      LDD	R16,Y+6
    00A43 811F      LDD	R17,Y+7
    00A44 8528      LDD	R18,Y+8
    00A45 8539      LDD	R19,Y+9
    00A46 9666      ADIW	R28,0x16
    00A47 940E 4106 CALL	pop_xgsetF0FC
    00A49 9622      ADIW	R28,2
    00A4A 9508      RET
ff.c:clmt_clust:
  tbl                  --> R10
  cl                   --> Y,+4
  ncl                  --> Y,+0
  ofs                  --> Y,+12
  fp                   --> R12
    00A4B 933A      ST	-Y,R19
    00A4C 932A      ST	-Y,R18
    00A4D 940E 4117 CALL	push_xgset003C
    00A4F 0168      MOVW	R12,R16
    00A50 9728      SBIW	R28,0x8
(1027) }
(1028) #endif /* !_FS_READONLY */
(1029) 
(1030) 
(1031) 
(1032) /*-----------------------------------------------------------------------*/
(1033) /* FAT handling - Convert offset into cluster with link map table        */
(1034) /*-----------------------------------------------------------------------*/
(1035) 
(1036) #if _USE_FASTSEEK
(1037) static
(1038) DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
(1039) 	FIL* fp,		/* Pointer to the file object */
(1040) 	DWORD ofs		/* File offset to be converted to cluster# */
(1041) )
(1042) {
(1043) 	DWORD cl, ncl, *tbl;
(1044) 
(1045) 
(1046) 	tbl = fp->cltbl + 1;	/* Top of CLMT */
    00A51 01F6      MOVW	R30,R12
    00A52 96B0      ADIW	R30,0x20
    00A53 8180      LD	R24,Z
    00A54 8191      LDD	R25,Z+1
    00A55 9604      ADIW	R24,4
    00A56 015C      MOVW	R10,R24
(1047) 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
    00A57 E089      LDI	R24,0x9
    00A58 E090      LDI	R25,0
    00A59 850C      LDD	R16,Y+12
    00A5A 851D      LDD	R17,Y+13
    00A5B 852E      LDD	R18,Y+14
    00A5C 853F      LDD	R19,Y+15
    00A5D 938A      ST	-Y,R24
    00A5E 940E 41AC CALL	lsr32
    00A60 01F6      MOVW	R30,R12
    00A61 93AF      PUSH	R26
    00A62 93BF      PUSH	R27
    00A63 81A0      LD	R26,Z
    00A64 81B1      LDD	R27,Z+1
    00A65 01FD      MOVW	R30,R26
    00A66 91BF      POP	R27
    00A67 91AF      POP	R26
    00A68 9632      ADIW	R30,2
    00A69 8020      LD	R2,Z
    00A6A 2433      CLR	R3
    00A6B 2444      CLR	R4
    00A6C 2455      CLR	R5
    00A6D 925A      ST	-Y,R5
    00A6E 924A      ST	-Y,R4
    00A6F 923A      ST	-Y,R3
    00A70 922A      ST	-Y,R2
    00A71 940E 4017 CALL	div32u
    00A73 830C      STD	Y+4,R16
    00A74 831D      STD	Y+5,R17
    00A75 832E      STD	Y+6,R18
    00A76 833F      STD	Y+7,R19
(1048) 	for (;;) {
(1049) 		ncl = *tbl++;			/* Number of cluters in the fragment */
    00A77 01F5      MOVW	R30,R10
    00A78 9021      LD	R2,Z+
    00A79 9031      LD	R3,Z+
    00A7A 9041      LD	R4,Z+
    00A7B 9051      LD	R5,Z+
    00A7C 015F      MOVW	R10,R30
    00A7D 8228      ST	Y,R2
    00A7E 8239      STD	Y+1,R3
    00A7F 824A      STD	Y+2,R4
    00A80 825B      STD	Y+3,R5
(1050) 		if (!ncl) return 0;		/* End of table? (error) */
    00A81 8028      LD	R2,Y
    00A82 8039      LDD	R3,Y+1
    00A83 804A      LDD	R4,Y+2
    00A84 805B      LDD	R5,Y+3
    00A85 9488      BCLR	0
    00A86 2022      TST	R2
    00A87 0432      CPC	R3,R2
    00A88 0442      CPC	R4,R2
    00A89 0452      CPC	R5,R2
    00A8A F429      BNE	0x0A90
    00A8B E000      LDI	R16,0
    00A8C E010      LDI	R17,0
    00A8D E020      LDI	R18,0
    00A8E E030      LDI	R19,0
    00A8F C02F      RJMP	0x0ABF
(1051) 		if (cl < ncl) break;	/* In this fragment? */
    00A90 8028      LD	R2,Y
    00A91 8039      LDD	R3,Y+1
    00A92 804A      LDD	R4,Y+2
    00A93 805B      LDD	R5,Y+3
    00A94 806C      LDD	R6,Y+4
    00A95 807D      LDD	R7,Y+5
    00A96 808E      LDD	R8,Y+6
    00A97 809F      LDD	R9,Y+7
    00A98 1462      CP	R6,R2
    00A99 0473      CPC	R7,R3
    00A9A 0484      CPC	R8,R4
    00A9B 0495      CPC	R9,R5
    00A9C F408      BCC	0x0A9E
    00A9D C014      RJMP	0x0AB2
(1052) 		cl -= ncl; tbl++;		/* Next fragment */
    00A9E 8028      LD	R2,Y
    00A9F 8039      LDD	R3,Y+1
    00AA0 804A      LDD	R4,Y+2
    00AA1 805B      LDD	R5,Y+3
    00AA2 806C      LDD	R6,Y+4
    00AA3 807D      LDD	R7,Y+5
    00AA4 808E      LDD	R8,Y+6
    00AA5 809F      LDD	R9,Y+7
    00AA6 1862      SUB	R6,R2
    00AA7 0873      SBC	R7,R3
    00AA8 0884      SBC	R8,R4
    00AA9 0895      SBC	R9,R5
    00AAA 826C      STD	Y+4,R6
    00AAB 827D      STD	Y+5,R7
    00AAC 828E      STD	Y+6,R8
    00AAD 829F      STD	Y+7,R9
    00AAE 01C5      MOVW	R24,R10
    00AAF 9604      ADIW	R24,4
    00AB0 015C      MOVW	R10,R24
    00AB1 CFC5      RJMP	0x0A77
(1053) 	}
(1054) 	return cl + *tbl;	/* Return the cluster number */
    00AB2 01F5      MOVW	R30,R10
    00AB3 8020      LD	R2,Z
    00AB4 8031      LDD	R3,Z+1
    00AB5 8042      LDD	R4,Z+2
    00AB6 8053      LDD	R5,Z+3
    00AB7 810C      LDD	R16,Y+4
    00AB8 811D      LDD	R17,Y+5
    00AB9 812E      LDD	R18,Y+6
    00ABA 813F      LDD	R19,Y+7
    00ABB 0D02      ADD	R16,R2
    00ABC 1D13      ADC	R17,R3
    00ABD 1D24      ADC	R18,R4
    00ABE 1D35      ADC	R19,R5
    00ABF 9628      ADIW	R28,0x8
    00AC0 940E 40F1 CALL	pop_xgset003C
    00AC2 9622      ADIW	R28,2
    00AC3 9508      RET
ff.c:dir_sdi:
  ic                   --> R14
  clst                 --> Y,+2
  idx                  --> R12
  dj                   --> R10
    00AC4 940E 4111 CALL	push_xgsetF0FC
    00AC6 0169      MOVW	R12,R18
    00AC7 0158      MOVW	R10,R16
    00AC8 9726      SBIW	R28,6
(1055) }
(1056) #endif	/* _USE_FASTSEEK */
(1057) 
(1058) 
(1059) 
(1060) /*-----------------------------------------------------------------------*/
(1061) /* Directory handling - Set directory index                              */
(1062) /*-----------------------------------------------------------------------*/
(1063) 
(1064) static
(1065) FRESULT dir_sdi (
(1066) 	DIR *dj,		/* Pointer to directory object */
(1067) 	WORD idx		/* Directory index number */
(1068) )
(1069) {
(1070) 	DWORD clst;
(1071) 	WORD ic;
(1072) 
(1073) 
(1074) 	dj->index = idx;
    00AC9 01F5      MOVW	R30,R10
    00ACA 82D5      STD	Z+5,R13
    00ACB 82C4      STD	Z+4,R12
(1075) 	clst = dj->sclust;
    00ACC 9636      ADIW	R30,6
    00ACD 8020      LD	R2,Z
    00ACE 8031      LDD	R3,Z+1
    00ACF 8042      LDD	R4,Z+2
    00AD0 8053      LDD	R5,Z+3
    00AD1 822A      STD	Y+2,R2
    00AD2 823B      STD	Y+3,R3
    00AD3 824C      STD	Y+4,R4
    00AD4 825D      STD	Y+5,R5
(1076) 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    00AD5 E041      LDI	R20,1
    00AD6 E050      LDI	R21,0
    00AD7 E060      LDI	R22,0
    00AD8 E070      LDI	R23,0
    00AD9 802A      LDD	R2,Y+2
    00ADA 803B      LDD	R3,Y+3
    00ADB 804C      LDD	R4,Y+4
    00ADC 805D      LDD	R5,Y+5
    00ADD 1624      CP	R2,R20
    00ADE 0635      CPC	R3,R21
    00ADF 0646      CPC	R4,R22
    00AE0 0657      CPC	R5,R23
    00AE1 F089      BEQ	0x0AF3
    00AE2 01F5      MOVW	R30,R10
    00AE3 81A0      LD	R26,Z
    00AE4 81B1      LDD	R27,Z+1
    00AE5 9656      ADIW	R26,0x16
    00AE6 902D      LD	R2,X+
    00AE7 903D      LD	R3,X+
    00AE8 904D      LD	R4,X+
    00AE9 905C      LD	R5,X
    00AEA 806A      LDD	R6,Y+2
    00AEB 807B      LDD	R7,Y+3
    00AEC 808C      LDD	R8,Y+4
    00AED 809D      LDD	R9,Y+5
    00AEE 1462      CP	R6,R2
    00AEF 0473      CPC	R7,R3
    00AF0 0484      CPC	R8,R4
    00AF1 0495      CPC	R9,R5
    00AF2 F010      BCS	0x0AF5
(1077) 		return FR_INT_ERR;
    00AF3 E002      LDI	R16,2
    00AF4 C0D6      RJMP	0x0BCB
(1078) 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    00AF5 802A      LDD	R2,Y+2
    00AF6 803B      LDD	R3,Y+3
    00AF7 804C      LDD	R4,Y+4
    00AF8 805D      LDD	R5,Y+5
    00AF9 9488      BCLR	0
    00AFA 2022      TST	R2
    00AFB 0432      CPC	R3,R2
    00AFC 0442      CPC	R4,R2
    00AFD 0452      CPC	R5,R2
    00AFE F479      BNE	0x0B0E
    00AFF 01F5      MOVW	R30,R10
    00B00 81A0      LD	R26,Z
    00B01 81B1      LDD	R27,Z+1
    00B02 918C      LD	R24,X
    00B03 3083      CPI	R24,3
    00B04 F449      BNE	0x0B0E
(1079) 		clst = dj->fs->dirbase;
    00B05 9692      ADIW	R26,0x22
    00B06 902D      LD	R2,X+
    00B07 903D      LD	R3,X+
    00B08 904D      LD	R4,X+
    00B09 905C      LD	R5,X
    00B0A 822A      STD	Y+2,R2
    00B0B 823B      STD	Y+3,R3
    00B0C 824C      STD	Y+4,R4
    00B0D 825D      STD	Y+5,R5
(1080) 
(1081) 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    00B0E 802A      LDD	R2,Y+2
    00B0F 803B      LDD	R3,Y+3
    00B10 804C      LDD	R4,Y+4
    00B11 805D      LDD	R5,Y+5
    00B12 9488      BCLR	0
    00B13 2022      TST	R2
    00B14 0432      CPC	R3,R2
    00B15 0442      CPC	R4,R2
    00B16 0452      CPC	R5,R2
    00B17 F009      BEQ	0x0B19
    00B18 C02B      RJMP	0x0B44
(1082) 		dj->clust = clst;
    00B19 01F5      MOVW	R30,R10
    00B1A 8622      STD	Z+10,R2
    00B1B 8633      STD	Z+11,R3
    00B1C 8644      STD	Z+12,R4
    00B1D 8655      STD	Z+13,R5
(1083) 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    00B1E 81A0      LD	R26,Z
    00B1F 81B1      LDD	R27,Z+1
    00B20 9618      ADIW	R26,0x8
    00B21 902D      LD	R2,X+
    00B22 903C      LD	R3,X
    00B23 14C2      CP	R12,R2
    00B24 04D3      CPC	R13,R3
    00B25 F010      BCS	0x0B28
(1084) 			return FR_INT_ERR;
    00B26 E002      LDI	R16,2
    00B27 C0A3      RJMP	0x0BCB
(1085) 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B28 0116      MOVW	R2,R12
    00B29 9436      LSR	R3
    00B2A 9427      ROR	R2
    00B2B 9436      LSR	R3
    00B2C 9427      ROR	R2
    00B2D 9436      LSR	R3
    00B2E 9427      ROR	R2
    00B2F 9436      LSR	R3
    00B30 9427      ROR	R2
    00B31 2444      CLR	R4
    00B32 2455      CLR	R5
    00B33 01F5      MOVW	R30,R10
    00B34 81A0      LD	R26,Z
    00B35 81B1      LDD	R27,Z+1
    00B36 9692      ADIW	R26,0x22
    00B37 906D      LD	R6,X+
    00B38 907D      LD	R7,X+
    00B39 908D      LD	R8,X+
    00B3A 909C      LD	R9,X
    00B3B 0C62      ADD	R6,R2
    00B3C 1C73      ADC	R7,R3
    00B3D 1C84      ADC	R8,R4
    00B3E 1C95      ADC	R9,R5
    00B3F 8666      STD	Z+14,R6
    00B40 8677      STD	Z+15,R7
    00B41 8A80      STD	Z+16,R8
    00B42 8A91      STD	Z+17,R9
(1086) 	}
    00B43 C076      RJMP	0x0BBA
(1087) 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
(1088) 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    00B44 01F5      MOVW	R30,R10
    00B45 93AF      PUSH	R26
    00B46 93BF      PUSH	R27
    00B47 81A0      LD	R26,Z
    00B48 81B1      LDD	R27,Z+1
    00B49 01FD      MOVW	R30,R26
    00B4A 91BF      POP	R27
    00B4B 91AF      POP	R26
    00B4C 8022      LDD	R2,Z+2
    00B4D E180      LDI	R24,0x10
    00B4E 9D82      MUL	R24,R2
    00B4F 0170      MOVW	R14,R0
    00B50 C040      RJMP	0x0B91
(1089) 		while (idx >= ic) {	/* Follow cluster chain */
(1090) 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    00B51 802A      LDD	R2,Y+2
    00B52 803B      LDD	R3,Y+3
    00B53 804C      LDD	R4,Y+4
    00B54 805D      LDD	R5,Y+5
    00B55 8248      ST	Y,R4
    00B56 8259      STD	Y+1,R5
    00B57 0191      MOVW	R18,R2
    00B58 01F5      MOVW	R30,R10
    00B59 8100      LD	R16,Z
    00B5A 8111      LDD	R17,Z+1
    00B5B D9B5      RCALL	_get_fat
    00B5C 830A      STD	Y+2,R16
    00B5D 831B      STD	Y+3,R17
    00B5E 832C      STD	Y+4,R18
    00B5F 833D      STD	Y+5,R19
(1091) 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    00B60 EF4F      LDI	R20,0xFF
    00B61 EF5F      LDI	R21,0xFF
    00B62 EF6F      LDI	R22,0xFF
    00B63 EF7F      LDI	R23,0xFF
    00B64 802A      LDD	R2,Y+2
    00B65 803B      LDD	R3,Y+3
    00B66 804C      LDD	R4,Y+4
    00B67 805D      LDD	R5,Y+5
    00B68 1624      CP	R2,R20
    00B69 0635      CPC	R3,R21
    00B6A 0646      CPC	R4,R22
    00B6B 0657      CPC	R5,R23
    00B6C F411      BNE	0x0B6F
    00B6D E001      LDI	R16,1
    00B6E C05C      RJMP	0x0BCB
(1092) 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    00B6F E042      LDI	R20,2
    00B70 E050      LDI	R21,0
    00B71 E060      LDI	R22,0
    00B72 E070      LDI	R23,0
    00B73 802A      LDD	R2,Y+2
    00B74 803B      LDD	R3,Y+3
    00B75 804C      LDD	R4,Y+4
    00B76 805D      LDD	R5,Y+5
    00B77 1624      CP	R2,R20
    00B78 0635      CPC	R3,R21
    00B79 0646      CPC	R4,R22
    00B7A 0657      CPC	R5,R23
    00B7B F088      BCS	0x0B8D
    00B7C 01F5      MOVW	R30,R10
    00B7D 81A0      LD	R26,Z
    00B7E 81B1      LDD	R27,Z+1
    00B7F 9656      ADIW	R26,0x16
    00B80 902D      LD	R2,X+
    00B81 903D      LD	R3,X+
    00B82 904D      LD	R4,X+
    00B83 905C      LD	R5,X
    00B84 806A      LDD	R6,Y+2
    00B85 807B      LDD	R7,Y+3
    00B86 808C      LDD	R8,Y+4
    00B87 809D      LDD	R9,Y+5
    00B88 1462      CP	R6,R2
    00B89 0473      CPC	R7,R3
    00B8A 0484      CPC	R8,R4
    00B8B 0495      CPC	R9,R5
    00B8C F010      BCS	0x0B8F
(1093) 				return FR_INT_ERR;
    00B8D E002      LDI	R16,2
    00B8E C03C      RJMP	0x0BCB
(1094) 			idx -= ic;
    00B8F 18CE      SUB	R12,R14
    00B90 08DF      SBC	R13,R15
    00B91 14CE      CP	R12,R14
    00B92 04DF      CPC	R13,R15
    00B93 F008      BCS	0x0B95
    00B94 CFBC      RJMP	0x0B51
(1095) 		}
(1096) 		dj->clust = clst;
    00B95 802A      LDD	R2,Y+2
    00B96 803B      LDD	R3,Y+3
    00B97 804C      LDD	R4,Y+4
    00B98 805D      LDD	R5,Y+5
    00B99 01F5      MOVW	R30,R10
    00B9A 8622      STD	Z+10,R2
    00B9B 8633      STD	Z+11,R3
    00B9C 8644      STD	Z+12,R4
    00B9D 8655      STD	Z+13,R5
(1097) 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B9E 8248      ST	Y,R4
    00B9F 8259      STD	Y+1,R5
    00BA0 0191      MOVW	R18,R2
    00BA1 8100      LD	R16,Z
    00BA2 8111      LDD	R17,Z+1
    00BA3 D91B      RCALL	_clust2sect
    00BA4 0116      MOVW	R2,R12
    00BA5 9436      LSR	R3
    00BA6 9427      ROR	R2
    00BA7 9436      LSR	R3
    00BA8 9427      ROR	R2
    00BA9 9436      LSR	R3
    00BAA 9427      ROR	R2
    00BAB 9436      LSR	R3
    00BAC 9427      ROR	R2
    00BAD 2444      CLR	R4
    00BAE 2455      CLR	R5
    00BAF 0138      MOVW	R6,R16
    00BB0 0149      MOVW	R8,R18
    00BB1 0C62      ADD	R6,R2
    00BB2 1C73      ADC	R7,R3
    00BB3 1C84      ADC	R8,R4
    00BB4 1C95      ADC	R9,R5
    00BB5 01F5      MOVW	R30,R10
    00BB6 8666      STD	Z+14,R6
    00BB7 8677      STD	Z+15,R7
    00BB8 8A80      STD	Z+16,R8
    00BB9 8A91      STD	Z+17,R9
(1098) 	}
(1099) 
(1100) 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    00BBA 0196      MOVW	R18,R12
    00BBB 702F      ANDI	R18,0xF
    00BBC 7030      ANDI	R19,0
    00BBD E200      LDI	R16,0x20
    00BBE E010      LDI	R17,0
    00BBF 940E 40AD CALL	empy16s
    00BC1 0118      MOVW	R2,R16
    00BC2 01F5      MOVW	R30,R10
    00BC3 8180      LD	R24,Z
    00BC4 8191      LDD	R25,Z+1
    00BC5 968E      ADIW	R24,0x2E
    00BC6 0E28      ADD	R2,R24
    00BC7 1E39      ADC	R3,R25
    00BC8 8A33      STD	Z+19,R3
    00BC9 8A22      STD	Z+18,R2
(1101) 
(1102) 	return FR_OK;	/* Seek succeeded */
    00BCA 2700      CLR	R16
    00BCB 9626      ADIW	R28,6
    00BCC 940C 4106 JMP	pop_xgsetF0FC
ff.c:dir_next:
  c                    --> R10
  clst                 --> Y,+2
  i                    --> R12
  stretch              --> R10
  dj                   --> Y,+16
    00BCE 940E 3FCC CALL	push_arg4
    00BD0 940E 4111 CALL	push_xgsetF0FC
    00BD2 0159      MOVW	R10,R18
    00BD3 9726      SBIW	R28,6
(1103) }
(1104) 
(1105) 
(1106) 
(1107) 
(1108) /*-----------------------------------------------------------------------*/
(1109) /* Directory handling - Move directory index next                        */
(1110) /*-----------------------------------------------------------------------*/
(1111) 
(1112) static
(1113) FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
(1114) 	DIR *dj,		/* Pointer to directory object */
(1115) 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
(1116) )
(1117) {
(1118) 	DWORD clst;
(1119) 	WORD i;
(1120) 
(1121) 
(1122) 	stretch = stretch;		/* To suppress warning on read-only cfg. */
(1123) 	i = dj->index + 1;
    00BD4 89E8      LDD	R30,Y+16
    00BD5 89F9      LDD	R31,Y+17
    00BD6 8184      LDD	R24,Z+4
    00BD7 8195      LDD	R25,Z+5
    00BD8 9601      ADIW	R24,1
    00BD9 016C      MOVW	R12,R24
(1124) 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    00BDA 3080      CPI	R24,0
    00BDB 0789      CPC	R24,R25
    00BDC F059      BEQ	0x0BE8
    00BDD 963E      ADIW	R30,0xE
    00BDE 8020      LD	R2,Z
    00BDF 8031      LDD	R3,Z+1
    00BE0 8042      LDD	R4,Z+2
    00BE1 8053      LDD	R5,Z+3
    00BE2 9488      BCLR	0
    00BE3 2022      TST	R2
    00BE4 0432      CPC	R3,R2
    00BE5 0442      CPC	R4,R2
    00BE6 0452      CPC	R5,R2
    00BE7 F411      BNE	0x0BEA
(1125) 		return FR_NO_FILE;
    00BE8 E004      LDI	R16,4
    00BE9 C18D      RJMP	0x0D77
(1126) 
(1127) 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    00BEA 01C6      MOVW	R24,R12
    00BEB 708F      ANDI	R24,0xF
    00BEC 7090      ANDI	R25,0
    00BED 3080      CPI	R24,0
    00BEE 0789      CPC	R24,R25
    00BEF F009      BEQ	0x0BF1
    00BF0 C170      RJMP	0x0D61
(1128) 		dj->sect++;					/* Next sector */
    00BF1 8988      LDD	R24,Y+16
    00BF2 8999      LDD	R25,Y+17
    00BF3 960E      ADIW	R24,0xE
    00BF4 E041      LDI	R20,1
    00BF5 E050      LDI	R21,0
    00BF6 E060      LDI	R22,0
    00BF7 E070      LDI	R23,0
    00BF8 01FC      MOVW	R30,R24
    00BF9 8020      LD	R2,Z
    00BFA 8031      LDD	R3,Z+1
    00BFB 8042      LDD	R4,Z+2
    00BFC 8053      LDD	R5,Z+3
    00BFD 0E24      ADD	R2,R20
    00BFE 1E35      ADC	R3,R21
    00BFF 1E46      ADC	R4,R22
    00C00 1E57      ADC	R5,R23
    00C01 8220      ST	Z,R2
    00C02 8231      STD	Z+1,R3
    00C03 8242      STD	Z+2,R4
    00C04 8253      STD	Z+3,R5
(1129) 
(1130) 		if (dj->clust == 0) {	/* Static table */
    00C05 89E8      LDD	R30,Y+16
    00C06 89F9      LDD	R31,Y+17
    00C07 963A      ADIW	R30,0xA
    00C08 8020      LD	R2,Z
    00C09 8031      LDD	R3,Z+1
    00C0A 8042      LDD	R4,Z+2
    00C0B 8053      LDD	R5,Z+3
    00C0C 9488      BCLR	0
    00C0D 2022      TST	R2
    00C0E 0432      CPC	R3,R2
    00C0F 0442      CPC	R4,R2
    00C10 0452      CPC	R5,R2
    00C11 F469      BNE	0x0C1F
(1131) 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    00C12 89E8      LDD	R30,Y+16
    00C13 89F9      LDD	R31,Y+17
    00C14 81A0      LD	R26,Z
    00C15 81B1      LDD	R27,Z+1
    00C16 9618      ADIW	R26,0x8
    00C17 902D      LD	R2,X+
    00C18 903C      LD	R3,X
    00C19 14C2      CP	R12,R2
    00C1A 04D3      CPC	R13,R3
    00C1B F408      BCC	0x0C1D
    00C1C C144      RJMP	0x0D61
(1132) 				return FR_NO_FILE;
    00C1D E004      LDI	R16,4
    00C1E C158      RJMP	0x0D77
(1133) 		}
(1134) 		else {					/* Dynamic table */
(1135) 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    00C1F 89E8      LDD	R30,Y+16
    00C20 89F9      LDD	R31,Y+17
    00C21 93AF      PUSH	R26
    00C22 93BF      PUSH	R27
    00C23 81A0      LD	R26,Z
    00C24 81B1      LDD	R27,Z+1
    00C25 01FD      MOVW	R30,R26
    00C26 91BF      POP	R27
    00C27 91AF      POP	R26
    00C28 8182      LDD	R24,Z+2
    00C29 2799      CLR	R25
    00C2A 9701      SBIW	R24,1
    00C2B 0116      MOVW	R2,R12
    00C2C 9436      LSR	R3
    00C2D 9427      ROR	R2
    00C2E 9436      LSR	R3
    00C2F 9427      ROR	R2
    00C30 9436      LSR	R3
    00C31 9427      ROR	R2
    00C32 9436      LSR	R3
    00C33 9427      ROR	R2
    00C34 2228      AND	R2,R24
    00C35 2239      AND	R3,R25
    00C36 2022      TST	R2
    00C37 F009      BEQ	0x0C39
    00C38 C128      RJMP	0x0D61
    00C39 2033      TST	R3
    00C3A F009      BEQ	0x0C3C
    00C3B C125      RJMP	0x0D61
(1136) 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    00C3C 89E8      LDD	R30,Y+16
    00C3D 89F9      LDD	R31,Y+17
    00C3E 8422      LDD	R2,Z+10
    00C3F 8433      LDD	R3,Z+11
    00C40 8444      LDD	R4,Z+12
    00C41 8455      LDD	R5,Z+13
    00C42 8248      ST	Y,R4
    00C43 8259      STD	Y+1,R5
    00C44 0191      MOVW	R18,R2
    00C45 8100      LD	R16,Z
    00C46 8111      LDD	R17,Z+1
    00C47 D8C9      RCALL	_get_fat
    00C48 830A      STD	Y+2,R16
    00C49 831B      STD	Y+3,R17
    00C4A 832C      STD	Y+4,R18
    00C4B 833D      STD	Y+5,R19
(1137) 				if (clst <= 1) return FR_INT_ERR;
    00C4C E041      LDI	R20,1
    00C4D E050      LDI	R21,0
    00C4E E060      LDI	R22,0
    00C4F E070      LDI	R23,0
    00C50 802A      LDD	R2,Y+2
    00C51 803B      LDD	R3,Y+3
    00C52 804C      LDD	R4,Y+4
    00C53 805D      LDD	R5,Y+5
    00C54 1542      CP	R20,R2
    00C55 0553      CPC	R21,R3
    00C56 0564      CPC	R22,R4
    00C57 0575      CPC	R23,R5
    00C58 F010      BCS	0x0C5B
    00C59 E002      LDI	R16,2
    00C5A C11C      RJMP	0x0D77
(1138) 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C5B EF4F      LDI	R20,0xFF
    00C5C EF5F      LDI	R21,0xFF
    00C5D EF6F      LDI	R22,0xFF
    00C5E EF7F      LDI	R23,0xFF
    00C5F 802A      LDD	R2,Y+2
    00C60 803B      LDD	R3,Y+3
    00C61 804C      LDD	R4,Y+4
    00C62 805D      LDD	R5,Y+5
    00C63 1624      CP	R2,R20
    00C64 0635      CPC	R3,R21
    00C65 0646      CPC	R4,R22
    00C66 0657      CPC	R5,R23
    00C67 F411      BNE	0x0C6A
    00C68 E001      LDI	R16,1
    00C69 C10D      RJMP	0x0D77
(1139) 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    00C6A 89E8      LDD	R30,Y+16
    00C6B 89F9      LDD	R31,Y+17
    00C6C 81A0      LD	R26,Z
    00C6D 81B1      LDD	R27,Z+1
    00C6E 9656      ADIW	R26,0x16
    00C6F 902D      LD	R2,X+
    00C70 903D      LD	R3,X+
    00C71 904D      LD	R4,X+
    00C72 905C      LD	R5,X
    00C73 806A      LDD	R6,Y+2
    00C74 807B      LDD	R7,Y+3
    00C75 808C      LDD	R8,Y+4
    00C76 809D      LDD	R9,Y+5
    00C77 1462      CP	R6,R2
    00C78 0473      CPC	R7,R3
    00C79 0484      CPC	R8,R4
    00C7A 0495      CPC	R9,R5
    00C7B F408      BCC	0x0C7D
    00C7C C0CD      RJMP	0x0D4A
(1140) #if !_FS_READONLY
(1141) 					BYTE c;
(1142) 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    00C7D 20AA      TST	R10
    00C7E F421      BNE	0x0C83
    00C7F 20BB      TST	R11
    00C80 F411      BNE	0x0C83
    00C81 E004      LDI	R16,4
    00C82 C0F4      RJMP	0x0D77
(1143) 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    00C83 89E8      LDD	R30,Y+16
    00C84 89F9      LDD	R31,Y+17
    00C85 8422      LDD	R2,Z+10
    00C86 8433      LDD	R3,Z+11
    00C87 8444      LDD	R4,Z+12
    00C88 8455      LDD	R5,Z+13
    00C89 8248      ST	Y,R4
    00C8A 8259      STD	Y+1,R5
    00C8B 0191      MOVW	R18,R2
    00C8C 8100      LD	R16,Z
    00C8D 8111      LDD	R17,Z+1
    00C8E DC44      RCALL	ff.c:create_chain
    00C8F 830A      STD	Y+2,R16
    00C90 831B      STD	Y+3,R17
    00C91 832C      STD	Y+4,R18
    00C92 833D      STD	Y+5,R19
(1144) 					if (clst == 0) return FR_DENIED;			/* No free cluster */
    00C93 802A      LDD	R2,Y+2
    00C94 803B      LDD	R3,Y+3
    00C95 804C      LDD	R4,Y+4
    00C96 805D      LDD	R5,Y+5
    00C97 9488      BCLR	0
    00C98 2022      TST	R2
    00C99 0432      CPC	R3,R2
    00C9A 0442      CPC	R4,R2
    00C9B 0452      CPC	R5,R2
    00C9C F411      BNE	0x0C9F
    00C9D E007      LDI	R16,7
    00C9E C0D8      RJMP	0x0D77
(1145) 					if (clst == 1) return FR_INT_ERR;
    00C9F E041      LDI	R20,1
    00CA0 E050      LDI	R21,0
    00CA1 E060      LDI	R22,0
    00CA2 E070      LDI	R23,0
    00CA3 802A      LDD	R2,Y+2
    00CA4 803B      LDD	R3,Y+3
    00CA5 804C      LDD	R4,Y+4
    00CA6 805D      LDD	R5,Y+5
    00CA7 1624      CP	R2,R20
    00CA8 0635      CPC	R3,R21
    00CA9 0646      CPC	R4,R22
    00CAA 0657      CPC	R5,R23
    00CAB F411      BNE	0x0CAE
    00CAC E002      LDI	R16,2
    00CAD C0C9      RJMP	0x0D77
(1146) 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00CAE EF4F      LDI	R20,0xFF
    00CAF EF5F      LDI	R21,0xFF
    00CB0 EF6F      LDI	R22,0xFF
    00CB1 EF7F      LDI	R23,0xFF
    00CB2 802A      LDD	R2,Y+2
    00CB3 803B      LDD	R3,Y+3
    00CB4 804C      LDD	R4,Y+4
    00CB5 805D      LDD	R5,Y+5
    00CB6 1624      CP	R2,R20
    00CB7 0635      CPC	R3,R21
    00CB8 0646      CPC	R4,R22
    00CB9 0657      CPC	R5,R23
    00CBA F411      BNE	0x0CBD
    00CBB E001      LDI	R16,1
    00CBC C0BA      RJMP	0x0D77
(1147) 					/* Clean-up stretched table */
(1148) 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    00CBD E040      LDI	R20,0
    00CBE E050      LDI	R21,0
    00CBF E060      LDI	R22,0
    00CC0 E070      LDI	R23,0
    00CC1 8368      ST	Y,R22
    00CC2 8379      STD	Y+1,R23
    00CC3 019A      MOVW	R18,R20
    00CC4 89E8      LDD	R30,Y+16
    00CC5 89F9      LDD	R31,Y+17
    00CC6 8100      LD	R16,Z
    00CC7 8111      LDD	R17,Z+1
    00CC8 940E 0348 CALL	ff.c:move_window
    00CCA 2300      TST	R16
    00CCB F011      BEQ	0x0CCE
    00CCC E001      LDI	R16,1
    00CCD C0A9      RJMP	0x0D77
(1149) 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    00CCE E080      LDI	R24,0
    00CCF E092      LDI	R25,2
    00CD0 8399      STD	Y+1,R25
    00CD1 8388      ST	Y,R24
    00CD2 2722      CLR	R18
    00CD3 2733      CLR	R19
    00CD4 89E8      LDD	R30,Y+16
    00CD5 89F9      LDD	R31,Y+17
    00CD6 8100      LD	R16,Z
    00CD7 8111      LDD	R17,Z+1
    00CD8 5D02      SUBI	R16,0xD2
    00CD9 4F1F      SBCI	R17,0xFF
    00CDA 940E 0305 CALL	ff.c:mem_set
(1150) 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    00CDC 802A      LDD	R2,Y+2
    00CDD 803B      LDD	R3,Y+3
    00CDE 804C      LDD	R4,Y+4
    00CDF 805D      LDD	R5,Y+5
    00CE0 8248      ST	Y,R4
    00CE1 8259      STD	Y+1,R5
    00CE2 0191      MOVW	R18,R2
    00CE3 89E8      LDD	R30,Y+16
    00CE4 89F9      LDD	R31,Y+17
    00CE5 80A0      LD	R10,Z
    00CE6 80B1      LDD	R11,Z+1
    00CE7 0185      MOVW	R16,R10
    00CE8 940E 04BF CALL	_clust2sect
    00CEA 01F5      MOVW	R30,R10
    00CEB A702      STD	Z+42,R16
    00CEC A713      STD	Z+43,R17
    00CED A724      STD	Z+44,R18
    00CEE A735      STD	Z+45,R19
(1151) 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    00CEF 24AA      CLR	R10
    00CF0 C035      RJMP	0x0D26
(1152) 						dj->fs->wflag = 1;
    00CF1 E081      LDI	R24,1
    00CF2 89E8      LDD	R30,Y+16
    00CF3 89F9      LDD	R31,Y+17
    00CF4 93AF      PUSH	R26
    00CF5 93BF      PUSH	R27
    00CF6 81A0      LD	R26,Z
    00CF7 81B1      LDD	R27,Z+1
    00CF8 01FD      MOVW	R30,R26
    00CF9 91BF      POP	R27
    00CFA 91AF      POP	R26
    00CFB 8384      STD	Z+4,R24
(1153) 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    00CFC E040      LDI	R20,0
    00CFD E050      LDI	R21,0
    00CFE E060      LDI	R22,0
    00CFF E070      LDI	R23,0
    00D00 8368      ST	Y,R22
    00D01 8379      STD	Y+1,R23
    00D02 019A      MOVW	R18,R20
    00D03 89E8      LDD	R30,Y+16
    00D04 89F9      LDD	R31,Y+17
    00D05 8100      LD	R16,Z
    00D06 8111      LDD	R17,Z+1
    00D07 940E 0348 CALL	ff.c:move_window
    00D09 2EE0      MOV	R14,R16
    00D0A 2300      TST	R16
    00D0B F011      BEQ	0x0D0E
    00D0C E001      LDI	R16,1
    00D0D C069      RJMP	0x0D77
(1154) 						dj->fs->winsect++;
    00D0E 89E8      LDD	R30,Y+16
    00D0F 89F9      LDD	R31,Y+17
    00D10 8180      LD	R24,Z
    00D11 8191      LDD	R25,Z+1
    00D12 968A      ADIW	R24,0x2A
    00D13 017C      MOVW	R14,R24
    00D14 E041      LDI	R20,1
    00D15 E050      LDI	R21,0
    00D16 E060      LDI	R22,0
    00D17 E070      LDI	R23,0
    00D18 01FC      MOVW	R30,R24
    00D19 8020      LD	R2,Z
    00D1A 8031      LDD	R3,Z+1
    00D1B 8042      LDD	R4,Z+2
    00D1C 8053      LDD	R5,Z+3
    00D1D 0E24      ADD	R2,R20
    00D1E 1E35      ADC	R3,R21
    00D1F 1E46      ADC	R4,R22
    00D20 1E57      ADC	R5,R23
    00D21 8220      ST	Z,R2
    00D22 8231      STD	Z+1,R3
    00D23 8242      STD	Z+2,R4
    00D24 8253      STD	Z+3,R5
    00D25 94A3      INC	R10
    00D26 89E8      LDD	R30,Y+16
    00D27 89F9      LDD	R31,Y+17
    00D28 93AF      PUSH	R26
    00D29 93BF      PUSH	R27
    00D2A 81A0      LD	R26,Z
    00D2B 81B1      LDD	R27,Z+1
    00D2C 01FD      MOVW	R30,R26
    00D2D 91BF      POP	R27
    00D2E 91AF      POP	R26
    00D2F 8022      LDD	R2,Z+2
    00D30 14A2      CP	R10,R2
    00D31 F408      BCC	0x0D33
    00D32 CFBE      RJMP	0x0CF1
(1155) 					}
(1156) 					dj->fs->winsect -= c;						/* Rewind window address */
    00D33 89E8      LDD	R30,Y+16
    00D34 89F9      LDD	R31,Y+17
    00D35 8180      LD	R24,Z
    00D36 8191      LDD	R25,Z+1
    00D37 968A      ADIW	R24,0x2A
    00D38 017C      MOVW	R14,R24
    00D39 2C2A      MOV	R2,R10
    00D3A 2433      CLR	R3
    00D3B 2444      CLR	R4
    00D3C 2455      CLR	R5
    00D3D 01FC      MOVW	R30,R24
    00D3E 8060      LD	R6,Z
    00D3F 8071      LDD	R7,Z+1
    00D40 8082      LDD	R8,Z+2
    00D41 8093      LDD	R9,Z+3
    00D42 1862      SUB	R6,R2
    00D43 0873      SBC	R7,R3
    00D44 0884      SBC	R8,R4
    00D45 0895      SBC	R9,R5
    00D46 8260      ST	Z,R6
    00D47 8271      STD	Z+1,R7
    00D48 8282      STD	Z+2,R8
    00D49 8293      STD	Z+3,R9
(1157) #else
(1158) 					return FR_NO_FILE;			/* Report EOT */
(1159) #endif
(1160) 				}
(1161) 				dj->clust = clst;				/* Initialize data for new cluster */
    00D4A 802A      LDD	R2,Y+2
    00D4B 803B      LDD	R3,Y+3
    00D4C 804C      LDD	R4,Y+4
    00D4D 805D      LDD	R5,Y+5
    00D4E 89E8      LDD	R30,Y+16
    00D4F 89F9      LDD	R31,Y+17
    00D50 8622      STD	Z+10,R2
    00D51 8633      STD	Z+11,R3
    00D52 8644      STD	Z+12,R4
    00D53 8655      STD	Z+13,R5
(1162) 				dj->sect = clust2sect(dj->fs, clst);
    00D54 8248      ST	Y,R4
    00D55 8259      STD	Y+1,R5
    00D56 0191      MOVW	R18,R2
    00D57 8100      LD	R16,Z
    00D58 8111      LDD	R17,Z+1
    00D59 940E 04BF CALL	_clust2sect
    00D5B 89E8      LDD	R30,Y+16
    00D5C 89F9      LDD	R31,Y+17
    00D5D 8706      STD	Z+14,R16
    00D5E 8717      STD	Z+15,R17
    00D5F 8B20      STD	Z+16,R18
    00D60 8B31      STD	Z+17,R19
(1163) 			}
(1164) 		}
(1165) 	}
(1166) 
(1167) 	dj->index = i;
    00D61 89E8      LDD	R30,Y+16
    00D62 89F9      LDD	R31,Y+17
    00D63 82D5      STD	Z+5,R13
    00D64 82C4      STD	Z+4,R12
(1168) 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    00D65 0196      MOVW	R18,R12
    00D66 702F      ANDI	R18,0xF
    00D67 7030      ANDI	R19,0
    00D68 E200      LDI	R16,0x20
    00D69 E010      LDI	R17,0
    00D6A 940E 40AD CALL	empy16s
    00D6C 0118      MOVW	R2,R16
    00D6D 89E8      LDD	R30,Y+16
    00D6E 89F9      LDD	R31,Y+17
    00D6F 8180      LD	R24,Z
    00D70 8191      LDD	R25,Z+1
    00D71 968E      ADIW	R24,0x2E
    00D72 0E28      ADD	R2,R24
    00D73 1E39      ADC	R3,R25
    00D74 8A33      STD	Z+19,R3
    00D75 8A22      STD	Z+18,R2
(1169) 
(1170) 	return FR_OK;
    00D76 2700      CLR	R16
    00D77 9626      ADIW	R28,6
    00D78 940E 4106 CALL	pop_xgsetF0FC
    00D7A 9624      ADIW	R28,4
    00D7B 9508      RET
ff.c:dir_find:
  c                    --> R12
  dir                  --> R10
  res                  --> R20
  dj                   --> R22
    00D7C 940E 414C CALL	push_xgsetF03C
    00D7E 01B8      MOVW	R22,R16
    00D7F 9722      SBIW	R28,2
(1171) }
(1172) 
(1173) 
(1174) 
(1175) 
(1176) /*-----------------------------------------------------------------------*/
(1177) /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
(1178) /*-----------------------------------------------------------------------*/
(1179) #if _USE_LFN
(1180) static
(1181) const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
(1182) 
(1183) 
(1184) static
(1185) int cmp_lfn (			/* 1:Matched, 0:Not matched */
(1186) 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
(1187) 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
(1188) )
(1189) {
(1190) 	UINT i, s;
(1191) 	WCHAR wc, uc;
(1192) 
(1193) 
(1194) 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
(1195) 	s = 0; wc = 1;
(1196) 	do {
(1197) 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
(1198) 		if (wc) {	/* Last char has not been processed */
(1199) 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
(1200) 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
(1201) 				return 0;				/* Not matched */
(1202) 		} else {
(1203) 			if (uc != 0xFFFF) return 0;	/* Check filler */
(1204) 		}
(1205) 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
(1206) 
(1207) 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
(1208) 		return 0;
(1209) 
(1210) 	return 1;						/* The part of LFN matched */
(1211) }
(1212) 
(1213) 
(1214) 
(1215) static
(1216) int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
(1217) 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
(1218) 	BYTE *dir			/* Pointer to the directory entry */
(1219) )
(1220) {
(1221) 	UINT i, s;
(1222) 	WCHAR wc, uc;
(1223) 
(1224) 
(1225) 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
(1226) 
(1227) 	s = 0; wc = 1;
(1228) 	do {
(1229) 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
(1230) 		if (wc) {	/* Last char has not been processed */
(1231) 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
(1232) 			lfnbuf[i++] = wc = uc;			/* Store it */
(1233) 		} else {
(1234) 			if (uc != 0xFFFF) return 0;		/* Check filler */
(1235) 		}
(1236) 	} while (++s < 13);						/* Read all character in the entry */
(1237) 
(1238) 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
(1239) 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
(1240) 		lfnbuf[i] = 0;
(1241) 	}
(1242) 
(1243) 	return 1;
(1244) }
(1245) 
(1246) 
(1247) #if !_FS_READONLY
(1248) static
(1249) void fit_lfn (
(1250) 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
(1251) 	BYTE *dir,				/* Pointer to the directory entry */
(1252) 	BYTE ord,				/* LFN order (1-20) */
(1253) 	BYTE sum				/* SFN sum */
(1254) )
(1255) {
(1256) 	UINT i, s;
(1257) 	WCHAR wc;
(1258) 
(1259) 
(1260) 	dir[LDIR_Chksum] = sum;			/* Set check sum */
(1261) 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
(1262) 	dir[LDIR_Type] = 0;
(1263) 	ST_WORD(dir+LDIR_FstClusLO, 0);
(1264) 
(1265) 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
(1266) 	s = wc = 0;
(1267) 	do {
(1268) 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
(1269) 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
(1270) 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
(1271) 	} while (++s < 13);
(1272) 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
(1273) 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
(1274) }
(1275) 
(1276) #endif
(1277) #endif
(1278) 
(1279) 
(1280) 
(1281) /*-----------------------------------------------------------------------*/
(1282) /* Create numbered name                                                  */
(1283) /*-----------------------------------------------------------------------*/
(1284) #if _USE_LFN
(1285) void gen_numname (
(1286) 	BYTE *dst,			/* Pointer to generated SFN */
(1287) 	const BYTE *src,	/* Pointer to source SFN to be modified */
(1288) 	const WCHAR *lfn,	/* Pointer to LFN */
(1289) 	WORD seq			/* Sequence number */
(1290) )
(1291) {
(1292) 	BYTE ns[8], c;
(1293) 	UINT i, j;
(1294) 
(1295) 
(1296) 	mem_cpy(dst, src, 11);
(1297) 
(1298) 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
(1299) 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
(1300) 	}
(1301) 
(1302) 	/* itoa (hexdecimal) */
(1303) 	i = 7;
(1304) 	do {
(1305) 		c = (seq % 16) + '0';
(1306) 		if (c > '9') c += 7;
(1307) 		ns[i--] = c;
(1308) 		seq /= 16;
(1309) 	} while (seq);
(1310) 	ns[i] = '~';
(1311) 
(1312) 	/* Append the number */
(1313) 	for (j = 0; j < i && dst[j] != ' '; j++) {
(1314) 		if (IsDBCS1(dst[j])) {
(1315) 			if (j == i - 1) break;
(1316) 			j++;
(1317) 		}
(1318) 	}
(1319) 	do {
(1320) 		dst[j++] = (i < 8) ? ns[i++] : ' ';
(1321) 	} while (j < 8);
(1322) }
(1323) #endif
(1324) 
(1325) 
(1326) 
(1327) 
(1328) /*-----------------------------------------------------------------------*/
(1329) /* Calculate sum of an SFN                                               */
(1330) /*-----------------------------------------------------------------------*/
(1331) #if _USE_LFN
(1332) static
(1333) BYTE sum_sfn (
(1334) 	const BYTE *dir		/* Ptr to directory entry */
(1335) )
(1336) {
(1337) 	BYTE sum = 0;
(1338) 	UINT n = 11;
(1339) 
(1340) 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
(1341) 	return sum;
(1342) }
(1343) #endif
(1344) 
(1345) 
(1346) 
(1347) 
(1348) /*-----------------------------------------------------------------------*/
(1349) /* Directory handling - Find an object in the directory                  */
(1350) /*-----------------------------------------------------------------------*/
(1351) 
(1352) static
(1353) FRESULT dir_find (
(1354) 	DIR *dj			/* Pointer to the directory object linked to the file name */
(1355) )
(1356) {
(1357) 	FRESULT res;
(1358) 	BYTE c, *dir;
(1359) #if _USE_LFN
(1360) 	BYTE a, ord, sum;
(1361) #endif
(1362) 
(1363) 	res = dir_sdi(dj, 0);			/* Rewind directory object */
    00D80 2722      CLR	R18
    00D81 2733      CLR	R19
    00D82 018B      MOVW	R16,R22
    00D83 DD40      RCALL	ff.c:dir_sdi
    00D84 2F40      MOV	R20,R16
(1364) 	if (res != FR_OK) return res;
    00D85 2300      TST	R16
    00D86 F009      BEQ	0x0D88
    00D87 C036      RJMP	0x0DBE
(1365) 
(1366) #if _USE_LFN
(1367) 	ord = sum = 0xFF;
(1368) #endif
(1369) 	do {
(1370) 		res = move_window(dj->fs, dj->sect);
    00D88 01FB      MOVW	R30,R22
    00D89 8426      LDD	R2,Z+14
    00D8A 8437      LDD	R3,Z+15
    00D8B 8840      LDD	R4,Z+16
    00D8C 8851      LDD	R5,Z+17
    00D8D 8248      ST	Y,R4
    00D8E 8259      STD	Y+1,R5
    00D8F 0191      MOVW	R18,R2
    00D90 8100      LD	R16,Z
    00D91 8111      LDD	R17,Z+1
    00D92 940E 0348 CALL	ff.c:move_window
    00D94 2F40      MOV	R20,R16
(1371) 		if (res != FR_OK) break;
    00D95 2300      TST	R16
    00D96 F009      BEQ	0x0D98
    00D97 C025      RJMP	0x0DBD
(1372) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00D98 01FB      MOVW	R30,R22
    00D99 88A2      LDD	R10,Z+18
    00D9A 88B3      LDD	R11,Z+19
(1373) 		c = dir[DIR_Name];
    00D9B 01F5      MOVW	R30,R10
    00D9C 80C0      LD	R12,Z
(1374) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00D9D 20CC      TST	R12
    00D9E F411      BNE	0x0DA1
    00D9F E044      LDI	R20,4
    00DA0 C01C      RJMP	0x0DBD
(1375) #if _USE_LFN	/* LFN configuration */
(1376) 		a = dir[DIR_Attr] & AM_MASK;
(1377) 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1378) 			ord = 0xFF;
(1379) 		} else {
(1380) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1381) 				if (dj->lfn) {
(1382) 					if (c & LLE) {		/* Is it start of LFN sequence? */
(1383) 						sum = dir[LDIR_Chksum];
(1384) 						c &= ~LLE; ord = c;	/* LFN start order */
(1385) 						dj->lfn_idx = dj->index;
(1386) 					}
(1387) 					/* Check validity of the LFN entry and compare it with given name */
(1388) 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1389) 				}
(1390) 			} else {					/* An SFN entry is found */
(1391) 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
(1392) 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
(1393) 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
(1394) 			}
(1395) 		}
(1396) #else		/* Non LFN configuration */
(1397) 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    00DA1 01F5      MOVW	R30,R10
    00DA2 8423      LDD	R2,Z+11
    00DA3 FC23      SBRC	R2,3
    00DA4 C00F      RJMP	0x0DB4
    00DA5 E08B      LDI	R24,0xB
    00DA6 E090      LDI	R25,0
    00DA7 8399      STD	Y+1,R25
    00DA8 8388      ST	Y,R24
    00DA9 01FB      MOVW	R30,R22
    00DAA 8924      LDD	R18,Z+20
    00DAB 8935      LDD	R19,Z+21
    00DAC 0185      MOVW	R16,R10
    00DAD 940E 0317 CALL	ff.c:mem_cmp
    00DAF 0158      MOVW	R10,R16
    00DB0 3000      CPI	R16,0
    00DB1 0701      CPC	R16,R17
    00DB2 F409      BNE	0x0DB4
(1398) 			break;
    00DB3 C009      RJMP	0x0DBD
(1399) #endif
(1400) 		res = dir_next(dj, 0);		/* Next entry */
    00DB4 2722      CLR	R18
    00DB5 2733      CLR	R19
    00DB6 018B      MOVW	R16,R22
    00DB7 DE16      RCALL	ff.c:dir_next
    00DB8 2EA0      MOV	R10,R16
    00DB9 2D4A      MOV	R20,R10
(1401) 	} while (res == FR_OK);
    00DBA 2344      TST	R20
    00DBB F409      BNE	0x0DBD
    00DBC CFCB      RJMP	0x0D88
(1402) 
(1403) 	return res;
    00DBD 2F04      MOV	R16,R20
    00DBE 9622      ADIW	R28,2
    00DBF 940C 4155 JMP	pop_xgsetF03C
ff.c:dir_read:
  dir                  --> R10
  c                    --> R12
  res                  --> R20
  dj                   --> R22
    00DC1 940E 414C CALL	push_xgsetF03C
    00DC3 01B8      MOVW	R22,R16
    00DC4 9722      SBIW	R28,2
(1404) }
(1405) 
(1406) 
(1407) 
(1408) 
(1409) /*-----------------------------------------------------------------------*/
(1410) /* Read an object from the directory                                     */
(1411) /*-----------------------------------------------------------------------*/
(1412) #if _FS_MINIMIZE <= 1
(1413) static
(1414) FRESULT dir_read (
(1415) 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
(1416) )
(1417) {
(1418) 	FRESULT res;
(1419) 	BYTE c, *dir;
(1420) #if _USE_LFN
(1421) 	BYTE a, ord = 0xFF, sum = 0xFF;
(1422) #endif
(1423) 
(1424) 	res = FR_NO_FILE;
    00DC5 E044      LDI	R20,4
    00DC6 C02B      RJMP	0x0DF2
(1425) 	while (dj->sect) {
(1426) 		res = move_window(dj->fs, dj->sect);
    00DC7 01FB      MOVW	R30,R22
    00DC8 8426      LDD	R2,Z+14
    00DC9 8437      LDD	R3,Z+15
    00DCA 8840      LDD	R4,Z+16
    00DCB 8851      LDD	R5,Z+17
    00DCC 8248      ST	Y,R4
    00DCD 8259      STD	Y+1,R5
    00DCE 0191      MOVW	R18,R2
    00DCF 8100      LD	R16,Z
    00DD0 8111      LDD	R17,Z+1
    00DD1 940E 0348 CALL	ff.c:move_window
    00DD3 2F40      MOV	R20,R16
(1427) 		if (res != FR_OK) break;
    00DD4 2300      TST	R16
    00DD5 F009      BEQ	0x0DD7
    00DD6 C028      RJMP	0x0DFF
(1428) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00DD7 01FB      MOVW	R30,R22
    00DD8 88A2      LDD	R10,Z+18
    00DD9 88B3      LDD	R11,Z+19
(1429) 		c = dir[DIR_Name];
    00DDA 01F5      MOVW	R30,R10
    00DDB 80C0      LD	R12,Z
(1430) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00DDC 20CC      TST	R12
    00DDD F411      BNE	0x0DE0
    00DDE E044      LDI	R20,4
    00DDF C01F      RJMP	0x0DFF
(1431) #if _USE_LFN	/* LFN configuration */
(1432) 		a = dir[DIR_Attr] & AM_MASK;
(1433) 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1434) 			ord = 0xFF;
(1435) 		} else {
(1436) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1437) 				if (c & LLE) {			/* Is it start of LFN sequence? */
(1438) 					sum = dir[LDIR_Chksum];
(1439) 					c &= ~LLE; ord = c;
(1440) 					dj->lfn_idx = dj->index;
(1441) 				}
(1442) 				/* Check LFN validity and capture it */
(1443) 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1444) 			} else {					/* An SFN entry is found */
(1445) 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
(1446) 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
(1447) 				break;
(1448) 			}
(1449) 		}
(1450) #else		/* Non LFN configuration */
(1451) 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    00DE0 2D8C      MOV	R24,R12
    00DE1 3E85      CPI	R24,0xE5
    00DE2 F039      BEQ	0x0DEA
    00DE3 328E      CPI	R24,0x2E
    00DE4 F029      BEQ	0x0DEA
    00DE5 01F5      MOVW	R30,R10
    00DE6 8423      LDD	R2,Z+11
    00DE7 FC23      SBRC	R2,3
    00DE8 C001      RJMP	0x0DEA
(1452) 			break;
    00DE9 C015      RJMP	0x0DFF
(1453) #endif
(1454) 		res = dir_next(dj, 0);				/* Next entry */
    00DEA 2722      CLR	R18
    00DEB 2733      CLR	R19
    00DEC 018B      MOVW	R16,R22
    00DED DDE0      RCALL	ff.c:dir_next
    00DEE 2F40      MOV	R20,R16
(1455) 		if (res != FR_OK) break;
    00DEF 2300      TST	R16
    00DF0 F009      BEQ	0x0DF2
    00DF1 C00D      RJMP	0x0DFF
    00DF2 01FB      MOVW	R30,R22
    00DF3 963E      ADIW	R30,0xE
    00DF4 8020      LD	R2,Z
    00DF5 8031      LDD	R3,Z+1
    00DF6 8042      LDD	R4,Z+2
    00DF7 8053      LDD	R5,Z+3
    00DF8 9488      BCLR	0
    00DF9 2022      TST	R2
    00DFA 0432      CPC	R3,R2
    00DFB 0442      CPC	R4,R2
    00DFC 0452      CPC	R5,R2
    00DFD F009      BEQ	0x0DFF
    00DFE CFC8      RJMP	0x0DC7
(1456) 	}
(1457) 
(1458) 	if (res != FR_OK) dj->sect = 0;
    00DFF 2344      TST	R20
    00E00 F039      BEQ	0x0E08
    00E01 01FB      MOVW	R30,R22
    00E02 963E      ADIW	R30,0xE
    00E03 E080      LDI	R24,0
    00E04 8380      ST	Z,R24
    00E05 8381      STD	Z+1,R24
    00E06 8382      STD	Z+2,R24
    00E07 8383      STD	Z+3,R24
(1459) 
(1460) 	return res;
    00E08 2F04      MOV	R16,R20
    00E09 9622      ADIW	R28,2
    00E0A 940C 4155 JMP	pop_xgsetF03C
ff.c:dir_register:
  dir                  --> R12
  c                    --> R22
  res                  --> R10
  dj                   --> R20
    00E0C 940E 414C CALL	push_xgsetF03C
    00E0E 01A8      MOVW	R20,R16
    00E0F 9722      SBIW	R28,2
(1461) }
(1462) #endif
(1463) 
(1464) 
(1465) 
(1466) /*-----------------------------------------------------------------------*/
(1467) /* Register an object to the directory                                   */
(1468) /*-----------------------------------------------------------------------*/
(1469) #if !_FS_READONLY
(1470) static
(1471) FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
(1472) 	DIR *dj				/* Target directory with object name to be created */
(1473) )
(1474) {
(1475) 	FRESULT res;
(1476) 	BYTE c, *dir;
(1477) #if _USE_LFN	/* LFN configuration */
(1478) 	WORD n, ne, is;
(1479) 	BYTE sn[12], *fn, sum;
(1480) 	WCHAR *lfn;
(1481) 
(1482) 
(1483) 	fn = dj->fn; lfn = dj->lfn;
(1484) 	mem_cpy(sn, fn, 12);
(1485) 
(1486) 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
(1487) 		return FR_INVALID_NAME;
(1488) 
(1489) 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
(1490) 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
(1491) 		for (n = 1; n < 100; n++) {
(1492) 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
(1493) 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
(1494) 			if (res != FR_OK) break;
(1495) 		}
(1496) 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
(1497) 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
(1498) 		fn[NS] = sn[NS]; dj->lfn = lfn;
(1499) 	}
(1500) 
(1501) 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
(1502) 		for (ne = 0; lfn[ne]; ne++) ;
(1503) 		ne = (ne + 25) / 13;
(1504) 	} else {						/* Otherwise reserve only an SFN entry. */
(1505) 		ne = 1;
(1506) 	}
(1507) 
(1508) 	/* Reserve contiguous entries */
(1509) 	res = dir_sdi(dj, 0);
(1510) 	if (res != FR_OK) return res;
(1511) 	n = is = 0;
(1512) 	do {
(1513) 		res = move_window(dj->fs, dj->sect);
(1514) 		if (res != FR_OK) break;
(1515) 		c = *dj->dir;				/* Check the entry status */
(1516) 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
(1517) 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
(1518) 			if (++n == ne) break;	/* A contiguous entry that required count is found */
(1519) 		} else {
(1520) 			n = 0;					/* Not a blank entry. Restart to search */
(1521) 		}
(1522) 		res = dir_next(dj, 1);		/* Next entry with table stretch */
(1523) 	} while (res == FR_OK);
(1524) 
(1525) 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
(1526) 		res = dir_sdi(dj, is);
(1527) 		if (res == FR_OK) {
(1528) 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
(1529) 			ne--;
(1530) 			do {					/* Store LFN entries in bottom first */
(1531) 				res = move_window(dj->fs, dj->sect);
(1532) 				if (res != FR_OK) break;
(1533) 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
(1534) 				dj->fs->wflag = 1;
(1535) 				res = dir_next(dj, 0);	/* Next entry */
(1536) 			} while (res == FR_OK && --ne);
(1537) 		}
(1538) 	}
(1539) 
(1540) #else	/* Non LFN configuration */
(1541) 	res = dir_sdi(dj, 0);
    00E10 2722      CLR	R18
    00E11 2733      CLR	R19
    00E12 018A      MOVW	R16,R20
    00E13 DCB0      RCALL	ff.c:dir_sdi
    00E14 2EA0      MOV	R10,R16
(1542) 	if (res == FR_OK) {
    00E15 2300      TST	R16
    00E16 F509      BNE	0x0E38
(1543) 		do {	/* Find a blank entry for the SFN */
(1544) 			res = move_window(dj->fs, dj->sect);
    00E17 01FA      MOVW	R30,R20
    00E18 8426      LDD	R2,Z+14
    00E19 8437      LDD	R3,Z+15
    00E1A 8840      LDD	R4,Z+16
    00E1B 8851      LDD	R5,Z+17
    00E1C 8248      ST	Y,R4
    00E1D 8259      STD	Y+1,R5
    00E1E 0191      MOVW	R18,R2
    00E1F 8100      LD	R16,Z
    00E20 8111      LDD	R17,Z+1
    00E21 940E 0348 CALL	ff.c:move_window
    00E23 2EA0      MOV	R10,R16
(1545) 			if (res != FR_OK) break;
    00E24 2300      TST	R16
    00E25 F009      BEQ	0x0E27
    00E26 C011      RJMP	0x0E38
(1546) 			c = *dj->dir;
    00E27 01FA      MOVW	R30,R20
    00E28 89A2      LDD	R26,Z+18
    00E29 89B3      LDD	R27,Z+19
    00E2A 916C      LD	R22,X
(1547) 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    00E2B 3E65      CPI	R22,0xE5
    00E2C F011      BEQ	0x0E2F
    00E2D 2366      TST	R22
    00E2E F409      BNE	0x0E30
    00E2F C008      RJMP	0x0E38
(1548) 			res = dir_next(dj, 1);			/* Next entry with table stretch */
    00E30 E021      LDI	R18,1
    00E31 E030      LDI	R19,0
    00E32 018A      MOVW	R16,R20
    00E33 DD9A      RCALL	ff.c:dir_next
    00E34 2EC0      MOV	R12,R16
    00E35 2CAC      MOV	R10,R12
(1549) 		} while (res == FR_OK);
    00E36 20AA      TST	R10
    00E37 F2F9      BEQ	0x0E17
(1550) 	}
(1551) #endif
(1552) 
(1553) 	if (res == FR_OK) {		/* Initialize the SFN entry */
    00E38 20AA      TST	R10
    00E39 F009      BEQ	0x0E3B
    00E3A C030      RJMP	0x0E6B
(1554) 		res = move_window(dj->fs, dj->sect);
    00E3B 01FA      MOVW	R30,R20
    00E3C 8426      LDD	R2,Z+14
    00E3D 8437      LDD	R3,Z+15
    00E3E 8840      LDD	R4,Z+16
    00E3F 8851      LDD	R5,Z+17
    00E40 8248      ST	Y,R4
    00E41 8259      STD	Y+1,R5
    00E42 0191      MOVW	R18,R2
    00E43 8100      LD	R16,Z
    00E44 8111      LDD	R17,Z+1
    00E45 940E 0348 CALL	ff.c:move_window
    00E47 2EC0      MOV	R12,R16
    00E48 2CAC      MOV	R10,R12
(1555) 		if (res == FR_OK) {
    00E49 2300      TST	R16
    00E4A F501      BNE	0x0E6B
(1556) 			dir = dj->dir;
    00E4B 01FA      MOVW	R30,R20
    00E4C 88C2      LDD	R12,Z+18
    00E4D 88D3      LDD	R13,Z+19
(1557) 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    00E4E E280      LDI	R24,0x20
    00E4F E090      LDI	R25,0
    00E50 8399      STD	Y+1,R25
    00E51 8388      ST	Y,R24
    00E52 2722      CLR	R18
    00E53 2733      CLR	R19
    00E54 0186      MOVW	R16,R12
    00E55 940E 0305 CALL	ff.c:mem_set
(1558) 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    00E57 E08B      LDI	R24,0xB
    00E58 E090      LDI	R25,0
    00E59 8399      STD	Y+1,R25
    00E5A 8388      ST	Y,R24
    00E5B 01FA      MOVW	R30,R20
    00E5C 8924      LDD	R18,Z+20
    00E5D 8935      LDD	R19,Z+21
    00E5E 0186      MOVW	R16,R12
    00E5F 940E 02EF CALL	ff.c:mem_cpy
(1559) #if _USE_LFN
(1560) 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
(1561) #endif
(1562) 			dj->fs->wflag = 1;
    00E61 E081      LDI	R24,1
    00E62 01FA      MOVW	R30,R20
    00E63 93AF      PUSH	R26
    00E64 93BF      PUSH	R27
    00E65 81A0      LD	R26,Z
    00E66 81B1      LDD	R27,Z+1
    00E67 01FD      MOVW	R30,R26
    00E68 91BF      POP	R27
    00E69 91AF      POP	R26
    00E6A 8384      STD	Z+4,R24
(1563) 		}
(1564) 	}
(1565) 
(1566) 	return res;
    00E6B 2D0A      MOV	R16,R10
    00E6C 9622      ADIW	R28,2
    00E6D 940C 4155 JMP	pop_xgsetF03C
ff.c:create_name:
  si                   --> R22
  b                    --> Y,+8
  sfn                  --> Y,+6
  ni                   --> R12
  d                    --> R10
  i                    --> Y,+4
  p                    --> Y,+2
  c                    --> R20
  path                 --> Y,+19
  dj                   --> R20
    00E6F 933A      ST	-Y,R19
    00E70 932A      ST	-Y,R18
    00E71 940E 4111 CALL	push_xgsetF0FC
    00E73 01A8      MOVW	R20,R16
    00E74 9729      SBIW	R28,0x9
(1567) }
(1568) #endif /* !_FS_READONLY */
(1569) 
(1570) 
(1571) 
(1572) 
(1573) /*-----------------------------------------------------------------------*/
(1574) /* Remove an object from the directory                                   */
(1575) /*-----------------------------------------------------------------------*/
(1576) #if !_FS_READONLY && !_FS_MINIMIZE
(1577) static
(1578) FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
(1579) 	DIR *dj				/* Directory object pointing the entry to be removed */
(1580) )
(1581) {
(1582) 	FRESULT res;
(1583) #if _USE_LFN	/* LFN configuration */
(1584) 	WORD i;
(1585) 
(1586) 	i = dj->index;	/* SFN index */
(1587) 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
(1588) 	if (res == FR_OK) {
(1589) 		do {
(1590) 			res = move_window(dj->fs, dj->sect);
(1591) 			if (res != FR_OK) break;
(1592) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1593) 			dj->fs->wflag = 1;
(1594) 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
(1595) 			res = dir_next(dj, 0);		/* Next entry */
(1596) 		} while (res == FR_OK);
(1597) 		if (res == FR_NO_FILE) res = FR_INT_ERR;
(1598) 	}
(1599) 
(1600) #else			/* Non LFN configuration */
(1601) 	res = dir_sdi(dj, dj->index);
(1602) 	if (res == FR_OK) {
(1603) 		res = move_window(dj->fs, dj->sect);
(1604) 		if (res == FR_OK) {
(1605) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1606) 			dj->fs->wflag = 1;
(1607) 		}
(1608) 	}
(1609) #endif
(1610) 
(1611) 	return res;
(1612) }
(1613) #endif /* !_FS_READONLY */
(1614) 
(1615) 
(1616) 
(1617) 
(1618) /*-----------------------------------------------------------------------*/
(1619) /* Pick a segment and create the object name in directory form           */
(1620) /*-----------------------------------------------------------------------*/
(1621) 
(1622) static
(1623) FRESULT create_name (
(1624) 	DIR *dj,			/* Pointer to the directory object */
(1625) 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
(1626) )
(1627) {
(1628) #ifdef _EXCVT
(1629) 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
(1630) #endif
(1631) 
(1632) #if _USE_LFN	/* LFN configuration */
(1633) 	BYTE b, cf;
(1634) 	WCHAR w, *lfn;
(1635) 	UINT i, ni, si, di;
(1636) 	const TCHAR *p;
(1637) 
(1638) 	/* Create LFN in Unicode */
(1639) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
(1640) 	lfn = dj->lfn;
(1641) 	si = di = 0;
(1642) 	for (;;) {
(1643) 		w = p[si++];					/* Get a character */
(1644) 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
(1645) 		if (di >= _MAX_LFN)				/* Reject too long name */
(1646) 			return FR_INVALID_NAME;
(1647) #if !_LFN_UNICODE
(1648) 		w &= 0xFF;
(1649) 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
(1650) 			b = (BYTE)p[si++];			/* Get 2nd byte */
(1651) 			if (!IsDBCS2(b))
(1652) 				return FR_INVALID_NAME;	/* Reject invalid sequence */
(1653) 			w = (w << 8) + b;			/* Create a DBC */
(1654) 		}
(1655) 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
(1656) 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
(1657) #endif
(1658) 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
(1659) 			return FR_INVALID_NAME;
(1660) 		lfn[di++] = w;					/* Store the Unicode char */
(1661) 	}
(1662) 	*path = &p[si];						/* Return pointer to the next segment */
(1663) 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
(1664) #if _FS_RPATH
(1665) 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
(1666) 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
(1667) 		lfn[di] = 0;
(1668) 		for (i = 0; i < 11; i++)
(1669) 			dj->fn[i] = (i < di) ? '.' : ' ';
(1670) 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
(1671) 		return FR_OK;
(1672) 	}
(1673) #endif
(1674) 	while (di) {						/* Strip trailing spaces and dots */
(1675) 		w = lfn[di-1];
(1676) 		if (w != ' ' && w != '.') break;
(1677) 		di--;
(1678) 	}
(1679) 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
(1680) 
(1681) 	lfn[di] = 0;						/* LFN is created */
(1682) 
(1683) 	/* Create SFN in directory form */
(1684) 	mem_set(dj->fn, ' ', 11);
(1685) 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
(1686) 	if (si) cf |= NS_LOSS | NS_LFN;
(1687) 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
(1688) 
(1689) 	b = i = 0; ni = 8;
(1690) 	for (;;) {
(1691) 		w = lfn[si++];					/* Get an LFN char */
(1692) 		if (!w) break;					/* Break on end of the LFN */
(1693) 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
(1694) 			cf |= NS_LOSS | NS_LFN; continue;
(1695) 		}
(1696) 
(1697) 		if (i >= ni || si == di) {		/* Extension or end of SFN */
(1698) 			if (ni == 11) {				/* Long extension */
(1699) 				cf |= NS_LOSS | NS_LFN; break;
(1700) 			}
(1701) 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
(1702) 			if (si > di) break;			/* No extension */
(1703) 			si = di; i = 8; ni = 11;	/* Enter extension section */
(1704) 			b <<= 2; continue;
(1705) 		}
(1706) 
(1707) 		if (w >= 0x80) {				/* Non ASCII char */
(1708) #ifdef _EXCVT
(1709) 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
(1710) 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
(1711) #else
(1712) 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
(1713) #endif
(1714) 			cf |= NS_LFN;				/* Force create LFN entry */
(1715) 		}
(1716) 
(1717) 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
(1718) 			if (i >= ni - 1) {
(1719) 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
(1720) 			}
(1721) 			dj->fn[i++] = (BYTE)(w >> 8);
(1722) 		} else {						/* Single byte char */
(1723) 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
(1724) 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
(1725) 			} else {
(1726) 				if (IsUpper(w)) {		/* ASCII large capital */
(1727) 					b |= 2;
(1728) 				} else {
(1729) 					if (IsLower(w)) {	/* ASCII small capital */
(1730) 						b |= 1; w -= 0x20;
(1731) 					}
(1732) 				}
(1733) 			}
(1734) 		}
(1735) 		dj->fn[i++] = (BYTE)w;
(1736) 	}
(1737) 
(1738) 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
(1739) 
(1740) 	if (ni == 8) b <<= 2;
(1741) 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
(1742) 		cf |= NS_LFN;
(1743) 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
(1744) 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
(1745) 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
(1746) 	}
(1747) 
(1748) 	dj->fn[NS] = cf;	/* SFN is created */
(1749) 
(1750) 	return FR_OK;
(1751) 
(1752) 
(1753) #else	/* Non-LFN configuration */
(1754) 	BYTE b, c, d, *sfn;
(1755) 	UINT ni, si, i;
(1756) 	const char *p;
(1757) 
(1758) 	/* Create file name in directory form */
(1759) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    00E75 89EB      LDD	R30,Y+19
    00E76 89FC      LDD	R31,Y+20
    00E77 8020      LD	R2,Z
    00E78 8031      LDD	R3,Z+1
    00E79 823B      STD	Y+3,R3
    00E7A 822A      STD	Y+2,R2
    00E7B C005      RJMP	0x0E81
    00E7C 818A      LDD	R24,Y+2
    00E7D 819B      LDD	R25,Y+3
    00E7E 9601      ADIW	R24,1
    00E7F 839B      STD	Y+3,R25
    00E80 838A      STD	Y+2,R24
    00E81 81EA      LDD	R30,Y+2
    00E82 81FB      LDD	R31,Y+3
    00E83 8020      LD	R2,Z
    00E84 2433      CLR	R3
    00E85 2D82      MOV	R24,R2
    00E86 328F      CPI	R24,0x2F
    00E87 F3A1      BEQ	0x0E7C
    00E88 358C      CPI	R24,0x5C
    00E89 F391      BEQ	0x0E7C
(1760) 	sfn = dj->fn;
    00E8A 01FA      MOVW	R30,R20
    00E8B 8824      LDD	R2,Z+20
    00E8C 8835      LDD	R3,Z+21
    00E8D 823F      STD	Y+7,R3
    00E8E 822E      STD	Y+6,R2
(1761) 	mem_set(sfn, ' ', 11);
    00E8F E08B      LDI	R24,0xB
    00E90 E090      LDI	R25,0
    00E91 8399      STD	Y+1,R25
    00E92 8388      ST	Y,R24
    00E93 E220      LDI	R18,0x20
    00E94 E030      LDI	R19,0
    00E95 0181      MOVW	R16,R2
    00E96 940E 0305 CALL	ff.c:mem_set
(1762) 	si = i = b = 0; ni = 8;
    00E98 2400      CLR	R0
    00E99 8608      STD	Y+8,R0
    00E9A 2422      CLR	R2
    00E9B 2433      CLR	R3
    00E9C 823D      STD	Y+5,R3
    00E9D 822C      STD	Y+4,R2
    00E9E 01B1      MOVW	R22,R2
    00E9F E088      LDI	R24,0x8
    00EA0 E090      LDI	R25,0
    00EA1 016C      MOVW	R12,R24
(1763) #if _FS_RPATH
(1764) 	if (p[si] == '.') { /* Is this a dot entry? */
(1765) 		for (;;) {
(1766) 			c = (BYTE)p[si++];
(1767) 			if (c != '.' || si >= 3) break;
(1768) 			sfn[i++] = c;
(1769) 		}
(1770) 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
(1771) 		*path = &p[si];									/* Return pointer to the next segment */
(1772) 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
(1773) 		return FR_OK;
(1774) 	}
(1775) #endif
(1776) 	for (;;) {
(1777) 		c = (BYTE)p[si++];
    00EA2 01AB      MOVW	R20,R22
    00EA3 5F6F      SUBI	R22,0xFF
    00EA4 4F7F      SBCI	R23,0xFF
    00EA5 01FA      MOVW	R30,R20
    00EA6 800A      LDD	R0,Y+2
    00EA7 801B      LDD	R1,Y+3
    00EA8 0DE0      ADD	R30,R0
    00EA9 1DF1      ADC	R31,R1
    00EAA 8140      LD	R20,Z
(1778) 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    00EAB E280      LDI	R24,0x20
    00EAC 1784      CP	R24,R20
    00EAD F420      BCC	0x0EB2
    00EAE 324F      CPI	R20,0x2F
    00EAF F011      BEQ	0x0EB2
    00EB0 354C      CPI	R20,0x5C
    00EB1 F409      BNE	0x0EB3
    00EB2 C087      RJMP	0x0F3A
(1779) 		if (c == '.' || i >= ni) {
    00EB3 324E      CPI	R20,0x2E
    00EB4 F029      BEQ	0x0EBA
    00EB5 800C      LDD	R0,Y+4
    00EB6 801D      LDD	R1,Y+5
    00EB7 140C      CP	R0,R12
    00EB8 041D      CPC	R1,R13
    00EB9 F0A0      BCS	0x0ECE
(1780) 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    00EBA 01C6      MOVW	R24,R12
    00EBB 3088      CPI	R24,0x8
    00EBC E0E0      LDI	R30,0
    00EBD 079E      CPC	R25,R30
    00EBE F411      BNE	0x0EC1
    00EBF 324E      CPI	R20,0x2E
    00EC0 F011      BEQ	0x0EC3
    00EC1 E006      LDI	R16,6
    00EC2 C0AF      RJMP	0x0F72
(1781) 			i = 8; ni = 11;
    00EC3 E088      LDI	R24,0x8
    00EC4 E090      LDI	R25,0
    00EC5 839D      STD	Y+5,R25
    00EC6 838C      STD	Y+4,R24
    00EC7 E08B      LDI	R24,0xB
    00EC8 016C      MOVW	R12,R24
(1782) 			b <<= 2; continue;
    00EC9 8408      LDD	R0,Y+8
    00ECA 0C00      LSL	R0
    00ECB 0C00      LSL	R0
    00ECC 8608      STD	Y+8,R0
    00ECD CFD4      RJMP	0x0EA2
(1783) 		}
(1784) 		if (c >= 0x80) {				/* Extended char? */
    00ECE 3840      CPI	R20,0x80
    00ECF F018      BCS	0x0ED3
(1785) 			b |= 3;						/* Eliminate NT flag */
    00ED0 8588      LDD	R24,Y+8
    00ED1 6083      ORI	R24,3
    00ED2 8788      STD	Y+8,R24
(1786) #ifdef _EXCVT
(1787) 			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
(1788) #else
(1789) #if !_DF1S	/* ASCII only cfg */
(1790) 			return FR_INVALID_NAME;
(1791) #endif
(1792) #endif
(1793) 		}
(1794) 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    00ED3 3841      CPI	R20,0x81
    00ED4 F408      BCC	0x0ED6
    00ED5 C039      RJMP	0x0F0F
    00ED6 EF8E      LDI	R24,0xFE
    00ED7 1784      CP	R24,R20
    00ED8 F408      BCC	0x0EDA
    00ED9 C035      RJMP	0x0F0F
(1795) 			d = (BYTE)p[si++];			/* Get 2nd byte */
    00EDA 015B      MOVW	R10,R22
    00EDB 5F6F      SUBI	R22,0xFF
    00EDC 4F7F      SBCI	R23,0xFF
    00EDD 01F5      MOVW	R30,R10
    00EDE 800A      LDD	R0,Y+2
    00EDF 801B      LDD	R1,Y+3
    00EE0 0DE0      ADD	R30,R0
    00EE1 1DF1      ADC	R31,R1
    00EE2 80A0      LD	R10,Z
(1796) 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    00EE3 2D8A      MOV	R24,R10
    00EE4 3480      CPI	R24,0x40
    00EE5 F018      BCS	0x0EE9
    00EE6 E78E      LDI	R24,0x7E
    00EE7 158A      CP	R24,R10
    00EE8 F430      BCC	0x0EEF
    00EE9 2D8A      MOV	R24,R10
    00EEA 3880      CPI	R24,0x80
    00EEB F050      BCS	0x0EF6
    00EEC EF8E      LDI	R24,0xFE
    00EED 158A      CP	R24,R10
    00EEE F038      BCS	0x0EF6
    00EEF 01C6      MOVW	R24,R12
    00EF0 9701      SBIW	R24,1
    00EF1 800C      LDD	R0,Y+4
    00EF2 801D      LDD	R1,Y+5
    00EF3 1608      CP	R0,R24
    00EF4 0619      CPC	R1,R25
    00EF5 F010      BCS	0x0EF8
(1797) 				return FR_INVALID_NAME;
    00EF6 E006      LDI	R16,6
    00EF7 C07A      RJMP	0x0F72
(1798) 			sfn[i++] = c;
    00EF8 80EC      LDD	R14,Y+4
    00EF9 80FD      LDD	R15,Y+5
    00EFA 01C7      MOVW	R24,R14
    00EFB 9601      ADIW	R24,1
    00EFC 839D      STD	Y+5,R25
    00EFD 838C      STD	Y+4,R24
    00EFE 01F7      MOVW	R30,R14
    00EFF 800E      LDD	R0,Y+6
    00F00 801F      LDD	R1,Y+7
    00F01 0DE0      ADD	R30,R0
    00F02 1DF1      ADC	R31,R1
    00F03 8340      ST	Z,R20
(1799) 			sfn[i++] = d;
    00F04 017C      MOVW	R14,R24
    00F05 9601      ADIW	R24,1
    00F06 839D      STD	Y+5,R25
    00F07 838C      STD	Y+4,R24
    00F08 01F7      MOVW	R30,R14
    00F09 800E      LDD	R0,Y+6
    00F0A 801F      LDD	R1,Y+7
    00F0B 0DE0      ADD	R30,R0
    00F0C 1DF1      ADC	R31,R1
    00F0D 82A0      ST	Z,R10
(1800) 		} else {						/* Single byte code */
    00F0E CF93      RJMP	0x0EA2
(1801) 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    00F0F 2F24      MOV	R18,R20
    00F10 2733      CLR	R19
    00F11 E000      LDI	R16,0
    00F12 E011      LDI	R17,1
    00F13 940E 0338 CALL	ff.c:chk_chr
    00F15 0158      MOVW	R10,R16
    00F16 3000      CPI	R16,0
    00F17 0701      CPC	R16,R17
    00F18 F011      BEQ	0x0F1B
(1802) 				return FR_INVALID_NAME;
    00F19 E006      LDI	R16,6
    00F1A C057      RJMP	0x0F72
(1803) 			if (IsUpper(c)) {			/* ASCII large capital? */
    00F1B 3441      CPI	R20,0x41
    00F1C F038      BCS	0x0F24
    00F1D E58A      LDI	R24,0x5A
    00F1E 1784      CP	R24,R20
    00F1F F020      BCS	0x0F24
(1804) 				b |= 2;
    00F20 8588      LDD	R24,Y+8
    00F21 6082      ORI	R24,2
    00F22 8788      STD	Y+8,R24
(1805) 			} else {
    00F23 C009      RJMP	0x0F2D
(1806) 				if (IsLower(c)) {		/* ASCII small capital? */
    00F24 3641      CPI	R20,0x61
    00F25 F038      BCS	0x0F2D
    00F26 E78A      LDI	R24,0x7A
    00F27 1784      CP	R24,R20
    00F28 F020      BCS	0x0F2D
(1807) 					b |= 1; c -= 0x20;
    00F29 8588      LDD	R24,Y+8
    00F2A 6081      ORI	R24,1
    00F2B 8788      STD	Y+8,R24
    00F2C 5240      SUBI	R20,0x20
(1808) 				}
(1809) 			}
(1810) 			sfn[i++] = c;
    00F2D 80AC      LDD	R10,Y+4
    00F2E 80BD      LDD	R11,Y+5
    00F2F 01C5      MOVW	R24,R10
    00F30 9601      ADIW	R24,1
    00F31 839D      STD	Y+5,R25
    00F32 838C      STD	Y+4,R24
    00F33 01F5      MOVW	R30,R10
    00F34 800E      LDD	R0,Y+6
    00F35 801F      LDD	R1,Y+7
    00F36 0DE0      ADD	R30,R0
    00F37 1DF1      ADC	R31,R1
    00F38 8340      ST	Z,R20
    00F39 CF68      RJMP	0x0EA2
(1811) 		}
(1812) 	}
(1813) 	*path = &p[si];						/* Return pointer to the next segment */
    00F3A 011B      MOVW	R2,R22
    00F3B 800A      LDD	R0,Y+2
    00F3C 801B      LDD	R1,Y+3
    00F3D 0C20      ADD	R2,R0
    00F3E 1C31      ADC	R3,R1
    00F3F 89EB      LDD	R30,Y+19
    00F40 89FC      LDD	R31,Y+20
    00F41 8231      STD	Z+1,R3
    00F42 8220      ST	Z,R2
(1814) 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    00F43 E280      LDI	R24,0x20
    00F44 1784      CP	R24,R20
    00F45 F018      BCS	0x0F49
    00F46 E064      LDI	R22,4
    00F47 E070      LDI	R23,0
    00F48 C002      RJMP	0x0F4B
    00F49 2766      CLR	R22
    00F4A 2777      CLR	R23
    00F4B 2F46      MOV	R20,R22
(1815) 
(1816) 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    00F4C 800C      LDD	R0,Y+4
    00F4D 801D      LDD	R1,Y+5
    00F4E 2000      TST	R0
    00F4F F421      BNE	0x0F54
    00F50 2011      TST	R1
    00F51 F411      BNE	0x0F54
    00F52 E006      LDI	R16,6
    00F53 C01E      RJMP	0x0F72
(1817) 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    00F54 81EE      LDD	R30,Y+6
    00F55 81FF      LDD	R31,Y+7
    00F56 8180      LD	R24,Z
    00F57 3E85      CPI	R24,0xE5
    00F58 F411      BNE	0x0F5B
    00F59 E085      LDI	R24,5
    00F5A 8380      ST	Z,R24
(1818) 
(1819) 	if (ni == 8) b <<= 2;
    00F5B 01C6      MOVW	R24,R12
    00F5C 3088      CPI	R24,0x8
    00F5D E0E0      LDI	R30,0
    00F5E 079E      CPC	R25,R30
    00F5F F421      BNE	0x0F64
    00F60 8408      LDD	R0,Y+8
    00F61 0C00      LSL	R0
    00F62 0C00      LSL	R0
    00F63 8608      STD	Y+8,R0
(1820) 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    00F64 8588      LDD	R24,Y+8
    00F65 7083      ANDI	R24,3
    00F66 3081      CPI	R24,1
    00F67 F409      BNE	0x0F69
    00F68 6140      ORI	R20,0x10
(1821) 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    00F69 8588      LDD	R24,Y+8
    00F6A 708C      ANDI	R24,0xC
    00F6B 3084      CPI	R24,4
    00F6C F409      BNE	0x0F6E
    00F6D 6048      ORI	R20,0x8
(1822) 
(1823) 	sfn[NS] = c;		/* Store NT flag, File name is created */
    00F6E 81EE      LDD	R30,Y+6
    00F6F 81FF      LDD	R31,Y+7
    00F70 8743      STD	Z+11,R20
(1824) 
(1825) 	return FR_OK;
    00F71 2700      CLR	R16
    00F72 9629      ADIW	R28,0x9
    00F73 940E 4106 CALL	pop_xgsetF0FC
    00F75 9622      ADIW	R28,2
    00F76 9508      RET
ff.c:get_fileinfo:
  nt                   --> R12
  p                    --> R20
  dir                  --> R10
  i                    --> R12
  c                    --> R14
  fno                  --> R22
  dj                   --> R10
    00F77 940E 4111 CALL	push_xgsetF0FC
    00F79 01B9      MOVW	R22,R18
    00F7A 0158      MOVW	R10,R16
(1826) #endif
(1827) }
(1828) 
(1829) 
(1830) 
(1831) 
(1832) /*-----------------------------------------------------------------------*/
(1833) /* Get file information from directory entry                             */
(1834) /*-----------------------------------------------------------------------*/
(1835) #if _FS_MINIMIZE <= 1
(1836) static
(1837) void get_fileinfo (		/* No return code */
(1838) 	DIR *dj,			/* Pointer to the directory object */
(1839) 	FILINFO *fno	 	/* Pointer to the file information to be filled */
(1840) )
(1841) {
(1842) 	UINT i;
(1843) 	BYTE nt, *dir;
(1844) 	TCHAR *p, c;
(1845) 
(1846) 
(1847) 	p = fno->fname;
    00F7B 01AB      MOVW	R20,R22
    00F7C 5F47      SUBI	R20,0xF7
    00F7D 4F5F      SBCI	R21,0xFF
(1848) 	if (dj->sect) {
    00F7E 01F5      MOVW	R30,R10
    00F7F 963E      ADIW	R30,0xE
    00F80 8020      LD	R2,Z
    00F81 8031      LDD	R3,Z+1
    00F82 8042      LDD	R4,Z+2
    00F83 8053      LDD	R5,Z+3
    00F84 9488      BCLR	0
    00F85 2022      TST	R2
    00F86 0432      CPC	R3,R2
    00F87 0442      CPC	R4,R2
    00F88 0452      CPC	R5,R2
    00F89 F409      BNE	0x0F8B
    00F8A C08A      RJMP	0x1015
(1849) 		dir = dj->dir;
    00F8B 01F5      MOVW	R30,R10
    00F8C 88A2      LDD	R10,Z+18
    00F8D 88B3      LDD	R11,Z+19
(1850) 		nt = dir[DIR_NTres];		/* NT flag */
(1851) 		for (i = 0; i < 8; i++) {	/* Copy name body */
    00F8E 24CC      CLR	R12
    00F8F 24DD      CLR	R13
    00F90 C014      RJMP	0x0FA5
(1852) 			c = dir[i];
    00F91 01F6      MOVW	R30,R12
    00F92 0DEA      ADD	R30,R10
    00F93 1DFB      ADC	R31,R11
    00F94 80E0      LD	R14,Z
(1853) 			if (c == ' ') break;
    00F95 2D8E      MOV	R24,R14
    00F96 3280      CPI	R24,0x20
    00F97 F409      BNE	0x0F99
    00F98 C011      RJMP	0x0FAA
(1854) 			if (c == NDDE) c = (TCHAR)DDE;
    00F99 2D8E      MOV	R24,R14
    00F9A 3085      CPI	R24,5
    00F9B F411      BNE	0x0F9E
    00F9C EE85      LDI	R24,0xE5
    00F9D 2EE8      MOV	R14,R24
(1855) 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
    00F9E C000      RJMP	0x0F9F
(1856) #if _LFN_UNICODE
(1857) 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
(1858) 				c = (c << 8) | dir[++i];
(1859) 			c = ff_convert(c, 1);
(1860) 			if (!c) c = '?';
(1861) #endif
(1862) 			*p++ = c;
    00F9F 01FA      MOVW	R30,R20
    00FA0 92E1      ST	Z+,R14
    00FA1 01AF      MOVW	R20,R30
    00FA2 01C6      MOVW	R24,R12
    00FA3 9601      ADIW	R24,1
    00FA4 016C      MOVW	R12,R24
    00FA5 01C6      MOVW	R24,R12
    00FA6 3088      CPI	R24,0x8
    00FA7 E0E0      LDI	R30,0
    00FA8 079E      CPC	R25,R30
    00FA9 F338      BCS	0x0F91
(1863) 		}
(1864) 		if (dir[8] != ' ') {		/* Copy name extension */
    00FAA 01F5      MOVW	R30,R10
    00FAB 8580      LDD	R24,Z+8
    00FAC 3280      CPI	R24,0x20
    00FAD F0E1      BEQ	0x0FCA
(1865) 			*p++ = '.';
    00FAE E28E      LDI	R24,0x2E
    00FAF 01FA      MOVW	R30,R20
    00FB0 9381      ST	Z+,R24
    00FB1 01AF      MOVW	R20,R30
(1866) 			for (i = 8; i < 11; i++) {
    00FB2 E088      LDI	R24,0x8
    00FB3 E090      LDI	R25,0
    00FB4 016C      MOVW	R12,R24
    00FB5 C00F      RJMP	0x0FC5
(1867) 				c = dir[i];
    00FB6 01F6      MOVW	R30,R12
    00FB7 0DEA      ADD	R30,R10
    00FB8 1DFB      ADC	R31,R11
    00FB9 80E0      LD	R14,Z
(1868) 				if (c == ' ') break;
    00FBA 2D8E      MOV	R24,R14
    00FBB 3280      CPI	R24,0x20
    00FBC F409      BNE	0x0FBE
    00FBD C00C      RJMP	0x0FCA
(1869) 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
    00FBE C000      RJMP	0x0FBF
(1870) #if _LFN_UNICODE
(1871) 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
(1872) 					c = (c << 8) | dir[++i];
(1873) 				c = ff_convert(c, 1);
(1874) 				if (!c) c = '?';
(1875) #endif
(1876) 				*p++ = c;
    00FBF 01FA      MOVW	R30,R20
    00FC0 92E1      ST	Z+,R14
    00FC1 01AF      MOVW	R20,R30
    00FC2 01C6      MOVW	R24,R12
    00FC3 9601      ADIW	R24,1
    00FC4 016C      MOVW	R12,R24
    00FC5 01C6      MOVW	R24,R12
    00FC6 308B      CPI	R24,0xB
    00FC7 E0E0      LDI	R30,0
    00FC8 079E      CPC	R25,R30
    00FC9 F360      BCS	0x0FB6
(1877) 			}
(1878) 		}
(1879) 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    00FCA 01F5      MOVW	R30,R10
    00FCB 8423      LDD	R2,Z+11
    00FCC 01FB      MOVW	R30,R22
    00FCD 8620      STD	Z+8,R2
(1880) 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    00FCE E188      LDI	R24,0x18
    00FCF E090      LDI	R25,0
    00FD0 01F5      MOVW	R30,R10
    00FD1 8D07      LDD	R16,Z+31
    00FD2 2711      CLR	R17
    00FD3 2722      CLR	R18
    00FD4 2733      CLR	R19
    00FD5 938A      ST	-Y,R24
    00FD6 940E 4193 CALL	lsl32
    00FD8 0118      MOVW	R2,R16
    00FD9 0129      MOVW	R4,R18
    00FDA 01F5      MOVW	R30,R10
    00FDB 8C66      LDD	R6,Z+30
    00FDC 2477      CLR	R7
    00FDD 2488      CLR	R8
    00FDE 2499      CLR	R9
    00FDF 0143      MOVW	R8,R6
    00FE0 2466      CLR	R6
    00FE1 2477      CLR	R7
    00FE2 2826      OR	R2,R6
    00FE3 2837      OR	R3,R7
    00FE4 2848      OR	R4,R8
    00FE5 2859      OR	R5,R9
    00FE6 8C65      LDD	R6,Z+29
    00FE7 2477      CLR	R7
    00FE8 2C76      MOV	R7,R6
    00FE9 2466      CLR	R6
    00FEA 2488      CLR	R8
    00FEB 2499      CLR	R9
    00FEC 2826      OR	R2,R6
    00FED 2837      OR	R3,R7
    00FEE 2848      OR	R4,R8
    00FEF 2859      OR	R5,R9
    00FF0 8C64      LDD	R6,Z+28
    00FF1 2477      CLR	R7
    00FF2 2488      CLR	R8
    00FF3 2499      CLR	R9
    00FF4 2826      OR	R2,R6
    00FF5 2837      OR	R3,R7
    00FF6 2848      OR	R4,R8
    00FF7 2859      OR	R5,R9
    00FF8 01FB      MOVW	R30,R22
    00FF9 8220      ST	Z,R2
    00FFA 8231      STD	Z+1,R3
    00FFB 8242      STD	Z+2,R4
    00FFC 8253      STD	Z+3,R5
(1881) 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    00FFD 01F5      MOVW	R30,R10
    00FFE 8C20      LDD	R2,Z+24
    00FFF 2433      CLR	R3
    01000 8C41      LDD	R4,Z+25
    01001 2455      CLR	R5
    01002 2C54      MOV	R5,R4
    01003 2444      CLR	R4
    01004 2842      OR	R4,R2
    01005 2853      OR	R5,R3
    01006 01FB      MOVW	R30,R22
    01007 8255      STD	Z+5,R5
    01008 8244      STD	Z+4,R4
(1882) 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    01009 01F5      MOVW	R30,R10
    0100A 8826      LDD	R2,Z+22
    0100B 2433      CLR	R3
    0100C 8847      LDD	R4,Z+23
    0100D 2455      CLR	R5
    0100E 2C54      MOV	R5,R4
    0100F 2444      CLR	R4
    01010 2842      OR	R4,R2
    01011 2853      OR	R5,R3
    01012 01FB      MOVW	R30,R22
    01013 8257      STD	Z+7,R5
    01014 8246      STD	Z+6,R4
(1883) 	}
(1884) 	*p = 0;		/* Terminate SFN str by a \0 */
    01015 2422      CLR	R2
    01016 01FA      MOVW	R30,R20
    01017 8220      ST	Z,R2
    01018 940C 4106 JMP	pop_xgsetF0FC
ff.c:follow_path:
  ns                   --> R10
  res                  --> R20
  dir                  --> R10
  path                 --> Y,+6
  dj                   --> R22
    0101A 933A      ST	-Y,R19
    0101B 932A      ST	-Y,R18
    0101C 940E 4130 CALL	push_xgsetF00C
    0101E 01B8      MOVW	R22,R16
(1885) 
(1886) #if _USE_LFN
(1887) 	if (fno->lfname && fno->lfsize) {
(1888) 		TCHAR *tp = fno->lfname;
(1889) 		WCHAR w, *lfn;
(1890) 
(1891) 		i = 0;
(1892) 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
(1893) 			lfn = dj->lfn;
(1894) 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
(1895) #if !_LFN_UNICODE
(1896) 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
(1897) 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
(1898) 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
(1899) 					tp[i++] = (TCHAR)(w >> 8);
(1900) #endif
(1901) 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
(1902) 				tp[i++] = (TCHAR)w;
(1903) 			}
(1904) 		}
(1905) 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
(1906) 	}
(1907) #endif
(1908) }
(1909) #endif /* _FS_MINIMIZE <= 1 */
(1910) 
(1911) 
(1912) 
(1913) 
(1914) /*-----------------------------------------------------------------------*/
(1915) /* Follow a file path                                                    */
(1916) /*-----------------------------------------------------------------------*/
(1917) 
(1918) static
(1919) FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
(1920) 	DIR *dj,			/* Directory object to return last directory and found object */
(1921) 	const TCHAR *path	/* Full-path string to find a file or directory */
(1922) )
(1923) {
(1924) 	FRESULT res;
(1925) 	BYTE *dir, ns;
(1926) 
(1927) 
(1928) #if _FS_RPATH
(1929) 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
(1930) 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
(1931) 	} else {							/* No heading separator */
(1932) 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
(1933) 	}
(1934) #else
(1935) 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    0101F 81EE      LDD	R30,Y+6
    01020 81FF      LDD	R31,Y+7
    01021 8020      LD	R2,Z
    01022 2433      CLR	R3
    01023 2D82      MOV	R24,R2
    01024 328F      CPI	R24,0x2F
    01025 F011      BEQ	0x1028
    01026 358C      CPI	R24,0x5C
    01027 F429      BNE	0x102D
(1936) 		path++;
    01028 818E      LDD	R24,Y+6
    01029 819F      LDD	R25,Y+7
    0102A 9601      ADIW	R24,1
    0102B 839F      STD	Y+7,R25
    0102C 838E      STD	Y+6,R24
(1937) 	dj->sclust = 0;						/* Start from the root dir */
    0102D 01FB      MOVW	R30,R22
    0102E 9636      ADIW	R30,6
    0102F E080      LDI	R24,0
    01030 8380      ST	Z,R24
    01031 8381      STD	Z+1,R24
    01032 8382      STD	Z+2,R24
    01033 8383      STD	Z+3,R24
(1938) #endif
(1939) 
(1940) 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    01034 81EE      LDD	R30,Y+6
    01035 81FF      LDD	R31,Y+7
    01036 8180      LD	R24,Z
    01037 2799      CLR	R25
    01038 3280      CPI	R24,0x20
    01039 E0E0      LDI	R30,0
    0103A 079E      CPC	R25,R30
    0103B F458      BCC	0x1047
(1941) 		res = dir_sdi(dj, 0);
    0103C 2722      CLR	R18
    0103D 2733      CLR	R19
    0103E 018B      MOVW	R16,R22
    0103F DA84      RCALL	ff.c:dir_sdi
    01040 2F40      MOV	R20,R16
(1942) 		dj->dir = 0;
    01041 2422      CLR	R2
    01042 2433      CLR	R3
    01043 01FB      MOVW	R30,R22
    01044 8A33      STD	Z+19,R3
    01045 8A22      STD	Z+18,R2
(1943) 
(1944) 	} else {							/* Follow path */
    01046 C052      RJMP	0x1099
(1945) 		for (;;) {
(1946) 			res = create_name(dj, &path);	/* Get a segment */
    01047 019E      MOVW	R18,R28
    01048 5F2A      SUBI	R18,0xFA
    01049 4F3F      SBCI	R19,0xFF
    0104A 018B      MOVW	R16,R22
    0104B DE23      RCALL	ff.c:create_name
    0104C 2EA0      MOV	R10,R16
    0104D 2D4A      MOV	R20,R10
(1947) 			if (res != FR_OK) break;
    0104E 2300      TST	R16
    0104F F009      BEQ	0x1051
    01050 C048      RJMP	0x1099
(1948) 			res = dir_find(dj);				/* Find it */
    01051 018B      MOVW	R16,R22
    01052 DD29      RCALL	ff.c:dir_find
    01053 2EA0      MOV	R10,R16
    01054 2D4A      MOV	R20,R10
(1949) 			ns = *(dj->fn+NS);
    01055 01FB      MOVW	R30,R22
    01056 93AF      PUSH	R26
    01057 93BF      PUSH	R27
    01058 89A4      LDD	R26,Z+20
    01059 89B5      LDD	R27,Z+21
    0105A 01FD      MOVW	R30,R26
    0105B 91BF      POP	R27
    0105C 91AF      POP	R26
    0105D 84A3      LDD	R10,Z+11
(1950) 			if (res != FR_OK) {				/* Failed to find the object */
    0105E 2300      TST	R16
    0105F F049      BEQ	0x1069
(1951) 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    01060 3004      CPI	R16,4
    01061 F009      BEQ	0x1063
    01062 C036      RJMP	0x1099
(1952) 				/* Object not found */
(1953) 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    01063 C001      RJMP	0x1065
(1954) 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
(1955) 					res = FR_OK;
(1956) 					if (!(ns & NS_LAST)) continue;
    01064 CFE2      RJMP	0x1047
(1957) 				} else {							/* Could not find the object */
(1958) 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    01065 FCA2      SBRC	R10,2
    01066 C032      RJMP	0x1099
    01067 E045      LDI	R20,5
(1959) 				}
(1960) 				break;
    01068 C030      RJMP	0x1099
(1961) 			}
(1962) 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    01069 FEA2      SBRS	R10,2
    0106A C001      RJMP	0x106C
    0106B C02D      RJMP	0x1099
(1963) 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    0106C 01FB      MOVW	R30,R22
    0106D 88A2      LDD	R10,Z+18
    0106E 88B3      LDD	R11,Z+19
(1964) 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    0106F 01F5      MOVW	R30,R10
    01070 8423      LDD	R2,Z+11
    01071 FC24      SBRC	R2,4
    01072 C002      RJMP	0x1075
(1965) 				res = FR_NO_PATH; break;
    01073 E045      LDI	R20,5
    01074 C024      RJMP	0x1099
(1966) 			}
(1967) 			dj->sclust = LD_CLUST(dir);
    01075 01F5      MOVW	R30,R10
    01076 8C22      LDD	R2,Z+26
    01077 2433      CLR	R3
    01078 8C43      LDD	R4,Z+27
    01079 2455      CLR	R5
    0107A 2C54      MOV	R5,R4
    0107B 2444      CLR	R4
    0107C 2842      OR	R4,R2
    0107D 2853      OR	R5,R3
    0107E 0112      MOVW	R2,R4
    0107F 2444      CLR	R4
    01080 2455      CLR	R5
    01081 8864      LDD	R6,Z+20
    01082 2477      CLR	R7
    01083 8885      LDD	R8,Z+21
    01084 2499      CLR	R9
    01085 2C98      MOV	R9,R8
    01086 2488      CLR	R8
    01087 2886      OR	R8,R6
    01088 2897      OR	R9,R7
    01089 0134      MOVW	R6,R8
    0108A 2488      CLR	R8
    0108B 2499      CLR	R9
    0108C 0143      MOVW	R8,R6
    0108D 2466      CLR	R6
    0108E 2477      CLR	R7
    0108F 2862      OR	R6,R2
    01090 2873      OR	R7,R3
    01091 2884      OR	R8,R4
    01092 2895      OR	R9,R5
    01093 01FB      MOVW	R30,R22
    01094 8266      STD	Z+6,R6
    01095 8277      STD	Z+7,R7
    01096 8680      STD	Z+8,R8
    01097 8691      STD	Z+9,R9
    01098 CFAE      RJMP	0x1047
(1968) 		}
(1969) 	}
(1970) 
(1971) 	return res;
    01099 2F04      MOV	R16,R20
    0109A 940E 4137 CALL	pop_xgsetF00C
    0109C 9622      ADIW	R28,2
    0109D 9508      RET
ff.c:check_fs:
  sect                 --> Y,+11
  fs                   --> R10
    0109E 933A      ST	-Y,R19
    0109F 932A      ST	-Y,R18
    010A0 940E 4130 CALL	push_xgsetF00C
    010A2 0158      MOVW	R10,R16
    010A3 9725      SBIW	R28,5
(1972) }
(1973) 
(1974) 
(1975) 
(1976) 
(1977) /*-----------------------------------------------------------------------*/
(1978) /* Load a sector and check if it is an FAT Volume Boot Record            */
(1979) /*-----------------------------------------------------------------------*/
(1980) 
(1981) static
(1982) BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
(1983) 	FATFS *fs,	/* File system object */
(1984) 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
(1985) )
(1986) {
(1987) 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    010A4 E081      LDI	R24,1
    010A5 838C      STD	Y+4,R24
    010A6 842B      LDD	R2,Y+11
    010A7 843C      LDD	R3,Y+12
    010A8 844D      LDD	R4,Y+13
    010A9 845E      LDD	R5,Y+14
    010AA 8228      ST	Y,R2
    010AB 8239      STD	Y+1,R3
    010AC 824A      STD	Y+2,R4
    010AD 825B      STD	Y+3,R5
    010AE 0195      MOVW	R18,R10
    010AF 5D22      SUBI	R18,0xD2
    010B0 4F3F      SBCI	R19,0xFF
    010B1 01F5      MOVW	R30,R10
    010B2 8101      LDD	R16,Z+1
    010B3 940E 02AD CALL	_disk_read
    010B5 2300      TST	R16
    010B6 F011      BEQ	0x10B9
(1988) 		return 3;
    010B7 E003      LDI	R16,3
    010B8 C0A8      RJMP	0x1161
(1989) 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    010B9 01F5      MOVW	R30,R10
    010BA 5DE4      SUBI	R30,0xD4
    010BB 4FFD      SBCI	R31,0xFD
    010BC 8020      LD	R2,Z
    010BD 52EC      SUBI	R30,0x2C
    010BE 40F2      SBCI	R31,2
    010BF 2433      CLR	R3
    010C0 5DE3      SUBI	R30,0xD3
    010C1 4FFD      SBCI	R31,0xFD
    010C2 8180      LD	R24,Z
    010C3 2799      CLR	R25
    010C4 2F98      MOV	R25,R24
    010C5 2788      CLR	R24
    010C6 2982      OR	R24,R2
    010C7 2993      OR	R25,R3
    010C8 3585      CPI	R24,0x55
    010C9 EAEA      LDI	R30,0xAA
    010CA 079E      CPC	R25,R30
    010CB F011      BEQ	0x10CE
(1990) 		return 2;
    010CC E002      LDI	R16,2
    010CD C093      RJMP	0x1161
(1991) 
(1992) 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    010CE E188      LDI	R24,0x18
    010CF E090      LDI	R25,0
    010D0 01F5      MOVW	R30,R10
    010D1 59E9      SUBI	R30,0x99
    010D2 4FFF      SBCI	R31,0xFF
    010D3 8100      LD	R16,Z
    010D4 2711      CLR	R17
    010D5 2722      CLR	R18
    010D6 2733      CLR	R19
    010D7 938A      ST	-Y,R24
    010D8 940E 4193 CALL	lsl32
    010DA 0118      MOVW	R2,R16
    010DB 0129      MOVW	R4,R18
    010DC 01F5      MOVW	R30,R10
    010DD 59EA      SUBI	R30,0x9A
    010DE 4FFF      SBCI	R31,0xFF
    010DF 8060      LD	R6,Z
    010E0 56E6      SUBI	R30,0x66
    010E1 40F0      SBCI	R31,0
    010E2 2477      CLR	R7
    010E3 2488      CLR	R8
    010E4 2499      CLR	R9
    010E5 0143      MOVW	R8,R6
    010E6 2466      CLR	R6
    010E7 2477      CLR	R7
    010E8 2826      OR	R2,R6
    010E9 2837      OR	R3,R7
    010EA 2848      OR	R4,R8
    010EB 2859      OR	R5,R9
    010EC 59EB      SUBI	R30,0x9B
    010ED 4FFF      SBCI	R31,0xFF
    010EE 8060      LD	R6,Z
    010EF 56E5      SUBI	R30,0x65
    010F0 40F0      SBCI	R31,0
    010F1 2477      CLR	R7
    010F2 2C76      MOV	R7,R6
    010F3 2466      CLR	R6
    010F4 2488      CLR	R8
    010F5 2499      CLR	R9
    010F6 2826      OR	R2,R6
    010F7 2837      OR	R3,R7
    010F8 2848      OR	R4,R8
    010F9 2859      OR	R5,R9
    010FA 59EC      SUBI	R30,0x9C
    010FB 4FFF      SBCI	R31,0xFF
    010FC 8060      LD	R6,Z
    010FD 2477      CLR	R7
    010FE 2488      CLR	R8
    010FF 2499      CLR	R9
    01100 2826      OR	R2,R6
    01101 2837      OR	R3,R7
    01102 2848      OR	R4,R8
    01103 2859      OR	R5,R9
    01104 EF4F      LDI	R20,0xFF
    01105 EF5F      LDI	R21,0xFF
    01106 EF6F      LDI	R22,0xFF
    01107 E070      LDI	R23,0
    01108 2224      AND	R2,R20
    01109 2235      AND	R3,R21
    0110A 2246      AND	R4,R22
    0110B 2257      AND	R5,R23
    0110C E446      LDI	R20,0x46
    0110D E451      LDI	R21,0x41
    0110E E564      LDI	R22,0x54
    0110F E070      LDI	R23,0
    01110 1624      CP	R2,R20
    01111 0635      CPC	R3,R21
    01112 0646      CPC	R4,R22
    01113 0657      CPC	R5,R23
    01114 F411      BNE	0x1117
(1993) 		return 0;
    01115 2700      CLR	R16
    01116 C04A      RJMP	0x1161
(1994) 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    01117 E188      LDI	R24,0x18
    01118 E090      LDI	R25,0
    01119 01F5      MOVW	R30,R10
    0111A 57ED      SUBI	R30,0x7D
    0111B 4FFF      SBCI	R31,0xFF
    0111C 8100      LD	R16,Z
    0111D 2711      CLR	R17
    0111E 2722      CLR	R18
    0111F 2733      CLR	R19
    01120 938A      ST	-Y,R24
    01121 940E 4193 CALL	lsl32
    01123 0118      MOVW	R2,R16
    01124 0129      MOVW	R4,R18
    01125 01F5      MOVW	R30,R10
    01126 57EE      SUBI	R30,0x7E
    01127 4FFF      SBCI	R31,0xFF
    01128 8060      LD	R6,Z
    01129 58E2      SUBI	R30,0x82
    0112A 40F0      SBCI	R31,0
    0112B 2477      CLR	R7
    0112C 2488      CLR	R8
    0112D 2499      CLR	R9
    0112E 0143      MOVW	R8,R6
    0112F 2466      CLR	R6
    01130 2477      CLR	R7
    01131 2826      OR	R2,R6
    01132 2837      OR	R3,R7
    01133 2848      OR	R4,R8
    01134 2859      OR	R5,R9
    01135 57EF      SUBI	R30,0x7F
    01136 4FFF      SBCI	R31,0xFF
    01137 8060      LD	R6,Z
    01138 58E1      SUBI	R30,0x81
    01139 40F0      SBCI	R31,0
    0113A 2477      CLR	R7
    0113B 2C76      MOV	R7,R6
    0113C 2466      CLR	R6
    0113D 2488      CLR	R8
    0113E 2499      CLR	R9
    0113F 2826      OR	R2,R6
    01140 2837      OR	R3,R7
    01141 2848      OR	R4,R8
    01142 2859      OR	R5,R9
    01143 58E0      SUBI	R30,0x80
    01144 4FFF      SBCI	R31,0xFF
    01145 8060      LD	R6,Z
    01146 2477      CLR	R7
    01147 2488      CLR	R8
    01148 2499      CLR	R9
    01149 2826      OR	R2,R6
    0114A 2837      OR	R3,R7
    0114B 2848      OR	R4,R8
    0114C 2859      OR	R5,R9
    0114D EF4F      LDI	R20,0xFF
    0114E EF5F      LDI	R21,0xFF
    0114F EF6F      LDI	R22,0xFF
    01150 E070      LDI	R23,0
    01151 2224      AND	R2,R20
    01152 2235      AND	R3,R21
    01153 2246      AND	R4,R22
    01154 2257      AND	R5,R23
    01155 E446      LDI	R20,0x46
    01156 E451      LDI	R21,0x41
    01157 E564      LDI	R22,0x54
    01158 E070      LDI	R23,0
    01159 1624      CP	R2,R20
    0115A 0635      CPC	R3,R21
    0115B 0646      CPC	R4,R22
    0115C 0657      CPC	R5,R23
    0115D F411      BNE	0x1160
(1995) 		return 0;
    0115E 2700      CLR	R16
    0115F C001      RJMP	0x1161
(1996) 
(1997) 	return 1;
    01160 E001      LDI	R16,1
    01161 9625      ADIW	R28,5
    01162 940E 4137 CALL	pop_xgsetF00C
    01164 9622      ADIW	R28,2
    01165 9508      RET
ff.c:chk_mounted:
  pi                   --> R10
  szbfat               --> Y,+25
  tbl                  --> R10
  p                    --> R10
  nrsv                 --> R14
  sysect               --> Y,+21
  bsect                --> Y,+17
  stat                 --> R10
  tsect                --> Y,+13
  nclst                --> Y,+9
  vol                  --> R14
  fasize               --> Y,+5
  b                    --> R14
  fmt                  --> R12
  fs                   --> Y,+37
  chk_wp               --> Y,+51
  rfs                  --> Y,+49
  path                 --> R12
    01166 933A      ST	-Y,R19
    01167 932A      ST	-Y,R18
    01168 940E 4111 CALL	push_xgsetF0FC
    0116A 0168      MOVW	R12,R16
    0116B 97A7      SBIW	R28,0x27
(1998) }
(1999) 
(2000) 
(2001) 
(2002) 
(2003) /*-----------------------------------------------------------------------*/
(2004) /* Check if the file system object is valid or not                       */
(2005) /*-----------------------------------------------------------------------*/
(2006) 
(2007) static
(2008) FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
(2009) 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
(2010) 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
(2011) 	BYTE chk_wp			/* !=0: Check media write protection for write access */
(2012) )
(2013) {
(2014) 	BYTE fmt, b, pi, *tbl;
(2015) 	UINT vol;
(2016) 	DSTATUS stat;
(2017) 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
(2018) 	WORD nrsv;
(2019) 	const TCHAR *p = *path;
    0116C 01F6      MOVW	R30,R12
    0116D 80A0      LD	R10,Z
    0116E 80B1      LDD	R11,Z+1
(2020) 	FATFS *fs;
(2021) 
(2022) 	/* Get logical drive number from the path name */
(2023) 	vol = p[0] - '0';					/* Is there a drive number? */
    0116F 01F5      MOVW	R30,R10
    01170 8180      LD	R24,Z
    01171 2799      CLR	R25
    01172 97C0      SBIW	R24,0x30
    01173 017C      MOVW	R14,R24
(2024) 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    01174 E089      LDI	R24,0x9
    01175 E090      LDI	R25,0
    01176 158E      CP	R24,R14
    01177 059F      CPC	R25,R15
    01178 F050      BCS	0x1183
    01179 8181      LDD	R24,Z+1
    0117A 338A      CPI	R24,0x3A
    0117B F439      BNE	0x1183
(2025) 		p += 2; *path = p;				/* Return pointer to the path name */
    0117C 01CF      MOVW	R24,R30
    0117D 9602      ADIW	R24,2
    0117E 015C      MOVW	R10,R24
    0117F 01F6      MOVW	R30,R12
    01180 82B1      STD	Z+1,R11
    01181 82A0      ST	Z,R10
(2026) 	} else {							/* No drive number is given */
    01182 C002      RJMP	0x1185
(2027) #if _FS_RPATH
(2028) 		vol = CurrVol;					/* Use current drive */
(2029) #else
(2030) 		vol = 0;						/* Use drive 0 */
    01183 24EE      CLR	R14
    01184 24FF      CLR	R15
(2031) #endif
(2032) 	}
(2033) 
(2034) 	/* Check if the file system object is valid or not */
(2035) 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    01185 01C7      MOVW	R24,R14
    01186 3081      CPI	R24,1
    01187 E0E0      LDI	R30,0
    01188 079E      CPC	R25,R30
    01189 F010      BCS	0x118C
(2036) 		return FR_INVALID_DRIVE;
    0118A E00B      LDI	R16,0xB
    0118B C4CF      RJMP	0x165B
(2037) 	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    0118C E08D      LDI	R24,0xD
    0118D E095      LDI	R25,5
    0118E 01F7      MOVW	R30,R14
    0118F 0FEE      LSL	R30
    01190 1FFF      ROL	R31
    01191 0FE8      ADD	R30,R24
    01192 1FF9      ADC	R31,R25
    01193 8020      LD	R2,Z
    01194 8031      LDD	R3,Z+1
    01195 A23E      STD	Y+38,R3
    01196 A22D      STD	Y+37,R2
    01197 A9E9      LDD	R30,Y+49
    01198 A9FA      LDD	R31,Y+50
    01199 8231      STD	Z+1,R3
    0119A 8220      ST	Z,R2
(2038) 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    0119B 0101      MOVW	R0,R2
    0119C 2022      TST	R2
    0119D F421      BNE	0x11A2
    0119E 2033      TST	R3
    0119F F411      BNE	0x11A2
    011A0 E00C      LDI	R16,0xC
    011A1 C4B9      RJMP	0x165B
(2039) 
(2040) 	ENTER_FF(fs);						/* Lock file system */
(2041) 
(2042) 	if (fs->fs_type) {					/* If the logical drive has been mounted */
    011A2 A1ED      LDD	R30,Y+37
    011A3 A1FE      LDD	R31,Y+38
    011A4 8020      LD	R2,Z
    011A5 2022      TST	R2
    011A6 F079      BEQ	0x11B6
(2043) 		stat = disk_status(fs->drv);
    011A7 8101      LDD	R16,Z+1
    011A8 940E 02A7 CALL	_disk_status
    011AA 2EA0      MOV	R10,R16
(2044) 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    011AB FD00      SBRC	R16,0
    011AC C009      RJMP	0x11B6
(2045) 			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    011AD A80B      LDD	R0,Y+51
    011AE 2000      TST	R0
    011AF F021      BEQ	0x11B4
    011B0 FF02      SBRS	R16,2
    011B1 C002      RJMP	0x11B4
(2046) 				return FR_WRITE_PROTECTED;
    011B2 E00A      LDI	R16,0xA
    011B3 C4A7      RJMP	0x165B
(2047) 			return FR_OK;				/* The file system object is valid */
    011B4 2700      CLR	R16
    011B5 C4A5      RJMP	0x165B
(2048) 		}
(2049) 	}
(2050) 
(2051) 	/* The file system object is not valid. */
(2052) 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
(2053) 
(2054) 	fs->fs_type = 0;					/* Clear the file system object */
    011B6 2422      CLR	R2
    011B7 A1ED      LDD	R30,Y+37
    011B8 A1FE      LDD	R31,Y+38
    011B9 8220      ST	Z,R2
(2055) 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    011BA 82E1      STD	Z+1,R14
(2056) 	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    011BB 8101      LDD	R16,Z+1
    011BC 940E 0291 CALL	_disk_initialize
    011BE 2EE0      MOV	R14,R16
    011BF 2CAE      MOV	R10,R14
(2057) 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    011C0 FF00      SBRS	R16,0
    011C1 C002      RJMP	0x11C4
(2058) 		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    011C2 E003      LDI	R16,3
    011C3 C497      RJMP	0x165B
(2059) 	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    011C4 A80B      LDD	R0,Y+51
    011C5 2000      TST	R0
    011C6 F021      BEQ	0x11CB
    011C7 FEA2      SBRS	R10,2
    011C8 C002      RJMP	0x11CB
(2060) 		return FR_WRITE_PROTECTED;
    011C9 E00A      LDI	R16,0xA
    011CA C490      RJMP	0x165B
(2061) #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
(2062) 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
(2063) 		return FR_DISK_ERR;
(2064) #endif
(2065) 	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
(2066) 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    011CB E080      LDI	R24,0
    011CC 8B89      STD	Y+17,R24
    011CD 8B8A      STD	Y+18,R24
    011CE 8B8B      STD	Y+19,R24
    011CF 8B8C      STD	Y+20,R24
    011D0 E040      LDI	R20,0
    011D1 E050      LDI	R21,0
    011D2 E060      LDI	R22,0
    011D3 E070      LDI	R23,0
    011D4 8368      ST	Y,R22
    011D5 8379      STD	Y+1,R23
    011D6 019A      MOVW	R18,R20
    011D7 A10D      LDD	R16,Y+37
    011D8 A11E      LDD	R17,Y+38
    011D9 DEC4      RCALL	ff.c:check_fs
    011DA 2EA0      MOV	R10,R16
    011DB 2CCA      MOV	R12,R10
(2067) 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
    011DC C000      RJMP	0x11DD
(2068) 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    011DD 2D8C      MOV	R24,R12
    011DE 3081      CPI	R24,1
    011DF F009      BEQ	0x11E1
    011E0 C04C      RJMP	0x122D
(2069) 		/* Check the partition listed in the partition table */
(2070) 		pi = LD2PT(vol);
    011E1 24AA      CLR	R10
(2071) 		if (pi) pi--;
    011E2 F009      BEQ	0x11E4
    011E3 94AA      DEC	R10
(2072) 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
    011E4 E100      LDI	R16,0x10
    011E5 2D1A      MOV	R17,R10
    011E6 0301      MULSU	R16,R17
    011E7 0150      MOVW	R10,R0
    011E8 A18D      LDD	R24,Y+37
    011E9 A19E      LDD	R25,Y+38
    011EA 5184      SUBI	R24,0x14
    011EB 4F9E      SBCI	R25,0xFE
    011EC 0EA8      ADD	R10,R24
    011ED 1EB9      ADC	R11,R25
(2073) 		if (tbl[4]) {						/* Is the partition existing? */
    011EE 01F5      MOVW	R30,R10
    011EF 8024      LDD	R2,Z+4
    011F0 2022      TST	R2
    011F1 F409      BNE	0x11F3
    011F2 C03A      RJMP	0x122D
(2074) 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    011F3 E188      LDI	R24,0x18
    011F4 E090      LDI	R25,0
    011F5 8503      LDD	R16,Z+11
    011F6 2711      CLR	R17
    011F7 2722      CLR	R18
    011F8 2733      CLR	R19
    011F9 938A      ST	-Y,R24
    011FA 940E 4193 CALL	lsl32
    011FC 0118      MOVW	R2,R16
    011FD 0129      MOVW	R4,R18
    011FE 01F5      MOVW	R30,R10
    011FF 8462      LDD	R6,Z+10
    01200 2477      CLR	R7
    01201 2488      CLR	R8
    01202 2499      CLR	R9
    01203 0143      MOVW	R8,R6
    01204 2466      CLR	R6
    01205 2477      CLR	R7
    01206 2826      OR	R2,R6
    01207 2837      OR	R3,R7
    01208 2848      OR	R4,R8
    01209 2859      OR	R5,R9
    0120A 8461      LDD	R6,Z+9
    0120B 2477      CLR	R7
    0120C 2C76      MOV	R7,R6
    0120D 2466      CLR	R6
    0120E 2488      CLR	R8
    0120F 2499      CLR	R9
    01210 2826      OR	R2,R6
    01211 2837      OR	R3,R7
    01212 2848      OR	R4,R8
    01213 2859      OR	R5,R9
    01214 9638      ADIW	R30,0x8
    01215 8060      LD	R6,Z
    01216 2477      CLR	R7
    01217 2488      CLR	R8
    01218 2499      CLR	R9
    01219 2826      OR	R2,R6
    0121A 2837      OR	R3,R7
    0121B 2848      OR	R4,R8
    0121C 2859      OR	R5,R9
    0121D 8A29      STD	Y+17,R2
    0121E 8A3A      STD	Y+18,R3
    0121F 8A4B      STD	Y+19,R4
    01220 8A5C      STD	Y+20,R5
(2075) 			fmt = check_fs(fs, bsect);		/* Check the partition */
    01221 8829      LDD	R2,Y+17
    01222 883A      LDD	R3,Y+18
    01223 884B      LDD	R4,Y+19
    01224 885C      LDD	R5,Y+20
    01225 8248      ST	Y,R4
    01226 8259      STD	Y+1,R5
    01227 0191      MOVW	R18,R2
    01228 A10D      LDD	R16,Y+37
    01229 A11E      LDD	R17,Y+38
    0122A DE73      RCALL	ff.c:check_fs
    0122B 2EA0      MOV	R10,R16
    0122C 2CCA      MOV	R12,R10
(2076) 		}
(2077) 	}
(2078) 	if (fmt == 3) return FR_DISK_ERR;
    0122D 2D8C      MOV	R24,R12
    0122E 3083      CPI	R24,3
    0122F F411      BNE	0x1232
    01230 E001      LDI	R16,1
    01231 C429      RJMP	0x165B
(2079) 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    01232 20CC      TST	R12
    01233 F011      BEQ	0x1236
    01234 E00D      LDI	R16,0xD
    01235 C425      RJMP	0x165B
(2080) 
(2081) 	/* An FAT volume is found. Following code initializes the file system object */
(2082) 
(2083) 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    01236 A1ED      LDD	R30,Y+37
    01237 A1FE      LDD	R31,Y+38
    01238 AC21      LDD	R2,Z+57
    01239 2433      CLR	R3
    0123A AD82      LDD	R24,Z+58
    0123B 2799      CLR	R25
    0123C 2F98      MOV	R25,R24
    0123D 2788      CLR	R24
    0123E 2982      OR	R24,R2
    0123F 2993      OR	R25,R3
    01240 3080      CPI	R24,0
    01241 E0E2      LDI	R30,2
    01242 079E      CPC	R25,R30
    01243 F011      BEQ	0x1246
(2084) 		return FR_NO_FILESYSTEM;
    01244 E00D      LDI	R16,0xD
    01245 C415      RJMP	0x165B
(2085) 
(2086) 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    01246 A1ED      LDD	R30,Y+37
    01247 A1FE      LDD	R31,Y+38
    01248 5BEC      SUBI	R30,0xBC
    01249 4FFF      SBCI	R31,0xFF
    0124A 8020      LD	R2,Z
    0124B 54E4      SUBI	R30,0x44
    0124C 40F0      SBCI	R31,0
    0124D 2433      CLR	R3
    0124E 5BEB      SUBI	R30,0xBB
    0124F 4FFF      SBCI	R31,0xFF
    01250 8040      LD	R4,Z
    01251 2455      CLR	R5
    01252 2C54      MOV	R5,R4
    01253 2444      CLR	R4
    01254 2842      OR	R4,R2
    01255 2853      OR	R5,R3
    01256 0112      MOVW	R2,R4
    01257 2444      CLR	R4
    01258 2455      CLR	R5
    01259 822D      STD	Y+5,R2
    0125A 823E      STD	Y+6,R3
    0125B 824F      STD	Y+7,R4
    0125C 8658      STD	Y+8,R5
(2087) 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    0125D 802D      LDD	R2,Y+5
    0125E 803E      LDD	R3,Y+6
    0125F 804F      LDD	R4,Y+7
    01260 8458      LDD	R5,Y+8
    01261 9488      BCLR	0
    01262 2022      TST	R2
    01263 0432      CPC	R3,R2
    01264 0442      CPC	R4,R2
    01265 0452      CPC	R5,R2
    01266 F009      BEQ	0x1268
    01267 C03C      RJMP	0x12A4
    01268 E188      LDI	R24,0x18
    01269 E090      LDI	R25,0
    0126A A1ED      LDD	R30,Y+37
    0126B A1FE      LDD	R31,Y+38
    0126C 5AEB      SUBI	R30,0xAB
    0126D 4FFF      SBCI	R31,0xFF
    0126E 8100      LD	R16,Z
    0126F 2711      CLR	R17
    01270 2722      CLR	R18
    01271 2733      CLR	R19
    01272 938A      ST	-Y,R24
    01273 940E 4193 CALL	lsl32
    01275 0118      MOVW	R2,R16
    01276 0129      MOVW	R4,R18
    01277 A1ED      LDD	R30,Y+37
    01278 A1FE      LDD	R31,Y+38
    01279 5AEC      SUBI	R30,0xAC
    0127A 4FFF      SBCI	R31,0xFF
    0127B 8060      LD	R6,Z
    0127C 55E4      SUBI	R30,0x54
    0127D 40F0      SBCI	R31,0
    0127E 2477      CLR	R7
    0127F 2488      CLR	R8
    01280 2499      CLR	R9
    01281 0143      MOVW	R8,R6
    01282 2466      CLR	R6
    01283 2477      CLR	R7
    01284 2826      OR	R2,R6
    01285 2837      OR	R3,R7
    01286 2848      OR	R4,R8
    01287 2859      OR	R5,R9
    01288 5AED      SUBI	R30,0xAD
    01289 4FFF      SBCI	R31,0xFF
    0128A 8060      LD	R6,Z
    0128B 55E3      SUBI	R30,0x53
    0128C 40F0      SBCI	R31,0
    0128D 2477      CLR	R7
    0128E 2C76      MOV	R7,R6
    0128F 2466      CLR	R6
    01290 2488      CLR	R8
    01291 2499      CLR	R9
    01292 2826      OR	R2,R6
    01293 2837      OR	R3,R7
    01294 2848      OR	R4,R8
    01295 2859      OR	R5,R9
    01296 5AEE      SUBI	R30,0xAE
    01297 4FFF      SBCI	R31,0xFF
    01298 8060      LD	R6,Z
    01299 2477      CLR	R7
    0129A 2488      CLR	R8
    0129B 2499      CLR	R9
    0129C 2826      OR	R2,R6
    0129D 2837      OR	R3,R7
    0129E 2848      OR	R4,R8
    0129F 2859      OR	R5,R9
    012A0 822D      STD	Y+5,R2
    012A1 823E      STD	Y+6,R3
    012A2 824F      STD	Y+7,R4
    012A3 8658      STD	Y+8,R5
(2088) 	fs->fsize = fasize;
    012A4 802D      LDD	R2,Y+5
    012A5 803E      LDD	R3,Y+6
    012A6 804F      LDD	R4,Y+7
    012A7 8458      LDD	R5,Y+8
    012A8 A1ED      LDD	R30,Y+37
    012A9 A1FE      LDD	R31,Y+38
    012AA 8E22      STD	Z+26,R2
    012AB 8E33      STD	Z+27,R3
    012AC 8E44      STD	Z+28,R4
    012AD 8E55      STD	Z+29,R5
(2089) 
(2090) 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    012AE ACA6      LDD	R10,Z+62
    012AF 2CEA      MOV	R14,R10
    012B0 82A3      STD	Z+3,R10
(2091) 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    012B1 2D8E      MOV	R24,R14
    012B2 3081      CPI	R24,1
    012B3 F021      BEQ	0x12B8
    012B4 3082      CPI	R24,2
    012B5 F011      BEQ	0x12B8
    012B6 E00D      LDI	R16,0xD
    012B7 C3A3      RJMP	0x165B
(2092) 	fasize *= b;										/* Number of sectors for FAT area */
    012B8 2C2E      MOV	R2,R14
    012B9 2433      CLR	R3
    012BA 2444      CLR	R4
    012BB 2455      CLR	R5
    012BC 810D      LDD	R16,Y+5
    012BD 811E      LDD	R17,Y+6
    012BE 812F      LDD	R18,Y+7
    012BF 8538      LDD	R19,Y+8
    012C0 925A      ST	-Y,R5
    012C1 924A      ST	-Y,R4
    012C2 923A      ST	-Y,R3
    012C3 922A      ST	-Y,R2
    012C4 940E 40BD CALL	empy32u|empy32s
    012C6 830D      STD	Y+5,R16
    012C7 831E      STD	Y+6,R17
    012C8 832F      STD	Y+7,R18
    012C9 8738      STD	Y+8,R19
(2093) 
(2094) 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    012CA A1ED      LDD	R30,Y+37
    012CB A1FE      LDD	R31,Y+38
    012CC ACA3      LDD	R10,Z+59
    012CD 2CEA      MOV	R14,R10
    012CE 82A2      STD	Z+2,R10
(2095) 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    012CF 20AA      TST	R10
    012D0 F029      BEQ	0x12D6
    012D1 2D8E      MOV	R24,R14
    012D2 5081      SUBI	R24,1
    012D3 2C2E      MOV	R2,R14
    012D4 2228      AND	R2,R24
    012D5 F011      BEQ	0x12D8
    012D6 E00D      LDI	R16,0xD
    012D7 C383      RJMP	0x165B
(2096) 
(2097) 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    012D8 A1ED      LDD	R30,Y+37
    012D9 A1FE      LDD	R31,Y+38
    012DA AC27      LDD	R2,Z+63
    012DB 2433      CLR	R3
    012DC 5CE0      SUBI	R30,0xC0
    012DD 4FFF      SBCI	R31,0xFF
    012DE 8040      LD	R4,Z
    012DF 54E0      SUBI	R30,0x40
    012E0 40F0      SBCI	R31,0
    012E1 2455      CLR	R5
    012E2 2C54      MOV	R5,R4
    012E3 2444      CLR	R4
    012E4 2842      OR	R4,R2
    012E5 2853      OR	R5,R3
    012E6 8651      STD	Z+9,R5
    012E7 8640      STD	Z+8,R4
(2098) 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    012E8 8580      LDD	R24,Z+8
    012E9 8591      LDD	R25,Z+9
    012EA 708F      ANDI	R24,0xF
    012EB 7090      ANDI	R25,0
    012EC 3080      CPI	R24,0
    012ED 0789      CPC	R24,R25
    012EE F011      BEQ	0x12F1
    012EF E00D      LDI	R16,0xD
    012F0 C36A      RJMP	0x165B
(2099) 
(2100) 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    012F1 A1ED      LDD	R30,Y+37
    012F2 A1FE      LDD	R31,Y+38
    012F3 5BEF      SUBI	R30,0xBF
    012F4 4FFF      SBCI	R31,0xFF
    012F5 8020      LD	R2,Z
    012F6 54E1      SUBI	R30,0x41
    012F7 40F0      SBCI	R31,0
    012F8 2433      CLR	R3
    012F9 5BEE      SUBI	R30,0xBE
    012FA 4FFF      SBCI	R31,0xFF
    012FB 8040      LD	R4,Z
    012FC 2455      CLR	R5
    012FD 2C54      MOV	R5,R4
    012FE 2444      CLR	R4
    012FF 2842      OR	R4,R2
    01300 2853      OR	R5,R3
    01301 0112      MOVW	R2,R4
    01302 2444      CLR	R4
    01303 2455      CLR	R5
    01304 862D      STD	Y+13,R2
    01305 863E      STD	Y+14,R3
    01306 864F      STD	Y+15,R4
    01307 8A58      STD	Y+16,R5
(2101) 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    01308 842D      LDD	R2,Y+13
    01309 843E      LDD	R3,Y+14
    0130A 844F      LDD	R4,Y+15
    0130B 8858      LDD	R5,Y+16
    0130C 9488      BCLR	0
    0130D 2022      TST	R2
    0130E 0432      CPC	R3,R2
    0130F 0442      CPC	R4,R2
    01310 0452      CPC	R5,R2
    01311 F009      BEQ	0x1313
    01312 C03C      RJMP	0x134F
    01313 E188      LDI	R24,0x18
    01314 E090      LDI	R25,0
    01315 A1ED      LDD	R30,Y+37
    01316 A1FE      LDD	R31,Y+38
    01317 5AEF      SUBI	R30,0xAF
    01318 4FFF      SBCI	R31,0xFF
    01319 8100      LD	R16,Z
    0131A 2711      CLR	R17
    0131B 2722      CLR	R18
    0131C 2733      CLR	R19
    0131D 938A      ST	-Y,R24
    0131E 940E 4193 CALL	lsl32
    01320 0118      MOVW	R2,R16
    01321 0129      MOVW	R4,R18
    01322 A1ED      LDD	R30,Y+37
    01323 A1FE      LDD	R31,Y+38
    01324 5BE0      SUBI	R30,0xB0
    01325 4FFF      SBCI	R31,0xFF
    01326 8060      LD	R6,Z
    01327 55E0      SUBI	R30,0x50
    01328 40F0      SBCI	R31,0
    01329 2477      CLR	R7
    0132A 2488      CLR	R8
    0132B 2499      CLR	R9
    0132C 0143      MOVW	R8,R6
    0132D 2466      CLR	R6
    0132E 2477      CLR	R7
    0132F 2826      OR	R2,R6
    01330 2837      OR	R3,R7
    01331 2848      OR	R4,R8
    01332 2859      OR	R5,R9
    01333 5BE1      SUBI	R30,0xB1
    01334 4FFF      SBCI	R31,0xFF
    01335 8060      LD	R6,Z
    01336 54EF      SUBI	R30,0x4F
    01337 40F0      SBCI	R31,0
    01338 2477      CLR	R7
    01339 2C76      MOV	R7,R6
    0133A 2466      CLR	R6
    0133B 2488      CLR	R8
    0133C 2499      CLR	R9
    0133D 2826      OR	R2,R6
    0133E 2837      OR	R3,R7
    0133F 2848      OR	R4,R8
    01340 2859      OR	R5,R9
    01341 5BE2      SUBI	R30,0xB2
    01342 4FFF      SBCI	R31,0xFF
    01343 8060      LD	R6,Z
    01344 2477      CLR	R7
    01345 2488      CLR	R8
    01346 2499      CLR	R9
    01347 2826      OR	R2,R6
    01348 2837      OR	R3,R7
    01349 2848      OR	R4,R8
    0134A 2859      OR	R5,R9
    0134B 862D      STD	Y+13,R2
    0134C 863E      STD	Y+14,R3
    0134D 864F      STD	Y+15,R4
    0134E 8A58      STD	Y+16,R5
(2102) 
(2103) 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    0134F A1ED      LDD	R30,Y+37
    01350 A1FE      LDD	R31,Y+38
    01351 AC24      LDD	R2,Z+60
    01352 2433      CLR	R3
    01353 ACE5      LDD	R14,Z+61
    01354 24FF      CLR	R15
    01355 2CFE      MOV	R15,R14
    01356 24EE      CLR	R14
    01357 28E2      OR	R14,R2
    01358 28F3      OR	R15,R3
(2104) 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    01359 20EE      TST	R14
    0135A F421      BNE	0x135F
    0135B 20FF      TST	R15
    0135C F411      BNE	0x135F
    0135D E00D      LDI	R16,0xD
    0135E C2FC      RJMP	0x165B
(2105) 
(2106) 	/* Determine the FAT sub type */
(2107) 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    0135F 802D      LDD	R2,Y+5
    01360 803E      LDD	R3,Y+6
    01361 804F      LDD	R4,Y+7
    01362 8458      LDD	R5,Y+8
    01363 0137      MOVW	R6,R14
    01364 2488      CLR	R8
    01365 2499      CLR	R9
    01366 0C62      ADD	R6,R2
    01367 1C73      ADC	R7,R3
    01368 1C84      ADC	R8,R4
    01369 1C95      ADC	R9,R5
    0136A A1ED      LDD	R30,Y+37
    0136B A1FE      LDD	R31,Y+38
    0136C 9638      ADIW	R30,0x8
    0136D 8020      LD	R2,Z
    0136E 8031      LDD	R3,Z+1
    0136F 9436      LSR	R3
    01370 9427      ROR	R2
    01371 9436      LSR	R3
    01372 9427      ROR	R2
    01373 9436      LSR	R3
    01374 9427      ROR	R2
    01375 9436      LSR	R3
    01376 9427      ROR	R2
    01377 2444      CLR	R4
    01378 2455      CLR	R5
    01379 0C62      ADD	R6,R2
    0137A 1C73      ADC	R7,R3
    0137B 1C84      ADC	R8,R4
    0137C 1C95      ADC	R9,R5
    0137D 8A6D      STD	Y+21,R6
    0137E 8A7E      STD	Y+22,R7
    0137F 8A8F      STD	Y+23,R8
    01380 8E98      STD	Y+24,R9
(2108) 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    01381 882D      LDD	R2,Y+21
    01382 883E      LDD	R3,Y+22
    01383 884F      LDD	R4,Y+23
    01384 8C58      LDD	R5,Y+24
    01385 846D      LDD	R6,Y+13
    01386 847E      LDD	R7,Y+14
    01387 848F      LDD	R8,Y+15
    01388 8898      LDD	R9,Y+16
    01389 1462      CP	R6,R2
    0138A 0473      CPC	R7,R3
    0138B 0484      CPC	R8,R4
    0138C 0495      CPC	R9,R5
    0138D F410      BCC	0x1390
    0138E E00D      LDI	R16,0xD
    0138F C2CB      RJMP	0x165B
(2109) 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    01390 882D      LDD	R2,Y+21
    01391 883E      LDD	R3,Y+22
    01392 884F      LDD	R4,Y+23
    01393 8C58      LDD	R5,Y+24
    01394 850D      LDD	R16,Y+13
    01395 851E      LDD	R17,Y+14
    01396 852F      LDD	R18,Y+15
    01397 8938      LDD	R19,Y+16
    01398 1902      SUB	R16,R2
    01399 0913      SBC	R17,R3
    0139A 0924      SBC	R18,R4
    0139B 0935      SBC	R19,R5
    0139C A1ED      LDD	R30,Y+37
    0139D A1FE      LDD	R31,Y+38
    0139E 9632      ADIW	R30,2
    0139F 8020      LD	R2,Z
    013A0 2433      CLR	R3
    013A1 2444      CLR	R4
    013A2 2455      CLR	R5
    013A3 925A      ST	-Y,R5
    013A4 924A      ST	-Y,R4
    013A5 923A      ST	-Y,R3
    013A6 922A      ST	-Y,R2
    013A7 940E 4017 CALL	div32u
    013A9 8709      STD	Y+9,R16
    013AA 871A      STD	Y+10,R17
    013AB 872B      STD	Y+11,R18
    013AC 873C      STD	Y+12,R19
(2110) 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    013AD 8429      LDD	R2,Y+9
    013AE 843A      LDD	R3,Y+10
    013AF 844B      LDD	R4,Y+11
    013B0 845C      LDD	R5,Y+12
    013B1 9488      BCLR	0
    013B2 2022      TST	R2
    013B3 0432      CPC	R3,R2
    013B4 0442      CPC	R4,R2
    013B5 0452      CPC	R5,R2
    013B6 F411      BNE	0x13B9
    013B7 E00D      LDI	R16,0xD
    013B8 C2A2      RJMP	0x165B
(2111) 	fmt = FS_FAT12;
    013B9 24CC      CLR	R12
    013BA 94C3      INC	R12
(2112) 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    013BB EF46      LDI	R20,0xF6
    013BC E05F      LDI	R21,0xF
    013BD E060      LDI	R22,0
    013BE E070      LDI	R23,0
    013BF 8429      LDD	R2,Y+9
    013C0 843A      LDD	R3,Y+10
    013C1 844B      LDD	R4,Y+11
    013C2 845C      LDD	R5,Y+12
    013C3 1624      CP	R2,R20
    013C4 0635      CPC	R3,R21
    013C5 0646      CPC	R4,R22
    013C6 0657      CPC	R5,R23
    013C7 F010      BCS	0x13CA
    013C8 E082      LDI	R24,2
    013C9 2EC8      MOV	R12,R24
(2113) 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    013CA EF46      LDI	R20,0xF6
    013CB EF5F      LDI	R21,0xFF
    013CC E060      LDI	R22,0
    013CD E070      LDI	R23,0
    013CE 8429      LDD	R2,Y+9
    013CF 843A      LDD	R3,Y+10
    013D0 844B      LDD	R4,Y+11
    013D1 845C      LDD	R5,Y+12
    013D2 1624      CP	R2,R20
    013D3 0635      CPC	R3,R21
    013D4 0646      CPC	R4,R22
    013D5 0657      CPC	R5,R23
    013D6 F010      BCS	0x13D9
    013D7 E083      LDI	R24,3
    013D8 2EC8      MOV	R12,R24
(2114) 
(2115) 	/* Boundaries and Limits */
(2116) 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    013D9 E042      LDI	R20,2
    013DA E050      LDI	R21,0
    013DB E060      LDI	R22,0
    013DC E070      LDI	R23,0
    013DD 8429      LDD	R2,Y+9
    013DE 843A      LDD	R3,Y+10
    013DF 844B      LDD	R4,Y+11
    013E0 845C      LDD	R5,Y+12
    013E1 0E24      ADD	R2,R20
    013E2 1E35      ADC	R3,R21
    013E3 1E46      ADC	R4,R22
    013E4 1E57      ADC	R5,R23
    013E5 A1ED      LDD	R30,Y+37
    013E6 A1FE      LDD	R31,Y+38
    013E7 9676      ADIW	R30,0x16
    013E8 8220      ST	Z,R2
    013E9 8231      STD	Z+1,R3
    013EA 8242      STD	Z+2,R4
    013EB 8253      STD	Z+3,R5
(2117) 	fs->database = bsect + sysect;						/* Data start sector */
    013EC 882D      LDD	R2,Y+21
    013ED 883E      LDD	R3,Y+22
    013EE 884F      LDD	R4,Y+23
    013EF 8C58      LDD	R5,Y+24
    013F0 8869      LDD	R6,Y+17
    013F1 887A      LDD	R7,Y+18
    013F2 888B      LDD	R8,Y+19
    013F3 889C      LDD	R9,Y+20
    013F4 0C62      ADD	R6,R2
    013F5 1C73      ADC	R7,R3
    013F6 1C84      ADC	R8,R4
    013F7 1C95      ADC	R9,R5
    013F8 A1ED      LDD	R30,Y+37
    013F9 A1FE      LDD	R31,Y+38
    013FA 96B6      ADIW	R30,0x26
    013FB 8260      ST	Z,R6
    013FC 8271      STD	Z+1,R7
    013FD 8282      STD	Z+2,R8
    013FE 8293      STD	Z+3,R9
(2118) 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    013FF 0117      MOVW	R2,R14
    01400 2444      CLR	R4
    01401 2455      CLR	R5
    01402 8869      LDD	R6,Y+17
    01403 887A      LDD	R7,Y+18
    01404 888B      LDD	R8,Y+19
    01405 889C      LDD	R9,Y+20
    01406 0C62      ADD	R6,R2
    01407 1C73      ADC	R7,R3
    01408 1C84      ADC	R8,R4
    01409 1C95      ADC	R9,R5
    0140A A1ED      LDD	R30,Y+37
    0140B A1FE      LDD	R31,Y+38
    0140C 8E66      STD	Z+30,R6
    0140D 8E77      STD	Z+31,R7
    0140E A280      STD	Z+32,R8
    0140F A291      STD	Z+33,R9
(2119) 	if (fmt == FS_FAT32) {
    01410 2D8C      MOV	R24,R12
    01411 3083      CPI	R24,3
    01412 F009      BEQ	0x1414
    01413 C055      RJMP	0x1469
(2120) 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    01414 8420      LDD	R2,Z+8
    01415 8431      LDD	R3,Z+9
    01416 2022      TST	R2
    01417 F411      BNE	0x141A
    01418 2033      TST	R3
    01419 F011      BEQ	0x141C
    0141A E00D      LDI	R16,0xD
    0141B C23F      RJMP	0x165B
(2121) 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    0141C E188      LDI	R24,0x18
    0141D E090      LDI	R25,0
    0141E A1ED      LDD	R30,Y+37
    0141F A1FE      LDD	R31,Y+38
    01420 5AE3      SUBI	R30,0xA3
    01421 4FFF      SBCI	R31,0xFF
    01422 8100      LD	R16,Z
    01423 2711      CLR	R17
    01424 2722      CLR	R18
    01425 2733      CLR	R19
    01426 938A      ST	-Y,R24
    01427 940E 4193 CALL	lsl32
    01429 0118      MOVW	R2,R16
    0142A 0129      MOVW	R4,R18
    0142B A1ED      LDD	R30,Y+37
    0142C A1FE      LDD	R31,Y+38
    0142D 5AE4      SUBI	R30,0xA4
    0142E 4FFF      SBCI	R31,0xFF
    0142F 8060      LD	R6,Z
    01430 55EC      SUBI	R30,0x5C
    01431 40F0      SBCI	R31,0
    01432 2477      CLR	R7
    01433 2488      CLR	R8
    01434 2499      CLR	R9
    01435 0143      MOVW	R8,R6
    01436 2466      CLR	R6
    01437 2477      CLR	R7
    01438 2826      OR	R2,R6
    01439 2837      OR	R3,R7
    0143A 2848      OR	R4,R8
    0143B 2859      OR	R5,R9
    0143C 5AE5      SUBI	R30,0xA5
    0143D 4FFF      SBCI	R31,0xFF
    0143E 8060      LD	R6,Z
    0143F 55EB      SUBI	R30,0x5B
    01440 40F0      SBCI	R31,0
    01441 2477      CLR	R7
    01442 2C76      MOV	R7,R6
    01443 2466      CLR	R6
    01444 2488      CLR	R8
    01445 2499      CLR	R9
    01446 2826      OR	R2,R6
    01447 2837      OR	R3,R7
    01448 2848      OR	R4,R8
    01449 2859      OR	R5,R9
    0144A 5AE6      SUBI	R30,0xA6
    0144B 4FFF      SBCI	R31,0xFF
    0144C 8060      LD	R6,Z
    0144D 55EA      SUBI	R30,0x5A
    0144E 40F0      SBCI	R31,0
    0144F 2477      CLR	R7
    01450 2488      CLR	R8
    01451 2499      CLR	R9
    01452 2826      OR	R2,R6
    01453 2837      OR	R3,R7
    01454 2848      OR	R4,R8
    01455 2859      OR	R5,R9
    01456 A222      STD	Z+34,R2
    01457 A233      STD	Z+35,R3
    01458 A244      STD	Z+36,R4
    01459 A255      STD	Z+37,R5
(2122) 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    0145A E082      LDI	R24,2
    0145B E090      LDI	R25,0
    0145C 9676      ADIW	R30,0x16
    0145D 8100      LD	R16,Z
    0145E 8111      LDD	R17,Z+1
    0145F 8122      LDD	R18,Z+2
    01460 8133      LDD	R19,Z+3
    01461 938A      ST	-Y,R24
    01462 940E 4193 CALL	lsl32
    01464 8F09      STD	Y+25,R16
    01465 8F1A      STD	Y+26,R17
    01466 8F2B      STD	Y+27,R18
    01467 8F3C      STD	Y+28,R19
(2123) 	} else {
    01468 C06A      RJMP	0x14D3
(2124) 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    01469 A1ED      LDD	R30,Y+37
    0146A A1FE      LDD	R31,Y+38
    0146B 8420      LDD	R2,Z+8
    0146C 8431      LDD	R3,Z+9
    0146D 2022      TST	R2
    0146E F421      BNE	0x1473
    0146F 2033      TST	R3
    01470 F411      BNE	0x1473
    01471 E00D      LDI	R16,0xD
    01472 C1E8      RJMP	0x165B
(2125) 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    01473 802D      LDD	R2,Y+5
    01474 803E      LDD	R3,Y+6
    01475 804F      LDD	R4,Y+7
    01476 8458      LDD	R5,Y+8
    01477 A1ED      LDD	R30,Y+37
    01478 A1FE      LDD	R31,Y+38
    01479 8C66      LDD	R6,Z+30
    0147A 8C77      LDD	R7,Z+31
    0147B A080      LDD	R8,Z+32
    0147C A091      LDD	R9,Z+33
    0147D 0C62      ADD	R6,R2
    0147E 1C73      ADC	R7,R3
    0147F 1C84      ADC	R8,R4
    01480 1C95      ADC	R9,R5
    01481 A262      STD	Z+34,R6
    01482 A273      STD	Z+35,R7
    01483 A284      STD	Z+36,R8
    01484 A295      STD	Z+37,R9
(2126) 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    01485 2D8C      MOV	R24,R12
    01486 3082      CPI	R24,2
    01487 F471      BNE	0x1496
    01488 9676      ADIW	R30,0x16
    01489 8020      LD	R2,Z
    0148A 8031      LDD	R3,Z+1
    0148B 8042      LDD	R4,Z+2
    0148C 8053      LDD	R5,Z+3
    0148D 0C22      LSL	R2
    0148E 1C33      ROL	R3
    0148F 1C44      ROL	R4
    01490 1C55      ROL	R5
    01491 8E2D      STD	Y+29,R2
    01492 8E3E      STD	Y+30,R3
    01493 8E4F      STD	Y+31,R4
    01494 A258      STD	Y+32,R5
    01495 C035      RJMP	0x14CB
    01496 A1ED      LDD	R30,Y+37
    01497 A1FE      LDD	R31,Y+38
    01498 9676      ADIW	R30,0x16
    01499 8020      LD	R2,Z
    0149A 8031      LDD	R3,Z+1
    0149B 8042      LDD	R4,Z+2
    0149C 8053      LDD	R5,Z+3
    0149D A229      STD	Y+33,R2
    0149E A23A      STD	Y+34,R3
    0149F A24B      STD	Y+35,R4
    014A0 A25C      STD	Y+36,R5
    014A1 E041      LDI	R20,1
    014A2 E050      LDI	R21,0
    014A3 E060      LDI	R22,0
    014A4 E070      LDI	R23,0
    014A5 A029      LDD	R2,Y+33
    014A6 A03A      LDD	R3,Y+34
    014A7 A04B      LDD	R4,Y+35
    014A8 A05C      LDD	R5,Y+36
    014A9 2224      AND	R2,R20
    014AA 2235      AND	R3,R21
    014AB 2246      AND	R4,R22
    014AC 2257      AND	R5,R23
    014AD A069      LDD	R6,Y+33
    014AE A07A      LDD	R7,Y+34
    014AF A08B      LDD	R8,Y+35
    014B0 A09C      LDD	R9,Y+36
    014B1 E043      LDI	R20,3
    014B2 E050      LDI	R21,0
    014B3 E060      LDI	R22,0
    014B4 E070      LDI	R23,0
    014B5 929A      ST	-Y,R9
    014B6 928A      ST	-Y,R8
    014B7 927A      ST	-Y,R7
    014B8 926A      ST	-Y,R6
    014B9 018A      MOVW	R16,R20
    014BA 019B      MOVW	R18,R22
    014BB 940E 40BD CALL	empy32u|empy32s
    014BD 0138      MOVW	R6,R16
    014BE 0149      MOVW	R8,R18
    014BF 9496      LSR	R9
    014C0 9487      ROR	R8
    014C1 9477      ROR	R7
    014C2 9467      ROR	R6
    014C3 0C62      ADD	R6,R2
    014C4 1C73      ADC	R7,R3
    014C5 1C84      ADC	R8,R4
    014C6 1C95      ADC	R9,R5
    014C7 8E6D      STD	Y+29,R6
    014C8 8E7E      STD	Y+30,R7
    014C9 8E8F      STD	Y+31,R8
    014CA A298      STD	Y+32,R9
    014CB 8C2D      LDD	R2,Y+29
    014CC 8C3E      LDD	R3,Y+30
    014CD 8C4F      LDD	R4,Y+31
    014CE A058      LDD	R5,Y+32
    014CF 8E29      STD	Y+25,R2
    014D0 8E3A      STD	Y+26,R3
    014D1 8E4B      STD	Y+27,R4
    014D2 8E5C      STD	Y+28,R5
(2127) 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
(2128) 	}
(2129) 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    014D3 EF4F      LDI	R20,0xFF
    014D4 E051      LDI	R21,1
    014D5 E060      LDI	R22,0
    014D6 E070      LDI	R23,0
    014D7 8D09      LDD	R16,Y+25
    014D8 8D1A      LDD	R17,Y+26
    014D9 8D2B      LDD	R18,Y+27
    014DA 8D3C      LDD	R19,Y+28
    014DB 0F04      ADD	R16,R20
    014DC 1F15      ADC	R17,R21
    014DD 1F26      ADC	R18,R22
    014DE 1F37      ADC	R19,R23
    014DF E089      LDI	R24,0x9
    014E0 E090      LDI	R25,0
    014E1 938A      ST	-Y,R24
    014E2 940E 41AC CALL	lsr32
    014E4 A1ED      LDD	R30,Y+37
    014E5 A1FE      LDD	R31,Y+38
    014E6 8C22      LDD	R2,Z+26
    014E7 8C33      LDD	R3,Z+27
    014E8 8C44      LDD	R4,Z+28
    014E9 8C55      LDD	R5,Z+29
    014EA 1620      CP	R2,R16
    014EB 0631      CPC	R3,R17
    014EC 0642      CPC	R4,R18
    014ED 0653      CPC	R5,R19
    014EE F410      BCC	0x14F1
(2130) 		return FR_NO_FILESYSTEM;
    014EF E00D      LDI	R16,0xD
    014F0 C16A      RJMP	0x165B
(2131) 
(2132) #if !_FS_READONLY
(2133) 	/* Initialize cluster allocation information */
(2134) 	fs->free_clust = 0xFFFFFFFF;
    014F1 A1ED      LDD	R30,Y+37
    014F2 A1FE      LDD	R31,Y+38
    014F3 963E      ADIW	R30,0xE
    014F4 EF8F      LDI	R24,0xFF
    014F5 8380      ST	Z,R24
    014F6 8381      STD	Z+1,R24
    014F7 8382      STD	Z+2,R24
    014F8 8383      STD	Z+3,R24
(2135) 	fs->last_clust = 0;
    014F9 A1ED      LDD	R30,Y+37
    014FA A1FE      LDD	R31,Y+38
    014FB 963A      ADIW	R30,0xA
    014FC E080      LDI	R24,0
    014FD 8380      ST	Z,R24
    014FE 8381      STD	Z+1,R24
    014FF 8382      STD	Z+2,R24
    01500 8383      STD	Z+3,R24
(2136) 
(2137) 	/* Get fsinfo if available */
(2138) 	if (fmt == FS_FAT32) {
    01501 2D8C      MOV	R24,R12
    01502 3083      CPI	R24,3
    01503 F009      BEQ	0x1505
    01504 C13C      RJMP	0x1641
(2139) 	 	fs->fsi_flag = 0;
    01505 2422      CLR	R2
    01506 A1ED      LDD	R30,Y+37
    01507 A1FE      LDD	R31,Y+38
    01508 8225      STD	Z+5,R2
(2140) 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    01509 5AE2      SUBI	R30,0xA2
    0150A 4FFF      SBCI	R31,0xFF
    0150B 8020      LD	R2,Z
    0150C 55EE      SUBI	R30,0x5E
    0150D 40F0      SBCI	R31,0
    0150E 2433      CLR	R3
    0150F 5AE1      SUBI	R30,0xA1
    01510 4FFF      SBCI	R31,0xFF
    01511 8040      LD	R4,Z
    01512 2455      CLR	R5
    01513 2C54      MOV	R5,R4
    01514 2444      CLR	R4
    01515 2842      OR	R4,R2
    01516 2853      OR	R5,R3
    01517 0112      MOVW	R2,R4
    01518 2444      CLR	R4
    01519 2455      CLR	R5
    0151A 8869      LDD	R6,Y+17
    0151B 887A      LDD	R7,Y+18
    0151C 888B      LDD	R8,Y+19
    0151D 889C      LDD	R9,Y+20
    0151E 0C62      ADD	R6,R2
    0151F 1C73      ADC	R7,R3
    01520 1C84      ADC	R8,R4
    01521 1C95      ADC	R9,R5
    01522 A1ED      LDD	R30,Y+37
    01523 A1FE      LDD	R31,Y+38
    01524 8A62      STD	Z+18,R6
    01525 8A73      STD	Z+19,R7
    01526 8A84      STD	Z+20,R8
    01527 8A95      STD	Z+21,R9
(2141) 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    01528 E081      LDI	R24,1
    01529 838C      STD	Y+4,R24
    0152A 8822      LDD	R2,Z+18
    0152B 8833      LDD	R3,Z+19
    0152C 8844      LDD	R4,Z+20
    0152D 8855      LDD	R5,Z+21
    0152E 8228      ST	Y,R2
    0152F 8239      STD	Y+1,R3
    01530 824A      STD	Y+2,R4
    01531 825B      STD	Y+3,R5
    01532 019F      MOVW	R18,R30
    01533 5D22      SUBI	R18,0xD2
    01534 4F3F      SBCI	R19,0xFF
    01535 8101      LDD	R16,Z+1
    01536 940E 02AD CALL	_disk_read
    01538 2EE0      MOV	R14,R16
    01539 2300      TST	R16
    0153A F009      BEQ	0x153C
    0153B C105      RJMP	0x1641
    0153C A1ED      LDD	R30,Y+37
    0153D A1FE      LDD	R31,Y+38
    0153E 5DE4      SUBI	R30,0xD4
    0153F 4FFD      SBCI	R31,0xFD
    01540 8020      LD	R2,Z
    01541 52EC      SUBI	R30,0x2C
    01542 40F2      SBCI	R31,2
    01543 2433      CLR	R3
    01544 5DE3      SUBI	R30,0xD3
    01545 4FFD      SBCI	R31,0xFD
    01546 8180      LD	R24,Z
    01547 52ED      SUBI	R30,0x2D
    01548 40F2      SBCI	R31,2
    01549 2799      CLR	R25
    0154A 2F98      MOV	R25,R24
    0154B 2788      CLR	R24
    0154C 2982      OR	R24,R2
    0154D 2993      OR	R25,R3
    0154E 3585      CPI	R24,0x55
    0154F EAAA      LDI	R26,0xAA
    01550 079A      CPC	R25,R26
    01551 F009      BEQ	0x1553
    01552 C0EE      RJMP	0x1641
    01553 E188      LDI	R24,0x18
    01554 E090      LDI	R25,0
    01555 A901      LDD	R16,Z+49
    01556 2711      CLR	R17
    01557 2722      CLR	R18
    01558 2733      CLR	R19
    01559 938A      ST	-Y,R24
    0155A 940E 4193 CALL	lsl32
    0155C 0118      MOVW	R2,R16
    0155D 0129      MOVW	R4,R18
    0155E A1ED      LDD	R30,Y+37
    0155F A1FE      LDD	R31,Y+38
    01560 A860      LDD	R6,Z+48
    01561 2477      CLR	R7
    01562 2488      CLR	R8
    01563 2499      CLR	R9
    01564 0143      MOVW	R8,R6
    01565 2466      CLR	R6
    01566 2477      CLR	R7
    01567 2826      OR	R2,R6
    01568 2837      OR	R3,R7
    01569 2848      OR	R4,R8
    0156A 2859      OR	R5,R9
    0156B A467      LDD	R6,Z+47
    0156C 2477      CLR	R7
    0156D 2C76      MOV	R7,R6
    0156E 2466      CLR	R6
    0156F 2488      CLR	R8
    01570 2499      CLR	R9
    01571 2826      OR	R2,R6
    01572 2837      OR	R3,R7
    01573 2848      OR	R4,R8
    01574 2859      OR	R5,R9
    01575 A466      LDD	R6,Z+46
    01576 2477      CLR	R7
    01577 2488      CLR	R8
    01578 2499      CLR	R9
    01579 2826      OR	R2,R6
    0157A 2837      OR	R3,R7
    0157B 2848      OR	R4,R8
    0157C 2859      OR	R5,R9
    0157D E542      LDI	R20,0x52
    0157E E552      LDI	R21,0x52
    0157F E661      LDI	R22,0x61
    01580 E471      LDI	R23,0x41
    01581 1624      CP	R2,R20
    01582 0635      CPC	R3,R21
    01583 0646      CPC	R4,R22
    01584 0657      CPC	R5,R23
    01585 F009      BEQ	0x1587
    01586 C0BA      RJMP	0x1641
    01587 E188      LDI	R24,0x18
    01588 E090      LDI	R25,0
    01589 5EEB      SUBI	R30,0xEB
    0158A 4FFD      SBCI	R31,0xFD
    0158B 8100      LD	R16,Z
    0158C 2711      CLR	R17
    0158D 2722      CLR	R18
    0158E 2733      CLR	R19
    0158F 938A      ST	-Y,R24
    01590 940E 4193 CALL	lsl32
    01592 0118      MOVW	R2,R16
    01593 0129      MOVW	R4,R18
    01594 A1ED      LDD	R30,Y+37
    01595 A1FE      LDD	R31,Y+38
    01596 5EEC      SUBI	R30,0xEC
    01597 4FFD      SBCI	R31,0xFD
    01598 8060      LD	R6,Z
    01599 51E4      SUBI	R30,0x14
    0159A 40F2      SBCI	R31,2
    0159B 2477      CLR	R7
    0159C 2488      CLR	R8
    0159D 2499      CLR	R9
    0159E 0143      MOVW	R8,R6
    0159F 2466      CLR	R6
    015A0 2477      CLR	R7
    015A1 2826      OR	R2,R6
    015A2 2837      OR	R3,R7
    015A3 2848      OR	R4,R8
    015A4 2859      OR	R5,R9
    015A5 5EED      SUBI	R30,0xED
    015A6 4FFD      SBCI	R31,0xFD
    015A7 8060      LD	R6,Z
    015A8 51E3      SUBI	R30,0x13
    015A9 40F2      SBCI	R31,2
    015AA 2477      CLR	R7
    015AB 2C76      MOV	R7,R6
    015AC 2466      CLR	R6
    015AD 2488      CLR	R8
    015AE 2499      CLR	R9
    015AF 2826      OR	R2,R6
    015B0 2837      OR	R3,R7
    015B1 2848      OR	R4,R8
    015B2 2859      OR	R5,R9
    015B3 5EEE      SUBI	R30,0xEE
    015B4 4FFD      SBCI	R31,0xFD
    015B5 8060      LD	R6,Z
    015B6 51E2      SUBI	R30,0x12
    015B7 40F2      SBCI	R31,2
    015B8 2477      CLR	R7
    015B9 2488      CLR	R8
    015BA 2499      CLR	R9
    015BB 2826      OR	R2,R6
    015BC 2837      OR	R3,R7
    015BD 2848      OR	R4,R8
    015BE 2859      OR	R5,R9
    015BF E742      LDI	R20,0x72
    015C0 E752      LDI	R21,0x72
    015C1 E461      LDI	R22,0x41
    015C2 E671      LDI	R23,0x61
    015C3 1624      CP	R2,R20
    015C4 0635      CPC	R3,R21
    015C5 0646      CPC	R4,R22
    015C6 0657      CPC	R5,R23
    015C7 F009      BEQ	0x15C9
    015C8 C078      RJMP	0x1641
(2142) 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
(2143) 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
(2144) 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
(2145) 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    015C9 E188      LDI	R24,0x18
    015CA E090      LDI	R25,0
    015CB 5EE3      SUBI	R30,0xE3
    015CC 4FFD      SBCI	R31,0xFD
    015CD 8100      LD	R16,Z
    015CE 2711      CLR	R17
    015CF 2722      CLR	R18
    015D0 2733      CLR	R19
    015D1 938A      ST	-Y,R24
    015D2 940E 4193 CALL	lsl32
    015D4 0118      MOVW	R2,R16
    015D5 0129      MOVW	R4,R18
    015D6 A1ED      LDD	R30,Y+37
    015D7 A1FE      LDD	R31,Y+38
    015D8 5EE4      SUBI	R30,0xE4
    015D9 4FFD      SBCI	R31,0xFD
    015DA 8060      LD	R6,Z
    015DB 51EC      SUBI	R30,0x1C
    015DC 40F2      SBCI	R31,2
    015DD 2477      CLR	R7
    015DE 2488      CLR	R8
    015DF 2499      CLR	R9
    015E0 0143      MOVW	R8,R6
    015E1 2466      CLR	R6
    015E2 2477      CLR	R7
    015E3 2826      OR	R2,R6
    015E4 2837      OR	R3,R7
    015E5 2848      OR	R4,R8
    015E6 2859      OR	R5,R9
    015E7 5EE5      SUBI	R30,0xE5
    015E8 4FFD      SBCI	R31,0xFD
    015E9 8060      LD	R6,Z
    015EA 51EB      SUBI	R30,0x1B
    015EB 40F2      SBCI	R31,2
    015EC 2477      CLR	R7
    015ED 2C76      MOV	R7,R6
    015EE 2466      CLR	R6
    015EF 2488      CLR	R8
    015F0 2499      CLR	R9
    015F1 2826      OR	R2,R6
    015F2 2837      OR	R3,R7
    015F3 2848      OR	R4,R8
    015F4 2859      OR	R5,R9
    015F5 5EE6      SUBI	R30,0xE6
    015F6 4FFD      SBCI	R31,0xFD
    015F7 8060      LD	R6,Z
    015F8 51EA      SUBI	R30,0x1A
    015F9 40F2      SBCI	R31,2
    015FA 2477      CLR	R7
    015FB 2488      CLR	R8
    015FC 2499      CLR	R9
    015FD 2826      OR	R2,R6
    015FE 2837      OR	R3,R7
    015FF 2848      OR	R4,R8
    01600 2859      OR	R5,R9
    01601 8622      STD	Z+10,R2
    01602 8633      STD	Z+11,R3
    01603 8644      STD	Z+12,R4
    01604 8655      STD	Z+13,R5
(2146) 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    01605 E188      LDI	R24,0x18
    01606 E090      LDI	R25,0
    01607 5EE7      SUBI	R30,0xE7
    01608 4FFD      SBCI	R31,0xFD
    01609 8100      LD	R16,Z
    0160A 2711      CLR	R17
    0160B 2722      CLR	R18
    0160C 2733      CLR	R19
    0160D 938A      ST	-Y,R24
    0160E 940E 4193 CALL	lsl32
    01610 0118      MOVW	R2,R16
    01611 0129      MOVW	R4,R18
    01612 A1ED      LDD	R30,Y+37
    01613 A1FE      LDD	R31,Y+38
    01614 5EE8      SUBI	R30,0xE8
    01615 4FFD      SBCI	R31,0xFD
    01616 8060      LD	R6,Z
    01617 51E8      SUBI	R30,0x18
    01618 40F2      SBCI	R31,2
    01619 2477      CLR	R7
    0161A 2488      CLR	R8
    0161B 2499      CLR	R9
    0161C 0143      MOVW	R8,R6
    0161D 2466      CLR	R6
    0161E 2477      CLR	R7
    0161F 2826      OR	R2,R6
    01620 2837      OR	R3,R7
    01621 2848      OR	R4,R8
    01622 2859      OR	R5,R9
    01623 5EE9      SUBI	R30,0xE9
    01624 4FFD      SBCI	R31,0xFD
    01625 8060      LD	R6,Z
    01626 51E7      SUBI	R30,0x17
    01627 40F2      SBCI	R31,2
    01628 2477      CLR	R7
    01629 2C76      MOV	R7,R6
    0162A 2466      CLR	R6
    0162B 2488      CLR	R8
    0162C 2499      CLR	R9
    0162D 2826      OR	R2,R6
    0162E 2837      OR	R3,R7
    0162F 2848      OR	R4,R8
    01630 2859      OR	R5,R9
    01631 5EEA      SUBI	R30,0xEA
    01632 4FFD      SBCI	R31,0xFD
    01633 8060      LD	R6,Z
    01634 51E6      SUBI	R30,0x16
    01635 40F2      SBCI	R31,2
    01636 2477      CLR	R7
    01637 2488      CLR	R8
    01638 2499      CLR	R9
    01639 2826      OR	R2,R6
    0163A 2837      OR	R3,R7
    0163B 2848      OR	R4,R8
    0163C 2859      OR	R5,R9
    0163D 8626      STD	Z+14,R2
    0163E 8637      STD	Z+15,R3
    0163F 8A40      STD	Z+16,R4
    01640 8A51      STD	Z+17,R5
(2147) 		}
(2148) 	}
(2149) #endif
(2150) 	fs->fs_type = fmt;		/* FAT sub-type */
    01641 A1ED      LDD	R30,Y+37
    01642 A1FE      LDD	R31,Y+38
    01643 82C0      ST	Z,R12
(2151) 	fs->id = ++Fsid;		/* File system mount ID */
    01644 9180 050B LDS	R24,ff.c:Fsid
    01646 9190 050C LDS	R25,ff.c:Fsid+1
    01648 9601      ADIW	R24,1
    01649 016C      MOVW	R12,R24
    0164A 92D0 050C STS	ff.c:Fsid+1,R13
    0164C 92C0 050B STS	ff.c:Fsid,R12
    0164E 82D7      STD	Z+7,R13
    0164F 82C6      STD	Z+6,R12
(2152) 	fs->winsect = 0;		/* Invalidate sector cache */
    01650 96BA      ADIW	R30,0x2A
    01651 E080      LDI	R24,0
    01652 8380      ST	Z,R24
    01653 8381      STD	Z+1,R24
    01654 8382      STD	Z+2,R24
    01655 8383      STD	Z+3,R24
(2153) 	fs->wflag = 0;
    01656 2422      CLR	R2
    01657 A1ED      LDD	R30,Y+37
    01658 A1FE      LDD	R31,Y+38
    01659 8224      STD	Z+4,R2
(2154) #if _FS_RPATH
(2155) 	fs->cdir = 0;			/* Current directory (root dir) */
(2156) #endif
(2157) #if _FS_SHARE				/* Clear file lock semaphores */
(2158) 	clear_lock(fs);
(2159) #endif
(2160) 
(2161) 	return FR_OK;
    0165A 2700      CLR	R16
    0165B 96A7      ADIW	R28,0x27
    0165C 940E 4106 CALL	pop_xgsetF0FC
    0165E 9622      ADIW	R28,2
    0165F 9508      RET
ff.c:validate:
  id                   --> R10
  fs                   --> R20
    01660 940E 411C CALL	push_xgset300C
    01662 0159      MOVW	R10,R18
    01663 01A8      MOVW	R20,R16
(2162) }
(2163) 
(2164) 
(2165) 
(2166) 
(2167) /*-----------------------------------------------------------------------*/
(2168) /* Check if the file/dir object is valid or not                          */
(2169) /*-----------------------------------------------------------------------*/
(2170) 
(2171) static
(2172) FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
(2173) 	FATFS *fs,		/* Pointer to the file system object */
(2174) 	WORD id			/* Member id of the target object to be checked */
(2175) )
(2176) {
(2177) 	if (!fs || !fs->fs_type || fs->id != id)
    01664 3040      CPI	R20,0
    01665 0745      CPC	R20,R21
    01666 F049      BEQ	0x1670
    01667 01FA      MOVW	R30,R20
    01668 8020      LD	R2,Z
    01669 2022      TST	R2
    0166A F029      BEQ	0x1670
    0166B 8026      LDD	R2,Z+6
    0166C 8037      LDD	R3,Z+7
    0166D 142A      CP	R2,R10
    0166E 043B      CPC	R3,R11
    0166F F011      BEQ	0x1672
(2178) 		return FR_INVALID_OBJECT;
    01670 E009      LDI	R16,0x9
    01671 C009      RJMP	0x167B
(2179) 
(2180) 	ENTER_FF(fs);		/* Lock file system */
(2181) 
(2182) 	if (disk_status(fs->drv) & STA_NOINIT)
    01672 01FA      MOVW	R30,R20
    01673 8101      LDD	R16,Z+1
    01674 940E 02A7 CALL	_disk_status
    01676 FF00      SBRS	R16,0
    01677 C002      RJMP	0x167A
(2183) 		return FR_NOT_READY;
    01678 E003      LDI	R16,3
    01679 C001      RJMP	0x167B
(2184) 
(2185) 	return FR_OK;
    0167A 2700      CLR	R16
    0167B 940C 4121 JMP	pop_xgset300C
_f_mount:
  rfs                  --> R10
  fs                   --> R18
  vol                  --> R16
    0167D 92AA      ST	-Y,R10
    0167E 92BA      ST	-Y,R11
(2186) }
(2187) 
(2188) 
(2189) 
(2190) 
(2191) /*--------------------------------------------------------------------------
(2192) 
(2193)    Public Functions
(2194) 
(2195) --------------------------------------------------------------------------*/
(2196) 
(2197) 
(2198) 
(2199) /*-----------------------------------------------------------------------*/
(2200) /* Mount/Unmount a Logical Drive                                         */
(2201) /*-----------------------------------------------------------------------*/
(2202) 
(2203) FRESULT f_mount (
(2204) 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
(2205) 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
(2206) )
(2207) {
(2208) 	FATFS *rfs;
(2209) 
(2210) 
(2211) 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    0167F 3001      CPI	R16,1
    01680 F010      BCS	0x1683
(2212) 		return FR_INVALID_DRIVE;
    01681 E00B      LDI	R16,0xB
    01682 C022      RJMP	0x16A5
(2213) 	rfs = FatFs[vol];			/* Get current fs object */
    01683 E08D      LDI	R24,0xD
    01684 E095      LDI	R25,5
    01685 2FE0      MOV	R30,R16
    01686 27FF      CLR	R31
    01687 0FEE      LSL	R30
    01688 1FFF      ROL	R31
    01689 0FE8      ADD	R30,R24
    0168A 1FF9      ADC	R31,R25
    0168B 80A0      LD	R10,Z
    0168C 80B1      LDD	R11,Z+1
(2214) 
(2215) 	if (rfs) {
    0168D 20AA      TST	R10
    0168E F411      BNE	0x1691
    0168F 20BB      TST	R11
    01690 F019      BEQ	0x1694
(2216) #if _FS_SHARE
(2217) 		clear_lock(rfs);
(2218) #endif
(2219) #if _FS_REENTRANT				/* Discard sync object of the current volume */
(2220) 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
(2221) #endif
(2222) 		rfs->fs_type = 0;		/* Clear old fs object */
    01691 2422      CLR	R2
    01692 01F5      MOVW	R30,R10
    01693 8220      ST	Z,R2
(2223) 	}
(2224) 
(2225) 	if (fs) {
    01694 3020      CPI	R18,0
    01695 0723      CPC	R18,R19
    01696 F019      BEQ	0x169A
(2226) 		fs->fs_type = 0;		/* Clear new fs object */
    01697 2422      CLR	R2
    01698 01F9      MOVW	R30,R18
    01699 8220      ST	Z,R2
(2227) #if _FS_REENTRANT				/* Create sync object for the new volume */
(2228) 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
(2229) #endif
(2230) 	}
(2231) 	FatFs[vol] = fs;			/* Register new fs object */
    0169A E08D      LDI	R24,0xD
    0169B E095      LDI	R25,5
    0169C 2FE0      MOV	R30,R16
    0169D 27FF      CLR	R31
    0169E 0FEE      LSL	R30
    0169F 1FFF      ROL	R31
    016A0 0FE8      ADD	R30,R24
    016A1 1FF9      ADC	R31,R25
    016A2 8331      STD	Z+1,R19
    016A3 8320      ST	Z,R18
(2232) 
(2233) 	return FR_OK;
    016A4 2700      CLR	R16
    016A5 90B9      LD	R11,Y+
    016A6 90A9      LD	R10,Y+
    016A7 9508      RET
_f_open:
  cl                   --> Y,+40
  dw                   --> Y,+36
  sfn                  --> Y,+24
  dj                   --> Y,+2
  res                  --> R10
  dir                  --> R14
  mode                 --> Y,+58
  path                 --> Y,+56
  fp                   --> Y,+54
    016A8 940E 3FCC CALL	push_arg4
    016AA 940E 4111 CALL	push_xgsetF0FC
    016AC 97AC      SBIW	R28,0x2C
(2234) }
(2235) 
(2236) 
(2237) 
(2238) 
(2239) /*-----------------------------------------------------------------------*/
(2240) /* Open or Create a File                                                 */
(2241) /*-----------------------------------------------------------------------*/
(2242) 
(2243) FRESULT f_open (
(2244) 	FIL *fp,			/* Pointer to the blank file object */
(2245) 	const TCHAR *path,	/* Pointer to the file name */
(2246) 	BYTE mode			/* Access mode and file open mode flags */
(2247) )
(2248) {
(2249) 	FRESULT res;
(2250) 	DIR dj;
(2251) 	BYTE *dir;
(2252) 	DEF_NAMEBUF;
(2253) 
(2254) 
(2255) 	fp->fs = 0;			/* Clear file object */
    016AD 2422      CLR	R2
    016AE 2433      CLR	R3
    016AF A9EE      LDD	R30,Y+54
    016B0 A9FF      LDD	R31,Y+55
    016B1 8231      STD	Z+1,R3
    016B2 8220      ST	Z,R2
(2256) 
(2257) #if !_FS_READONLY
(2258) 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    016B3 AD8A      LDD	R24,Y+58
    016B4 718F      ANDI	R24,0x1F
    016B5 AF8A      STD	Y+58,R24
(2259) 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    016B6 2799      CLR	R25
    016B7 7F8E      ANDI	R24,0xFE
    016B8 8388      ST	Y,R24
    016B9 019E      MOVW	R18,R28
    016BA 5F2E      SUBI	R18,0xFE
    016BB 4F3F      SBCI	R19,0xFF
    016BC 018E      MOVW	R16,R28
    016BD 5C08      SUBI	R16,0xC8
    016BE 4F1F      SBCI	R17,0xFF
    016BF DAA6      RCALL	ff.c:chk_mounted
    016C0 2EA0      MOV	R10,R16
(2260) #else
(2261) 	mode &= FA_READ;
(2262) 	res = chk_mounted(&path, &dj.fs, 0);
(2263) #endif
(2264) 	INIT_BUF(dj);
    016C1 01CE      MOVW	R24,R28
    016C2 9648      ADIW	R24,0x18
    016C3 8B9F      STD	Y+23,R25
    016C4 8B8E      STD	Y+22,R24
(2265) 	if (res == FR_OK)
    016C5 2300      TST	R16
    016C6 F439      BNE	0x16CE
(2266) 		res = follow_path(&dj, path);	/* Follow the file path */
    016C7 AD28      LDD	R18,Y+56
    016C8 AD39      LDD	R19,Y+57
    016C9 018E      MOVW	R16,R28
    016CA 5F0E      SUBI	R16,0xFE
    016CB 4F1F      SBCI	R17,0xFF
    016CC D94D      RCALL	ff.c:follow_path
    016CD 2EA0      MOV	R10,R16
(2267) 	dir = dj.dir;
    016CE 88EC      LDD	R14,Y+20
    016CF 88FD      LDD	R15,Y+21
(2268) 
(2269) #if !_FS_READONLY	/* R/W configuration */
(2270) 	if (res == FR_OK) {
    016D0 20AA      TST	R10
    016D1 F431      BNE	0x16D8
(2271) 		if (!dir)	/* Current dir itself */
    016D2 20EE      TST	R14
    016D3 F421      BNE	0x16D8
    016D4 20FF      TST	R15
    016D5 F411      BNE	0x16D8
(2272) 			res = FR_INVALID_NAME;
    016D6 E086      LDI	R24,6
    016D7 2EA8      MOV	R10,R24
(2273) #if _FS_SHARE
(2274) 		else
(2275) 			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2276) #endif
(2277) 	}
(2278) 	/* Create or Open a file */
(2279) 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    016D8 AD8A      LDD	R24,Y+58
    016D9 718C      ANDI	R24,0x1C
    016DA F409      BNE	0x16DC
    016DB C0C0      RJMP	0x179C
(2280) 		DWORD dw, cl;
(2281) 
(2282) 		if (res != FR_OK) {					/* No file, create new */
    016DC 20AA      TST	R10
    016DD F081      BEQ	0x16EE
(2283) 			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    016DE 2D8A      MOV	R24,R10
    016DF 3084      CPI	R24,4
    016E0 F439      BNE	0x16E8
(2284) #if _FS_SHARE
(2285) 				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
(2286) #else
(2287) 				res = dir_register(&dj);
    016E1 018E      MOVW	R16,R28
    016E2 5F0E      SUBI	R16,0xFE
    016E3 4F1F      SBCI	R17,0xFF
    016E4 940E 0E0C CALL	ff.c:dir_register
    016E6 2EC0      MOV	R12,R16
    016E7 2CAC      MOV	R10,R12
(2288) #endif
(2289) 			mode |= FA_CREATE_ALWAYS;		/* File is created */
    016E8 AD8A      LDD	R24,Y+58
    016E9 6088      ORI	R24,0x8
    016EA AF8A      STD	Y+58,R24
(2290) 			dir = dj.dir;					/* New entry */
    016EB 88EC      LDD	R14,Y+20
    016EC 88FD      LDD	R15,Y+21
(2291) 		}
    016ED C00C      RJMP	0x16FA
(2292) 		else {								/* Any object is already existing */
(2293) 			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    016EE 01F7      MOVW	R30,R14
    016EF 8583      LDD	R24,Z+11
    016F0 7181      ANDI	R24,0x11
    016F1 F019      BEQ	0x16F5
(2294) 				res = FR_DENIED;
    016F2 E087      LDI	R24,7
    016F3 2EA8      MOV	R10,R24
(2295) 			} else {
    016F4 C005      RJMP	0x16FA
(2296) 				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    016F5 AC0A      LDD	R0,Y+58
    016F6 FE02      SBRS	R0,2
    016F7 C002      RJMP	0x16FA
(2297) 					res = FR_EXIST;
    016F8 E088      LDI	R24,0x8
    016F9 2EA8      MOV	R10,R24
(2298) 			}
(2299) 		}
(2300) 		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    016FA 20AA      TST	R10
    016FB F009      BEQ	0x16FD
    016FC C0B1      RJMP	0x17AE
    016FD AC0A      LDD	R0,Y+58
    016FE FE03      SBRS	R0,3
    016FF C0AE      RJMP	0x17AE
(2301) 			dw = get_fattime();					/* Created time */
    01700 940E 02EA CALL	_get_fattime
    01702 A30C      STD	Y+36,R16
    01703 A31D      STD	Y+37,R17
    01704 A32E      STD	Y+38,R18
    01705 A33F      STD	Y+39,R19
(2302) 			ST_DWORD(dir+DIR_CrtTime, dw);
    01706 A02C      LDD	R2,Y+36
    01707 A03D      LDD	R3,Y+37
    01708 A04E      LDD	R4,Y+38
    01709 A05F      LDD	R5,Y+39
    0170A 01F7      MOVW	R30,R14
    0170B 8626      STD	Z+14,R2
    0170C 2C23      MOV	R2,R3
    0170D 2433      CLR	R3
    0170E 963F      ADIW	R30,0xF
    0170F 8220      ST	Z,R2
    01710 A02C      LDD	R2,Y+36
    01711 A03D      LDD	R3,Y+37
    01712 A04E      LDD	R4,Y+38
    01713 A05F      LDD	R5,Y+39
    01714 0112      MOVW	R2,R4
    01715 2444      CLR	R4
    01716 2455      CLR	R5
    01717 01F7      MOVW	R30,R14
    01718 9670      ADIW	R30,0x10
    01719 8220      ST	Z,R2
    0171A E188      LDI	R24,0x18
    0171B E090      LDI	R25,0
    0171C A10C      LDD	R16,Y+36
    0171D A11D      LDD	R17,Y+37
    0171E A12E      LDD	R18,Y+38
    0171F A13F      LDD	R19,Y+39
    01720 938A      ST	-Y,R24
    01721 940E 41AC CALL	lsr32
    01723 01F7      MOVW	R30,R14
    01724 8B01      STD	Z+17,R16
(2303) 			dir[DIR_Attr] = 0;					/* Reset attribute */
    01725 2422      CLR	R2
    01726 8623      STD	Z+11,R2
(2304) 			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    01727 8E24      STD	Z+28,R2
    01728 8E25      STD	Z+29,R2
    01729 8E26      STD	Z+30,R2
    0172A 8E27      STD	Z+31,R2
(2305) 			cl = LD_CLUST(dir);					/* Get start cluster */
    0172B 8C22      LDD	R2,Z+26
    0172C 2433      CLR	R3
    0172D 8C43      LDD	R4,Z+27
    0172E 2455      CLR	R5
    0172F 2C54      MOV	R5,R4
    01730 2444      CLR	R4
    01731 2842      OR	R4,R2
    01732 2853      OR	R5,R3
    01733 0112      MOVW	R2,R4
    01734 2444      CLR	R4
    01735 2455      CLR	R5
    01736 8864      LDD	R6,Z+20
    01737 2477      CLR	R7
    01738 9675      ADIW	R30,0x15
    01739 8080      LD	R8,Z
    0173A 2499      CLR	R9
    0173B 2C98      MOV	R9,R8
    0173C 2488      CLR	R8
    0173D 2886      OR	R8,R6
    0173E 2897      OR	R9,R7
    0173F 0134      MOVW	R6,R8
    01740 2488      CLR	R8
    01741 2499      CLR	R9
    01742 0143      MOVW	R8,R6
    01743 2466      CLR	R6
    01744 2477      CLR	R7
    01745 2862      OR	R6,R2
    01746 2873      OR	R7,R3
    01747 2884      OR	R8,R4
    01748 2895      OR	R9,R5
    01749 A668      STD	Y+40,R6
    0174A A679      STD	Y+41,R7
    0174B A68A      STD	Y+42,R8
    0174C A69B      STD	Y+43,R9
(2306) 			ST_CLUST(dir, 0);					/* cluster = 0 */
    0174D 2422      CLR	R2
    0174E 01F7      MOVW	R30,R14
    0174F 8E22      STD	Z+26,R2
    01750 8E23      STD	Z+27,R2
    01751 8A24      STD	Z+20,R2
    01752 8A25      STD	Z+21,R2
(2307) 			dj.fs->wflag = 1;
    01753 E081      LDI	R24,1
    01754 81EA      LDD	R30,Y+2
    01755 81FB      LDD	R31,Y+3
    01756 9634      ADIW	R30,4
    01757 8380      ST	Z,R24
(2308) 			if (cl) {							/* Remove the cluster chain if exist */
    01758 A428      LDD	R2,Y+40
    01759 A439      LDD	R3,Y+41
    0175A A44A      LDD	R4,Y+42
    0175B A45B      LDD	R5,Y+43
    0175C 9488      BCLR	0
    0175D 2022      TST	R2
    0175E 0432      CPC	R3,R2
    0175F 0442      CPC	R4,R2
    01760 0452      CPC	R5,R2
    01761 F409      BNE	0x1763
    01762 C04B      RJMP	0x17AE
(2309) 				dw = dj.fs->winsect;
    01763 81EA      LDD	R30,Y+2
    01764 81FB      LDD	R31,Y+3
    01765 A422      LDD	R2,Z+42
    01766 A433      LDD	R3,Z+43
    01767 A444      LDD	R4,Z+44
    01768 A455      LDD	R5,Z+45
    01769 A22C      STD	Y+36,R2
    0176A A23D      STD	Y+37,R3
    0176B A24E      STD	Y+38,R4
    0176C A25F      STD	Y+39,R5
(2310) 				res = remove_chain(dj.fs, cl);
    0176D A428      LDD	R2,Y+40
    0176E A439      LDD	R3,Y+41
    0176F A44A      LDD	R4,Y+42
    01770 A45B      LDD	R5,Y+43
    01771 8248      ST	Y,R4
    01772 8259      STD	Y+1,R5
    01773 0191      MOVW	R18,R2
    01774 810A      LDD	R16,Y+2
    01775 811B      LDD	R17,Y+3
    01776 940E 0820 CALL	ff.c:remove_chain
    01778 2EC0      MOV	R12,R16
    01779 2CAC      MOV	R10,R12
(2311) 				if (res == FR_OK) {
    0177A 2300      TST	R16
    0177B F591      BNE	0x17AE
(2312) 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    0177C E041      LDI	R20,1
    0177D E050      LDI	R21,0
    0177E E060      LDI	R22,0
    0177F E070      LDI	R23,0
    01780 A428      LDD	R2,Y+40
    01781 A439      LDD	R3,Y+41
    01782 A44A      LDD	R4,Y+42
    01783 A45B      LDD	R5,Y+43
    01784 1A24      SUB	R2,R20
    01785 0A35      SBC	R3,R21
    01786 0A46      SBC	R4,R22
    01787 0A57      SBC	R5,R23
    01788 81EA      LDD	R30,Y+2
    01789 81FB      LDD	R31,Y+3
    0178A 8622      STD	Z+10,R2
    0178B 8633      STD	Z+11,R3
    0178C 8644      STD	Z+12,R4
    0178D 8655      STD	Z+13,R5
(2313) 					res = move_window(dj.fs, dw);
    0178E A02C      LDD	R2,Y+36
    0178F A03D      LDD	R3,Y+37
    01790 A04E      LDD	R4,Y+38
    01791 A05F      LDD	R5,Y+39
    01792 8248      ST	Y,R4
    01793 8259      STD	Y+1,R5
    01794 0191      MOVW	R18,R2
    01795 810A      LDD	R16,Y+2
    01796 811B      LDD	R17,Y+3
    01797 940E 0348 CALL	ff.c:move_window
    01799 2EC0      MOV	R12,R16
    0179A 2CAC      MOV	R10,R12
(2314) 				}
(2315) 			}
(2316) 		}
(2317) 	}
    0179B C012      RJMP	0x17AE
(2318) 	else {	/* Open an existing file */
(2319) 		if (res == FR_OK) {						/* Follow succeeded */
    0179C 20AA      TST	R10
    0179D F481      BNE	0x17AE
(2320) 			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    0179E 01F7      MOVW	R30,R14
    0179F 8423      LDD	R2,Z+11
    017A0 FE24      SBRS	R2,4
    017A1 C003      RJMP	0x17A5
(2321) 				res = FR_NO_FILE;
    017A2 E084      LDI	R24,4
    017A3 2EA8      MOV	R10,R24
(2322) 			} else {
    017A4 C009      RJMP	0x17AE
(2323) 				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    017A5 AC0A      LDD	R0,Y+58
    017A6 FE01      SBRS	R0,1
    017A7 C006      RJMP	0x17AE
    017A8 01F7      MOVW	R30,R14
    017A9 8423      LDD	R2,Z+11
    017AA FE20      SBRS	R2,0
    017AB C002      RJMP	0x17AE
(2324) 					res = FR_DENIED;
    017AC E087      LDI	R24,7
    017AD 2EA8      MOV	R10,R24
(2325) 			}
(2326) 		}
(2327) 	}
(2328) 	if (res == FR_OK) {
    017AE 20AA      TST	R10
    017AF F4A1      BNE	0x17C4
(2329) 		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    017B0 AC0A      LDD	R0,Y+58
    017B1 FE03      SBRS	R0,3
    017B2 C003      RJMP	0x17B6
(2330) 			mode |= FA__WRITTEN;
    017B3 2D80      MOV	R24,R0
    017B4 6280      ORI	R24,0x20
    017B5 AF8A      STD	Y+58,R24
(2331) 		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    017B6 81EA      LDD	R30,Y+2
    017B7 81FB      LDD	R31,Y+3
    017B8 A422      LDD	R2,Z+42
    017B9 A433      LDD	R3,Z+43
    017BA A444      LDD	R4,Z+44
    017BB A455      LDD	R5,Z+45
    017BC A9EE      LDD	R30,Y+54
    017BD A9FF      LDD	R31,Y+55
    017BE 8E22      STD	Z+26,R2
    017BF 8E33      STD	Z+27,R3
    017C0 8E44      STD	Z+28,R4
    017C1 8E55      STD	Z+29,R5
(2332) 		fp->dir_ptr = dir;
    017C2 8EF7      STD	Z+31,R15
    017C3 8EE6      STD	Z+30,R14
(2333) #if _FS_SHARE
(2334) 		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2335) 		if (!fp->lockid) res = FR_INT_ERR;
(2336) #endif
(2337) 	}
(2338) 
(2339) #else				/* R/O configuration */
(2340) 	if (res == FR_OK) {					/* Follow succeeded */
(2341) 		if (!dir) {						/* Current dir itself */
(2342) 			res = FR_INVALID_NAME;
(2343) 		} else {
(2344) 			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
(2345) 				res = FR_NO_FILE;
(2346) 		}
(2347) 	}
(2348) #endif
(2349) 	FREE_BUF();
(2350) 
(2351) 	if (res == FR_OK) {
    017C4 20AA      TST	R10
    017C5 F009      BEQ	0x17C7
    017C6 C077      RJMP	0x183E
(2352) 		fp->flag = mode;					/* File access mode */
    017C7 A9EE      LDD	R30,Y+54
    017C8 A9FF      LDD	R31,Y+55
    017C9 AC0A      LDD	R0,Y+58
    017CA 8204      STD	Z+4,R0
(2353) 		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    017CB 01F7      MOVW	R30,R14
    017CC 8C22      LDD	R2,Z+26
    017CD 2433      CLR	R3
    017CE 8C43      LDD	R4,Z+27
    017CF 2455      CLR	R5
    017D0 2C54      MOV	R5,R4
    017D1 2444      CLR	R4
    017D2 2842      OR	R4,R2
    017D3 2853      OR	R5,R3
    017D4 0112      MOVW	R2,R4
    017D5 2444      CLR	R4
    017D6 2455      CLR	R5
    017D7 8864      LDD	R6,Z+20
    017D8 2477      CLR	R7
    017D9 8885      LDD	R8,Z+21
    017DA 2499      CLR	R9
    017DB 2C98      MOV	R9,R8
    017DC 2488      CLR	R8
    017DD 2886      OR	R8,R6
    017DE 2897      OR	R9,R7
    017DF 0134      MOVW	R6,R8
    017E0 2488      CLR	R8
    017E1 2499      CLR	R9
    017E2 0143      MOVW	R8,R6
    017E3 2466      CLR	R6
    017E4 2477      CLR	R7
    017E5 2862      OR	R6,R2
    017E6 2873      OR	R7,R3
    017E7 2884      OR	R8,R4
    017E8 2895      OR	R9,R5
    017E9 A9EE      LDD	R30,Y+54
    017EA A9FF      LDD	R31,Y+55
    017EB 8666      STD	Z+14,R6
    017EC 8677      STD	Z+15,R7
    017ED 8A80      STD	Z+16,R8
    017EE 8A91      STD	Z+17,R9
(2354) 		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    017EF E188      LDI	R24,0x18
    017F0 E090      LDI	R25,0
    017F1 01F7      MOVW	R30,R14
    017F2 8D07      LDD	R16,Z+31
    017F3 2711      CLR	R17
    017F4 2722      CLR	R18
    017F5 2733      CLR	R19
    017F6 938A      ST	-Y,R24
    017F7 940E 4193 CALL	lsl32
    017F9 0118      MOVW	R2,R16
    017FA 0129      MOVW	R4,R18
    017FB 01F7      MOVW	R30,R14
    017FC 8C66      LDD	R6,Z+30
    017FD 2477      CLR	R7
    017FE 2488      CLR	R8
    017FF 2499      CLR	R9
    01800 0143      MOVW	R8,R6
    01801 2466      CLR	R6
    01802 2477      CLR	R7
    01803 2826      OR	R2,R6
    01804 2837      OR	R3,R7
    01805 2848      OR	R4,R8
    01806 2859      OR	R5,R9
    01807 8C65      LDD	R6,Z+29
    01808 2477      CLR	R7
    01809 2C76      MOV	R7,R6
    0180A 2466      CLR	R6
    0180B 2488      CLR	R8
    0180C 2499      CLR	R9
    0180D 2826      OR	R2,R6
    0180E 2837      OR	R3,R7
    0180F 2848      OR	R4,R8
    01810 2859      OR	R5,R9
    01811 8C64      LDD	R6,Z+28
    01812 2477      CLR	R7
    01813 2488      CLR	R8
    01814 2499      CLR	R9
    01815 2826      OR	R2,R6
    01816 2837      OR	R3,R7
    01817 2848      OR	R4,R8
    01818 2859      OR	R5,R9
    01819 A9EE      LDD	R30,Y+54
    0181A A9FF      LDD	R31,Y+55
    0181B 8622      STD	Z+10,R2
    0181C 8633      STD	Z+11,R3
    0181D 8644      STD	Z+12,R4
    0181E 8655      STD	Z+13,R5
(2355) 		fp->fptr = 0;						/* File pointer */
    0181F 9636      ADIW	R30,6
    01820 E080      LDI	R24,0
    01821 8380      ST	Z,R24
    01822 8381      STD	Z+1,R24
    01823 8382      STD	Z+2,R24
    01824 8383      STD	Z+3,R24
(2356) 		fp->dsect = 0;
    01825 A9EE      LDD	R30,Y+54
    01826 A9FF      LDD	R31,Y+55
    01827 9676      ADIW	R30,0x16
    01828 E080      LDI	R24,0
    01829 8380      ST	Z,R24
    0182A 8381      STD	Z+1,R24
    0182B 8382      STD	Z+2,R24
    0182C 8383      STD	Z+3,R24
(2357) #if _USE_FASTSEEK
(2358) 		fp->cltbl = 0;						/* Normal seek mode */
    0182D 2422      CLR	R2
    0182E 2433      CLR	R3
    0182F A9EE      LDD	R30,Y+54
    01830 A9FF      LDD	R31,Y+55
    01831 A231      STD	Z+33,R3
    01832 A220      STD	Z+32,R2
(2359) #endif
(2360) 		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    01833 802A      LDD	R2,Y+2
    01834 803B      LDD	R3,Y+3
    01835 8231      STD	Z+1,R3
    01836 8220      ST	Z,R2
    01837 01F1      MOVW	R30,R2
    01838 8026      LDD	R2,Z+6
    01839 8037      LDD	R3,Z+7
    0183A A9EE      LDD	R30,Y+54
    0183B A9FF      LDD	R31,Y+55
    0183C 8233      STD	Z+3,R3
    0183D 8222      STD	Z+2,R2
(2361) 	}
(2362) 
(2363) 	LEAVE_FF(dj.fs, res);
    0183E 2D0A      MOV	R16,R10
    0183F 96AC      ADIW	R28,0x2C
    01840 940E 4106 CALL	pop_xgsetF0FC
    01842 9624      ADIW	R28,4
    01843 9508      RET
_f_read:
  remain               --> Y,+13
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  rbuff                --> R14
  sect                 --> Y,+5
  rcnt                 --> R12
  br                   --> Y,+33
  btr                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01844 940E 3FCC CALL	push_arg4
    01846 940E 4111 CALL	push_xgsetF0FC
    01848 0159      MOVW	R10,R18
    01849 9761      SBIW	R28,0x11
(2364) }
(2365) 
(2366) 
(2367) 
(2368) 
(2369) /*-----------------------------------------------------------------------*/
(2370) /* Read File                                                             */
(2371) /*-----------------------------------------------------------------------*/
(2372) 
(2373) FRESULT f_read (
(2374) 	FIL *fp, 		/* Pointer to the file object */
(2375) 	void *buff,		/* Pointer to data buffer */
(2376) 	UINT btr,		/* Number of bytes to read */
(2377) 	UINT *br		/* Pointer to number of bytes read */
(2378) )
(2379) {
(2380) 	FRESULT res;
(2381) 	DWORD clst, sect, remain;
(2382) 	UINT rcnt, cc;
(2383) 	BYTE csect, *rbuff = buff;
    0184A 0175      MOVW	R14,R10
(2384) 
(2385) 	memset(buff,0,512);
    0184B E080      LDI	R24,0
    0184C E092      LDI	R25,2
    0184D 8399      STD	Y+1,R25
    0184E 8388      ST	Y,R24
    0184F 2722      CLR	R18
    01850 2733      CLR	R19
    01851 0185      MOVW	R16,R10
    01852 940E 3FA8 CALL	_memset
(2386) 
(2387) 	*br = 0;	/* Initialize byte counter */
    01854 2422      CLR	R2
    01855 2433      CLR	R3
    01856 A1E9      LDD	R30,Y+33
    01857 A1FA      LDD	R31,Y+34
    01858 8231      STD	Z+1,R3
    01859 8220      ST	Z,R2
(2388) 
(2389) 	res = validate(fp->fs, fp->id);				/* Check validity */
    0185A 8DEB      LDD	R30,Y+27
    0185B 8DFC      LDD	R31,Y+28
    0185C 8122      LDD	R18,Z+2
    0185D 8133      LDD	R19,Z+3
    0185E 8100      LD	R16,Z
    0185F 8111      LDD	R17,Z+1
    01860 DDFF      RCALL	ff.c:validate
    01861 2EA0      MOV	R10,R16
(2390) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01862 2300      TST	R16
    01863 F009      BEQ	0x1865
    01864 C245      RJMP	0x1AAA
(2391) 	if (fp->flag & FA__ERROR)					/* Aborted file? */
    01865 8DEB      LDD	R30,Y+27
    01866 8DFC      LDD	R31,Y+28
    01867 8024      LDD	R2,Z+4
    01868 FE27      SBRS	R2,7
    01869 C002      RJMP	0x186C
(2392) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    0186A E002      LDI	R16,2
    0186B C23E      RJMP	0x1AAA
(2393) 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    0186C 8DEB      LDD	R30,Y+27
    0186D 8DFC      LDD	R31,Y+28
    0186E 8024      LDD	R2,Z+4
    0186F FC20      SBRC	R2,0
    01870 C002      RJMP	0x1873
(2394) 		LEAVE_FF(fp->fs, FR_DENIED);
    01871 E007      LDI	R16,7
    01872 C237      RJMP	0x1AAA
(2395) 	remain = fp->fsize - fp->fptr;
    01873 8DEB      LDD	R30,Y+27
    01874 8DFC      LDD	R31,Y+28
    01875 8026      LDD	R2,Z+6
    01876 8037      LDD	R3,Z+7
    01877 8440      LDD	R4,Z+8
    01878 8451      LDD	R5,Z+9
    01879 963A      ADIW	R30,0xA
    0187A 8060      LD	R6,Z
    0187B 8071      LDD	R7,Z+1
    0187C 8082      LDD	R8,Z+2
    0187D 8093      LDD	R9,Z+3
    0187E 1862      SUB	R6,R2
    0187F 0873      SBC	R7,R3
    01880 0884      SBC	R8,R4
    01881 0895      SBC	R9,R5
    01882 866D      STD	Y+13,R6
    01883 867E      STD	Y+14,R7
    01884 868F      STD	Y+15,R8
    01885 8A98      STD	Y+16,R9
(2396) 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    01886 842D      LDD	R2,Y+13
    01887 843E      LDD	R3,Y+14
    01888 844F      LDD	R4,Y+15
    01889 8858      LDD	R5,Y+16
    0188A 8C6F      LDD	R6,Y+31
    0188B A078      LDD	R7,Y+32
    0188C 2488      CLR	R8
    0188D 2499      CLR	R9
    0188E 1426      CP	R2,R6
    0188F 0437      CPC	R3,R7
    01890 0448      CPC	R4,R8
    01891 0459      CPC	R5,R9
    01892 F008      BCS	0x1894
    01893 C20D      RJMP	0x1AA1
    01894 A238      STD	Y+32,R3
    01895 8E2F      STD	Y+31,R2
(2397) 
(2398) 	for ( ;  btr;								/* Repeat until all data read */
    01896 C20A      RJMP	0x1AA1
(2399) 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
(2400) 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    01897 EF4F      LDI	R20,0xFF
    01898 E051      LDI	R21,1
    01899 E060      LDI	R22,0
    0189A E070      LDI	R23,0
    0189B 8DEB      LDD	R30,Y+27
    0189C 8DFC      LDD	R31,Y+28
    0189D 9636      ADIW	R30,6
    0189E 8020      LD	R2,Z
    0189F 8031      LDD	R3,Z+1
    018A0 8042      LDD	R4,Z+2
    018A1 8053      LDD	R5,Z+3
    018A2 2224      AND	R2,R20
    018A3 2235      AND	R3,R21
    018A4 2246      AND	R4,R22
    018A5 2257      AND	R5,R23
    018A6 9488      BCLR	0
    018A7 2022      TST	R2
    018A8 0432      CPC	R3,R2
    018A9 0442      CPC	R4,R2
    018AA 0452      CPC	R5,R2
    018AB F009      BEQ	0x18AD
    018AC C180      RJMP	0x1A2D
(2401) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    018AD E089      LDI	R24,0x9
    018AE E090      LDI	R25,0
    018AF 8DEB      LDD	R30,Y+27
    018B0 8DFC      LDD	R31,Y+28
    018B1 8106      LDD	R16,Z+6
    018B2 8117      LDD	R17,Z+7
    018B3 8520      LDD	R18,Z+8
    018B4 8531      LDD	R19,Z+9
    018B5 938A      ST	-Y,R24
    018B6 940E 41AC CALL	lsr32
    018B8 0118      MOVW	R2,R16
    018B9 0129      MOVW	R4,R18
    018BA 8DEB      LDD	R30,Y+27
    018BB 8DFC      LDD	R31,Y+28
    018BC 93AF      PUSH	R26
    018BD 93BF      PUSH	R27
    018BE 81A0      LD	R26,Z
    018BF 81B1      LDD	R27,Z+1
    018C0 01FD      MOVW	R30,R26
    018C1 91BF      POP	R27
    018C2 91AF      POP	R26
    018C3 8182      LDD	R24,Z+2
    018C4 2799      CLR	R25
    018C5 9701      SBIW	R24,1
    018C6 013C      MOVW	R6,R24
    018C7 2488      CLR	R8
    018C8 FC77      SBRC	R7,7
    018C9 9480      COM	R8
    018CA 2499      CLR	R9
    018CB FC87      SBRC	R8,7
    018CC 9490      COM	R9
    018CD 2026      AND	R2,R6
    018CE 2037      AND	R3,R7
    018CF 2048      AND	R4,R8
    018D0 2059      AND	R5,R9
    018D1 2CC2      MOV	R12,R2
(2402) 			if (!csect) {						/* On the cluster boundary? */
    018D2 2022      TST	R2
    018D3 F009      BEQ	0x18D5
    018D4 C078      RJMP	0x194D
(2403) 				if (fp->fptr == 0) {			/* On the top of the file? */
    018D5 8DEB      LDD	R30,Y+27
    018D6 8DFC      LDD	R31,Y+28
    018D7 9636      ADIW	R30,6
    018D8 8020      LD	R2,Z
    018D9 8031      LDD	R3,Z+1
    018DA 8042      LDD	R4,Z+2
    018DB 8053      LDD	R5,Z+3
    018DC 9488      BCLR	0
    018DD 2022      TST	R2
    018DE 0432      CPC	R3,R2
    018DF 0442      CPC	R4,R2
    018E0 0452      CPC	R5,R2
    018E1 F461      BNE	0x18EE
(2404) 					clst = fp->sclust;			/* Follow from the origin */
    018E2 8DEB      LDD	R30,Y+27
    018E3 8DFC      LDD	R31,Y+28
    018E4 963E      ADIW	R30,0xE
    018E5 8020      LD	R2,Z
    018E6 8031      LDD	R3,Z+1
    018E7 8042      LDD	R4,Z+2
    018E8 8053      LDD	R5,Z+3
    018E9 8629      STD	Y+9,R2
    018EA 863A      STD	Y+10,R3
    018EB 864B      STD	Y+11,R4
    018EC 865C      STD	Y+12,R5
(2405) 				} else {						/* Middle or end of the file */
    018ED C028      RJMP	0x1916
(2406) #if _USE_FASTSEEK
(2407) 					if (fp->cltbl)
    018EE 8DEB      LDD	R30,Y+27
    018EF 8DFC      LDD	R31,Y+28
    018F0 A020      LDD	R2,Z+32
    018F1 A031      LDD	R3,Z+33
    018F2 2022      TST	R2
    018F3 F411      BNE	0x18F6
    018F4 2033      TST	R3
    018F5 F079      BEQ	0x1905
(2408) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    018F6 8026      LDD	R2,Z+6
    018F7 8037      LDD	R3,Z+7
    018F8 8440      LDD	R4,Z+8
    018F9 8451      LDD	R5,Z+9
    018FA 8248      ST	Y,R4
    018FB 8259      STD	Y+1,R5
    018FC 0191      MOVW	R18,R2
    018FD 018F      MOVW	R16,R30
    018FE 940E 0A4B CALL	ff.c:clmt_clust
    01900 8709      STD	Y+9,R16
    01901 871A      STD	Y+10,R17
    01902 872B      STD	Y+11,R18
    01903 873C      STD	Y+12,R19
    01904 C011      RJMP	0x1916
(2409) 					else
(2410) #endif
(2411) 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    01905 8DEB      LDD	R30,Y+27
    01906 8DFC      LDD	R31,Y+28
    01907 8822      LDD	R2,Z+18
    01908 8833      LDD	R3,Z+19
    01909 8844      LDD	R4,Z+20
    0190A 8855      LDD	R5,Z+21
    0190B 8248      ST	Y,R4
    0190C 8259      STD	Y+1,R5
    0190D 0191      MOVW	R18,R2
    0190E 8100      LD	R16,Z
    0190F 8111      LDD	R17,Z+1
    01910 940E 0511 CALL	_get_fat
    01912 8709      STD	Y+9,R16
    01913 871A      STD	Y+10,R17
    01914 872B      STD	Y+11,R18
    01915 873C      STD	Y+12,R19
(2412) 				}
(2413) 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    01916 E042      LDI	R20,2
    01917 E050      LDI	R21,0
    01918 E060      LDI	R22,0
    01919 E070      LDI	R23,0
    0191A 8429      LDD	R2,Y+9
    0191B 843A      LDD	R3,Y+10
    0191C 844B      LDD	R4,Y+11
    0191D 845C      LDD	R5,Y+12
    0191E 1624      CP	R2,R20
    0191F 0635      CPC	R3,R21
    01920 0646      CPC	R4,R22
    01921 0657      CPC	R5,R23
    01922 F448      BCC	0x192C
    01923 8D8B      LDD	R24,Y+27
    01924 8D9C      LDD	R25,Y+28
    01925 9604      ADIW	R24,4
    01926 01FC      MOVW	R30,R24
    01927 8180      LD	R24,Z
    01928 6880      ORI	R24,0x80
    01929 8380      ST	Z,R24
    0192A E002      LDI	R16,2
    0192B C17E      RJMP	0x1AAA
(2414) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    0192C EF4F      LDI	R20,0xFF
    0192D EF5F      LDI	R21,0xFF
    0192E EF6F      LDI	R22,0xFF
    0192F EF7F      LDI	R23,0xFF
    01930 8429      LDD	R2,Y+9
    01931 843A      LDD	R3,Y+10
    01932 844B      LDD	R4,Y+11
    01933 845C      LDD	R5,Y+12
    01934 1624      CP	R2,R20
    01935 0635      CPC	R3,R21
    01936 0646      CPC	R4,R22
    01937 0657      CPC	R5,R23
    01938 F451      BNE	0x1943
    01939 8D8B      LDD	R24,Y+27
    0193A 8D9C      LDD	R25,Y+28
    0193B 9604      ADIW	R24,4
    0193C 015C      MOVW	R10,R24
    0193D 01FC      MOVW	R30,R24
    0193E 8180      LD	R24,Z
    0193F 6880      ORI	R24,0x80
    01940 8380      ST	Z,R24
    01941 E001      LDI	R16,1
    01942 C167      RJMP	0x1AAA
(2415) 				fp->clust = clst;				/* Update current cluster */
    01943 8429      LDD	R2,Y+9
    01944 843A      LDD	R3,Y+10
    01945 844B      LDD	R4,Y+11
    01946 845C      LDD	R5,Y+12
    01947 8DEB      LDD	R30,Y+27
    01948 8DFC      LDD	R31,Y+28
    01949 8A22      STD	Z+18,R2
    0194A 8A33      STD	Z+19,R3
    0194B 8A44      STD	Z+20,R4
    0194C 8A55      STD	Z+21,R5
(2416) 			}
(2417) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    0194D 8DEB      LDD	R30,Y+27
    0194E 8DFC      LDD	R31,Y+28
    0194F 8822      LDD	R2,Z+18
    01950 8833      LDD	R3,Z+19
    01951 8844      LDD	R4,Z+20
    01952 8855      LDD	R5,Z+21
    01953 8248      ST	Y,R4
    01954 8259      STD	Y+1,R5
    01955 0191      MOVW	R18,R2
    01956 8100      LD	R16,Z
    01957 8111      LDD	R17,Z+1
    01958 940E 04BF CALL	_clust2sect
    0195A 830D      STD	Y+5,R16
    0195B 831E      STD	Y+6,R17
    0195C 832F      STD	Y+7,R18
    0195D 8738      STD	Y+8,R19
(2418) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    0195E 802D      LDD	R2,Y+5
    0195F 803E      LDD	R3,Y+6
    01960 804F      LDD	R4,Y+7
    01961 8458      LDD	R5,Y+8
    01962 9488      BCLR	0
    01963 2022      TST	R2
    01964 0432      CPC	R3,R2
    01965 0442      CPC	R4,R2
    01966 0452      CPC	R5,R2
    01967 F451      BNE	0x1972
    01968 8D8B      LDD	R24,Y+27
    01969 8D9C      LDD	R25,Y+28
    0196A 9604      ADIW	R24,4
    0196B 015C      MOVW	R10,R24
    0196C 01FC      MOVW	R30,R24
    0196D 8180      LD	R24,Z
    0196E 6880      ORI	R24,0x80
    0196F 8380      ST	Z,R24
    01970 E002      LDI	R16,2
    01971 C138      RJMP	0x1AAA
(2419) 			sect += csect;
    01972 2C2C      MOV	R2,R12
    01973 2433      CLR	R3
    01974 2444      CLR	R4
    01975 2455      CLR	R5
    01976 806D      LDD	R6,Y+5
    01977 807E      LDD	R7,Y+6
    01978 808F      LDD	R8,Y+7
    01979 8498      LDD	R9,Y+8
    0197A 0C62      ADD	R6,R2
    0197B 1C73      ADC	R7,R3
    0197C 1C84      ADC	R8,R4
    0197D 1C95      ADC	R9,R5
    0197E 826D      STD	Y+5,R6
    0197F 827E      STD	Y+6,R7
    01980 828F      STD	Y+7,R8
    01981 8698      STD	Y+8,R9
(2420) 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    01982 E029      LDI	R18,0x9
    01983 E030      LDI	R19,0
    01984 8D0F      LDD	R16,Y+31
    01985 A118      LDD	R17,Y+32
    01986 940E 41A5 CALL	lsr16
    01988 0158      MOVW	R10,R16
(2421) 			if (cc) {							/* Read maximum contiguous sectors directly */
    01989 3000      CPI	R16,0
    0198A 0701      CPC	R16,R17
    0198B F409      BNE	0x198D
    0198C C096      RJMP	0x1A23
(2422) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    0198D 2C2C      MOV	R2,R12
    0198E 2433      CLR	R3
    0198F 0E20      ADD	R2,R16
    01990 1E31      ADC	R3,R17
    01991 8DEB      LDD	R30,Y+27
    01992 8DFC      LDD	R31,Y+28
    01993 93AF      PUSH	R26
    01994 93BF      PUSH	R27
    01995 81A0      LD	R26,Z
    01996 81B1      LDD	R27,Z+1
    01997 01FD      MOVW	R30,R26
    01998 91BF      POP	R27
    01999 91AF      POP	R26
    0199A 8042      LDD	R4,Z+2
    0199B 2455      CLR	R5
    0199C 1442      CP	R4,R2
    0199D 0453      CPC	R5,R3
    0199E F478      BCC	0x19AE
(2423) 					cc = fp->fs->csize - csect;
    0199F 2C2C      MOV	R2,R12
    019A0 2433      CLR	R3
    019A1 8DEB      LDD	R30,Y+27
    019A2 8DFC      LDD	R31,Y+28
    019A3 93AF      PUSH	R26
    019A4 93BF      PUSH	R27
    019A5 81A0      LD	R26,Z
    019A6 81B1      LDD	R27,Z+1
    019A7 01FD      MOVW	R30,R26
    019A8 91BF      POP	R27
    019A9 91AF      POP	R26
    019AA 80A2      LDD	R10,Z+2
    019AB 24BB      CLR	R11
    019AC 18A2      SUB	R10,R2
    019AD 08B3      SBC	R11,R3
(2424) 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    019AE 82AC      STD	Y+4,R10
    019AF 802D      LDD	R2,Y+5
    019B0 803E      LDD	R3,Y+6
    019B1 804F      LDD	R4,Y+7
    019B2 8458      LDD	R5,Y+8
    019B3 8228      ST	Y,R2
    019B4 8239      STD	Y+1,R3
    019B5 824A      STD	Y+2,R4
    019B6 825B      STD	Y+3,R5
    019B7 0197      MOVW	R18,R14
    019B8 8DEB      LDD	R30,Y+27
    019B9 8DFC      LDD	R31,Y+28
    019BA 93AF      PUSH	R26
    019BB 93BF      PUSH	R27
    019BC 81A0      LD	R26,Z
    019BD 81B1      LDD	R27,Z+1
    019BE 01FD      MOVW	R30,R26
    019BF 91BF      POP	R27
    019C0 91AF      POP	R26
    019C1 8101      LDD	R16,Z+1
    019C2 940E 02AD CALL	_disk_read
    019C4 2EC0      MOV	R12,R16
    019C5 2300      TST	R16
    019C6 F051      BEQ	0x19D1
(2425) 					ABORT(fp->fs, FR_DISK_ERR);
    019C7 8D8B      LDD	R24,Y+27
    019C8 8D9C      LDD	R25,Y+28
    019C9 9604      ADIW	R24,4
    019CA 016C      MOVW	R12,R24
    019CB 01FC      MOVW	R30,R24
    019CC 8180      LD	R24,Z
    019CD 6880      ORI	R24,0x80
    019CE 8380      ST	Z,R24
    019CF E001      LDI	R16,1
    019D0 C0D9      RJMP	0x1AAA
(2426) #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
(2427) #if _FS_TINY
(2428) 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    019D1 8DEB      LDD	R30,Y+27
    019D2 8DFC      LDD	R31,Y+28
    019D3 80C0      LD	R12,Z
    019D4 80D1      LDD	R13,Z+1
    019D5 01F6      MOVW	R30,R12
    019D6 9634      ADIW	R30,4
    019D7 8020      LD	R2,Z
    019D8 2022      TST	R2
    019D9 F409      BNE	0x19DB
    019DA C041      RJMP	0x1A1C
    019DB 802D      LDD	R2,Y+5
    019DC 803E      LDD	R3,Y+6
    019DD 804F      LDD	R4,Y+7
    019DE 8458      LDD	R5,Y+8
    019DF 01F6      MOVW	R30,R12
    019E0 A462      LDD	R6,Z+42
    019E1 A473      LDD	R7,Z+43
    019E2 A484      LDD	R8,Z+44
    019E3 A495      LDD	R9,Z+45
    019E4 1862      SUB	R6,R2
    019E5 0873      SBC	R7,R3
    019E6 0884      SBC	R8,R4
    019E7 0895      SBC	R9,R5
    019E8 0115      MOVW	R2,R10
    019E9 2444      CLR	R4
    019EA 2455      CLR	R5
    019EB 1462      CP	R6,R2
    019EC 0473      CPC	R7,R3
    019ED 0484      CPC	R8,R4
    019EE 0495      CPC	R9,R5
    019EF F560      BCC	0x1A1C
(2429) 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
    019F0 E080      LDI	R24,0
    019F1 E092      LDI	R25,2
    019F2 8399      STD	Y+1,R25
    019F3 8388      ST	Y,R24
    019F4 8DEB      LDD	R30,Y+27
    019F5 8DFC      LDD	R31,Y+28
    019F6 80C0      LD	R12,Z
    019F7 80D1      LDD	R13,Z+1
    019F8 0196      MOVW	R18,R12
    019F9 5D22      SUBI	R18,0xD2
    019FA 4F3F      SBCI	R19,0xFF
    019FB 802D      LDD	R2,Y+5
    019FC 803E      LDD	R3,Y+6
    019FD 804F      LDD	R4,Y+7
    019FE 8458      LDD	R5,Y+8
    019FF 01F6      MOVW	R30,R12
    01A00 A462      LDD	R6,Z+42
    01A01 A473      LDD	R7,Z+43
    01A02 A484      LDD	R8,Z+44
    01A03 A495      LDD	R9,Z+45
    01A04 1862      SUB	R6,R2
    01A05 0873      SBC	R7,R3
    01A06 0884      SBC	R8,R4
    01A07 0895      SBC	R9,R5
    01A08 E040      LDI	R20,0
    01A09 E052      LDI	R21,2
    01A0A E060      LDI	R22,0
    01A0B E070      LDI	R23,0
    01A0C 932F      PUSH	R18
    01A0D 933F      PUSH	R19
    01A0E 929A      ST	-Y,R9
    01A0F 928A      ST	-Y,R8
    01A10 927A      ST	-Y,R7
    01A11 926A      ST	-Y,R6
    01A12 018A      MOVW	R16,R20
    01A13 019B      MOVW	R18,R22
    01A14 940E 40BD CALL	empy32u|empy32s
    01A16 913F      POP	R19
    01A17 912F      POP	R18
    01A18 0D0E      ADD	R16,R14
    01A19 1D1F      ADC	R17,R15
    01A1A 940E 02EF CALL	ff.c:mem_cpy
(2430) #else
(2431) 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
(2432) 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
(2433) #endif
(2434) #endif
(2435) 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    01A1C E000      LDI	R16,0
    01A1D E012      LDI	R17,2
    01A1E 0195      MOVW	R18,R10
    01A1F 940E 40AD CALL	empy16s
    01A21 0168      MOVW	R12,R16
(2436) 				continue;
    01A22 C05A      RJMP	0x1A7D
(2437) 			}
(2438) #if !_FS_TINY
(2439) 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
(2440) #if !_FS_READONLY
(2441) 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2442) 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2443) 						ABORT(fp->fs, FR_DISK_ERR);
(2444) 					fp->flag &= ~FA__DIRTY;
(2445) 				}
(2446) #endif
(2447) 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
(2448) 					ABORT(fp->fs, FR_DISK_ERR);
(2449) 			}
(2450) #endif
(2451) 			fp->dsect = sect;
    01A23 802D      LDD	R2,Y+5
    01A24 803E      LDD	R3,Y+6
    01A25 804F      LDD	R4,Y+7
    01A26 8458      LDD	R5,Y+8
    01A27 8DEB      LDD	R30,Y+27
    01A28 8DFC      LDD	R31,Y+28
    01A29 8A26      STD	Z+22,R2
    01A2A 8A37      STD	Z+23,R3
    01A2B 8E40      STD	Z+24,R4
    01A2C 8E51      STD	Z+25,R5
(2452) 		}
(2453) 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    01A2D EF4F      LDI	R20,0xFF
    01A2E E051      LDI	R21,1
    01A2F E060      LDI	R22,0
    01A30 E070      LDI	R23,0
    01A31 8DEB      LDD	R30,Y+27
    01A32 8DFC      LDD	R31,Y+28
    01A33 8026      LDD	R2,Z+6
    01A34 8037      LDD	R3,Z+7
    01A35 8440      LDD	R4,Z+8
    01A36 8451      LDD	R5,Z+9
    01A37 2224      AND	R2,R20
    01A38 2235      AND	R3,R21
    01A39 2246      AND	R4,R22
    01A3A 2257      AND	R5,R23
    01A3B E040      LDI	R20,0
    01A3C E052      LDI	R21,2
    01A3D E060      LDI	R22,0
    01A3E E070      LDI	R23,0
    01A3F 1942      SUB	R20,R2
    01A40 0953      SBC	R21,R3
    01A41 0964      SBC	R22,R4
    01A42 0975      SBC	R23,R5
    01A43 016A      MOVW	R12,R20
(2454) 		if (rcnt > btr) rcnt = btr;
    01A44 8C0F      LDD	R0,Y+31
    01A45 A018      LDD	R1,Y+32
    01A46 1604      CP	R0,R20
    01A47 0615      CPC	R1,R21
    01A48 F408      BCC	0x1A4A
    01A49 0160      MOVW	R12,R0
(2455) #if _FS_TINY
(2456) 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    01A4A 8DEB      LDD	R30,Y+27
    01A4B 8DFC      LDD	R31,Y+28
    01A4C 8826      LDD	R2,Z+22
    01A4D 8837      LDD	R3,Z+23
    01A4E 8C40      LDD	R4,Z+24
    01A4F 8C51      LDD	R5,Z+25
    01A50 8248      ST	Y,R4
    01A51 8259      STD	Y+1,R5
    01A52 0191      MOVW	R18,R2
    01A53 8100      LD	R16,Z
    01A54 8111      LDD	R17,Z+1
    01A55 940E 0348 CALL	ff.c:move_window
    01A57 2EA0      MOV	R10,R16
    01A58 2300      TST	R16
    01A59 F051      BEQ	0x1A64
(2457) 			ABORT(fp->fs, FR_DISK_ERR);
    01A5A 8D8B      LDD	R24,Y+27
    01A5B 8D9C      LDD	R25,Y+28
    01A5C 9604      ADIW	R24,4
    01A5D 015C      MOVW	R10,R24
    01A5E 01FC      MOVW	R30,R24
    01A5F 8180      LD	R24,Z
    01A60 6880      ORI	R24,0x80
    01A61 8380      ST	Z,R24
    01A62 E001      LDI	R16,1
    01A63 C046      RJMP	0x1AAA
(2458) 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    01A64 82D9      STD	Y+1,R13
    01A65 82C8      ST	Y,R12
    01A66 EF4F      LDI	R20,0xFF
    01A67 E051      LDI	R21,1
    01A68 E060      LDI	R22,0
    01A69 E070      LDI	R23,0
    01A6A 8DEB      LDD	R30,Y+27
    01A6B 8DFC      LDD	R31,Y+28
    01A6C 8026      LDD	R2,Z+6
    01A6D 8037      LDD	R3,Z+7
    01A6E 8440      LDD	R4,Z+8
    01A6F 8451      LDD	R5,Z+9
    01A70 2224      AND	R2,R20
    01A71 2235      AND	R3,R21
    01A72 2246      AND	R4,R22
    01A73 2257      AND	R5,R23
    01A74 0191      MOVW	R18,R2
    01A75 8180      LD	R24,Z
    01A76 8191      LDD	R25,Z+1
    01A77 968E      ADIW	R24,0x2E
    01A78 0F28      ADD	R18,R24
    01A79 1F39      ADC	R19,R25
    01A7A 0187      MOVW	R16,R14
    01A7B 940E 02EF CALL	ff.c:mem_cpy
    01A7D 0CEC      ADD	R14,R12
    01A7E 1CFD      ADC	R15,R13
    01A7F 8D8B      LDD	R24,Y+27
    01A80 8D9C      LDD	R25,Y+28
    01A81 9606      ADIW	R24,6
    01A82 015C      MOVW	R10,R24
    01A83 0116      MOVW	R2,R12
    01A84 2444      CLR	R4
    01A85 2455      CLR	R5
    01A86 01FC      MOVW	R30,R24
    01A87 8060      LD	R6,Z
    01A88 8071      LDD	R7,Z+1
    01A89 8082      LDD	R8,Z+2
    01A8A 8093      LDD	R9,Z+3
    01A8B 0C62      ADD	R6,R2
    01A8C 1C73      ADC	R7,R3
    01A8D 1C84      ADC	R8,R4
    01A8E 1C95      ADC	R9,R5
    01A8F 8260      ST	Z,R6
    01A90 8271      STD	Z+1,R7
    01A91 8282      STD	Z+2,R8
    01A92 8293      STD	Z+3,R9
    01A93 A1E9      LDD	R30,Y+33
    01A94 A1FA      LDD	R31,Y+34
    01A95 8020      LD	R2,Z
    01A96 8031      LDD	R3,Z+1
    01A97 0C2C      ADD	R2,R12
    01A98 1C3D      ADC	R3,R13
    01A99 8231      STD	Z+1,R3
    01A9A 8220      ST	Z,R2
    01A9B 8C0F      LDD	R0,Y+31
    01A9C A018      LDD	R1,Y+32
    01A9D 180C      SUB	R0,R12
    01A9E 081D      SBC	R1,R13
    01A9F A218      STD	Y+32,R1
    01AA0 8E0F      STD	Y+31,R0
    01AA1 8C0F      LDD	R0,Y+31
    01AA2 A018      LDD	R1,Y+32
    01AA3 2000      TST	R0
    01AA4 F009      BEQ	0x1AA6
    01AA5 CDF1      RJMP	0x1897
    01AA6 2011      TST	R1
    01AA7 F009      BEQ	0x1AA9
    01AA8 CDEE      RJMP	0x1897
(2459) #else
(2460) 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
(2461) #endif
(2462) 	}
(2463) 
(2464) 	LEAVE_FF(fp->fs, FR_OK);
    01AA9 2700      CLR	R16
    01AAA 9661      ADIW	R28,0x11
    01AAB 940E 4106 CALL	pop_xgsetF0FC
    01AAD 9624      ADIW	R28,4
    01AAE 9508      RET
_f_write:
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  wbuff                --> R14
  sect                 --> Y,+5
  wcnt                 --> R12
  bw                   --> Y,+33
  btw                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01AAF 940E 3FCC CALL	push_arg4
    01AB1 940E 4111 CALL	push_xgsetF0FC
    01AB3 0159      MOVW	R10,R18
    01AB4 9761      SBIW	R28,0x11
(2465) }
(2466) 
(2467) 
(2468) 
(2469) 
(2470) #if !_FS_READONLY
(2471) /*-----------------------------------------------------------------------*/
(2472) /* Write File                                                            */
(2473) /*-----------------------------------------------------------------------*/
(2474) 
(2475) FRESULT f_write (
(2476) 	FIL *fp,			/* Pointer to the file object */
(2477) 	const void *buff,	/* Pointer to the data to be written */
(2478) 	UINT btw,			/* Number of bytes to write */
(2479) 	UINT *bw			/* Pointer to number of bytes written */
(2480) )
(2481) {
(2482) 	FRESULT res;
(2483) 	DWORD clst, sect;
(2484) 	UINT wcnt, cc;
(2485) 	const BYTE *wbuff = buff;
    01AB5 0175      MOVW	R14,R10
(2486) 	BYTE csect;
(2487) 
(2488) 
(2489) 	*bw = 0;	/* Initialize byte counter */
    01AB6 2422      CLR	R2
    01AB7 2433      CLR	R3
    01AB8 A1E9      LDD	R30,Y+33
    01AB9 A1FA      LDD	R31,Y+34
    01ABA 8231      STD	Z+1,R3
    01ABB 8220      ST	Z,R2
(2490) 
(2491) 	res = validate(fp->fs, fp->id);			/* Check validity */
    01ABC 8DEB      LDD	R30,Y+27
    01ABD 8DFC      LDD	R31,Y+28
    01ABE 8122      LDD	R18,Z+2
    01ABF 8133      LDD	R19,Z+3
    01AC0 8100      LD	R16,Z
    01AC1 8111      LDD	R17,Z+1
    01AC2 DB9D      RCALL	ff.c:validate
    01AC3 2EA0      MOV	R10,R16
(2492) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01AC4 2300      TST	R16
    01AC5 F009      BEQ	0x1AC7
    01AC6 C2FC      RJMP	0x1DC3
(2493) 	if (fp->flag & FA__ERROR)				/* Aborted file? */
    01AC7 8DEB      LDD	R30,Y+27
    01AC8 8DFC      LDD	R31,Y+28
    01AC9 8024      LDD	R2,Z+4
    01ACA FE27      SBRS	R2,7
    01ACB C002      RJMP	0x1ACE
(2494) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01ACC E002      LDI	R16,2
    01ACD C2F5      RJMP	0x1DC3
(2495) 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    01ACE 8DEB      LDD	R30,Y+27
    01ACF 8DFC      LDD	R31,Y+28
    01AD0 8024      LDD	R2,Z+4
    01AD1 FC21      SBRC	R2,1
    01AD2 C002      RJMP	0x1AD5
(2496) 		LEAVE_FF(fp->fs, FR_DENIED);
    01AD3 E007      LDI	R16,7
    01AD4 C2EE      RJMP	0x1DC3
(2497) 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    01AD5 8DEB      LDD	R30,Y+27
    01AD6 8DFC      LDD	R31,Y+28
    01AD7 963A      ADIW	R30,0xA
    01AD8 8020      LD	R2,Z
    01AD9 8031      LDD	R3,Z+1
    01ADA 8042      LDD	R4,Z+2
    01ADB 8053      LDD	R5,Z+3
    01ADC 862D      STD	Y+13,R2
    01ADD 863E      STD	Y+14,R3
    01ADE 864F      STD	Y+15,R4
    01ADF 8A58      STD	Y+16,R5
    01AE0 8C2F      LDD	R2,Y+31
    01AE1 A038      LDD	R3,Y+32
    01AE2 2444      CLR	R4
    01AE3 2455      CLR	R5
    01AE4 846D      LDD	R6,Y+13
    01AE5 847E      LDD	R7,Y+14
    01AE6 848F      LDD	R8,Y+15
    01AE7 8898      LDD	R9,Y+16
    01AE8 0C62      ADD	R6,R2
    01AE9 1C73      ADC	R7,R3
    01AEA 1C84      ADC	R8,R4
    01AEB 1C95      ADC	R9,R5
    01AEC 842D      LDD	R2,Y+13
    01AED 843E      LDD	R3,Y+14
    01AEE 844F      LDD	R4,Y+15
    01AEF 8858      LDD	R5,Y+16
    01AF0 1462      CP	R6,R2
    01AF1 0473      CPC	R7,R3
    01AF2 0484      CPC	R8,R4
    01AF3 0495      CPC	R9,R5
    01AF4 F008      BCS	0x1AF6
    01AF5 C2A5      RJMP	0x1D9B
    01AF6 2400      CLR	R0
    01AF7 2411      CLR	R1
    01AF8 A218      STD	Y+32,R1
    01AF9 8E0F      STD	Y+31,R0
(2498) 
(2499) 	for ( ;  btw;							/* Repeat until all data written */
    01AFA C2A0      RJMP	0x1D9B
(2500) 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
(2501) 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    01AFB EF4F      LDI	R20,0xFF
    01AFC E051      LDI	R21,1
    01AFD E060      LDI	R22,0
    01AFE E070      LDI	R23,0
    01AFF 8DEB      LDD	R30,Y+27
    01B00 8DFC      LDD	R31,Y+28
    01B01 9636      ADIW	R30,6
    01B02 8020      LD	R2,Z
    01B03 8031      LDD	R3,Z+1
    01B04 8042      LDD	R4,Z+2
    01B05 8053      LDD	R5,Z+3
    01B06 2224      AND	R2,R20
    01B07 2235      AND	R3,R21
    01B08 2246      AND	R4,R22
    01B09 2257      AND	R5,R23
    01B0A 9488      BCLR	0
    01B0B 2022      TST	R2
    01B0C 0432      CPC	R3,R2
    01B0D 0442      CPC	R4,R2
    01B0E 0452      CPC	R5,R2
    01B0F F009      BEQ	0x1B11
    01B10 C20B      RJMP	0x1D1C
(2502) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01B11 E089      LDI	R24,0x9
    01B12 E090      LDI	R25,0
    01B13 8DEB      LDD	R30,Y+27
    01B14 8DFC      LDD	R31,Y+28
    01B15 8106      LDD	R16,Z+6
    01B16 8117      LDD	R17,Z+7
    01B17 8520      LDD	R18,Z+8
    01B18 8531      LDD	R19,Z+9
    01B19 938A      ST	-Y,R24
    01B1A 940E 41AC CALL	lsr32
    01B1C 0118      MOVW	R2,R16
    01B1D 0129      MOVW	R4,R18
    01B1E 8DEB      LDD	R30,Y+27
    01B1F 8DFC      LDD	R31,Y+28
    01B20 93AF      PUSH	R26
    01B21 93BF      PUSH	R27
    01B22 81A0      LD	R26,Z
    01B23 81B1      LDD	R27,Z+1
    01B24 01FD      MOVW	R30,R26
    01B25 91BF      POP	R27
    01B26 91AF      POP	R26
    01B27 8182      LDD	R24,Z+2
    01B28 2799      CLR	R25
    01B29 9701      SBIW	R24,1
    01B2A 013C      MOVW	R6,R24
    01B2B 2488      CLR	R8
    01B2C FC77      SBRC	R7,7
    01B2D 9480      COM	R8
    01B2E 2499      CLR	R9
    01B2F FC87      SBRC	R8,7
    01B30 9490      COM	R9
    01B31 2026      AND	R2,R6
    01B32 2037      AND	R3,R7
    01B33 2048      AND	R4,R8
    01B34 2059      AND	R5,R9
    01B35 2CC2      MOV	R12,R2
(2503) 			if (!csect) {					/* On the cluster boundary? */
    01B36 2022      TST	R2
    01B37 F009      BEQ	0x1B39
    01B38 C0A5      RJMP	0x1BDE
(2504) 				if (fp->fptr == 0) {		/* On the top of the file? */
    01B39 8DEB      LDD	R30,Y+27
    01B3A 8DFC      LDD	R31,Y+28
    01B3B 9636      ADIW	R30,6
    01B3C 8020      LD	R2,Z
    01B3D 8031      LDD	R3,Z+1
    01B3E 8042      LDD	R4,Z+2
    01B3F 8053      LDD	R5,Z+3
    01B40 9488      BCLR	0
    01B41 2022      TST	R2
    01B42 0432      CPC	R3,R2
    01B43 0442      CPC	R4,R2
    01B44 0452      CPC	R5,R2
    01B45 F571      BNE	0x1B74
(2505) 					clst = fp->sclust;		/* Follow from the origin */
    01B46 8DEB      LDD	R30,Y+27
    01B47 8DFC      LDD	R31,Y+28
    01B48 963E      ADIW	R30,0xE
    01B49 8020      LD	R2,Z
    01B4A 8031      LDD	R3,Z+1
    01B4B 8042      LDD	R4,Z+2
    01B4C 8053      LDD	R5,Z+3
    01B4D 8629      STD	Y+9,R2
    01B4E 863A      STD	Y+10,R3
    01B4F 864B      STD	Y+11,R4
    01B50 865C      STD	Y+12,R5
(2506) 					if (clst == 0)			/* When no cluster is allocated, */
    01B51 8429      LDD	R2,Y+9
    01B52 843A      LDD	R3,Y+10
    01B53 844B      LDD	R4,Y+11
    01B54 845C      LDD	R5,Y+12
    01B55 9488      BCLR	0
    01B56 2022      TST	R2
    01B57 0432      CPC	R3,R2
    01B58 0442      CPC	R4,R2
    01B59 0452      CPC	R5,R2
    01B5A F009      BEQ	0x1B5C
    01B5B C040      RJMP	0x1B9C
(2507) 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    01B5C E040      LDI	R20,0
    01B5D E050      LDI	R21,0
    01B5E E060      LDI	R22,0
    01B5F E070      LDI	R23,0
    01B60 8368      ST	Y,R22
    01B61 8379      STD	Y+1,R23
    01B62 019A      MOVW	R18,R20
    01B63 8DEB      LDD	R30,Y+27
    01B64 8DFC      LDD	R31,Y+28
    01B65 8100      LD	R16,Z
    01B66 8111      LDD	R17,Z+1
    01B67 940E 08D3 CALL	ff.c:create_chain
    01B69 8709      STD	Y+9,R16
    01B6A 871A      STD	Y+10,R17
    01B6B 872B      STD	Y+11,R18
    01B6C 873C      STD	Y+12,R19
    01B6D 8DEB      LDD	R30,Y+27
    01B6E 8DFC      LDD	R31,Y+28
    01B6F 8706      STD	Z+14,R16
    01B70 8717      STD	Z+15,R17
    01B71 8B20      STD	Z+16,R18
    01B72 8B31      STD	Z+17,R19
(2508) 				} else {					/* Middle or end of the file */
    01B73 C028      RJMP	0x1B9C
(2509) #if _USE_FASTSEEK
(2510) 					if (fp->cltbl)
    01B74 8DEB      LDD	R30,Y+27
    01B75 8DFC      LDD	R31,Y+28
    01B76 A020      LDD	R2,Z+32
    01B77 A031      LDD	R3,Z+33
    01B78 2022      TST	R2
    01B79 F411      BNE	0x1B7C
    01B7A 2033      TST	R3
    01B7B F079      BEQ	0x1B8B
(2511) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    01B7C 8026      LDD	R2,Z+6
    01B7D 8037      LDD	R3,Z+7
    01B7E 8440      LDD	R4,Z+8
    01B7F 8451      LDD	R5,Z+9
    01B80 8248      ST	Y,R4
    01B81 8259      STD	Y+1,R5
    01B82 0191      MOVW	R18,R2
    01B83 018F      MOVW	R16,R30
    01B84 940E 0A4B CALL	ff.c:clmt_clust
    01B86 8709      STD	Y+9,R16
    01B87 871A      STD	Y+10,R17
    01B88 872B      STD	Y+11,R18
    01B89 873C      STD	Y+12,R19
    01B8A C011      RJMP	0x1B9C
(2512) 					else
(2513) #endif
(2514) 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    01B8B 8DEB      LDD	R30,Y+27
    01B8C 8DFC      LDD	R31,Y+28
    01B8D 8822      LDD	R2,Z+18
    01B8E 8833      LDD	R3,Z+19
    01B8F 8844      LDD	R4,Z+20
    01B90 8855      LDD	R5,Z+21
    01B91 8248      ST	Y,R4
    01B92 8259      STD	Y+1,R5
    01B93 0191      MOVW	R18,R2
    01B94 8100      LD	R16,Z
    01B95 8111      LDD	R17,Z+1
    01B96 940E 08D3 CALL	ff.c:create_chain
    01B98 8709      STD	Y+9,R16
    01B99 871A      STD	Y+10,R17
    01B9A 872B      STD	Y+11,R18
    01B9B 873C      STD	Y+12,R19
(2515) 				}
(2516) 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    01B9C 8429      LDD	R2,Y+9
    01B9D 843A      LDD	R3,Y+10
    01B9E 844B      LDD	R4,Y+11
    01B9F 845C      LDD	R5,Y+12
    01BA0 9488      BCLR	0
    01BA1 2022      TST	R2
    01BA2 0432      CPC	R3,R2
    01BA3 0442      CPC	R4,R2
    01BA4 0452      CPC	R5,R2
    01BA5 F409      BNE	0x1BA7
    01BA6 C1FC      RJMP	0x1DA3
(2517) 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    01BA7 E041      LDI	R20,1
    01BA8 E050      LDI	R21,0
    01BA9 E060      LDI	R22,0
    01BAA E070      LDI	R23,0
    01BAB 8429      LDD	R2,Y+9
    01BAC 843A      LDD	R3,Y+10
    01BAD 844B      LDD	R4,Y+11
    01BAE 845C      LDD	R5,Y+12
    01BAF 1624      CP	R2,R20
    01BB0 0635      CPC	R3,R21
    01BB1 0646      CPC	R4,R22
    01BB2 0657      CPC	R5,R23
    01BB3 F449      BNE	0x1BBD
    01BB4 8D8B      LDD	R24,Y+27
    01BB5 8D9C      LDD	R25,Y+28
    01BB6 9604      ADIW	R24,4
    01BB7 01FC      MOVW	R30,R24
    01BB8 8180      LD	R24,Z
    01BB9 6880      ORI	R24,0x80
    01BBA 8380      ST	Z,R24
    01BBB E002      LDI	R16,2
    01BBC C206      RJMP	0x1DC3
(2518) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01BBD EF4F      LDI	R20,0xFF
    01BBE EF5F      LDI	R21,0xFF
    01BBF EF6F      LDI	R22,0xFF
    01BC0 EF7F      LDI	R23,0xFF
    01BC1 8429      LDD	R2,Y+9
    01BC2 843A      LDD	R3,Y+10
    01BC3 844B      LDD	R4,Y+11
    01BC4 845C      LDD	R5,Y+12
    01BC5 1624      CP	R2,R20
    01BC6 0635      CPC	R3,R21
    01BC7 0646      CPC	R4,R22
    01BC8 0657      CPC	R5,R23
    01BC9 F451      BNE	0x1BD4
    01BCA 8D8B      LDD	R24,Y+27
    01BCB 8D9C      LDD	R25,Y+28
    01BCC 9604      ADIW	R24,4
    01BCD 015C      MOVW	R10,R24
    01BCE 01FC      MOVW	R30,R24
    01BCF 8180      LD	R24,Z
    01BD0 6880      ORI	R24,0x80
    01BD1 8380      ST	Z,R24
    01BD2 E001      LDI	R16,1
    01BD3 C1EF      RJMP	0x1DC3
(2519) 				fp->clust = clst;			/* Update current cluster */
    01BD4 8429      LDD	R2,Y+9
    01BD5 843A      LDD	R3,Y+10
    01BD6 844B      LDD	R4,Y+11
    01BD7 845C      LDD	R5,Y+12
    01BD8 8DEB      LDD	R30,Y+27
    01BD9 8DFC      LDD	R31,Y+28
    01BDA 8A22      STD	Z+18,R2
    01BDB 8A33      STD	Z+19,R3
    01BDC 8A44      STD	Z+20,R4
    01BDD 8A55      STD	Z+21,R5
(2520) 			}
(2521) #if _FS_TINY
(2522) 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
    01BDE 8DEB      LDD	R30,Y+27
    01BDF 8DFC      LDD	R31,Y+28
    01BE0 80A0      LD	R10,Z
    01BE1 80B1      LDD	R11,Z+1
    01BE2 8826      LDD	R2,Z+22
    01BE3 8837      LDD	R3,Z+23
    01BE4 8C40      LDD	R4,Z+24
    01BE5 8C51      LDD	R5,Z+25
    01BE6 01F5      MOVW	R30,R10
    01BE7 A462      LDD	R6,Z+42
    01BE8 A473      LDD	R7,Z+43
    01BE9 A484      LDD	R8,Z+44
    01BEA A495      LDD	R9,Z+45
    01BEB 1462      CP	R6,R2
    01BEC 0473      CPC	R7,R3
    01BED 0484      CPC	R8,R4
    01BEE 0495      CPC	R9,R5
    01BEF F4B9      BNE	0x1C07
    01BF0 E040      LDI	R20,0
    01BF1 E050      LDI	R21,0
    01BF2 E060      LDI	R22,0
    01BF3 E070      LDI	R23,0
    01BF4 8368      ST	Y,R22
    01BF5 8379      STD	Y+1,R23
    01BF6 019A      MOVW	R18,R20
    01BF7 018F      MOVW	R16,R30
    01BF8 940E 0348 CALL	ff.c:move_window
    01BFA 2EA0      MOV	R10,R16
    01BFB 2300      TST	R16
    01BFC F051      BEQ	0x1C07
(2523) 				ABORT(fp->fs, FR_DISK_ERR);
    01BFD 8D8B      LDD	R24,Y+27
    01BFE 8D9C      LDD	R25,Y+28
    01BFF 9604      ADIW	R24,4
    01C00 015C      MOVW	R10,R24
    01C01 01FC      MOVW	R30,R24
    01C02 8180      LD	R24,Z
    01C03 6880      ORI	R24,0x80
    01C04 8380      ST	Z,R24
    01C05 E001      LDI	R16,1
    01C06 C1BC      RJMP	0x1DC3
(2524) #else
(2525) 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
(2526) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2527) 					ABORT(fp->fs, FR_DISK_ERR);
(2528) 				fp->flag &= ~FA__DIRTY;
(2529) 			}
(2530) #endif
(2531) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01C07 8DEB      LDD	R30,Y+27
    01C08 8DFC      LDD	R31,Y+28
    01C09 8822      LDD	R2,Z+18
    01C0A 8833      LDD	R3,Z+19
    01C0B 8844      LDD	R4,Z+20
    01C0C 8855      LDD	R5,Z+21
    01C0D 8248      ST	Y,R4
    01C0E 8259      STD	Y+1,R5
    01C0F 0191      MOVW	R18,R2
    01C10 8100      LD	R16,Z
    01C11 8111      LDD	R17,Z+1
    01C12 940E 04BF CALL	_clust2sect
    01C14 830D      STD	Y+5,R16
    01C15 831E      STD	Y+6,R17
    01C16 832F      STD	Y+7,R18
    01C17 8738      STD	Y+8,R19
(2532) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01C18 802D      LDD	R2,Y+5
    01C19 803E      LDD	R3,Y+6
    01C1A 804F      LDD	R4,Y+7
    01C1B 8458      LDD	R5,Y+8
    01C1C 9488      BCLR	0
    01C1D 2022      TST	R2
    01C1E 0432      CPC	R3,R2
    01C1F 0442      CPC	R4,R2
    01C20 0452      CPC	R5,R2
    01C21 F451      BNE	0x1C2C
    01C22 8D8B      LDD	R24,Y+27
    01C23 8D9C      LDD	R25,Y+28
    01C24 9604      ADIW	R24,4
    01C25 015C      MOVW	R10,R24
    01C26 01FC      MOVW	R30,R24
    01C27 8180      LD	R24,Z
    01C28 6880      ORI	R24,0x80
    01C29 8380      ST	Z,R24
    01C2A E002      LDI	R16,2
    01C2B C197      RJMP	0x1DC3
(2533) 			sect += csect;
    01C2C 2C2C      MOV	R2,R12
    01C2D 2433      CLR	R3
    01C2E 2444      CLR	R4
    01C2F 2455      CLR	R5
    01C30 806D      LDD	R6,Y+5
    01C31 807E      LDD	R7,Y+6
    01C32 808F      LDD	R8,Y+7
    01C33 8498      LDD	R9,Y+8
    01C34 0C62      ADD	R6,R2
    01C35 1C73      ADC	R7,R3
    01C36 1C84      ADC	R8,R4
    01C37 1C95      ADC	R9,R5
    01C38 826D      STD	Y+5,R6
    01C39 827E      STD	Y+6,R7
    01C3A 828F      STD	Y+7,R8
    01C3B 8698      STD	Y+8,R9
(2534) 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    01C3C E029      LDI	R18,0x9
    01C3D E030      LDI	R19,0
    01C3E 8D0F      LDD	R16,Y+31
    01C3F A118      LDD	R17,Y+32
    01C40 940E 41A5 CALL	lsr16
    01C42 0158      MOVW	R10,R16
(2535) 			if (cc) {						/* Write maximum contiguous sectors directly */
    01C43 3000      CPI	R16,0
    01C44 0701      CPC	R16,R17
    01C45 F409      BNE	0x1C47
    01C46 C097      RJMP	0x1CDE
(2536) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01C47 2C2C      MOV	R2,R12
    01C48 2433      CLR	R3
    01C49 0E20      ADD	R2,R16
    01C4A 1E31      ADC	R3,R17
    01C4B 8DEB      LDD	R30,Y+27
    01C4C 8DFC      LDD	R31,Y+28
    01C4D 93AF      PUSH	R26
    01C4E 93BF      PUSH	R27
    01C4F 81A0      LD	R26,Z
    01C50 81B1      LDD	R27,Z+1
    01C51 01FD      MOVW	R30,R26
    01C52 91BF      POP	R27
    01C53 91AF      POP	R26
    01C54 8042      LDD	R4,Z+2
    01C55 2455      CLR	R5
    01C56 1442      CP	R4,R2
    01C57 0453      CPC	R5,R3
    01C58 F478      BCC	0x1C68
(2537) 					cc = fp->fs->csize - csect;
    01C59 2C2C      MOV	R2,R12
    01C5A 2433      CLR	R3
    01C5B 8DEB      LDD	R30,Y+27
    01C5C 8DFC      LDD	R31,Y+28
    01C5D 93AF      PUSH	R26
    01C5E 93BF      PUSH	R27
    01C5F 81A0      LD	R26,Z
    01C60 81B1      LDD	R27,Z+1
    01C61 01FD      MOVW	R30,R26
    01C62 91BF      POP	R27
    01C63 91AF      POP	R26
    01C64 80A2      LDD	R10,Z+2
    01C65 24BB      CLR	R11
    01C66 18A2      SUB	R10,R2
    01C67 08B3      SBC	R11,R3
(2538) 				if (disk_write(fp->fs->drv,(char*)wbuff, sect, (BYTE)cc) != RES_OK)
    01C68 82AC      STD	Y+4,R10
    01C69 802D      LDD	R2,Y+5
    01C6A 803E      LDD	R3,Y+6
    01C6B 804F      LDD	R4,Y+7
    01C6C 8458      LDD	R5,Y+8
    01C6D 8228      ST	Y,R2
    01C6E 8239      STD	Y+1,R3
    01C6F 824A      STD	Y+2,R4
    01C70 825B      STD	Y+3,R5
    01C71 0197      MOVW	R18,R14
    01C72 8DEB      LDD	R30,Y+27
    01C73 8DFC      LDD	R31,Y+28
    01C74 93AF      PUSH	R26
    01C75 93BF      PUSH	R27
    01C76 81A0      LD	R26,Z
    01C77 81B1      LDD	R27,Z+1
    01C78 01FD      MOVW	R30,R26
    01C79 91BF      POP	R27
    01C7A 91AF      POP	R26
    01C7B 8101      LDD	R16,Z+1
    01C7C 940E 02CD CALL	_disk_write
    01C7E 2EC0      MOV	R12,R16
    01C7F 2300      TST	R16
    01C80 F051      BEQ	0x1C8B
(2539) 					ABORT(fp->fs, FR_DISK_ERR);
    01C81 8D8B      LDD	R24,Y+27
    01C82 8D9C      LDD	R25,Y+28
    01C83 9604      ADIW	R24,4
    01C84 016C      MOVW	R12,R24
    01C85 01FC      MOVW	R30,R24
    01C86 8180      LD	R24,Z
    01C87 6880      ORI	R24,0x80
    01C88 8380      ST	Z,R24
    01C89 E001      LDI	R16,1
    01C8A C138      RJMP	0x1DC3
(2540) #if _FS_TINY
(2541) 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
    01C8B 802D      LDD	R2,Y+5
    01C8C 803E      LDD	R3,Y+6
    01C8D 804F      LDD	R4,Y+7
    01C8E 8458      LDD	R5,Y+8
    01C8F 8DEB      LDD	R30,Y+27
    01C90 8DFC      LDD	R31,Y+28
    01C91 81A0      LD	R26,Z
    01C92 81B1      LDD	R27,Z+1
    01C93 969A      ADIW	R26,0x2A
    01C94 906D      LD	R6,X+
    01C95 907D      LD	R7,X+
    01C96 908D      LD	R8,X+
    01C97 909C      LD	R9,X
    01C98 1862      SUB	R6,R2
    01C99 0873      SBC	R7,R3
    01C9A 0884      SBC	R8,R4
    01C9B 0895      SBC	R9,R5
    01C9C 0115      MOVW	R2,R10
    01C9D 2444      CLR	R4
    01C9E 2455      CLR	R5
    01C9F 1462      CP	R6,R2
    01CA0 0473      CPC	R7,R3
    01CA1 0484      CPC	R8,R4
    01CA2 0495      CPC	R9,R5
    01CA3 F008      BCS	0x1CA5
    01CA4 C032      RJMP	0x1CD7
(2542) 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
    01CA5 E080      LDI	R24,0
    01CA6 E092      LDI	R25,2
    01CA7 8399      STD	Y+1,R25
    01CA8 8388      ST	Y,R24
    01CA9 80C0      LD	R12,Z
    01CAA 80D1      LDD	R13,Z+1
    01CAB 802D      LDD	R2,Y+5
    01CAC 803E      LDD	R3,Y+6
    01CAD 804F      LDD	R4,Y+7
    01CAE 8458      LDD	R5,Y+8
    01CAF 01F6      MOVW	R30,R12
    01CB0 A462      LDD	R6,Z+42
    01CB1 A473      LDD	R7,Z+43
    01CB2 A484      LDD	R8,Z+44
    01CB3 A495      LDD	R9,Z+45
    01CB4 1862      SUB	R6,R2
    01CB5 0873      SBC	R7,R3
    01CB6 0884      SBC	R8,R4
    01CB7 0895      SBC	R9,R5
    01CB8 E040      LDI	R20,0
    01CB9 E052      LDI	R21,2
    01CBA E060      LDI	R22,0
    01CBB E070      LDI	R23,0
    01CBC 929A      ST	-Y,R9
    01CBD 928A      ST	-Y,R8
    01CBE 927A      ST	-Y,R7
    01CBF 926A      ST	-Y,R6
    01CC0 018A      MOVW	R16,R20
    01CC1 019B      MOVW	R18,R22
    01CC2 940E 40BD CALL	empy32u|empy32s
    01CC4 0198      MOVW	R18,R16
    01CC5 0D2E      ADD	R18,R14
    01CC6 1D3F      ADC	R19,R15
    01CC7 0186      MOVW	R16,R12
    01CC8 5D02      SUBI	R16,0xD2
    01CC9 4F1F      SBCI	R17,0xFF
    01CCA 940E 02EF CALL	ff.c:mem_cpy
(2543) 					fp->fs->wflag = 0;
    01CCC 2422      CLR	R2
    01CCD 8DEB      LDD	R30,Y+27
    01CCE 8DFC      LDD	R31,Y+28
    01CCF 93AF      PUSH	R26
    01CD0 93BF      PUSH	R27
    01CD1 81A0      LD	R26,Z
    01CD2 81B1      LDD	R27,Z+1
    01CD3 01FD      MOVW	R30,R26
    01CD4 91BF      POP	R27
    01CD5 91AF      POP	R26
    01CD6 8224      STD	Z+4,R2
(2544) 				}
(2545) #else
(2546) 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
(2547) 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
(2548) 					fp->flag &= ~FA__DIRTY;
(2549) 				}
(2550) #endif
(2551) 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    01CD7 E000      LDI	R16,0
    01CD8 E012      LDI	R17,2
    01CD9 0195      MOVW	R18,R10
    01CDA 940E 40AD CALL	empy16s
    01CDC 0168      MOVW	R12,R16
(2552) 				continue;
    01CDD C099      RJMP	0x1D77
(2553) 			}
(2554) #if _FS_TINY
(2555) 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
    01CDE 8DEB      LDD	R30,Y+27
    01CDF 8DFC      LDD	R31,Y+28
    01CE0 8422      LDD	R2,Z+10
    01CE1 8433      LDD	R3,Z+11
    01CE2 8444      LDD	R4,Z+12
    01CE3 8455      LDD	R5,Z+13
    01CE4 8066      LDD	R6,Z+6
    01CE5 8077      LDD	R7,Z+7
    01CE6 8480      LDD	R8,Z+8
    01CE7 8491      LDD	R9,Z+9
    01CE8 1462      CP	R6,R2
    01CE9 0473      CPC	R7,R3
    01CEA 0484      CPC	R8,R4
    01CEB 0495      CPC	R9,R5
    01CEC F128      BCS	0x1D12
(2556) 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    01CED E040      LDI	R20,0
    01CEE E050      LDI	R21,0
    01CEF E060      LDI	R22,0
    01CF0 E070      LDI	R23,0
    01CF1 8368      ST	Y,R22
    01CF2 8379      STD	Y+1,R23
    01CF3 019A      MOVW	R18,R20
    01CF4 8100      LD	R16,Z
    01CF5 8111      LDD	R17,Z+1
    01CF6 940E 0348 CALL	ff.c:move_window
    01CF8 2EA0      MOV	R10,R16
    01CF9 2300      TST	R16
    01CFA F051      BEQ	0x1D05
    01CFB 8D8B      LDD	R24,Y+27
    01CFC 8D9C      LDD	R25,Y+28
    01CFD 9604      ADIW	R24,4
    01CFE 015C      MOVW	R10,R24
    01CFF 01FC      MOVW	R30,R24
    01D00 8180      LD	R24,Z
    01D01 6880      ORI	R24,0x80
    01D02 8380      ST	Z,R24
    01D03 E001      LDI	R16,1
    01D04 C0BE      RJMP	0x1DC3
(2557) 				fp->fs->winsect = sect;
    01D05 802D      LDD	R2,Y+5
    01D06 803E      LDD	R3,Y+6
    01D07 804F      LDD	R4,Y+7
    01D08 8458      LDD	R5,Y+8
    01D09 8DEB      LDD	R30,Y+27
    01D0A 8DFC      LDD	R31,Y+28
    01D0B 81A0      LD	R26,Z
    01D0C 81B1      LDD	R27,Z+1
    01D0D 969A      ADIW	R26,0x2A
    01D0E 922D      ST	X+,R2
    01D0F 923D      ST	X+,R3
    01D10 924D      ST	X+,R4
    01D11 925C      ST	X,R5
(2558) 			}
(2559) #else
(2560) 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
(2561) 				if (fp->fptr < fp->fsize &&
(2562) 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
(2563) 						ABORT(fp->fs, FR_DISK_ERR);
(2564) 			}
(2565) #endif
(2566) 			fp->dsect = sect;
    01D12 802D      LDD	R2,Y+5
    01D13 803E      LDD	R3,Y+6
    01D14 804F      LDD	R4,Y+7
    01D15 8458      LDD	R5,Y+8
    01D16 8DEB      LDD	R30,Y+27
    01D17 8DFC      LDD	R31,Y+28
    01D18 8A26      STD	Z+22,R2
    01D19 8A37      STD	Z+23,R3
    01D1A 8E40      STD	Z+24,R4
    01D1B 8E51      STD	Z+25,R5
(2567) 		}
(2568) 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    01D1C EF4F      LDI	R20,0xFF
    01D1D E051      LDI	R21,1
    01D1E E060      LDI	R22,0
    01D1F E070      LDI	R23,0
    01D20 8DEB      LDD	R30,Y+27
    01D21 8DFC      LDD	R31,Y+28
    01D22 8026      LDD	R2,Z+6
    01D23 8037      LDD	R3,Z+7
    01D24 8440      LDD	R4,Z+8
    01D25 8451      LDD	R5,Z+9
    01D26 2224      AND	R2,R20
    01D27 2235      AND	R3,R21
    01D28 2246      AND	R4,R22
    01D29 2257      AND	R5,R23
    01D2A E040      LDI	R20,0
    01D2B E052      LDI	R21,2
    01D2C E060      LDI	R22,0
    01D2D E070      LDI	R23,0
    01D2E 1942      SUB	R20,R2
    01D2F 0953      SBC	R21,R3
    01D30 0964      SBC	R22,R4
    01D31 0975      SBC	R23,R5
    01D32 016A      MOVW	R12,R20
(2569) 		if (wcnt > btw) wcnt = btw;
    01D33 8C0F      LDD	R0,Y+31
    01D34 A018      LDD	R1,Y+32
    01D35 1604      CP	R0,R20
    01D36 0615      CPC	R1,R21
    01D37 F408      BCC	0x1D39
    01D38 0160      MOVW	R12,R0
(2570) #if _FS_TINY
(2571) 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
    01D39 8DEB      LDD	R30,Y+27
    01D3A 8DFC      LDD	R31,Y+28
    01D3B 8826      LDD	R2,Z+22
    01D3C 8837      LDD	R3,Z+23
    01D3D 8C40      LDD	R4,Z+24
    01D3E 8C51      LDD	R5,Z+25
    01D3F 8248      ST	Y,R4
    01D40 8259      STD	Y+1,R5
    01D41 0191      MOVW	R18,R2
    01D42 8100      LD	R16,Z
    01D43 8111      LDD	R17,Z+1
    01D44 940E 0348 CALL	ff.c:move_window
    01D46 2EA0      MOV	R10,R16
    01D47 2300      TST	R16
    01D48 F051      BEQ	0x1D53
(2572) 			ABORT(fp->fs, FR_DISK_ERR);
    01D49 8D8B      LDD	R24,Y+27
    01D4A 8D9C      LDD	R25,Y+28
    01D4B 9604      ADIW	R24,4
    01D4C 015C      MOVW	R10,R24
    01D4D 01FC      MOVW	R30,R24
    01D4E 8180      LD	R24,Z
    01D4F 6880      ORI	R24,0x80
    01D50 8380      ST	Z,R24
    01D51 E001      LDI	R16,1
    01D52 C070      RJMP	0x1DC3
(2573) 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    01D53 82D9      STD	Y+1,R13
    01D54 82C8      ST	Y,R12
    01D55 0197      MOVW	R18,R14
    01D56 EF4F      LDI	R20,0xFF
    01D57 E051      LDI	R21,1
    01D58 E060      LDI	R22,0
    01D59 E070      LDI	R23,0
    01D5A 8DEB      LDD	R30,Y+27
    01D5B 8DFC      LDD	R31,Y+28
    01D5C 8026      LDD	R2,Z+6
    01D5D 8037      LDD	R3,Z+7
    01D5E 8440      LDD	R4,Z+8
    01D5F 8451      LDD	R5,Z+9
    01D60 2224      AND	R2,R20
    01D61 2235      AND	R3,R21
    01D62 2246      AND	R4,R22
    01D63 2257      AND	R5,R23
    01D64 0181      MOVW	R16,R2
    01D65 8180      LD	R24,Z
    01D66 8191      LDD	R25,Z+1
    01D67 968E      ADIW	R24,0x2E
    01D68 0F08      ADD	R16,R24
    01D69 1F19      ADC	R17,R25
    01D6A 940E 02EF CALL	ff.c:mem_cpy
(2574) 		fp->fs->wflag = 1;
    01D6C E081      LDI	R24,1
    01D6D 8DEB      LDD	R30,Y+27
    01D6E 8DFC      LDD	R31,Y+28
    01D6F 93AF      PUSH	R26
    01D70 93BF      PUSH	R27
    01D71 81A0      LD	R26,Z
    01D72 81B1      LDD	R27,Z+1
    01D73 01FD      MOVW	R30,R26
    01D74 91BF      POP	R27
    01D75 91AF      POP	R26
    01D76 8384      STD	Z+4,R24
    01D77 0CEC      ADD	R14,R12
    01D78 1CFD      ADC	R15,R13
    01D79 8D8B      LDD	R24,Y+27
    01D7A 8D9C      LDD	R25,Y+28
    01D7B 9606      ADIW	R24,6
    01D7C 015C      MOVW	R10,R24
    01D7D 0116      MOVW	R2,R12
    01D7E 2444      CLR	R4
    01D7F 2455      CLR	R5
    01D80 01FC      MOVW	R30,R24
    01D81 8060      LD	R6,Z
    01D82 8071      LDD	R7,Z+1
    01D83 8082      LDD	R8,Z+2
    01D84 8093      LDD	R9,Z+3
    01D85 0C62      ADD	R6,R2
    01D86 1C73      ADC	R7,R3
    01D87 1C84      ADC	R8,R4
    01D88 1C95      ADC	R9,R5
    01D89 8260      ST	Z,R6
    01D8A 8271      STD	Z+1,R7
    01D8B 8282      STD	Z+2,R8
    01D8C 8293      STD	Z+3,R9
    01D8D A1E9      LDD	R30,Y+33
    01D8E A1FA      LDD	R31,Y+34
    01D8F 8020      LD	R2,Z
    01D90 8031      LDD	R3,Z+1
    01D91 0C2C      ADD	R2,R12
    01D92 1C3D      ADC	R3,R13
    01D93 8231      STD	Z+1,R3
    01D94 8220      ST	Z,R2
    01D95 8C0F      LDD	R0,Y+31
    01D96 A018      LDD	R1,Y+32
    01D97 180C      SUB	R0,R12
    01D98 081D      SBC	R1,R13
    01D99 A218      STD	Y+32,R1
    01D9A 8E0F      STD	Y+31,R0
    01D9B 8C0F      LDD	R0,Y+31
    01D9C A018      LDD	R1,Y+32
    01D9D 2000      TST	R0
    01D9E F009      BEQ	0x1DA0
    01D9F CD5B      RJMP	0x1AFB
    01DA0 2011      TST	R1
    01DA1 F009      BEQ	0x1DA3
    01DA2 CD58      RJMP	0x1AFB
(2575) #else
(2576) 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
(2577) 		fp->flag |= FA__DIRTY;
(2578) #endif
(2579) 	}
(2580) 
(2581) 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    01DA3 8DEB      LDD	R30,Y+27
    01DA4 8DFC      LDD	R31,Y+28
    01DA5 8422      LDD	R2,Z+10
    01DA6 8433      LDD	R3,Z+11
    01DA7 8444      LDD	R4,Z+12
    01DA8 8455      LDD	R5,Z+13
    01DA9 8066      LDD	R6,Z+6
    01DAA 8077      LDD	R7,Z+7
    01DAB 8480      LDD	R8,Z+8
    01DAC 8491      LDD	R9,Z+9
    01DAD 1426      CP	R2,R6
    01DAE 0437      CPC	R3,R7
    01DAF 0448      CPC	R4,R8
    01DB0 0459      CPC	R5,R9
    01DB1 F440      BCC	0x1DBA
    01DB2 8026      LDD	R2,Z+6
    01DB3 8037      LDD	R3,Z+7
    01DB4 8440      LDD	R4,Z+8
    01DB5 8451      LDD	R5,Z+9
    01DB6 8622      STD	Z+10,R2
    01DB7 8633      STD	Z+11,R3
    01DB8 8644      STD	Z+12,R4
    01DB9 8655      STD	Z+13,R5
(2582) 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    01DBA 8D8B      LDD	R24,Y+27
    01DBB 8D9C      LDD	R25,Y+28
    01DBC 9604      ADIW	R24,4
    01DBD 015C      MOVW	R10,R24
    01DBE 01FC      MOVW	R30,R24
    01DBF 8180      LD	R24,Z
    01DC0 6280      ORI	R24,0x20
    01DC1 8380      ST	Z,R24
(2583) 
(2584) 	LEAVE_FF(fp->fs, FR_OK);
    01DC2 2700      CLR	R16
    01DC3 9661      ADIW	R28,0x11
    01DC4 940E 4106 CALL	pop_xgsetF0FC
    01DC6 9624      ADIW	R28,4
    01DC7 9508      RET
_f_sync:
  tim                  --> Y,+2
  dir                  --> R22
  res                  --> R10
  fp                   --> R20
    01DC8 940E 414C CALL	push_xgsetF03C
    01DCA 01A8      MOVW	R20,R16
    01DCB 9726      SBIW	R28,6
(2585) }
(2586) 
(2587) 
(2588) 
(2589) 
(2590) /*-----------------------------------------------------------------------*/
(2591) /* Synchronize the File Object                                           */
(2592) /*-----------------------------------------------------------------------*/
(2593) 
(2594) FRESULT f_sync (
(2595) 	FIL *fp		/* Pointer to the file object */
(2596) )
(2597) {
(2598) 	FRESULT res;
(2599) 	DWORD tim;
(2600) 	BYTE *dir;
(2601) 
(2602) 
(2603) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01DCC 01FA      MOVW	R30,R20
    01DCD 8122      LDD	R18,Z+2
    01DCE 8133      LDD	R19,Z+3
    01DCF 8100      LD	R16,Z
    01DD0 8111      LDD	R17,Z+1
    01DD1 D88E      RCALL	ff.c:validate
    01DD2 2EA0      MOV	R10,R16
(2604) 	if (res == FR_OK) {
    01DD3 2300      TST	R16
    01DD4 F009      BEQ	0x1DD6
    01DD5 C09F      RJMP	0x1E75
(2605) 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    01DD6 01FA      MOVW	R30,R20
    01DD7 8024      LDD	R2,Z+4
    01DD8 FE25      SBRS	R2,5
    01DD9 C09B      RJMP	0x1E75
(2606) #if !_FS_TINY	/* Write-back dirty buffer */
(2607) 			if (fp->flag & FA__DIRTY) {
(2608) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2609) 					LEAVE_FF(fp->fs, FR_DISK_ERR);
(2610) 				fp->flag &= ~FA__DIRTY;
(2611) 			}
(2612) #endif
(2613) 			/* Update the directory entry */
(2614) 			res = move_window(fp->fs, fp->dir_sect);
    01DDA 8C22      LDD	R2,Z+26
    01DDB 8C33      LDD	R3,Z+27
    01DDC 8C44      LDD	R4,Z+28
    01DDD 8C55      LDD	R5,Z+29
    01DDE 8248      ST	Y,R4
    01DDF 8259      STD	Y+1,R5
    01DE0 0191      MOVW	R18,R2
    01DE1 8100      LD	R16,Z
    01DE2 8111      LDD	R17,Z+1
    01DE3 940E 0348 CALL	ff.c:move_window
    01DE5 2EA0      MOV	R10,R16
(2615) 			if (res == FR_OK) {
    01DE6 2300      TST	R16
    01DE7 F009      BEQ	0x1DE9
    01DE8 C08C      RJMP	0x1E75
(2616) 				dir = fp->dir_ptr;
    01DE9 01FA      MOVW	R30,R20
    01DEA 8D66      LDD	R22,Z+30
    01DEB 8D77      LDD	R23,Z+31
(2617) 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    01DEC 01CB      MOVW	R24,R22
    01DED 960B      ADIW	R24,0xB
    01DEE 01FC      MOVW	R30,R24
    01DEF 8180      LD	R24,Z
    01DF0 6280      ORI	R24,0x20
    01DF1 8380      ST	Z,R24
(2618) 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    01DF2 01FA      MOVW	R30,R20
    01DF3 8422      LDD	R2,Z+10
    01DF4 8433      LDD	R3,Z+11
    01DF5 8444      LDD	R4,Z+12
    01DF6 8455      LDD	R5,Z+13
    01DF7 01FB      MOVW	R30,R22
    01DF8 8E24      STD	Z+28,R2
    01DF9 01FA      MOVW	R30,R20
    01DFA 8422      LDD	R2,Z+10
    01DFB 8433      LDD	R3,Z+11
    01DFC 2C23      MOV	R2,R3
    01DFD 2433      CLR	R3
    01DFE 01FB      MOVW	R30,R22
    01DFF 8E25      STD	Z+29,R2
    01E00 01FA      MOVW	R30,R20
    01E01 8422      LDD	R2,Z+10
    01E02 8433      LDD	R3,Z+11
    01E03 8444      LDD	R4,Z+12
    01E04 8455      LDD	R5,Z+13
    01E05 0112      MOVW	R2,R4
    01E06 2444      CLR	R4
    01E07 2455      CLR	R5
    01E08 01FB      MOVW	R30,R22
    01E09 8E26      STD	Z+30,R2
    01E0A E188      LDI	R24,0x18
    01E0B E090      LDI	R25,0
    01E0C 01FA      MOVW	R30,R20
    01E0D 8502      LDD	R16,Z+10
    01E0E 8513      LDD	R17,Z+11
    01E0F 8524      LDD	R18,Z+12
    01E10 8535      LDD	R19,Z+13
    01E11 938A      ST	-Y,R24
    01E12 940E 41AC CALL	lsr32
    01E14 01FB      MOVW	R30,R22
    01E15 8F07      STD	Z+31,R16
(2619) 				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    01E16 01FA      MOVW	R30,R20
    01E17 8426      LDD	R2,Z+14
    01E18 8437      LDD	R3,Z+15
    01E19 8840      LDD	R4,Z+16
    01E1A 8851      LDD	R5,Z+17
    01E1B 01FB      MOVW	R30,R22
    01E1C 8E22      STD	Z+26,R2
    01E1D 01FA      MOVW	R30,R20
    01E1E 8426      LDD	R2,Z+14
    01E1F 8437      LDD	R3,Z+15
    01E20 2C23      MOV	R2,R3
    01E21 2433      CLR	R3
    01E22 01FB      MOVW	R30,R22
    01E23 8E23      STD	Z+27,R2
    01E24 01FA      MOVW	R30,R20
    01E25 8426      LDD	R2,Z+14
    01E26 8437      LDD	R3,Z+15
    01E27 8840      LDD	R4,Z+16
    01E28 8851      LDD	R5,Z+17
    01E29 0112      MOVW	R2,R4
    01E2A 2444      CLR	R4
    01E2B 2455      CLR	R5
    01E2C 01FB      MOVW	R30,R22
    01E2D 8A24      STD	Z+20,R2
    01E2E 01FA      MOVW	R30,R20
    01E2F 8426      LDD	R2,Z+14
    01E30 8437      LDD	R3,Z+15
    01E31 8840      LDD	R4,Z+16
    01E32 8851      LDD	R5,Z+17
    01E33 0112      MOVW	R2,R4
    01E34 2C23      MOV	R2,R3
    01E35 2433      CLR	R3
    01E36 01FB      MOVW	R30,R22
    01E37 8A25      STD	Z+21,R2
(2620) 				tim = get_fattime();						/* Update updated time */
    01E38 940E 02EA CALL	_get_fattime
    01E3A 830A      STD	Y+2,R16
    01E3B 831B      STD	Y+3,R17
    01E3C 832C      STD	Y+4,R18
    01E3D 833D      STD	Y+5,R19
(2621) 				ST_DWORD(dir+DIR_WrtTime, tim);
    01E3E 802A      LDD	R2,Y+2
    01E3F 803B      LDD	R3,Y+3
    01E40 804C      LDD	R4,Y+4
    01E41 805D      LDD	R5,Y+5
    01E42 01FB      MOVW	R30,R22
    01E43 8A26      STD	Z+22,R2
    01E44 2C23      MOV	R2,R3
    01E45 2433      CLR	R3
    01E46 9677      ADIW	R30,0x17
    01E47 8220      ST	Z,R2
    01E48 802A      LDD	R2,Y+2
    01E49 803B      LDD	R3,Y+3
    01E4A 804C      LDD	R4,Y+4
    01E4B 805D      LDD	R5,Y+5
    01E4C 0112      MOVW	R2,R4
    01E4D 2444      CLR	R4
    01E4E 2455      CLR	R5
    01E4F 01FB      MOVW	R30,R22
    01E50 9678      ADIW	R30,0x18
    01E51 8220      ST	Z,R2
    01E52 E188      LDI	R24,0x18
    01E53 E090      LDI	R25,0
    01E54 810A      LDD	R16,Y+2
    01E55 811B      LDD	R17,Y+3
    01E56 812C      LDD	R18,Y+4
    01E57 813D      LDD	R19,Y+5
    01E58 938A      ST	-Y,R24
    01E59 940E 41AC CALL	lsr32
    01E5B 01FB      MOVW	R30,R22
    01E5C 8F01      STD	Z+25,R16
(2622) 				fp->flag &= ~FA__WRITTEN;
    01E5D 01BA      MOVW	R22,R20
    01E5E 5F6C      SUBI	R22,0xFC
    01E5F 4F7F      SBCI	R23,0xFF
    01E60 01FB      MOVW	R30,R22
    01E61 8180      LD	R24,Z
    01E62 7D8F      ANDI	R24,0xDF
    01E63 8380      ST	Z,R24
(2623) 				fp->fs->wflag = 1;
    01E64 E081      LDI	R24,1
    01E65 01FA      MOVW	R30,R20
    01E66 93AF      PUSH	R26
    01E67 93BF      PUSH	R27
    01E68 81A0      LD	R26,Z
    01E69 81B1      LDD	R27,Z+1
    01E6A 01FD      MOVW	R30,R26
    01E6B 91BF      POP	R27
    01E6C 91AF      POP	R26
    01E6D 8384      STD	Z+4,R24
(2624) 				res = sync(fp->fs);
    01E6E 01FA      MOVW	R30,R20
    01E6F 8100      LD	R16,Z
    01E70 8111      LDD	R17,Z+1
    01E71 940E 03EA CALL	ff.c:sync
    01E73 2EC0      MOV	R12,R16
    01E74 2CAC      MOV	R10,R12
(2625) 			}
(2626) 		}
(2627) 	}
(2628) 
(2629) 	LEAVE_FF(fp->fs, res);
    01E75 2D0A      MOV	R16,R10
    01E76 9626      ADIW	R28,6
    01E77 940C 4155 JMP	pop_xgsetF03C
_f_close:
  res                  --> R10
  fp                   --> R12
    01E79 940E 4117 CALL	push_xgset003C
    01E7B 0168      MOVW	R12,R16
(2630) }
(2631) 
(2632) #endif /* !_FS_READONLY */
(2633) 
(2634) 
(2635) 
(2636) 
(2637) /*-----------------------------------------------------------------------*/
(2638) /* Close File                                                            */
(2639) /*-----------------------------------------------------------------------*/
(2640) 
(2641) FRESULT f_close (
(2642) 	FIL *fp		/* Pointer to the file object to be closed */
(2643) )
(2644) {
(2645) 	FRESULT res;
(2646) 
(2647) #if _FS_READONLY
(2648) 	FATFS *fs = fp->fs;
(2649) 	res = validate(fs, fp->id);
(2650) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
(2651) 	LEAVE_FF(fs, res);
(2652) 
(2653) #else
(2654) 	res = f_sync(fp);		/* Flush cached data */
    01E7C 0186      MOVW	R16,R12
    01E7D DF4A      RCALL	_f_sync
    01E7E 2EA0      MOV	R10,R16
(2655) #if _FS_SHARE
(2656) 	if (res == FR_OK) {		/* Decrement open counter */
(2657) #if _FS_REENTRANT
(2658) 		res = validate(fp->fs, fp->id);
(2659) 		if (res == FR_OK) {
(2660) 			res = dec_lock(fp->lockid);	
(2661) 			unlock_fs(fp->fs, FR_OK);
(2662) 		}
(2663) #else
(2664) 		res = dec_lock(fp->lockid);
(2665) #endif
(2666) 	}
(2667) #endif
(2668) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    01E7F 2300      TST	R16
    01E80 F429      BNE	0x1E86
    01E81 2422      CLR	R2
    01E82 2433      CLR	R3
    01E83 01F6      MOVW	R30,R12
    01E84 8231      STD	Z+1,R3
    01E85 8220      ST	Z,R2
(2669) 	return res;
    01E86 2D0A      MOV	R16,R10
    01E87 940C 40F1 JMP	pop_xgset003C
_f_lseek:
  ifptr                --> Y,+14
  nsect                --> Y,+10
  bcs                  --> Y,+6
  clst                 --> Y,+2
  dsc                  --> Y,+26
  tlen                 --> Y,+22
  tbl                  --> R14
  tcl                  --> Y,+18
  ulen                 --> Y,+14
  ncl                  --> Y,+10
  pcl                  --> Y,+6
  cl                   --> Y,+2
  res                  --> R10
  ofs                  --> Y,+42
  fp                   --> Y,+40
    01E89 940E 3FCC CALL	push_arg4
    01E8B 940E 4111 CALL	push_xgsetF0FC
    01E8D 976E      SBIW	R28,0x1E
(2670) #endif
(2671) }
(2672) 
(2673) 
(2674) 
(2675) 
(2676) /*-----------------------------------------------------------------------*/
(2677) /* Current Drive/Directory Handlings                                     */
(2678) /*-----------------------------------------------------------------------*/
(2679) 
(2680) #if _FS_RPATH >= 1
(2681) 
(2682) FRESULT f_chdrive (
(2683) 	BYTE drv		/* Drive number */
(2684) )
(2685) {
(2686) 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
(2687) 
(2688) 	CurrVol = drv;
(2689) 
(2690) 	return FR_OK;
(2691) }
(2692) 
(2693) 
(2694) 
(2695) FRESULT f_chdir (
(2696) 	const TCHAR *path	/* Pointer to the directory path */
(2697) )
(2698) {
(2699) 	FRESULT res;
(2700) 	DIR dj;
(2701) 	DEF_NAMEBUF;
(2702) 
(2703) 
(2704) 	res = chk_mounted(&path, &dj.fs, 0);
(2705) 	if (res == FR_OK) {
(2706) 		INIT_BUF(dj);
(2707) 		res = follow_path(&dj, path);		/* Follow the path */
(2708) 		FREE_BUF();
(2709) 		if (res == FR_OK) {					/* Follow completed */
(2710) 			if (!dj.dir) {
(2711) 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
(2712) 			} else {
(2713) 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
(2714) 					dj.fs->cdir = LD_CLUST(dj.dir);
(2715) 				else
(2716) 					res = FR_NO_PATH;		/* Reached but a file */
(2717) 			}
(2718) 		}
(2719) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
(2720) 	}
(2721) 
(2722) 	LEAVE_FF(dj.fs, res);
(2723) }
(2724) 
(2725) 
(2726) #if _FS_RPATH >= 2
(2727) FRESULT f_getcwd (
(2728) 	TCHAR *path,	/* Pointer to the directory path */
(2729) 	UINT sz_path	/* Size of path */
(2730) )
(2731) {
(2732) 	FRESULT res;
(2733) 	DIR dj;
(2734) 	UINT i, n;
(2735) 	DWORD ccl;
(2736) 	TCHAR *tp;
(2737) 	FILINFO fno;
(2738) 	DEF_NAMEBUF;
(2739) 
(2740) 
(2741) 	*path = 0;
(2742) 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
(2743) 	if (res == FR_OK) {
(2744) 		INIT_BUF(dj);
(2745) 		i = sz_path;		/* Bottom of buffer (dir stack base) */
(2746) 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
(2747) 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
(2748) 			res = dir_sdi(&dj, 1);			/* Get parent dir */
(2749) 			if (res != FR_OK) break;
(2750) 			res = dir_read(&dj);
(2751) 			if (res != FR_OK) break;
(2752) 			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
(2753) 			res = dir_sdi(&dj, 0);
(2754) 			if (res != FR_OK) break;
(2755) 			do {							/* Find the entry links to the child dir */
(2756) 				res = dir_read(&dj);
(2757) 				if (res != FR_OK) break;
(2758) 				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
(2759) 				res = dir_next(&dj, 0);	
(2760) 			} while (res == FR_OK);
(2761) 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
(2762) 			if (res != FR_OK) break;
(2763) #if _USE_LFN
(2764) 			fno.lfname = path;
(2765) 			fno.lfsize = i;
(2766) #endif
(2767) 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
(2768) 			tp = fno.fname;
(2769) 			if (_USE_LFN && *path) tp = path;
(2770) 			for (n = 0; tp[n]; n++) ;
(2771) 			if (i < n + 3) {
(2772) 				res = FR_NOT_ENOUGH_CORE; break;
(2773) 			}
(2774) 			while (n) path[--i] = tp[--n];
(2775) 			path[--i] = '/';
(2776) 		}
(2777) 		tp = path;
(2778) 		if (res == FR_OK) {
(2779) 			*tp++ = '0' + CurrVol;			/* Put drive number */
(2780) 			*tp++ = ':';
(2781) 			if (i == sz_path) {				/* Root-dir */
(2782) 				*tp++ = '/';
(2783) 			} else {						/* Sub-dir */
(2784) 				do		/* Add stacked path str */
(2785) 					*tp++ = path[i++];
(2786) 				while (i < sz_path);
(2787) 			}
(2788) 		}
(2789) 		*tp = 0;
(2790) 		FREE_BUF();
(2791) 	}
(2792) 
(2793) 	LEAVE_FF(dj.fs, res);
(2794) }
(2795) #endif /* _FS_RPATH >= 2 */
(2796) #endif /* _FS_RPATH >= 1 */
(2797) 
(2798) 
(2799) 
(2800) #if _FS_MINIMIZE <= 2
(2801) /*-----------------------------------------------------------------------*/
(2802) /* Seek File R/W Pointer                                                 */
(2803) /*-----------------------------------------------------------------------*/
(2804) 
(2805) FRESULT f_lseek (
(2806) 	FIL *fp,		/* Pointer to the file object */
(2807) 	DWORD ofs		/* File pointer from top of file */
(2808) )
(2809) {
(2810) 	FRESULT res;
(2811) 
(2812) 
(2813) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01E8E A5E8      LDD	R30,Y+40
    01E8F A5F9      LDD	R31,Y+41
    01E90 8122      LDD	R18,Z+2
    01E91 8133      LDD	R19,Z+3
    01E92 8100      LD	R16,Z
    01E93 8111      LDD	R17,Z+1
    01E94 940E 1660 CALL	ff.c:validate
    01E96 2EA0      MOV	R10,R16
(2814) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01E97 2300      TST	R16
    01E98 F009      BEQ	0x1E9A
    01E99 C4A7      RJMP	0x2341
(2815) 	if (fp->flag & FA__ERROR)			/* Check abort flag */
    01E9A A5E8      LDD	R30,Y+40
    01E9B A5F9      LDD	R31,Y+41
    01E9C 8024      LDD	R2,Z+4
    01E9D FE27      SBRS	R2,7
    01E9E C002      RJMP	0x1EA1
(2816) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01E9F E002      LDI	R16,2
    01EA0 C4A0      RJMP	0x2341
(2817) 
(2818) #if _USE_FASTSEEK
(2819) 	if (fp->cltbl) {	/* Fast seek */
    01EA1 A5E8      LDD	R30,Y+40
    01EA2 A5F9      LDD	R31,Y+41
    01EA3 96B0      ADIW	R30,0x20
    01EA4 8020      LD	R2,Z
    01EA5 8031      LDD	R3,Z+1
    01EA6 2022      TST	R2
    01EA7 F419      BNE	0x1EAB
    01EA8 2033      TST	R3
    01EA9 F409      BNE	0x1EAB
    01EAA C1E3      RJMP	0x208E
(2820) 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
(2821) 
(2822) 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
    01EAB EF4F      LDI	R20,0xFF
    01EAC EF5F      LDI	R21,0xFF
    01EAD EF6F      LDI	R22,0xFF
    01EAE EF7F      LDI	R23,0xFF
    01EAF A42A      LDD	R2,Y+42
    01EB0 A43B      LDD	R3,Y+43
    01EB1 A44C      LDD	R4,Y+44
    01EB2 A45D      LDD	R5,Y+45
    01EB3 1624      CP	R2,R20
    01EB4 0635      CPC	R3,R21
    01EB5 0646      CPC	R4,R22
    01EB6 0657      CPC	R5,R23
    01EB7 F009      BEQ	0x1EB9
    01EB8 C109      RJMP	0x1FC2
(2823) 			tbl = fp->cltbl;
    01EB9 A5E8      LDD	R30,Y+40
    01EBA A5F9      LDD	R31,Y+41
    01EBB A0E0      LDD	R14,Z+32
    01EBC A0F1      LDD	R15,Z+33
(2824) 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
    01EBD 01F7      MOVW	R30,R14
    01EBE 9021      LD	R2,Z+
    01EBF 9031      LD	R3,Z+
    01EC0 9041      LD	R4,Z+
    01EC1 9051      LD	R5,Z+
    01EC2 017F      MOVW	R14,R30
    01EC3 8A2E      STD	Y+22,R2
    01EC4 8A3F      STD	Y+23,R3
    01EC5 8E48      STD	Y+24,R4
    01EC6 8E59      STD	Y+25,R5
    01EC7 E082      LDI	R24,2
    01EC8 878E      STD	Y+14,R24
    01EC9 E080      LDI	R24,0
    01ECA 878F      STD	Y+15,R24
    01ECB 8B88      STD	Y+16,R24
    01ECC 8B89      STD	Y+17,R24
(2825) 			cl = fp->sclust;			/* Top of the chain */
    01ECD A5E8      LDD	R30,Y+40
    01ECE A5F9      LDD	R31,Y+41
    01ECF 963E      ADIW	R30,0xE
    01ED0 8020      LD	R2,Z
    01ED1 8031      LDD	R3,Z+1
    01ED2 8042      LDD	R4,Z+2
    01ED3 8053      LDD	R5,Z+3
    01ED4 822A      STD	Y+2,R2
    01ED5 823B      STD	Y+3,R3
    01ED6 824C      STD	Y+4,R4
    01ED7 825D      STD	Y+5,R5
(2826) 			if (cl) {
    01ED8 802A      LDD	R2,Y+2
    01ED9 803B      LDD	R3,Y+3
    01EDA 804C      LDD	R4,Y+4
    01EDB 805D      LDD	R5,Y+5
    01EDC 9488      BCLR	0
    01EDD 2022      TST	R2
    01EDE 0432      CPC	R3,R2
    01EDF 0442      CPC	R4,R2
    01EE0 0452      CPC	R5,R2
    01EE1 F409      BNE	0x1EE3
    01EE2 C0BB      RJMP	0x1F9E
(2827) 				do {
(2828) 					/* Get a fragment */
(2829) 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
    01EE3 802A      LDD	R2,Y+2
    01EE4 803B      LDD	R3,Y+3
    01EE5 804C      LDD	R4,Y+4
    01EE6 805D      LDD	R5,Y+5
    01EE7 8A2A      STD	Y+18,R2
    01EE8 8A3B      STD	Y+19,R3
    01EE9 8A4C      STD	Y+20,R4
    01EEA 8A5D      STD	Y+21,R5
    01EEB E080      LDI	R24,0
    01EEC 878A      STD	Y+10,R24
    01EED 878B      STD	Y+11,R24
    01EEE 878C      STD	Y+12,R24
    01EEF 878D      STD	Y+13,R24
    01EF0 E042      LDI	R20,2
    01EF1 E050      LDI	R21,0
    01EF2 E060      LDI	R22,0
    01EF3 E070      LDI	R23,0
    01EF4 842E      LDD	R2,Y+14
    01EF5 843F      LDD	R3,Y+15
    01EF6 8848      LDD	R4,Y+16
    01EF7 8859      LDD	R5,Y+17
    01EF8 0E24      ADD	R2,R20
    01EF9 1E35      ADC	R3,R21
    01EFA 1E46      ADC	R4,R22
    01EFB 1E57      ADC	R5,R23
    01EFC 862E      STD	Y+14,R2
    01EFD 863F      STD	Y+15,R3
    01EFE 8A48      STD	Y+16,R4
    01EFF 8A59      STD	Y+17,R5
(2830) 					do {
(2831) 						pcl = cl; ncl++;
    01F00 802A      LDD	R2,Y+2
    01F01 803B      LDD	R3,Y+3
    01F02 804C      LDD	R4,Y+4
    01F03 805D      LDD	R5,Y+5
    01F04 822E      STD	Y+6,R2
    01F05 823F      STD	Y+7,R3
    01F06 8648      STD	Y+8,R4
    01F07 8659      STD	Y+9,R5
    01F08 E041      LDI	R20,1
    01F09 E050      LDI	R21,0
    01F0A E060      LDI	R22,0
    01F0B E070      LDI	R23,0
    01F0C 842A      LDD	R2,Y+10
    01F0D 843B      LDD	R3,Y+11
    01F0E 844C      LDD	R4,Y+12
    01F0F 845D      LDD	R5,Y+13
    01F10 0E24      ADD	R2,R20
    01F11 1E35      ADC	R3,R21
    01F12 1E46      ADC	R4,R22
    01F13 1E57      ADC	R5,R23
    01F14 862A      STD	Y+10,R2
    01F15 863B      STD	Y+11,R3
    01F16 864C      STD	Y+12,R4
    01F17 865D      STD	Y+13,R5
(2832) 						cl = get_fat(fp->fs, cl);
    01F18 802A      LDD	R2,Y+2
    01F19 803B      LDD	R3,Y+3
    01F1A 804C      LDD	R4,Y+4
    01F1B 805D      LDD	R5,Y+5
    01F1C 8248      ST	Y,R4
    01F1D 8259      STD	Y+1,R5
    01F1E 0191      MOVW	R18,R2
    01F1F A5E8      LDD	R30,Y+40
    01F20 A5F9      LDD	R31,Y+41
    01F21 8100      LD	R16,Z
    01F22 8111      LDD	R17,Z+1
    01F23 940E 0511 CALL	_get_fat
    01F25 830A      STD	Y+2,R16
    01F26 831B      STD	Y+3,R17
    01F27 832C      STD	Y+4,R18
    01F28 833D      STD	Y+5,R19
(2833) 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
    01F29 E041      LDI	R20,1
    01F2A E050      LDI	R21,0
    01F2B E060      LDI	R22,0
    01F2C E070      LDI	R23,0
    01F2D 802A      LDD	R2,Y+2
    01F2E 803B      LDD	R3,Y+3
    01F2F 804C      LDD	R4,Y+4
    01F30 805D      LDD	R5,Y+5
    01F31 1542      CP	R20,R2
    01F32 0553      CPC	R21,R3
    01F33 0564      CPC	R22,R4
    01F34 0575      CPC	R23,R5
    01F35 F048      BCS	0x1F3F
    01F36 A588      LDD	R24,Y+40
    01F37 A599      LDD	R25,Y+41
    01F38 9604      ADIW	R24,4
    01F39 01FC      MOVW	R30,R24
    01F3A 8180      LD	R24,Z
    01F3B 6880      ORI	R24,0x80
    01F3C 8380      ST	Z,R24
    01F3D E002      LDI	R16,2
    01F3E C402      RJMP	0x2341
(2834) 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01F3F EF4F      LDI	R20,0xFF
    01F40 EF5F      LDI	R21,0xFF
    01F41 EF6F      LDI	R22,0xFF
    01F42 EF7F      LDI	R23,0xFF
    01F43 802A      LDD	R2,Y+2
    01F44 803B      LDD	R3,Y+3
    01F45 804C      LDD	R4,Y+4
    01F46 805D      LDD	R5,Y+5
    01F47 1624      CP	R2,R20
    01F48 0635      CPC	R3,R21
    01F49 0646      CPC	R4,R22
    01F4A 0657      CPC	R5,R23
    01F4B F451      BNE	0x1F56
    01F4C A588      LDD	R24,Y+40
    01F4D A599      LDD	R25,Y+41
    01F4E 9604      ADIW	R24,4
    01F4F 016C      MOVW	R12,R24
    01F50 01FC      MOVW	R30,R24
    01F51 8180      LD	R24,Z
    01F52 6880      ORI	R24,0x80
    01F53 8380      ST	Z,R24
    01F54 E001      LDI	R16,1
    01F55 C3EB      RJMP	0x2341
(2835) 					} while (cl == pcl + 1);
    01F56 E041      LDI	R20,1
    01F57 E050      LDI	R21,0
    01F58 E060      LDI	R22,0
    01F59 E070      LDI	R23,0
    01F5A 802E      LDD	R2,Y+6
    01F5B 803F      LDD	R3,Y+7
    01F5C 8448      LDD	R4,Y+8
    01F5D 8459      LDD	R5,Y+9
    01F5E 0E24      ADD	R2,R20
    01F5F 1E35      ADC	R3,R21
    01F60 1E46      ADC	R4,R22
    01F61 1E57      ADC	R5,R23
    01F62 806A      LDD	R6,Y+2
    01F63 807B      LDD	R7,Y+3
    01F64 808C      LDD	R8,Y+4
    01F65 809D      LDD	R9,Y+5
    01F66 1462      CP	R6,R2
    01F67 0473      CPC	R7,R3
    01F68 0484      CPC	R8,R4
    01F69 0495      CPC	R9,R5
    01F6A F409      BNE	0x1F6C
    01F6B CF94      RJMP	0x1F00
(2836) 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
    01F6C 882E      LDD	R2,Y+22
    01F6D 883F      LDD	R3,Y+23
    01F6E 8C48      LDD	R4,Y+24
    01F6F 8C59      LDD	R5,Y+25
    01F70 846E      LDD	R6,Y+14
    01F71 847F      LDD	R7,Y+15
    01F72 8888      LDD	R8,Y+16
    01F73 8899      LDD	R9,Y+17
    01F74 1426      CP	R2,R6
    01F75 0437      CPC	R3,R7
    01F76 0448      CPC	R4,R8
    01F77 0459      CPC	R5,R9
    01F78 F090      BCS	0x1F8B
(2837) 						*tbl++ = ncl; *tbl++ = tcl;
    01F79 842A      LDD	R2,Y+10
    01F7A 843B      LDD	R3,Y+11
    01F7B 844C      LDD	R4,Y+12
    01F7C 845D      LDD	R5,Y+13
    01F7D 01F7      MOVW	R30,R14
    01F7E 9221      ST	Z+,R2
    01F7F 9231      ST	Z+,R3
    01F80 9241      ST	Z+,R4
    01F81 9251      ST	Z+,R5
    01F82 882A      LDD	R2,Y+18
    01F83 883B      LDD	R3,Y+19
    01F84 884C      LDD	R4,Y+20
    01F85 885D      LDD	R5,Y+21
    01F86 9221      ST	Z+,R2
    01F87 9231      ST	Z+,R3
    01F88 9241      ST	Z+,R4
    01F89 9251      ST	Z+,R5
    01F8A 017F      MOVW	R14,R30
(2838) 					}
(2839) 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
    01F8B A5E8      LDD	R30,Y+40
    01F8C A5F9      LDD	R31,Y+41
    01F8D 81A0      LD	R26,Z
    01F8E 81B1      LDD	R27,Z+1
    01F8F 9656      ADIW	R26,0x16
    01F90 902D      LD	R2,X+
    01F91 903D      LD	R3,X+
    01F92 904D      LD	R4,X+
    01F93 905C      LD	R5,X
    01F94 806A      LDD	R6,Y+2
    01F95 807B      LDD	R7,Y+3
    01F96 808C      LDD	R8,Y+4
    01F97 809D      LDD	R9,Y+5
    01F98 1462      CP	R6,R2
    01F99 0473      CPC	R7,R3
    01F9A 0484      CPC	R8,R4
    01F9B 0495      CPC	R9,R5
    01F9C F408      BCC	0x1F9E
    01F9D CF45      RJMP	0x1EE3
(2840) 			}
(2841) 			*fp->cltbl = ulen;	/* Number of items used */
    01F9E 842E      LDD	R2,Y+14
    01F9F 843F      LDD	R3,Y+15
    01FA0 8848      LDD	R4,Y+16
    01FA1 8859      LDD	R5,Y+17
    01FA2 A5E8      LDD	R30,Y+40
    01FA3 A5F9      LDD	R31,Y+41
    01FA4 96B0      ADIW	R30,0x20
    01FA5 81A0      LD	R26,Z
    01FA6 81B1      LDD	R27,Z+1
    01FA7 922D      ST	X+,R2
    01FA8 923D      ST	X+,R3
    01FA9 924D      ST	X+,R4
    01FAA 925C      ST	X,R5
(2842) 			if (ulen <= tlen)
    01FAB 882E      LDD	R2,Y+22
    01FAC 883F      LDD	R3,Y+23
    01FAD 8C48      LDD	R4,Y+24
    01FAE 8C59      LDD	R5,Y+25
    01FAF 846E      LDD	R6,Y+14
    01FB0 847F      LDD	R7,Y+15
    01FB1 8888      LDD	R8,Y+16
    01FB2 8899      LDD	R9,Y+17
    01FB3 1426      CP	R2,R6
    01FB4 0437      CPC	R3,R7
    01FB5 0448      CPC	R4,R8
    01FB6 0459      CPC	R5,R9
    01FB7 F038      BCS	0x1FBF
(2843) 				*tbl = 0;		/* Terminate table */
    01FB8 01F7      MOVW	R30,R14
    01FB9 E080      LDI	R24,0
    01FBA 8380      ST	Z,R24
    01FBB 8381      STD	Z+1,R24
    01FBC 8382      STD	Z+2,R24
    01FBD 8383      STD	Z+3,R24
    01FBE C381      RJMP	0x2340
(2844) 			else
(2845) 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
    01FBF E181      LDI	R24,0x11
    01FC0 2EA8      MOV	R10,R24
(2846) 
(2847) 		} else {						/* Fast seek */
    01FC1 C37E      RJMP	0x2340
(2848) 			if (ofs > fp->fsize)		/* Clip offset at the file size */
    01FC2 A5E8      LDD	R30,Y+40
    01FC3 A5F9      LDD	R31,Y+41
    01FC4 963A      ADIW	R30,0xA
    01FC5 8020      LD	R2,Z
    01FC6 8031      LDD	R3,Z+1
    01FC7 8042      LDD	R4,Z+2
    01FC8 8053      LDD	R5,Z+3
    01FC9 A46A      LDD	R6,Y+42
    01FCA A47B      LDD	R7,Y+43
    01FCB A48C      LDD	R8,Y+44
    01FCC A49D      LDD	R9,Y+45
    01FCD 1426      CP	R2,R6
    01FCE 0437      CPC	R3,R7
    01FCF 0448      CPC	R4,R8
    01FD0 0459      CPC	R5,R9
    01FD1 F458      BCC	0x1FDD
(2849) 				ofs = fp->fsize;
    01FD2 A5E8      LDD	R30,Y+40
    01FD3 A5F9      LDD	R31,Y+41
    01FD4 963A      ADIW	R30,0xA
    01FD5 8020      LD	R2,Z
    01FD6 8031      LDD	R3,Z+1
    01FD7 8042      LDD	R4,Z+2
    01FD8 8053      LDD	R5,Z+3
    01FD9 A62A      STD	Y+42,R2
    01FDA A63B      STD	Y+43,R3
    01FDB A64C      STD	Y+44,R4
    01FDC A65D      STD	Y+45,R5
(2850) 			fp->fptr = ofs;				/* Set file pointer */
    01FDD A42A      LDD	R2,Y+42
    01FDE A43B      LDD	R3,Y+43
    01FDF A44C      LDD	R4,Y+44
    01FE0 A45D      LDD	R5,Y+45
    01FE1 A5E8      LDD	R30,Y+40
    01FE2 A5F9      LDD	R31,Y+41
    01FE3 9636      ADIW	R30,6
    01FE4 8220      ST	Z,R2
    01FE5 8231      STD	Z+1,R3
    01FE6 8242      STD	Z+2,R4
    01FE7 8253      STD	Z+3,R5
(2851) 			if (ofs) {
    01FE8 9488      BCLR	0
    01FE9 2022      TST	R2
    01FEA 0432      CPC	R3,R2
    01FEB 0442      CPC	R4,R2
    01FEC 0452      CPC	R5,R2
    01FED F409      BNE	0x1FEF
    01FEE C351      RJMP	0x2340
(2852) 				fp->clust = clmt_clust(fp, ofs - 1);
    01FEF E041      LDI	R20,1
    01FF0 E050      LDI	R21,0
    01FF1 E060      LDI	R22,0
    01FF2 E070      LDI	R23,0
    01FF3 1A24      SUB	R2,R20
    01FF4 0A35      SBC	R3,R21
    01FF5 0A46      SBC	R4,R22
    01FF6 0A57      SBC	R5,R23
    01FF7 8248      ST	Y,R4
    01FF8 8259      STD	Y+1,R5
    01FF9 0191      MOVW	R18,R2
    01FFA A508      LDD	R16,Y+40
    01FFB A519      LDD	R17,Y+41
    01FFC 940E 0A4B CALL	ff.c:clmt_clust
    01FFE A5E8      LDD	R30,Y+40
    01FFF A5F9      LDD	R31,Y+41
    02000 8B02      STD	Z+18,R16
    02001 8B13      STD	Z+19,R17
    02002 8B24      STD	Z+20,R18
    02003 8B35      STD	Z+21,R19
(2853) 				dsc = clust2sect(fp->fs, fp->clust);
    02004 8822      LDD	R2,Z+18
    02005 8833      LDD	R3,Z+19
    02006 8844      LDD	R4,Z+20
    02007 8855      LDD	R5,Z+21
    02008 8248      ST	Y,R4
    02009 8259      STD	Y+1,R5
    0200A 0191      MOVW	R18,R2
    0200B 8100      LD	R16,Z
    0200C 8111      LDD	R17,Z+1
    0200D 940E 04BF CALL	_clust2sect
    0200F 8F0A      STD	Y+26,R16
    02010 8F1B      STD	Y+27,R17
    02011 8F2C      STD	Y+28,R18
    02012 8F3D      STD	Y+29,R19
(2854) 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
    02013 8C2A      LDD	R2,Y+26
    02014 8C3B      LDD	R3,Y+27
    02015 8C4C      LDD	R4,Y+28
    02016 8C5D      LDD	R5,Y+29
    02017 9488      BCLR	0
    02018 2022      TST	R2
    02019 0432      CPC	R3,R2
    0201A 0442      CPC	R4,R2
    0201B 0452      CPC	R5,R2
    0201C F451      BNE	0x2027
    0201D A588      LDD	R24,Y+40
    0201E A599      LDD	R25,Y+41
    0201F 9604      ADIW	R24,4
    02020 017C      MOVW	R14,R24
    02021 01FC      MOVW	R30,R24
    02022 8180      LD	R24,Z
    02023 6880      ORI	R24,0x80
    02024 8380      ST	Z,R24
    02025 E002      LDI	R16,2
    02026 C31A      RJMP	0x2341
(2855) 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
    02027 E041      LDI	R20,1
    02028 E050      LDI	R21,0
    02029 E060      LDI	R22,0
    0202A E070      LDI	R23,0
    0202B A50A      LDD	R16,Y+42
    0202C A51B      LDD	R17,Y+43
    0202D A52C      LDD	R18,Y+44
    0202E A53D      LDD	R19,Y+45
    0202F 1B04      SUB	R16,R20
    02030 0B15      SBC	R17,R21
    02031 0B26      SBC	R18,R22
    02032 0B37      SBC	R19,R23
    02033 E089      LDI	R24,0x9
    02034 E090      LDI	R25,0
    02035 938A      ST	-Y,R24
    02036 940E 41AC CALL	lsr32
    02038 0118      MOVW	R2,R16
    02039 0129      MOVW	R4,R18
    0203A A5E8      LDD	R30,Y+40
    0203B A5F9      LDD	R31,Y+41
    0203C 93AF      PUSH	R26
    0203D 93BF      PUSH	R27
    0203E 81A0      LD	R26,Z
    0203F 81B1      LDD	R27,Z+1
    02040 01FD      MOVW	R30,R26
    02041 91BF      POP	R27
    02042 91AF      POP	R26
    02043 9632      ADIW	R30,2
    02044 8180      LD	R24,Z
    02045 2799      CLR	R25
    02046 9701      SBIW	R24,1
    02047 013C      MOVW	R6,R24
    02048 2488      CLR	R8
    02049 FC77      SBRC	R7,7
    0204A 9480      COM	R8
    0204B 2499      CLR	R9
    0204C FC87      SBRC	R8,7
    0204D 9490      COM	R9
    0204E 2026      AND	R2,R6
    0204F 2037      AND	R3,R7
    02050 2048      AND	R4,R8
    02051 2059      AND	R5,R9
    02052 8C6A      LDD	R6,Y+26
    02053 8C7B      LDD	R7,Y+27
    02054 8C8C      LDD	R8,Y+28
    02055 8C9D      LDD	R9,Y+29
    02056 0C62      ADD	R6,R2
    02057 1C73      ADC	R7,R3
    02058 1C84      ADC	R8,R4
    02059 1C95      ADC	R9,R5
    0205A 8E6A      STD	Y+26,R6
    0205B 8E7B      STD	Y+27,R7
    0205C 8E8C      STD	Y+28,R8
    0205D 8E9D      STD	Y+29,R9
(2856) 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
    0205E EF4F      LDI	R20,0xFF
    0205F E051      LDI	R21,1
    02060 E060      LDI	R22,0
    02061 E070      LDI	R23,0
    02062 A5E8      LDD	R30,Y+40
    02063 A5F9      LDD	R31,Y+41
    02064 9636      ADIW	R30,6
    02065 8020      LD	R2,Z
    02066 8031      LDD	R3,Z+1
    02067 8042      LDD	R4,Z+2
    02068 8053      LDD	R5,Z+3
    02069 2224      AND	R2,R20
    0206A 2235      AND	R3,R21
    0206B 2246      AND	R4,R22
    0206C 2257      AND	R5,R23
    0206D 9488      BCLR	0
    0206E 2022      TST	R2
    0206F 0432      CPC	R3,R2
    02070 0442      CPC	R4,R2
    02071 0452      CPC	R5,R2
    02072 F409      BNE	0x2074
    02073 C2CC      RJMP	0x2340
    02074 A5E8      LDD	R30,Y+40
    02075 A5F9      LDD	R31,Y+41
    02076 9676      ADIW	R30,0x16
    02077 8020      LD	R2,Z
    02078 8031      LDD	R3,Z+1
    02079 8042      LDD	R4,Z+2
    0207A 8053      LDD	R5,Z+3
    0207B 8C6A      LDD	R6,Y+26
    0207C 8C7B      LDD	R7,Y+27
    0207D 8C8C      LDD	R8,Y+28
    0207E 8C9D      LDD	R9,Y+29
    0207F 1462      CP	R6,R2
    02080 0473      CPC	R7,R3
    02081 0484      CPC	R8,R4
    02082 0495      CPC	R9,R5
    02083 F409      BNE	0x2085
    02084 C2BB      RJMP	0x2340
(2857) #if !_FS_TINY
(2858) #if !_FS_READONLY
(2859) 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2860) 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2861) 							ABORT(fp->fs, FR_DISK_ERR);
(2862) 						fp->flag &= ~FA__DIRTY;
(2863) 					}
(2864) #endif
(2865) 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
(2866) 						ABORT(fp->fs, FR_DISK_ERR);
(2867) #endif
(2868) 					fp->dsect = dsc;
    02085 0113      MOVW	R2,R6
    02086 0124      MOVW	R4,R8
    02087 A5E8      LDD	R30,Y+40
    02088 A5F9      LDD	R31,Y+41
    02089 8A26      STD	Z+22,R2
    0208A 8A37      STD	Z+23,R3
    0208B 8E40      STD	Z+24,R4
    0208C 8E51      STD	Z+25,R5
(2869) 				}
(2870) 			}
(2871) 		}
(2872) 	} else
    0208D C2B2      RJMP	0x2340
(2873) #endif
(2874) 
(2875) 	/* Normal Seek */
(2876) 	{
(2877) 		DWORD clst, bcs, nsect, ifptr;
(2878) 
(2879) 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    0208E A5E8      LDD	R30,Y+40
    0208F A5F9      LDD	R31,Y+41
    02090 963A      ADIW	R30,0xA
    02091 8020      LD	R2,Z
    02092 8031      LDD	R3,Z+1
    02093 8042      LDD	R4,Z+2
    02094 8053      LDD	R5,Z+3
    02095 A46A      LDD	R6,Y+42
    02096 A47B      LDD	R7,Y+43
    02097 A48C      LDD	R8,Y+44
    02098 A49D      LDD	R9,Y+45
    02099 1426      CP	R2,R6
    0209A 0437      CPC	R3,R7
    0209B 0448      CPC	R4,R8
    0209C 0459      CPC	R5,R9
    0209D F470      BCC	0x20AC
    0209E A5E8      LDD	R30,Y+40
    0209F A5F9      LDD	R31,Y+41
    020A0 8024      LDD	R2,Z+4
    020A1 FC21      SBRC	R2,1
    020A2 C009      RJMP	0x20AC
(2880) #if !_FS_READONLY
(2881) 			 && !(fp->flag & FA_WRITE)
(2882) #endif
(2883) 			) ofs = fp->fsize;
    020A3 963A      ADIW	R30,0xA
    020A4 8020      LD	R2,Z
    020A5 8031      LDD	R3,Z+1
    020A6 8042      LDD	R4,Z+2
    020A7 8053      LDD	R5,Z+3
    020A8 A62A      STD	Y+42,R2
    020A9 A63B      STD	Y+43,R3
    020AA A64C      STD	Y+44,R4
    020AB A65D      STD	Y+45,R5
(2884) 
(2885) 		ifptr = fp->fptr;
    020AC A5E8      LDD	R30,Y+40
    020AD A5F9      LDD	R31,Y+41
    020AE 9636      ADIW	R30,6
    020AF 8020      LD	R2,Z
    020B0 8031      LDD	R3,Z+1
    020B1 8042      LDD	R4,Z+2
    020B2 8053      LDD	R5,Z+3
    020B3 862E      STD	Y+14,R2
    020B4 863F      STD	Y+15,R3
    020B5 8A48      STD	Y+16,R4
    020B6 8A59      STD	Y+17,R5
(2886) 		fp->fptr = nsect = 0;
    020B7 E080      LDI	R24,0
    020B8 878A      STD	Y+10,R24
    020B9 878B      STD	Y+11,R24
    020BA 878C      STD	Y+12,R24
    020BB 878D      STD	Y+13,R24
    020BC A5E8      LDD	R30,Y+40
    020BD A5F9      LDD	R31,Y+41
    020BE 9636      ADIW	R30,6
    020BF E080      LDI	R24,0
    020C0 8380      ST	Z,R24
    020C1 8381      STD	Z+1,R24
    020C2 8382      STD	Z+2,R24
    020C3 8383      STD	Z+3,R24
(2887) 		if (ofs) {
    020C4 A42A      LDD	R2,Y+42
    020C5 A43B      LDD	R3,Y+43
    020C6 A44C      LDD	R4,Y+44
    020C7 A45D      LDD	R5,Y+45
    020C8 9488      BCLR	0
    020C9 2022      TST	R2
    020CA 0432      CPC	R3,R2
    020CB 0442      CPC	R4,R2
    020CC 0452      CPC	R5,R2
    020CD F409      BNE	0x20CF
    020CE C226      RJMP	0x22F5
(2888) 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    020CF A5E8      LDD	R30,Y+40
    020D0 A5F9      LDD	R31,Y+41
    020D1 93AF      PUSH	R26
    020D2 93BF      PUSH	R27
    020D3 81A0      LD	R26,Z
    020D4 81B1      LDD	R27,Z+1
    020D5 01FD      MOVW	R30,R26
    020D6 91BF      POP	R27
    020D7 91AF      POP	R26
    020D8 9632      ADIW	R30,2
    020D9 8020      LD	R2,Z
    020DA 2433      CLR	R3
    020DB 2444      CLR	R4
    020DC 2455      CLR	R5
    020DD E040      LDI	R20,0
    020DE E052      LDI	R21,2
    020DF E060      LDI	R22,0
    020E0 E070      LDI	R23,0
    020E1 925A      ST	-Y,R5
    020E2 924A      ST	-Y,R4
    020E3 923A      ST	-Y,R3
    020E4 922A      ST	-Y,R2
    020E5 018A      MOVW	R16,R20
    020E6 019B      MOVW	R18,R22
    020E7 940E 40BD CALL	empy32u|empy32s
    020E9 830E      STD	Y+6,R16
    020EA 831F      STD	Y+7,R17
    020EB 8728      STD	Y+8,R18
    020EC 8739      STD	Y+9,R19
(2889) 			if (ifptr > 0 &&
    020ED 842E      LDD	R2,Y+14
    020EE 843F      LDD	R3,Y+15
    020EF 8848      LDD	R4,Y+16
    020F0 8859      LDD	R5,Y+17
    020F1 9488      BCLR	0
    020F2 2022      TST	R2
    020F3 0432      CPC	R3,R2
    020F4 0442      CPC	R4,R2
    020F5 0452      CPC	R5,R2
    020F6 F409      BNE	0x20F8
    020F7 C075      RJMP	0x216D
    020F8 E041      LDI	R20,1
    020F9 E050      LDI	R21,0
    020FA E060      LDI	R22,0
    020FB E070      LDI	R23,0
    020FC 0181      MOVW	R16,R2
    020FD 0192      MOVW	R18,R4
    020FE 1B04      SUB	R16,R20
    020FF 0B15      SBC	R17,R21
    02100 0B26      SBC	R18,R22
    02101 0B37      SBC	R19,R23
    02102 802E      LDD	R2,Y+6
    02103 803F      LDD	R3,Y+7
    02104 8448      LDD	R4,Y+8
    02105 8459      LDD	R5,Y+9
    02106 925A      ST	-Y,R5
    02107 924A      ST	-Y,R4
    02108 923A      ST	-Y,R3
    02109 922A      ST	-Y,R2
    0210A 940E 4017 CALL	div32u
    0210C 0118      MOVW	R2,R16
    0210D 0129      MOVW	R4,R18
    0210E E041      LDI	R20,1
    0210F E050      LDI	R21,0
    02110 E060      LDI	R22,0
    02111 E070      LDI	R23,0
    02112 A50A      LDD	R16,Y+42
    02113 A51B      LDD	R17,Y+43
    02114 A52C      LDD	R18,Y+44
    02115 A53D      LDD	R19,Y+45
    02116 1B04      SUB	R16,R20
    02117 0B15      SBC	R17,R21
    02118 0B26      SBC	R18,R22
    02119 0B37      SBC	R19,R23
    0211A 806E      LDD	R6,Y+6
    0211B 807F      LDD	R7,Y+7
    0211C 8488      LDD	R8,Y+8
    0211D 8499      LDD	R9,Y+9
    0211E 929A      ST	-Y,R9
    0211F 928A      ST	-Y,R8
    02120 927A      ST	-Y,R7
    02121 926A      ST	-Y,R6
    02122 940E 4017 CALL	div32u
    02124 1502      CP	R16,R2
    02125 0513      CPC	R17,R3
    02126 0524      CPC	R18,R4
    02127 0535      CPC	R19,R5
    02128 F408      BCC	0x212A
    02129 C043      RJMP	0x216D
(2890) 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
(2891) 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    0212A E041      LDI	R20,1
    0212B E050      LDI	R21,0
    0212C E060      LDI	R22,0
    0212D E070      LDI	R23,0
    0212E 802E      LDD	R2,Y+6
    0212F 803F      LDD	R3,Y+7
    02130 8448      LDD	R4,Y+8
    02131 8459      LDD	R5,Y+9
    02132 1A24      SUB	R2,R20
    02133 0A35      SBC	R3,R21
    02134 0A46      SBC	R4,R22
    02135 0A57      SBC	R5,R23
    02136 9420      COM	R2
    02137 9430      COM	R3
    02138 9440      COM	R4
    02139 9450      COM	R5
    0213A E041      LDI	R20,1
    0213B E050      LDI	R21,0
    0213C E060      LDI	R22,0
    0213D E070      LDI	R23,0
    0213E 846E      LDD	R6,Y+14
    0213F 847F      LDD	R7,Y+15
    02140 8888      LDD	R8,Y+16
    02141 8899      LDD	R9,Y+17
    02142 1A64      SUB	R6,R20
    02143 0A75      SBC	R7,R21
    02144 0A86      SBC	R8,R22
    02145 0A97      SBC	R9,R23
    02146 2062      AND	R6,R2
    02147 2073      AND	R7,R3
    02148 2084      AND	R8,R4
    02149 2095      AND	R9,R5
    0214A A5E8      LDD	R30,Y+40
    0214B A5F9      LDD	R31,Y+41
    0214C 8266      STD	Z+6,R6
    0214D 8277      STD	Z+7,R7
    0214E 8680      STD	Z+8,R8
    0214F 8691      STD	Z+9,R9
(2892) 				ofs -= fp->fptr;
    02150 9636      ADIW	R30,6
    02151 8020      LD	R2,Z
    02152 8031      LDD	R3,Z+1
    02153 8042      LDD	R4,Z+2
    02154 8053      LDD	R5,Z+3
    02155 A46A      LDD	R6,Y+42
    02156 A47B      LDD	R7,Y+43
    02157 A48C      LDD	R8,Y+44
    02158 A49D      LDD	R9,Y+45
    02159 1862      SUB	R6,R2
    0215A 0873      SBC	R7,R3
    0215B 0884      SBC	R8,R4
    0215C 0895      SBC	R9,R5
    0215D A66A      STD	Y+42,R6
    0215E A67B      STD	Y+43,R7
    0215F A68C      STD	Y+44,R8
    02160 A69D      STD	Y+45,R9
(2893) 				clst = fp->clust;
    02161 A5E8      LDD	R30,Y+40
    02162 A5F9      LDD	R31,Y+41
    02163 9672      ADIW	R30,0x12
    02164 8020      LD	R2,Z
    02165 8031      LDD	R3,Z+1
    02166 8042      LDD	R4,Z+2
    02167 8053      LDD	R5,Z+3
    02168 822A      STD	Y+2,R2
    02169 823B      STD	Y+3,R3
    0216A 824C      STD	Y+4,R4
    0216B 825D      STD	Y+5,R5
(2894) 			} else {									/* When seek to back cluster, */
    0216C C069      RJMP	0x21D6
(2895) 				clst = fp->sclust;						/* start from the first cluster */
    0216D A5E8      LDD	R30,Y+40
    0216E A5F9      LDD	R31,Y+41
    0216F 963E      ADIW	R30,0xE
    02170 8020      LD	R2,Z
    02171 8031      LDD	R3,Z+1
    02172 8042      LDD	R4,Z+2
    02173 8053      LDD	R5,Z+3
    02174 822A      STD	Y+2,R2
    02175 823B      STD	Y+3,R3
    02176 824C      STD	Y+4,R4
    02177 825D      STD	Y+5,R5
(2896) #if !_FS_READONLY
(2897) 				if (clst == 0) {						/* If no cluster chain, create a new chain */
    02178 802A      LDD	R2,Y+2
    02179 803B      LDD	R3,Y+3
    0217A 804C      LDD	R4,Y+4
    0217B 805D      LDD	R5,Y+5
    0217C 9488      BCLR	0
    0217D 2022      TST	R2
    0217E 0432      CPC	R3,R2
    0217F 0442      CPC	R4,R2
    02180 0452      CPC	R5,R2
    02181 F009      BEQ	0x2183
    02182 C049      RJMP	0x21CC
(2898) 					clst = create_chain(fp->fs, 0);
    02183 E040      LDI	R20,0
    02184 E050      LDI	R21,0
    02185 E060      LDI	R22,0
    02186 E070      LDI	R23,0
    02187 8368      ST	Y,R22
    02188 8379      STD	Y+1,R23
    02189 019A      MOVW	R18,R20
    0218A A5E8      LDD	R30,Y+40
    0218B A5F9      LDD	R31,Y+41
    0218C 8100      LD	R16,Z
    0218D 8111      LDD	R17,Z+1
    0218E 940E 08D3 CALL	ff.c:create_chain
    02190 830A      STD	Y+2,R16
    02191 831B      STD	Y+3,R17
    02192 832C      STD	Y+4,R18
    02193 833D      STD	Y+5,R19
(2899) 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    02194 E041      LDI	R20,1
    02195 E050      LDI	R21,0
    02196 E060      LDI	R22,0
    02197 E070      LDI	R23,0
    02198 802A      LDD	R2,Y+2
    02199 803B      LDD	R3,Y+3
    0219A 804C      LDD	R4,Y+4
    0219B 805D      LDD	R5,Y+5
    0219C 1624      CP	R2,R20
    0219D 0635      CPC	R3,R21
    0219E 0646      CPC	R4,R22
    0219F 0657      CPC	R5,R23
    021A0 F451      BNE	0x21AB
    021A1 A588      LDD	R24,Y+40
    021A2 A599      LDD	R25,Y+41
    021A3 9604      ADIW	R24,4
    021A4 017C      MOVW	R14,R24
    021A5 01FC      MOVW	R30,R24
    021A6 8180      LD	R24,Z
    021A7 6880      ORI	R24,0x80
    021A8 8380      ST	Z,R24
    021A9 E002      LDI	R16,2
    021AA C196      RJMP	0x2341
(2900) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    021AB EF4F      LDI	R20,0xFF
    021AC EF5F      LDI	R21,0xFF
    021AD EF6F      LDI	R22,0xFF
    021AE EF7F      LDI	R23,0xFF
    021AF 802A      LDD	R2,Y+2
    021B0 803B      LDD	R3,Y+3
    021B1 804C      LDD	R4,Y+4
    021B2 805D      LDD	R5,Y+5
    021B3 1624      CP	R2,R20
    021B4 0635      CPC	R3,R21
    021B5 0646      CPC	R4,R22
    021B6 0657      CPC	R5,R23
    021B7 F451      BNE	0x21C2
    021B8 A588      LDD	R24,Y+40
    021B9 A599      LDD	R25,Y+41
    021BA 9604      ADIW	R24,4
    021BB 017C      MOVW	R14,R24
    021BC 01FC      MOVW	R30,R24
    021BD 8180      LD	R24,Z
    021BE 6880      ORI	R24,0x80
    021BF 8380      ST	Z,R24
    021C0 E001      LDI	R16,1
    021C1 C17F      RJMP	0x2341
(2901) 					fp->sclust = clst;
    021C2 802A      LDD	R2,Y+2
    021C3 803B      LDD	R3,Y+3
    021C4 804C      LDD	R4,Y+4
    021C5 805D      LDD	R5,Y+5
    021C6 A5E8      LDD	R30,Y+40
    021C7 A5F9      LDD	R31,Y+41
    021C8 8626      STD	Z+14,R2
    021C9 8637      STD	Z+15,R3
    021CA 8A40      STD	Z+16,R4
    021CB 8A51      STD	Z+17,R5
(2902) 				}
(2903) #endif
(2904) 				fp->clust = clst;
    021CC 802A      LDD	R2,Y+2
    021CD 803B      LDD	R3,Y+3
    021CE 804C      LDD	R4,Y+4
    021CF 805D      LDD	R5,Y+5
    021D0 A5E8      LDD	R30,Y+40
    021D1 A5F9      LDD	R31,Y+41
    021D2 8A22      STD	Z+18,R2
    021D3 8A33      STD	Z+19,R3
    021D4 8A44      STD	Z+20,R4
    021D5 8A55      STD	Z+21,R5
(2905) 			}
(2906) 			if (clst != 0) {
    021D6 802A      LDD	R2,Y+2
    021D7 803B      LDD	R3,Y+3
    021D8 804C      LDD	R4,Y+4
    021D9 805D      LDD	R5,Y+5
    021DA 9488      BCLR	0
    021DB 2022      TST	R2
    021DC 0432      CPC	R3,R2
    021DD 0442      CPC	R4,R2
    021DE 0452      CPC	R5,R2
    021DF F409      BNE	0x21E1
    021E0 C114      RJMP	0x22F5
    021E1 C0A7      RJMP	0x2289
(2907) 				while (ofs > bcs) {						/* Cluster following loop */
(2908) #if !_FS_READONLY
(2909) 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    021E2 A5E8      LDD	R30,Y+40
    021E3 A5F9      LDD	R31,Y+41
    021E4 9634      ADIW	R30,4
    021E5 8020      LD	R2,Z
    021E6 FE21      SBRS	R2,1
    021E7 C024      RJMP	0x220C
(2910) 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    021E8 802A      LDD	R2,Y+2
    021E9 803B      LDD	R3,Y+3
    021EA 804C      LDD	R4,Y+4
    021EB 805D      LDD	R5,Y+5
    021EC 8248      ST	Y,R4
    021ED 8259      STD	Y+1,R5
    021EE 0191      MOVW	R18,R2
    021EF A5E8      LDD	R30,Y+40
    021F0 A5F9      LDD	R31,Y+41
    021F1 8100      LD	R16,Z
    021F2 8111      LDD	R17,Z+1
    021F3 940E 08D3 CALL	ff.c:create_chain
    021F5 830A      STD	Y+2,R16
    021F6 831B      STD	Y+3,R17
    021F7 832C      STD	Y+4,R18
    021F8 833D      STD	Y+5,R19
(2911) 						if (clst == 0) {				/* When disk gets full, clip file size */
    021F9 802A      LDD	R2,Y+2
    021FA 803B      LDD	R3,Y+3
    021FB 804C      LDD	R4,Y+4
    021FC 805D      LDD	R5,Y+5
    021FD 9488      BCLR	0
    021FE 2022      TST	R2
    021FF 0432      CPC	R3,R2
    02200 0442      CPC	R4,R2
    02201 0452      CPC	R5,R2
    02202 F4D1      BNE	0x221D
(2912) 							ofs = bcs; break;
    02203 802E      LDD	R2,Y+6
    02204 803F      LDD	R3,Y+7
    02205 8448      LDD	R4,Y+8
    02206 8459      LDD	R5,Y+9
    02207 A62A      STD	Y+42,R2
    02208 A63B      STD	Y+43,R3
    02209 A64C      STD	Y+44,R4
    0220A A65D      STD	Y+45,R5
    0220B C08B      RJMP	0x2297
(2913) 						}
(2914) 					} else
(2915) #endif
(2916) 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    0220C 802A      LDD	R2,Y+2
    0220D 803B      LDD	R3,Y+3
    0220E 804C      LDD	R4,Y+4
    0220F 805D      LDD	R5,Y+5
    02210 8248      ST	Y,R4
    02211 8259      STD	Y+1,R5
    02212 0191      MOVW	R18,R2
    02213 A5E8      LDD	R30,Y+40
    02214 A5F9      LDD	R31,Y+41
    02215 8100      LD	R16,Z
    02216 8111      LDD	R17,Z+1
    02217 940E 0511 CALL	_get_fat
    02219 830A      STD	Y+2,R16
    0221A 831B      STD	Y+3,R17
    0221B 832C      STD	Y+4,R18
    0221C 833D      STD	Y+5,R19
(2917) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    0221D EF4F      LDI	R20,0xFF
    0221E EF5F      LDI	R21,0xFF
    0221F EF6F      LDI	R22,0xFF
    02220 EF7F      LDI	R23,0xFF
    02221 802A      LDD	R2,Y+2
    02222 803B      LDD	R3,Y+3
    02223 804C      LDD	R4,Y+4
    02224 805D      LDD	R5,Y+5
    02225 1624      CP	R2,R20
    02226 0635      CPC	R3,R21
    02227 0646      CPC	R4,R22
    02228 0657      CPC	R5,R23
    02229 F451      BNE	0x2234
    0222A A588      LDD	R24,Y+40
    0222B A599      LDD	R25,Y+41
    0222C 9604      ADIW	R24,4
    0222D 017C      MOVW	R14,R24
    0222E 01FC      MOVW	R30,R24
    0222F 8180      LD	R24,Z
    02230 6880      ORI	R24,0x80
    02231 8380      ST	Z,R24
    02232 E001      LDI	R16,1
    02233 C10D      RJMP	0x2341
(2918) 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    02234 E041      LDI	R20,1
    02235 E050      LDI	R21,0
    02236 E060      LDI	R22,0
    02237 E070      LDI	R23,0
    02238 802A      LDD	R2,Y+2
    02239 803B      LDD	R3,Y+3
    0223A 804C      LDD	R4,Y+4
    0223B 805D      LDD	R5,Y+5
    0223C 1542      CP	R20,R2
    0223D 0553      CPC	R21,R3
    0223E 0564      CPC	R22,R4
    0223F 0575      CPC	R23,R5
    02240 F490      BCC	0x2253
    02241 A5E8      LDD	R30,Y+40
    02242 A5F9      LDD	R31,Y+41
    02243 81A0      LD	R26,Z
    02244 81B1      LDD	R27,Z+1
    02245 9656      ADIW	R26,0x16
    02246 902D      LD	R2,X+
    02247 903D      LD	R3,X+
    02248 904D      LD	R4,X+
    02249 905C      LD	R5,X
    0224A 806A      LDD	R6,Y+2
    0224B 807B      LDD	R7,Y+3
    0224C 808C      LDD	R8,Y+4
    0224D 809D      LDD	R9,Y+5
    0224E 1462      CP	R6,R2
    0224F 0473      CPC	R7,R3
    02250 0484      CPC	R8,R4
    02251 0495      CPC	R9,R5
    02252 F050      BCS	0x225D
    02253 A588      LDD	R24,Y+40
    02254 A599      LDD	R25,Y+41
    02255 9604      ADIW	R24,4
    02256 017C      MOVW	R14,R24
    02257 01FC      MOVW	R30,R24
    02258 8180      LD	R24,Z
    02259 6880      ORI	R24,0x80
    0225A 8380      ST	Z,R24
    0225B E002      LDI	R16,2
    0225C C0E4      RJMP	0x2341
(2919) 					fp->clust = clst;
    0225D 802A      LDD	R2,Y+2
    0225E 803B      LDD	R3,Y+3
    0225F 804C      LDD	R4,Y+4
    02260 805D      LDD	R5,Y+5
    02261 A5E8      LDD	R30,Y+40
    02262 A5F9      LDD	R31,Y+41
    02263 9672      ADIW	R30,0x12
    02264 8220      ST	Z,R2
    02265 8231      STD	Z+1,R3
    02266 8242      STD	Z+2,R4
    02267 8253      STD	Z+3,R5
(2920) 					fp->fptr += bcs;
    02268 A588      LDD	R24,Y+40
    02269 A599      LDD	R25,Y+41
    0226A 9606      ADIW	R24,6
    0226B 017C      MOVW	R14,R24
    0226C 802E      LDD	R2,Y+6
    0226D 803F      LDD	R3,Y+7
    0226E 8448      LDD	R4,Y+8
    0226F 8459      LDD	R5,Y+9
    02270 01FC      MOVW	R30,R24
    02271 8060      LD	R6,Z
    02272 8071      LDD	R7,Z+1
    02273 8082      LDD	R8,Z+2
    02274 8093      LDD	R9,Z+3
    02275 0C62      ADD	R6,R2
    02276 1C73      ADC	R7,R3
    02277 1C84      ADC	R8,R4
    02278 1C95      ADC	R9,R5
    02279 8260      ST	Z,R6
    0227A 8271      STD	Z+1,R7
    0227B 8282      STD	Z+2,R8
    0227C 8293      STD	Z+3,R9
(2921) 					ofs -= bcs;
    0227D A46A      LDD	R6,Y+42
    0227E A47B      LDD	R7,Y+43
    0227F A48C      LDD	R8,Y+44
    02280 A49D      LDD	R9,Y+45
    02281 1862      SUB	R6,R2
    02282 0873      SBC	R7,R3
    02283 0884      SBC	R8,R4
    02284 0895      SBC	R9,R5
    02285 A66A      STD	Y+42,R6
    02286 A67B      STD	Y+43,R7
    02287 A68C      STD	Y+44,R8
    02288 A69D      STD	Y+45,R9
    02289 802E      LDD	R2,Y+6
    0228A 803F      LDD	R3,Y+7
    0228B 8448      LDD	R4,Y+8
    0228C 8459      LDD	R5,Y+9
    0228D A46A      LDD	R6,Y+42
    0228E A47B      LDD	R7,Y+43
    0228F A48C      LDD	R8,Y+44
    02290 A49D      LDD	R9,Y+45
    02291 1426      CP	R2,R6
    02292 0437      CPC	R3,R7
    02293 0448      CPC	R4,R8
    02294 0459      CPC	R5,R9
    02295 F408      BCC	0x2297
    02296 CF4B      RJMP	0x21E2
(2922) 				}
(2923) 				fp->fptr += ofs;
    02297 A588      LDD	R24,Y+40
    02298 A599      LDD	R25,Y+41
    02299 9606      ADIW	R24,6
    0229A 017C      MOVW	R14,R24
    0229B A42A      LDD	R2,Y+42
    0229C A43B      LDD	R3,Y+43
    0229D A44C      LDD	R4,Y+44
    0229E A45D      LDD	R5,Y+45
    0229F 01FC      MOVW	R30,R24
    022A0 8060      LD	R6,Z
    022A1 8071      LDD	R7,Z+1
    022A2 8082      LDD	R8,Z+2
    022A3 8093      LDD	R9,Z+3
    022A4 0C62      ADD	R6,R2
    022A5 1C73      ADC	R7,R3
    022A6 1C84      ADC	R8,R4
    022A7 1C95      ADC	R9,R5
    022A8 8260      ST	Z,R6
    022A9 8271      STD	Z+1,R7
    022AA 8282      STD	Z+2,R8
    022AB 8293      STD	Z+3,R9
(2924) 				if (ofs % SS(fp->fs)) {
    022AC EF4F      LDI	R20,0xFF
    022AD E051      LDI	R21,1
    022AE E060      LDI	R22,0
    022AF E070      LDI	R23,0
    022B0 2224      AND	R2,R20
    022B1 2235      AND	R3,R21
    022B2 2246      AND	R4,R22
    022B3 2257      AND	R5,R23
    022B4 9488      BCLR	0
    022B5 2022      TST	R2
    022B6 0432      CPC	R3,R2
    022B7 0442      CPC	R4,R2
    022B8 0452      CPC	R5,R2
    022B9 F409      BNE	0x22BB
    022BA C03A      RJMP	0x22F5
(2925) 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    022BB 802A      LDD	R2,Y+2
    022BC 803B      LDD	R3,Y+3
    022BD 804C      LDD	R4,Y+4
    022BE 805D      LDD	R5,Y+5
    022BF 8248      ST	Y,R4
    022C0 8259      STD	Y+1,R5
    022C1 0191      MOVW	R18,R2
    022C2 A5E8      LDD	R30,Y+40
    022C3 A5F9      LDD	R31,Y+41
    022C4 8100      LD	R16,Z
    022C5 8111      LDD	R17,Z+1
    022C6 940E 04BF CALL	_clust2sect
    022C8 870A      STD	Y+10,R16
    022C9 871B      STD	Y+11,R17
    022CA 872C      STD	Y+12,R18
    022CB 873D      STD	Y+13,R19
(2926) 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    022CC 842A      LDD	R2,Y+10
    022CD 843B      LDD	R3,Y+11
    022CE 844C      LDD	R4,Y+12
    022CF 845D      LDD	R5,Y+13
    022D0 9488      BCLR	0
    022D1 2022      TST	R2
    022D2 0432      CPC	R3,R2
    022D3 0442      CPC	R4,R2
    022D4 0452      CPC	R5,R2
    022D5 F451      BNE	0x22E0
    022D6 A588      LDD	R24,Y+40
    022D7 A599      LDD	R25,Y+41
    022D8 9604      ADIW	R24,4
    022D9 017C      MOVW	R14,R24
    022DA 01FC      MOVW	R30,R24
    022DB 8180      LD	R24,Z
    022DC 6880      ORI	R24,0x80
    022DD 8380      ST	Z,R24
    022DE E002      LDI	R16,2
    022DF C061      RJMP	0x2341
(2927) 					nsect += ofs / SS(fp->fs);
    022E0 E089      LDI	R24,0x9
    022E1 E090      LDI	R25,0
    022E2 A50A      LDD	R16,Y+42
    022E3 A51B      LDD	R17,Y+43
    022E4 A52C      LDD	R18,Y+44
    022E5 A53D      LDD	R19,Y+45
    022E6 938A      ST	-Y,R24
    022E7 940E 41AC CALL	lsr32
    022E9 842A      LDD	R2,Y+10
    022EA 843B      LDD	R3,Y+11
    022EB 844C      LDD	R4,Y+12
    022EC 845D      LDD	R5,Y+13
    022ED 0E20      ADD	R2,R16
    022EE 1E31      ADC	R3,R17
    022EF 1E42      ADC	R4,R18
    022F0 1E53      ADC	R5,R19
    022F1 862A      STD	Y+10,R2
    022F2 863B      STD	Y+11,R3
    022F3 864C      STD	Y+12,R4
    022F4 865D      STD	Y+13,R5
(2928) 				}
(2929) 			}
(2930) 		}
(2931) 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    022F5 EF4F      LDI	R20,0xFF
    022F6 E051      LDI	R21,1
    022F7 E060      LDI	R22,0
    022F8 E070      LDI	R23,0
    022F9 A5E8      LDD	R30,Y+40
    022FA A5F9      LDD	R31,Y+41
    022FB 9636      ADIW	R30,6
    022FC 8020      LD	R2,Z
    022FD 8031      LDD	R3,Z+1
    022FE 8042      LDD	R4,Z+2
    022FF 8053      LDD	R5,Z+3
    02300 2224      AND	R2,R20
    02301 2235      AND	R3,R21
    02302 2246      AND	R4,R22
    02303 2257      AND	R5,R23
    02304 9488      BCLR	0
    02305 2022      TST	R2
    02306 0432      CPC	R3,R2
    02307 0442      CPC	R4,R2
    02308 0452      CPC	R5,R2
    02309 F0C1      BEQ	0x2322
    0230A A5E8      LDD	R30,Y+40
    0230B A5F9      LDD	R31,Y+41
    0230C 9676      ADIW	R30,0x16
    0230D 8020      LD	R2,Z
    0230E 8031      LDD	R3,Z+1
    0230F 8042      LDD	R4,Z+2
    02310 8053      LDD	R5,Z+3
    02311 846A      LDD	R6,Y+10
    02312 847B      LDD	R7,Y+11
    02313 848C      LDD	R8,Y+12
    02314 849D      LDD	R9,Y+13
    02315 1462      CP	R6,R2
    02316 0473      CPC	R7,R3
    02317 0484      CPC	R8,R4
    02318 0495      CPC	R9,R5
    02319 F041      BEQ	0x2322
(2932) #if !_FS_TINY
(2933) #if !_FS_READONLY
(2934) 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
(2935) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2936) 					ABORT(fp->fs, FR_DISK_ERR);
(2937) 				fp->flag &= ~FA__DIRTY;
(2938) 			}
(2939) #endif
(2940) 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
(2941) 				ABORT(fp->fs, FR_DISK_ERR);
(2942) #endif
(2943) 			fp->dsect = nsect;
    0231A 0113      MOVW	R2,R6
    0231B 0124      MOVW	R4,R8
    0231C A5E8      LDD	R30,Y+40
    0231D A5F9      LDD	R31,Y+41
    0231E 8A26      STD	Z+22,R2
    0231F 8A37      STD	Z+23,R3
    02320 8E40      STD	Z+24,R4
    02321 8E51      STD	Z+25,R5
(2944) 		}
(2945) #if !_FS_READONLY
(2946) 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    02322 A5E8      LDD	R30,Y+40
    02323 A5F9      LDD	R31,Y+41
    02324 8422      LDD	R2,Z+10
    02325 8433      LDD	R3,Z+11
    02326 8444      LDD	R4,Z+12
    02327 8455      LDD	R5,Z+13
    02328 8066      LDD	R6,Z+6
    02329 8077      LDD	R7,Z+7
    0232A 8480      LDD	R8,Z+8
    0232B 8491      LDD	R9,Z+9
    0232C 1426      CP	R2,R6
    0232D 0437      CPC	R3,R7
    0232E 0448      CPC	R4,R8
    0232F 0459      CPC	R5,R9
    02330 F478      BCC	0x2340
(2947) 			fp->fsize = fp->fptr;
    02331 8026      LDD	R2,Z+6
    02332 8037      LDD	R3,Z+7
    02333 8440      LDD	R4,Z+8
    02334 8451      LDD	R5,Z+9
    02335 8622      STD	Z+10,R2
    02336 8633      STD	Z+11,R3
    02337 8644      STD	Z+12,R4
    02338 8655      STD	Z+13,R5
(2948) 			fp->flag |= FA__WRITTEN;
    02339 01CF      MOVW	R24,R30
    0233A 9604      ADIW	R24,4
    0233B 016C      MOVW	R12,R24
    0233C 01FC      MOVW	R30,R24
    0233D 8180      LD	R24,Z
    0233E 6280      ORI	R24,0x20
    0233F 8380      ST	Z,R24
(2949) 		}
(2950) #endif
(2951) 	}
(2952) 
(2953) 	LEAVE_FF(fp->fs, res);
    02340 2D0A      MOV	R16,R10
    02341 966E      ADIW	R28,0x1E
    02342 940E 4106 CALL	pop_xgsetF0FC
    02344 9624      ADIW	R28,4
    02345 9508      RET
_f_opendir:
  sfn                  --> Y,+1
  res                  --> R20
  path                 --> Y,+19
  dj                   --> R22
    02346 933A      ST	-Y,R19
    02347 932A      ST	-Y,R18
    02348 940E 4130 CALL	push_xgsetF00C
    0234A 01B8      MOVW	R22,R16
    0234B 972D      SBIW	R28,0xD
(2954) }
(2955) 
(2956) 
(2957) 
(2958) #if _FS_MINIMIZE <= 1
(2959) /*-----------------------------------------------------------------------*/
(2960) /* Create a Directroy Object                                             */
(2961) /*-----------------------------------------------------------------------*/
(2962) 
(2963) FRESULT f_opendir (
(2964) 	DIR *dj,			/* Pointer to directory object to create */
(2965) 	const TCHAR *path	/* Pointer to the directory path */
(2966) )
(2967) {
(2968) 	FRESULT res;
(2969) 	DEF_NAMEBUF;
(2970) 
(2971) 
(2972) 	res = chk_mounted(&path, &dj->fs, 0);
    0234C 2422      CLR	R2
    0234D 8228      ST	Y,R2
    0234E 019B      MOVW	R18,R22
    0234F 018E      MOVW	R16,R28
    02350 5E0D      SUBI	R16,0xED
    02351 4F1F      SBCI	R17,0xFF
    02352 940E 1166 CALL	ff.c:chk_mounted
    02354 2F40      MOV	R20,R16
(2973) 	if (res == FR_OK) {
    02355 2300      TST	R16
    02356 F009      BEQ	0x2358
    02357 C05C      RJMP	0x23B4
(2974) 		INIT_BUF(*dj);
    02358 01CE      MOVW	R24,R28
    02359 9601      ADIW	R24,1
    0235A 01FB      MOVW	R30,R22
    0235B 8B95      STD	Z+21,R25
    0235C 8B84      STD	Z+20,R24
(2975) 		res = follow_path(dj, path);			/* Follow the path to the directory */
    0235D 892B      LDD	R18,Y+19
    0235E 893C      LDD	R19,Y+20
    0235F 018F      MOVW	R16,R30
    02360 940E 101A CALL	ff.c:follow_path
    02362 2F40      MOV	R20,R16
(2976) 		FREE_BUF();
(2977) 		if (res == FR_OK) {						/* Follow completed */
    02363 2300      TST	R16
    02364 F009      BEQ	0x2366
    02365 C04B      RJMP	0x23B1
(2978) 			if (dj->dir) {						/* It is not the root dir */
    02366 01FB      MOVW	R30,R22
    02367 8822      LDD	R2,Z+18
    02368 8833      LDD	R3,Z+19
    02369 2022      TST	R2
    0236A F419      BNE	0x236E
    0236B 2033      TST	R3
    0236C F409      BNE	0x236E
    0236D C032      RJMP	0x23A0
(2979) 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    0236E 93AF      PUSH	R26
    0236F 93BF      PUSH	R27
    02370 89A2      LDD	R26,Z+18
    02371 89B3      LDD	R27,Z+19
    02372 01FD      MOVW	R30,R26
    02373 91BF      POP	R27
    02374 91AF      POP	R26
    02375 8423      LDD	R2,Z+11
    02376 FE24      SBRS	R2,4
    02377 C027      RJMP	0x239F
(2980) 					dj->sclust = LD_CLUST(dj->dir);
    02378 01FB      MOVW	R30,R22
    02379 88A2      LDD	R10,Z+18
    0237A 88B3      LDD	R11,Z+19
    0237B 01F5      MOVW	R30,R10
    0237C 8C22      LDD	R2,Z+26
    0237D 2433      CLR	R3
    0237E 8C43      LDD	R4,Z+27
    0237F 2455      CLR	R5
    02380 2C54      MOV	R5,R4
    02381 2444      CLR	R4
    02382 2842      OR	R4,R2
    02383 2853      OR	R5,R3
    02384 0112      MOVW	R2,R4
    02385 2444      CLR	R4
    02386 2455      CLR	R5
    02387 8864      LDD	R6,Z+20
    02388 2477      CLR	R7
    02389 8885      LDD	R8,Z+21
    0238A 2499      CLR	R9
    0238B 2C98      MOV	R9,R8
    0238C 2488      CLR	R8
    0238D 2886      OR	R8,R6
    0238E 2897      OR	R9,R7
    0238F 0134      MOVW	R6,R8
    02390 2488      CLR	R8
    02391 2499      CLR	R9
    02392 0143      MOVW	R8,R6
    02393 2466      CLR	R6
    02394 2477      CLR	R7
    02395 2862      OR	R6,R2
    02396 2873      OR	R7,R3
    02397 2884      OR	R8,R4
    02398 2895      OR	R9,R5
    02399 01FB      MOVW	R30,R22
    0239A 8266      STD	Z+6,R6
    0239B 8277      STD	Z+7,R7
    0239C 8680      STD	Z+8,R8
    0239D 8691      STD	Z+9,R9
(2981) 				} else {						/* The object is not a directory */
    0239E C001      RJMP	0x23A0
(2982) 					res = FR_NO_PATH;
    0239F E045      LDI	R20,5
(2983) 				}
(2984) 			}
(2985) 			if (res == FR_OK) {
    023A0 2344      TST	R20
    023A1 F479      BNE	0x23B1
(2986) 				dj->id = dj->fs->id;
    023A2 01FB      MOVW	R30,R22
    023A3 81A0      LD	R26,Z
    023A4 81B1      LDD	R27,Z+1
    023A5 9616      ADIW	R26,6
    023A6 902D      LD	R2,X+
    023A7 903C      LD	R3,X
    023A8 8233      STD	Z+3,R3
    023A9 8222      STD	Z+2,R2
(2987) 				res = dir_sdi(dj, 0);			/* Rewind dir */
    023AA 2722      CLR	R18
    023AB 2733      CLR	R19
    023AC 018F      MOVW	R16,R30
    023AD 940E 0AC4 CALL	ff.c:dir_sdi
    023AF 2EA0      MOV	R10,R16
    023B0 2D4A      MOV	R20,R10
(2988) 			}
(2989) 		}
(2990) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
    023B1 3044      CPI	R20,4
    023B2 F409      BNE	0x23B4
    023B3 E045      LDI	R20,5
(2991) 	}
(2992) 
(2993) 	LEAVE_FF(dj->fs, res);
    023B4 2F04      MOV	R16,R20
    023B5 962D      ADIW	R28,0xD
    023B6 940E 4137 CALL	pop_xgsetF00C
    023B8 9622      ADIW	R28,2
    023B9 9508      RET
_f_readdir:
  sfn                  --> Y,+0
  res                  --> R20
  fno                  --> R10
  dj                   --> R22
    023BA 940E 414C CALL	push_xgsetF03C
    023BC 0159      MOVW	R10,R18
    023BD 01B8      MOVW	R22,R16
    023BE 972C      SBIW	R28,0xC
(2994) }
(2995) 
(2996) 
(2997) 
(2998) 
(2999) /*-----------------------------------------------------------------------*/
(3000) /* Read Directory Entry in Sequense                                      */
(3001) /*-----------------------------------------------------------------------*/
(3002) 
(3003) FRESULT f_readdir (
(3004) 	DIR *dj,			/* Pointer to the open directory object */
(3005) 	FILINFO *fno		/* Pointer to file information to return */
(3006) )
(3007) {
(3008) 	FRESULT res;
(3009) 	DEF_NAMEBUF;
(3010) 
(3011) 
(3012) 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    023BF 01FB      MOVW	R30,R22
    023C0 8122      LDD	R18,Z+2
    023C1 8133      LDD	R19,Z+3
    023C2 8100      LD	R16,Z
    023C3 8111      LDD	R17,Z+1
    023C4 940E 1660 CALL	ff.c:validate
    023C6 2F40      MOV	R20,R16
(3013) 	if (res == FR_OK) {
    023C7 2300      TST	R16
    023C8 F009      BEQ	0x23CA
    023C9 C035      RJMP	0x23FF
(3014) 		if (!fno) {
    023CA 20AA      TST	R10
    023CB F449      BNE	0x23D5
    023CC 20BB      TST	R11
    023CD F439      BNE	0x23D5
(3015) 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    023CE 2722      CLR	R18
    023CF 2733      CLR	R19
    023D0 018B      MOVW	R16,R22
    023D1 940E 0AC4 CALL	ff.c:dir_sdi
    023D3 2F40      MOV	R20,R16
(3016) 		} else {
    023D4 C02A      RJMP	0x23FF
(3017) 			INIT_BUF(*dj);
    023D5 01CE      MOVW	R24,R28
    023D6 01FB      MOVW	R30,R22
    023D7 8B95      STD	Z+21,R25
    023D8 8B84      STD	Z+20,R24
(3018) 			res = dir_read(dj);				/* Read an directory item */
    023D9 018F      MOVW	R16,R30
    023DA 940E 0DC1 CALL	ff.c:dir_read
    023DC 2EC0      MOV	R12,R16
    023DD 2D4C      MOV	R20,R12
(3019) 			if (res == FR_NO_FILE) {		/* Reached end of dir */
    023DE 3004      CPI	R16,4
    023DF F441      BNE	0x23E8
(3020) 				dj->sect = 0;
    023E0 01FB      MOVW	R30,R22
    023E1 963E      ADIW	R30,0xE
    023E2 E080      LDI	R24,0
    023E3 8380      ST	Z,R24
    023E4 8381      STD	Z+1,R24
    023E5 8382      STD	Z+2,R24
    023E6 8383      STD	Z+3,R24
(3021) 				res = FR_OK;
    023E7 2744      CLR	R20
(3022) 			}
(3023) 			if (res == FR_OK) {				/* A valid entry is found */
    023E8 2344      TST	R20
    023E9 F4A9      BNE	0x23FF
(3024) 				get_fileinfo(dj, fno);		/* Get the object information */
    023EA 0195      MOVW	R18,R10
    023EB 018B      MOVW	R16,R22
    023EC 940E 0F77 CALL	ff.c:get_fileinfo
(3025) 				res = dir_next(dj, 0);		/* Increment index for next */
    023EE 2722      CLR	R18
    023EF 2733      CLR	R19
    023F0 018B      MOVW	R16,R22
    023F1 940E 0BCE CALL	ff.c:dir_next
    023F3 2EA0      MOV	R10,R16
    023F4 2D4A      MOV	R20,R10
(3026) 				if (res == FR_NO_FILE) {
    023F5 3004      CPI	R16,4
    023F6 F441      BNE	0x23FF
(3027) 					dj->sect = 0;
    023F7 01FB      MOVW	R30,R22
    023F8 963E      ADIW	R30,0xE
    023F9 E080      LDI	R24,0
    023FA 8380      ST	Z,R24
    023FB 8381      STD	Z+1,R24
    023FC 8382      STD	Z+2,R24
    023FD 8383      STD	Z+3,R24
(3028) 					res = FR_OK;
    023FE 2744      CLR	R20
(3029) 				}
(3030) 			}
(3031) 			FREE_BUF();
(3032) 		}
(3033) 	}
(3034) 
(3035) 	LEAVE_FF(dj->fs, res);
    023FF 2F04      MOV	R16,R20
    02400 962C      ADIW	R28,0xC
    02401 940C 4155 JMP	pop_xgsetF03C
FILE: D:\LQD\software\master\software_src\delay.c
(0001) /*******************************
(0002)  function ：延时函数
(0003) Clock F  :7.3728M 
(0004) Software : ICCAVR7.14C
(0005) ********************************/
(0006) /*---------------------------------------------------------------------------------
(0007)      延时程序计算方法
(0008)      计数个数j = 延时时间/6*晶振频率 - 1
(0009) ---------------------------------------------------------------------------------*/
(0010) void delayus(unsigned int tttt)   // 1.2us 延时子函数   
(0011) { 
(0012)    do
(0013)    {
(0014)        tttt--;
_delayus:
  tttt                 --> R16
    02403 5001      SUBI	R16,1
    02404 4010      SBCI	R17,0
(0015)    }
(0016)    while(tttt>1);
    02405 E081      LDI	R24,1
    02406 E090      LDI	R25,0
    02407 1780      CP	R24,R16
    02408 0791      CPC	R25,R17
    02409 F3C8      BCS	0x2403
    0240A 9508      RET
_delayms:
  j                    --> R20
  i                    --> R16
    0240B 934A      ST	-Y,R20
    0240C 935A      ST	-Y,R21
(0017) }
(0018) void delayms(unsigned int i)                 //1ms延时
(0019)    {
    0240D C00A      RJMP	0x2418
(0020)     while(i--)
(0021)     {                          
(0022) 	    unsigned int j;                
(0023)         for(j=1;j<=1227;j++)   
    0240E E041      LDI	R20,1
    0240F E050      LDI	R21,0
    02410 C002      RJMP	0x2413
    02411 5F4F      SUBI	R20,0xFF
    02412 4F5F      SBCI	R21,0xFF
    02413 EC8B      LDI	R24,0xCB
    02414 E094      LDI	R25,4
    02415 1784      CP	R24,R20
    02416 0795      CPC	R25,R21
    02417 F7C8      BCC	0x2411
    02418 0118      MOVW	R2,R16
    02419 5001      SUBI	R16,1
    0241A 4010      SBCI	R17,0
    0241B 2022      TST	R2
    0241C F789      BNE	0x240E
    0241D 2033      TST	R3
    0241E F779      BNE	0x240E
    0241F 9159      LD	R21,Y+
    02420 9149      LD	R20,Y+
    02421 9508      RET
FILE: D:\LQD\software\master\software_src\main.c
(0001) #include "config.h"
(0002) #define  N_per_Second  (2.72*60)
(0003) const char tab[]="\t\0";
(0004) const char enter[]="\n\0";
(0005) char buffer[512];
(0006) char TempChar[80]; //存放临时字串
(0007) struct DATA Result;
(0008) struct tm t;
(0009) unsigned long now =0; 
(0010) void debug(UINT8 *str,UINT8 val);
(0011) void WriteSDFile(void);
(0012) struct CONFIG config;
(0013) void initDevices(void){
(0014)      CLI();
_initDevices:
    02422 94F8      BCLR	7
(0015) 	 DDRA=0XFF;
    02423 EF8F      LDI	R24,0xFF
    02424 BB8A      OUT	0x1A,R24
(0016) 	 PORTA=0XFF;
    02425 BB8B      OUT	0x1B,R24
(0017) 	 DDRB=0XFF;
    02426 BB87      OUT	0x17,R24
(0018) 	 PORTB=0XFF; 	 
    02427 BB88      OUT	0x18,R24
(0019) 	 DDRC=0XFF;
    02428 BB84      OUT	0x14,R24
(0020) 	 PORTC=0XFF;
    02429 BB85      OUT	0x15,R24
(0021) 	 DDRG=0XFF;
    0242A 9380 0064 STS	0x64,R24
(0022) 	 PORTG=0XFF;	 
    0242C 9380 0065 STS	0x65,R24
(0023) 	 SPI_IO_Init(); 
    0242E 940E 392C CALL	_SPI_IO_Init
(0024) 	 SD_Init();
    02430 940E 2B6E CALL	_SD_Init
(0025) 	 uart1_init();
    02432 940E 3756 CALL	_uart1_init
(0026) 	 LCD_INT();delayms(50);LCD_INT();
    02434 940E 394A CALL	_LCD_INT
    02436 E302      LDI	R16,0x32
    02437 E010      LDI	R17,0
    02438 940E 240B CALL	_delayms
    0243A 940E 394A CALL	_LCD_INT
(0027) 	 LCD_SW(1);
    0243C E001      LDI	R16,1
    0243D 940E 3940 CALL	_LCD_SW
(0028) 	 config.THRESHOLD_delta_sec=60; //一次检测用时
    0243F E38C      LDI	R24,0x3C
    02440 9380 07D3 STS	config+4,R24
    02442 E080      LDI	R24,0
    02443 9380 07D4 STS	config+5,R24
    02445 9380 07D5 STS	config+6,R24
    02447 9380 07D6 STS	config+7,R24
(0029) 	 config.autocheck=1;        //自动检测开关
    02449 E081      LDI	R24,1
    0244A 9380 07DF STS	config+16,R24
(0030) 	 config.checkDeltaTime=20;  //自动检测模式 时间间隔
    0244C E184      LDI	R24,0x14
    0244D E090      LDI	R25,0
    0244E 9390 07E1 STS	config+18,R25
    02450 9380 07E0 STS	config+17,R24
(0031) 	 config.readMode = 0;      //读数据模式
    02452 2422      CLR	R2
    02453 9220 07E2 STS	config+19,R2
(0032) 	 SEI();
    02455 9478      BSET	7
    02456 9508      RET
(0033) }
(0034) void timer1_init(void)
(0035) {
(0036)  TCCR1B = 0x00; //stop
_timer1_init:
    02457 2422      CLR	R2
    02458 BC2E      OUT	0x2E,R2
(0037)  TCNT1H = 0x00 /*INVALID SETTING*/; //setup
    02459 BC2D      OUT	0x2D,R2
(0038)  TCNT1L = 0x00 /*INVALID SETTING*/;
    0245A BC2C      OUT	0x2C,R2
(0039)  TCCR1A = 0x00;
    0245B BC2F      OUT	0x2F,R2
(0040)  TCCR1B = 0x46; //start Timer
    0245C E486      LDI	R24,0x46
    0245D BD8E      OUT	0x2E,R24
    0245E 9508      RET
_main:
  keycode              --> Y,+1
  i                    --> R10
  filename             --> Y,+513
  buf512               --> Y,+0
  tmp                  --> R10
    0245F 97EF      SBIW	R28,0x3F
    02460 97EF      SBIW	R28,0x3F
    02461 97EF      SBIW	R28,0x3F
    02462 97EF      SBIW	R28,0x3F
    02463 97EF      SBIW	R28,0x3F
    02464 97EF      SBIW	R28,0x3F
    02465 97EF      SBIW	R28,0x3F
    02466 97EF      SBIW	R28,0x3F
    02467 9767      SBIW	R28,0x17
(0041) }
(0042) ////////////////////////////////////////////////////////////////
(0043) void main(void){
(0044) 	 UINT8 tmp,keycode;
(0045) 	 UINT8 buf512[513];
(0046) 	 char filename[]="201302.xls\0\0\0";
    02468 E189      LDI	R24,0x19
    02469 E091      LDI	R25,1
    0246A 01FE      MOVW	R30,R28
    0246B 5FEF      SUBI	R30,0xFF
    0246C 4FFD      SBCI	R31,0xFD
    0246D E00E      LDI	R16,0xE
    0246E E010      LDI	R17,0
    0246F 93FA      ST	-Y,R31
    02470 93EA      ST	-Y,R30
    02471 939A      ST	-Y,R25
    02472 938A      ST	-Y,R24
    02473 940E 41B8 CALL	asgnblk
(0047) 	 int i=0;
    02475 24AA      CLR	R10
    02476 24BB      CLR	R11
(0048) 	 initDevices();
    02477 DFAA      RCALL	_initDevices
(0049) 	 dateRefresh(1);
    02478 E001      LDI	R16,1
    02479 940E 35F6 CALL	_dateRefresh
(0050) 	 WriteFileHead();
    0247B D0FD      RCALL	_WriteFileHead
(0051)      Result.Index=findIndex(get_name(filename),buf512);
    0247C 018E      MOVW	R16,R28
    0247D 5F0F      SUBI	R16,0xFF
    0247E 4F1D      SBCI	R17,0xFD
    0247F D5C4      RCALL	_get_name
    02480 019E      MOVW	R18,R28
    02481 D23A      RCALL	_findIndex
    02482 0118      MOVW	R2,R16
    02483 2444      CLR	R4
    02484 2455      CLR	R5
    02485 9230 056A STS	Result+11,R3
    02487 9220 0569 STS	Result+10,R2
    02489 9250 056C STS	Result+13,R5
    0248B 9240 056B STS	Result+12,R4
(0052) 	 //selfTest();
(0053) 	 GUI_welcome();
    0248D 940E 35D9 CALL	_GUI_welcome
    0248F C025      RJMP	0x24B5
(0054) 	 while(1){
(0055) 	    tmp=GUI_mainmeu();
    02490 940E 2D47 CALL	_GUI_mainmeu
    02492 2EA0      MOV	R10,R16
(0056) 		switch(tmp){
    02493 2D4A      MOV	R20,R10
    02494 2755      CLR	R21
    02495 3043      CPI	R20,3
    02496 E0E0      LDI	R30,0
    02497 075E      CPC	R21,R30
    02498 F069      BEQ	0x24A6
    02499 3044      CPI	R20,4
    0249A E0E0      LDI	R30,0
    0249B 075E      CPC	R21,R30
    0249C F061      BEQ	0x24A9
    0249D 3045      CPI	R20,5
    0249E E0E0      LDI	R30,0
    0249F 075E      CPC	R21,R30
    024A0 F059      BEQ	0x24AC
    024A1 3047      CPI	R20,7
    024A2 E0E0      LDI	R30,0
    024A3 075E      CPC	R21,R30
    024A4 F059      BEQ	0x24B0
    024A5 C00B      RJMP	0x24B1
(0057) 		    case 3 : GUI_check(); break; 
    024A6 940E 2E2C CALL	_GUI_check
    024A8 C008      RJMP	0x24B1
(0058) 			case 4 : GUI_set_time(); break ;
    024A9 940E 3274 CALL	_GUI_set_time
    024AB C005      RJMP	0x24B1
(0059) 			case 5 : GUI_readback(buf512); break;
    024AC 018E      MOVW	R16,R28
    024AD 940E 34BC CALL	_GUI_readback
    024AF C001      RJMP	0x24B1
(0060) 			//case 6 : GUI_send_date();
(0061) 			case 7 : selfTest(); break ;
    024B0 D00F      RCALL	_selfTest
(0062) 			default : break;
(0063) 	   }
(0064) 	   delayms(100);
    024B1 E604      LDI	R16,0x64
    024B2 E010      LDI	R17,0
    024B3 940E 240B CALL	_delayms
    024B5 CFDA      RJMP	0x2490
    024B6 96EF      ADIW	R28,0x3F
    024B7 96EF      ADIW	R28,0x3F
    024B8 96EF      ADIW	R28,0x3F
    024B9 96EF      ADIW	R28,0x3F
    024BA 96EF      ADIW	R28,0x3F
    024BB 96EF      ADIW	R28,0x3F
    024BC 96EF      ADIW	R28,0x3F
    024BD 96EF      ADIW	R28,0x3F
    024BE 9667      ADIW	R28,0x17
    024BF 9508      RET
_selfTest:
  str2                 --> Y,+12
  str1                 --> Y,+6
  tmp                  --> Y,+2
    024C0 9762      SBIW	R28,0x12
(0065) 	 }
(0066) 
(0067) }
(0068) void selfTest(void){
(0069) 	float tmp=0;                                                                
    024C1 EB04      LDI	R16,0xB4
    024C2 E010      LDI	R17,0
    024C3 940E 4099 CALL	elpm32
    024C5 830A      STD	Y+2,R16
    024C6 831B      STD	Y+3,R17
    024C7 832C      STD	Y+4,R18
    024C8 833D      STD	Y+5,R19
(0070) 	char str1[6],str2[6];
(0071) 	
(0072) 	 //自检程序
(0073) 	lp("自检程序");delayms(500);
    024C9 E401      LDI	R16,0x41
    024CA E012      LDI	R17,2
    024CB 940E 3C79 CALL	_lp
    024CD EF04      LDI	R16,0xF4
    024CE E011      LDI	R17,1
    024CF 940E 240B CALL	_delayms
(0074) 	lp("外部温度 ");
    024D1 E307      LDI	R16,0x37
    024D2 E012      LDI	R17,2
    024D3 940E 3C79 CALL	_lp
(0075) 	tmp=read_T_NUM(0);
    024D5 2700      CLR	R16
    024D6 940E 3EAC CALL	_read_T_NUM
    024D8 830A      STD	Y+2,R16
    024D9 831B      STD	Y+3,R17
    024DA 832C      STD	Y+4,R18
    024DB 833D      STD	Y+5,R19
(0076) 	ftochr(tmp,str1);
    024DC 01CE      MOVW	R24,R28
    024DD 9606      ADIW	R24,6
    024DE 8399      STD	Y+1,R25
    024DF 8388      ST	Y,R24
    024E0 810A      LDD	R16,Y+2
    024E1 811B      LDD	R17,Y+3
    024E2 812C      LDD	R18,Y+4
    024E3 813D      LDD	R19,Y+5
    024E4 D465      RCALL	_ftochr
(0077) 	str1[6]=0;
    024E5 2422      CLR	R2
    024E6 862C      STD	Y+12,R2
(0078) 	lp(str1);
    024E7 018E      MOVW	R16,R28
    024E8 5F0A      SUBI	R16,0xFA
    024E9 4F1F      SBCI	R17,0xFF
    024EA 940E 3C79 CALL	_lp
(0079) 	delayms(500);
    024EC EF04      LDI	R16,0xF4
    024ED E011      LDI	R17,1
    024EE 940E 240B CALL	_delayms
(0080) 	lp("内部温度");
    024F0 E20E      LDI	R16,0x2E
    024F1 E012      LDI	R17,2
    024F2 940E 3C79 CALL	_lp
(0081) 	tmp=read_T_NUM(1);
    024F4 E001      LDI	R16,1
    024F5 940E 3EAC CALL	_read_T_NUM
    024F7 830A      STD	Y+2,R16
    024F8 831B      STD	Y+3,R17
    024F9 832C      STD	Y+4,R18
    024FA 833D      STD	Y+5,R19
(0082) 	ftochr(tmp,str2);
    024FB 01CE      MOVW	R24,R28
    024FC 960C      ADIW	R24,0xC
    024FD 8399      STD	Y+1,R25
    024FE 8388      ST	Y,R24
    024FF 810A      LDD	R16,Y+2
    02500 811B      LDD	R17,Y+3
    02501 812C      LDD	R18,Y+4
    02502 813D      LDD	R19,Y+5
    02503 D446      RCALL	_ftochr
(0083) 	str2[6]=0;
    02504 2422      CLR	R2
    02505 8A2A      STD	Y+18,R2
(0084) 	lp(str2);
    02506 018E      MOVW	R16,R28
    02507 5F04      SUBI	R16,0xF4
    02508 4F1F      SBCI	R17,0xFF
    02509 940E 3C79 CALL	_lp
(0085) 	delayms(500);
    0250B EF04      LDI	R16,0xF4
    0250C E011      LDI	R17,1
    0250D 940E 240B CALL	_delayms
(0086) 	lp("风速脉冲：");delayms(500);
    0250F E203      LDI	R16,0x23
    02510 E012      LDI	R17,2
    02511 940E 3C79 CALL	_lp
    02513 EF04      LDI	R16,0xF4
    02514 E011      LDI	R17,1
    02515 940E 240B CALL	_delayms
(0087) 	lp("蜂鸣器"); beep(2,2);delayms(500);
    02517 E10C      LDI	R16,0x1C
    02518 E012      LDI	R17,2
    02519 940E 3C79 CALL	_lp
    0251B E022      LDI	R18,2
    0251C E002      LDI	R16,2
    0251D 940E 3CEF CALL	_beep
    0251F EF04      LDI	R16,0xF4
    02520 E011      LDI	R17,1
    02521 940E 240B CALL	_delayms
(0088) 	lp("power 指示灯");
    02523 E00F      LDI	R16,0xF
    02524 E012      LDI	R17,2
    02525 940E 3C79 CALL	_lp
(0089) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02527 9AA7      SBI	0x14,7
    02528 98AF      CBI	0x15,7
    02529 E604      LDI	R16,0x64
    0252A E010      LDI	R17,0
    0252B 940E 240B CALL	_delayms
    0252D 9AA7      SBI	0x14,7
    0252E 9AAF      SBI	0x15,7
    0252F E604      LDI	R16,0x64
    02530 E010      LDI	R17,0
    02531 940E 240B CALL	_delayms
(0090) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02533 9AA7      SBI	0x14,7
    02534 98AF      CBI	0x15,7
    02535 E604      LDI	R16,0x64
    02536 E010      LDI	R17,0
    02537 940E 240B CALL	_delayms
    02539 9AA7      SBI	0x14,7
    0253A 9AAF      SBI	0x15,7
    0253B E604      LDI	R16,0x64
    0253C E010      LDI	R17,0
    0253D 940E 240B CALL	_delayms
(0091) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    0253F 9AA7      SBI	0x14,7
    02540 98AF      CBI	0x15,7
    02541 E604      LDI	R16,0x64
    02542 E010      LDI	R17,0
    02543 940E 240B CALL	_delayms
    02545 9AA7      SBI	0x14,7
    02546 9AAF      SBI	0x15,7
    02547 E604      LDI	R16,0x64
    02548 E010      LDI	R17,0
    02549 940E 240B CALL	_delayms
(0092) 	delayms(500);
    0254B EF04      LDI	R16,0xF4
    0254C E011      LDI	R17,1
    0254D 940E 240B CALL	_delayms
(0093) 	lp("加热开关");
    0254F E006      LDI	R16,6
    02550 E012      LDI	R17,2
    02551 940E 3C79 CALL	_lp
(0094) 	RELAY_ON();delayms(100);  
    02553 9AAD      SBI	0x15,5
    02554 E604      LDI	R16,0x64
    02555 E010      LDI	R17,0
    02556 940E 240B CALL	_delayms
(0095) 	RELAY_OFF();delayms(100);
    02558 98AD      CBI	0x15,5
    02559 E604      LDI	R16,0x64
    0255A E010      LDI	R17,0
    0255B 940E 240B CALL	_delayms
(0096) 	RELAY_ON();delayms(100);
    0255D 9AAD      SBI	0x15,5
    0255E E604      LDI	R16,0x64
    0255F E010      LDI	R17,0
    02560 940E 240B CALL	_delayms
(0097) 	RELAY_OFF();delayms(100);
    02562 98AD      CBI	0x15,5
    02563 E604      LDI	R16,0x64
    02564 E010      LDI	R17,0
    02565 940E 240B CALL	_delayms
(0098) 	lp("  ");delayms(500);
    02567 E003      LDI	R16,3
    02568 E012      LDI	R17,2
    02569 940E 3C79 CALL	_lp
    0256B EF04      LDI	R16,0xF4
    0256C E011      LDI	R17,1
    0256D 940E 240B CALL	_delayms
(0099) 	lp("完成自检");delayms(500);
    0256F EF0A      LDI	R16,0xFA
    02570 E011      LDI	R17,1
    02571 940E 3C79 CALL	_lp
    02573 EF04      LDI	R16,0xF4
    02574 E011      LDI	R17,1
    02575 940E 240B CALL	_delayms
    02577 9662      ADIW	R28,0x12
    02578 9508      RET
_WriteFileHead:
  fs                   --> Y,+177
  bw                   --> Y,+175
  fnamep               --> Y,+161
  itam                 --> Y,+38
  file                 --> Y,+4
  res                  --> R10
    02579 940E 4117 CALL	push_xgset003C
    0257B 97EF      SBIW	R28,0x3F
    0257C 97EF      SBIW	R28,0x3F
    0257D 97EF      SBIW	R28,0x3F
    0257E 97EF      SBIW	R28,0x3F
    0257F 97EF      SBIW	R28,0x3F
    02580 97EF      SBIW	R28,0x3F
    02581 97EF      SBIW	R28,0x3F
    02582 97EF      SBIW	R28,0x3F
    02583 97EF      SBIW	R28,0x3F
    02584 97EF      SBIW	R28,0x3F
    02585 97EF      SBIW	R28,0x3F
    02586 97AA      SBIW	R28,0x2A
(0100) 	  
(0101) }
(0102) void WriteFileHead(void)   
(0103) {
(0104)  	 unsigned int bw;
(0105) 	 FRESULT res;
(0106) 	 FATFS fs;
(0107) 	 FIL file;
(0108) 	 char fnamep[]="201201.xls\0\0\0"; 
    02587 E287      LDI	R24,0x27
    02588 E091      LDI	R25,1
    02589 01FE      MOVW	R30,R28
    0258A 55EF      SUBI	R30,0x5F
    0258B 4FFF      SBCI	R31,0xFF
    0258C E00E      LDI	R16,0xE
    0258D E010      LDI	R17,0
    0258E 93FA      ST	-Y,R31
    0258F 93EA      ST	-Y,R30
    02590 939A      ST	-Y,R25
    02591 938A      ST	-Y,R24
    02592 940E 41B8 CALL	asgnblk
(0109) 	 UINT8 itam[]="DEV000001\t\t\t\t\t\t\t\t\t\t\r\n序号\t日期\t时分\t温度\t风速\t风冷指数\t等价制冷温度\t相当温度\t冻伤危害性\t安静作业\t中等强度作业\t高强度作业\n\0";
    02594 E385      LDI	R24,0x35
    02595 E091      LDI	R25,1
    02596 01FE      MOVW	R30,R28
    02597 96B6      ADIW	R30,0x26
    02598 E70B      LDI	R16,0x7B
    02599 E010      LDI	R17,0
    0259A 93FA      ST	-Y,R31
    0259B 93EA      ST	-Y,R30
    0259C 939A      ST	-Y,R25
    0259D 938A      ST	-Y,R24
    0259E 940E 41B8 CALL	asgnblk
(0110) 	 res=disk_initialize(0);
    025A0 2700      CLR	R16
    025A1 940E 0291 CALL	_disk_initialize
    025A3 2EA0      MOV	R10,R16
(0111) 	 #ifdef _DEBUG
(0112) 	 debug("dinit",res);
    025A4 2D2A      MOV	R18,R10
    025A5 EF04      LDI	R16,0xF4
    025A6 E011      LDI	R17,1
    025A7 D577      RCALL	_debug
(0113) 	 #endif
(0114) 	 res = f_mount(0, &fs);
    025A8 019E      MOVW	R18,R28
    025A9 542F      SUBI	R18,0x4F
    025AA 4F3F      SBCI	R19,0xFF
    025AB 2700      CLR	R16
    025AC 940E 167D CALL	_f_mount
    025AE 2EA0      MOV	R10,R16
(0115) 	 #ifdef _DEBUG
(0116)  	 debug("dmnt",res);
    025AF 2D2A      MOV	R18,R10
    025B0 EE0F      LDI	R16,0xEF
    025B1 E011      LDI	R17,1
    025B2 D56C      RCALL	_debug
(0117) 	 #endif
(0118) 	 //get_name(fnamep)
(0119) 	 res = f_open(&file, get_name(fnamep) , FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    025B3 018E      MOVW	R16,R28
    025B4 550F      SUBI	R16,0x5F
    025B5 4F1F      SBCI	R17,0xFF
    025B6 D48D      RCALL	_get_name
    025B7 0168      MOVW	R12,R16
    025B8 E182      LDI	R24,0x12
    025B9 8388      ST	Y,R24
    025BA 0196      MOVW	R18,R12
    025BB 018E      MOVW	R16,R28
    025BC 5F0C      SUBI	R16,0xFC
    025BD 4F1F      SBCI	R17,0xFF
    025BE 940E 16A8 CALL	_f_open
    025C0 2EC0      MOV	R12,R16
    025C1 2CAC      MOV	R10,R12
(0120) 	 #ifdef _DEBUG
(0121) 	 debug("fopen",res);
    025C2 2D2A      MOV	R18,R10
    025C3 EE09      LDI	R16,0xE9
    025C4 E011      LDI	R17,1
    025C5 D559      RCALL	_debug
(0122) 	 #endif
(0123) 	 res = f_write(&file,itam,sizeof(itam),&bw);   //bw 已写入字节数
    025C6 01CE      MOVW	R24,R28
    025C7 5581      SUBI	R24,0x51
    025C8 4F9F      SBCI	R25,0xFF
    025C9 839B      STD	Y+3,R25
    025CA 838A      STD	Y+2,R24
    025CB E78B      LDI	R24,0x7B
    025CC E090      LDI	R25,0
    025CD 8399      STD	Y+1,R25
    025CE 8388      ST	Y,R24
    025CF 019E      MOVW	R18,R28
    025D0 5D2A      SUBI	R18,0xDA
    025D1 4F3F      SBCI	R19,0xFF
    025D2 018E      MOVW	R16,R28
    025D3 5F0C      SUBI	R16,0xFC
    025D4 4F1F      SBCI	R17,0xFF
    025D5 940E 1AAF CALL	_f_write
    025D7 2EC0      MOV	R12,R16
    025D8 2CAC      MOV	R10,R12
(0124) 	 #ifdef _DEBUG
(0125) 	 debug("fwrite",res);
    025D9 2D2A      MOV	R18,R10
    025DA EE02      LDI	R16,0xE2
    025DB E011      LDI	R17,1
    025DC D542      RCALL	_debug
(0126) 	 #endif
(0127) 	 f_close(&file);
    025DD 018E      MOVW	R16,R28
    025DE 5F0C      SUBI	R16,0xFC
    025DF 4F1F      SBCI	R17,0xFF
    025E0 940E 1E79 CALL	_f_close
(0128) 	 f_mount(0, NULL);
    025E2 2722      CLR	R18
    025E3 2733      CLR	R19
    025E4 2700      CLR	R16
    025E5 940E 167D CALL	_f_mount
    025E7 96EF      ADIW	R28,0x3F
    025E8 96EF      ADIW	R28,0x3F
    025E9 96EF      ADIW	R28,0x3F
    025EA 96EF      ADIW	R28,0x3F
    025EB 96EF      ADIW	R28,0x3F
    025EC 96EF      ADIW	R28,0x3F
    025ED 96EF      ADIW	R28,0x3F
    025EE 96EF      ADIW	R28,0x3F
    025EF 96EF      ADIW	R28,0x3F
    025F0 96EF      ADIW	R28,0x3F
    025F1 96EF      ADIW	R28,0x3F
    025F2 96AA      ADIW	R28,0x2A
    025F3 940C 40F1 JMP	pop_xgset003C
_WriteSDFile:
  fnamep               --> Y,+602
  fs                   --> Y,+44
  bw                   --> Y,+42
  lenth                --> Y,+38
  res                  --> R10
  file                 --> Y,+4
    025F5 92AA      ST	-Y,R10
    025F6 92CA      ST	-Y,R12
    025F7 97EF      SBIW	R28,0x3F
    025F8 97EF      SBIW	R28,0x3F
    025F9 97EF      SBIW	R28,0x3F
    025FA 97EF      SBIW	R28,0x3F
    025FB 97EF      SBIW	R28,0x3F
    025FC 97EF      SBIW	R28,0x3F
    025FD 97EF      SBIW	R28,0x3F
    025FE 97EF      SBIW	R28,0x3F
    025FF 97EF      SBIW	R28,0x3F
    02600 97E0      SBIW	R28,0x30
(0129) } /////////////////////////////////////////////////
(0130) //       写入文件函数 
(0131) //(创建)打开文件 
(0132) // data 指向欲写入的的字符串 64byt 
(0133) //////////////////////////////////////////////// 
(0134) void WriteSDFile(void)   
(0135) {
(0136)     unsigned int bw;
(0137) 	FRESULT res;
(0138) 	FATFS fs;
(0139)     FIL file;
(0140) 	char fnamep[13];
(0141) 	long lenth=0;
    02601 E080      LDI	R24,0
    02602 A38E      STD	Y+38,R24
    02603 A38F      STD	Y+39,R24
    02604 A788      STD	Y+40,R24
    02605 A789      STD	Y+41,R24
(0142) 	disk_initialize(0);
    02606 2700      CLR	R16
    02607 940E 0291 CALL	_disk_initialize
(0143) 	res = f_mount(0, &fs);
    02609 019E      MOVW	R18,R28
    0260A 5D24      SUBI	R18,0xD4
    0260B 4F3F      SBCI	R19,0xFF
    0260C 2700      CLR	R16
    0260D 940E 167D CALL	_f_mount
(0144) 	res = f_open(&file,get_name(fnamep), FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    0260F 018E      MOVW	R16,R28
    02610 5A06      SUBI	R16,0xA6
    02611 4F1D      SBCI	R17,0xFD
    02612 D431      RCALL	_get_name
    02613 E182      LDI	R24,0x12
    02614 8388      ST	Y,R24
    02615 0198      MOVW	R18,R16
    02616 018E      MOVW	R16,R28
    02617 5F0C      SUBI	R16,0xFC
    02618 4F1F      SBCI	R17,0xFF
    02619 940E 16A8 CALL	_f_open
(0145) 	lenth=file.fsize;   
    0261B 842E      LDD	R2,Y+14
    0261C 843F      LDD	R3,Y+15
    0261D 8848      LDD	R4,Y+16
    0261E 8859      LDD	R5,Y+17
    0261F A22E      STD	Y+38,R2
    02620 A23F      STD	Y+39,R3
    02621 A648      STD	Y+40,R4
    02622 A659      STD	Y+41,R5
(0146) 	res = f_lseek (&file,lenth);	 
    02623 A02E      LDD	R2,Y+38
    02624 A03F      LDD	R3,Y+39
    02625 A448      LDD	R4,Y+40
    02626 A459      LDD	R5,Y+41
    02627 8248      ST	Y,R4
    02628 8259      STD	Y+1,R5
    02629 0191      MOVW	R18,R2
    0262A 018E      MOVW	R16,R28
    0262B 5F0C      SUBI	R16,0xFC
    0262C 4F1F      SBCI	R17,0xFF
    0262D 940E 1E89 CALL	_f_lseek
(0147) 	res = f_write(&file,TempChar,64,&bw);   //bw 已写入字节数
    0262F 01CE      MOVW	R24,R28
    02630 968A      ADIW	R24,0x2A
    02631 839B      STD	Y+3,R25
    02632 838A      STD	Y+2,R24
    02633 E480      LDI	R24,0x40
    02634 E090      LDI	R25,0
    02635 8399      STD	Y+1,R25
    02636 8388      ST	Y,R24
    02637 E02F      LDI	R18,0xF
    02638 E035      LDI	R19,5
    02639 018E      MOVW	R16,R28
    0263A 5F0C      SUBI	R16,0xFC
    0263B 4F1F      SBCI	R17,0xFF
    0263C 940E 1AAF CALL	_f_write
    0263E 2EC0      MOV	R12,R16
    0263F 2CAC      MOV	R10,R12
(0148) 	f_close(&file);
    02640 018E      MOVW	R16,R28
    02641 5F0C      SUBI	R16,0xFC
    02642 4F1F      SBCI	R17,0xFF
    02643 940E 1E79 CALL	_f_close
(0149) 	f_mount(0, NULL);
    02645 2722      CLR	R18
    02646 2733      CLR	R19
    02647 2700      CLR	R16
    02648 940E 167D CALL	_f_mount
    0264A 96EF      ADIW	R28,0x3F
    0264B 96EF      ADIW	R28,0x3F
    0264C 96EF      ADIW	R28,0x3F
    0264D 96EF      ADIW	R28,0x3F
    0264E 96EF      ADIW	R28,0x3F
    0264F 96EF      ADIW	R28,0x3F
    02650 96EF      ADIW	R28,0x3F
    02651 96EF      ADIW	R28,0x3F
    02652 96EF      ADIW	R28,0x3F
    02653 96E0      ADIW	R28,0x30
    02654 90C9      LD	R12,Y+
    02655 90A9      LD	R10,Y+
    02656 9508      RET
_ReadSDFile:
  fs                   --> Y,+53
  bw                   --> Y,+51
  fnamep               --> Y,+38
  file                 --> Y,+4
  res                  --> R20
  data                 --> R10
  index                --> R22
    02657 940E 414C CALL	push_xgsetF03C
    02659 0159      MOVW	R10,R18
    0265A 01B8      MOVW	R22,R16
    0265B 97EF      SBIW	R28,0x3F
    0265C 97EF      SBIW	R28,0x3F
    0265D 97EF      SBIW	R28,0x3F
    0265E 97EF      SBIW	R28,0x3F
    0265F 97EF      SBIW	R28,0x3F
    02660 97EF      SBIW	R28,0x3F
    02661 97EF      SBIW	R28,0x3F
    02662 97EF      SBIW	R28,0x3F
    02663 97EF      SBIW	R28,0x3F
    02664 97AC      SBIW	R28,0x2C
(0150) }
(0151) /////////////////////////////////////////////////
(0152) //       读取文件函数
(0153) //以64byte为一块 读取
(0154) //index数据偏移量   data读出后存放地
(0155) //////////////////////////////////////////////// 
(0156) char ReadSDFile(unsigned int index,char *data)
(0157) {
(0158)  	unsigned int bw;
(0159) 	char res;
(0160) 	FATFS fs;
(0161)     FIL file;
(0162) 	char fnamep[13];
(0163)     get_name(fnamep); 
    02665 018E      MOVW	R16,R28
    02666 5D0A      SUBI	R16,0xDA
    02667 4F1F      SBCI	R17,0xFF
    02668 D3DB      RCALL	_get_name
(0164)     disk_initialize(0);
    02669 2700      CLR	R16
    0266A 940E 0291 CALL	_disk_initialize
(0165)     res = f_mount(0, &fs);
    0266C 019E      MOVW	R18,R28
    0266D 5C2B      SUBI	R18,0xCB
    0266E 4F3F      SBCI	R19,0xFF
    0266F 2700      CLR	R16
    02670 940E 167D CALL	_f_mount
(0166)     res = f_open(&file,fnamep,FA_READ);  
    02672 E081      LDI	R24,1
    02673 8388      ST	Y,R24
    02674 019E      MOVW	R18,R28
    02675 5D2A      SUBI	R18,0xDA
    02676 4F3F      SBCI	R19,0xFF
    02677 018E      MOVW	R16,R28
    02678 5F0C      SUBI	R16,0xFC
    02679 4F1F      SBCI	R17,0xFF
    0267A 940E 16A8 CALL	_f_open
    0267C 2F40      MOV	R20,R16
(0167)     if(res==FR_NO_FILE) {data=NULL;
    0267D 3004      CPI	R16,4
    0267E F419      BNE	0x2682
    0267F 24AA      CLR	R10
    02680 24BB      CLR	R11
(0168)     #if _debug >= 1 
(0169)     debug_out("now file",255);
(0170) 	debug_out(filename,res);
(0171) 	debug_out("file is no exist....",255);
(0172)     #endif 
(0173)     return res;
    02681 C02E      RJMP	0x26B0
(0174)     }   
(0175)     res = f_lseek (&file,(index+2)*64);	 //前两个字节数据为文件头空间 所以从第三块读/写起
    02682 019B      MOVW	R18,R22
    02683 5F2E      SUBI	R18,0xFE
    02684 4F3F      SBCI	R19,0xFF
    02685 E400      LDI	R16,0x40
    02686 E010      LDI	R17,0
    02687 940E 40AD CALL	empy16s
    02689 0118      MOVW	R2,R16
    0268A 2444      CLR	R4
    0268B 2455      CLR	R5
    0268C 8248      ST	Y,R4
    0268D 8259      STD	Y+1,R5
    0268E 0191      MOVW	R18,R2
    0268F 018E      MOVW	R16,R28
    02690 5F0C      SUBI	R16,0xFC
    02691 4F1F      SBCI	R17,0xFF
    02692 940E 1E89 CALL	_f_lseek
    02694 2EC0      MOV	R12,R16
(0176)     res = f_read(&file,data,64,&bw);
    02695 01CE      MOVW	R24,R28
    02696 96C3      ADIW	R24,0x33
    02697 839B      STD	Y+3,R25
    02698 838A      STD	Y+2,R24
    02699 E480      LDI	R24,0x40
    0269A E090      LDI	R25,0
    0269B 8399      STD	Y+1,R25
    0269C 8388      ST	Y,R24
    0269D 0195      MOVW	R18,R10
    0269E 018E      MOVW	R16,R28
    0269F 5F0C      SUBI	R16,0xFC
    026A0 4F1F      SBCI	R17,0xFF
    026A1 940E 1844 CALL	_f_read
    026A3 2EA0      MOV	R10,R16
    026A4 2D4A      MOV	R20,R10
(0177)     f_close(&file);
    026A5 018E      MOVW	R16,R28
    026A6 5F0C      SUBI	R16,0xFC
    026A7 4F1F      SBCI	R17,0xFF
    026A8 940E 1E79 CALL	_f_close
(0178) 	f_mount(0, NULL);
    026AA 2722      CLR	R18
    026AB 2733      CLR	R19
    026AC 2700      CLR	R16
    026AD 940E 167D CALL	_f_mount
(0179) 	return res;
    026AF 2F04      MOV	R16,R20
    026B0 96EF      ADIW	R28,0x3F
    026B1 96EF      ADIW	R28,0x3F
    026B2 96EF      ADIW	R28,0x3F
    026B3 96EF      ADIW	R28,0x3F
    026B4 96EF      ADIW	R28,0x3F
    026B5 96EF      ADIW	R28,0x3F
    026B6 96EF      ADIW	R28,0x3F
    026B7 96EF      ADIW	R28,0x3F
    026B8 96EF      ADIW	R28,0x3F
    026B9 96AC      ADIW	R28,0x2C
    026BA 940C 4155 JMP	pop_xgsetF03C
_findIndex:
  fs                   --> Y,+48
  bw                   --> Y,+46
  fnamep               --> R14
  readsize             --> R10
  res                  --> R12
  file                 --> Y,+12
  lenth                --> Y,+8
  index                --> Y,+4
  is_first_end         --> Y,+606
  tmp                  --> R10
  buf                  --> Y,+617
  filename             --> R10
    026BC 933A      ST	-Y,R19
    026BD 932A      ST	-Y,R18
    026BE 940E 4111 CALL	push_xgsetF0FC
    026C0 0158      MOVW	R10,R16
    026C1 97EF      SBIW	R28,0x3F
    026C2 97EF      SBIW	R28,0x3F
    026C3 97EF      SBIW	R28,0x3F
    026C4 97EF      SBIW	R28,0x3F
    026C5 97EF      SBIW	R28,0x3F
    026C6 97EF      SBIW	R28,0x3F
    026C7 97EF      SBIW	R28,0x3F
    026C8 97EF      SBIW	R28,0x3F
    026C9 97EF      SBIW	R28,0x3F
    026CA 97A8      SBIW	R28,0x28
(0180) } 
(0181) //////////////////////////////////
(0182) //   find index
(0183) // 检查当前文件尺寸，根据倒数第二个
(0184) //'\n'及其后面的index确定当前index值
(0185) //////////////////////////////////
(0186) unsigned int findIndex(char *filename,char *buf){
(0187)     unsigned int bw,tmp;
(0188) 	long index =0;
    026CB E080      LDI	R24,0
    026CC 838C      STD	Y+4,R24
    026CD 838D      STD	Y+5,R24
    026CE 838E      STD	Y+6,R24
    026CF 838F      STD	Y+7,R24
(0189) 	unsigned char is_first_end=0;
    026D0 2400      CLR	R0
    026D1 01DE      MOVW	R26,R28
    026D2 5AA2      SUBI	R26,0xA2
    026D3 4FBD      SBCI	R27,0xFD
    026D4 920C      ST	X,R0
(0190) 	char *fnamep=filename;
    026D5 0175      MOVW	R14,R10
(0191) 	FRESULT res;
(0192) 	FATFS fs;
(0193) 	FIL file;
(0194) 	long lenth=0;
    026D6 E080      LDI	R24,0
    026D7 8788      STD	Y+8,R24
    026D8 8789      STD	Y+9,R24
    026D9 878A      STD	Y+10,R24
    026DA 878B      STD	Y+11,R24
(0195) 	int readsize=0;
    026DB 24AA      CLR	R10
    026DC 24BB      CLR	R11
(0196) 	//PrintString_n(fnamep);
(0197) 	res = f_mount(0, &fs);
    026DD 019E      MOVW	R18,R28
    026DE 5D20      SUBI	R18,0xD0
    026DF 4F3F      SBCI	R19,0xFF
    026E0 2700      CLR	R16
    026E1 940E 167D CALL	_f_mount
(0198) 	res = f_open(&file,fnamep, FA_OPEN_ALWAYS | FA_READ );  //创建一个新的文件
    026E3 E181      LDI	R24,0x11
    026E4 8388      ST	Y,R24
    026E5 0197      MOVW	R18,R14
    026E6 018E      MOVW	R16,R28
    026E7 5F04      SUBI	R16,0xF4
    026E8 4F1F      SBCI	R17,0xFF
    026E9 940E 16A8 CALL	_f_open
    026EB 2EC0      MOV	R12,R16
(0199) 	if(res !=  FR_OK){ //openerror
    026EC 2300      TST	R16
    026ED F011      BEQ	0x26F0
(0200) 	    return res;}
    026EE 2711      CLR	R17
    026EF C11E      RJMP	0x280E
(0201) 	lenth=file.fsize;   //文件尾部为 file.size 
    026F0 882E      LDD	R2,Y+22
    026F1 883F      LDD	R3,Y+23
    026F2 8C48      LDD	R4,Y+24
    026F3 8C59      LDD	R5,Y+25
    026F4 8628      STD	Y+8,R2
    026F5 8639      STD	Y+9,R3
    026F6 864A      STD	Y+10,R4
    026F7 865B      STD	Y+11,R5
(0202) 	//debug("size=",0xff);
(0203) 	//PrintLong(lenth);
(0204) 	if(lenth > 512) {
    026F8 E040      LDI	R20,0
    026F9 E052      LDI	R21,2
    026FA E060      LDI	R22,0
    026FB E070      LDI	R23,0
    026FC 8428      LDD	R2,Y+8
    026FD 8439      LDD	R3,Y+9
    026FE 844A      LDD	R4,Y+10
    026FF 845B      LDD	R5,Y+11
    02700 1542      CP	R20,R2
    02701 0553      CPC	R21,R3
    02702 0564      CPC	R22,R4
    02703 0575      CPC	R23,R5
    02704 F464      BGE	0x2711
(0205) 	    readsize=512;
    02705 E080      LDI	R24,0
    02706 E092      LDI	R25,2
    02707 015C      MOVW	R10,R24
(0206) 		lenth=file.fsize;
    02708 882E      LDD	R2,Y+22
    02709 883F      LDD	R3,Y+23
    0270A 8C48      LDD	R4,Y+24
    0270B 8C59      LDD	R5,Y+25
    0270C 8628      STD	Y+8,R2
    0270D 8639      STD	Y+9,R3
    0270E 864A      STD	Y+10,R4
    0270F 865B      STD	Y+11,R5
(0207) 	}
    02710 C007      RJMP	0x2718
(0208) 	else {
(0209) 	    readsize =file.fsize;
    02711 88AE      LDD	R10,Y+22
    02712 88BF      LDD	R11,Y+23
(0210) 		lenth=0;
    02713 E080      LDI	R24,0
    02714 8788      STD	Y+8,R24
    02715 8789      STD	Y+9,R24
    02716 878A      STD	Y+10,R24
    02717 878B      STD	Y+11,R24
(0211) 	}
(0212) 	res = f_lseek (&file,file.fsize-readsize);
    02718 0115      MOVW	R2,R10
    02719 2444      CLR	R4
    0271A FC37      SBRC	R3,7
    0271B 9440      COM	R4
    0271C 2455      CLR	R5
    0271D FC47      SBRC	R4,7
    0271E 9450      COM	R5
    0271F 886E      LDD	R6,Y+22
    02720 887F      LDD	R7,Y+23
    02721 8C88      LDD	R8,Y+24
    02722 8C99      LDD	R9,Y+25
    02723 1862      SUB	R6,R2
    02724 0873      SBC	R7,R3
    02725 0884      SBC	R8,R4
    02726 0895      SBC	R9,R5
    02727 8288      ST	Y,R8
    02728 8299      STD	Y+1,R9
    02729 0193      MOVW	R18,R6
    0272A 018E      MOVW	R16,R28
    0272B 5F04      SUBI	R16,0xF4
    0272C 4F1F      SBCI	R17,0xFF
    0272D 940E 1E89 CALL	_f_lseek
(0213) 	//debug("readSIZE=",0x00);
(0214) 	//PrintLong((file.fsize-readsize));
(0215) 	res = f_read(&file,buf,readsize,&bw);
    0272F 01CE      MOVW	R24,R28
    02730 968E      ADIW	R24,0x2E
    02731 839B      STD	Y+3,R25
    02732 838A      STD	Y+2,R24
    02733 82B9      STD	Y+1,R11
    02734 82A8      ST	Y,R10
    02735 01FE      MOVW	R30,R28
    02736 59E7      SUBI	R30,0x97
    02737 4FFD      SBCI	R31,0xFD
    02738 8120      LD	R18,Z
    02739 8131      LDD	R19,Z+1
    0273A 018E      MOVW	R16,R28
    0273B 5F04      SUBI	R16,0xF4
    0273C 4F1F      SBCI	R17,0xFF
    0273D 940E 1844 CALL	_f_read
    0273F 2EE0      MOV	R14,R16
    02740 2CCE      MOV	R12,R14
(0216) 	f_close(&file);
    02741 018E      MOVW	R16,R28
    02742 5F04      SUBI	R16,0xF4
    02743 4F1F      SBCI	R17,0xFF
    02744 940E 1E79 CALL	_f_close
(0217) 	//debug("readRES=",res);
(0218) 	//debug("readbw=",0X00);
(0219) 	//PrintLong(bw);
(0220) 	//PrintString_n(buf);
(0221) 	for(tmp=readsize;tmp>0;tmp--){
    02746 C04E      RJMP	0x2795
(0222) 		//debug("buf index",buf[tmp]);
(0223) 		//PrintLong(tmp);
(0224) 		if(buf[tmp] == '\n') Usart_Transmit('@');						  
    02747 01F5      MOVW	R30,R10
    02748 01DE      MOVW	R26,R28
    02749 59A7      SUBI	R26,0x97
    0274A 4FBD      SBCI	R27,0xFD
    0274B 900D      LD	R0,X+
    0274C 901C      LD	R1,X
    0274D 0DE0      ADD	R30,R0
    0274E 1DF1      ADC	R31,R1
    0274F 8180      LD	R24,Z
    02750 308A      CPI	R24,0xA
    02751 F419      BNE	0x2755
    02752 E400      LDI	R16,0x40
    02753 940E 3770 CALL	_Usart_Transmit
(0225) 		if(buf[tmp] == '\n' && is_first_end== 0){
    02755 01F5      MOVW	R30,R10
    02756 01DE      MOVW	R26,R28
    02757 59A7      SUBI	R26,0x97
    02758 4FBD      SBCI	R27,0xFD
    02759 900D      LD	R0,X+
    0275A 901C      LD	R1,X
    0275B 0DE0      ADD	R30,R0
    0275C 1DF1      ADC	R31,R1
    0275D 8180      LD	R24,Z
    0275E 308A      CPI	R24,0xA
    0275F F469      BNE	0x276D
    02760 01FE      MOVW	R30,R28
    02761 5AE2      SUBI	R30,0xA2
    02762 4FFD      SBCI	R31,0xFD
    02763 8000      LD	R0,Z
    02764 2000      TST	R0
    02765 F439      BNE	0x276D
(0226) 		    is_first_end=1; 	
    02766 2400      CLR	R0
    02767 9403      INC	R0
    02768 01FE      MOVW	R30,R28
    02769 5AE2      SUBI	R30,0xA2
    0276A 4FFD      SBCI	R31,0xFD
    0276B 8200      ST	Z,R0
(0227) 			//debug("first=",0xf0);					      
(0228) 		}
    0276C C025      RJMP	0x2792
(0229) 		else if(buf[tmp] == '\n' && is_first_end== 1){
    0276D 01F5      MOVW	R30,R10
    0276E 01DE      MOVW	R26,R28
    0276F 59A7      SUBI	R26,0x97
    02770 4FBD      SBCI	R27,0xFD
    02771 900D      LD	R0,X+
    02772 901C      LD	R1,X
    02773 0DE0      ADD	R30,R0
    02774 1DF1      ADC	R31,R1
    02775 8180      LD	R24,Z
    02776 308A      CPI	R24,0xA
    02777 F4D1      BNE	0x2792
    02778 01DE      MOVW	R26,R28
    02779 5AA2      SUBI	R26,0xA2
    0277A 4FBD      SBCI	R27,0xFD
    0277B 918C      LD	R24,X
    0277C 3081      CPI	R24,1
    0277D F4A1      BNE	0x2792
(0230) 		    lenth -= (512-tmp);
    0277E E080      LDI	R24,0
    0277F E092      LDI	R25,2
    02780 011C      MOVW	R2,R24
    02781 182A      SUB	R2,R10
    02782 083B      SBC	R3,R11
    02783 2444      CLR	R4
    02784 2455      CLR	R5
    02785 8468      LDD	R6,Y+8
    02786 8479      LDD	R7,Y+9
    02787 848A      LDD	R8,Y+10
    02788 849B      LDD	R9,Y+11
    02789 1862      SUB	R6,R2
    0278A 0873      SBC	R7,R3
    0278B 0884      SBC	R8,R4
    0278C 0895      SBC	R9,R5
    0278D 8668      STD	Y+8,R6
    0278E 8679      STD	Y+9,R7
    0278F 868A      STD	Y+10,R8
    02790 869B      STD	Y+11,R9
(0231) 			break;
    02791 C009      RJMP	0x279B
    02792 01C5      MOVW	R24,R10
    02793 9701      SBIW	R24,1
    02794 015C      MOVW	R10,R24
    02795 20AA      TST	R10
    02796 F009      BEQ	0x2798
    02797 CFAF      RJMP	0x2747
    02798 20BB      TST	R11
    02799 F009      BEQ	0x279B
    0279A CFAC      RJMP	0x2747
(0232) 		} 						
(0233) 	}
(0234) 	//debug("start=",0X00); PrintLong(lenth);
(0235) 	if(lenth < 118 ){ 
    0279B E746      LDI	R20,0x76
    0279C E050      LDI	R21,0
    0279D E060      LDI	R22,0
    0279E E070      LDI	R23,0
    0279F 8428      LDD	R2,Y+8
    027A0 8439      LDD	R3,Y+9
    027A1 844A      LDD	R4,Y+10
    027A2 845B      LDD	R5,Y+11
    027A3 1624      CP	R2,R20
    027A4 0635      CPC	R3,R21
    027A5 0646      CPC	R4,R22
    027A6 0657      CPC	R5,R23
    027A7 F434      BGE	0x27AE
(0236)  		return 1;
    027A8 E001      LDI	R16,1
    027A9 E010      LDI	R17,0
    027AA C063      RJMP	0x280E
(0237) 	}
(0238) 	else {
(0239) 		 //debug(">128 ",0X00);
(0240) 		 while(buf[tmp] <= '0' || buf[tmp] >= '9') tmp++;
    027AB 01C5      MOVW	R24,R10
    027AC 9601      ADIW	R24,1
    027AD 015C      MOVW	R10,R24
    027AE 01F5      MOVW	R30,R10
    027AF 01DE      MOVW	R26,R28
    027B0 59A7      SUBI	R26,0x97
    027B1 4FBD      SBCI	R27,0xFD
    027B2 900D      LD	R0,X+
    027B3 901C      LD	R1,X
    027B4 0DE0      ADD	R30,R0
    027B5 1DF1      ADC	R31,R1
    027B6 80E0      LD	R14,Z
    027B7 24FF      CLR	R15
    027B8 E380      LDI	R24,0x30
    027B9 158E      CP	R24,R14
    027BA F780      BCC	0x27AB
    027BB 2D8E      MOV	R24,R14
    027BC 3389      CPI	R24,0x39
    027BD F768      BCC	0x27AB
    027BE C02F      RJMP	0x27EE
(0241) 		 //debug("nozero ",bw); PrintLong(tmp);
(0242) 		 while(buf[tmp] != 't' && buf[tmp] >= '0' && buf[tmp] <= '9'){
(0243) 		     index=index*10+(buf[tmp]-'0');
    027BF 01F5      MOVW	R30,R10
    027C0 01DE      MOVW	R26,R28
    027C1 59A7      SUBI	R26,0x97
    027C2 4FBD      SBCI	R27,0xFD
    027C3 900D      LD	R0,X+
    027C4 901C      LD	R1,X
    027C5 0DE0      ADD	R30,R0
    027C6 1DF1      ADC	R31,R1
    027C7 8180      LD	R24,Z
    027C8 2799      CLR	R25
    027C9 97C0      SBIW	R24,0x30
    027CA 011C      MOVW	R2,R24
    027CB 2444      CLR	R4
    027CC FC37      SBRC	R3,7
    027CD 9440      COM	R4
    027CE 2455      CLR	R5
    027CF FC47      SBRC	R4,7
    027D0 9450      COM	R5
    027D1 806C      LDD	R6,Y+4
    027D2 807D      LDD	R7,Y+5
    027D3 808E      LDD	R8,Y+6
    027D4 809F      LDD	R9,Y+7
    027D5 E04A      LDI	R20,0xA
    027D6 E050      LDI	R21,0
    027D7 E060      LDI	R22,0
    027D8 E070      LDI	R23,0
    027D9 929A      ST	-Y,R9
    027DA 928A      ST	-Y,R8
    027DB 927A      ST	-Y,R7
    027DC 926A      ST	-Y,R6
    027DD 018A      MOVW	R16,R20
    027DE 019B      MOVW	R18,R22
    027DF 940E 40BD CALL	empy32u|empy32s
    027E1 0138      MOVW	R6,R16
    027E2 0149      MOVW	R8,R18
    027E3 0C62      ADD	R6,R2
    027E4 1C73      ADC	R7,R3
    027E5 1C84      ADC	R8,R4
    027E6 1C95      ADC	R9,R5
    027E7 826C      STD	Y+4,R6
    027E8 827D      STD	Y+5,R7
    027E9 828E      STD	Y+6,R8
    027EA 829F      STD	Y+7,R9
(0244) 		 	 //Usart_Transmit(buf[tmp]);	
(0245) 		 	 tmp++;
    027EB 01C5      MOVW	R24,R10
    027EC 9601      ADIW	R24,1
    027ED 015C      MOVW	R10,R24
    027EE 01F5      MOVW	R30,R10
    027EF 01DE      MOVW	R26,R28
    027F0 59A7      SUBI	R26,0x97
    027F1 4FBD      SBCI	R27,0xFD
    027F2 900D      LD	R0,X+
    027F3 901C      LD	R1,X
    027F4 0DE0      ADD	R30,R0
    027F5 1DF1      ADC	R31,R1
    027F6 80E0      LD	R14,Z
    027F7 24FF      CLR	R15
    027F8 2D8E      MOV	R24,R14
    027F9 3784      CPI	R24,0x74
    027FA F031      BEQ	0x2801
    027FB 3380      CPI	R24,0x30
    027FC F020      BCS	0x2801
    027FD E389      LDI	R24,0x39
    027FE 158E      CP	R24,R14
    027FF F008      BCS	0x2801
    02800 CFBE      RJMP	0x27BF
(0246) 		 }
(0247) 	}
(0248) 	//debug("index=",0X00);
(0249) 	//PrintLong(index+1);
(0250) 	return index+1;
    02801 E041      LDI	R20,1
    02802 E050      LDI	R21,0
    02803 E060      LDI	R22,0
    02804 E070      LDI	R23,0
    02805 802C      LDD	R2,Y+4
    02806 803D      LDD	R3,Y+5
    02807 804E      LDD	R4,Y+6
    02808 805F      LDD	R5,Y+7
    02809 0E24      ADD	R2,R20
    0280A 1E35      ADC	R3,R21
    0280B 1E46      ADC	R4,R22
    0280C 1E57      ADC	R5,R23
    0280D 0181      MOVW	R16,R2
    0280E 96EF      ADIW	R28,0x3F
    0280F 96EF      ADIW	R28,0x3F
    02810 96EF      ADIW	R28,0x3F
    02811 96EF      ADIW	R28,0x3F
    02812 96EF      ADIW	R28,0x3F
    02813 96EF      ADIW	R28,0x3F
    02814 96EF      ADIW	R28,0x3F
    02815 96EF      ADIW	R28,0x3F
    02816 96EF      ADIW	R28,0x3F
    02817 96A8      ADIW	R28,0x28
    02818 940E 4106 CALL	pop_xgsetF0FC
    0281A 9622      ADIW	R28,2
    0281B 9508      RET
_check:
  WScounter            --> R10
  tmp                  --> R12
    0281C 940E 4117 CALL	push_xgset003C
    0281E 9722      SBIW	R28,2
(0251) }
(0252) void check( void )
(0253) {
(0254)  unsigned char tmp;
(0255)  unsigned int WScounter;
(0256)  //检测风速
(0257)  //读计数器1 此步需严格按手册进行。
(0258)  tmp=SREG;
    0281F B6CF      IN	R12,0x3F
(0259)  CLI();
    02820 94F8      BCLR	7
(0260)  WScounter=TCNT1H*256+TCNT1L;
    02821 B52D      IN	R18,0x2D
    02822 2733      CLR	R19
    02823 E000      LDI	R16,0
    02824 E011      LDI	R17,1
    02825 940E 40AD CALL	empy16s
    02827 0158      MOVW	R10,R16
    02828 B42C      IN	R2,0x2C
    02829 2433      CLR	R3
    0282A 0CA2      ADD	R10,R2
    0282B 1CB3      ADC	R11,R3
(0261)  SREG=tmp;
    0282C BECF      OUT	0x3F,R12
(0262)  SEI();
    0282D 9478      BSET	7
(0263)  //计算风速
(0264)  Result.WindSpeed=WScounter/N_per_Second;
    0282E 0185      MOVW	R16,R10
    0282F 940E 426B CALL	uint2fp
    02831 0118      MOVW	R2,R16
    02832 0129      MOVW	R4,R18
    02833 EB00      LDI	R16,0xB0
    02834 E010      LDI	R17,0
    02835 940E 4099 CALL	elpm32
    02837 933A      ST	-Y,R19
    02838 932A      ST	-Y,R18
    02839 931A      ST	-Y,R17
    0283A 930A      ST	-Y,R16
    0283B 0181      MOVW	R16,R2
    0283C 0192      MOVW	R18,R4
    0283D 940E 4298 CALL	fpdiv2
    0283F 9310 0593 STS	Result+52,R17
    02841 9300 0592 STS	Result+51,R16
    02843 9330 0595 STS	Result+54,R19
    02845 9320 0594 STS	Result+53,R18
(0265)  //温度
(0266)  Result.Temperature=read_T_NUM(1);
    02847 E001      LDI	R16,1
    02848 940E 3EAC CALL	_read_T_NUM
    0284A 9310 0589 STS	Result+42,R17
    0284C 9300 0588 STS	Result+41,R16
    0284E 9330 058B STS	Result+44,R19
    02850 9320 058A STS	Result+43,R18
(0267)  //WCI风冷指数
(0268)   Result.WCI = 4.18 *(10*SquareRootFloat(Result.WindSpeed) + 10.45 -  Result.WindSpeed  ) *( 33 - Result.Temperature );
    02852 9120 0594 LDS	R18,Result+53
    02854 9130 0595 LDS	R19,Result+54
    02856 9100 0592 LDS	R16,Result+51
    02858 9110 0593 LDS	R17,Result+52
    0285A D228      RCALL	_SquareRootFloat
    0285B 0118      MOVW	R2,R16
    0285C 0129      MOVW	R4,R18
    0285D EA0C      LDI	R16,0xAC
    0285E E010      LDI	R17,0
    0285F 940E 4099 CALL	elpm32
    02861 0138      MOVW	R6,R16
    02862 0149      MOVW	R8,R18
    02863 EA08      LDI	R16,0xA8
    02864 E010      LDI	R17,0
    02865 940E 4099 CALL	elpm32
    02867 925A      ST	-Y,R5
    02868 924A      ST	-Y,R4
    02869 923A      ST	-Y,R3
    0286A 922A      ST	-Y,R2
    0286B 940E 4412 CALL	fpmule2
    0286D 0118      MOVW	R2,R16
    0286E 0129      MOVW	R4,R18
    0286F EA04      LDI	R16,0xA4
    02870 E010      LDI	R17,0
    02871 940E 4099 CALL	elpm32
    02873 933A      ST	-Y,R19
    02874 932A      ST	-Y,R18
    02875 931A      ST	-Y,R17
    02876 930A      ST	-Y,R16
    02877 0181      MOVW	R16,R2
    02878 0192      MOVW	R18,R4
    02879 940E 423A CALL	fpadd2
    0287B E982      LDI	R24,0x92
    0287C E095      LDI	R25,5
    0287D 939A      ST	-Y,R25
    0287E 938A      ST	-Y,R24
    0287F 940E 4250 CALL	fpsub1x
    02881 0183      MOVW	R16,R6
    02882 0194      MOVW	R18,R8
    02883 940E 4412 CALL	fpmule2
    02885 0118      MOVW	R2,R16
    02886 0129      MOVW	R4,R18
    02887 EA00      LDI	R16,0xA0
    02888 E010      LDI	R17,0
    02889 940E 4099 CALL	elpm32
    0288B E888      LDI	R24,0x88
    0288C E095      LDI	R25,5
    0288D 939A      ST	-Y,R25
    0288E 938A      ST	-Y,R24
    0288F 940E 4250 CALL	fpsub1x
    02891 0181      MOVW	R16,R2
    02892 0192      MOVW	R18,R4
    02893 940E 4412 CALL	fpmule2
    02895 9310 059C STS	Result+61,R17
    02897 9300 059B STS	Result+60,R16
    02899 9330 059E STS	Result+63,R19
    0289B 9320 059D STS	Result+62,R18
(0269)  //ECT等价制冷温度
(0270)  Result.ECT = 33 - 0.01085 * Result.WCI;
    0289D E90C      LDI	R16,0x9C
    0289E E010      LDI	R17,0
    0289F 940E 4099 CALL	elpm32
    028A1 0118      MOVW	R2,R16
    028A2 0129      MOVW	R4,R18
    028A3 E908      LDI	R16,0x98
    028A4 E010      LDI	R17,0
    028A5 940E 4099 CALL	elpm32
    028A7 E98B      LDI	R24,0x9B
    028A8 E095      LDI	R25,5
    028A9 939A      ST	-Y,R25
    028AA 938A      ST	-Y,R24
    028AB 940E 441D CALL	fpmule1x
    028AD 0181      MOVW	R16,R2
    028AE 0192      MOVW	R18,R4
    028AF 940E 4245 CALL	fpsub2
    028B1 9310 05A6 STS	Result+71,R17
    028B3 9300 05A5 STS	Result+70,R16
    028B5 9330 05A8 STS	Result+73,R19
    028B7 9320 05A7 STS	Result+72,R18
(0271)  //TEQ 相当温度
(0272)  Result.Teq = Result.Temperature +( (Result.Temperature -36)/10 ) * Result.WindSpeed ;
    028B9 9040 058A LDS	R4,Result+43
    028BB 9050 058B LDS	R5,Result+44
    028BD 9020 0588 LDS	R2,Result+41
    028BF 9030 0589 LDS	R3,Result+42
    028C1 0131      MOVW	R6,R2
    028C2 0142      MOVW	R8,R4
    028C3 E904      LDI	R16,0x94
    028C4 E010      LDI	R17,0
    028C5 940E 4099 CALL	elpm32
    028C7 933A      ST	-Y,R19
    028C8 932A      ST	-Y,R18
    028C9 931A      ST	-Y,R17
    028CA 930A      ST	-Y,R16
    028CB 0183      MOVW	R16,R6
    028CC 0194      MOVW	R18,R8
    028CD 940E 4245 CALL	fpsub2
    028CF 0138      MOVW	R6,R16
    028D0 0149      MOVW	R8,R18
    028D1 EA08      LDI	R16,0xA8
    028D2 E010      LDI	R17,0
    028D3 940E 4099 CALL	elpm32
    028D5 933A      ST	-Y,R19
    028D6 932A      ST	-Y,R18
    028D7 931A      ST	-Y,R17
    028D8 930A      ST	-Y,R16
    028D9 0183      MOVW	R16,R6
    028DA 0194      MOVW	R18,R8
    028DB 940E 4298 CALL	fpdiv2
    028DD E982      LDI	R24,0x92
    028DE E095      LDI	R25,5
    028DF 939A      ST	-Y,R25
    028E0 938A      ST	-Y,R24
    028E1 940E 441D CALL	fpmule1x
    028E3 0181      MOVW	R16,R2
    028E4 0192      MOVW	R18,R4
    028E5 940E 423A CALL	fpadd2
    028E7 9310 05B0 STS	Result+81,R17
    028E9 9300 05AF STS	Result+80,R16
    028EB 9330 05B2 STS	Result+83,R19
    028ED 9320 05B1 STS	Result+82,R18
(0273) //将数据转换成字符串
(0274)  
(0275) ftochr(Result.WindSpeed,Result.WSChar);
    028EF E986      LDI	R24,0x96
    028F0 E095      LDI	R25,5
    028F1 8399      STD	Y+1,R25
    028F2 8388      ST	Y,R24
    028F3 9120 0594 LDS	R18,Result+53
    028F5 9130 0595 LDS	R19,Result+54
    028F7 9100 0592 LDS	R16,Result+51
    028F9 9110 0593 LDS	R17,Result+52
    028FB D04E      RCALL	_ftochr
(0276) ftochr(Result.Temperature,Result.TempChar);
    028FC E88C      LDI	R24,0x8C
    028FD E095      LDI	R25,5
    028FE 8399      STD	Y+1,R25
    028FF 8388      ST	Y,R24
    02900 9120 058A LDS	R18,Result+43
    02902 9130 058B LDS	R19,Result+44
    02904 9100 0588 LDS	R16,Result+41
    02906 9110 0589 LDS	R17,Result+42
    02908 D041      RCALL	_ftochr
(0277) ftochr(Result.WCI,Result.WCIChar);
    02909 E98F      LDI	R24,0x9F
    0290A E095      LDI	R25,5
    0290B 8399      STD	Y+1,R25
    0290C 8388      ST	Y,R24
    0290D 9120 059D LDS	R18,Result+62
    0290F 9130 059E LDS	R19,Result+63
    02911 9100 059B LDS	R16,Result+60
    02913 9110 059C LDS	R17,Result+61
    02915 D034      RCALL	_ftochr
(0278) ftochr(Result.ECT,Result.ECTChar);
    02916 EA89      LDI	R24,0xA9
    02917 E095      LDI	R25,5
    02918 8399      STD	Y+1,R25
    02919 8388      ST	Y,R24
    0291A 9120 05A7 LDS	R18,Result+72
    0291C 9130 05A8 LDS	R19,Result+73
    0291E 9100 05A5 LDS	R16,Result+70
    02920 9110 05A6 LDS	R17,Result+71
    02922 D027      RCALL	_ftochr
(0279) ftochr(Result.Teq,Result.TeqChar);
    02923 EB83      LDI	R24,0xB3
    02924 E095      LDI	R25,5
    02925 8399      STD	Y+1,R25
    02926 8388      ST	Y,R24
    02927 9120 05B1 LDS	R18,Result+82
    02929 9130 05B2 LDS	R19,Result+83
    0292B 9100 05AF LDS	R16,Result+80
    0292D 9110 05B0 LDS	R17,Result+81
    0292F D01A      RCALL	_ftochr
(0280) itoa(Result.IndexChar,Result.Index,10);
    02930 E08A      LDI	R24,0xA
    02931 E090      LDI	R25,0
    02932 8399      STD	Y+1,R25
    02933 8388      ST	Y,R24
    02934 9120 0569 LDS	R18,Result+10
    02936 9130 056A LDS	R19,Result+11
    02938 E60D      LDI	R16,0x6D
    02939 E015      LDI	R17,5
    0293A 940E 4443 CALL	_itoa
(0281) Result.TempChar[6]='\0';
    0293C 2422      CLR	R2
    0293D 9220 0592 STS	Result+51,R2
(0282) Result.WSChar[5]='\0';
    0293F 9220 059B STS	Result+60,R2
(0283) Result.WCIChar[6]='\0';
    02941 9220 05A5 STS	Result+70,R2
(0284) Result.ECTChar[6]='\0';
    02943 9220 05AF STS	Result+80,R2
(0285) Result.TeqChar[6]='\0';
    02945 9220 05B9 STS	Result+90,R2
(0286)  return ;
    02947 9622      ADIW	R28,2
    02948 940C 40F1 JMP	pop_xgset003C
_ftochr:
  status               --> Y,+2
  j                    --> R12
  lenth                --> R20
  res                  --> R12
  i                    --> R10
  dest                 --> R14
  a                    --> Y,+12
    0294A 940E 3FCC CALL	push_arg4
    0294C 940E 4113 CALL	push_xgset30FC
    0294E 9724      SBIW	R28,4
    0294F 88E8      LDD	R14,Y+16
    02950 88F9      LDD	R15,Y+17
(0287) }
(0288) ////////////////////////////////////////////
(0289) //				字符串转换函数
(0290) //   浮点 到  字符串
(0291) ////////////////////////////////////////////
(0292) void ftochr(float a,char * dest){//float
(0293) char i=0,j=0,lenth;
(0294) int status;
(0295) char *res;
(0296)  res=ftoa(a,&status);  //float to ascii
    02951 01CE      MOVW	R24,R28
    02952 9602      ADIW	R24,2
    02953 8399      STD	Y+1,R25
    02954 8388      ST	Y,R24
    02955 850C      LDD	R16,Y+12
    02956 851D      LDD	R17,Y+13
    02957 852E      LDD	R18,Y+14
    02958 853F      LDD	R19,Y+15
    02959 940E 4566 CALL	_ftoa
    0295B 0168      MOVW	R12,R16
(0297) lenth=strlen(res);
    0295C 940E 3FC0 CALL	_strlen
    0295E 2F40      MOV	R20,R16
(0298) 
(0299) for(i=0;i <lenth;i++) 
    0295F 24AA      CLR	R10
    02960 C023      RJMP	0x2984
(0300)        {
(0301) 	   	dest[i]=res[i];
    02961 2DEA      MOV	R30,R10
    02962 27FF      CLR	R31
    02963 0DEC      ADD	R30,R12
    02964 1DFD      ADC	R31,R13
    02965 8020      LD	R2,Z
    02966 2DEA      MOV	R30,R10
    02967 27FF      CLR	R31
    02968 0DEE      ADD	R30,R14
    02969 1DFF      ADC	R31,R15
    0296A 8220      ST	Z,R2
(0302) 
(0303) 		if( res[i]=='.'  ) 
    0296B 2DEA      MOV	R30,R10
    0296C 27FF      CLR	R31
    0296D 0DEC      ADD	R30,R12
    0296E 1DFD      ADC	R31,R13
    0296F 8180      LD	R24,Z
    02970 328E      CPI	R24,0x2E
    02971 F489      BNE	0x2983
(0304) 			{
(0305) 				dest[i+1]=res[i+1];
    02972 2DEA      MOV	R30,R10
    02973 27FF      CLR	R31
    02974 0DEC      ADD	R30,R12
    02975 1DFD      ADC	R31,R13
    02976 8021      LDD	R2,Z+1
    02977 2DEA      MOV	R30,R10
    02978 27FF      CLR	R31
    02979 0DEE      ADD	R30,R14
    0297A 1DFF      ADC	R31,R15
    0297B 8221      STD	Z+1,R2
(0306) 					dest[i+2]='\0';
    0297C 2DEA      MOV	R30,R10
    0297D 27FF      CLR	R31
    0297E 0DEE      ADD	R30,R14
    0297F 1DFF      ADC	R31,R15
    02980 2422      CLR	R2
    02981 8222      STD	Z+2,R2
(0307) 						return ;    
    02982 C003      RJMP	0x2986
    02983 94A3      INC	R10
    02984 16A4      CP	R10,R20
    02985 F2D8      BCS	0x2961
    02986 9624      ADIW	R28,4
    02987 940E 40FD CALL	pop_xgset30FC
    02989 9624      ADIW	R28,4
    0298A 9508      RET
_itochr:
  dest                 --> R10
  a                    --> R12
    0298B 940E 4117 CALL	push_xgset003C
    0298D 0159      MOVW	R10,R18
    0298E 0168      MOVW	R12,R16
    0298F 9722      SBIW	R28,2
(0308) 		    }
(0309)  
(0310)  		}
(0311) }
(0312) //////////////////////////////////////////////////////
(0313) //              整型数据变字符串
(0314) //    a  到  dest
(0315) ///////////////////////////////////////////////////////
(0316) void itochr(int a,char * dest){ //int to ascii
(0317) 	 itoa(dest,a,10); 
    02990 E08A      LDI	R24,0xA
    02991 E090      LDI	R25,0
    02992 8399      STD	Y+1,R25
    02993 8388      ST	Y,R24
    02994 0196      MOVW	R18,R12
    02995 0185      MOVW	R16,R10
    02996 940E 4443 CALL	_itoa
    02998 9622      ADIW	R28,2
    02999 940C 40F1 JMP	pop_xgset003C
_StructToChar:
  otherbyte            --> Y,+16
  ary                  --> Y,+0
  i                    --> R10
    0299B 92AA      ST	-Y,R10
    0299C 9768      SBIW	R28,0x18
(0318) }
(0319) //////////////////////////////////////////////////////
(0320) //                  结构体 变字符串
(0321) // 将目前存于结构体的数据转换到Temp_Char中。
(0322) ///////////////////////////////////////////////////////
(0323) void  StructToChar(void)
(0324) { 
(0325)   unsigned char i;
(0326)   char otherbyte[]="0\t0\t0\t0";
    0299D EB80      LDI	R24,0xB0
    0299E E091      LDI	R25,1
    0299F 01FE      MOVW	R30,R28
    029A0 9670      ADIW	R30,0x10
    029A1 E008      LDI	R16,0x8
    029A2 E010      LDI	R17,0
    029A3 93FA      ST	-Y,R31
    029A4 93EA      ST	-Y,R30
    029A5 939A      ST	-Y,R25
    029A6 938A      ST	-Y,R24
    029A7 940E 41B8 CALL	asgnblk
(0327)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    029A9 EB88      LDI	R24,0xB8
    029AA E091      LDI	R25,1
    029AB 01FE      MOVW	R30,R28
    029AC E100      LDI	R16,0x10
    029AD E010      LDI	R17,0
    029AE 93FA      ST	-Y,R31
    029AF 93EA      ST	-Y,R30
    029B0 939A      ST	-Y,R25
    029B1 938A      ST	-Y,R24
    029B2 940E 41B8 CALL	asgnblk
(0328)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0329) 				Result.TeqChar
(0330) 			   };  //指向数组首地址的指针
(0331)   //strcat(Temp_Char,Result.Name);
(0332)   for(i=0;i<=80;i++) TempChar[i]='\0';  //清空数组
    029B4 24AA      CLR	R10
    029B5 C009      RJMP	0x29BF
    029B6 E08F      LDI	R24,0xF
    029B7 E095      LDI	R25,5
    029B8 2DEA      MOV	R30,R10
    029B9 27FF      CLR	R31
    029BA 0FE8      ADD	R30,R24
    029BB 1FF9      ADC	R31,R25
    029BC 2422      CLR	R2
    029BD 8220      ST	Z,R2
    029BE 94A3      INC	R10
    029BF E580      LDI	R24,0x50
    029C0 158A      CP	R24,R10
    029C1 F7A0      BCC	0x29B6
(0333)     for(i=0;i<=7;i++){
    029C2 24AA      CLR	R10
    029C3 C014      RJMP	0x29D8
(0334) 		strcat(TempChar,ary[i]);  // 按顺序复制字符串
    029C4 01CE      MOVW	R24,R28
    029C5 2DEA      MOV	R30,R10
    029C6 27FF      CLR	R31
    029C7 0FEE      LSL	R30
    029C8 1FFF      ROL	R31
    029C9 0FE8      ADD	R30,R24
    029CA 1FF9      ADC	R31,R25
    029CB 8120      LD	R18,Z
    029CC 8131      LDD	R19,Z+1
    029CD E00F      LDI	R16,0xF
    029CE E015      LDI	R17,5
    029CF 940E 3FB3 CALL	_strcat
(0335) 		strcat(TempChar,tab);     // 字串结尾加上制表符
    029D1 E02F      LDI	R18,0xF
    029D2 E031      LDI	R19,1
    029D3 E00F      LDI	R16,0xF
    029D4 E015      LDI	R17,5
    029D5 940E 3FB3 CALL	_strcat
    029D7 94A3      INC	R10
    029D8 E087      LDI	R24,7
    029D9 158A      CP	R24,R10
    029DA F748      BCC	0x29C4
(0336)     }
(0337) 				 
(0338) 				 otherbyte[0]=otherbyte[0]+Result.WeiHai;
    029DB 9020 05B9 LDS	R2,Result+90
    029DD 8838      LDD	R3,Y+16
    029DE 0C32      ADD	R3,R2
    029DF 8A38      STD	Y+16,R3
(0339) 				 otherbyte[2]=otherbyte[0]+Result.LowLabor;
    029E0 9020 05BA LDS	R2,Result+91
    029E2 0C32      ADD	R3,R2
    029E3 8A3A      STD	Y+18,R3
(0340) 				 otherbyte[4]=otherbyte[0]+Result.MidLabor;
    029E4 9020 05BB LDS	R2,Result+92
    029E6 8838      LDD	R3,Y+16
    029E7 0C32      ADD	R3,R2
    029E8 8A3C      STD	Y+20,R3
(0341) 				 otherbyte[6]=otherbyte[0]+Result.HighLabor;
    029E9 9020 05BC LDS	R2,Result+93
    029EB 8838      LDD	R3,Y+16
    029EC 0C32      ADD	R3,R2
    029ED 8A3E      STD	Y+22,R3
(0342)  
(0343)   strcat(TempChar,otherbyte);  
    029EE 019E      MOVW	R18,R28
    029EF 5F20      SUBI	R18,0xF0
    029F0 4F3F      SBCI	R19,0xFF
    029F1 E00F      LDI	R16,0xF
    029F2 E015      LDI	R17,5
    029F3 940E 3FB3 CALL	_strcat
(0344)   strcat(TempChar,enter);  
    029F5 E122      LDI	R18,0x12
    029F6 E031      LDI	R19,1
    029F7 E00F      LDI	R16,0xF
    029F8 E015      LDI	R17,5
    029F9 940E 3FB3 CALL	_strcat
(0345)   strcat(TempChar,"\0\0");
    029FB ED2F      LDI	R18,0xDF
    029FC E031      LDI	R19,1
    029FD E00F      LDI	R16,0xF
    029FE E015      LDI	R17,5
    029FF 940E 3FB3 CALL	_strcat
    02A01 9668      ADIW	R28,0x18
    02A02 90A9      LD	R10,Y+
    02A03 9508      RET
_CharToStruct:
  Temp_Char            --> Y,+16
  i                    --> R20
  ary                  --> Y,+0
  j                    --> R14
  p                    --> R10
  q                    --> R12
    02A04 940E 4113 CALL	push_xgset30FC
    02A06 97EF      SBIW	R28,0x3F
    02A07 97A1      SBIW	R28,0x21
(0346) }
(0347) 
(0348) //////////////////////////////////////////////////////
(0349) //               字符串  变  结构体
(0350) // 
(0351) ///////////////////////////////////////////////////////
(0352) void CharToStruct(void)
(0353) {
(0354)   unsigned char i=0,j=0;
    02A08 2744      CLR	R20
    02A09 24EE      CLR	R14
(0355)   unsigned char *p,*q;
(0356)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    02A0A EC88      LDI	R24,0xC8
    02A0B E091      LDI	R25,1
    02A0C 01FE      MOVW	R30,R28
    02A0D E100      LDI	R16,0x10
    02A0E E010      LDI	R17,0
    02A0F 93FA      ST	-Y,R31
    02A10 93EA      ST	-Y,R30
    02A11 939A      ST	-Y,R25
    02A12 938A      ST	-Y,R24
    02A13 940E 41B8 CALL	asgnblk
(0357)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0358) 				Result.TeqChar
(0359) 			   };  //指向数组首地址的指针
(0360)   char Temp_Char[80];
(0361)     p=ary[j];
    02A15 01CE      MOVW	R24,R28
    02A16 2DEE      MOV	R30,R14
    02A17 27FF      CLR	R31
    02A18 0FEE      LSL	R30
    02A19 1FFF      ROL	R31
    02A1A 0FE8      ADD	R30,R24
    02A1B 1FF9      ADC	R31,R25
    02A1C 80A0      LD	R10,Z
    02A1D 80B1      LDD	R11,Z+1
(0362) 	q=Temp_Char;
    02A1E 01CE      MOVW	R24,R28
    02A1F 9640      ADIW	R24,0x10
    02A20 016C      MOVW	R12,R24
    02A21 C01D      RJMP	0x2A3F
(0363) 	while(1){
(0364)     if(*q =='\n') {*p='\0'; return;} ;
    02A22 01F6      MOVW	R30,R12
    02A23 8180      LD	R24,Z
    02A24 308A      CPI	R24,0xA
    02A25 F421      BNE	0x2A2A
    02A26 2422      CLR	R2
    02A27 01F5      MOVW	R30,R10
    02A28 8220      ST	Z,R2
    02A29 C016      RJMP	0x2A40
(0365) 	if(*q =='\t') {j++;p=ary[j];i=0;}
    02A2A 01F6      MOVW	R30,R12
    02A2B 8180      LD	R24,Z
    02A2C 3089      CPI	R24,0x9
    02A2D F459      BNE	0x2A39
    02A2E 94E3      INC	R14
    02A2F 01CE      MOVW	R24,R28
    02A30 2DEE      MOV	R30,R14
    02A31 27FF      CLR	R31
    02A32 0FEE      LSL	R30
    02A33 1FFF      ROL	R31
    02A34 0FE8      ADD	R30,R24
    02A35 1FF9      ADC	R31,R25
    02A36 80A0      LD	R10,Z
    02A37 80B1      LDD	R11,Z+1
    02A38 2744      CLR	R20
(0366)     *p++=*q++;
    02A39 01F6      MOVW	R30,R12
    02A3A 01D5      MOVW	R26,R10
    02A3B 9001      LD	R0,Z+
    02A3C 016F      MOVW	R12,R30
    02A3D 920D      ST	X+,R0
    02A3E 015D      MOVW	R10,R26
    02A3F CFE2      RJMP	0x2A22
    02A40 96EF      ADIW	R28,0x3F
    02A41 96A1      ADIW	R28,0x21
    02A42 940C 40FD JMP	pop_xgset30FC
_get_name:
  i                    --> R20
  filenamep            --> R16
    02A44 940E 4126 CALL	push_xgsetF000
(0367) 	}
(0368)   }
(0369)  
(0370)  ////////////////////////////////////////////
(0371) //				根据当前日期获取文件名
(0372) //   
(0373) ////////////////////////////////////////////
(0374) char *get_name( char filenamep[] ){     
(0375) 	  unsigned char i=0;
(0376)  	  for(i=0;i<6;i++) {
    02A46 2744      CLR	R20
    02A47 C00D      RJMP	0x2A55
(0377) 	  				    *(filenamep+i)=Result.Date[i];
    02A48 E785      LDI	R24,0x75
    02A49 E095      LDI	R25,5
    02A4A 2FE4      MOV	R30,R20
    02A4B 27FF      CLR	R31
    02A4C 0FE8      ADD	R30,R24
    02A4D 1FF9      ADC	R31,R25
    02A4E 8020      LD	R2,Z
    02A4F 2FE4      MOV	R30,R20
    02A50 27FF      CLR	R31
    02A51 0FE0      ADD	R30,R16
    02A52 1FF1      ADC	R31,R17
    02A53 8220      ST	Z,R2
    02A54 9543      INC	R20
    02A55 3046      CPI	R20,6
    02A56 F388      BCS	0x2A48
(0378) 	  				   } 
(0379) 	 	*(filenamep+(i++))='.';
    02A57 2E24      MOV	R2,R20
    02A58 2433      CLR	R3
    02A59 5F4F      SUBI	R20,0xFF
    02A5A 2DE2      MOV	R30,R2
    02A5B 27FF      CLR	R31
    02A5C 0FE0      ADD	R30,R16
    02A5D 1FF1      ADC	R31,R17
    02A5E E28E      LDI	R24,0x2E
    02A5F 8380      ST	Z,R24
(0380) 		*(filenamep+(i++))='x';
    02A60 2E24      MOV	R2,R20
    02A61 2433      CLR	R3
    02A62 5F4F      SUBI	R20,0xFF
    02A63 2DE2      MOV	R30,R2
    02A64 27FF      CLR	R31
    02A65 0FE0      ADD	R30,R16
    02A66 1FF1      ADC	R31,R17
    02A67 E788      LDI	R24,0x78
    02A68 8380      ST	Z,R24
(0381) 		*(filenamep+(i++))='l';
    02A69 2F64      MOV	R22,R20
    02A6A 2777      CLR	R23
    02A6B 5F4F      SUBI	R20,0xFF
    02A6C 2FE6      MOV	R30,R22
    02A6D 27FF      CLR	R31
    02A6E 0FE0      ADD	R30,R16
    02A6F 1FF1      ADC	R31,R17
    02A70 E68C      LDI	R24,0x6C
    02A71 8380      ST	Z,R24
(0382) 		*(filenamep+(i++))='s';
    02A72 2F64      MOV	R22,R20
    02A73 2777      CLR	R23
    02A74 5F4F      SUBI	R20,0xFF
    02A75 2FE6      MOV	R30,R22
    02A76 27FF      CLR	R31
    02A77 0FE0      ADD	R30,R16
    02A78 1FF1      ADC	R31,R17
    02A79 E783      LDI	R24,0x73
    02A7A 8380      ST	Z,R24
(0383) 		*(filenamep+(i))='\0';
    02A7B 2FE4      MOV	R30,R20
    02A7C 27FF      CLR	R31
    02A7D 0FE0      ADD	R30,R16
    02A7E 1FF1      ADC	R31,R17
    02A7F 2422      CLR	R2
    02A80 8220      ST	Z,R2
(0384) 					   
(0385)       return filenamep;
    02A81 940C 412B JMP	pop_xgsetF000
_SquareRootFloat:
  f                    --> Y,+12
  x                    --> Y,+8
  i                    --> Y,+4
  y                    --> Y,+0
  number               --> Y,+20
    02A83 940E 3FCC CALL	push_arg4
    02A85 940E 4126 CALL	push_xgsetF000
    02A87 9760      SBIW	R28,0x10
(0386) } 
(0387) float SquareRootFloat(float number)
(0388) {
(0389)     long i;
(0390)     float x, y;
(0391)     const float f = 1.5F;
    02A88 E900      LDI	R16,0x90
    02A89 E010      LDI	R17,0
    02A8A 940E 4099 CALL	elpm32
    02A8C 870C      STD	Y+12,R16
    02A8D 871D      STD	Y+13,R17
    02A8E 872E      STD	Y+14,R18
    02A8F 873F      STD	Y+15,R19
(0392)     x = number * 0.5F;
    02A90 E80C      LDI	R16,0x8C
    02A91 E010      LDI	R17,0
    02A92 940E 4099 CALL	elpm32
    02A94 01CE      MOVW	R24,R28
    02A95 9644      ADIW	R24,0x14
    02A96 939A      ST	-Y,R25
    02A97 938A      ST	-Y,R24
    02A98 940E 4408 CALL	fpmule1
    02A9A 8708      STD	Y+8,R16
    02A9B 8719      STD	Y+9,R17
    02A9C 872A      STD	Y+10,R18
    02A9D 873B      STD	Y+11,R19
(0393)     y  = number;
    02A9E 882C      LDD	R2,Y+20
    02A9F 883D      LDD	R3,Y+21
    02AA0 884E      LDD	R4,Y+22
    02AA1 885F      LDD	R5,Y+23
    02AA2 8228      ST	Y,R2
    02AA3 8239      STD	Y+1,R3
    02AA4 824A      STD	Y+2,R4
    02AA5 825B      STD	Y+3,R5
(0394)     i  = * ( long * ) &y;
    02AA6 01FE      MOVW	R30,R28
    02AA7 8020      LD	R2,Z
    02AA8 8031      LDD	R3,Z+1
    02AA9 8042      LDD	R4,Z+2
    02AAA 8053      LDD	R5,Z+3
    02AAB 822C      STD	Y+4,R2
    02AAC 823D      STD	Y+5,R3
    02AAD 824E      STD	Y+6,R4
    02AAE 825F      STD	Y+7,R5
(0395)     i  = 0x5f3759df - ( i >> 1 );  //卡马克
    02AAF 802C      LDD	R2,Y+4
    02AB0 803D      LDD	R3,Y+5
    02AB1 804E      LDD	R4,Y+6
    02AB2 805F      LDD	R5,Y+7
    02AB3 9455      ASR	R5
    02AB4 9447      ROR	R4
    02AB5 9437      ROR	R3
    02AB6 9427      ROR	R2
    02AB7 ED4F      LDI	R20,0xDF
    02AB8 E559      LDI	R21,0x59
    02AB9 E367      LDI	R22,0x37
    02ABA E57F      LDI	R23,0x5F
    02ABB 1942      SUB	R20,R2
    02ABC 0953      SBC	R21,R3
    02ABD 0964      SBC	R22,R4
    02ABE 0975      SBC	R23,R5
    02ABF 834C      STD	Y+4,R20
    02AC0 835D      STD	Y+5,R21
    02AC1 836E      STD	Y+6,R22
    02AC2 837F      STD	Y+7,R23
(0396)   //i  = 0x5f375a86 - ( i >> 1 );  //Lomont
(0397)     y  = * ( float * ) &i;
    02AC3 01FE      MOVW	R30,R28
    02AC4 9634      ADIW	R30,4
    02AC5 8020      LD	R2,Z
    02AC6 8031      LDD	R3,Z+1
    02AC7 8042      LDD	R4,Z+2
    02AC8 8053      LDD	R5,Z+3
    02AC9 8228      ST	Y,R2
    02ACA 8239      STD	Y+1,R3
    02ACB 824A      STD	Y+2,R4
    02ACC 825B      STD	Y+3,R5
(0398)     y  = y * ( f - ( x * y * y ) );
    02ACD 8028      LD	R2,Y
    02ACE 8039      LDD	R3,Y+1
    02ACF 804A      LDD	R4,Y+2
    02AD0 805B      LDD	R5,Y+3
    02AD1 846C      LDD	R6,Y+12
    02AD2 847D      LDD	R7,Y+13
    02AD3 848E      LDD	R8,Y+14
    02AD4 849F      LDD	R9,Y+15
    02AD5 8508      LDD	R16,Y+8
    02AD6 8519      LDD	R17,Y+9
    02AD7 852A      LDD	R18,Y+10
    02AD8 853B      LDD	R19,Y+11
    02AD9 01CE      MOVW	R24,R28
    02ADA 939A      ST	-Y,R25
    02ADB 938A      ST	-Y,R24
    02ADC 940E 4408 CALL	fpmule1
    02ADE 01CE      MOVW	R24,R28
    02ADF 939A      ST	-Y,R25
    02AE0 938A      ST	-Y,R24
    02AE1 940E 441D CALL	fpmule1x
    02AE3 0183      MOVW	R16,R6
    02AE4 0194      MOVW	R18,R8
    02AE5 940E 425D CALL	fpsub2x
    02AE7 0181      MOVW	R16,R2
    02AE8 0192      MOVW	R18,R4
    02AE9 940E 4412 CALL	fpmule2
    02AEB 8308      ST	Y,R16
    02AEC 8319      STD	Y+1,R17
    02AED 832A      STD	Y+2,R18
    02AEE 833B      STD	Y+3,R19
(0399)     y  = y * ( f - ( x * y * y ) );
    02AEF 8028      LD	R2,Y
    02AF0 8039      LDD	R3,Y+1
    02AF1 804A      LDD	R4,Y+2
    02AF2 805B      LDD	R5,Y+3
    02AF3 846C      LDD	R6,Y+12
    02AF4 847D      LDD	R7,Y+13
    02AF5 848E      LDD	R8,Y+14
    02AF6 849F      LDD	R9,Y+15
    02AF7 8508      LDD	R16,Y+8
    02AF8 8519      LDD	R17,Y+9
    02AF9 852A      LDD	R18,Y+10
    02AFA 853B      LDD	R19,Y+11
    02AFB 01CE      MOVW	R24,R28
    02AFC 939A      ST	-Y,R25
    02AFD 938A      ST	-Y,R24
    02AFE 940E 4408 CALL	fpmule1
    02B00 01CE      MOVW	R24,R28
    02B01 939A      ST	-Y,R25
    02B02 938A      ST	-Y,R24
    02B03 940E 441D CALL	fpmule1x
    02B05 0183      MOVW	R16,R6
    02B06 0194      MOVW	R18,R8
    02B07 940E 425D CALL	fpsub2x
    02B09 0181      MOVW	R16,R2
    02B0A 0192      MOVW	R18,R4
    02B0B 940E 4412 CALL	fpmule2
    02B0D 8308      ST	Y,R16
    02B0E 8319      STD	Y+1,R17
    02B0F 832A      STD	Y+2,R18
    02B10 833B      STD	Y+3,R19
(0400)     return number * y;
    02B11 890C      LDD	R16,Y+20
    02B12 891D      LDD	R17,Y+21
    02B13 892E      LDD	R18,Y+22
    02B14 893F      LDD	R19,Y+23
    02B15 01CE      MOVW	R24,R28
    02B16 939A      ST	-Y,R25
    02B17 938A      ST	-Y,R24
    02B18 940E 4408 CALL	fpmule1
    02B1A 9660      ADIW	R28,0x10
    02B1B 940E 412B CALL	pop_xgsetF000
    02B1D 9624      ADIW	R28,4
    02B1E 9508      RET
_debug:
  str2                 --> Y,+0
  val                  --> R10
  str                  --> R12
    02B1F 940E 4117 CALL	push_xgset003C
    02B21 2EA2      MOV	R10,R18
    02B22 0168      MOVW	R12,R16
    02B23 9724      SBIW	R28,4
(0401) } 
(0402) //
(0403) //###############################################################//
(0404) //debug
(0405) void debug(UINT8 *str,UINT8 val)
(0406) {
(0407)  UINT8 str2[4]={0,0,0,0};
    02B24 ED88      LDI	R24,0xD8
    02B25 E091      LDI	R25,1
    02B26 01FE      MOVW	R30,R28
    02B27 E004      LDI	R16,4
    02B28 E010      LDI	R17,0
    02B29 93FA      ST	-Y,R31
    02B2A 93EA      ST	-Y,R30
    02B2B 939A      ST	-Y,R25
    02B2C 938A      ST	-Y,R24
    02B2D 940E 41B8 CALL	asgnblk
(0408)  str=str;
(0409)  val=val;
(0410)  #ifdef _UARTDEBUG
(0411)  PrintString("\r\n");
    02B2F ED0C      LDI	R16,0xDC
    02B30 E011      LDI	R17,1
    02B31 940E 37A2 CALL	_PrintString
(0412)  PrintString(str);
    02B33 0186      MOVW	R16,R12
    02B34 940E 37A2 CALL	_PrintString
(0413)  PrintChar(val);
    02B36 2D0A      MOV	R16,R10
    02B37 940E 390C CALL	_PrintChar
    02B39 9624      ADIW	R28,4
    02B3A 940C 40F1 JMP	pop_xgset003C
_SD_Write_cmd:
  k                    --> R22
  temp                 --> R20
  p                    --> R20
    02B3C 940E 4126 CALL	push_xgsetF000
    02B3E 01A8      MOVW	R20,R16
FILE: D:\LQD\software\master\software_src\sd.c
(0001) //*****************************************************************************//
(0002) //*								数码相框
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SD卡控制
(0006) //*修改者：  桃子
(0007) //*****************************************************************************//
(0008) #include "sd.h"
(0009) 
(0010) //****************************************************************
(0011) //*隶属模块：SD卡控制
(0012) //*函数功能：写6字节数据
(0013) //****************************************************************
(0014) UINT8 SD_Write_cmd(UINT8 *p)
(0015) {	
(0016) 	UINT16 temp,k=0;
    02B3F 2766      CLR	R22
    02B40 2777      CLR	R23
(0017) 	SD_CS_DIS();//禁止SPI
    02B41 9AC0      SBI	0x18,0
(0018) 	SPI_Read();//空读一字节
    02B42 940E 393A CALL	_SPI_Read
(0019) 	SD_CS_EN();//使能SPI
    02B44 98C0      CBI	0x18,0
(0020) 
(0021) 	SPI_Write(p[0]);
    02B45 01FA      MOVW	R30,R20
    02B46 8100      LD	R16,Z
    02B47 940E 3936 CALL	_SPI_Write
(0022) 	SPI_Write(p[1]);
    02B49 01FA      MOVW	R30,R20
    02B4A 8101      LDD	R16,Z+1
    02B4B 940E 3936 CALL	_SPI_Write
(0023) 	SPI_Write(p[2]);
    02B4D 01FA      MOVW	R30,R20
    02B4E 8102      LDD	R16,Z+2
    02B4F 940E 3936 CALL	_SPI_Write
(0024) 	SPI_Write(p[3]);
    02B51 01FA      MOVW	R30,R20
    02B52 8103      LDD	R16,Z+3
    02B53 940E 3936 CALL	_SPI_Write
(0025) 	SPI_Write(p[4]);
    02B55 01FA      MOVW	R30,R20
    02B56 8104      LDD	R16,Z+4
    02B57 940E 3936 CALL	_SPI_Write
(0026) 	SPI_Write(p[5]);
    02B59 01FA      MOVW	R30,R20
    02B5A 8105      LDD	R16,Z+5
    02B5B 940E 3936 CALL	_SPI_Write
(0027) 
(0028) 	do 
(0029)  	{  
(0030)   		temp = SPI_Read();//一直读，直到读到的不是0xff或超时
    02B5D 940E 393A CALL	_SPI_Read
    02B5F 2F40      MOV	R20,R16
    02B60 2755      CLR	R21
(0031)  		k++;
    02B61 5F6F      SUBI	R22,0xFF
    02B62 4F7F      SBCI	R23,0xFF
(0032)  	}while((temp==0xff)&&(k<TRY_TIME)); 
    02B63 3F4F      CPI	R20,0xFF
    02B64 E0E0      LDI	R30,0
    02B65 075E      CPC	R21,R30
    02B66 F421      BNE	0x2B6B
    02B67 3164      CPI	R22,0x14
    02B68 E0E0      LDI	R30,0
    02B69 077E      CPC	R23,R30
    02B6A F390      BCS	0x2B5D
(0033) 
(0034) 	return temp;
    02B6B 2F04      MOV	R16,R20
    02B6C 940C 412B JMP	pop_xgsetF000
_SD_Init:
  pcmd                 --> Y,+0
  temp                 --> R22
  time                 --> R20
    02B6E 940E 4130 CALL	push_xgsetF00C
    02B70 9726      SBIW	R28,6
(0035) }
(0036) //****************************************************************
(0037) //*隶属模块：SD卡控制
(0038) //*函数功能：初始化
(0039) //****************************************************************
(0040) UINT8 SD_Init(void)	
(0041) {  
(0042) 	UINT8 time=0,temp=0;
    02B71 2744      CLR	R20
    02B72 2766      CLR	R22
(0043) 	UINT8 pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; //命令0的字节序列
    02B73 E48A      LDI	R24,0x4A
    02B74 E092      LDI	R25,2
    02B75 01FE      MOVW	R30,R28
    02B76 E006      LDI	R16,6
    02B77 E010      LDI	R17,0
    02B78 93FA      ST	-Y,R31
    02B79 93EA      ST	-Y,R30
    02B7A 939A      ST	-Y,R25
    02B7B 938A      ST	-Y,R24
    02B7C 940E 41B8 CALL	asgnblk
(0044) 	if(SD_DET()==0) return 0x02; //no disk
    02B7E B181      IN	R24,0x01
    02B7F 9586      LSR	R24
    02B80 9586      LSR	R24
    02B81 9586      LSR	R24
    02B82 9586      LSR	R24
    02B83 9586      LSR	R24
    02B84 7081      ANDI	R24,1
    02B85 F421      BNE	0x2B8A
    02B86 E081      LDI	R24,1
    02B87 E090      LDI	R25,0
    02B88 015C      MOVW	R10,R24
    02B89 C002      RJMP	0x2B8C
    02B8A 24AA      CLR	R10
    02B8B 24BB      CLR	R11
    02B8C 20AA      TST	R10
    02B8D F421      BNE	0x2B92
    02B8E 20BB      TST	R11
    02B8F F411      BNE	0x2B92
    02B90 E002      LDI	R16,2
    02B91 C039      RJMP	0x2BCB
(0045) 	SD_PORT |= (1<<SD_CS);
    02B92 9AC0      SBI	0x18,0
(0046) 	SD_DDR |= (1<<SD_CS);
    02B93 9AB8      SBI	0x17,0
(0047) 
(0048) 	SPI_IO_Init();
    02B94 940E 392C CALL	_SPI_IO_Init
(0049) 	SPI_Low();
    02B96 E582      LDI	R24,0x52
    02B97 B98D      OUT	0x0D,R24
    02B98 B18E      IN	R24,0x0E
    02B99 7F8F      ANDI	R24,0xFF
    02B9A B98E      OUT	0x0E,R24
(0050) 
(0051) 	SD_CS_DIS();  //关闭片选 
    02B9B 9AC0      SBI	0x18,0
(0052) 	for(time=0;time<10;time++) //初始时，首先要发送最少74个时钟信号，这是必须的！！！
    02B9C 2744      CLR	R20
    02B9D C003      RJMP	0x2BA1
(0053) 	{
(0054)   		SPI_Read(); 
    02B9E 940E 393A CALL	_SPI_Read
    02BA0 9543      INC	R20
    02BA1 304A      CPI	R20,0xA
    02BA2 F3D8      BCS	0x2B9E
(0055) 	}
(0056) 	SD_CS_EN(); //打开片选
    02BA3 98C0      CBI	0x18,0
(0057) 	time = 0;
    02BA4 2744      CLR	R20
(0058) 	do
(0059) 	{ 
(0060) 		temp=SD_Write_cmd(pcmd);//写入CMD0
    02BA5 018E      MOVW	R16,R28
    02BA6 DF95      RCALL	_SD_Write_cmd
    02BA7 2F60      MOV	R22,R16
(0061) 	 	time++;
    02BA8 9543      INC	R20
(0062) 	 	if(time==TRY_TIME) 
    02BA9 3144      CPI	R20,0x14
    02BAA F419      BNE	0x2BAE
(0063) 	 	{ 
(0064) 	  		SD_CS_DIS(); //关闭片选
    02BAB 9AC0      SBI	0x18,0
(0065) 	  		return(INIT_CMD0_ERROR);//CMD0写入失败
    02BAC E001      LDI	R16,1
    02BAD C01D      RJMP	0x2BCB
(0066) 	 	}
(0067) 	 }while(temp!=0x01);
    02BAE 3061      CPI	R22,1
    02BAF F7A9      BNE	0x2BA5
(0068) 
(0069) 	SD_CS_DIS(); //关闭片选
    02BB0 9AC0      SBI	0x18,0
(0070) 	SPI_Read(); //按照SD卡的操作时序在这里补8个时钟 
    02BB1 940E 393A CALL	_SPI_Read
(0071) 	SD_CS_EN(); //打开片选
    02BB3 98C0      CBI	0x18,0
(0072) 
(0073) 	pcmd[0]=0x41,pcmd[5]=0xff;
    02BB4 E481      LDI	R24,0x41
    02BB5 8388      ST	Y,R24
    02BB6 EF8F      LDI	R24,0xFF
    02BB7 838D      STD	Y+5,R24
(0074) 	time = 0;
    02BB8 2744      CLR	R20
(0075) 	do
(0076) 	{ 
(0077) 		temp=SD_Write_cmd(pcmd);
    02BB9 018E      MOVW	R16,R28
    02BBA DF81      RCALL	_SD_Write_cmd
    02BBB 2F60      MOV	R22,R16
(0078) 		time++;
    02BBC 9543      INC	R20
(0079) 		if(time==TRY_TIME) 
    02BBD 3144      CPI	R20,0x14
    02BBE F419      BNE	0x2BC2
(0080) 		{ 
(0081) 		 	SD_CS_DIS(); //关闭片选
    02BBF 9AC0      SBI	0x18,0
(0082) 			 return(INIT_CMD1_ERROR);//CMD1写入失败
    02BC0 E002      LDI	R16,2
    02BC1 C009      RJMP	0x2BCB
(0083) 		 }
(0084) 	 }while(temp!=0);
    02BC2 2366      TST	R22
    02BC3 F7A9      BNE	0x2BB9
(0085)   
(0086) 	 SPI_High();  
    02BC4 E580      LDI	R24,0x50
    02BC5 B98D      OUT	0x0D,R24
    02BC6 9A70      SBI	0x0E,0
(0087) 	 SD_CS_DIS();  //关闭片选 
    02BC7 9AC0      SBI	0x18,0
(0088) 	 SPI_Read(); //按照SD卡的操作时序在这里补8个时钟
    02BC8 940E 393A CALL	_SPI_Read
(0089) 	 return SD_TURE; //返回0,说明初始化操作成功
    02BCA 2700      CLR	R16
    02BCB 9626      ADIW	R28,6
    02BCC 940C 4137 JMP	pop_xgsetF00C
_SD_Write_Sector:
  pcmd                 --> Y,+0
  time                 --> R12
  temp                 --> R20
  i                    --> R22
  buffer               --> R10
  addr                 --> Y,+14
    02BCE 940E 3FCC CALL	push_arg4
    02BD0 940E 414C CALL	push_xgsetF03C
    02BD2 9726      SBIW	R28,6
    02BD3 88AA      LDD	R10,Y+18
    02BD4 88BB      LDD	R11,Y+19
(0090) } 
(0091) //****************************************************************
(0092) //*隶属模块：SD卡控制
(0093) //*函数功能：写512字节数据（一扇区字节）
(0094) //****************************************************************
(0095) UINT16 SD_Write_Sector(UINT32 addr,UINT8 *buffer)
(0096) {  
(0097) 	UINT8 temp=0,time=0;
    02BD5 2744      CLR	R20
    02BD6 24CC      CLR	R12
(0098) 	UINT16 i=0;
    02BD7 2766      CLR	R22
    02BD8 2777      CLR	R23
(0099) 	UINT8 pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //向SD卡中单个块（512字节，一个扇区）写入数据，用CMD24
    02BD9 E580      LDI	R24,0x50
    02BDA E092      LDI	R25,2
    02BDB 01FE      MOVW	R30,R28
    02BDC E006      LDI	R16,6
    02BDD E010      LDI	R17,0
    02BDE 93FA      ST	-Y,R31
    02BDF 93EA      ST	-Y,R30
    02BE0 939A      ST	-Y,R25
    02BE1 938A      ST	-Y,R24
    02BE2 940E 41B8 CALL	asgnblk
(0100) 
(0101) 	 addr<<=9; //将块地址（扇区地址）转为字节地址 ［这里就限制了SD卡的最大容量为4G］
    02BE4 E089      LDI	R24,0x9
    02BE5 E090      LDI	R25,0
    02BE6 850E      LDD	R16,Y+14
    02BE7 851F      LDD	R17,Y+15
    02BE8 8928      LDD	R18,Y+16
    02BE9 8939      LDD	R19,Y+17
    02BEA 938A      ST	-Y,R24
    02BEB 940E 4193 CALL	lsl32
    02BED 870E      STD	Y+14,R16
    02BEE 871F      STD	Y+15,R17
    02BEF 8B28      STD	Y+16,R18
    02BF0 8B39      STD	Y+17,R19
(0102) 
(0103) 	 pcmd[1]=(addr>>24); //将字节地址写入到CMD24字节序列中
    02BF1 E188      LDI	R24,0x18
    02BF2 E090      LDI	R25,0
    02BF3 850E      LDD	R16,Y+14
    02BF4 851F      LDD	R17,Y+15
    02BF5 8928      LDD	R18,Y+16
    02BF6 8939      LDD	R19,Y+17
    02BF7 938A      ST	-Y,R24
    02BF8 940E 41AC CALL	lsr32
    02BFA 8309      STD	Y+1,R16
(0104) 	 pcmd[2]=(addr>>16);
    02BFB 842E      LDD	R2,Y+14
    02BFC 843F      LDD	R3,Y+15
    02BFD 8848      LDD	R4,Y+16
    02BFE 8859      LDD	R5,Y+17
    02BFF 0112      MOVW	R2,R4
    02C00 2444      CLR	R4
    02C01 2455      CLR	R5
    02C02 822A      STD	Y+2,R2
(0105) 	 pcmd[3]=(addr>>8);
    02C03 E088      LDI	R24,0x8
    02C04 E090      LDI	R25,0
    02C05 850E      LDD	R16,Y+14
    02C06 851F      LDD	R17,Y+15
    02C07 8928      LDD	R18,Y+16
    02C08 8939      LDD	R19,Y+17
    02C09 938A      ST	-Y,R24
    02C0A 940E 41AC CALL	lsr32
    02C0C 830B      STD	Y+3,R16
(0106) 	// pcmd[4]=offset;	
(0107) 	 SD_CS_EN();//打开SD卡片选
    02C0D 98C0      CBI	0x18,0
(0108) 
(0109) 	 do
(0110) 	 {  
(0111) 		temp=SD_Write_cmd(pcmd);
    02C0E 018E      MOVW	R16,R28
    02C0F DF2C      RCALL	_SD_Write_cmd
    02C10 2F40      MOV	R20,R16
(0112)   		time++;
    02C11 94C3      INC	R12
(0113)   		if(time==TRY_TIME) 
    02C12 2D8C      MOV	R24,R12
    02C13 3184      CPI	R24,0x14
    02C14 F419      BNE	0x2C18
(0114)   		{ 
(0115)    			SD_CS_DIS(); //关闭片选
    02C15 9AC0      SBI	0x18,0
(0116)    			return(temp); //命令写入失败
    02C16 2711      CLR	R17
    02C17 C037      RJMP	0x2C4F
(0117)   		}
(0118) 	}while(temp!=0); 
    02C18 2344      TST	R20
    02C19 F7A1      BNE	0x2C0E
(0119) 
(0120) 	for(i=0;i<100;i++) //这里要插入若干时钟信号
    02C1A 2766      CLR	R22
    02C1B 2777      CLR	R23
    02C1C C004      RJMP	0x2C21
(0121)   		SPI_Read();
    02C1D 940E 393A CALL	_SPI_Read
    02C1F 5F6F      SUBI	R22,0xFF
    02C20 4F7F      SBCI	R23,0xFF
    02C21 3664      CPI	R22,0x64
    02C22 E0E0      LDI	R30,0
    02C23 077E      CPC	R23,R30
    02C24 F3C0      BCS	0x2C1D
(0122) 	
(0123) 	SPI_Write(0xfe);//写入开始字节 0xfe，后面就是要写入的512个字节的数据	
    02C25 EF0E      LDI	R16,0xFE
    02C26 940E 3936 CALL	_SPI_Write
(0124) 	
(0125) 	for(i=0;i<512;i++) //将缓冲区中要写入的512个字节写入SD卡
    02C28 2766      CLR	R22
    02C29 2777      CLR	R23
    02C2A C007      RJMP	0x2C32
(0126) 		SPI_Write(*buffer++);
    02C2B 01F5      MOVW	R30,R10
    02C2C 9101      LD	R16,Z+
    02C2D 015F      MOVW	R10,R30
    02C2E 940E 3936 CALL	_SPI_Write
    02C30 5F6F      SUBI	R22,0xFF
    02C31 4F7F      SBCI	R23,0xFF
    02C32 3060      CPI	R22,0
    02C33 E0E2      LDI	R30,2
    02C34 077E      CPC	R23,R30
    02C35 F3A8      BCS	0x2C2B
(0127)   
(0128) 	SPI_Read(); 
    02C36 940E 393A CALL	_SPI_Read
(0129) 	SPI_Read(); //两个字节的CRC校验码，不用关心
    02C38 940E 393A CALL	_SPI_Read
(0130)    
(0131)     
(0132) 	temp=SPI_Read();   //读取返回值
    02C3A 940E 393A CALL	_SPI_Read
    02C3C 2F40      MOV	R20,R16
(0133) 	if((temp&0x1F)!=0x05) //如果返回值是 XXX00101说明数据已经被SD卡接受了
    02C3D 2F84      MOV	R24,R20
    02C3E 718F      ANDI	R24,0x1F
    02C3F 3085      CPI	R24,5
    02C40 F021      BEQ	0x2C45
(0134) 	{
(0135)  		SD_CS_DIS();
    02C41 9AC0      SBI	0x18,0
(0136)  		return(WRITE_BLOCK_ERROR); //写块数据失败
    02C42 E003      LDI	R16,3
    02C43 E010      LDI	R17,0
    02C44 C00A      RJMP	0x2C4F
(0137) 	}
(0138)  
(0139) 	while(SPI_Read()!=0xff);//等到SD卡不忙（数据被接受以后，SD卡要将这些数据写入到自身的FLASH中，需要一个时间）
    02C45 940E 393A CALL	_SPI_Read
    02C47 2F40      MOV	R20,R16
    02C48 3F0F      CPI	R16,0xFF
    02C49 F7D9      BNE	0x2C45
(0140) 						    //忙时，读回来的值为0x00,不忙时，为0xff
(0141) 
(0142) 	SD_CS_DIS(); //关闭片选
    02C4A 9AC0      SBI	0x18,0
(0143) 
(0144) 	SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02C4B 940E 393A CALL	_SPI_Read
(0145) 	return SD_TURE;		 //返回0,说明写扇区操作成功
    02C4D 2700      CLR	R16
    02C4E 2711      CLR	R17
    02C4F 9626      ADIW	R28,6
    02C50 940E 4155 CALL	pop_xgsetF03C
    02C52 9624      ADIW	R28,4
    02C53 9508      RET
_SD_Read_Sector:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  buffer               --> R10
  addr                 --> Y,+14
    02C54 940E 3FCC CALL	push_arg4
    02C56 940E 414C CALL	push_xgsetF03C
    02C58 9726      SBIW	R28,6
    02C59 88AA      LDD	R10,Y+18
    02C5A 88BB      LDD	R11,Y+19
(0146) } 
(0147) //****************************************************************
(0148) //*隶属模块：SD卡控制
(0149) //*函数功能：读512字节数据（一扇区字节）
(0150) //****************************************************************
(0151) UINT16 SD_Read_Sector(UINT32 addr,UINT8 *buffer)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0152) {
(0153) 
(0154) 	 UINT16 j=0;
    02C5B 2744      CLR	R20
    02C5C 2755      CLR	R21
(0155) 	 UINT8 time=0,temp=0;
    02C5D 2766      CLR	R22
    02C5E 24CC      CLR	R12
(0156) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02C5F E586      LDI	R24,0x56
    02C60 E092      LDI	R25,2
    02C61 01FE      MOVW	R30,R28
    02C62 E006      LDI	R16,6
    02C63 E010      LDI	R17,0
    02C64 93FA      ST	-Y,R31
    02C65 93EA      ST	-Y,R30
    02C66 939A      ST	-Y,R25
    02C67 938A      ST	-Y,R24
    02C68 940E 41B8 CALL	asgnblk
(0157) 
(0158) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02C6A E089      LDI	R24,0x9
    02C6B E090      LDI	R25,0
    02C6C 850E      LDD	R16,Y+14
    02C6D 851F      LDD	R17,Y+15
    02C6E 8928      LDD	R18,Y+16
    02C6F 8939      LDD	R19,Y+17
    02C70 938A      ST	-Y,R24
    02C71 940E 4193 CALL	lsl32
    02C73 870E      STD	Y+14,R16
    02C74 871F      STD	Y+15,R17
    02C75 8B28      STD	Y+16,R18
    02C76 8B39      STD	Y+17,R19
(0159) 
(0160) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02C77 E188      LDI	R24,0x18
    02C78 E090      LDI	R25,0
    02C79 850E      LDD	R16,Y+14
    02C7A 851F      LDD	R17,Y+15
    02C7B 8928      LDD	R18,Y+16
    02C7C 8939      LDD	R19,Y+17
    02C7D 938A      ST	-Y,R24
    02C7E 940E 41AC CALL	lsr32
    02C80 8309      STD	Y+1,R16
(0161) 	 pcmd[2] = (addr>>16);
    02C81 842E      LDD	R2,Y+14
    02C82 843F      LDD	R3,Y+15
    02C83 8848      LDD	R4,Y+16
    02C84 8859      LDD	R5,Y+17
    02C85 0112      MOVW	R2,R4
    02C86 2444      CLR	R4
    02C87 2455      CLR	R5
    02C88 822A      STD	Y+2,R2
(0162) 	 pcmd[3] =(addr>>8);
    02C89 E088      LDI	R24,0x8
    02C8A E090      LDI	R25,0
    02C8B 850E      LDD	R16,Y+14
    02C8C 851F      LDD	R17,Y+15
    02C8D 8928      LDD	R18,Y+16
    02C8E 8939      LDD	R19,Y+17
    02C8F 938A      ST	-Y,R24
    02C90 940E 41AC CALL	lsr32
    02C92 830B      STD	Y+3,R16
(0163) 	// pcmd[4] = offset;
(0164) 
(0165) 	 SD_CS_EN();//打开片选 
    02C93 98C0      CBI	0x18,0
(0166) 
(0167) 	 do
(0168) 	 {  
(0169) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02C94 018E      MOVW	R16,R28
    02C95 DEA6      RCALL	_SD_Write_cmd
    02C96 2EC0      MOV	R12,R16
(0170) 		  time++;
    02C97 9563      INC	R22
(0171) 		  if(time==TRY_TIME) 
    02C98 3164      CPI	R22,0x14
    02C99 F421      BNE	0x2C9E
(0172) 		  {
(0173) 		   SD_CS_DIS();
    02C9A 9AC0      SBI	0x18,0
(0174) 		   return(READ_BLOCK_ERROR); //读块失败
    02C9B E004      LDI	R16,4
    02C9C E010      LDI	R17,0
    02C9D C01F      RJMP	0x2CBD
(0175) 		  }
(0176) 	 }while(temp!=0); 
    02C9E 20CC      TST	R12
    02C9F F7A1      BNE	0x2C94
(0177)    			
(0178) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02CA0 940E 393A CALL	_SPI_Read
    02CA2 3F0E      CPI	R16,0xFE
    02CA3 F7E1      BNE	0x2CA0
(0179)  		   	   	
(0180) 	 for(j=0;j<512;j++)	 //将数据写入到数据缓冲区中
    02CA4 2744      CLR	R20
    02CA5 2755      CLR	R21
    02CA6 C009      RJMP	0x2CB0
(0181) 	 {	
(0182) 	    buffer[j]=SPI_Read();
    02CA7 940E 393A CALL	_SPI_Read
    02CA9 2EC0      MOV	R12,R16
    02CAA 01FA      MOVW	R30,R20
    02CAB 0DEA      ADD	R30,R10
    02CAC 1DFB      ADC	R31,R11
    02CAD 82C0      ST	Z,R12
    02CAE 5F4F      SUBI	R20,0xFF
    02CAF 4F5F      SBCI	R21,0xFF
    02CB0 3040      CPI	R20,0
    02CB1 E0E2      LDI	R30,2
    02CB2 075E      CPC	R21,R30
    02CB3 F398      BCS	0x2CA7
(0183) 	 }
(0184) 
(0185) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02CB4 940E 393A CALL	_SPI_Read
(0186) 	 SPI_Read();
    02CB6 940E 393A CALL	_SPI_Read
(0187) 
(0188) 	 SD_CS_DIS();  //SD卡关闭片选 
    02CB8 9AC0      SBI	0x18,0
(0189) 
(0190) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02CB9 940E 393A CALL	_SPI_Read
(0191) 
(0192) 	 return SD_TURE;
    02CBB 2700      CLR	R16
    02CBC 2711      CLR	R17
    02CBD 9626      ADIW	R28,6
    02CBE 940E 4155 CALL	pop_xgsetF03C
    02CC0 9624      ADIW	R28,4
    02CC1 9508      RET
_SD_Read_Sector_ndata:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  len                  --> R14
  offset               --> R10
  buffer               --> Y,+20
  addr                 --> Y,+16
    02CC2 940E 3FCC CALL	push_arg4
    02CC4 940E 4111 CALL	push_xgsetF0FC
    02CC6 9726      SBIW	R28,6
    02CC7 88AE      LDD	R10,Y+22
    02CC8 88BF      LDD	R11,Y+23
    02CC9 8CE8      LDD	R14,Y+24
    02CCA 8CF9      LDD	R15,Y+25
(0193) }
(0194) //****************************************************************
(0195) //*隶属模块：SD卡控制
(0196) //*函数功能：写多扇区数据（多扇区字节）
(0197) //****************************************************************
(0198) UINT16 SD_Read_Sector_ndata(UINT32 addr,UINT8 *buffer,UINT16 offset,UINT16 len)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0199) {
(0200) 
(0201) 	 UINT16 j=0;
    02CCB 2744      CLR	R20
    02CCC 2755      CLR	R21
(0202) 	 UINT8 time=0,temp=0;
    02CCD 2766      CLR	R22
    02CCE 24CC      CLR	R12
(0203) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02CCF E58C      LDI	R24,0x5C
    02CD0 E092      LDI	R25,2
    02CD1 01FE      MOVW	R30,R28
    02CD2 E006      LDI	R16,6
    02CD3 E010      LDI	R17,0
    02CD4 93FA      ST	-Y,R31
    02CD5 93EA      ST	-Y,R30
    02CD6 939A      ST	-Y,R25
    02CD7 938A      ST	-Y,R24
    02CD8 940E 41B8 CALL	asgnblk
(0204) 
(0205) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02CDA E089      LDI	R24,0x9
    02CDB E090      LDI	R25,0
    02CDC 8908      LDD	R16,Y+16
    02CDD 8919      LDD	R17,Y+17
    02CDE 892A      LDD	R18,Y+18
    02CDF 893B      LDD	R19,Y+19
    02CE0 938A      ST	-Y,R24
    02CE1 940E 4193 CALL	lsl32
    02CE3 8B08      STD	Y+16,R16
    02CE4 8B19      STD	Y+17,R17
    02CE5 8B2A      STD	Y+18,R18
    02CE6 8B3B      STD	Y+19,R19
(0206) 
(0207) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02CE7 E188      LDI	R24,0x18
    02CE8 E090      LDI	R25,0
    02CE9 8908      LDD	R16,Y+16
    02CEA 8919      LDD	R17,Y+17
    02CEB 892A      LDD	R18,Y+18
    02CEC 893B      LDD	R19,Y+19
    02CED 938A      ST	-Y,R24
    02CEE 940E 41AC CALL	lsr32
    02CF0 8309      STD	Y+1,R16
(0208) 	 pcmd[2] = (addr>>16);
    02CF1 8828      LDD	R2,Y+16
    02CF2 8839      LDD	R3,Y+17
    02CF3 884A      LDD	R4,Y+18
    02CF4 885B      LDD	R5,Y+19
    02CF5 0112      MOVW	R2,R4
    02CF6 2444      CLR	R4
    02CF7 2455      CLR	R5
    02CF8 822A      STD	Y+2,R2
(0209) 	 pcmd[3] =(addr>>8);
    02CF9 E088      LDI	R24,0x8
    02CFA E090      LDI	R25,0
    02CFB 8908      LDD	R16,Y+16
    02CFC 8919      LDD	R17,Y+17
    02CFD 892A      LDD	R18,Y+18
    02CFE 893B      LDD	R19,Y+19
    02CFF 938A      ST	-Y,R24
    02D00 940E 41AC CALL	lsr32
    02D02 830B      STD	Y+3,R16
(0210) 	// pcmd[4] = offset;
(0211) 
(0212) 	 SD_CS_EN();//打开片选 
    02D03 98C0      CBI	0x18,0
(0213) 
(0214) 	 do
(0215) 	 {  
(0216) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02D04 018E      MOVW	R16,R28
    02D05 DE36      RCALL	_SD_Write_cmd
    02D06 2EC0      MOV	R12,R16
(0217) 		  time++;
    02D07 9563      INC	R22
(0218) 		  if(time==TRY_TIME) 
    02D08 3164      CPI	R22,0x14
    02D09 F421      BNE	0x2D0E
(0219) 		  {
(0220) 		   SD_CS_DIS();
    02D0A 9AC0      SBI	0x18,0
(0221) 		   return(READ_BLOCK_ERROR); //读块失败
    02D0B E004      LDI	R16,4
    02D0C E010      LDI	R17,0
    02D0D C034      RJMP	0x2D42
(0222) 		  }
(0223) 	 }while(temp!=0); 
    02D0E 20CC      TST	R12
    02D0F F7A1      BNE	0x2D04
(0224)    			
(0225) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02D10 940E 393A CALL	_SPI_Read
    02D12 3F0E      CPI	R16,0xFE
    02D13 F7E1      BNE	0x2D10
(0226)  		   	   	
(0227) 	 for(j=0;j<offset;j++)	 //将数据写入到数据缓冲区中
    02D14 2744      CLR	R20
    02D15 2755      CLR	R21
    02D16 C004      RJMP	0x2D1B
(0228) 	    SPI_Read();
    02D17 940E 393A CALL	_SPI_Read
    02D19 5F4F      SUBI	R20,0xFF
    02D1A 4F5F      SBCI	R21,0xFF
    02D1B 154A      CP	R20,R10
    02D1C 055B      CPC	R21,R11
    02D1D F3C8      BCS	0x2D17
(0229) 	 for(;j<offset+len;j++)	 
    02D1E C00B      RJMP	0x2D2A
(0230) 		buffer[j]=SPI_Read();
    02D1F 940E 393A CALL	_SPI_Read
    02D21 2F60      MOV	R22,R16
    02D22 01FA      MOVW	R30,R20
    02D23 880C      LDD	R0,Y+20
    02D24 881D      LDD	R1,Y+21
    02D25 0DE0      ADD	R30,R0
    02D26 1DF1      ADC	R31,R1
    02D27 8360      ST	Z,R22
    02D28 5F4F      SUBI	R20,0xFF
    02D29 4F5F      SBCI	R21,0xFF
    02D2A 0115      MOVW	R2,R10
    02D2B 0C2E      ADD	R2,R14
    02D2C 1C3F      ADC	R3,R15
    02D2D 1542      CP	R20,R2
    02D2E 0553      CPC	R21,R3
    02D2F F378      BCS	0x2D1F
(0231) 	 for(;j<512;j++)	 
    02D30 C004      RJMP	0x2D35
(0232) 		SPI_Read();
    02D31 940E 393A CALL	_SPI_Read
    02D33 5F4F      SUBI	R20,0xFF
    02D34 4F5F      SBCI	R21,0xFF
    02D35 3040      CPI	R20,0
    02D36 E0E2      LDI	R30,2
    02D37 075E      CPC	R21,R30
    02D38 F3C0      BCS	0x2D31
(0233) 
(0234) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02D39 940E 393A CALL	_SPI_Read
(0235) 	 SPI_Read();
    02D3B 940E 393A CALL	_SPI_Read
(0236) 
(0237) 	 SD_CS_DIS();  //SD卡关闭片选 
    02D3D 9AC0      SBI	0x18,0
(0238) 
(0239) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02D3E 940E 393A CALL	_SPI_Read
(0240) 
(0241) 	 return SD_TURE;
    02D40 2700      CLR	R16
    02D41 2711      CLR	R17
    02D42 9626      ADIW	R28,6
    02D43 940E 4106 CALL	pop_xgsetF0FC
    02D45 9624      ADIW	R28,4
    02D46 9508      RET
_GUI_mainmeu:
  key                  --> R22
  select               --> R20
    02D47 934A      ST	-Y,R20
    02D48 936A      ST	-Y,R22
    02D49 9723      SBIW	R28,3
FILE: D:\LQD\software\master\software_src\gui.c
(0001) #include "config.h"
(0002) const char labelH[]="高强度作业：\0";
(0003) const char labelM[]="中等强度作业：\0";
(0004) const char labelL[]="低强度作业：\0";
(0005) const char H01[]="加强劳动监督；\0";
(0006) const char H02[]="增加饮水;\0" ;
(0007) const char H03[]="保持干燥禁裸露。\0";
(0008) #define M01 H01
(0009) #define M02 H03
(0010) const char M03[]="戴面罩。\0";
(0011) const char M04[]="禁油彩。\0";
(0012) #define L01 M03
(0013) #define L02 M04
(0014) const char L03[]="缩短作业时间。";
(0015) //-----//
(0016) #define H11 M04
(0017) #define H12 H03
(0018) const char H13[]="休息注意保暖。\0";
(0019) #define M11 H01
(0020) const char M12[]="减少非必须作业；\0";
(0021) const char M13[]="劳动时间<30min。\0";
(0022) const char L11[]="取消非必须的作业\0";
(0023) const char L12[]="劳动时间<15min；\0";
(0024) #define L13 H03
(0025) //-----//
(0026) #define H21 L11
(0027) #define H22 L12
(0028) #define H23 H03
(0029) const char M21[]="取消户外作业。"; 
(0030) #define L21 M21
(0031) 
(0032) //#define LEDON   PORTC&=~(1<<7)					   
(0033) //#define LEDOFF  PINC|=(1<<7)
(0034) char GUI_date[17]="09月19日18:00:00\0";
(0035) 
(0036) // 主菜单
(0037) unsigned char GUI_mainmeu( void ){
(0038)  	unsigned char key=0; //init= nokey
    02D4A 2766      CLR	R22
(0039) 	unsigned char select=3;
    02D4B E043      LDI	R20,3
(0040) 	LCD_CLR();
    02D4C 940E 3A1A CALL	_LCD_CLR
(0041)  	Set_White(1,1,8,1);
    02D4E E081      LDI	R24,1
    02D4F 838A      STD	Y+2,R24
    02D50 E088      LDI	R24,0x8
    02D51 8388      ST	Y,R24
    02D52 E021      LDI	R18,1
    02D53 E001      LDI	R16,1
    02D54 940E 3AA4 CALL	_Set_White
(0042) 	Set_White(1,2,8,1);
    02D56 E081      LDI	R24,1
    02D57 838A      STD	Y+2,R24
    02D58 E088      LDI	R24,0x8
    02D59 8388      ST	Y,R24
    02D5A E022      LDI	R18,2
    02D5B E001      LDI	R16,1
    02D5C 940E 3AA4 CALL	_Set_White
(0043) 	Set_White(1,3,8,1);
    02D5E E081      LDI	R24,1
    02D5F 838A      STD	Y+2,R24
    02D60 E088      LDI	R24,0x8
    02D61 8388      ST	Y,R24
    02D62 E023      LDI	R18,3
    02D63 E001      LDI	R16,1
    02D64 940E 3AA4 CALL	_Set_White
(0044) 	Set_White(1,4,8,1);
    02D66 E081      LDI	R24,1
    02D67 838A      STD	Y+2,R24
    02D68 E088      LDI	R24,0x8
    02D69 8388      ST	Y,R24
    02D6A E024      LDI	R18,4
    02D6B E001      LDI	R16,1
    02D6C 940E 3AA4 CALL	_Set_White
(0045) 	LCD_const_disp(2,1,"  检测  时钟调整");
    02D6E ED86      LDI	R24,0xD6
    02D6F E094      LDI	R25,4
    02D70 8399      STD	Y+1,R25
    02D71 8388      ST	Y,R24
    02D72 E021      LDI	R18,1
    02D73 E002      LDI	R16,2
    02D74 940E 3974 CALL	_LCD_const_disp
(0046) 	LCD_const_disp(3,1,"  查询  数据传输");
    02D76 EC85      LDI	R24,0xC5
    02D77 E094      LDI	R25,4
    02D78 8399      STD	Y+1,R25
    02D79 8388      ST	Y,R24
    02D7A E021      LDI	R18,1
    02D7B E003      LDI	R16,3
    02D7C 940E 3974 CALL	_LCD_const_disp
(0047) 	LCD_const_disp(4,1,"  初始化");
    02D7E EB8C      LDI	R24,0xBC
    02D7F E094      LDI	R25,4
    02D80 8399      STD	Y+1,R25
    02D81 8388      ST	Y,R24
    02D82 E021      LDI	R18,1
    02D83 E004      LDI	R16,4
    02D84 940E 3974 CALL	_LCD_const_disp
(0048) 	Set_White(1,1,8,1);
    02D86 E081      LDI	R24,1
    02D87 838A      STD	Y+2,R24
    02D88 E088      LDI	R24,0x8
    02D89 8388      ST	Y,R24
    02D8A E021      LDI	R18,1
    02D8B E001      LDI	R16,1
    02D8C 940E 3AA4 CALL	_Set_White
(0049) 	Set_White(1,2,8,1);
    02D8E E081      LDI	R24,1
    02D8F 838A      STD	Y+2,R24
    02D90 E088      LDI	R24,0x8
    02D91 8388      ST	Y,R24
    02D92 E022      LDI	R18,2
    02D93 E001      LDI	R16,1
    02D94 940E 3AA4 CALL	_Set_White
(0050) 	Set_White(1,3,8,1);
    02D96 E081      LDI	R24,1
    02D97 838A      STD	Y+2,R24
    02D98 E088      LDI	R24,0x8
    02D99 8388      ST	Y,R24
    02D9A E023      LDI	R18,3
    02D9B E001      LDI	R16,1
    02D9C 940E 3AA4 CALL	_Set_White
(0051) 	Set_White(1,4,8,1);
    02D9E E081      LDI	R24,1
    02D9F 838A      STD	Y+2,R24
    02DA0 E088      LDI	R24,0x8
    02DA1 8388      ST	Y,R24
    02DA2 E024      LDI	R18,4
    02DA3 E001      LDI	R16,1
    02DA4 940E 3AA4 CALL	_Set_White
(0052) 	set_white_n(select,0);
    02DA6 2722      CLR	R18
    02DA7 2F04      MOV	R16,R20
    02DA8 940E 3B36 CALL	_set_white_n
    02DAA C07C      RJMP	0x2E27
(0053) 	while(1)
(0054) 	{
(0055) 	 	key=kbscan();
    02DAB 940E 3F63 CALL	_kbscan
    02DAD 2F60      MOV	R22,R16
(0056) 		dateRefresh(1); //更新系统时间
    02DAE E001      LDI	R16,1
    02DAF 940E 35F6 CALL	_dateRefresh
(0057) 		LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02DB1 D494      RCALL	_GUI_get_date
    02DB2 8319      STD	Y+1,R17
    02DB3 8308      ST	Y,R16
    02DB4 E021      LDI	R18,1
    02DB5 E001      LDI	R16,1
    02DB6 940E 3974 CALL	_LCD_const_disp
(0058) 		if((select>3) && ( key==up ) ){
    02DB8 E083      LDI	R24,3
    02DB9 1784      CP	R24,R20
    02DBA F4F8      BCC	0x2DDA
    02DBB 316E      CPI	R22,0x1E
    02DBC F4E9      BNE	0x2DDA
(0059) 		 Set_White(1,2,8,1);
    02DBD E081      LDI	R24,1
    02DBE 838A      STD	Y+2,R24
    02DBF E088      LDI	R24,0x8
    02DC0 8388      ST	Y,R24
    02DC1 E022      LDI	R18,2
    02DC2 E001      LDI	R16,1
    02DC3 940E 3AA4 CALL	_Set_White
(0060) 		 Set_White(1,3,8,1);
    02DC5 E081      LDI	R24,1
    02DC6 838A      STD	Y+2,R24
    02DC7 E088      LDI	R24,0x8
    02DC8 8388      ST	Y,R24
    02DC9 E023      LDI	R18,3
    02DCA E001      LDI	R16,1
    02DCB 940E 3AA4 CALL	_Set_White
(0061) 		 Set_White(1,4,8,1);
    02DCD E081      LDI	R24,1
    02DCE 838A      STD	Y+2,R24
    02DCF E088      LDI	R24,0x8
    02DD0 8388      ST	Y,R24
    02DD1 E024      LDI	R18,4
    02DD2 E001      LDI	R16,1
    02DD3 940E 3AA4 CALL	_Set_White
(0062) 		 select--;
    02DD5 954A      DEC	R20
(0063) 		 set_white_n(select,0);
    02DD6 2722      CLR	R18
    02DD7 2F04      MOV	R16,R20
    02DD8 940E 3B36 CALL	_set_white_n
(0064) 		}
(0065) 		if((select<7) && ( key==down ) ){
    02DDA 3047      CPI	R20,7
    02DDB F538      BCC	0x2E03
    02DDC 316D      CPI	R22,0x1D
    02DDD F529      BNE	0x2E03
(0066) 		 Set_White(1,1,8,1);
    02DDE E081      LDI	R24,1
    02DDF 838A      STD	Y+2,R24
    02DE0 E088      LDI	R24,0x8
    02DE1 8388      ST	Y,R24
    02DE2 E021      LDI	R18,1
    02DE3 E001      LDI	R16,1
    02DE4 940E 3AA4 CALL	_Set_White
(0067) 		 Set_White(1,2,8,1);
    02DE6 E081      LDI	R24,1
    02DE7 838A      STD	Y+2,R24
    02DE8 E088      LDI	R24,0x8
    02DE9 8388      ST	Y,R24
    02DEA E022      LDI	R18,2
    02DEB E001      LDI	R16,1
    02DEC 940E 3AA4 CALL	_Set_White
(0068) 		 Set_White(1,3,8,1);
    02DEE E081      LDI	R24,1
    02DEF 838A      STD	Y+2,R24
    02DF0 E088      LDI	R24,0x8
    02DF1 8388      ST	Y,R24
    02DF2 E023      LDI	R18,3
    02DF3 E001      LDI	R16,1
    02DF4 940E 3AA4 CALL	_Set_White
(0069) 		 Set_White(1,4,8,1);
    02DF6 E081      LDI	R24,1
    02DF7 838A      STD	Y+2,R24
    02DF8 E088      LDI	R24,0x8
    02DF9 8388      ST	Y,R24
    02DFA E024      LDI	R18,4
    02DFB E001      LDI	R16,1
    02DFC 940E 3AA4 CALL	_Set_White
(0070) 		 select++;
    02DFE 9543      INC	R20
(0071) 		 set_white_n(select,0);
    02DFF 2722      CLR	R18
    02E00 2F04      MOV	R16,R20
    02E01 940E 3B36 CALL	_set_white_n
(0072) 		}
(0073) 		if(key == left ){
    02E03 316B      CPI	R22,0x1B
    02E04 F511      BNE	0x2E27
(0074) 		 Set_White(1,1,8,1);
    02E05 E081      LDI	R24,1
    02E06 838A      STD	Y+2,R24
    02E07 E088      LDI	R24,0x8
    02E08 8388      ST	Y,R24
    02E09 E021      LDI	R18,1
    02E0A E001      LDI	R16,1
    02E0B 940E 3AA4 CALL	_Set_White
(0075) 		 Set_White(1,2,8,1);
    02E0D E081      LDI	R24,1
    02E0E 838A      STD	Y+2,R24
    02E0F E088      LDI	R24,0x8
    02E10 8388      ST	Y,R24
    02E11 E022      LDI	R18,2
    02E12 E001      LDI	R16,1
    02E13 940E 3AA4 CALL	_Set_White
(0076) 		 Set_White(1,3,8,1);
    02E15 E081      LDI	R24,1
    02E16 838A      STD	Y+2,R24
    02E17 E088      LDI	R24,0x8
    02E18 8388      ST	Y,R24
    02E19 E023      LDI	R18,3
    02E1A E001      LDI	R16,1
    02E1B 940E 3AA4 CALL	_Set_White
(0077) 		 Set_White(1,4,8,1);
    02E1D E081      LDI	R24,1
    02E1E 838A      STD	Y+2,R24
    02E1F E088      LDI	R24,0x8
    02E20 8388      ST	Y,R24
    02E21 E024      LDI	R18,4
    02E22 E001      LDI	R16,1
    02E23 940E 3AA4 CALL	_Set_White
(0078) 		 //beep(3,select);
(0079) 		 return select;
    02E25 2F04      MOV	R16,R20
    02E26 C001      RJMP	0x2E28
    02E27 CF83      RJMP	0x2DAB
    02E28 9623      ADIW	R28,3
    02E29 9169      LD	R22,Y+
    02E2A 9149      LD	R20,Y+
    02E2B 9508      RET
_GUI_check:
  next_step_time       --> Y,+3
  windcounter          --> R10
  selectCheckMode      --> R14
  is_on                --> Y,+8
  page                 --> Y,+7
  key                  --> R12
    02E2C 940E 4111 CALL	push_xgsetF0FC
    02E2E 9729      SBIW	R28,0x9
(0080) 		}
(0081)     }
(0082) 	return 0xff; //error
(0083) 	
(0084) }
(0085) 
(0086) //”检测 “菜单
(0087) void GUI_check(void){
(0088)     char key;
(0089) 	char page=0,is_on=0;
    02E2F 2400      CLR	R0
    02E30 820F      STD	Y+7,R0
    02E31 8608      STD	Y+8,R0
(0090) 	char windcounter=0;
    02E32 24AA      CLR	R10
(0091) 	unsigned long next_step_time=0;
    02E33 E080      LDI	R24,0
    02E34 838B      STD	Y+3,R24
    02E35 838C      STD	Y+4,R24
    02E36 838D      STD	Y+5,R24
    02E37 838E      STD	Y+6,R24
(0092) 	char selectCheckMode=config.autocheck; //自动检测开关
    02E38 90E0 07DF LDS	R14,config+16
(0093) RE_IN:
(0094) 	dateRefresh(1);
    02E3A E001      LDI	R16,1
    02E3B D7BA      RCALL	_dateRefresh
(0095) 	LCD_CLR();
    02E3C 940E 3A1A CALL	_LCD_CLR
(0096) 	LCD_const_disp(1,1,"菜单/ 检测");
    02E3E EB81      LDI	R24,0xB1
    02E3F E094      LDI	R25,4
    02E40 8399      STD	Y+1,R25
    02E41 8388      ST	Y,R24
    02E42 E021      LDI	R18,1
    02E43 E001      LDI	R16,1
    02E44 940E 3974 CALL	_LCD_const_disp
(0097) 	LCD_const_disp(2,3,"自动");		 
    02E46 EA8C      LDI	R24,0xAC
    02E47 E094      LDI	R25,4
    02E48 8399      STD	Y+1,R25
    02E49 8388      ST	Y,R24
    02E4A E023      LDI	R18,3
    02E4B E002      LDI	R16,2
    02E4C 940E 3974 CALL	_LCD_const_disp
(0098) 	LCD_const_disp(3,3,"手动");
    02E4E EA87      LDI	R24,0xA7
    02E4F E094      LDI	R25,4
    02E50 8399      STD	Y+1,R25
    02E51 8388      ST	Y,R24
    02E52 E023      LDI	R18,3
    02E53 E003      LDI	R16,3
    02E54 940E 3974 CALL	_LCD_const_disp
(0099) 	if(selectCheckMode==1) {
    02E56 2D8E      MOV	R24,R14
    02E57 3081      CPI	R24,1
    02E58 F489      BNE	0x2E6A
(0100) 	    Set_White(1,2,8,0);
    02E59 2422      CLR	R2
    02E5A 822A      STD	Y+2,R2
    02E5B E088      LDI	R24,0x8
    02E5C 8388      ST	Y,R24
    02E5D E022      LDI	R18,2
    02E5E E001      LDI	R16,1
    02E5F 940E 3AA4 CALL	_Set_White
(0101) 		Set_White(1,3,8,1);
    02E61 E081      LDI	R24,1
    02E62 838A      STD	Y+2,R24
    02E63 E088      LDI	R24,0x8
    02E64 8388      ST	Y,R24
    02E65 E023      LDI	R18,3
    02E66 E001      LDI	R16,1
    02E67 940E 3AA4 CALL	_Set_White
(0102) 	}
    02E69 C05B      RJMP	0x2EC5
(0103) 	else {
(0104) 		 Set_White(1,2,8,1);
    02E6A E081      LDI	R24,1
    02E6B 838A      STD	Y+2,R24
    02E6C E088      LDI	R24,0x8
    02E6D 8388      ST	Y,R24
    02E6E E022      LDI	R18,2
    02E6F E001      LDI	R16,1
    02E70 940E 3AA4 CALL	_Set_White
(0105) 		 Set_White(1,3,8,0);
    02E72 2422      CLR	R2
    02E73 822A      STD	Y+2,R2
    02E74 E088      LDI	R24,0x8
    02E75 8388      ST	Y,R24
    02E76 E023      LDI	R18,3
    02E77 E001      LDI	R16,1
    02E78 940E 3AA4 CALL	_Set_White
(0106) 	}
    02E7A C04A      RJMP	0x2EC5
(0107) 	
(0108) //<<菜单/检测/手（自）动>>
(0109) 	while(1){
(0110) 	 	key=kbscan();
    02E7B 940E 3F63 CALL	_kbscan
    02E7D 2EC0      MOV	R12,R16
(0111) 		//上键短按 选择
(0112) 		if(key==up || key ==down){
    02E7E 2D8C      MOV	R24,R12
    02E7F 310E      CPI	R16,0x1E
    02E80 F011      BEQ	0x2E83
    02E81 310D      CPI	R16,0x1D
    02E82 F539      BNE	0x2EAA
(0113) 		    if(selectCheckMode >0){
    02E83 E080      LDI	R24,0
    02E84 158E      CP	R24,R14
    02E85 F490      BCC	0x2E98
(0114) 			    selectCheckMode=0;
    02E86 24EE      CLR	R14
(0115) 				Set_White(1,2,8,1);
    02E87 E081      LDI	R24,1
    02E88 838A      STD	Y+2,R24
    02E89 E088      LDI	R24,0x8
    02E8A 8388      ST	Y,R24
    02E8B E022      LDI	R18,2
    02E8C E001      LDI	R16,1
    02E8D 940E 3AA4 CALL	_Set_White
(0116) 	 			Set_White(1,3,8,0);
    02E8F 2422      CLR	R2
    02E90 822A      STD	Y+2,R2
    02E91 E088      LDI	R24,0x8
    02E92 8388      ST	Y,R24
    02E93 E023      LDI	R18,3
    02E94 E001      LDI	R16,1
    02E95 940E 3AA4 CALL	_Set_White
(0117) 			}
    02E97 C012      RJMP	0x2EAA
(0118) 			else {
(0119) 			    selectCheckMode=1;
    02E98 24EE      CLR	R14
    02E99 94E3      INC	R14
(0120) 				Set_White(1,2,8,0);
    02E9A 2422      CLR	R2
    02E9B 822A      STD	Y+2,R2
    02E9C E088      LDI	R24,0x8
    02E9D 8388      ST	Y,R24
    02E9E E022      LDI	R18,2
    02E9F E001      LDI	R16,1
    02EA0 940E 3AA4 CALL	_Set_White
(0121) 	 			Set_White(1,3,8,1);
    02EA2 E081      LDI	R24,1
    02EA3 838A      STD	Y+2,R24
    02EA4 E088      LDI	R24,0x8
    02EA5 8388      ST	Y,R24
    02EA6 E023      LDI	R18,3
    02EA7 E001      LDI	R16,1
    02EA8 940E 3AA4 CALL	_Set_White
(0122) 			}
(0123) 			
(0124) 		}
(0125) 		//左键短按  进入
(0126) 		if(key == left) {
    02EAA 2D8C      MOV	R24,R12
    02EAB 318B      CPI	R24,0x1B
    02EAC F499      BNE	0x2EC0
(0127) 			config.autocheck=selectCheckMode; 
    02EAD 92E0 07DF STS	config+16,R14
(0128) 			Set_White(1,2,8,1);
    02EAF E081      LDI	R24,1
    02EB0 838A      STD	Y+2,R24
    02EB1 E088      LDI	R24,0x8
    02EB2 8388      ST	Y,R24
    02EB3 E022      LDI	R18,2
    02EB4 E001      LDI	R16,1
    02EB5 940E 3AA4 CALL	_Set_White
(0129) 	 		Set_White(1,3,8,1); 
    02EB7 E081      LDI	R24,1
    02EB8 838A      STD	Y+2,R24
    02EB9 E088      LDI	R24,0x8
    02EBA 8388      ST	Y,R24
    02EBB E023      LDI	R18,3
    02EBC E001      LDI	R16,1
    02EBD 940E 3AA4 CALL	_Set_White
(0130) 			break ;		
    02EBF C006      RJMP	0x2EC6
(0131) 		}
(0132) 		//右键短按  返回
(0133) 		if(key == right) {
    02EC0 2D8C      MOV	R24,R12
    02EC1 3187      CPI	R24,0x17
    02EC2 F409      BNE	0x2EC4
(0134) 			return ;		
    02EC3 C173      RJMP	0x3037
(0135) 		}
(0136) 		key=0;
    02EC4 24CC      CLR	R12
    02EC5 CFB5      RJMP	0x2E7B
(0137) 	} //end of while
(0138)     //自动开启检测
(0139) 	dateRefresh(0);
    02EC6 2700      CLR	R16
    02EC7 D72E      RCALL	_dateRefresh
(0140) 	is_on =1 ;
    02EC8 2400      CLR	R0
    02EC9 9403      INC	R0
    02ECA 8608      STD	Y+8,R0
(0141) 	config.time1=config.now+config.THRESHOLD_delta_sec;
    02ECB 9040 07D5 LDS	R4,config+6
    02ECD 9050 07D6 LDS	R5,config+7
    02ECF 9020 07D3 LDS	R2,config+4
    02ED1 9030 07D4 LDS	R3,config+5
    02ED3 9080 07DD LDS	R8,config+14
    02ED5 9090 07DE LDS	R9,config+15
    02ED7 9060 07DB LDS	R6,config+12
    02ED9 9070 07DC LDS	R7,config+13
    02EDB 0C62      ADD	R6,R2
    02EDC 1C73      ADC	R7,R3
    02EDD 1C84      ADC	R8,R4
    02EDE 1C95      ADC	R9,R5
    02EDF 9270 07D8 STS	config+9,R7
    02EE1 9260 07D7 STS	config+8,R6
    02EE3 9290 07DA STS	config+11,R9
    02EE5 9280 07D9 STS	config+10,R8
(0142) 	Result.TempChar[0]=0; //清除上次结果
    02EE7 2422      CLR	R2
    02EE8 9220 058C STS	Result+45,R2
(0143) 	Result.WSChar[0]=0;
    02EEA 9220 0596 STS	Result+55,R2
    02EEC C149      RJMP	0x3036
(0144) 	while(1){
(0145) 		key=kbscan();
    02EED 940E 3F63 CALL	_kbscan
    02EEF 2EC0      MOV	R12,R16
(0146) 		if(key != 0) beep(0,1);
    02EF0 2300      TST	R16
    02EF1 F021      BEQ	0x2EF6
    02EF2 E021      LDI	R18,1
    02EF3 2700      CLR	R16
    02EF4 940E 3CEF CALL	_beep
(0147) 		if(key==right){	//右键 退出
    02EF6 2D8C      MOV	R24,R12
    02EF7 3187      CPI	R24,0x17
    02EF8 F569      BNE	0x2F26
(0148) 		    is_on=0;
    02EF9 2400      CLR	R0
    02EFA 8608      STD	Y+8,R0
(0149) 			LCD_CLR();
    02EFB 940E 3A1A CALL	_LCD_CLR
(0150) 		 	LCD_Init();	  
    02EFD 940E 39E8 CALL	_LCD_Init
(0151) 	 	 	LCD_const_disp(4,5,"退出    "); 
    02EFF E98E      LDI	R24,0x9E
    02F00 E094      LDI	R25,4
    02F01 8399      STD	Y+1,R25
    02F02 8388      ST	Y,R24
    02F03 E025      LDI	R18,5
    02F04 E004      LDI	R16,4
    02F05 940E 3974 CALL	_LCD_const_disp
(0152) 		 	delayms(200);
    02F07 EC08      LDI	R16,0xC8
    02F08 E010      LDI	R17,0
    02F09 940E 240B CALL	_delayms
(0153) 		 	LCD_const_disp(4,7,".."); 
    02F0B E98B      LDI	R24,0x9B
    02F0C E094      LDI	R25,4
    02F0D 8399      STD	Y+1,R25
    02F0E 8388      ST	Y,R24
    02F0F E027      LDI	R18,7
    02F10 E004      LDI	R16,4
    02F11 940E 3974 CALL	_LCD_const_disp
(0154) 		 	delayms(200);
    02F13 EC08      LDI	R16,0xC8
    02F14 E010      LDI	R17,0
    02F15 940E 240B CALL	_delayms
(0155) 		 	LCD_const_disp(4,8,".."); 	
    02F17 E98B      LDI	R24,0x9B
    02F18 E094      LDI	R25,4
    02F19 8399      STD	Y+1,R25
    02F1A 8388      ST	Y,R24
    02F1B E028      LDI	R18,0x8
    02F1C E004      LDI	R16,4
    02F1D 940E 3974 CALL	_LCD_const_disp
(0156) 		 	delayms(500);
    02F1F EF04      LDI	R16,0xF4
    02F20 E011      LDI	R17,1
    02F21 940E 240B CALL	_delayms
(0157) 		 	LCD_CLR();
    02F23 940E 3A1A CALL	_LCD_CLR
(0158) 		 	goto RE_IN;
    02F25 CF14      RJMP	0x2E3A
(0159) 		}
(0160) 		if(is_on==1){ 
    02F26 8588      LDD	R24,Y+8
    02F27 3081      CPI	R24,1
    02F28 F009      BEQ	0x2F2A
    02F29 C08B      RJMP	0x2FB5
(0161) 			dateRefresh(1); 
    02F2A E001      LDI	R16,1
    02F2B D6CA      RCALL	_dateRefresh
(0162) 		    _GUI_datashow(page); //更新时间
    02F2C 810F      LDD	R16,Y+7
    02F2D D10C      RCALL	__GUI_datashow
(0163) 		    if(config.now < config.time1) {
    02F2E 9040 07D9 LDS	R4,config+10
    02F30 9050 07DA LDS	R5,config+11
    02F32 9020 07D7 LDS	R2,config+8
    02F34 9030 07D8 LDS	R3,config+9
    02F36 9080 07DD LDS	R8,config+14
    02F38 9090 07DE LDS	R9,config+15
    02F3A 9060 07DB LDS	R6,config+12
    02F3C 9070 07DC LDS	R7,config+13
    02F3E 1462      CP	R6,R2
    02F3F 0473      CPC	R7,R3
    02F40 0484      CPC	R8,R4
    02F41 0495      CPC	R9,R5
    02F42 F598      BCC	0x2F76
(0164) 				//时间更新 开启风速检测 等待检测 不支持翻页
(0165) 				if(windcounter==0){
    02F43 20AA      TST	R10
    02F44 F421      BNE	0x2F49
(0166) 				    windcounter=1; //清零开启风速计数器
    02F45 24AA      CLR	R10
    02F46 94A3      INC	R10
(0167) 					timer1_init(); //开启风速传感器技术
    02F47 940E 2457 CALL	_timer1_init
(0168) 				}
(0169) 				if(page == 0 ){
    02F49 800F      LDD	R0,Y+7
    02F4A 2000      TST	R0
    02F4B F009      BEQ	0x2F4D
    02F4C C0E5      RJMP	0x3032
(0170) 				
(0171) 				    LCD_const_disp(4,1,"正在检测");
    02F4D E982      LDI	R24,0x92
    02F4E E094      LDI	R25,4
    02F4F 8399      STD	Y+1,R25
    02F50 8388      ST	Y,R24
    02F51 E021      LDI	R18,1
    02F52 E004      LDI	R16,4
    02F53 940E 3974 CALL	_LCD_const_disp
(0172) 					LCD_print4num(4,5,config.time1-config.now);
    02F55 9020 07DB LDS	R2,config+12
    02F57 9030 07DC LDS	R3,config+13
    02F59 9040 07D7 LDS	R4,config+8
    02F5B 9050 07D8 LDS	R5,config+9
    02F5D 1842      SUB	R4,R2
    02F5E 0853      SBC	R5,R3
    02F5F 8259      STD	Y+1,R5
    02F60 8248      ST	Y,R4
    02F61 E025      LDI	R18,5
    02F62 E004      LDI	R16,4
    02F63 940E 3C36 CALL	_LCD_print4num
(0173) 					LCD_const_disp(2,6,"      ");
    02F65 E88B      LDI	R24,0x8B
    02F66 E094      LDI	R25,4
    02F67 8399      STD	Y+1,R25
    02F68 8388      ST	Y,R24
    02F69 E026      LDI	R18,6
    02F6A E002      LDI	R16,2
    02F6B 940E 3974 CALL	_LCD_const_disp
(0174) 					LCD_const_disp(3,6,"      ");
    02F6D E88B      LDI	R24,0x8B
    02F6E E094      LDI	R25,4
    02F6F 8399      STD	Y+1,R25
    02F70 8388      ST	Y,R24
    02F71 E026      LDI	R18,6
    02F72 E003      LDI	R16,3
    02F73 940E 3974 CALL	_LCD_const_disp
(0175) 				}
(0176) 			} 
    02F75 C0BC      RJMP	0x3032
(0177) 			else {
(0178) 			   //检测完成 获得数据 转换数据 存储数据 切换到非检测状态
(0179) 			    windcounter =0 ; //关闭风速传感器计数器
    02F76 24AA      CLR	R10
(0180) 				check();
    02F77 940E 281C CALL	_check
(0181) 				StructToChar(); //转成字符串
    02F79 940E 299B CALL	_StructToChar
(0182) 				WriteFileHead();//重写文件头
    02F7B 940E 2579 CALL	_WriteFileHead
(0183) 				WriteSDFile();  //写入sd卡
    02F7D 940E 25F5 CALL	_WriteSDFile
(0184) 				//zigbee_send(); //发送
(0185) 				Result.Index++; //索引自增一
    02F7F E041      LDI	R20,1
    02F80 E050      LDI	R21,0
    02F81 E060      LDI	R22,0
    02F82 E070      LDI	R23,0
    02F83 9040 056B LDS	R4,Result+12
    02F85 9050 056C LDS	R5,Result+13
    02F87 9020 0569 LDS	R2,Result+10
    02F89 9030 056A LDS	R3,Result+11
    02F8B 0E24      ADD	R2,R20
    02F8C 1E35      ADC	R3,R21
    02F8D 1E46      ADC	R4,R22
    02F8E 1E57      ADC	R5,R23
    02F8F 9230 056A STS	Result+11,R3
    02F91 9220 0569 STS	Result+10,R2
    02F93 9250 056C STS	Result+13,R5
    02F95 9240 056B STS	Result+12,R4
(0186) 				is_on=0; //切换到非检测状态
    02F97 2400      CLR	R0
    02F98 8608      STD	Y+8,R0
(0187) 				next_step_time=config.now+config.checkDeltaTime;//自动翻页时间更新
    02F99 9020 07E0 LDS	R2,config+17
    02F9B 9030 07E1 LDS	R3,config+18
    02F9D 2444      CLR	R4
    02F9E FC37      SBRC	R3,7
    02F9F 9440      COM	R4
    02FA0 2455      CLR	R5
    02FA1 FC47      SBRC	R4,7
    02FA2 9450      COM	R5
    02FA3 9080 07DD LDS	R8,config+14
    02FA5 9090 07DE LDS	R9,config+15
    02FA7 9060 07DB LDS	R6,config+12
    02FA9 9070 07DC LDS	R7,config+13
    02FAB 0C62      ADD	R6,R2
    02FAC 1C73      ADC	R7,R3
    02FAD 1C84      ADC	R8,R4
    02FAE 1C95      ADC	R9,R5
    02FAF 826B      STD	Y+3,R6
    02FB0 827C      STD	Y+4,R7
    02FB1 828D      STD	Y+5,R8
    02FB2 829E      STD	Y+6,R9
(0188) 				page=0;
    02FB3 820F      STD	Y+7,R0
(0189) 		   }
(0190) 		}
    02FB4 C07D      RJMP	0x3032
(0191) 		else { //is_on == 0 非检测状态 手动翻页/自动翻页
(0192) 		    dateRefresh(0);//不更新时间
    02FB5 2700      CLR	R16
    02FB6 D63F      RCALL	_dateRefresh
(0193) 			_GUI_datashow(page); 
    02FB7 810F      LDD	R16,Y+7
    02FB8 D081      RCALL	__GUI_datashow
(0194) 			//手动翻页 
(0195) 			if(key==up){ //上键 : 页面减 
    02FB9 2D8C      MOV	R24,R12
    02FBA 318E      CPI	R24,0x1E
    02FBB F469      BNE	0x2FC9
(0196) 		        if(page>0) page--;
    02FBC E080      LDI	R24,0
    02FBD 800F      LDD	R0,Y+7
    02FBE 1580      CP	R24,R0
    02FBF F418      BCC	0x2FC3
    02FC0 940A      DEC	R0
    02FC1 820F      STD	Y+7,R0
    02FC2 C002      RJMP	0x2FC5
(0197) 				else page =5;
    02FC3 E085      LDI	R24,5
    02FC4 838F      STD	Y+7,R24
(0198) 		    	LCD_CLR();
    02FC5 940E 3A1A CALL	_LCD_CLR
(0199) 		    	LCD_Init();
    02FC7 940E 39E8 CALL	_LCD_Init
(0200) 			}
(0201) 			if(key==down){//下键 ： 页面加
    02FC9 2D8C      MOV	R24,R12
    02FCA 318D      CPI	R24,0x1D
    02FCB F469      BNE	0x2FD9
(0202) 		        if(page<5) 
    02FCC 818F      LDD	R24,Y+7
    02FCD 3085      CPI	R24,5
    02FCE F420      BCC	0x2FD3
(0203) 				    page++;
    02FCF 2E08      MOV	R0,R24
    02FD0 9403      INC	R0
    02FD1 820F      STD	Y+7,R0
    02FD2 C002      RJMP	0x2FD5
(0204) 		  		else  
(0205) 				    page = 0;
    02FD3 2400      CLR	R0
    02FD4 820F      STD	Y+7,R0
(0206) 		    	LCD_CLR();
    02FD5 940E 3A1A CALL	_LCD_CLR
(0207) 		    	LCD_Init();
    02FD7 940E 39E8 CALL	_LCD_Init
(0208) 		    }
(0209) 			//LCD_print2num(4,1,page);
(0210) 			//LCD_print4num(4,3,config.now);
(0211) 			//LCD_print4num(4,6,next_step_time);
(0212) 			if( config.autocheck == 1){  //如果开启自动翻页
    02FD9 9180 07DF LDS	R24,config+16
    02FDB 3081      CPI	R24,1
    02FDC F009      BEQ	0x2FDE
    02FDD C054      RJMP	0x3032
(0213) 			      if(config.now >= next_step_time )	{
    02FDE 802B      LDD	R2,Y+3
    02FDF 803C      LDD	R3,Y+4
    02FE0 804D      LDD	R4,Y+5
    02FE1 805E      LDD	R5,Y+6
    02FE2 9080 07DD LDS	R8,config+14
    02FE4 9090 07DE LDS	R9,config+15
    02FE6 9060 07DB LDS	R6,config+12
    02FE8 9070 07DC LDS	R7,config+13
    02FEA 1462      CP	R6,R2
    02FEB 0473      CPC	R7,R3
    02FEC 0484      CPC	R8,R4
    02FED 0495      CPC	R9,R5
    02FEE F408      BCC	0x2FF0
    02FEF C042      RJMP	0x3032
(0214) 				      next_step_time = config.now + config.checkDeltaTime;
    02FF0 9020 07E0 LDS	R2,config+17
    02FF2 9030 07E1 LDS	R3,config+18
    02FF4 2444      CLR	R4
    02FF5 FC37      SBRC	R3,7
    02FF6 9440      COM	R4
    02FF7 2455      CLR	R5
    02FF8 FC47      SBRC	R4,7
    02FF9 9450      COM	R5
    02FFA 0C62      ADD	R6,R2
    02FFB 1C73      ADC	R7,R3
    02FFC 1C84      ADC	R8,R4
    02FFD 1C95      ADC	R9,R5
    02FFE 826B      STD	Y+3,R6
    02FFF 827C      STD	Y+4,R7
    03000 828D      STD	Y+5,R8
    03001 829E      STD	Y+6,R9
(0215) 					  page++;
    03002 800F      LDD	R0,Y+7
    03003 9403      INC	R0
    03004 820F      STD	Y+7,R0
(0216) 					  if( page==6 ){
    03005 2D80      MOV	R24,R0
    03006 3086      CPI	R24,6
    03007 F541      BNE	0x3030
(0217) 					      //自动翻到最后页，页面清零开启下次检测
(0218) 					      page = 0;
    03008 2400      CLR	R0
    03009 820F      STD	Y+7,R0
(0219) 						  dateRefresh(1); //刷新时间
    0300A E001      LDI	R16,1
    0300B D5EA      RCALL	_dateRefresh
(0220) 						  is_on =1 ; //开启检测
    0300C 2400      CLR	R0
    0300D 9403      INC	R0
    0300E 8608      STD	Y+8,R0
(0221) 						  config.time1=config.now+config.THRESHOLD_delta_sec; //更新下次检测时间
    0300F 9040 07D5 LDS	R4,config+6
    03011 9050 07D6 LDS	R5,config+7
    03013 9020 07D3 LDS	R2,config+4
    03015 9030 07D4 LDS	R3,config+5
    03017 9080 07DD LDS	R8,config+14
    03019 9090 07DE LDS	R9,config+15
    0301B 9060 07DB LDS	R6,config+12
    0301D 9070 07DC LDS	R7,config+13
    0301F 0C62      ADD	R6,R2
    03020 1C73      ADC	R7,R3
    03021 1C84      ADC	R8,R4
    03022 1C95      ADC	R9,R5
    03023 9270 07D8 STS	config+9,R7
    03025 9260 07D7 STS	config+8,R6
    03027 9290 07DA STS	config+11,R9
    03029 9280 07D9 STS	config+10,R8
(0222) 						  Result.TempChar[0]=0; //清除上次结果
    0302B 2422      CLR	R2
    0302C 9220 058C STS	Result+45,R2
(0223) 						  Result.WSChar[0]=0;
    0302E 9220 0596 STS	Result+55,R2
(0224) 					  }
(0225) 				      LCD_CLR();      
    03030 940E 3A1A CALL	_LCD_CLR
(0226) 				  }  
(0227) 			}
(0228) 			 
(0229) 		} 
(0230) 	    delayms(10); 
    03032 E00A      LDI	R16,0xA
    03033 E010      LDI	R17,0
    03034 940E 240B CALL	_delayms
    03036 CEB6      RJMP	0x2EED
    03037 9629      ADIW	R28,0x9
    03038 940C 4106 JMP	pop_xgsetF0FC
__GUI_datashow:
  page                 --> R20
    0303A 940E 4130 CALL	push_xgsetF00C
    0303C 2F40      MOV	R20,R16
    0303D 9722      SBIW	R28,2
(0231) 	}//end while
(0232) }//end function
(0233) void _GUI_datashow(char page){
(0234) 	if(page == 0){
    0303E 2344      TST	R20
    0303F F539      BNE	0x3067
(0235)  	//显示日期时间
(0236) 	    LCD_var_disp(1,1,GUI_get_date());
    03040 D205      RCALL	_GUI_get_date
    03041 8319      STD	Y+1,R17
    03042 8308      ST	Y,R16
    03043 E021      LDI	R18,1
    03044 E001      LDI	R16,1
    03045 940E 39A1 CALL	_LCD_var_disp
(0237) 	//显示温度
(0238) 	 	LCD_const_disp(2,1,"温度 (℃):");
    03047 E880      LDI	R24,0x80
    03048 E094      LDI	R25,4
    03049 8399      STD	Y+1,R25
    0304A 8388      ST	Y,R24
    0304B E021      LDI	R18,1
    0304C E002      LDI	R16,2
    0304D 940E 3974 CALL	_LCD_const_disp
(0239) 	 	LCD_var_disp(2,6,Result.TempChar);
    0304F E88C      LDI	R24,0x8C
    03050 E095      LDI	R25,5
    03051 8399      STD	Y+1,R25
    03052 8388      ST	Y,R24
    03053 E026      LDI	R18,6
    03054 E002      LDI	R16,2
    03055 940E 39A1 CALL	_LCD_var_disp
(0240) 	//显示风速
(0241) 	    LCD_const_disp(3,1,"风速(m/s): ");
    03057 E784      LDI	R24,0x74
    03058 E094      LDI	R25,4
    03059 8399      STD	Y+1,R25
    0305A 8388      ST	Y,R24
    0305B E021      LDI	R18,1
    0305C E003      LDI	R16,3
    0305D 940E 3974 CALL	_LCD_const_disp
(0242) 	 	LCD_const_disp(3,6,Result.WSChar);
    0305F E986      LDI	R24,0x96
    03060 E095      LDI	R25,5
    03061 8399      STD	Y+1,R25
    03062 8388      ST	Y,R24
    03063 E026      LDI	R18,6
    03064 E003      LDI	R16,3
    03065 940E 3974 CALL	_LCD_const_disp
(0243) 
(0244) 	 } 
(0245) 	 if(page == 1){
    03067 3041      CPI	R20,1
    03068 F5B9      BNE	0x30A0
(0246) 	     LCD_var_disp(1,1,GUI_get_date());
    03069 D1DC      RCALL	_GUI_get_date
    0306A 8319      STD	Y+1,R17
    0306B 8308      ST	Y,R16
    0306C E021      LDI	R18,1
    0306D E001      LDI	R16,1
    0306E 940E 39A1 CALL	_LCD_var_disp
(0247) 		 LCD_const_disp(2,1,"风冷指数: ");
    03070 E689      LDI	R24,0x69
    03071 E094      LDI	R25,4
    03072 8399      STD	Y+1,R25
    03073 8388      ST	Y,R24
    03074 E021      LDI	R18,1
    03075 E002      LDI	R16,2
    03076 940E 3974 CALL	_LCD_const_disp
(0248) 		 LCD_var_disp(2,6,Result.WCIChar);						
    03078 E98F      LDI	R24,0x9F
    03079 E095      LDI	R25,5
    0307A 8399      STD	Y+1,R25
    0307B 8388      ST	Y,R24
    0307C E026      LDI	R18,6
    0307D E002      LDI	R16,2
    0307E 940E 39A1 CALL	_LCD_var_disp
(0249) 		 LCD_const_disp(3,1,"等价温度: ");
    03080 E58E      LDI	R24,0x5E
    03081 E094      LDI	R25,4
    03082 8399      STD	Y+1,R25
    03083 8388      ST	Y,R24
    03084 E021      LDI	R18,1
    03085 E003      LDI	R16,3
    03086 940E 3974 CALL	_LCD_const_disp
(0250) 		 LCD_var_disp(3,6,Result.ECTChar);	 
    03088 EA89      LDI	R24,0xA9
    03089 E095      LDI	R25,5
    0308A 8399      STD	Y+1,R25
    0308B 8388      ST	Y,R24
    0308C E026      LDI	R18,6
    0308D E003      LDI	R16,3
    0308E 940E 39A1 CALL	_LCD_var_disp
(0251) 		 LCD_const_disp(4,1,"相当温度: ");
    03090 E583      LDI	R24,0x53
    03091 E094      LDI	R25,4
    03092 8399      STD	Y+1,R25
    03093 8388      ST	Y,R24
    03094 E021      LDI	R18,1
    03095 E004      LDI	R16,4
    03096 940E 3974 CALL	_LCD_const_disp
(0252) 		 LCD_var_disp(4,6,Result.TeqChar);	
    03098 EB83      LDI	R24,0xB3
    03099 E095      LDI	R25,5
    0309A 8399      STD	Y+1,R25
    0309B 8388      ST	Y,R24
    0309C E026      LDI	R18,6
    0309D E004      LDI	R16,4
    0309E 940E 39A1 CALL	_LCD_var_disp
(0253) 	 }
(0254) 	 if(page == 2){
    030A0 3042      CPI	R20,2
    030A1 F009      BEQ	0x30A3
    030A2 C03F      RJMP	0x30E2
(0255) 	     LCD_var_disp(1,1,GUI_get_date());
    030A3 D1A2      RCALL	_GUI_get_date
    030A4 0158      MOVW	R10,R16
    030A5 82B9      STD	Y+1,R11
    030A6 82A8      ST	Y,R10
    030A7 E021      LDI	R18,1
    030A8 E001      LDI	R16,1
    030A9 940E 39A1 CALL	_LCD_var_disp
(0256) 		 LCD_const_disp(2,1,"冻伤危害性:");
    030AB E487      LDI	R24,0x47
    030AC E094      LDI	R25,4
    030AD 8399      STD	Y+1,R25
    030AE 8388      ST	Y,R24
    030AF E021      LDI	R18,1
    030B0 E002      LDI	R16,2
    030B1 940E 3974 CALL	_LCD_const_disp
(0257) 	 if(Result.WeiHai==0){LCD_const_disp(3,1,"  冻伤危害性小");			 }
    030B3 9020 05B9 LDS	R2,Result+90
    030B5 2022      TST	R2
    030B6 F449      BNE	0x30C0
    030B7 E388      LDI	R24,0x38
    030B8 E094      LDI	R25,4
    030B9 8399      STD	Y+1,R25
    030BA 8388      ST	Y,R24
    030BB E021      LDI	R18,1
    030BC E003      LDI	R16,3
    030BD 940E 3974 CALL	_LCD_const_disp
    030BF C022      RJMP	0x30E2
(0258) 	 else if(Result.WeiHai==1){	LCD_const_disp(3,1,"  冻伤危害性较大");	 }
    030C0 9180 05B9 LDS	R24,Result+90
    030C2 3081      CPI	R24,1
    030C3 F449      BNE	0x30CD
    030C4 E287      LDI	R24,0x27
    030C5 E094      LDI	R25,4
    030C6 8399      STD	Y+1,R25
    030C7 8388      ST	Y,R24
    030C8 E021      LDI	R18,1
    030C9 E003      LDI	R16,3
    030CA 940E 3974 CALL	_LCD_const_disp
    030CC C015      RJMP	0x30E2
(0259) 	 else if(Result.WeiHai==2){	LCD_const_disp(3,1,"  冻伤危害性很大");	 }
    030CD 9180 05B9 LDS	R24,Result+90
    030CF 3082      CPI	R24,2
    030D0 F449      BNE	0x30DA
    030D1 E186      LDI	R24,0x16
    030D2 E094      LDI	R25,4
    030D3 8399      STD	Y+1,R25
    030D4 8388      ST	Y,R24
    030D5 E021      LDI	R18,1
    030D6 E003      LDI	R16,3
    030D7 940E 3974 CALL	_LCD_const_disp
    030D9 C008      RJMP	0x30E2
(0260) 	 else LCD_const_disp(3,1,"冻伤危害性小。");
    030DA E087      LDI	R24,7
    030DB E094      LDI	R25,4
    030DC 8399      STD	Y+1,R25
    030DD 8388      ST	Y,R24
    030DE E021      LDI	R18,1
    030DF E003      LDI	R16,3
    030E0 940E 3974 CALL	_LCD_const_disp
(0261) 	 }	  
(0262) 	 if(page==3){
    030E2 3043      CPI	R20,3
    030E3 F009      BEQ	0x30E5
    030E4 C061      RJMP	0x3146
(0263) 	     LCD_const_disp(1,1,labelH);		
    030E5 E682      LDI	R24,0x62
    030E6 E092      LDI	R25,2
    030E7 8399      STD	Y+1,R25
    030E8 8388      ST	Y,R24
    030E9 E021      LDI	R18,1
    030EA E001      LDI	R16,1
    030EB 940E 3974 CALL	_LCD_const_disp
(0264) 	 	 switch( Result.WeiHai ){
    030ED 9160 05B9 LDS	R22,Result+90
    030EF 2777      CLR	R23
    030F0 3060      CPI	R22,0
    030F1 0767      CPC	R22,R23
    030F2 F049      BEQ	0x30FC
    030F3 3061      CPI	R22,1
    030F4 E0E0      LDI	R30,0
    030F5 077E      CPC	R23,R30
    030F6 F0F1      BEQ	0x3115
    030F7 3062      CPI	R22,2
    030F8 E0E0      LDI	R30,0
    030F9 077E      CPC	R23,R30
    030FA F199      BEQ	0x312E
    030FB C04A      RJMP	0x3146
(0265) 			case 0 :
(0266) 			LCD_const_disp(2,1,H01);
    030FC E88E      LDI	R24,0x8E
    030FD E092      LDI	R25,2
    030FE 8399      STD	Y+1,R25
    030FF 8388      ST	Y,R24
    03100 E021      LDI	R18,1
    03101 E002      LDI	R16,2
    03102 940E 3974 CALL	_LCD_const_disp
(0267) 			LCD_const_disp(3,1,H02);
    03104 E98E      LDI	R24,0x9E
    03105 E092      LDI	R25,2
    03106 8399      STD	Y+1,R25
    03107 8388      ST	Y,R24
    03108 E021      LDI	R18,1
    03109 E003      LDI	R16,3
    0310A 940E 3974 CALL	_LCD_const_disp
(0268) 			LCD_const_disp(4,1,H03);
    0310C EA89      LDI	R24,0xA9
    0310D E092      LDI	R25,2
    0310E 8399      STD	Y+1,R25
    0310F 8388      ST	Y,R24
    03110 E021      LDI	R18,1
    03111 E004      LDI	R16,4
    03112 940E 3974 CALL	_LCD_const_disp
(0269) 			break;
    03114 C031      RJMP	0x3146
(0270) 			case 1 : 
(0271) 			LCD_const_disp(2,1,H11);
    03115 EC85      LDI	R24,0xC5
    03116 E092      LDI	R25,2
    03117 8399      STD	Y+1,R25
    03118 8388      ST	Y,R24
    03119 E021      LDI	R18,1
    0311A E002      LDI	R16,2
    0311B 940E 3974 CALL	_LCD_const_disp
(0272) 			LCD_const_disp(3,1,H12);
    0311D EA89      LDI	R24,0xA9
    0311E E092      LDI	R25,2
    0311F 8399      STD	Y+1,R25
    03120 8388      ST	Y,R24
    03121 E021      LDI	R18,1
    03122 E003      LDI	R16,3
    03123 940E 3974 CALL	_LCD_const_disp
(0273) 			LCD_const_disp(4,1,H13);
    03125 ED8E      LDI	R24,0xDE
    03126 E092      LDI	R25,2
    03127 8399      STD	Y+1,R25
    03128 8388      ST	Y,R24
    03129 E021      LDI	R18,1
    0312A E004      LDI	R16,4
    0312B 940E 3974 CALL	_LCD_const_disp
(0274) 			break ;	
    0312D C018      RJMP	0x3146
(0275) 			case 2 :
(0276) 			LCD_const_disp(2,1,H21);
    0312E E182      LDI	R24,0x12
    0312F E093      LDI	R25,3
    03130 8399      STD	Y+1,R25
    03131 8388      ST	Y,R24
    03132 E021      LDI	R18,1
    03133 E002      LDI	R16,2
    03134 940E 3974 CALL	_LCD_const_disp
(0277) 			LCD_const_disp(3,1,H22);
    03136 E284      LDI	R24,0x24
    03137 E093      LDI	R25,3
    03138 8399      STD	Y+1,R25
    03139 8388      ST	Y,R24
    0313A E021      LDI	R18,1
    0313B E003      LDI	R16,3
    0313C 940E 3974 CALL	_LCD_const_disp
(0278) 			LCD_const_disp(4,1,H23);
    0313E EA89      LDI	R24,0xA9
    0313F E092      LDI	R25,2
    03140 8399      STD	Y+1,R25
    03141 8388      ST	Y,R24
    03142 E021      LDI	R18,1
    03143 E004      LDI	R16,4
    03144 940E 3974 CALL	_LCD_const_disp
(0279) 			break;
(0280) 			default : ;
(0281) 		}
(0282) 	 } 
(0283) 	 if(page==4){
    03146 3044      CPI	R20,4
    03147 F009      BEQ	0x3149
    03148 C086      RJMP	0x31CF
(0284) 	 		LCD_const_disp(1,1,labelM);		
    03149 E780      LDI	R24,0x70
    0314A E092      LDI	R25,2
    0314B 8399      STD	Y+1,R25
    0314C 8388      ST	Y,R24
    0314D E021      LDI	R18,1
    0314E E001      LDI	R16,1
    0314F 940E 3974 CALL	_LCD_const_disp
(0285) 	 		switch( Result.WeiHai ){
    03151 9160 05B9 LDS	R22,Result+90
    03153 2777      CLR	R23
    03154 3060      CPI	R22,0
    03155 0767      CPC	R22,R23
    03156 F059      BEQ	0x3162
    03157 3061      CPI	R22,1
    03158 E0E0      LDI	R30,0
    03159 077E      CPC	R23,R30
    0315A F409      BNE	0x315C
    0315B C052      RJMP	0x31AE
    0315C 3062      CPI	R22,2
    0315D E0E0      LDI	R30,0
    0315E 077E      CPC	R23,R30
    0315F F409      BNE	0x3161
    03160 C066      RJMP	0x31C7
    03161 C06D      RJMP	0x31CF
(0286) 	 			case 0 :
(0287) 				LCD_const_disp(2,1,M01);
    03162 E88E      LDI	R24,0x8E
    03163 E092      LDI	R25,2
    03164 8399      STD	Y+1,R25
    03165 8388      ST	Y,R24
    03166 E021      LDI	R18,1
    03167 E002      LDI	R16,2
    03168 940E 3974 CALL	_LCD_const_disp
(0288) 				LCD_const_disp(3,1,M02);
    0316A EA89      LDI	R24,0xA9
    0316B E092      LDI	R25,2
    0316C 8399      STD	Y+1,R25
    0316D 8388      ST	Y,R24
    0316E E021      LDI	R18,1
    0316F E003      LDI	R16,3
    03170 940E 3974 CALL	_LCD_const_disp
(0289) 				if(Result.Temperature < 17.7){
    03172 9040 058A LDS	R4,Result+43
    03174 9050 058B LDS	R5,Result+44
    03176 9020 0588 LDS	R2,Result+41
    03178 9030 0589 LDS	R3,Result+42
    0317A EC00      LDI	R16,0xC0
    0317B E010      LDI	R17,0
    0317C 940E 4099 CALL	elpm32
    0317E 933A      ST	-Y,R19
    0317F 932A      ST	-Y,R18
    03180 931A      ST	-Y,R17
    03181 930A      ST	-Y,R16
    03182 0181      MOVW	R16,R2
    03183 0192      MOVW	R18,R4
    03184 940E 4437 CALL	fpcmp2
    03186 F44C      BGE	0x3190
(0290) 				    LCD_const_disp(4,1,"戴面罩；禁油彩。");
    03187 EF86      LDI	R24,0xF6
    03188 E093      LDI	R25,3
    03189 8399      STD	Y+1,R25
    0318A 8388      ST	Y,R24
    0318B E021      LDI	R18,1
    0318C E004      LDI	R16,4
    0318D 940E 3974 CALL	_LCD_const_disp
(0291) 				}
    0318F C03F      RJMP	0x31CF
(0292) 				else if(Result.Temperature < 12){
    03190 9040 058A LDS	R4,Result+43
    03192 9050 058B LDS	R5,Result+44
    03194 9020 0588 LDS	R2,Result+41
    03196 9030 0589 LDS	R3,Result+42
    03198 EB0C      LDI	R16,0xBC
    03199 E010      LDI	R17,0
    0319A 940E 4099 CALL	elpm32
    0319C 933A      ST	-Y,R19
    0319D 932A      ST	-Y,R18
    0319E 931A      ST	-Y,R17
    0319F 930A      ST	-Y,R16
    031A0 0181      MOVW	R16,R2
    031A1 0192      MOVW	R18,R4
    031A2 940E 4437 CALL	fpcmp2
    031A4 F554      BGE	0x31CF
(0293) 				    LCD_const_disp(4,1,"禁油彩。        \0");
    031A5 EE84      LDI	R24,0xE4
    031A6 E093      LDI	R25,3
    031A7 8399      STD	Y+1,R25
    031A8 8388      ST	Y,R24
    031A9 E021      LDI	R18,1
    031AA E004      LDI	R16,4
    031AB 940E 3974 CALL	_LCD_const_disp
(0294) 				}
(0295) 				break;
    031AD C021      RJMP	0x31CF
(0296) 				case 1 : 
(0297) 			    LCD_const_disp(2,1,M11);
    031AE E88E      LDI	R24,0x8E
    031AF E092      LDI	R25,2
    031B0 8399      STD	Y+1,R25
    031B1 8388      ST	Y,R24
    031B2 E021      LDI	R18,1
    031B3 E002      LDI	R16,2
    031B4 940E 3974 CALL	_LCD_const_disp
(0298) 				LCD_const_disp(3,1,M12);
    031B6 EE8E      LDI	R24,0xEE
    031B7 E092      LDI	R25,2
    031B8 8399      STD	Y+1,R25
    031B9 8388      ST	Y,R24
    031BA E021      LDI	R18,1
    031BB E003      LDI	R16,3
    031BC 940E 3974 CALL	_LCD_const_disp
(0299) 				LCD_const_disp(4,1,M13);
    031BE E080      LDI	R24,0
    031BF E093      LDI	R25,3
    031C0 8399      STD	Y+1,R25
    031C1 8388      ST	Y,R24
    031C2 E021      LDI	R18,1
    031C3 E004      LDI	R16,4
    031C4 940E 3974 CALL	_LCD_const_disp
(0300) 				break ;
    031C6 C008      RJMP	0x31CF
(0301) 				case 2 :
(0302) 				LCD_const_disp(2,1,M21);
    031C7 E386      LDI	R24,0x36
    031C8 E093      LDI	R25,3
    031C9 8399      STD	Y+1,R25
    031CA 8388      ST	Y,R24
    031CB E021      LDI	R18,1
    031CC E002      LDI	R16,2
    031CD 940E 3974 CALL	_LCD_const_disp
(0303) 				break ;
(0304) 				default :;
(0305) 	 		}
(0306) 	 }
(0307) 	 if(page==5){
    031CF 3045      CPI	R20,5
    031D0 F009      BEQ	0x31D2
    031D1 C071      RJMP	0x3243
(0308) 	     LCD_const_disp(1,1,labelL);		
    031D2 E880      LDI	R24,0x80
    031D3 E092      LDI	R25,2
    031D4 8399      STD	Y+1,R25
    031D5 8388      ST	Y,R24
    031D6 E021      LDI	R18,1
    031D7 E001      LDI	R16,1
    031D8 940E 3974 CALL	_LCD_const_disp
(0309) 	 	 switch( Result.WeiHai ){	
    031DA 9140 05B9 LDS	R20,Result+90
    031DC 2755      CLR	R21
    031DD 3040      CPI	R20,0
    031DE 0745      CPC	R20,R21
    031DF F059      BEQ	0x31EB
    031E0 3041      CPI	R20,1
    031E1 E0E0      LDI	R30,0
    031E2 075E      CPC	R21,R30
    031E3 F409      BNE	0x31E5
    031E4 C03D      RJMP	0x3222
    031E5 3042      CPI	R20,2
    031E6 E0E0      LDI	R30,0
    031E7 075E      CPC	R21,R30
    031E8 F409      BNE	0x31EA
    031E9 C051      RJMP	0x323B
    031EA C058      RJMP	0x3243
(0310) 		     case 0 :
(0311) 			 LCD_const_disp(2,1,L01);
    031EB EB8B      LDI	R24,0xBB
    031EC E092      LDI	R25,2
    031ED 8399      STD	Y+1,R25
    031EE 8388      ST	Y,R24
    031EF E021      LDI	R18,1
    031F0 E002      LDI	R16,2
    031F1 940E 3974 CALL	_LCD_const_disp
(0312) 			 if(Result.Temperature < -12) {
    031F3 9040 058A LDS	R4,Result+43
    031F5 9050 058B LDS	R5,Result+44
    031F7 9020 0588 LDS	R2,Result+41
    031F9 9030 0589 LDS	R3,Result+42
    031FB EB08      LDI	R16,0xB8
    031FC E010      LDI	R17,0
    031FD 940E 4099 CALL	elpm32
    031FF 933A      ST	-Y,R19
    03200 932A      ST	-Y,R18
    03201 931A      ST	-Y,R17
    03202 930A      ST	-Y,R16
    03203 0181      MOVW	R16,R2
    03204 0192      MOVW	R18,R4
    03205 940E 4437 CALL	fpcmp2
    03207 F48C      BGE	0x3219
(0313) 			 LCD_const_disp(3,1,L02);
    03208 EC85      LDI	R24,0xC5
    03209 E092      LDI	R25,2
    0320A 8399      STD	Y+1,R25
    0320B 8388      ST	Y,R24
    0320C E021      LDI	R18,1
    0320D E003      LDI	R16,3
    0320E 940E 3974 CALL	_LCD_const_disp
(0314) 			 LCD_const_disp(4,1,L03);
    03210 EC8F      LDI	R24,0xCF
    03211 E092      LDI	R25,2
    03212 8399      STD	Y+1,R25
    03213 8388      ST	Y,R24
    03214 E021      LDI	R18,1
    03215 E004      LDI	R16,4
    03216 940E 3974 CALL	_LCD_const_disp
(0315) 			 } 
    03218 C02A      RJMP	0x3243
(0316) 			 else {
(0317) 			 LCD_const_disp(3,1,L03);
    03219 EC8F      LDI	R24,0xCF
    0321A E092      LDI	R25,2
    0321B 8399      STD	Y+1,R25
    0321C 8388      ST	Y,R24
    0321D E021      LDI	R18,1
    0321E E003      LDI	R16,3
    0321F 940E 3974 CALL	_LCD_const_disp
(0318) 			 }
(0319) 			 break;
    03221 C021      RJMP	0x3243
(0320) 			 case 1: 
(0321) 			 LCD_const_disp(2,1,L11);
    03222 E182      LDI	R24,0x12
    03223 E093      LDI	R25,3
    03224 8399      STD	Y+1,R25
    03225 8388      ST	Y,R24
    03226 E021      LDI	R18,1
    03227 E002      LDI	R16,2
    03228 940E 3974 CALL	_LCD_const_disp
(0322) 			 LCD_const_disp(3,1,L12);
    0322A E284      LDI	R24,0x24
    0322B E093      LDI	R25,3
    0322C 8399      STD	Y+1,R25
    0322D 8388      ST	Y,R24
    0322E E021      LDI	R18,1
    0322F E003      LDI	R16,3
    03230 940E 3974 CALL	_LCD_const_disp
(0323) 			 LCD_const_disp(3,1,L13);
    03232 EA89      LDI	R24,0xA9
    03233 E092      LDI	R25,2
    03234 8399      STD	Y+1,R25
    03235 8388      ST	Y,R24
    03236 E021      LDI	R18,1
    03237 E003      LDI	R16,3
    03238 940E 3974 CALL	_LCD_const_disp
(0324) 			 break ;
    0323A C008      RJMP	0x3243
(0325) 			 case 2 :
(0326) 			 LCD_const_disp(2,1,L21);
    0323B E386      LDI	R24,0x36
    0323C E093      LDI	R25,3
    0323D 8399      STD	Y+1,R25
    0323E 8388      ST	Y,R24
    0323F E021      LDI	R18,1
    03240 E002      LDI	R16,2
    03241 940E 3974 CALL	_LCD_const_disp
(0327) 			 break;
(0328) 			 default : ;
(0329) 		} //end switch
(0330) 	}  //end if
    03243 9622      ADIW	R28,2
    03244 940C 4137 JMP	pop_xgsetF00C
(0331) }
(0332) char * GUI_get_date(void) {  
(0333)   //格式：2012年12月11日19:00:00
(0334)     GUI_date[0]=Result.Date[4]; 
_GUI_get_date:
    03246 9020 0579 LDS	R2,Result+26
    03248 9220 0345 STS	GUI_date,R2
(0335)     GUI_date[1]=Result.Date[5];
    0324A 9020 057A LDS	R2,Result+27
    0324C 9220 0346 STS	GUI_date+1,R2
(0336)     GUI_date[4]=Result.Date[6];
    0324E 9020 057B LDS	R2,Result+28
    03250 9220 0349 STS	GUI_date+4,R2
(0337)     GUI_date[5]=Result.Date[7];
    03252 9020 057C LDS	R2,Result+29
    03254 9220 034A STS	GUI_date+5,R2
(0338)     GUI_date[8]=Result.Time[0];
    03256 9020 057E LDS	R2,Result+31
    03258 9220 034D STS	GUI_date+8,R2
(0339)     GUI_date[9]=Result.Time[1];
    0325A 9020 057F LDS	R2,Result+32
    0325C 9220 034E STS	GUI_date+9,R2
(0340)     GUI_date[11]=Result.Time[4];
    0325E 9020 0582 LDS	R2,Result+35
    03260 9220 0350 STS	GUI_date+11,R2
(0341)     GUI_date[12]=Result.Time[5];
    03262 9020 0583 LDS	R2,Result+36
    03264 9220 0351 STS	GUI_date+12,R2
(0342)     GUI_date[14]=Result.Time[8];
    03266 9020 0586 LDS	R2,Result+39
    03268 9220 0353 STS	GUI_date+14,R2
(0343)     GUI_date[15]=Result.Time[9];
    0326A 9020 0587 LDS	R2,Result+40
    0326C 9220 0354 STS	GUI_date+15,R2
(0344)     GUI_date[16]='\0';
    0326E 2422      CLR	R2
    0326F 9220 0355 STS	GUI_date+16,R2
(0345)     return GUI_date;
    03271 E405      LDI	R16,0x45
    03272 E013      LDI	R17,3
    03273 9508      RET
_GUI_set_time:
  GUI_down             --> Y,+5
  GUI_up               --> Y,+2
  pT                   --> R14
  ary                  --> R12
  p                    --> Y,+10
  i                    --> R20
  keyc                 --> R22
  pD                   --> Y,+8
    03274 940E 4111 CALL	push_xgsetF0FC
    03276 972B      SBIW	R28,0xB
(0346) }
(0347) //设置时间 菜单 
(0348) void GUI_set_time(void){
(0349)     unsigned char p=2;
    03277 E082      LDI	R24,2
    03278 878A      STD	Y+10,R24
(0350) 	char GUI_up[]= "↑";
    03279 E586      LDI	R24,0x56
    0327A E093      LDI	R25,3
    0327B 01FE      MOVW	R30,R28
    0327C 9632      ADIW	R30,2
    0327D E003      LDI	R16,3
    0327E E010      LDI	R17,0
    0327F 93FA      ST	-Y,R31
    03280 93EA      ST	-Y,R30
    03281 939A      ST	-Y,R25
    03282 938A      ST	-Y,R24
    03283 940E 41B8 CALL	asgnblk
(0351) 	char GUI_down[]= "↓";
    03285 E589      LDI	R24,0x59
    03286 E093      LDI	R25,3
    03287 01FE      MOVW	R30,R28
    03288 9635      ADIW	R30,5
    03289 E003      LDI	R16,3
    0328A E010      LDI	R17,0
    0328B 93FA      ST	-Y,R31
    0328C 93EA      ST	-Y,R30
    0328D 939A      ST	-Y,R25
    0328E 938A      ST	-Y,R24
    0328F 940E 41B8 CALL	asgnblk
(0352) 	char *pD=NULL,*pT=NULL;
    03291 2400      CLR	R0
    03292 2411      CLR	R1
    03293 8619      STD	Y+9,R1
    03294 8608      STD	Y+8,R0
(0353) 	char *ary=GUI_up;
    03295 01CE      MOVW	R24,R28
    03296 9602      ADIW	R24,2
    03297 016C      MOVW	R12,R24
(0354) 	unsigned char i=0,keyc=NO_KEY;
    03298 2744      CLR	R20
    03299 2766      CLR	R22
(0355) 	LCD_CLR(); //清屏
    0329A 940E 3A1A CALL	_LCD_CLR
(0356) 	pD="2012年12月31日\0";
    0329C ED84      LDI	R24,0xD4
    0329D E093      LDI	R25,3
    0329E 8799      STD	Y+9,R25
    0329F 8788      STD	Y+8,R24
(0357) 	pT=Result.Time;
    032A0 E78E      LDI	R24,0x7E
    032A1 E095      LDI	R25,5
    032A2 017C      MOVW	R14,R24
(0358) 	LCD_const_disp(1,1,"时间设置:       ");
    032A3 EC83      LDI	R24,0xC3
    032A4 E093      LDI	R25,3
    032A5 8399      STD	Y+1,R25
    032A6 8388      ST	Y,R24
    032A7 E021      LDI	R18,1
    032A8 E001      LDI	R16,1
    032A9 940E 3974 CALL	_LCD_const_disp
(0359) 	LCD_const_disp(4,7,"保存");
    032AB EB8E      LDI	R24,0xBE
    032AC E093      LDI	R25,3
    032AD 8399      STD	Y+1,R25
    032AE 8388      ST	Y,R24
    032AF E027      LDI	R18,7
    032B0 E004      LDI	R16,4
    032B1 940E 3974 CALL	_LCD_const_disp
(0360) 	LCD_var_disp(3,p,ary);
    032B3 82D9      STD	Y+1,R13
    032B4 82C8      ST	Y,R12
    032B5 852A      LDD	R18,Y+10
    032B6 E003      LDI	R16,3
    032B7 940E 39A1 CALL	_LCD_var_disp
(0361) 	LCD_var_disp(2,1,pD);
    032B9 8408      LDD	R0,Y+8
    032BA 8419      LDD	R1,Y+9
    032BB 8219      STD	Y+1,R1
    032BC 8208      ST	Y,R0
    032BD E021      LDI	R18,1
    032BE E002      LDI	R16,2
    032BF 940E 39A1 CALL	_LCD_var_disp
(0362) 	LCD_var_disp(4,1,pT);
    032C1 82F9      STD	Y+1,R15
    032C2 82E8      ST	Y,R14
    032C3 E021      LDI	R18,1
    032C4 E004      LDI	R16,4
    032C5 940E 39A1 CALL	_LCD_var_disp
(0363) 	delayms(250);
    032C7 EF0A      LDI	R16,0xFA
    032C8 E010      LDI	R17,0
    032C9 940E 240B CALL	_delayms
    032CB C1EC      RJMP	0x34B8
(0364) 	while(1){
(0365) 	    keyc=kbscan();
    032CC 940E 3F63 CALL	_kbscan
    032CE 2F60      MOV	R22,R16
(0366) 		pD[2]=Result.Date[2];
    032CF 9020 0577 LDS	R2,Result+24
    032D1 85E8      LDD	R30,Y+8
    032D2 85F9      LDD	R31,Y+9
    032D3 8222      STD	Z+2,R2
(0367) 		pD[3]=Result.Date[3];
    032D4 9020 0578 LDS	R2,Result+25
    032D6 8223      STD	Z+3,R2
(0368) 		pD[6]=Result.Date[4];
    032D7 9020 0579 LDS	R2,Result+26
    032D9 8226      STD	Z+6,R2
(0369) 		pD[7]=Result.Date[5];
    032DA 9020 057A LDS	R2,Result+27
    032DC 8227      STD	Z+7,R2
(0370) 		pD[10]=Result.Date[6];
    032DD 9020 057B LDS	R2,Result+28
    032DF 8622      STD	Z+10,R2
(0371) 		pD[11]=Result.Date[7];  
    032E0 9020 057C LDS	R2,Result+29
    032E2 8623      STD	Z+11,R2
(0372) 
(0373) 		switch(i){
    032E3 2EA4      MOV	R10,R20
    032E4 24BB      CLR	R11
    032E5 20AA      TST	R10
    032E6 F411      BNE	0x32E9
    032E7 20BB      TST	R11
    032E8 F0D9      BEQ	0x3304
    032E9 01C5      MOVW	R24,R10
    032EA 3081      CPI	R24,1
    032EB E0E0      LDI	R30,0
    032EC 079E      CPC	R25,R30
    032ED F409      BNE	0x32EF
    032EE C049      RJMP	0x3338
    032EF 3082      CPI	R24,2
    032F0 E0E0      LDI	R30,0
    032F1 079E      CPC	R25,R30
    032F2 F409      BNE	0x32F4
    032F3 C07D      RJMP	0x3371
    032F4 3083      CPI	R24,3
    032F5 E0E0      LDI	R30,0
    032F6 079E      CPC	R25,R30
    032F7 F409      BNE	0x32F9
    032F8 C0C1      RJMP	0x33BA
    032F9 3084      CPI	R24,4
    032FA E0E0      LDI	R30,0
    032FB 079E      CPC	R25,R30
    032FC F409      BNE	0x32FE
    032FD C0F6      RJMP	0x33F4
    032FE 3085      CPI	R24,5
    032FF E0E0      LDI	R30,0
    03300 079E      CPC	R25,R30
    03301 F409      BNE	0x3303
    03302 C12A      RJMP	0x342D
    03303 C165      RJMP	0x3469
(0374)             case 0: p=2;ary=GUI_up;  //年
    03304 E082      LDI	R24,2
    03305 878A      STD	Y+10,R24
    03306 01CE      MOVW	R24,R28
    03307 9602      ADIW	R24,2
    03308 016C      MOVW	R12,R24
(0375) 		 	  	 if(keyc==up){
    03309 316E      CPI	R22,0x1E
    0330A F491      BNE	0x331D
(0376) 				     if(time_buf[1]<0x99){ 
    0330B 9180 0504 LDS	R24,time_buf+1
    0330D 3989      CPI	R24,0x99
    0330E F008      BCS	0x3310
    0330F C159      RJMP	0x3469
(0377) 					     time_buf[1]++;
    03310 5F8F      SUBI	R24,0xFF
    03311 9380 0504 STS	time_buf+1,R24
(0378) 						 if((time_buf[1]&0x0f)==0x0a) 
    03313 708F      ANDI	R24,0xF
    03314 308A      CPI	R24,0xA
    03315 F009      BEQ	0x3317
    03316 C152      RJMP	0x3469
(0379) 						     time_buf[1]=time_buf[1]+6;
    03317 9180 0504 LDS	R24,time_buf+1
    03319 5F8A      SUBI	R24,0xFA
    0331A 9380 0504 STS	time_buf+1,R24
(0380) 					 }
(0381) 												     
(0382) 				}				  
    0331C C14C      RJMP	0x3469
(0383)  					        
(0384) 			    else if(keyc==down){ 
    0331D 316D      CPI	R22,0x1D
    0331E F4A1      BNE	0x3333
(0385) 				    if(time_buf[1]>0x00){
    0331F E080      LDI	R24,0
    03320 9020 0504 LDS	R2,time_buf+1
    03322 1582      CP	R24,R2
    03323 F008      BCS	0x3325
    03324 C144      RJMP	0x3469
(0386) 				        time_buf[1]--;
    03325 2D82      MOV	R24,R2
    03326 5081      SUBI	R24,1
    03327 9380 0504 STS	time_buf+1,R24
(0387) 						if((time_buf[1]&0x0f)==0x0f) 
    03329 708F      ANDI	R24,0xF
    0332A 308F      CPI	R24,0xF
    0332B F009      BEQ	0x332D
    0332C C13C      RJMP	0x3469
(0388) 						    time_buf[1]=time_buf[1]-6;
    0332D 9180 0504 LDS	R24,time_buf+1
    0332F 5086      SUBI	R24,6
    03330 9380 0504 STS	time_buf+1,R24
(0389) 		 	  	 		 }
(0390) 												   
(0391) 					}			   		
    03332 C136      RJMP	0x3469
(0392) 				else if(keyc==right) {i=1;}
    03333 3167      CPI	R22,0x17
    03334 F009      BEQ	0x3336
    03335 C133      RJMP	0x3469
    03336 E041      LDI	R20,1
(0393) 				break;
    03337 C131      RJMP	0x3469
(0394) 		 case 1:p=4;ary=GUI_up;  //月
    03338 E084      LDI	R24,4
    03339 878A      STD	Y+10,R24
    0333A 01CE      MOVW	R24,R28
    0333B 9602      ADIW	R24,2
    0333C 016C      MOVW	R12,R24
(0395) 		  	  	if(keyc==up){
    0333D 316E      CPI	R22,0x1E
    0333E F499      BNE	0x3352
(0396) 				    if(time_buf[2]<0x12){  
    0333F 9180 0505 LDS	R24,time_buf+2
    03341 3182      CPI	R24,0x12
    03342 F460      BCC	0x334F
(0397) 					    time_buf[2]++;	
    03343 5F8F      SUBI	R24,0xFF
    03344 9380 0505 STS	time_buf+2,R24
(0398) 						if((time_buf[2]&0x0f)==0x0a) time_buf[2]+=6;
    03346 708F      ANDI	R24,0xF
    03347 308A      CPI	R24,0xA
    03348 F449      BNE	0x3352
    03349 9180 0505 LDS	R24,time_buf+2
    0334B 5F8A      SUBI	R24,0xFA
    0334C 9380 0505 STS	time_buf+2,R24
(0399) 					}
    0334E C003      RJMP	0x3352
(0400) 					else 
(0401) 					    time_buf[2]=0x01;
    0334F E081      LDI	R24,1
    03350 9380 0505 STS	time_buf+2,R24
(0402) 				}						 
(0403) 				if(keyc==down){ 
    03352 316D      CPI	R22,0x1D
    03353 F4A9      BNE	0x3369
(0404) 				    if(time_buf[2]>0x01){  
    03354 E081      LDI	R24,1
    03355 9020 0505 LDS	R2,time_buf+2
    03357 1582      CP	R24,R2
    03358 F468      BCC	0x3366
(0405) 					    time_buf[2]--;	
    03359 2D82      MOV	R24,R2
    0335A 5081      SUBI	R24,1
    0335B 9380 0505 STS	time_buf+2,R24
(0406) 						if((time_buf[2]&0x0f)==0x0f) 
    0335D 708F      ANDI	R24,0xF
    0335E 308F      CPI	R24,0xF
    0335F F449      BNE	0x3369
(0407) 						    time_buf[2]-=6;
    03360 9180 0505 LDS	R24,time_buf+2
    03362 5086      SUBI	R24,6
    03363 9380 0505 STS	time_buf+2,R24
(0408) 			  		}
    03365 C003      RJMP	0x3369
(0409) 				    else 
(0410) 					    time_buf[2]=0x12;						
    03366 E182      LDI	R24,0x12
    03367 9380 0505 STS	time_buf+2,R24
(0411) 				}						 							
(0412) 				if(keyc==left){
    03369 316B      CPI	R22,0x1B
    0336A F409      BNE	0x336C
(0413) 				    i=0;   
    0336B 2744      CLR	R20
(0414) 				}									
(0415) 				if(keyc==right){
    0336C 3167      CPI	R22,0x17
    0336D F009      BEQ	0x336F
    0336E C0FA      RJMP	0x3469
(0416) 				    i=2;   
    0336F E042      LDI	R20,2
(0417) 				}  
(0418) 				break;
    03370 C0F8      RJMP	0x3469
(0419) 	 	 case 2: p=6;ary=GUI_up;
    03371 E086      LDI	R24,6
    03372 878A      STD	Y+10,R24
    03373 01CE      MOVW	R24,R28
    03374 9602      ADIW	R24,2
    03375 016C      MOVW	R12,R24
(0420) 		 	  	 if(keyc==up){ 
    03376 316E      CPI	R22,0x1E
    03377 F519      BNE	0x339B
(0421) 				     if(time_buf[3]<0x31){ 
    03378 9180 0506 LDS	R24,time_buf+3
    0337A 3381      CPI	R24,0x31
    0337B F5B0      BCC	0x33B2
(0422) 				         time_buf[3]++;
    0337C 5F8F      SUBI	R24,0xFF
    0337D 9380 0506 STS	time_buf+3,R24
(0423) 						 if ((time_buf[3]&0x0f)==0x0a) time_buf[3]=time_buf[3]+6;
    0337F 708F      ANDI	R24,0xF
    03380 308A      CPI	R24,0xA
    03381 F429      BNE	0x3387
    03382 9180 0506 LDS	R24,time_buf+3
    03384 5F8A      SUBI	R24,0xFA
    03385 9380 0506 STS	time_buf+3,R24
(0424) 						 if(  //2 4 6 9 11 月最大30天
(0425) 						  ( ((time_buf[2]==0x02) || (time_buf[2]==0x04)|| (time_buf[2]==0x06)||
    03387 9180 0505 LDS	R24,time_buf+2
    03389 3082      CPI	R24,2
    0338A F041      BEQ	0x3393
    0338B 3084      CPI	R24,4
    0338C F031      BEQ	0x3393
    0338D 3086      CPI	R24,6
    0338E F021      BEQ	0x3393
    0338F 3089      CPI	R24,0x9
    03390 F011      BEQ	0x3393
    03391 3181      CPI	R24,0x11
    03392 F4F9      BNE	0x33B2
    03393 9180 0506 LDS	R24,time_buf+3
    03395 3381      CPI	R24,0x31
    03396 F4D9      BNE	0x33B2
(0426) 						  (time_buf[2]==0x09)||(time_buf[2]==0x11))&&(time_buf[3]==0x31))){
(0427) 						      time_buf[3]=0x30;
    03397 E380      LDI	R24,0x30
    03398 9380 0506 STS	time_buf+3,R24
(0428) 						}
(0429) 				     }
(0430)  									  
(0431)  				 }
    0339A C017      RJMP	0x33B2
(0432) 			     else if(keyc==down){ 
    0339B 316D      CPI	R22,0x1D
    0339C F4A9      BNE	0x33B2
(0433) 				      if(time_buf[3]>0x01){  
    0339D E081      LDI	R24,1
    0339E 9020 0506 LDS	R2,time_buf+3
    033A0 1582      CP	R24,R2
    033A1 F468      BCC	0x33AF
(0434) 					     time_buf[3]--;
    033A2 2D82      MOV	R24,R2
    033A3 5081      SUBI	R24,1
    033A4 9380 0506 STS	time_buf+3,R24
(0435) 				 	  	 if((time_buf[3]&0x0f)==0x0f) time_buf[3]=time_buf[3]-6;
    033A6 708F      ANDI	R24,0xF
    033A7 308F      CPI	R24,0xF
    033A8 F449      BNE	0x33B2
    033A9 9180 0506 LDS	R24,time_buf+3
    033AB 5086      SUBI	R24,6
    033AC 9380 0506 STS	time_buf+3,R24
(0436) 		 	  	 	 }
    033AE C003      RJMP	0x33B2
(0437) 					 else time_buf[3]=0x31;						
    033AF E381      LDI	R24,0x31
    033B0 9380 0506 STS	time_buf+3,R24
(0438) 											   
(0439) 				}
(0440) 				if(keyc==left) {i=1;  }						 			   		
    033B2 316B      CPI	R22,0x1B
    033B3 F409      BNE	0x33B5
    033B4 E041      LDI	R20,1
(0441) 				if(keyc==right) {i=3;    }  	
    033B5 3167      CPI	R22,0x17
    033B6 F009      BEQ	0x33B8
    033B7 C0B1      RJMP	0x3469
    033B8 E043      LDI	R20,3
(0442) 				break;
    033B9 C0AF      RJMP	0x3469
(0443) 		case 3:p=1;ary=GUI_down;
    033BA 2400      CLR	R0
    033BB 9403      INC	R0
    033BC 860A      STD	Y+10,R0
    033BD 01CE      MOVW	R24,R28
    033BE 9605      ADIW	R24,5
    033BF 016C      MOVW	R12,R24
(0444)  	  	if(keyc==up){ if(time_buf[4]<0x23){  time_buf[4]++;	
    033C0 316E      CPI	R22,0x1E
    033C1 F499      BNE	0x33D5
    033C2 9180 0507 LDS	R24,time_buf+4
    033C4 3283      CPI	R24,0x23
    033C5 F460      BCC	0x33D2
    033C6 5F8F      SUBI	R24,0xFF
    033C7 9380 0507 STS	time_buf+4,R24
(0445) 													if((time_buf[4]&0x0f)==0x0a) time_buf[4]+=6;
    033C9 708F      ANDI	R24,0xF
    033CA 308A      CPI	R24,0xA
    033CB F449      BNE	0x33D5
    033CC 9180 0507 LDS	R24,time_buf+4
    033CE 5F8A      SUBI	R24,0xFA
    033CF 9380 0507 STS	time_buf+4,R24
(0446) 													 
(0447) 													
(0448) 												 }
    033D1 C003      RJMP	0x33D5
(0449) 							else time_buf[4]=0x00;
    033D2 2422      CLR	R2
    033D3 9220 0507 STS	time_buf+4,R2
(0450) 						  }						 
(0451) 				if(keyc==down){ if(time_buf[4]>0x00){  time_buf[4]--;	
    033D5 316D      CPI	R22,0x1D
    033D6 F4A9      BNE	0x33EC
    033D7 E080      LDI	R24,0
    033D8 9020 0507 LDS	R2,time_buf+4
    033DA 1582      CP	R24,R2
    033DB F468      BCC	0x33E9
    033DC 2D82      MOV	R24,R2
    033DD 5081      SUBI	R24,1
    033DE 9380 0507 STS	time_buf+4,R24
(0452) 													if((time_buf[4]&0x0f)==0x0f) time_buf[4]-=6;
    033E0 708F      ANDI	R24,0xF
    033E1 308F      CPI	R24,0xF
    033E2 F449      BNE	0x33EC
    033E3 9180 0507 LDS	R24,time_buf+4
    033E5 5086      SUBI	R24,6
    033E6 9380 0507 STS	time_buf+4,R24
(0453) 													
(0454) 												 }
    033E8 C003      RJMP	0x33EC
(0455) 							 else time_buf[4]=0x23;						
    033E9 E283      LDI	R24,0x23
    033EA 9380 0507 STS	time_buf+4,R24
(0456) 						  }	
(0457) 		if(keyc==left ) {i=2;   } 				  
    033EC 316B      CPI	R22,0x1B
    033ED F409      BNE	0x33EF
    033EE E042      LDI	R20,2
(0458) 		if(keyc==right) {i=4;    } 
    033EF 3167      CPI	R22,0x17
    033F0 F009      BEQ	0x33F2
    033F1 C077      RJMP	0x3469
    033F2 E044      LDI	R20,4
(0459) 		break;						  					 			
    033F3 C075      RJMP	0x3469
(0460)  case 4:p=3;ary=GUI_down;
    033F4 E083      LDI	R24,3
    033F5 878A      STD	Y+10,R24
    033F6 01CE      MOVW	R24,R28
    033F7 9605      ADIW	R24,5
    033F8 016C      MOVW	R12,R24
(0461)  	  	if(keyc==up){ if(time_buf[5]<0x59){  time_buf[5]++;	
    033F9 316E      CPI	R22,0x1E
    033FA F499      BNE	0x340E
    033FB 9180 0508 LDS	R24,time_buf+5
    033FD 3589      CPI	R24,0x59
    033FE F460      BCC	0x340B
    033FF 5F8F      SUBI	R24,0xFF
    03400 9380 0508 STS	time_buf+5,R24
(0462) 											 if((time_buf[5]&0x0f)==0x0a) time_buf[5]+=6;
    03402 708F      ANDI	R24,0xF
    03403 308A      CPI	R24,0xA
    03404 F449      BNE	0x340E
    03405 9180 0508 LDS	R24,time_buf+5
    03407 5F8A      SUBI	R24,0xFA
    03408 9380 0508 STS	time_buf+5,R24
(0463) 										  }
    0340A C003      RJMP	0x340E
(0464) 					  else time_buf[5]=0x00;
    0340B 2422      CLR	R2
    0340C 9220 0508 STS	time_buf+5,R2
(0465) 					}						 
(0466) 		if(keyc==down){ if(time_buf[5]>0x00){  time_buf[5]--;	
    0340E 316D      CPI	R22,0x1D
    0340F F4A9      BNE	0x3425
    03410 E080      LDI	R24,0
    03411 9020 0508 LDS	R2,time_buf+5
    03413 1582      CP	R24,R2
    03414 F468      BCC	0x3422
    03415 2D82      MOV	R24,R2
    03416 5081      SUBI	R24,1
    03417 9380 0508 STS	time_buf+5,R24
(0467) 												if((time_buf[5]&0x0f)==0x0f) time_buf[5]-=6;
    03419 708F      ANDI	R24,0xF
    0341A 308F      CPI	R24,0xF
    0341B F449      BNE	0x3425
    0341C 9180 0508 LDS	R24,time_buf+5
    0341E 5086      SUBI	R24,6
    0341F 9380 0508 STS	time_buf+5,R24
(0468) 											}
    03421 C003      RJMP	0x3425
(0469) 						else time_buf[5]=0x59;						
    03422 E589      LDI	R24,0x59
    03423 9380 0508 STS	time_buf+5,R24
(0470) 					  }
(0471) 		if(keyc==left ) {i=3;    } 		  						 								  			
    03425 316B      CPI	R22,0x1B
    03426 F409      BNE	0x3428
    03427 E043      LDI	R20,3
(0472)  		if(keyc==right) {i=5;   }	
    03428 3167      CPI	R22,0x17
    03429 F009      BEQ	0x342B
    0342A C03E      RJMP	0x3469
    0342B E045      LDI	R20,5
(0473) 		break;			   
    0342C C03C      RJMP	0x3469
(0474)  case 5:p=5;ary=GUI_down;
    0342D E085      LDI	R24,5
    0342E 878A      STD	Y+10,R24
    0342F 01CE      MOVW	R24,R28
    03430 9605      ADIW	R24,5
    03431 016C      MOVW	R12,R24
(0475)  	  	if(keyc==up){ if(time_buf[6]<0x59){  time_buf[6]++;	
    03432 316E      CPI	R22,0x1E
    03433 F499      BNE	0x3447
    03434 9180 0509 LDS	R24,time_buf+6
    03436 3589      CPI	R24,0x59
    03437 F460      BCC	0x3444
    03438 5F8F      SUBI	R24,0xFF
    03439 9380 0509 STS	time_buf+6,R24
(0476) 											 if((time_buf[6]&0x0f)==0x0a) time_buf[6]+=6;
    0343B 708F      ANDI	R24,0xF
    0343C 308A      CPI	R24,0xA
    0343D F449      BNE	0x3447
    0343E 9180 0509 LDS	R24,time_buf+6
    03440 5F8A      SUBI	R24,0xFA
    03441 9380 0509 STS	time_buf+6,R24
(0477) 										 }
    03443 C003      RJMP	0x3447
(0478) 					  else time_buf[6]=0x00;
    03444 2422      CLR	R2
    03445 9220 0509 STS	time_buf+6,R2
(0479) 					}						 
(0480) 		if(keyc==down){ if(time_buf[6]>0x00){  time_buf[6]--;	
    03447 316D      CPI	R22,0x1D
    03448 F4A9      BNE	0x345E
    03449 E080      LDI	R24,0
    0344A 9020 0509 LDS	R2,time_buf+6
    0344C 1582      CP	R24,R2
    0344D F468      BCC	0x345B
    0344E 2D82      MOV	R24,R2
    0344F 5081      SUBI	R24,1
    03450 9380 0509 STS	time_buf+6,R24
(0481) 						if((time_buf[6]&0x0f)==0x0f) time_buf[6]-=6;
    03452 708F      ANDI	R24,0xF
    03453 308F      CPI	R24,0xF
    03454 F449      BNE	0x345E
    03455 9180 0509 LDS	R24,time_buf+6
    03457 5086      SUBI	R24,6
    03458 9380 0509 STS	time_buf+6,R24
(0482) 					  }
    0345A C003      RJMP	0x345E
(0483) 		else time_buf[6]=0x59;		}				
    0345B E589      LDI	R24,0x59
    0345C 9380 0509 STS	time_buf+6,R24
(0484) 		if(keyc==left ) {i=4;    } 		  				 														   
    0345E 316B      CPI	R22,0x1B
    0345F F409      BNE	0x3461
    03460 E044      LDI	R20,4
(0485) 		if(keyc==right) {i=6;p=1;ary=NULL;}  
    03461 3167      CPI	R22,0x17
    03462 F431      BNE	0x3469
    03463 E046      LDI	R20,6
    03464 2400      CLR	R0
    03465 9403      INC	R0
    03466 860A      STD	Y+10,R0
    03467 24CC      CLR	R12
    03468 24DD      CLR	R13
(0486) 		break;           
(0487) 							 
(0488) 		 }//endcase
(0489)  		 dateRefresh(0);
    03469 2700      CLR	R16
    0346A D18B      RCALL	_dateRefresh
(0490) 		 
(0491) 		 LCD_const_disp(3,1,"                "); //清空箭头 
    0346B EA8D      LDI	R24,0xAD
    0346C E093      LDI	R25,3
    0346D 8399      STD	Y+1,R25
    0346E 8388      ST	Y,R24
    0346F E021      LDI	R18,1
    03470 E003      LDI	R16,3
    03471 940E 3974 CALL	_LCD_const_disp
(0492)  		 LCD_var_disp(3,p,ary); //显示箭头 
    03473 82D9      STD	Y+1,R13
    03474 82C8      ST	Y,R12
    03475 852A      LDD	R18,Y+10
    03476 E003      LDI	R16,3
    03477 940E 39A1 CALL	_LCD_var_disp
(0493)  		 LCD_var_disp(2,1,pD);  //显示日期
    03479 8408      LDD	R0,Y+8
    0347A 8419      LDD	R1,Y+9
    0347B 8219      STD	Y+1,R1
    0347C 8208      ST	Y,R0
    0347D E021      LDI	R18,1
    0347E E002      LDI	R16,2
    0347F 940E 39A1 CALL	_LCD_var_disp
(0494)  		 LCD_var_disp(4,1,pT);  //显示时间
    03481 82F9      STD	Y+1,R15
    03482 82E8      ST	Y,R14
    03483 E021      LDI	R18,1
    03484 E004      LDI	R16,4
    03485 940E 39A1 CALL	_LCD_var_disp
(0495)  if(keyc==lright) {		  
    03487 3967      CPI	R22,0x97
    03488 F479      BNE	0x3498
(0496)  		  LCD_const_disp(3,1,"        放弃修改"); 
    03489 E98C      LDI	R24,0x9C
    0348A E093      LDI	R25,3
    0348B 8399      STD	Y+1,R25
    0348C 8388      ST	Y,R24
    0348D E021      LDI	R18,1
    0348E E003      LDI	R16,3
    0348F 940E 3974 CALL	_LCD_const_disp
(0497) 		  delayms(500);
    03491 EF04      LDI	R16,0xF4
    03492 E011      LDI	R17,1
    03493 940E 240B CALL	_delayms
(0498) 		  LCD_CLR(); //清屏
    03495 940E 3A1A CALL	_LCD_CLR
(0499) 		  return ;} 
    03497 C021      RJMP	0x34B9
(0500)  keyc=NO_KEY;
    03498 2766      CLR	R22
(0501)  if(i==6){    //各值改变完成后 显示已保存 清屏 返回
    03499 3046      CPI	R20,6
    0349A F4C9      BNE	0x34B4
(0502) 		  ds1302_write_time(); 
    0349B 940E 3F16 CALL	_ds1302_write_time
(0503)           LCD_const_disp(4,7,"    ");		  
    0349D E987      LDI	R24,0x97
    0349E E093      LDI	R25,3
    0349F 8399      STD	Y+1,R25
    034A0 8388      ST	Y,R24
    034A1 E027      LDI	R18,7
    034A2 E004      LDI	R16,4
    034A3 940E 3974 CALL	_LCD_const_disp
(0504) 		  LCD_const_disp(3,1,"          已保存"); 
    034A5 E886      LDI	R24,0x86
    034A6 E093      LDI	R25,3
    034A7 8399      STD	Y+1,R25
    034A8 8388      ST	Y,R24
    034A9 E021      LDI	R18,1
    034AA E003      LDI	R16,3
    034AB 940E 3974 CALL	_LCD_const_disp
(0505) 		  delayms(300);
    034AD E20C      LDI	R16,0x2C
    034AE E011      LDI	R17,1
    034AF 940E 240B CALL	_delayms
(0506) 		  LCD_CLR(); //清屏
    034B1 940E 3A1A CALL	_LCD_CLR
(0507) 		  return ;
    034B3 C005      RJMP	0x34B9
(0508) 		  }
(0509)  delayms(2);	  
    034B4 E002      LDI	R16,2
    034B5 E010      LDI	R17,0
    034B6 940E 240B CALL	_delayms
    034B8 CE13      RJMP	0x32CC
    034B9 962B      ADIW	R28,0xB
    034BA 940C 4106 JMP	pop_xgsetF0FC
_GUI_readback:
  index                --> Y,+3
  page                 --> R10
  key                  --> R14
  buf                  --> R12
    034BC 940E 4111 CALL	push_xgsetF0FC
    034BE 0168      MOVW	R12,R16
    034BF 9727      SBIW	R28,7
(0510) }//endwhile(1)
(0511) }
(0512) void GUI_readback(char *buf){
(0513)     char key=0;
    034C0 24EE      CLR	R14
(0514) 	char page=0;
    034C1 24AA      CLR	R10
(0515) 	long index=Result.Index;
    034C2 9040 056B LDS	R4,Result+12
    034C4 9050 056C LDS	R5,Result+13
    034C6 9020 0569 LDS	R2,Result+10
    034C8 9030 056A LDS	R3,Result+11
    034CA 822B      STD	Y+3,R2
    034CB 823C      STD	Y+4,R3
    034CC 824D      STD	Y+5,R4
    034CD 825E      STD	Y+6,R5
(0516) 	LCD_CLR(); //清屏
    034CE 940E 3A1A CALL	_LCD_CLR
(0517) 	LCD_const_disp(1,1,"菜单/ 检测");
    034D0 EB81      LDI	R24,0xB1
    034D1 E094      LDI	R25,4
    034D2 8399      STD	Y+1,R25
    034D3 8388      ST	Y,R24
    034D4 E021      LDI	R18,1
    034D5 E001      LDI	R16,1
    034D6 940E 3974 CALL	_LCD_const_disp
(0518)     LCD_const_disp(2,3,"最后一次");		 
    034D8 E78D      LDI	R24,0x7D
    034D9 E093      LDI	R25,3
    034DA 8399      STD	Y+1,R25
    034DB 8388      ST	Y,R24
    034DC E023      LDI	R18,3
    034DD E002      LDI	R16,2
    034DE 940E 3974 CALL	_LCD_const_disp
(0519) 	LCD_const_disp(3,3,"按顺序");
    034E0 E786      LDI	R24,0x76
    034E1 E093      LDI	R25,3
    034E2 8399      STD	Y+1,R25
    034E3 8388      ST	Y,R24
    034E4 E023      LDI	R18,3
    034E5 E003      LDI	R16,3
    034E6 940E 3974 CALL	_LCD_const_disp
    034E8 C061      RJMP	0x354A
(0520) 	//<<菜单/检测/手（自）动>>
(0521) while(1){
(0522)  	key=kbscan();
    034E9 940E 3F63 CALL	_kbscan
    034EB 2EE0      MOV	R14,R16
(0523) 	//上键短按 选择
(0524) 	if(key==up || key ==down){
    034EC 2D8E      MOV	R24,R14
    034ED 310E      CPI	R16,0x1E
    034EE F011      BEQ	0x34F1
    034EF 310D      CPI	R16,0x1D
    034F0 F5E1      BNE	0x352D
(0525) 	    if(config.readMode == 0){
    034F1 9020 07E2 LDS	R2,config+19
    034F3 2022      TST	R2
    034F4 F501      BNE	0x3515
(0526) 		    config.readMode=1;
    034F5 E081      LDI	R24,1
    034F6 9380 07E2 STS	config+19,R24
(0527) 			Set_White(1,2,8,0);
    034F8 2422      CLR	R2
    034F9 822A      STD	Y+2,R2
    034FA E088      LDI	R24,0x8
    034FB 8388      ST	Y,R24
    034FC E022      LDI	R18,2
    034FD E001      LDI	R16,1
    034FE 940E 3AA4 CALL	_Set_White
(0528)  			Set_White(1,3,8,1);
    03500 E081      LDI	R24,1
    03501 838A      STD	Y+2,R24
    03502 E088      LDI	R24,0x8
    03503 8388      ST	Y,R24
    03504 E023      LDI	R18,3
    03505 E001      LDI	R16,1
    03506 940E 3AA4 CALL	_Set_White
(0529) 			index=Result.Index;	
    03508 9040 056B LDS	R4,Result+12
    0350A 9050 056C LDS	R5,Result+13
    0350C 9020 0569 LDS	R2,Result+10
    0350E 9030 056A LDS	R3,Result+11
    03510 822B      STD	Y+3,R2
    03511 823C      STD	Y+4,R3
    03512 824D      STD	Y+5,R4
    03513 825E      STD	Y+6,R5
(0530) 		}
    03514 C018      RJMP	0x352D
(0531) 		else {
(0532) 		    config.readMode=0;
    03515 2422      CLR	R2
    03516 9220 07E2 STS	config+19,R2
(0533) 			Set_White(1,2,8,1);
    03518 E081      LDI	R24,1
    03519 838A      STD	Y+2,R24
    0351A E088      LDI	R24,0x8
    0351B 8388      ST	Y,R24
    0351C E022      LDI	R18,2
    0351D E001      LDI	R16,1
    0351E 940E 3AA4 CALL	_Set_White
(0534)  			Set_White(1,3,8,0);
    03520 2422      CLR	R2
    03521 822A      STD	Y+2,R2
    03522 E088      LDI	R24,0x8
    03523 8388      ST	Y,R24
    03524 E023      LDI	R18,3
    03525 E001      LDI	R16,1
    03526 940E 3AA4 CALL	_Set_White
(0535) 			index=0;
    03528 E080      LDI	R24,0
    03529 838B      STD	Y+3,R24
    0352A 838C      STD	Y+4,R24
    0352B 838D      STD	Y+5,R24
    0352C 838E      STD	Y+6,R24
(0536) 		}
(0537) 		
(0538) 	}
(0539) 	//左键短按  进入
(0540) 	if(key == left) {
    0352D 2D8E      MOV	R24,R14
    0352E 318B      CPI	R24,0x1B
    0352F F4A9      BNE	0x3545
(0541) 		Set_White(1,2,8,1);
    03530 E081      LDI	R24,1
    03531 838A      STD	Y+2,R24
    03532 E088      LDI	R24,0x8
    03533 8388      ST	Y,R24
    03534 E022      LDI	R18,2
    03535 E001      LDI	R16,1
    03536 940E 3AA4 CALL	_Set_White
(0542)  		Set_White(1,3,8,1);
    03538 E081      LDI	R24,1
    03539 838A      STD	Y+2,R24
    0353A E088      LDI	R24,0x8
    0353B 8388      ST	Y,R24
    0353C E023      LDI	R18,3
    0353D E001      LDI	R16,1
    0353E 940E 3AA4 CALL	_Set_White
(0543) 		delayms(100);
    03540 E604      LDI	R16,0x64
    03541 E010      LDI	R17,0
    03542 940E 240B CALL	_delayms
(0544) 		break ;		
    03544 C006      RJMP	0x354B
(0545) 	}
(0546) 	//右键短按  返回
(0547) 	if(key == right) {
    03545 2D8E      MOV	R24,R14
    03546 3187      CPI	R24,0x17
    03547 F409      BNE	0x3549
(0548) 		return ;		
    03548 C08D      RJMP	0x35D6
(0549) 	}
(0550) 	key=0;
    03549 24EE      CLR	R14
    0354A CF9E      RJMP	0x34E9
(0551) } //end of while
(0552) ReadSDFile(index,buf);
    0354B 0196      MOVW	R18,R12
    0354C 810B      LDD	R16,Y+3
    0354D 811C      LDD	R17,Y+4
    0354E 940E 2657 CALL	_ReadSDFile
(0553) CharToStruct();
    03550 940E 2A04 CALL	_CharToStruct
    03552 C082      RJMP	0x35D5
(0554) while(1){
(0555) 	key=kbscan();
    03553 940E 3F63 CALL	_kbscan
    03555 2EE0      MOV	R14,R16
(0556) 	if(key != 0) beep(0,1);
    03556 2300      TST	R16
    03557 F021      BEQ	0x355C
    03558 E021      LDI	R18,1
    03559 2700      CLR	R16
    0355A 940E 3CEF CALL	_beep
(0557) 	dateRefresh(0);
    0355C 2700      CLR	R16
    0355D D098      RCALL	_dateRefresh
(0558) 	_GUI_datashow(page);
    0355E 2D0A      MOV	R16,R10
    0355F DADA      RCALL	__GUI_datashow
(0559) 	if( key==left ){ //按left键下一条
    03560 2D8E      MOV	R24,R14
    03561 318B      CPI	R24,0x1B
    03562 F541      BNE	0x358B
(0560) pre_item:
(0561) 		if(index < Result.Index){
    03563 9040 056B LDS	R4,Result+12
    03565 9050 056C LDS	R5,Result+13
    03567 9020 0569 LDS	R2,Result+10
    03569 9030 056A LDS	R3,Result+11
    0356B 806B      LDD	R6,Y+3
    0356C 807C      LDD	R7,Y+4
    0356D 808D      LDD	R8,Y+5
    0356E 809E      LDD	R9,Y+6
    0356F 1462      CP	R6,R2
    03570 0473      CPC	R7,R3
    03571 0484      CPC	R8,R4
    03572 0495      CPC	R9,R5
    03573 F4B0      BCC	0x358A
(0562) 		    index++;
    03574 E041      LDI	R20,1
    03575 E050      LDI	R21,0
    03576 E060      LDI	R22,0
    03577 E070      LDI	R23,0
    03578 0113      MOVW	R2,R6
    03579 0124      MOVW	R4,R8
    0357A 0E24      ADD	R2,R20
    0357B 1E35      ADC	R3,R21
    0357C 1E46      ADC	R4,R22
    0357D 1E57      ADC	R5,R23
    0357E 822B      STD	Y+3,R2
    0357F 823C      STD	Y+4,R3
    03580 824D      STD	Y+5,R4
    03581 825E      STD	Y+6,R5
(0563) 			ReadSDFile(index,buf);
    03582 0196      MOVW	R18,R12
    03583 810B      LDD	R16,Y+3
    03584 811C      LDD	R17,Y+4
    03585 940E 2657 CALL	_ReadSDFile
(0564) 			CharToStruct();
    03587 940E 2A04 CALL	_CharToStruct
(0565) 			page = 0;
    03589 24AA      CLR	R10
(0566) 		}
(0567) 		key=0;
    0358A 24EE      CLR	R14
(0568) 	}
(0569) 	if( key==lleft ){ //长按按left键上一条
    0358B 2D8E      MOV	R24,R14
    0358C 398B      CPI	R24,0x9B
    0358D F511      BNE	0x35B0
(0570) next_item:
(0571) 		if(index > 0){
    0358E E040      LDI	R20,0
    0358F E050      LDI	R21,0
    03590 E060      LDI	R22,0
    03591 E070      LDI	R23,0
    03592 802B      LDD	R2,Y+3
    03593 803C      LDD	R3,Y+4
    03594 804D      LDD	R4,Y+5
    03595 805E      LDD	R5,Y+6
    03596 1542      CP	R20,R2
    03597 0553      CPC	R21,R3
    03598 0564      CPC	R22,R4
    03599 0575      CPC	R23,R5
    0359A F4A4      BGE	0x35AF
(0572) 		    index--;
    0359B E041      LDI	R20,1
    0359C E050      LDI	R21,0
    0359D E060      LDI	R22,0
    0359E E070      LDI	R23,0
    0359F 1A24      SUB	R2,R20
    035A0 0A35      SBC	R3,R21
    035A1 0A46      SBC	R4,R22
    035A2 0A57      SBC	R5,R23
    035A3 822B      STD	Y+3,R2
    035A4 823C      STD	Y+4,R3
    035A5 824D      STD	Y+5,R4
    035A6 825E      STD	Y+6,R5
(0573) 			ReadSDFile(index,buf);
    035A7 0196      MOVW	R18,R12
    035A8 810B      LDD	R16,Y+3
    035A9 811C      LDD	R17,Y+4
    035AA 940E 2657 CALL	_ReadSDFile
(0574) 			CharToStruct();
    035AC 940E 2A04 CALL	_CharToStruct
(0575) 			page = 0;
    035AE 24AA      CLR	R10
(0576) 		}
(0577) 		key=0;
    035AF 24EE      CLR	R14
(0578) 	}
(0579) 	
(0580) 	if(key==up){ //上键 : 页面减 
    035B0 2D8E      MOV	R24,R14
    035B1 318E      CPI	R24,0x1E
    035B2 F449      BNE	0x35BC
(0581) 	    if(page>0) page--;
    035B3 E080      LDI	R24,0
    035B4 158A      CP	R24,R10
    035B5 F008      BCS	0x35B7
    035B6 CFAC      RJMP	0x3563
    035B7 94AA      DEC	R10
(0582) 	    else goto pre_item;
(0583) 		LCD_CLR();
    035B8 940E 3A1A CALL	_LCD_CLR
(0584) 	    LCD_Init();
    035BA 940E 39E8 CALL	_LCD_Init
(0585) 		
(0586) 	}
(0587) 	if(key==down){ //下键 ： 页面加
    035BC 2D8E      MOV	R24,R14
    035BD 318D      CPI	R24,0x1D
    035BE F441      BNE	0x35C7
(0588) 	    if(page<5) page++;
    035BF 2D8A      MOV	R24,R10
    035C0 3085      CPI	R24,5
    035C1 F660      BCC	0x358E
    035C2 94A3      INC	R10
(0589) 	  	else goto next_item;
(0590) 	    LCD_CLR();
    035C3 940E 3A1A CALL	_LCD_CLR
(0591) 	    LCD_Init();
    035C5 940E 39E8 CALL	_LCD_Init
(0592) 	}
(0593) 	if(key==right){	//右键 退出
    035C7 2D8E      MOV	R24,R14
    035C8 3187      CPI	R24,0x17
    035C9 F439      BNE	0x35D1
(0594) 	    beep(0,1); 
    035CA E021      LDI	R18,1
    035CB 2700      CLR	R16
    035CC 940E 3CEF CALL	_beep
(0595) 	 	LCD_CLR();
    035CE 940E 3A1A CALL	_LCD_CLR
(0596) 	 	return ;
    035D0 C005      RJMP	0x35D6
(0597) 	}
(0598) 	
(0599)     delayms(30); 
    035D1 E10E      LDI	R16,0x1E
    035D2 E010      LDI	R17,0
    035D3 940E 240B CALL	_delayms
    035D5 CF7D      RJMP	0x3553
    035D6 9627      ADIW	R28,7
    035D7 940C 4106 JMP	pop_xgsetF0FC
_GUI_welcome:
    035D9 9722      SBIW	R28,2
(0600) }//end while
(0601) }
(0602) void GUI_welcome(void){
(0603)     LCD_CLR(); //清屏
    035DA 940E 3A1A CALL	_LCD_CLR
(0604) 	LCD_const_disp(2,3,"欢迎使用");
    035DC E68D      LDI	R24,0x6D
    035DD E093      LDI	R25,3
    035DE 8399      STD	Y+1,R25
    035DF 8388      ST	Y,R24
    035E0 E023      LDI	R18,3
    035E1 E002      LDI	R16,2
    035E2 940E 3974 CALL	_LCD_const_disp
(0605) 	LCD_const_disp(3,1,"环境冷强度检测仪");
    035E4 E58C      LDI	R24,0x5C
    035E5 E093      LDI	R25,3
    035E6 8399      STD	Y+1,R25
    035E7 8388      ST	Y,R24
    035E8 E021      LDI	R18,1
    035E9 E003      LDI	R16,3
    035EA 940E 3974 CALL	_LCD_const_disp
(0606) 	delayms(800);
    035EC E200      LDI	R16,0x20
    035ED E013      LDI	R17,3
    035EE 940E 240B CALL	_delayms
(0607) 	beep(0,1);
    035F0 E021      LDI	R18,1
    035F1 2700      CLR	R16
    035F2 940E 3CEF CALL	_beep
    035F4 9622      ADIW	R28,2
    035F5 9508      RET
_dateRefresh:
  readhardware         --> R20
    035F6 934A      ST	-Y,R20
    035F7 935A      ST	-Y,R21
    035F8 2F40      MOV	R20,R16
(0608) 	
(0609) }
(0610) 
(0611) ////////////////////////////////////
(0612) //  函数作用
(0613) //   将ds1302中缓存的时钟数据转换进结构体中
(0614) ////////////////////////////////////
(0615) void dateRefresh(unsigned char readhardware)
(0616) {	//readhardware = 0 not refresh, =1 refresh
(0617) 	ds1302_read_time();
    035F9 940E 3F3B CALL	_ds1302_read_time
(0618) 	t.tm_sec=(((time_buf[6]&0x70)>>4)*10)+(time_buf[6]&0x0f);
    035FB 9110 0509 LDS	R17,time_buf+6
    035FD 7710      ANDI	R17,0x70
    035FE 9512      SWAP	R17
    035FF 701F      ANDI	R17,0xF
    03600 E00A      LDI	R16,0xA
    03601 0301      MULSU	R16,R17
    03602 0110      MOVW	R2,R0
    03603 9180 0509 LDS	R24,time_buf+6
    03605 2799      CLR	R25
    03606 708F      ANDI	R24,0xF
    03607 7090      ANDI	R25,0
    03608 0E28      ADD	R2,R24
    03609 1E39      ADC	R3,R25
    0360A 9230 07BE STS	t+1,R3
    0360C 9220 07BD STS	t,R2
(0619) 	t.tm_min=  (((time_buf[5]&0x70)>>4)*10)+(time_buf[5]&0x0f);
    0360E 9110 0508 LDS	R17,time_buf+5
    03610 7710      ANDI	R17,0x70
    03611 9512      SWAP	R17
    03612 701F      ANDI	R17,0xF
    03613 0301      MULSU	R16,R17
    03614 0110      MOVW	R2,R0
    03615 9180 0508 LDS	R24,time_buf+5
    03617 2799      CLR	R25
    03618 708F      ANDI	R24,0xF
    03619 7090      ANDI	R25,0
    0361A 0E28      ADD	R2,R24
    0361B 1E39      ADC	R3,R25
    0361C 9230 07C0 STS	t+3,R3
    0361E 9220 07BF STS	t+2,R2
(0620) 	t.tm_hour=  (((time_buf[4]&0x70)>>4)*10)+(time_buf[4]&0x0f);
    03620 9110 0507 LDS	R17,time_buf+4
    03622 7710      ANDI	R17,0x70
    03623 9512      SWAP	R17
    03624 701F      ANDI	R17,0xF
    03625 0301      MULSU	R16,R17
    03626 0110      MOVW	R2,R0
    03627 9180 0507 LDS	R24,time_buf+4
    03629 2799      CLR	R25
    0362A 708F      ANDI	R24,0xF
    0362B 7090      ANDI	R25,0
    0362C 0E28      ADD	R2,R24
    0362D 1E39      ADC	R3,R25
    0362E 9230 07C2 STS	t+5,R3
    03630 9220 07C1 STS	t+4,R2
(0621) 	t.tm_mday=	(((time_buf[3]&0x70)>>4)*10)+(time_buf[3]&0x0f);
    03632 9110 0506 LDS	R17,time_buf+3
    03634 7710      ANDI	R17,0x70
    03635 9512      SWAP	R17
    03636 701F      ANDI	R17,0xF
    03637 0301      MULSU	R16,R17
    03638 0110      MOVW	R2,R0
    03639 9180 0506 LDS	R24,time_buf+3
    0363B 2799      CLR	R25
    0363C 708F      ANDI	R24,0xF
    0363D 7090      ANDI	R25,0
    0363E 0E28      ADD	R2,R24
    0363F 1E39      ADC	R3,R25
    03640 9230 07C4 STS	t+7,R3
    03642 9220 07C3 STS	t+6,R2
(0622) 	t.tm_mon= (((time_buf[2]&0x70)>>4)*10)+(time_buf[2]&0x0f);
    03644 9110 0505 LDS	R17,time_buf+2
    03646 7710      ANDI	R17,0x70
    03647 9512      SWAP	R17
    03648 701F      ANDI	R17,0xF
    03649 0301      MULSU	R16,R17
    0364A 0110      MOVW	R2,R0
    0364B 9180 0505 LDS	R24,time_buf+2
    0364D 2799      CLR	R25
    0364E 708F      ANDI	R24,0xF
    0364F 7090      ANDI	R25,0
    03650 0E28      ADD	R2,R24
    03651 1E39      ADC	R3,R25
    03652 9230 07C6 STS	t+9,R3
    03654 9220 07C5 STS	t+8,R2
(0623) 	t.tm_wday=	(time_buf[7]&0x0f);
    03656 9180 050A LDS	R24,time_buf+7
    03658 2799      CLR	R25
    03659 708F      ANDI	R24,0xF
    0365A 7090      ANDI	R25,0
    0365B 9390 07CA STS	t+13,R25
    0365D 9380 07C9 STS	t+12,R24
(0624)     t.tm_year=	(((time_buf[1]&0x70)>>4)*10)+(time_buf[1]&0x0f);
    0365F 9110 0504 LDS	R17,time_buf+1
    03661 7710      ANDI	R17,0x70
    03662 9512      SWAP	R17
    03663 701F      ANDI	R17,0xF
    03664 0301      MULSU	R16,R17
    03665 0110      MOVW	R2,R0
    03666 9180 0504 LDS	R24,time_buf+1
    03668 2799      CLR	R25
    03669 708F      ANDI	R24,0xF
    0366A 7090      ANDI	R25,0
    0366B 0E28      ADD	R2,R24
    0366C 1E39      ADC	R3,R25
    0366D 9230 07C8 STS	t+11,R3
    0366F 9220 07C7 STS	t+10,R2
(0625) 	config.now =t.tm_hour*3600 + t.tm_min*60 + t.tm_sec; //更新系统心跳
    03671 9120 07BF LDS	R18,t+2
    03673 9130 07C0 LDS	R19,t+3
    03675 E30C      LDI	R16,0x3C
    03676 E010      LDI	R17,0
    03677 940E 40AD CALL	empy16s
    03679 0118      MOVW	R2,R16
    0367A 9120 07C1 LDS	R18,t+4
    0367C 9130 07C2 LDS	R19,t+5
    0367E E100      LDI	R16,0x10
    0367F E01E      LDI	R17,0xE
    03680 940E 40AD CALL	empy16s
    03682 0128      MOVW	R4,R16
    03683 0C42      ADD	R4,R2
    03684 1C53      ADC	R5,R3
    03685 9020 07BD LDS	R2,t
    03687 9030 07BE LDS	R3,t+1
    03689 0C42      ADD	R4,R2
    0368A 1C53      ADC	R5,R3
    0368B 0112      MOVW	R2,R4
    0368C 2444      CLR	R4
    0368D FC37      SBRC	R3,7
    0368E 9440      COM	R4
    0368F 2455      CLR	R5
    03690 FC47      SBRC	R4,7
    03691 9450      COM	R5
    03692 9230 07DC STS	config+13,R3
    03694 9220 07DB STS	config+12,R2
    03696 9250 07DE STS	config+15,R5
    03698 9240 07DD STS	config+14,R4
(0626) 	if( readhardware >=1 ){  
    0369A 3041      CPI	R20,1
    0369B F408      BCC	0x369D
    0369C C0B6      RJMP	0x3753
(0627) 	config.Relay=relay(!config.Relay);
    0369D 9020 07D0 LDS	R2,config+1
    0369F 2022      TST	R2
    036A0 F419      BNE	0x36A4
    036A1 E041      LDI	R20,1
    036A2 E050      LDI	R21,0
    036A3 C002      RJMP	0x36A6
    036A4 2744      CLR	R20
    036A5 2755      CLR	R21
    036A6 018A      MOVW	R16,R20
    036A7 940E 3CE4 CALL	_relay
    036A9 9300 07D0 STS	config+1,R16
(0628) 	Result.Date[0]='2';
    036AB E382      LDI	R24,0x32
    036AC 9380 0575 STS	Result+22,R24
(0629) 	Result.Date[1]='0';
    036AE E380      LDI	R24,0x30
    036AF 9380 0576 STS	Result+23,R24
(0630) 	Result.Date[2]=t.tm_year/10+'0';
    036B1 E02A      LDI	R18,0xA
    036B2 E030      LDI	R19,0
    036B3 9100 07C7 LDS	R16,t+10
    036B5 9110 07C8 LDS	R17,t+11
    036B7 940E 3FE1 CALL	div16s
    036B9 01C8      MOVW	R24,R16
    036BA 96C0      ADIW	R24,0x30
    036BB 9380 0577 STS	Result+24,R24
(0631) 	Result.Date[3]=t.tm_year%10+'0';
    036BD E02A      LDI	R18,0xA
    036BE E030      LDI	R19,0
    036BF 9100 07C7 LDS	R16,t+10
    036C1 9110 07C8 LDS	R17,t+11
    036C3 940E 3FDD CALL	mod16s
    036C5 01C8      MOVW	R24,R16
    036C6 96C0      ADIW	R24,0x30
    036C7 9380 0578 STS	Result+25,R24
(0632) 	Result.Date[4]=t.tm_mon/10+'0';
    036C9 E02A      LDI	R18,0xA
    036CA E030      LDI	R19,0
    036CB 9100 07C5 LDS	R16,t+8
    036CD 9110 07C6 LDS	R17,t+9
    036CF 940E 3FE1 CALL	div16s
    036D1 01C8      MOVW	R24,R16
    036D2 96C0      ADIW	R24,0x30
    036D3 9380 0579 STS	Result+26,R24
(0633) 	Result.Date[5]=t.tm_mon%10+'0';
    036D5 E02A      LDI	R18,0xA
    036D6 E030      LDI	R19,0
    036D7 9100 07C5 LDS	R16,t+8
    036D9 9110 07C6 LDS	R17,t+9
    036DB 940E 3FDD CALL	mod16s
    036DD 01C8      MOVW	R24,R16
    036DE 96C0      ADIW	R24,0x30
    036DF 9380 057A STS	Result+27,R24
(0634) 	Result.Date[6]=t.tm_mday/10+'0';
    036E1 E02A      LDI	R18,0xA
    036E2 E030      LDI	R19,0
    036E3 9100 07C3 LDS	R16,t+6
    036E5 9110 07C4 LDS	R17,t+7
    036E7 940E 3FE1 CALL	div16s
    036E9 01C8      MOVW	R24,R16
    036EA 96C0      ADIW	R24,0x30
    036EB 9380 057B STS	Result+28,R24
(0635) 	Result.Date[7]=t.tm_mday%10+'0';
    036ED E02A      LDI	R18,0xA
    036EE E030      LDI	R19,0
    036EF 9100 07C3 LDS	R16,t+6
    036F1 9110 07C4 LDS	R17,t+7
    036F3 940E 3FDD CALL	mod16s
    036F5 01C8      MOVW	R24,R16
    036F6 96C0      ADIW	R24,0x30
    036F7 9380 057C STS	Result+29,R24
(0636)     Result.Date[8]='\0';
    036F9 2422      CLR	R2
    036FA 9220 057D STS	Result+30,R2
(0637) 	Result.Time[0]=t.tm_hour/10+'0';
    036FC E02A      LDI	R18,0xA
    036FD E030      LDI	R19,0
    036FE 9100 07C1 LDS	R16,t+4
    03700 9110 07C2 LDS	R17,t+5
    03702 940E 3FE1 CALL	div16s
    03704 01C8      MOVW	R24,R16
    03705 96C0      ADIW	R24,0x30
    03706 9380 057E STS	Result+31,R24
(0638) 	Result.Time[1]=t.tm_hour%10+'0';
    03708 E02A      LDI	R18,0xA
    03709 E030      LDI	R19,0
    0370A 9100 07C1 LDS	R16,t+4
    0370C 9110 07C2 LDS	R17,t+5
    0370E 940E 3FDD CALL	mod16s
    03710 01C8      MOVW	R24,R16
    03711 96C0      ADIW	R24,0x30
    03712 9380 057F STS	Result+32,R24
(0639) 	Result.Time[2]=':';
    03714 E38A      LDI	R24,0x3A
    03715 9380 0580 STS	Result+33,R24
(0640) 	Result.Time[3]=' ';
    03717 E280      LDI	R24,0x20
    03718 9380 0581 STS	Result+34,R24
(0641) 	Result.Time[4]=t.tm_min/10+'0';
    0371A E02A      LDI	R18,0xA
    0371B E030      LDI	R19,0
    0371C 9100 07BF LDS	R16,t+2
    0371E 9110 07C0 LDS	R17,t+3
    03720 940E 3FE1 CALL	div16s
    03722 01C8      MOVW	R24,R16
    03723 96C0      ADIW	R24,0x30
    03724 9380 0582 STS	Result+35,R24
(0642) 	Result.Time[5]=t.tm_min%10+'0';
    03726 E02A      LDI	R18,0xA
    03727 E030      LDI	R19,0
    03728 9100 07BF LDS	R16,t+2
    0372A 9110 07C0 LDS	R17,t+3
    0372C 940E 3FDD CALL	mod16s
    0372E 01C8      MOVW	R24,R16
    0372F 96C0      ADIW	R24,0x30
    03730 9380 0583 STS	Result+36,R24
(0643) 	Result.Time[6]=':';
    03732 E38A      LDI	R24,0x3A
    03733 9380 0584 STS	Result+37,R24
(0644) 	Result.Time[7]=' ';
    03735 E280      LDI	R24,0x20
    03736 9380 0585 STS	Result+38,R24
(0645) 	Result.Time[8]=t.tm_sec/10+'0';
    03738 E02A      LDI	R18,0xA
    03739 E030      LDI	R19,0
    0373A 9100 07BD LDS	R16,t
    0373C 9110 07BE LDS	R17,t+1
    0373E 940E 3FE1 CALL	div16s
    03740 01C8      MOVW	R24,R16
    03741 96C0      ADIW	R24,0x30
    03742 9380 0586 STS	Result+39,R24
(0646) 	Result.Time[9]=t.tm_sec%10+'0';
    03744 E02A      LDI	R18,0xA
    03745 E030      LDI	R19,0
    03746 9100 07BD LDS	R16,t
    03748 9110 07BE LDS	R17,t+1
    0374A 940E 3FDD CALL	mod16s
    0374C 01C8      MOVW	R24,R16
    0374D 96C0      ADIW	R24,0x30
    0374E 9380 0587 STS	Result+40,R24
(0647) 	Result.Time[10]='\0'; 
    03750 2422      CLR	R2
    03751 9220 0588 STS	Result+41,R2
(0648) 	}
    03753 9159      LD	R21,Y+
    03754 9149      LD	R20,Y+
    03755 9508      RET
FILE: D:\LQD\software\master\software_src\usart.c
(0001) #include "config.h"
(0002) 
(0003) 
(0004) #define fosc 7372800UL //晶振7.3728MHZ
(0005) #define baud 38400  //波特率
(0006) //串口通信初始化  MEGA128
(0007) //UART1 initialize
(0008) // desired baud rate:38400
(0009) // actual baud rate:38400 (0.0%)
(0010) // char size: 8 bit
(0011) // parity: Disabled
(0012) void uart1_init(void)
(0013) {
(0014)  	 UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    03756 2422      CLR	R2
    03757 9220 009A STS	0x9A,R2
(0015)      UCSR1A = 0x00;
    03759 9220 009B STS	0x9B,R2
(0016)      UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//8bit+1bit stop
    0375B E086      LDI	R24,6
    0375C 9380 009D STS	0x9D,R24
(0017)      UBRR1L=(fosc/16/(baud+1))%256;
    0375E E08B      LDI	R24,0xB
    0375F 9380 0099 STS	0x99,R24
(0018)      UBRR1H=(fosc/16/(baud+1))/256;
    03761 9220 0098 STS	0x98,R2
(0019)      UCSR1B =(1<<RXEN1)|(1<<TXEN1);//RXCEN TXCEN
    03763 E188      LDI	R24,0x18
    03764 9380 009A STS	0x9A,R24
    03766 9508      RET
_uart1_rx_isr:
  tmp                  --> R16
    03767 930A      ST	-Y,R16
    03768 B70F      IN	R16,0x3F
    03769 930A      ST	-Y,R16
(0020) }
(0021) 
(0022) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0023) void uart1_rx_isr(void){   
(0024) 	 char tmp;
(0025) 	 tmp=UDR1;
    0376A 9100 009C LDS	R16,0x9C
    0376C 9109      LD	R16,Y+
    0376D BF0F      OUT	0x3F,R16
    0376E 9109      LD	R16,Y+
    0376F 9518      RETI
(0026) }
(0027) 
(0028) void Usart_Transmit(char c)
(0029) {
(0030)  	 while (!(UCSR1A&(1<<UDRE1)));//表明发送器一准备就绪
_Usart_Transmit:
  c                    --> R16
    03770 9020 009B LDS	R2,0x9B
    03772 FE25      SBRS	R2,5
    03773 CFFC      RJMP	_Usart_Transmit
(0031) 	 UDR1=c;
    03774 9300 009C STS	0x9C,R16
    03776 9508      RET
_Puts:
  s                    --> R20
    03777 934A      ST	-Y,R20
    03778 935A      ST	-Y,R21
    03779 01A8      MOVW	R20,R16
(0032) }
(0033) 
(0034) //串口输出字符串
(0035) void Puts( unsigned char *s)
(0036) { 
    0377A C00B      RJMP	0x3786
(0037) 	 while (*s) 
(0038)       { 
(0039) 	  //为数据间的隔断创造一个串口能显示的隔断字符 即'/t'  ->  ' '
(0040) 	  if(*s==0x09)  
    0377B 01FA      MOVW	R30,R20
    0377C 8180      LD	R24,Z
    0377D 3089      CPI	R24,0x9
    0377E F411      BNE	0x3781
(0041) 	  {   Usart_Transmit(' ');    }
    0377F E200      LDI	R16,0x20
    03780 DFEF      RCALL	_Usart_Transmit
(0042) 	 Usart_Transmit(*s);
    03781 01FA      MOVW	R30,R20
    03782 8100      LD	R16,Z
    03783 DFEC      RCALL	_Usart_Transmit
(0043) 	 s++;
    03784 5F4F      SUBI	R20,0xFF
    03785 4F5F      SBCI	R21,0xFF
    03786 01FA      MOVW	R30,R20
    03787 8020      LD	R2,Z
    03788 2022      TST	R2
    03789 F789      BNE	0x377B
    0378A 9159      LD	R21,Y+
    0378B 9149      LD	R20,Y+
    0378C 9508      RET
_Send_nByte:
  i                    --> R20
  len                  --> R10
  p                    --> R12
    0378D 940E 413E CALL	push_xgset303C
    0378F 2EA2      MOV	R10,R18
    03790 0168      MOVW	R12,R16
(0044) 	
(0045) 	
(0046)       }
(0047) }
(0048) 
(0049) 
(0050) 
(0051) void Send_nByte(unsigned char *p, unsigned char len)
(0052) { 
(0053)   int i = 0;
(0054)   for(i=0;i<len;i++)
    03791 2744      CLR	R20
    03792 2755      CLR	R21
    03793 C007      RJMP	0x379B
(0055)   {
(0056)    	Usart_Transmit(*(p+i));
    03794 01FA      MOVW	R30,R20
    03795 0DEC      ADD	R30,R12
    03796 1DFD      ADC	R31,R13
    03797 8100      LD	R16,Z
    03798 DFD7      RCALL	_Usart_Transmit
    03799 5F4F      SUBI	R20,0xFF
    0379A 4F5F      SBCI	R21,0xFF
    0379B 2C2A      MOV	R2,R10
    0379C 2433      CLR	R3
    0379D 1542      CP	R20,R2
    0379E 0553      CPC	R21,R3
    0379F F3A4      BLT	0x3794
    037A0 940C 4145 JMP	pop_xgset303C
_PrintString:
  str                  --> R10
    037A2 92AA      ST	-Y,R10
    037A3 92BA      ST	-Y,R11
    037A4 0158      MOVW	R10,R16
(0057)   }
(0058) }
(0059) 
(0060) void  PrintString(const unsigned char *str)
(0061) {    
    037A5 C004      RJMP	0x37AA
(0062) 	while(*str!=0)	Usart_Transmit(*str++);
    037A6 01F5      MOVW	R30,R10
    037A7 9101      LD	R16,Z+
    037A8 015F      MOVW	R10,R30
    037A9 DFC6      RCALL	_Usart_Transmit
    037AA 01F5      MOVW	R30,R10
    037AB 8020      LD	R2,Z
    037AC 2022      TST	R2
    037AD F7C1      BNE	0x37A6
    037AE 90B9      LD	R11,Y+
    037AF 90A9      LD	R10,Y+
    037B0 9508      RET
_PrintString_n:
  str                  --> R10
    037B1 92AA      ST	-Y,R10
    037B2 92BA      ST	-Y,R11
    037B3 0158      MOVW	R10,R16
(0063) }
(0064) void  PrintString_n(const unsigned char *str)
(0065) {   
(0066) 	Usart_Transmit('\r');
    037B4 E00D      LDI	R16,0xD
    037B5 DFBA      RCALL	_Usart_Transmit
(0067) 	Usart_Transmit('\n'); 
    037B6 E00A      LDI	R16,0xA
    037B7 DFB8      RCALL	_Usart_Transmit
    037B8 C004      RJMP	0x37BD
(0068) 	while(*str!=0)	Usart_Transmit(*str++);
    037B9 01F5      MOVW	R30,R10
    037BA 9101      LD	R16,Z+
    037BB 015F      MOVW	R10,R30
    037BC DFB3      RCALL	_Usart_Transmit
    037BD 01F5      MOVW	R30,R10
    037BE 8020      LD	R2,Z
    037BF 2022      TST	R2
    037C0 F7C1      BNE	0x37B9
    037C1 90B9      LD	R11,Y+
    037C2 90A9      LD	R10,Y+
    037C3 9508      RET
_PrintLong:
  i                    --> R20
  da                   --> Y,+0
  data                 --> Y,+9
    037C4 940E 3FCC CALL	push_arg4
    037C6 934A      ST	-Y,R20
    037C7 9728      SBIW	R28,0x8
(0069) 
(0070) } 
(0071)  
(0072) void PrintLong(unsigned long data)
(0073) {
(0074)  
(0075) 	unsigned char da[8];
(0076) 	unsigned char i;
(0077) 	for(i=0;i<8;i++)	da[i]=0;
    037C8 2744      CLR	R20
    037C9 C008      RJMP	0x37D2
    037CA 01CE      MOVW	R24,R28
    037CB 2FE4      MOV	R30,R20
    037CC 27FF      CLR	R31
    037CD 0FE8      ADD	R30,R24
    037CE 1FF9      ADC	R31,R25
    037CF 2422      CLR	R2
    037D0 8220      ST	Z,R2
    037D1 9543      INC	R20
    037D2 3048      CPI	R20,0x8
    037D3 F3B0      BCS	0x37CA
    037D4 C013      RJMP	0x37E8
(0078) 	while(data>=10000000L){ ++da[7];data-=10000000L;}
    037D5 818F      LDD	R24,Y+7
    037D6 5F8F      SUBI	R24,0xFF
    037D7 838F      STD	Y+7,R24
    037D8 E880      LDI	R24,0x80
    037D9 E996      LDI	R25,0x96
    037DA E9A8      LDI	R26,0x98
    037DB E0B0      LDI	R27,0
    037DC 8429      LDD	R2,Y+9
    037DD 843A      LDD	R3,Y+10
    037DE 844B      LDD	R4,Y+11
    037DF 845C      LDD	R5,Y+12
    037E0 1A28      SUB	R2,R24
    037E1 0A39      SBC	R3,R25
    037E2 0A4A      SBC	R4,R26
    037E3 0A5B      SBC	R5,R27
    037E4 8629      STD	Y+9,R2
    037E5 863A      STD	Y+10,R3
    037E6 864B      STD	Y+11,R4
    037E7 865C      STD	Y+12,R5
    037E8 E880      LDI	R24,0x80
    037E9 E996      LDI	R25,0x96
    037EA E9A8      LDI	R26,0x98
    037EB E0B0      LDI	R27,0
    037EC 8429      LDD	R2,Y+9
    037ED 843A      LDD	R3,Y+10
    037EE 844B      LDD	R4,Y+11
    037EF 845C      LDD	R5,Y+12
    037F0 1628      CP	R2,R24
    037F1 0639      CPC	R3,R25
    037F2 064A      CPC	R4,R26
    037F3 065B      CPC	R5,R27
    037F4 F700      BCC	0x37D5
(0079) 	if(da[7])	i=0;
    037F5 802F      LDD	R2,Y+7
    037F6 2022      TST	R2
    037F7 F009      BEQ	0x37F9
    037F8 2744      CLR	R20
(0080) 	if(i==0)	Usart_Transmit('0'+da[7]);
    037F9 2344      TST	R20
    037FA F4B9      BNE	0x3812
    037FB 810F      LDD	R16,Y+7
    037FC 5D00      SUBI	R16,0xD0
    037FD DF72      RCALL	_Usart_Transmit
    037FE C013      RJMP	0x3812
(0081) 	while(data>=1000000L) { ++da[6];data-=1000000L;}
    037FF 818E      LDD	R24,Y+6
    03800 5F8F      SUBI	R24,0xFF
    03801 838E      STD	Y+6,R24
    03802 E480      LDI	R24,0x40
    03803 E492      LDI	R25,0x42
    03804 E0AF      LDI	R26,0xF
    03805 E0B0      LDI	R27,0
    03806 8429      LDD	R2,Y+9
    03807 843A      LDD	R3,Y+10
    03808 844B      LDD	R4,Y+11
    03809 845C      LDD	R5,Y+12
    0380A 1A28      SUB	R2,R24
    0380B 0A39      SBC	R3,R25
    0380C 0A4A      SBC	R4,R26
    0380D 0A5B      SBC	R5,R27
    0380E 8629      STD	Y+9,R2
    0380F 863A      STD	Y+10,R3
    03810 864B      STD	Y+11,R4
    03811 865C      STD	Y+12,R5
    03812 E480      LDI	R24,0x40
    03813 E492      LDI	R25,0x42
    03814 E0AF      LDI	R26,0xF
    03815 E0B0      LDI	R27,0
    03816 8429      LDD	R2,Y+9
    03817 843A      LDD	R3,Y+10
    03818 844B      LDD	R4,Y+11
    03819 845C      LDD	R5,Y+12
    0381A 1628      CP	R2,R24
    0381B 0639      CPC	R3,R25
    0381C 064A      CPC	R4,R26
    0381D 065B      CPC	R5,R27
    0381E F700      BCC	0x37FF
(0082) 	if(da[6])	i=0;
    0381F 802E      LDD	R2,Y+6
    03820 2022      TST	R2
    03821 F009      BEQ	0x3823
    03822 2744      CLR	R20
(0083) 	if(i==0)	Usart_Transmit('0'+da[6]);
    03823 2344      TST	R20
    03824 F4B9      BNE	0x383C
    03825 810E      LDD	R16,Y+6
    03826 5D00      SUBI	R16,0xD0
    03827 DF48      RCALL	_Usart_Transmit
    03828 C013      RJMP	0x383C
(0084) 	while(data>=100000L)  { ++da[5];data-=100000L;}
    03829 818D      LDD	R24,Y+5
    0382A 5F8F      SUBI	R24,0xFF
    0382B 838D      STD	Y+5,R24
    0382C EA80      LDI	R24,0xA0
    0382D E896      LDI	R25,0x86
    0382E E0A1      LDI	R26,1
    0382F E0B0      LDI	R27,0
    03830 8429      LDD	R2,Y+9
    03831 843A      LDD	R3,Y+10
    03832 844B      LDD	R4,Y+11
    03833 845C      LDD	R5,Y+12
    03834 1A28      SUB	R2,R24
    03835 0A39      SBC	R3,R25
    03836 0A4A      SBC	R4,R26
    03837 0A5B      SBC	R5,R27
    03838 8629      STD	Y+9,R2
    03839 863A      STD	Y+10,R3
    0383A 864B      STD	Y+11,R4
    0383B 865C      STD	Y+12,R5
    0383C EA80      LDI	R24,0xA0
    0383D E896      LDI	R25,0x86
    0383E E0A1      LDI	R26,1
    0383F E0B0      LDI	R27,0
    03840 8429      LDD	R2,Y+9
    03841 843A      LDD	R3,Y+10
    03842 844B      LDD	R4,Y+11
    03843 845C      LDD	R5,Y+12
    03844 1628      CP	R2,R24
    03845 0639      CPC	R3,R25
    03846 064A      CPC	R4,R26
    03847 065B      CPC	R5,R27
    03848 F700      BCC	0x3829
(0085) 	if(da[5])	i=0;
    03849 802D      LDD	R2,Y+5
    0384A 2022      TST	R2
    0384B F009      BEQ	0x384D
    0384C 2744      CLR	R20
(0086) 	if(i==0)	Usart_Transmit('0'+da[5]);
    0384D 2344      TST	R20
    0384E F4B9      BNE	0x3866
    0384F 810D      LDD	R16,Y+5
    03850 5D00      SUBI	R16,0xD0
    03851 DF1E      RCALL	_Usart_Transmit
    03852 C013      RJMP	0x3866
(0087) 	while(data>=10000L)   { ++da[4];data-=10000L;}
    03853 818C      LDD	R24,Y+4
    03854 5F8F      SUBI	R24,0xFF
    03855 838C      STD	Y+4,R24
    03856 E180      LDI	R24,0x10
    03857 E297      LDI	R25,0x27
    03858 E0A0      LDI	R26,0
    03859 E0B0      LDI	R27,0
    0385A 8429      LDD	R2,Y+9
    0385B 843A      LDD	R3,Y+10
    0385C 844B      LDD	R4,Y+11
    0385D 845C      LDD	R5,Y+12
    0385E 1A28      SUB	R2,R24
    0385F 0A39      SBC	R3,R25
    03860 0A4A      SBC	R4,R26
    03861 0A5B      SBC	R5,R27
    03862 8629      STD	Y+9,R2
    03863 863A      STD	Y+10,R3
    03864 864B      STD	Y+11,R4
    03865 865C      STD	Y+12,R5
    03866 E180      LDI	R24,0x10
    03867 E297      LDI	R25,0x27
    03868 E0A0      LDI	R26,0
    03869 E0B0      LDI	R27,0
    0386A 8429      LDD	R2,Y+9
    0386B 843A      LDD	R3,Y+10
    0386C 844B      LDD	R4,Y+11
    0386D 845C      LDD	R5,Y+12
    0386E 1628      CP	R2,R24
    0386F 0639      CPC	R3,R25
    03870 064A      CPC	R4,R26
    03871 065B      CPC	R5,R27
    03872 F700      BCC	0x3853
(0088) 	if(da[4])	i=0;
    03873 802C      LDD	R2,Y+4
    03874 2022      TST	R2
    03875 F009      BEQ	0x3877
    03876 2744      CLR	R20
(0089) 	if(i==0)	Usart_Transmit('0'+da[4]);
    03877 2344      TST	R20
    03878 F4B9      BNE	0x3890
    03879 810C      LDD	R16,Y+4
    0387A 5D00      SUBI	R16,0xD0
    0387B DEF4      RCALL	_Usart_Transmit
    0387C C013      RJMP	0x3890
(0090) 	while(data>=1000L)    { ++da[3];data-=1000L;}
    0387D 818B      LDD	R24,Y+3
    0387E 5F8F      SUBI	R24,0xFF
    0387F 838B      STD	Y+3,R24
    03880 EE88      LDI	R24,0xE8
    03881 E093      LDI	R25,3
    03882 E0A0      LDI	R26,0
    03883 E0B0      LDI	R27,0
    03884 8429      LDD	R2,Y+9
    03885 843A      LDD	R3,Y+10
    03886 844B      LDD	R4,Y+11
    03887 845C      LDD	R5,Y+12
    03888 1A28      SUB	R2,R24
    03889 0A39      SBC	R3,R25
    0388A 0A4A      SBC	R4,R26
    0388B 0A5B      SBC	R5,R27
    0388C 8629      STD	Y+9,R2
    0388D 863A      STD	Y+10,R3
    0388E 864B      STD	Y+11,R4
    0388F 865C      STD	Y+12,R5
    03890 EE88      LDI	R24,0xE8
    03891 E093      LDI	R25,3
    03892 E0A0      LDI	R26,0
    03893 E0B0      LDI	R27,0
    03894 8429      LDD	R2,Y+9
    03895 843A      LDD	R3,Y+10
    03896 844B      LDD	R4,Y+11
    03897 845C      LDD	R5,Y+12
    03898 1628      CP	R2,R24
    03899 0639      CPC	R3,R25
    0389A 064A      CPC	R4,R26
    0389B 065B      CPC	R5,R27
    0389C F700      BCC	0x387D
(0091) 	if(da[3])	i=0;
    0389D 802B      LDD	R2,Y+3
    0389E 2022      TST	R2
    0389F F009      BEQ	0x38A1
    038A0 2744      CLR	R20
(0092) 	if(i==0)	Usart_Transmit('0'+da[3]);
    038A1 2344      TST	R20
    038A2 F4B9      BNE	0x38BA
    038A3 810B      LDD	R16,Y+3
    038A4 5D00      SUBI	R16,0xD0
    038A5 DECA      RCALL	_Usart_Transmit
    038A6 C013      RJMP	0x38BA
(0093) 	while(data>=100L)     { ++da[2];data-=100L;}
    038A7 818A      LDD	R24,Y+2
    038A8 5F8F      SUBI	R24,0xFF
    038A9 838A      STD	Y+2,R24
    038AA E684      LDI	R24,0x64
    038AB E090      LDI	R25,0
    038AC E0A0      LDI	R26,0
    038AD E0B0      LDI	R27,0
    038AE 8429      LDD	R2,Y+9
    038AF 843A      LDD	R3,Y+10
    038B0 844B      LDD	R4,Y+11
    038B1 845C      LDD	R5,Y+12
    038B2 1A28      SUB	R2,R24
    038B3 0A39      SBC	R3,R25
    038B4 0A4A      SBC	R4,R26
    038B5 0A5B      SBC	R5,R27
    038B6 8629      STD	Y+9,R2
    038B7 863A      STD	Y+10,R3
    038B8 864B      STD	Y+11,R4
    038B9 865C      STD	Y+12,R5
    038BA E684      LDI	R24,0x64
    038BB E090      LDI	R25,0
    038BC E0A0      LDI	R26,0
    038BD E0B0      LDI	R27,0
    038BE 8429      LDD	R2,Y+9
    038BF 843A      LDD	R3,Y+10
    038C0 844B      LDD	R4,Y+11
    038C1 845C      LDD	R5,Y+12
    038C2 1628      CP	R2,R24
    038C3 0639      CPC	R3,R25
    038C4 064A      CPC	R4,R26
    038C5 065B      CPC	R5,R27
    038C6 F700      BCC	0x38A7
(0094) 	if(da[2])	i=0;
    038C7 802A      LDD	R2,Y+2
    038C8 2022      TST	R2
    038C9 F009      BEQ	0x38CB
    038CA 2744      CLR	R20
(0095) 	if(i==0)	Usart_Transmit('0'+da[2]);
    038CB 2344      TST	R20
    038CC F4B9      BNE	0x38E4
    038CD 810A      LDD	R16,Y+2
    038CE 5D00      SUBI	R16,0xD0
    038CF DEA0      RCALL	_Usart_Transmit
    038D0 C013      RJMP	0x38E4
(0096) 	while(data>=10L)      { ++da[1];data-=10L;}
    038D1 8189      LDD	R24,Y+1
    038D2 5F8F      SUBI	R24,0xFF
    038D3 8389      STD	Y+1,R24
    038D4 E08A      LDI	R24,0xA
    038D5 E090      LDI	R25,0
    038D6 E0A0      LDI	R26,0
    038D7 E0B0      LDI	R27,0
    038D8 8429      LDD	R2,Y+9
    038D9 843A      LDD	R3,Y+10
    038DA 844B      LDD	R4,Y+11
    038DB 845C      LDD	R5,Y+12
    038DC 1A28      SUB	R2,R24
    038DD 0A39      SBC	R3,R25
    038DE 0A4A      SBC	R4,R26
    038DF 0A5B      SBC	R5,R27
    038E0 8629      STD	Y+9,R2
    038E1 863A      STD	Y+10,R3
    038E2 864B      STD	Y+11,R4
    038E3 865C      STD	Y+12,R5
    038E4 E08A      LDI	R24,0xA
    038E5 E090      LDI	R25,0
    038E6 E0A0      LDI	R26,0
    038E7 E0B0      LDI	R27,0
    038E8 8429      LDD	R2,Y+9
    038E9 843A      LDD	R3,Y+10
    038EA 844B      LDD	R4,Y+11
    038EB 845C      LDD	R5,Y+12
    038EC 1628      CP	R2,R24
    038ED 0639      CPC	R3,R25
    038EE 064A      CPC	R4,R26
    038EF 065B      CPC	R5,R27
    038F0 F700      BCC	0x38D1
(0097) 	if(da[1])	i=0;
    038F1 8029      LDD	R2,Y+1
    038F2 2022      TST	R2
    038F3 F009      BEQ	0x38F5
    038F4 2744      CLR	R20
(0098) 	if(i==0)	Usart_Transmit('0'+da[1]);
    038F5 2344      TST	R20
    038F6 F419      BNE	0x38FA
    038F7 8109      LDD	R16,Y+1
    038F8 5D00      SUBI	R16,0xD0
    038F9 DE76      RCALL	_Usart_Transmit
(0099) 	Usart_Transmit('0'+data);
    038FA E380      LDI	R24,0x30
    038FB E090      LDI	R25,0
    038FC E0A0      LDI	R26,0
    038FD E0B0      LDI	R27,0
    038FE 8429      LDD	R2,Y+9
    038FF 843A      LDD	R3,Y+10
    03900 844B      LDD	R4,Y+11
    03901 845C      LDD	R5,Y+12
    03902 0E28      ADD	R2,R24
    03903 1E39      ADC	R3,R25
    03904 1E4A      ADC	R4,R26
    03905 1E5B      ADC	R5,R27
    03906 2D02      MOV	R16,R2
    03907 DE68      RCALL	_Usart_Transmit
    03908 9628      ADIW	R28,0x8
    03909 9149      LD	R20,Y+
    0390A 9624      ADIW	R28,4
    0390B 9508      RET
_PrintChar:
  h                    --> R20
  d                    --> R22
    0390C 934A      ST	-Y,R20
    0390D 936A      ST	-Y,R22
    0390E 2F60      MOV	R22,R16
(0100)  
(0101) }
(0102)  
(0103) void PrintChar(unsigned char d)
(0104) {
(0105) 	unsigned char h=(d&0xF0)>>4;
    0390F 2F46      MOV	R20,R22
    03910 7F40      ANDI	R20,0xF0
    03911 9542      SWAP	R20
    03912 704F      ANDI	R20,0xF
(0106) 	if(h<10)	Usart_Transmit('0'+h);
    03913 304A      CPI	R20,0xA
    03914 F420      BCC	0x3919
    03915 2F04      MOV	R16,R20
    03916 5D00      SUBI	R16,0xD0
    03917 DE58      RCALL	_Usart_Transmit
    03918 C003      RJMP	0x391C
(0107) 	else		Usart_Transmit('A'-10+h);
    03919 2F04      MOV	R16,R20
    0391A 5C09      SUBI	R16,0xC9
    0391B DE54      RCALL	_Usart_Transmit
(0108) 	h=d&0x0f;
    0391C 2F46      MOV	R20,R22
    0391D 704F      ANDI	R20,0xF
(0109) 	if(h<10)	Usart_Transmit('0'+h);
    0391E 304A      CPI	R20,0xA
    0391F F420      BCC	0x3924
    03920 2F04      MOV	R16,R20
    03921 5D00      SUBI	R16,0xD0
    03922 DE4D      RCALL	_Usart_Transmit
    03923 C003      RJMP	0x3927
(0110) 	else		Usart_Transmit('A'-10+h);
    03924 2F04      MOV	R16,R20
    03925 5C09      SUBI	R16,0xC9
    03926 DE49      RCALL	_Usart_Transmit
(0111) 	Usart_Transmit(' ');
    03927 E200      LDI	R16,0x20
    03928 DE47      RCALL	_Usart_Transmit
    03929 9169      LD	R22,Y+
    0392A 9149      LD	R20,Y+
    0392B 9508      RET
FILE: D:\LQD\software\master\software_src\SPI.c
(0001) //*****************************************************************************//
(0002) //*								 
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SPI接口控制
(0006) //*****************************************************************************//
(0007) #include "SPI.h"
(0008) 
(0009) /******************************************************************
(0010) SPI接口函数初始化
(0011) ******************************************************************/
(0012) void SPI_IO_Init(void)
(0013) {
(0014) 	SPI_PORT |= (1<<SS);////拉高CS
_SPI_IO_Init:
    0392C 9AC0      SBI	0x18,0
(0015) 	SPI_DDR |= (1<<SCLK)|(1<<MOSI)|(1<<SS);////CS,CLK,MOSI设为输出
    0392D B387      IN	R24,0x17
    0392E 6087      ORI	R24,7
    0392F BB87      OUT	0x17,R24
(0016) 	SPI_DDR &=~(1<<MISO);//MISO设为输入
    03930 98BB      CBI	0x17,3
(0017) 	SPI_PORT |= (1<<SCLK);//拉高CLK
    03931 9AC1      SBI	0x18,1
(0018) 	SPI_High();//SPI高通
    03932 E580      LDI	R24,0x50
    03933 B98D      OUT	0x0D,R24
    03934 9A70      SBI	0x0E,0
    03935 9508      RET
(0019) }
(0020) /******************************************************************
(0021) SPI写一个字节
(0022) ******************************************************************/
(0023) void SPI_Write(UINT8 data)
(0024) {
(0025) 	SPDR = data;
_SPI_Write:
  data                 --> R16
    03936 B90F      OUT	0x0F,R16
(0026) 	while ((SPSR&(1<<SPIF))==0);
    03937 9B77      SBIS	0x0E,7
    03938 CFFE      RJMP	0x3937
    03939 9508      RET
(0027) 	//loop_until_bit_is_set(SPSR,SPIF);
(0028) }
(0029) /******************************************************************
(0030) SPI读一个字节
(0031) ******************************************************************/
(0032) unsigned char SPI_Read(void)
(0033) {
(0034) 	SPDR = 0xFF;//写0xFF启动SPI
_SPI_Read:
    0393A EF8F      LDI	R24,0xFF
    0393B B98F      OUT	0x0F,R24
(0035) 	while ((SPSR&(1<<SPIF))==0);
    0393C 9B77      SBIS	0x0E,7
    0393D CFFE      RJMP	0x393C
(0036) 	//loop_until_bit_is_set(SPSR,SPIF);//等待SPIF为高电平
(0037) 	return  SPDR;//返回读取值
    0393E B10F      IN	R16,0x0F
    0393F 9508      RET
FILE: D:\LQD\software\master\software_src\lcd.c
(0001) #include "config.h"
(0002) 
(0003) //此硬件引脚适合冷强度检测仪第2版电路  mega128
(0004) #define LCD_PIN_CS   4
(0005) #define LCD_PIN_SID  3
(0006) #define LCD_PIN_SCLK 2
(0007) #define LCD_PIN_RST  1
(0008) #define LCD_BACKLIGHT_SW		0
(0009) #define LCD_PORT PORTC
(0010) #define LCD_PIN_DDR DDRC
(0011) #define Set_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT |= (1<<LCD_PIN_CS) 
(0012) #define Set_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT |= (1<<LCD_PIN_SID) 
(0013) #define Set_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT |= (1<<LCD_PIN_SCLK) 
(0014) #define LCD_LIGHT_ON()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT |= (1<<LCD_BACKLIGHT_SW) 
(0015) #define Set_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT |= (1<<LCD_PIN_RST) 
(0016) 
(0017) #define Clr_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT &=~(1<<LCD_PIN_CS) 
(0018) #define Clr_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT &=~(1<<LCD_PIN_SID) 
(0019) #define Clr_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT &=~(1<<LCD_PIN_SCLK) 
(0020) #define LCD_LIGHT_OFF()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT &=~(1<<LCD_BACKLIGHT_SW) 
(0021) #define Clr_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT &=~(1<<LCD_PIN_RST) 
(0022)  
(0023) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data); 
(0024) void Write_8bits(unsigned int W_bits); 
(0025) void LCD_Init(void); 
(0026) unsigned char LCD_INT(void); 
(0027) 
(0028) unsigned char LCD_SW(unsigned char i)
(0029) {
(0030)  if(i==0){
_LCD_SW:
  i                    --> R16
    03940 2300      TST	R16
    03941 F421      BNE	0x3946
(0031)  LCD_LIGHT_OFF();
    03942 9AA0      SBI	0x14,0
    03943 98A8      CBI	0x15,0
(0032)  return 0;
    03944 2700      CLR	R16
    03945 C003      RJMP	0x3949
(0033)  }
(0034)  else{
(0035)  LCD_LIGHT_ON();
    03946 9AA0      SBI	0x14,0
    03947 9AA8      SBI	0x15,0
(0036)  return 1;
    03948 E001      LDI	R16,1
    03949 9508      RET
(0037)  }
(0038)  
(0039) }
(0040)  
(0041) unsigned char LCD_INT(void) 
(0042) { 
(0043)   Clr_CS(); 
_LCD_INT:
    0394A 9AA4      SBI	0x14,4
    0394B 98AC      CBI	0x15,4
(0044)   Clr_SID(); 
    0394C 9AA3      SBI	0x14,3
    0394D 98AB      CBI	0x15,3
(0045)   Clr_SCLK(); 
    0394E 9AA2      SBI	0x14,2
    0394F 98AA      CBI	0x15,2
(0046)   LCD_Init(); 
    03950 D097      RCALL	_LCD_Init
(0047)   return (0);
    03951 2700      CLR	R16
    03952 9508      RET
_address:
  a                    --> R20
  y                    --> R18
  x                    --> R16
    03953 940E 4126 CALL	push_xgsetF000
(0048) } 
(0049)   
(0050) /******************************************************************** 
(0051) 函数 名：address
(0052) 入口参数：地址转换
(0053) 出口参数：无 
(0054) 函数作用： 
(0055) 说        明： 
(0056) ********************************************************************/ 
(0057) unsigned char address(unsigned char x,unsigned char y)
(0058) {  
(0059)  unsigned char a;
(0060) 
(0061) switch(x) 
    03955 2F60      MOV	R22,R16
    03956 2777      CLR	R23
    03957 3061      CPI	R22,1
    03958 E0E0      LDI	R30,0
    03959 077E      CPC	R23,R30
    0395A F069      BEQ	0x3968
    0395B 3062      CPI	R22,2
    0395C E0E0      LDI	R30,0
    0395D 077E      CPC	R23,R30
    0395E F059      BEQ	0x396A
    0395F 3063      CPI	R22,3
    03960 E0E0      LDI	R30,0
    03961 077E      CPC	R23,R30
    03962 F049      BEQ	0x396C
    03963 3064      CPI	R22,4
    03964 E0E0      LDI	R30,0
    03965 077E      CPC	R23,R30
    03966 F039      BEQ	0x396E
    03967 C007      RJMP	0x396F
(0062) { 
(0063) case 1: 
(0064) {a=0x80;break;} 
    03968 E840      LDI	R20,0x80
    03969 C005      RJMP	0x396F
(0065) case 2: 
(0066) {a=0x90;break;} 
    0396A E940      LDI	R20,0x90
    0396B C003      RJMP	0x396F
(0067)   case 3: 
(0068) {a=0x88;break;} 
    0396C E848      LDI	R20,0x88
    0396D C001      RJMP	0x396F
(0069)   case 4: 
(0070) {a=0x98;break;} 
    0396E E948      LDI	R20,0x98
(0071) } 
(0072) a=a+y-1;
    0396F 0F42      ADD	R20,R18
    03970 5041      SUBI	R20,1
(0073) 
(0074) return a;
    03971 2F04      MOV	R16,R20
    03972 940C 412B JMP	pop_xgsetF000
_LCD_const_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    03974 940E 4113 CALL	push_xgset30FC
    03976 2EE2      MOV	R14,R18
    03977 2EC0      MOV	R12,R16
    03978 9721      SBIW	R28,1
    03979 84A9      LDD	R10,Y+9
    0397A 84BA      LDD	R11,Y+10
(0075) }
(0076)  
(0077) //////////////////////////////////////////////////////////////
(0078) 
(0079) /******************************************************************** 
(0080) 函数 名：LCD_const_disp
(0081) 入口参数：x y  *single_data
(0082) 出口参数：无 
(0083) 函数作用：负责 显示一串常量
(0084) 说        明： 
(0085) ********************************************************************/ 
(0086) void LCD_const_disp(unsigned char x, unsigned char y, const unsigned char *single_data) 
(0087) { 
(0088) unsigned char  a,i; 
(0089) a=address(x,y);
    0397B 2D2E      MOV	R18,R14
    0397C 2D0C      MOV	R16,R12
    0397D DFD5      RCALL	_address
    0397E 2EC0      MOV	R12,R16
(0090) W_1byte(0,0,a);     //显示的地址 
    0397F 82C8      ST	Y,R12
    03980 2722      CLR	R18
    03981 2700      CLR	R16
    03982 D0B7      RCALL	_W_1byte
(0091)    for(i=0; single_data[i]!='\0';i++) 
    03983 2744      CLR	R20
    03984 C00D      RJMP	0x3992
(0092)    {
(0093)     if(i>=16) break; 
    03985 3140      CPI	R20,0x10
    03986 F008      BCS	0x3988
    03987 C011      RJMP	0x3999
(0094)     W_1byte(0,1,single_data[i]); 
    03988 2FE4      MOV	R30,R20
    03989 27FF      CLR	R31
    0398A 0DEA      ADD	R30,R10
    0398B 1DFB      ADC	R31,R11
    0398C 8020      LD	R2,Z
    0398D 8228      ST	Y,R2
    0398E E021      LDI	R18,1
    0398F 2700      CLR	R16
    03990 D0A9      RCALL	_W_1byte
    03991 9543      INC	R20
    03992 2FE4      MOV	R30,R20
    03993 27FF      CLR	R31
    03994 0DEA      ADD	R30,R10
    03995 1DFB      ADC	R31,R11
    03996 8020      LD	R2,Z
    03997 2022      TST	R2
    03998 F761      BNE	0x3985
(0095)     
(0096)    } 
(0097)    W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03999 EF8F      LDI	R24,0xFF
    0399A 8388      ST	Y,R24
    0399B 2722      CLR	R18
    0399C 2700      CLR	R16
    0399D D09C      RCALL	_W_1byte
    0399E 9621      ADIW	R28,1
    0399F 940C 40FD JMP	pop_xgset30FC
_LCD_var_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    039A1 940E 4113 CALL	push_xgset30FC
    039A3 2EE2      MOV	R14,R18
    039A4 2EC0      MOV	R12,R16
    039A5 9721      SBIW	R28,1
    039A6 84A9      LDD	R10,Y+9
    039A7 84BA      LDD	R11,Y+10
(0098)  
(0099) } 
(0100) 
(0101) /******************************************************************** 
(0102) 函数 名：LCD_var_disp
(0103) 入口参数：single_row single_line  *single_data
(0104) 出口参数：无 
(0105) 函数作用：负责 显示一串变量
(0106) 说        明： 
(0107) ********************************************************************/ 
(0108) 
(0109) void LCD_var_disp(unsigned char x, unsigned char y, unsigned char *single_data) 
(0110) { 
(0111) unsigned char  a,i; 
(0112) 
(0113) #if _debug == 1 
(0114) 	PrintString_n(single_data);
(0115) #endif 
(0116) 
(0117) a=address( x,y);
    039A8 2D2E      MOV	R18,R14
    039A9 2D0C      MOV	R16,R12
    039AA DFA8      RCALL	_address
    039AB 2EC0      MOV	R12,R16
(0118) W_1byte(0,0,a);     //显示的地址0x88 
    039AC 82C8      ST	Y,R12
    039AD 2722      CLR	R18
    039AE 2700      CLR	R16
    039AF D08A      RCALL	_W_1byte
(0119) 
(0120) for(i=0; single_data[i]!='\0';i++) 
    039B0 2744      CLR	R20
    039B1 C00D      RJMP	0x39BF
(0121)    { 
(0122)     if(i>=16) break;
    039B2 3140      CPI	R20,0x10
    039B3 F008      BCS	0x39B5
    039B4 C011      RJMP	0x39C6
(0123)     W_1byte(0,1,single_data[i]); 
    039B5 2FE4      MOV	R30,R20
    039B6 27FF      CLR	R31
    039B7 0DEA      ADD	R30,R10
    039B8 1DFB      ADC	R31,R11
    039B9 8020      LD	R2,Z
    039BA 8228      ST	Y,R2
    039BB E021      LDI	R18,1
    039BC 2700      CLR	R16
    039BD D07C      RCALL	_W_1byte
    039BE 9543      INC	R20
    039BF 2FE4      MOV	R30,R20
    039C0 27FF      CLR	R31
    039C1 0DEA      ADD	R30,R10
    039C2 1DFB      ADC	R31,R11
    039C3 8020      LD	R2,Z
    039C4 2022      TST	R2
    039C5 F761      BNE	0x39B2
(0124) 	} 
(0125)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    039C6 EF8F      LDI	R24,0xFF
    039C7 8388      ST	Y,R24
    039C8 2722      CLR	R18
    039C9 2700      CLR	R16
    039CA D06F      RCALL	_W_1byte
    039CB 9621      ADIW	R28,1
    039CC 940C 40FD JMP	pop_xgset30FC
_LCD_char_disp:
  a                    --> R12
  data                 --> R10
  y                    --> R14
  x                    --> R12
    039CE 940E 4115 CALL	push_xgset00FC
    039D0 2EE2      MOV	R14,R18
    039D1 2EC0      MOV	R12,R16
    039D2 9721      SBIW	R28,1
    039D3 80AF      LDD	R10,Y+7
(0126) } 
(0127) /******************************************************************** 
(0128) 函数 名：LCD_char_disp
(0129) 入口参数：single_row single_line  data
(0130) 出口参数：无 
(0131) 函数作用：负责 显示一个 变量
(0132) 说        明： 
(0133) ********************************************************************/ 
(0134) 
(0135) void LCD_char_disp(unsigned char x, unsigned char y, unsigned char data) 
(0136) { 
(0137) unsigned char a; 
(0138) a=address(x,y);
    039D4 2D2E      MOV	R18,R14
    039D5 2D0C      MOV	R16,R12
    039D6 DF7C      RCALL	_address
    039D7 2EC0      MOV	R12,R16
(0139) W_1byte(0,0,a);     //显示的地址 
    039D8 82C8      ST	Y,R12
    039D9 2722      CLR	R18
    039DA 2700      CLR	R16
    039DB D05E      RCALL	_W_1byte
(0140) W_1byte(0,1,data);  //显示内容
    039DC 82A8      ST	Y,R10
    039DD E021      LDI	R18,1
    039DE 2700      CLR	R16
    039DF D05A      RCALL	_W_1byte
(0141)  
(0142)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    039E0 EF8F      LDI	R24,0xFF
    039E1 8388      ST	Y,R24
    039E2 2722      CLR	R18
    039E3 2700      CLR	R16
    039E4 D055      RCALL	_W_1byte
    039E5 9621      ADIW	R28,1
    039E6 940C 40F6 JMP	pop_xgset00FC
_LCD_Init:
  cmd                  --> R20
    039E8 934A      ST	-Y,R20
    039E9 9721      SBIW	R28,1
(0143) } 
(0144) 
(0145) /******************************************************************** 
(0146) 函数 名：LCD_Init
(0147) 入口参数：无
(0148) 出口参数：unsigned char  0/1
(0149) 函数作用：负责 清空液晶显示
(0150) 说        明： 
(0151) ********************************************************************/ 
(0152) void LCD_Init(void) 
(0153) { 
(0154)    unsigned char cmd; 
(0155)    cmd=0x30;      //功能设置 8 位数据，基本指令 
    039EA E340      LDI	R20,0x30
(0156)   W_1byte(0,0,cmd); 
    039EB 8348      ST	Y,R20
    039EC 2722      CLR	R18
    039ED 2700      CLR	R16
    039EE D04B      RCALL	_W_1byte
(0157)   delayms(2); 
    039EF E002      LDI	R16,2
    039F0 E010      LDI	R17,0
    039F1 940E 240B CALL	_delayms
(0158)   cmd=0x0C;      //显示状态 ON，游标OFF，反白OFF 
    039F3 E04C      LDI	R20,0xC
(0159)   W_1byte(0,0,cmd); //写指令 
    039F4 8348      ST	Y,R20
    039F5 2722      CLR	R18
    039F6 2700      CLR	R16
    039F7 D042      RCALL	_W_1byte
(0160)   delayms(2); 
    039F8 E002      LDI	R16,2
    039F9 E010      LDI	R17,0
    039FA 940E 240B CALL	_delayms
(0161)   cmd=0x01;      //清除显示 
    039FC E041      LDI	R20,1
(0162)   W_1byte(0,0,cmd); //写指令 
    039FD 8348      ST	Y,R20
    039FE 2722      CLR	R18
    039FF 2700      CLR	R16
    03A00 D039      RCALL	_W_1byte
(0163)   delayms(2); 
    03A01 E002      LDI	R16,2
    03A02 E010      LDI	R17,0
    03A03 940E 240B CALL	_delayms
(0164)   cmd=0x02;      //地址归位 
    03A05 E042      LDI	R20,2
(0165)   W_1byte(0,0,cmd); //写指令 
    03A06 8348      ST	Y,R20
    03A07 2722      CLR	R18
    03A08 2700      CLR	R16
    03A09 D030      RCALL	_W_1byte
(0166)   delayms(2); 
    03A0A E002      LDI	R16,2
    03A0B E010      LDI	R17,0
    03A0C 940E 240B CALL	_delayms
(0167)   cmd=0x80;      //设置DDRAM 地址 
    03A0E E840      LDI	R20,0x80
(0168)   W_1byte(0,0,cmd); //写指令 
    03A0F 8348      ST	Y,R20
    03A10 2722      CLR	R18
    03A11 2700      CLR	R16
    03A12 D027      RCALL	_W_1byte
(0169)   delayms(2);     //延时 
    03A13 E002      LDI	R16,2
    03A14 E010      LDI	R17,0
    03A15 940E 240B CALL	_delayms
    03A17 9621      ADIW	R28,1
    03A18 9149      LD	R20,Y+
    03A19 9508      RET
_LCD_CLR:
  cmd                  --> R20
    03A1A 934A      ST	-Y,R20
    03A1B 9721      SBIW	R28,1
(0170) } 
(0171) 
(0172) void LCD_CLR(void)
(0173) {
(0174) unsigned char cmd;
(0175)   cmd=0x01;      //清除显示 
    03A1C E041      LDI	R20,1
(0176)   W_1byte(0,0,cmd); //写指令 
    03A1D 8348      ST	Y,R20
    03A1E 2722      CLR	R18
    03A1F 2700      CLR	R16
    03A20 D019      RCALL	_W_1byte
(0177)   delayms(1); 
    03A21 E001      LDI	R16,1
    03A22 E010      LDI	R17,0
    03A23 940E 240B CALL	_delayms
(0178)   cmd=0x02;      //地址归位 
    03A25 E042      LDI	R20,2
(0179)   W_1byte(0,0,cmd); //写指令 
    03A26 8348      ST	Y,R20
    03A27 2722      CLR	R18
    03A28 2700      CLR	R16
    03A29 D010      RCALL	_W_1byte
(0180)   delayms(1); 
    03A2A E001      LDI	R16,1
    03A2B E010      LDI	R17,0
    03A2C 940E 240B CALL	_delayms
(0181)   cmd=0x80;      //设置DDRAM 地址 
    03A2E E840      LDI	R20,0x80
(0182)   W_1byte(0,0,cmd); //写指令 
    03A2F 8348      ST	Y,R20
    03A30 2722      CLR	R18
    03A31 2700      CLR	R16
    03A32 D007      RCALL	_W_1byte
(0183)   delayms(1);     //延时
    03A33 E001      LDI	R16,1
    03A34 E010      LDI	R17,0
    03A35 940E 240B CALL	_delayms
    03A37 9621      ADIW	R28,1
    03A38 9149      LD	R20,Y+
    03A39 9508      RET
_W_1byte:
  H_data               --> R22
  S_ID                 --> R10
  L_data               --> R20
  W_data               --> R12
  RS                   --> R14
  RW                   --> R20
    03A3A 940E 4111 CALL	push_xgsetF0FC
    03A3C 2EE2      MOV	R14,R18
    03A3D 2F40      MOV	R20,R16
    03A3E 84CA      LDD	R12,Y+10
(0184) 
(0185) }
(0186)  
(0187) /*******************************************************************
(0188) 函 数 名：W_1byte
(0189) 入口参数：RW、RS、W_data
(0190) 出口参数：无
(0191) 建立日期：2007年3月3日
(0192) 修改日期：
(0193) 函数作用：写一个字节的数据到12864液晶，包括指令和数据
(0194) 说    明：RW=1，从液晶读数据到MCU；RW=0，写一个数据到液晶；
(0195) 		 （一般RW都设为0，即只向液晶写数据，不读数据）
(0196)           RS=1，写入的是数据；RS=0，写入的是指令；
(0197) 		  一般模式：RW=0，RS=1;写数据
(0198) 		  			RW=0，RS=0;写指令
(0199) ********************************************************************/
(0200) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data)
(0201) {
(0202) 	unsigned int H_data,L_data,S_ID = 0xf8;	 //11111RWRS0
    03A3F EF88      LDI	R24,0xF8
    03A40 E090      LDI	R25,0
    03A41 015C      MOVW	R10,R24
(0203) 	if(RW == 0)
    03A42 2344      TST	R20
    03A43 F419      BNE	0x3A47
(0204) 	{
(0205) 	 	S_ID &=~ 0x04;
    03A44 7F8B      ANDI	R24,0xFB
    03A45 015C      MOVW	R10,R24
(0206) 	}
    03A46 C003      RJMP	0x3A4A
(0207) 	else					//if(RW==1)
(0208) 	{
(0209) 	 	S_ID |= 0X04;
    03A47 01C5      MOVW	R24,R10
    03A48 6084      ORI	R24,4
    03A49 015C      MOVW	R10,R24
(0210) 	}
(0211) 	if(RS == 0)
    03A4A 20EE      TST	R14
    03A4B F421      BNE	0x3A50
(0212) 	{
(0213) 	 	S_ID &=~ 0x02;
    03A4C 01C5      MOVW	R24,R10
    03A4D 7F8D      ANDI	R24,0xFD
    03A4E 015C      MOVW	R10,R24
(0214) 	}
    03A4F C003      RJMP	0x3A53
(0215) 	else					//if(RS==1)
(0216) 	{
(0217) 	 	S_ID |= 0X02;
    03A50 01C5      MOVW	R24,R10
    03A51 6082      ORI	R24,2
    03A52 015C      MOVW	R10,R24
(0218) 	}
(0219) 	H_data = W_data;
    03A53 2D6C      MOV	R22,R12
    03A54 2777      CLR	R23
(0220) 	H_data &= 0xf0;			//屏蔽低4位的数据
    03A55 7F60      ANDI	R22,0xF0
    03A56 7070      ANDI	R23,0
(0221) 	L_data = W_data;	   	//xxxx0000格式
    03A57 2D4C      MOV	R20,R12
    03A58 2755      CLR	R21
(0222) 	L_data &= 0x0f;			//屏蔽高4位的数据
    03A59 704F      ANDI	R20,0xF
    03A5A 7050      ANDI	R21,0
(0223) 	L_data <<= 4;			//xxxx0000格式
    03A5B 0F44      LSL	R20
    03A5C 1F55      ROL	R21
    03A5D 0F44      LSL	R20
    03A5E 1F55      ROL	R21
    03A5F 0F44      LSL	R20
    03A60 1F55      ROL	R21
    03A61 0F44      LSL	R20
    03A62 1F55      ROL	R21
(0224) 	Set_CS();
    03A63 9AA4      SBI	0x14,4
    03A64 9AAC      SBI	0x15,4
(0225) 	Write_8bits(S_ID); 		//发送S_ID
    03A65 0185      MOVW	R16,R10
    03A66 D00C      RCALL	_Write_8bits
(0226) 	Write_8bits(H_data);	//发送H_data
    03A67 018B      MOVW	R16,R22
    03A68 D00A      RCALL	_Write_8bits
(0227) 	Write_8bits(L_data);	//发送L_data
    03A69 018A      MOVW	R16,R20
    03A6A D008      RCALL	_Write_8bits
(0228) 	Clr_CS();	Clr_CS();	Clr_CS();	
    03A6B 9AA4      SBI	0x14,4
    03A6C 98AC      CBI	0x15,4
    03A6D 9AA4      SBI	0x14,4
    03A6E 98AC      CBI	0x15,4
    03A6F 9AA4      SBI	0x14,4
    03A70 98AC      CBI	0x15,4
    03A71 940C 4106 JMP	pop_xgsetF0FC
_Write_8bits:
  Temp_data            --> R12
  i                    --> R20
  W_bits               --> R10
    03A73 940E 413E CALL	push_xgset303C
    03A75 0158      MOVW	R10,R16
(0229) 	 
(0230) 
(0231) }
(0232) /********************************************************************
(0233) 函 数 名：Write_8bits
(0234) 入口参数：W_bits
(0235) 出口参数：无
(0236) 建立日期：2007年3月3日
(0237) 修改日期：
(0238) 函数作用：负责串行输出8个bit位
(0239) 说    明：
(0240) ********************************************************************/
(0241) void Write_8bits(unsigned int W_bits)
(0242) {
(0243) 	unsigned int i,Temp_data;
(0244) 	for(i=0; i<8; i++)
    03A76 2744      CLR	R20
    03A77 2755      CLR	R21
    03A78 C019      RJMP	0x3A92
(0245) 	{
(0246) 		Temp_data = W_bits;
    03A79 0165      MOVW	R12,R10
(0247) 		Temp_data <<= i;
    03A7A 019A      MOVW	R18,R20
    03A7B 0186      MOVW	R16,R12
    03A7C 940E 418C CALL	lsl16
    03A7E 0168      MOVW	R12,R16
(0248) 		if((Temp_data&0x80)==0) 
    03A7F FD07      SBRC	R16,7
    03A80 C003      RJMP	0x3A84
(0249) 		{
(0250) 		 	Clr_SID();
    03A81 9AA3      SBI	0x14,3
    03A82 98AB      CBI	0x15,3
(0251) 		}
    03A83 C002      RJMP	0x3A86
(0252) 		else
(0253) 		{
(0254) 		 	Set_SID();
    03A84 9AA3      SBI	0x14,3
    03A85 9AAB      SBI	0x15,3
(0255) 		} 
(0256) 		NOP();
    03A86 0000      NOP
(0257) 		Set_SCLK();
    03A87 9AA2      SBI	0x14,2
    03A88 9AAA      SBI	0x15,2
(0258) 		NOP();
    03A89 0000      NOP
(0259) 		NOP();
    03A8A 0000      NOP
(0260) 		Clr_SCLK();
    03A8B 9AA2      SBI	0x14,2
    03A8C 98AA      CBI	0x15,2
(0261) 		NOP();
    03A8D 0000      NOP
(0262) 		Clr_SID();
    03A8E 9AA3      SBI	0x14,3
    03A8F 98AB      CBI	0x15,3
    03A90 5F4F      SUBI	R20,0xFF
    03A91 4F5F      SBCI	R21,0xFF
    03A92 3048      CPI	R20,0x8
    03A93 E0E0      LDI	R30,0
    03A94 075E      CPC	R21,R30
    03A95 F318      BCS	0x3A79
    03A96 940C 4145 JMP	pop_xgset303C
_Set_Draw:
    03A98 9721      SBIW	R28,1
(0263) 	}
(0264) }
(0265)  
(0266) /********************************************************************
(0267) 函 数 名：Set_Draw(
(0268) 入口参数：无
(0269) 出口参数：无
(0270) 函数作用：设置为绘图模式
(0271) 说    明：
(0272) ********************************************************************/
(0273) void Set_Draw(void)
(0274) {  	
(0275) 	//W_1byte(0,0,0x34);			//8BIT控制界面，扩充指令集,，绘图显示OFF
(0276) 	W_1byte(0,0,0x36);
    03A99 E386      LDI	R24,0x36
    03A9A 8388      ST	Y,R24
    03A9B 2722      CLR	R18
    03A9C 2700      CLR	R16
    03A9D DF9C      RCALL	_W_1byte
(0277) 	delayms(1);					//延时
    03A9E E001      LDI	R16,1
    03A9F E010      LDI	R17,0
    03AA0 940E 240B CALL	_delayms
    03AA2 9621      ADIW	R28,1
    03AA3 9508      RET
_Set_White:
  clr_y                --> R10
  clr_x                --> R20
  white_y              --> Y,+2
  white_x              --> Y,+1
  i                    --> R22
  white_end_x          --> R12
  j                    --> R14
  clear                --> Y,+15
  end_x                --> R12
  y                    --> R14
  x                    --> R22
    03AA4 940E 4111 CALL	push_xgsetF0FC
    03AA6 2EE2      MOV	R14,R18
    03AA7 2F60      MOV	R22,R16
    03AA8 9723      SBIW	R28,3
    03AA9 84CD      LDD	R12,Y+13
(0278) } 
(0279)  
(0280) 
(0281) /******************************************************************** 
(0282) 函数 名：Set_White 
(0283) 入口参数：  x,   y,  end_x,  clear
(0284) 出口参数：无 
(0285) 函数作用： 设置反显
(0286) 说        明： 
(0287) ********************************************************************/ 
(0288) void Set_White(unsigned char x,unsigned char y,unsigned char end_x,unsigned char clear)
(0289) {
(0290)  
(0291) 	unsigned char i, j, white_x, white_y,white_end_x,clr_x,clr_y ;		//
(0292)   
(0293) 	W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03AAA E386      LDI	R24,0x36
    03AAB 8388      ST	Y,R24
    03AAC 2722      CLR	R18
    03AAD 2700      CLR	R16
    03AAE DF8B      RCALL	_W_1byte
(0294) 	delayus(20);					//延时
    03AAF E104      LDI	R16,0x14
    03AB0 E010      LDI	R17,0
    03AB1 940E 2403 CALL	_delayus
(0295)  
(0296) 	white_end_x = (end_x-x+1);
    03AB3 2D8C      MOV	R24,R12
    03AB4 1B86      SUB	R24,R22
    03AB5 5F8F      SUBI	R24,0xFF
    03AB6 2EC8      MOV	R12,R24
(0297) 	white_end_x <<= 1;
    03AB7 0CCC      LSL	R12
(0298) 	if(y==1)   //x,1  a=80+x-1                   
    03AB8 2D8E      MOV	R24,R14
    03AB9 3081      CPI	R24,1
    03ABA F449      BNE	0x3AC4
(0299) 	{
(0300) 	 	white_x = (0x80+x-1); 
    03ABB 2F86      MOV	R24,R22
    03ABC 5880      SUBI	R24,0x80
    03ABD 5081      SUBI	R24,1
    03ABE 8389      STD	Y+1,R24
(0301) 		white_y = 0x80;
    03ABF E880      LDI	R24,0x80
    03AC0 838A      STD	Y+2,R24
(0302) 		clr_x = 0x80;
    03AC1 E840      LDI	R20,0x80
(0303) 		clr_y = 0x80;
    03AC2 2EA8      MOV	R10,R24
(0304) 	}
    03AC3 C023      RJMP	0x3AE7
(0305) 	else if(y==2)
    03AC4 2D8E      MOV	R24,R14
    03AC5 3082      CPI	R24,2
    03AC6 F449      BNE	0x3AD0
(0306) 	{
(0307) 	 	white_x = (0x80+x-1);
    03AC7 2F86      MOV	R24,R22
    03AC8 5880      SUBI	R24,0x80
    03AC9 5081      SUBI	R24,1
    03ACA 8389      STD	Y+1,R24
(0308) 		white_y = 0x90;
    03ACB E980      LDI	R24,0x90
    03ACC 838A      STD	Y+2,R24
(0309) 		clr_x = 0x80;
    03ACD E840      LDI	R20,0x80
(0310) 		clr_y = 0x90;
    03ACE 2EA8      MOV	R10,R24
(0311) 	}
    03ACF C017      RJMP	0x3AE7
(0312) 	else if(y==3)
    03AD0 2D8E      MOV	R24,R14
    03AD1 3083      CPI	R24,3
    03AD2 F449      BNE	0x3ADC
(0313) 	{
(0314) 	 	white_x = (0x88+x-1);
    03AD3 2F86      MOV	R24,R22
    03AD4 5788      SUBI	R24,0x78
    03AD5 5081      SUBI	R24,1
    03AD6 8389      STD	Y+1,R24
(0315) 		white_y = 0x80;
    03AD7 E880      LDI	R24,0x80
    03AD8 838A      STD	Y+2,R24
(0316) 		clr_x = 0x88;
    03AD9 E848      LDI	R20,0x88
(0317) 		clr_y = 0x80;
    03ADA 2EA8      MOV	R10,R24
(0318) 	}
    03ADB C00B      RJMP	0x3AE7
(0319) 	else if(y==4)
    03ADC 2D8E      MOV	R24,R14
    03ADD 3084      CPI	R24,4
    03ADE F441      BNE	0x3AE7
(0320) 	{
(0321) 	 	white_x = (0x88+x-1);
    03ADF 2F86      MOV	R24,R22
    03AE0 5788      SUBI	R24,0x78
    03AE1 5081      SUBI	R24,1
    03AE2 8389      STD	Y+1,R24
(0322) 		white_y = 0x90;
    03AE3 E980      LDI	R24,0x90
    03AE4 838A      STD	Y+2,R24
(0323) 		clr_x = 0x88;
    03AE5 E848      LDI	R20,0x88
(0324) 		clr_y = 0x90;
    03AE6 2EA8      MOV	R10,R24
(0325) 	}
(0326)   if(clear==0)//要反白时，先将整行的液晶全部清成不反白（此处行指y）
    03AE7 840F      LDD	R0,Y+15
    03AE8 2000      TST	R0
    03AE9 F4E9      BNE	0x3B07
(0327) 	{
(0328) 	 	for(i=0;i<16;i++ )			//16行
    03AEA 2766      CLR	R22
    03AEB C019      RJMP	0x3B05
(0329) 		{
(0330) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03AEC 2C2A      MOV	R2,R10
    03AED 2D82      MOV	R24,R2
    03AEE 5F8F      SUBI	R24,0xFF
    03AEF 2EA8      MOV	R10,R24
    03AF0 8228      ST	Y,R2
    03AF1 2722      CLR	R18
    03AF2 2700      CLR	R16
    03AF3 DF46      RCALL	_W_1byte
(0331) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03AF4 8348      ST	Y,R20
    03AF5 2722      CLR	R18
    03AF6 2700      CLR	R16
    03AF7 DF42      RCALL	_W_1byte
(0332) 			for(j=0;j<16;j++)		//
    03AF8 24EE      CLR	R14
    03AF9 C007      RJMP	0x3B01
(0333) 			{
(0334) 			 	W_1byte(0,1,0x00);	//清成不反白
    03AFA 2422      CLR	R2
    03AFB 8228      ST	Y,R2
    03AFC E021      LDI	R18,1
    03AFD 2700      CLR	R16
    03AFE DF3B      RCALL	_W_1byte
(0335) 			 	nop();
    03AFF 0000      NOP
    03B00 94E3      INC	R14
    03B01 2D8E      MOV	R24,R14
    03B02 3180      CPI	R24,0x10
    03B03 F3B0      BCS	0x3AFA
    03B04 9563      INC	R22
    03B05 3160      CPI	R22,0x10
    03B06 F328      BCS	0x3AEC
(0336) 			}
(0337) 		}
(0338) 	}
(0339) 	nop();
    03B07 0000      NOP
(0340) //	
(0341) 	for(i=0;i<16;i++ )				//16行，因为是16*16汉字
    03B08 2766      CLR	R22
    03B09 C022      RJMP	0x3B2C
(0342) 	{
(0343) 		W_1byte(0,0,white_y++);		//设置绘图区的Y地址坐标0
    03B0A 802A      LDD	R2,Y+2
    03B0B 2D82      MOV	R24,R2
    03B0C 5F8F      SUBI	R24,0xFF
    03B0D 838A      STD	Y+2,R24
    03B0E 8228      ST	Y,R2
    03B0F 2722      CLR	R18
    03B10 2700      CLR	R16
    03B11 DF28      RCALL	_W_1byte
(0344) 		W_1byte(0,0,white_x);		//设置绘图区的X地址坐标0
    03B12 8009      LDD	R0,Y+1
    03B13 8208      ST	Y,R0
    03B14 2722      CLR	R18
    03B15 2700      CLR	R16
    03B16 DF23      RCALL	_W_1byte
(0345) 		for(j=0;j<white_end_x;j++)	//
    03B17 24EE      CLR	R14
    03B18 C010      RJMP	0x3B29
(0346) 		{
(0347) 			 if(clear==1)
    03B19 858F      LDD	R24,Y+15
    03B1A 3081      CPI	R24,1
    03B1B F431      BNE	0x3B22
(0348) 			 {
(0349) 			  	W_1byte(0,1,0x00); //取消这一行的8个点的反白，液晶地址自动加1
    03B1C 2422      CLR	R2
    03B1D 8228      ST	Y,R2
    03B1E E021      LDI	R18,1
    03B1F 2700      CLR	R16
    03B20 DF19      RCALL	_W_1byte
(0350) 								   //（此处行指一个一个液晶点所组成的行）
(0351) 			 }
    03B21 C005      RJMP	0x3B27
(0352) 			 else
(0353) 			 {
(0354) 				W_1byte(0,1,0xff); //反白这一行的8个点，液晶地址自动加1
    03B22 EF8F      LDI	R24,0xFF
    03B23 8388      ST	Y,R24
    03B24 E021      LDI	R18,1
    03B25 2700      CLR	R16
    03B26 DF13      RCALL	_W_1byte
(0355) 								   //（此处行指一个一个液晶点所组成的行）
(0356) 			 }
(0357) 			nop();
    03B27 0000      NOP
    03B28 94E3      INC	R14
    03B29 14EC      CP	R14,R12
    03B2A F370      BCS	0x3B19
    03B2B 9563      INC	R22
    03B2C 3160      CPI	R22,0x10
    03B2D F2E0      BCS	0x3B0A
(0358) 		}
(0359) 	}
(0360) 	W_1byte(0,0,0x30);		//基本指令集,，绘图显示OFF
    03B2E E380      LDI	R24,0x30
    03B2F 8388      ST	Y,R24
    03B30 2722      CLR	R18
    03B31 2700      CLR	R16
    03B32 DF07      RCALL	_W_1byte
    03B33 9623      ADIW	R28,3
    03B34 940C 4106 JMP	pop_xgsetF0FC
_set_white_n:
  tempendx             --> R10
  tempy                --> R22
  tempx                --> R20
  clear                --> R12
  n                    --> R14
    03B36 940E 4111 CALL	push_xgsetF0FC
    03B38 2EC2      MOV	R12,R18
    03B39 2EE0      MOV	R14,R16
    03B3A 9723      SBIW	R28,3
(0361)  }
(0362) 
(0363) /******************************************************************** 
(0364) 函数 名：set_white_n
(0365) 入口参数： n ,  clear
(0366) 出口参数：无 
(0367) 函数作用：   将四行分成八个位置。n代表位置1-8。本函数用于反显或取消反显
(0368)           某一位置的文字。
(0369) 说        明： 例如 set_white_n(1,0); 表示反显第一行前四个字
(0370) ********************************************************************/ 
(0371) void set_white_n(unsigned char n,unsigned char clear)
(0372) {
(0373) unsigned char tempx,tempy,tempendx;
(0374) if(n==1) {tempx=1;tempy=1;tempendx=4;}
    03B3B 2D8E      MOV	R24,R14
    03B3C 3081      CPI	R24,1
    03B3D F429      BNE	0x3B43
    03B3E E041      LDI	R20,1
    03B3F E061      LDI	R22,1
    03B40 E084      LDI	R24,4
    03B41 2EA8      MOV	R10,R24
    03B42 C037      RJMP	0x3B7A
(0375) else if(n==2) {tempx=5;tempy=1;tempendx=8;}
    03B43 2D8E      MOV	R24,R14
    03B44 3082      CPI	R24,2
    03B45 F429      BNE	0x3B4B
    03B46 E045      LDI	R20,5
    03B47 E061      LDI	R22,1
    03B48 E088      LDI	R24,0x8
    03B49 2EA8      MOV	R10,R24
    03B4A C02F      RJMP	0x3B7A
(0376) else if(n==3) {tempx=1;tempy=2;tempendx=4;}
    03B4B 2D8E      MOV	R24,R14
    03B4C 3083      CPI	R24,3
    03B4D F429      BNE	0x3B53
    03B4E E041      LDI	R20,1
    03B4F E062      LDI	R22,2
    03B50 E084      LDI	R24,4
    03B51 2EA8      MOV	R10,R24
    03B52 C027      RJMP	0x3B7A
(0377) else if(n==4) {tempx=5;tempy=2;tempendx=8;}
    03B53 2D8E      MOV	R24,R14
    03B54 3084      CPI	R24,4
    03B55 F429      BNE	0x3B5B
    03B56 E045      LDI	R20,5
    03B57 E062      LDI	R22,2
    03B58 E088      LDI	R24,0x8
    03B59 2EA8      MOV	R10,R24
    03B5A C01F      RJMP	0x3B7A
(0378) else if(n==5) {tempx=1;tempy=3;tempendx=4;}
    03B5B 2D8E      MOV	R24,R14
    03B5C 3085      CPI	R24,5
    03B5D F429      BNE	0x3B63
    03B5E E041      LDI	R20,1
    03B5F E063      LDI	R22,3
    03B60 E084      LDI	R24,4
    03B61 2EA8      MOV	R10,R24
    03B62 C017      RJMP	0x3B7A
(0379) else if(n==6) {tempx=5;tempy=3;tempendx=8;}
    03B63 2D8E      MOV	R24,R14
    03B64 3086      CPI	R24,6
    03B65 F429      BNE	0x3B6B
    03B66 E045      LDI	R20,5
    03B67 E063      LDI	R22,3
    03B68 E088      LDI	R24,0x8
    03B69 2EA8      MOV	R10,R24
    03B6A C00F      RJMP	0x3B7A
(0380) else if(n==7) {tempx=1;tempy=4;tempendx=4;}
    03B6B 2D8E      MOV	R24,R14
    03B6C 3087      CPI	R24,7
    03B6D F429      BNE	0x3B73
    03B6E E041      LDI	R20,1
    03B6F E064      LDI	R22,4
    03B70 E084      LDI	R24,4
    03B71 2EA8      MOV	R10,R24
    03B72 C007      RJMP	0x3B7A
(0381) else if(n==8) {tempx=5;tempy=4;tempendx=8;}
    03B73 2D8E      MOV	R24,R14
    03B74 3088      CPI	R24,0x8
    03B75 F421      BNE	0x3B7A
    03B76 E045      LDI	R20,5
    03B77 E064      LDI	R22,4
    03B78 E088      LDI	R24,0x8
    03B79 2EA8      MOV	R10,R24
(0382) Set_White(tempx,tempy,tempendx,clear);
    03B7A 82CA      STD	Y+2,R12
    03B7B 82A8      ST	Y,R10
    03B7C 2F26      MOV	R18,R22
    03B7D 2F04      MOV	R16,R20
    03B7E DF25      RCALL	_Set_White
    03B7F 9623      ADIW	R28,3
    03B80 940C 4106 JMP	pop_xgsetF0FC
_clr_white:
  clr_x                --> R10
  clr_y                --> R20
  i                    --> R22
  j                    --> R12
    03B82 940E 4111 CALL	push_xgsetF0FC
    03B84 9721      SBIW	R28,1
(0383) 
(0384) }
(0385)  
(0386) /******************************************************************** 
(0387) 函数 名：clr_white
(0388) 入口参数： 清所有 反白
(0389) 出口参数：无 
(0390) 函数作用： 
(0391) 说        明： 
(0392) ********************************************************************/ 
(0393) void clr_white(void)
(0394) {      unsigned char i,j;
(0395) 
(0396)        unsigned char  clr_y=0x80;
    03B85 E840      LDI	R20,0x80
(0397) 	   unsigned char  clr_x=0x80;
    03B86 E880      LDI	R24,0x80
    03B87 2EA8      MOV	R10,R24
(0398) 	   W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03B88 E386      LDI	R24,0x36
    03B89 8388      ST	Y,R24
    03B8A 2722      CLR	R18
    03B8B 2700      CLR	R16
    03B8C DEAD      RCALL	_W_1byte
(0399) 	 	for(i=0;i<16;i++ )			//16行
    03B8D 2766      CLR	R22
    03B8E C017      RJMP	0x3BA6
(0400) 		{
(0401) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03B8F 2E24      MOV	R2,R20
    03B90 5F4F      SUBI	R20,0xFF
    03B91 8228      ST	Y,R2
    03B92 2722      CLR	R18
    03B93 2700      CLR	R16
    03B94 DEA5      RCALL	_W_1byte
(0402) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03B95 82A8      ST	Y,R10
    03B96 2722      CLR	R18
    03B97 2700      CLR	R16
    03B98 DEA1      RCALL	_W_1byte
(0403) 			for(j=0;j<16;j++)		//
    03B99 24CC      CLR	R12
    03B9A C007      RJMP	0x3BA2
(0404) 			{
(0405) 			 	W_1byte(0,1,0x00);	//清成不反白
    03B9B 2422      CLR	R2
    03B9C 8228      ST	Y,R2
    03B9D E021      LDI	R18,1
    03B9E 2700      CLR	R16
    03B9F DE9A      RCALL	_W_1byte
(0406) 			 	nop();
    03BA0 0000      NOP
    03BA1 94C3      INC	R12
    03BA2 2D8C      MOV	R24,R12
    03BA3 3180      CPI	R24,0x10
    03BA4 F3B0      BCS	0x3B9B
    03BA5 9563      INC	R22
    03BA6 3160      CPI	R22,0x10
    03BA7 F338      BCS	0x3B8F
(0407) 			}
(0408) 		}
(0409) 	
(0410) 	    clr_y=0x80;
    03BA8 E840      LDI	R20,0x80
(0411) 	    clr_x=0x90;
    03BA9 E980      LDI	R24,0x90
    03BAA 2EA8      MOV	R10,R24
(0412) 		 	for(i=0;i<16;i++ )			//16行
    03BAB 2766      CLR	R22
    03BAC C017      RJMP	0x3BC4
(0413) 		{
(0414) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03BAD 2E24      MOV	R2,R20
    03BAE 5F4F      SUBI	R20,0xFF
    03BAF 8228      ST	Y,R2
    03BB0 2722      CLR	R18
    03BB1 2700      CLR	R16
    03BB2 DE87      RCALL	_W_1byte
(0415) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03BB3 82A8      ST	Y,R10
    03BB4 2722      CLR	R18
    03BB5 2700      CLR	R16
    03BB6 DE83      RCALL	_W_1byte
(0416) 			for(j=0;j<16;j++)		//
    03BB7 24CC      CLR	R12
    03BB8 C007      RJMP	0x3BC0
(0417) 			{
(0418) 			 	W_1byte(0,1,0x00);	//清成不反白
    03BB9 2422      CLR	R2
    03BBA 8228      ST	Y,R2
    03BBB E021      LDI	R18,1
    03BBC 2700      CLR	R16
    03BBD DE7C      RCALL	_W_1byte
(0419) 			 	nop();
    03BBE 0000      NOP
    03BBF 94C3      INC	R12
    03BC0 2D8C      MOV	R24,R12
    03BC1 3180      CPI	R24,0x10
    03BC2 F3B0      BCS	0x3BB9
    03BC3 9563      INC	R22
    03BC4 3160      CPI	R22,0x10
    03BC5 F338      BCS	0x3BAD
(0420) 			}
(0421) 		}   
(0422) 	   
(0423) 	     clr_y=0x88;
    03BC6 E848      LDI	R20,0x88
(0424) 	     clr_x=0x80;
    03BC7 E880      LDI	R24,0x80
    03BC8 2EA8      MOV	R10,R24
(0425) 		 	for(i=0;i<16;i++ )			//16行
    03BC9 2766      CLR	R22
    03BCA C017      RJMP	0x3BE2
(0426) 		{
(0427) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03BCB 2EE4      MOV	R14,R20
    03BCC 5F4F      SUBI	R20,0xFF
    03BCD 82E8      ST	Y,R14
    03BCE 2722      CLR	R18
    03BCF 2700      CLR	R16
    03BD0 DE69      RCALL	_W_1byte
(0428) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03BD1 82A8      ST	Y,R10
    03BD2 2722      CLR	R18
    03BD3 2700      CLR	R16
    03BD4 DE65      RCALL	_W_1byte
(0429) 			for(j=0;j<16;j++)		//
    03BD5 24CC      CLR	R12
    03BD6 C007      RJMP	0x3BDE
(0430) 			{
(0431) 			 	W_1byte(0,1,0x00);	//清成不反白
    03BD7 2422      CLR	R2
    03BD8 8228      ST	Y,R2
    03BD9 E021      LDI	R18,1
    03BDA 2700      CLR	R16
    03BDB DE5E      RCALL	_W_1byte
(0432) 			 	nop();
    03BDC 0000      NOP
    03BDD 94C3      INC	R12
    03BDE 2D8C      MOV	R24,R12
    03BDF 3180      CPI	R24,0x10
    03BE0 F3B0      BCS	0x3BD7
    03BE1 9563      INC	R22
    03BE2 3160      CPI	R22,0x10
    03BE3 F338      BCS	0x3BCB
(0433) 			}
(0434) 		} 
(0435) 	     clr_y=0x88;
    03BE4 E848      LDI	R20,0x88
(0436) 	     clr_x=0x90;
    03BE5 E980      LDI	R24,0x90
    03BE6 2EA8      MOV	R10,R24
(0437) 		 	for(i=0;i<16;i++ )			//16行
    03BE7 2766      CLR	R22
    03BE8 C017      RJMP	0x3C00
(0438) 		{
(0439) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03BE9 2EE4      MOV	R14,R20
    03BEA 5F4F      SUBI	R20,0xFF
    03BEB 82E8      ST	Y,R14
    03BEC 2722      CLR	R18
    03BED 2700      CLR	R16
    03BEE DE4B      RCALL	_W_1byte
(0440) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03BEF 82A8      ST	Y,R10
    03BF0 2722      CLR	R18
    03BF1 2700      CLR	R16
    03BF2 DE47      RCALL	_W_1byte
(0441) 			for(j=0;j<16;j++)		//
    03BF3 24CC      CLR	R12
    03BF4 C007      RJMP	0x3BFC
(0442) 			{
(0443) 			 	W_1byte(0,1,0x00);	//清成不反白
    03BF5 2422      CLR	R2
    03BF6 8228      ST	Y,R2
    03BF7 E021      LDI	R18,1
    03BF8 2700      CLR	R16
    03BF9 DE40      RCALL	_W_1byte
(0444) 			 	nop();
    03BFA 0000      NOP
    03BFB 94C3      INC	R12
    03BFC 2D8C      MOV	R24,R12
    03BFD 3180      CPI	R24,0x10
    03BFE F3B0      BCS	0x3BF5
    03BFF 9563      INC	R22
    03C00 3160      CPI	R22,0x10
    03C01 F338      BCS	0x3BE9
(0445) 			}
(0446) 		} 		
(0447)   W_1byte(0,0,0x30);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03C02 E380      LDI	R24,0x30
    03C03 8388      ST	Y,R24
    03C04 2722      CLR	R18
    03C05 2700      CLR	R16
    03C06 DE33      RCALL	_W_1byte
    03C07 9621      ADIW	R28,1
    03C08 940C 4106 JMP	pop_xgsetF0FC
_LCD_print2num:
  a                    --> R12
  tem                  --> R20
  num                  --> R10
  y                    --> R14
  x                    --> R12
    03C0A 940E 4113 CALL	push_xgset30FC
    03C0C 2EE2      MOV	R14,R18
    03C0D 2EC0      MOV	R12,R16
    03C0E 9721      SBIW	R28,1
    03C0F 84A9      LDD	R10,Y+9
(0448) 	}
(0449) /******************************************************************** 
(0450) 函数 名：LCD_print2num
(0451) 入口参数： 显示2数字
(0452) 出口参数：无 
(0453) 函数作用： 
(0454) 说        明： 
(0455) ********************************************************************/ 
(0456) void LCD_print2num(unsigned char x,unsigned char y,unsigned char num){
(0457) unsigned char tem;
(0458) unsigned char a; 
(0459) 
(0460) a=address(x,y);
    03C10 2D2E      MOV	R18,R14
    03C11 2D0C      MOV	R16,R12
    03C12 DD40      RCALL	_address
    03C13 2EC0      MOV	R12,R16
(0461) W_1byte(0,0,a);     //显示的地址 
    03C14 82C8      ST	Y,R12
    03C15 2722      CLR	R18
    03C16 2700      CLR	R16
    03C17 DE22      RCALL	_W_1byte
(0462) tem=num/10;
    03C18 E01A      LDI	R17,0xA
    03C19 2D0A      MOV	R16,R10
    03C1A 940E 4083 CALL	div8u
    03C1C 2F40      MOV	R20,R16
(0463) W_1byte(0,1,tem+0x30);
    03C1D 2F84      MOV	R24,R20
    03C1E 5D80      SUBI	R24,0xD0
    03C1F 8388      ST	Y,R24
    03C20 E021      LDI	R18,1
    03C21 2700      CLR	R16
    03C22 DE17      RCALL	_W_1byte
(0464) tem=num%10;
    03C23 E01A      LDI	R17,0xA
    03C24 2D0A      MOV	R16,R10
    03C25 940E 4081 CALL	mod8u
    03C27 2F40      MOV	R20,R16
(0465) W_1byte(0,1,tem+0x30); 
    03C28 2F84      MOV	R24,R20
    03C29 5D80      SUBI	R24,0xD0
    03C2A 8388      ST	Y,R24
    03C2B E021      LDI	R18,1
    03C2C 2700      CLR	R16
    03C2D DE0C      RCALL	_W_1byte
(0466) W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03C2E EF8F      LDI	R24,0xFF
    03C2F 8388      ST	Y,R24
    03C30 2722      CLR	R18
    03C31 2700      CLR	R16
    03C32 DE07      RCALL	_W_1byte
    03C33 9621      ADIW	R28,1
    03C34 940C 40FD JMP	pop_xgset30FC
_LCD_print4num:
  tem                  --> R12
  num                  --> R14
  y                    --> R20
  x                    --> R10
    03C36 940E 4113 CALL	push_xgset30FC
    03C38 2F42      MOV	R20,R18
    03C39 2EA0      MOV	R10,R16
    03C3A 9721      SBIW	R28,1
    03C3B 84E9      LDD	R14,Y+9
    03C3C 84FA      LDD	R15,Y+10
(0467) }
(0468)  
(0469) /******************************************************************** 
(0470) 函数 名：LCD_print4num
(0471) 入口参数： 显示4数字
(0472) 出口参数：无 
(0473) 函数作用： 
(0474) 说        明： 
(0475) ********************************************************************/ 
(0476) void LCD_print4num(unsigned char x,unsigned char y,unsigned int num){
(0477) unsigned char tem;
(0478) tem=num/100;
    03C3D E624      LDI	R18,0x64
    03C3E E030      LDI	R19,0
    03C3F 0187      MOVW	R16,R14
    03C40 940E 3FFD CALL	div16u
    03C42 2EC0      MOV	R12,R16
(0479) LCD_print2num(x,y,tem);
    03C43 82C8      ST	Y,R12
    03C44 2F24      MOV	R18,R20
    03C45 2D0A      MOV	R16,R10
    03C46 DFC3      RCALL	_LCD_print2num
(0480) 
(0481) tem=num%100;   
    03C47 E624      LDI	R18,0x64
    03C48 E030      LDI	R19,0
    03C49 0187      MOVW	R16,R14
    03C4A 940E 3FFB CALL	mod16u
    03C4C 2EC0      MOV	R12,R16
(0482) LCD_print2num(x,y+1,tem);
    03C4D 82C8      ST	Y,R12
    03C4E 2F24      MOV	R18,R20
    03C4F 5F2F      SUBI	R18,0xFF
    03C50 2D0A      MOV	R16,R10
    03C51 DFB8      RCALL	_LCD_print2num
(0483) 
(0484) 
(0485)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03C52 EF8F      LDI	R24,0xFF
    03C53 8388      ST	Y,R24
    03C54 2722      CLR	R18
    03C55 2700      CLR	R16
    03C56 DDE3      RCALL	_W_1byte
    03C57 9621      ADIW	R28,1
    03C58 940C 40FD JMP	pop_xgset30FC
_LCD_print:
  a                    --> R12
  ch                   --> R10
  y                    --> R14
  x                    --> R12
    03C5A 940E 4115 CALL	push_xgset00FC
    03C5C 2EE2      MOV	R14,R18
    03C5D 2EC0      MOV	R12,R16
    03C5E 9721      SBIW	R28,1
    03C5F 80AF      LDD	R10,Y+7
(0486) }
(0487)  
(0488) //////////////////////////////////////////////////////////////
(0489) 
(0490) /******************************************************************** 
(0491) 函数 名：LCD_print 
(0492) 入口参数： 显示1 ascii
(0493) 出口参数：无 
(0494) 函数作用： 
(0495) 说        明： 
(0496) ********************************************************************/ 
(0497) void LCD_print(unsigned char x,unsigned char y,unsigned char ch)
(0498) {  
(0499) unsigned char a; 
(0500) a=address(x,y);
    03C60 2D2E      MOV	R18,R14
    03C61 2D0C      MOV	R16,R12
    03C62 DCF0      RCALL	_address
    03C63 2EC0      MOV	R12,R16
(0501) W_1byte(0,0,a);     //显示的地址 
    03C64 82C8      ST	Y,R12
    03C65 2722      CLR	R18
    03C66 2700      CLR	R16
    03C67 DDD2      RCALL	_W_1byte
(0502) W_1byte(0,1,ch); 
    03C68 82A8      ST	Y,R10
    03C69 E021      LDI	R18,1
    03C6A 2700      CLR	R16
    03C6B DDCE      RCALL	_W_1byte
    03C6C 9621      ADIW	R28,1
    03C6D 940C 40F6 JMP	pop_xgset00FC
_LCD_print1:
  ch                   --> R10
    03C6F 92AA      ST	-Y,R10
    03C70 2EA0      MOV	R10,R16
    03C71 9721      SBIW	R28,1
(0503) 
(0504) 
(0505) 
(0506) }
(0507) /******************************************************************** 
(0508) 函数 名：LCD_print1 
(0509) 入口参数： 显示1 ascii
(0510) 出口参数：无 
(0511) 函数作用：接着上文地址显示，不重设地址 
(0512) 说        明： 
(0513) ********************************************************************/ 
(0514) void LCD_print1(char ch)
(0515) {  
(0516) W_1byte(0,1,ch); 
    03C72 82A8      ST	Y,R10
    03C73 E021      LDI	R18,1
    03C74 2700      CLR	R16
    03C75 DDC4      RCALL	_W_1byte
    03C76 9621      ADIW	R28,1
    03C77 90A9      LD	R10,Y+
    03C78 9508      RET
_lp:
  p                    --> R10
    03C79 92AA      ST	-Y,R10
    03C7A 92BA      ST	-Y,R11
    03C7B 0158      MOVW	R10,R16
    03C7C 9722      SBIW	R28,2
(0517) }
(0518) //////////////////////////////////////////////////////////////
(0519) 
(0520) 
(0521) 
(0522)  void lp(unsigned char *p)
(0523)  {
(0524)  static unsigned char *p1=" ",*p2=" ",*p3=" ",*p4=" ";
(0525)  p4=p3;
    03C7D 9020 04EB LDS	R2,lcd.c:p3
    03C7F 9030 04EC LDS	R3,lcd.c:p3+1
    03C81 9230 04EE STS	lcd.c:p4+1,R3
    03C83 9220 04ED STS	lcd.c:p4,R2
(0526)  p3=p2;
    03C85 9020 04E9 LDS	R2,lcd.c:p2
    03C87 9030 04EA LDS	R3,lcd.c:p2+1
    03C89 9230 04EC STS	lcd.c:p3+1,R3
    03C8B 9220 04EB STS	lcd.c:p3,R2
(0527)  p2=p1;
    03C8D 9020 04E7 LDS	R2,lcd.c:p1
    03C8F 9030 04E8 LDS	R3,lcd.c:p1+1
    03C91 9230 04EA STS	lcd.c:p2+1,R3
    03C93 9220 04E9 STS	lcd.c:p2,R2
(0528)  p1=p;
    03C95 92B0 04E8 STS	lcd.c:p1+1,R11
    03C97 92A0 04E7 STS	lcd.c:p1,R10
(0529)   LCD_const_disp(1,1,"                ");
    03C99 EE8F      LDI	R24,0xEF
    03C9A E094      LDI	R25,4
    03C9B 8399      STD	Y+1,R25
    03C9C 8388      ST	Y,R24
    03C9D E021      LDI	R18,1
    03C9E E001      LDI	R16,1
    03C9F DCD4      RCALL	_LCD_const_disp
(0530)   LCD_const_disp(2,1,"                ");
    03CA0 EE8F      LDI	R24,0xEF
    03CA1 E094      LDI	R25,4
    03CA2 8399      STD	Y+1,R25
    03CA3 8388      ST	Y,R24
    03CA4 E021      LDI	R18,1
    03CA5 E002      LDI	R16,2
    03CA6 DCCD      RCALL	_LCD_const_disp
(0531)   LCD_const_disp(3,1,"                ");
    03CA7 EE8F      LDI	R24,0xEF
    03CA8 E094      LDI	R25,4
    03CA9 8399      STD	Y+1,R25
    03CAA 8388      ST	Y,R24
    03CAB E021      LDI	R18,1
    03CAC E003      LDI	R16,3
    03CAD DCC6      RCALL	_LCD_const_disp
(0532)   LCD_const_disp(4,1,"                ");
    03CAE EE8F      LDI	R24,0xEF
    03CAF E094      LDI	R25,4
    03CB0 8399      STD	Y+1,R25
    03CB1 8388      ST	Y,R24
    03CB2 E021      LDI	R18,1
    03CB3 E004      LDI	R16,4
    03CB4 DCBF      RCALL	_LCD_const_disp
(0533)   LCD_var_disp(1,1,p4);
    03CB5 9020 04ED LDS	R2,lcd.c:p4
    03CB7 9030 04EE LDS	R3,lcd.c:p4+1
    03CB9 8239      STD	Y+1,R3
    03CBA 8228      ST	Y,R2
    03CBB E021      LDI	R18,1
    03CBC E001      LDI	R16,1
    03CBD DCE3      RCALL	_LCD_var_disp
(0534)   LCD_var_disp(2,1,p3);
    03CBE 9020 04EB LDS	R2,lcd.c:p3
    03CC0 9030 04EC LDS	R3,lcd.c:p3+1
    03CC2 8239      STD	Y+1,R3
    03CC3 8228      ST	Y,R2
    03CC4 E021      LDI	R18,1
    03CC5 E002      LDI	R16,2
    03CC6 DCDA      RCALL	_LCD_var_disp
(0535)   LCD_var_disp(3,1,p2);
    03CC7 9020 04E9 LDS	R2,lcd.c:p2
    03CC9 9030 04EA LDS	R3,lcd.c:p2+1
    03CCB 8239      STD	Y+1,R3
    03CCC 8228      ST	Y,R2
    03CCD E021      LDI	R18,1
    03CCE E003      LDI	R16,3
    03CCF DCD1      RCALL	_LCD_var_disp
(0536)   LCD_var_disp(4,1,p1);
    03CD0 9020 04E7 LDS	R2,lcd.c:p1
    03CD2 9030 04E8 LDS	R3,lcd.c:p1+1
    03CD4 8239      STD	Y+1,R3
    03CD5 8228      ST	Y,R2
    03CD6 E021      LDI	R18,1
    03CD7 E004      LDI	R16,4
    03CD8 DCC8      RCALL	_LCD_var_disp
(0537)   delayms(300);
    03CD9 E20C      LDI	R16,0x2C
    03CDA E011      LDI	R17,1
    03CDB 940E 240B CALL	_delayms
    03CDD 9622      ADIW	R28,2
    03CDE 90B9      LD	R11,Y+
    03CDF 90A9      LD	R10,Y+
    03CE0 9508      RET
FILE: D:\LQD\software\master\software_src\relay.c
(0001) #include "config.h"
(0002) /*继电器初始化
(0003) *设置端口
(0004) *初始化关闭
(0005) */
(0006) void relay_init(void){
(0007) 	
(0008) 		RELAY_DDR_SET() ;
_relay_init:
    03CE1 9AA5      SBI	0x14,5
(0009) 		RELAY_OFF();
    03CE2 98AD      CBI	0x15,5
    03CE3 9508      RET
(0010) 		//state.Relay = 0;
(0011) 	}	
(0012) 
(0013) /*继电器控制
(0014) *传入 ： 温度
(0015) *传出 ： 当前继电器状态
(0016) *
(0017) */
(0018) unsigned char  relay(int temp)
(0019) {
(0020) 	if(temp<HEAT_THRESHOLD)
_relay:
  temp                 --> R16
    03CE4 3005      CPI	R16,5
    03CE5 E0E0      LDI	R30,0
    03CE6 071E      CPC	R17,R30
    03CE7 F41C      BGE	0x3CEB
(0021) 	{
(0022) 	 		RELAY_DDR_SET();
    03CE8 9AA5      SBI	0x14,5
(0023) 			RELAY_ON();
    03CE9 9AAD      SBI	0x15,5
(0024) 			//state.Relay = 1 ;
(0025) 	}
    03CEA C002      RJMP	0x3CED
(0026) 	else
(0027) 	{
(0028) 	 	RELAY_DDR_SET();
    03CEB 9AA5      SBI	0x14,5
(0029) 		RELAY_OFF();
    03CEC 98AD      CBI	0x15,5
(0030) 		//state.Relay = 0 ;
(0031) 	}		
(0032) 	//return state.Relay;
(0033) 	return 0;
    03CED 2700      CLR	R16
    03CEE 9508      RET
_beep:
  i                    --> R10
  short_beep           --> R12
  long_beep            --> R14
    03CEF 940E 4115 CALL	push_xgset00FC
    03CF1 2EC2      MOV	R12,R18
    03CF2 2EE0      MOV	R14,R16
FILE: D:\LQD\software\master\software_src\beep.c
(0001) #include "config.h"
(0002) 
(0003) #define BEEP_PORT	PORTC
(0004) #define BEEP_PIN	6
(0005) #define BEEP_OFF() BEEP_PORT|=(1<<BEEP_PIN)
(0006) #define BEEP_ON()  BEEP_PORT&=~(1<<BEEP_PIN)
(0007) //楦ｅ
(0008) void beep(unsigned char long_beep,unsigned char short_beep)
(0009) { 
(0010) unsigned char i;
(0011) DDRB|=(1<<0);
    03CF3 9AB8      SBI	0x17,0
(0012) for(i=0;i<long_beep;i++)
    03CF4 24AA      CLR	R10
    03CF5 C00B      RJMP	0x3D01
(0013) {
(0014) BEEP_ON();  delayms(200);
    03CF6 98AE      CBI	0x15,6
    03CF7 EC08      LDI	R16,0xC8
    03CF8 E010      LDI	R17,0
    03CF9 940E 240B CALL	_delayms
(0015) BEEP_OFF(); delayms(50);
    03CFB 9AAE      SBI	0x15,6
    03CFC E302      LDI	R16,0x32
    03CFD E010      LDI	R17,0
    03CFE 940E 240B CALL	_delayms
    03D00 94A3      INC	R10
    03D01 14AE      CP	R10,R14
    03D02 F398      BCS	0x3CF6
(0016) }
(0017) delayms(100);
    03D03 E604      LDI	R16,0x64
    03D04 E010      LDI	R17,0
    03D05 940E 240B CALL	_delayms
(0018) for(i=0;i<short_beep;i++)
    03D07 24AA      CLR	R10
    03D08 C00B      RJMP	0x3D14
(0019) {
(0020) BEEP_ON();  delayms(80);
    03D09 98AE      CBI	0x15,6
    03D0A E500      LDI	R16,0x50
    03D0B E010      LDI	R17,0
    03D0C 940E 240B CALL	_delayms
(0021) BEEP_OFF(); delayms(50);
    03D0E 9AAE      SBI	0x15,6
    03D0F E302      LDI	R16,0x32
    03D10 E010      LDI	R17,0
    03D11 940E 240B CALL	_delayms
    03D13 94A3      INC	R10
    03D14 14AC      CP	R10,R12
    03D15 F398      BCS	0x3D09
    03D16 940C 40F6 JMP	pop_xgset00FC
_Delay_nus:
  i                    --> R20
  n                    --> R16
    03D18 934A      ST	-Y,R20
    03D19 935A      ST	-Y,R21
FILE: D:\LQD\software\master\software_src\DS18B20_driver.c
(0001) //------------------------------------------------------------------------------
(0002) // 文件名：DS18B20_driver.c
(0003) // 说明：  DS18B20驱动头文件
(0004) // 功能：  实现1-wire器件的读写
(0005) // 使用方法：   void Delay_nus(unsigned int n);             //延时n微秒函数
(0006) //              unsigned char reset_18B20(void);            //18B20复位
(0007) //              void write_bit_18B20(char bitval);          //写一位到18B20
(0008) //              unsigned char read_bit_18B20(void);         //读一位从18B20
(0009) //              void write_byte_18B20(unsigned char data);  //写一字节到18B20
(0010) //              unsigned char read_18B20(void);             //读一字节到18B20
(0011) //
(0012) // 运行平台：   AVR 8bit (M16已验证)
(0013) // 依存关系：   DS18B20_driver.h    DS18B20基本驱动头文件（函数声明）
(0014) // 移植人：     
(0015) // 最后修改：   
(0016) //------------------------------------------------------------------------------
(0017) 
(0018) #include "config.h"
(0019) #define DS18B20_PORT PORTG
(0020) #define DS18B20_PIN  PING
(0021) #define DS18B20_DDR  DDRG
(0022) #define CL_DQ   DS18B20_PORT&=~(1<<T_NUM)					   
(0023) #define SET_DQ  DS18B20_PORT|=(1<<T_NUM)			   
(0024) #define SET_OUT DS18B20_DDR|=(1<<T_NUM)				   
(0025) #define SET_IN  DS18B20_DDR&=~(1<<T_NUM)			   
(0026) #define IN_DQ   DS18B20_PIN&(1<<T_NUM)				  
(0027) unsigned char T_NUM=0;
(0028) 
(0029) 
(0030) //------------------------------------------------------------------------------
(0031) // 延时N微秒程序 供控制读写DS18B20时序使用
(0032) //------------------------------------------------------------------------------
(0033) void Delay_nus(unsigned int n)   
(0034) {  unsigned int i;
(0035) 	  for (i=0;i<n;i++) 
    03D1A 2744      CLR	R20
    03D1B 2755      CLR	R21
    03D1C C005      RJMP	0x3D22
(0036) 	  		{NOP();
    03D1D 0000      NOP
(0037) 						NOP();
    03D1E 0000      NOP
(0038) 						NOP();				        //20--300//比较接近
    03D1F 0000      NOP
    03D20 5F4F      SUBI	R20,0xFF
    03D21 4F5F      SBCI	R21,0xFF
    03D22 1740      CP	R20,R16
    03D23 0751      CPC	R21,R17
    03D24 F3C0      BCS	0x3D1D
    03D25 9159      LD	R21,Y+
    03D26 9149      LD	R20,Y+
    03D27 9508      RET
_reset_18B20:
  bus_flag             --> R10
    03D28 92AA      ST	-Y,R10
(0039) 					}
(0040) }
(0041) 
(0042) 
(0043) //------------------------------------------------------------------------------
(0044) // 1-wire总线复位
(0045) //------------------------------------------------------------------------------
(0046) unsigned char reset_18B20(void)
(0047) {
(0048) 	char bus_flag;
(0049) 	CLI();
    03D29 94F8      BCLR	7
(0050) 	SET_DQ;
    03D2A 9110 0502 LDS	R17,T_NUM
    03D2C E001      LDI	R16,1
    03D2D 940E 419F CALL	lsl8
    03D2F 9020 0065 LDS	R2,0x65
    03D31 2A20      OR	R2,R16
    03D32 9220 0065 STS	0x65,R2
(0051) 	SET_OUT;
    03D34 9110 0502 LDS	R17,T_NUM
    03D36 E001      LDI	R16,1
    03D37 940E 419F CALL	lsl8
    03D39 9020 0064 LDS	R2,0x64
    03D3B 2A20      OR	R2,R16
    03D3C 9220 0064 STS	0x64,R2
(0052)  	
(0053)   	Delay_nus(1);
    03D3E E001      LDI	R16,1
    03D3F E010      LDI	R17,0
    03D40 DFD7      RCALL	_Delay_nus
(0054)   	CL_DQ;
    03D41 9110 0502 LDS	R17,T_NUM
    03D43 E001      LDI	R16,1
    03D44 940E 419F CALL	lsl8
    03D46 2E20      MOV	R2,R16
    03D47 9420      COM	R2
    03D48 9030 0065 LDS	R3,0x65
    03D4A 2032      AND	R3,R2
    03D4B 9230 0065 STS	0x65,R3
(0055)   	Delay_nus(550);		//拉低至少480us时间
    03D4D E206      LDI	R16,0x26
    03D4E E012      LDI	R17,2
    03D4F DFC8      RCALL	_Delay_nus
(0056)   	SET_DQ;				//释放
    03D50 9110 0502 LDS	R17,T_NUM
    03D52 E001      LDI	R16,1
    03D53 940E 419F CALL	lsl8
    03D55 9020 0065 LDS	R2,0x65
    03D57 2A20      OR	R2,R16
    03D58 9220 0065 STS	0x65,R2
(0057) 					NOP();
    03D5A 0000      NOP
(0058) 					NOP();
    03D5B 0000      NOP
(0059)   	SET_IN;				//输入
    03D5C 9110 0502 LDS	R17,T_NUM
    03D5E E001      LDI	R16,1
    03D5F 940E 419F CALL	lsl8
    03D61 2E20      MOV	R2,R16
    03D62 9420      COM	R2
    03D63 9030 0064 LDS	R3,0x64
    03D65 2032      AND	R3,R2
    03D66 9230 0064 STS	0x64,R3
(0060)   	Delay_nus(60);
    03D68 E30C      LDI	R16,0x3C
    03D69 E010      LDI	R17,0
    03D6A DFAD      RCALL	_Delay_nus
(0061)   	
(0062) 						//等待回复
(0063)   	bus_flag = IN_DQ;
    03D6B 9110 0502 LDS	R17,T_NUM
    03D6D E001      LDI	R16,1
    03D6E 940E 419F CALL	lsl8
    03D70 90A0 0063 LDS	R10,0x63
    03D72 22A0      AND	R10,R16
(0064)   	
(0065)   	Delay_nus(240);		//回复的低电平在60到240US
    03D73 EF00      LDI	R16,0xF0
    03D74 E010      LDI	R17,0
    03D75 DFA2      RCALL	_Delay_nus
(0066)   	SET_OUT;
    03D76 9110 0502 LDS	R17,T_NUM
    03D78 E001      LDI	R16,1
    03D79 940E 419F CALL	lsl8
    03D7B 9020 0064 LDS	R2,0x64
    03D7D 2A20      OR	R2,R16
    03D7E 9220 0064 STS	0x64,R2
(0067) 					NOP();
    03D80 0000      NOP
(0068) 					NOP();
    03D81 0000      NOP
(0069)   	SET_DQ;				//回到初始DQ=1；
    03D82 9110 0502 LDS	R17,T_NUM
    03D84 E001      LDI	R16,1
    03D85 940E 419F CALL	lsl8
    03D87 9020 0065 LDS	R2,0x65
    03D89 2A20      OR	R2,R16
    03D8A 9220 0065 STS	0x65,R2
(0070) 
(0071)   	SEI();
    03D8C 9478      BSET	7
(0072) 	if(bus_flag){
    03D8D 20AA      TST	R10
    03D8E F011      BEQ	0x3D91
(0073) 		return FALSE;
    03D8F 2700      CLR	R16
    03D90 C001      RJMP	0x3D92
(0074) 	}else{
(0075) 		return TRUE;
    03D91 E001      LDI	R16,1
    03D92 90A9      LD	R10,Y+
    03D93 9508      RET
_write_bit_18B20:
  bitval               --> R10
    03D94 92AA      ST	-Y,R10
    03D95 2EA0      MOV	R10,R16
(0076) 	}
(0077) 
(0078) }
(0079) 
(0080) //------------------------------------------------------------------------------
(0081) // 写一位到总线
(0082) //------------------------------------------------------------------------------
(0083) void write_bit_18B20(char bitval)
(0084) {
(0085)     SET_OUT;
    03D96 9110 0502 LDS	R17,T_NUM
    03D98 E001      LDI	R16,1
    03D99 940E 419F CALL	lsl8
    03D9B 9020 0064 LDS	R2,0x64
    03D9D 2A20      OR	R2,R16
    03D9E 9220 0064 STS	0x64,R2
(0086) 					NOP();
    03DA0 0000      NOP
(0087) 					NOP();
    03DA1 0000      NOP
(0088) 			 CL_DQ;
    03DA2 9110 0502 LDS	R17,T_NUM
    03DA4 E001      LDI	R16,1
    03DA5 940E 419F CALL	lsl8
    03DA7 2E20      MOV	R2,R16
    03DA8 9420      COM	R2
    03DA9 9030 0065 LDS	R3,0x65
    03DAB 2032      AND	R3,R2
    03DAC 9230 0065 STS	0x65,R3
(0089) 	   Delay_nus(1);
    03DAE E001      LDI	R16,1
    03DAF E010      LDI	R17,0
    03DB0 DF67      RCALL	_Delay_nus
(0090) 	   if(bitval){    //写数据，从低位开始
    03DB1 20AA      TST	R10
    03DB2 F059      BEQ	0x3DBE
(0091) 		     SET_DQ;
    03DB3 9110 0502 LDS	R17,T_NUM
    03DB5 E001      LDI	R16,1
    03DB6 940E 419F CALL	lsl8
    03DB8 9020 0065 LDS	R2,0x65
    03DBA 2A20      OR	R2,R16
    03DBB 9220 0065 STS	0x65,R2
(0092) 	  }else{
    03DBD C00C      RJMP	0x3DCA
(0093) 		     CL_DQ;
    03DBE 9110 0502 LDS	R17,T_NUM
    03DC0 E001      LDI	R16,1
    03DC1 940E 419F CALL	lsl8
    03DC3 2E20      MOV	R2,R16
    03DC4 9420      COM	R2
    03DC5 9030 0065 LDS	R3,0x65
    03DC7 2032      AND	R3,R2
    03DC8 9230 0065 STS	0x65,R3
(0094) 	  }
(0095) 	Delay_nus(40);		//15~60us
    03DCA E208      LDI	R16,0x28
    03DCB E010      LDI	R17,0
    03DCC DF4B      RCALL	_Delay_nus
(0096) 	SET_DQ;
    03DCD 9110 0502 LDS	R17,T_NUM
    03DCF E001      LDI	R16,1
    03DD0 940E 419F CALL	lsl8
    03DD2 9020 0065 LDS	R2,0x65
    03DD4 2A20      OR	R2,R16
    03DD5 9220 0065 STS	0x65,R2
(0097) 	Delay_nus(10);
    03DD7 E00A      LDI	R16,0xA
    03DD8 E010      LDI	R17,0
    03DD9 DF3E      RCALL	_Delay_nus
    03DDA 90A9      LD	R10,Y+
    03DDB 9508      RET
_read_bit_18B20:
  k                    --> R10
    03DDC 92AA      ST	-Y,R10
(0098) }
(0099) 
(0100) //------------------------------------------------------------------------------
(0101) // 读一位从总线
(0102) //------------------------------------------------------------------------------
(0103) unsigned char read_bit_18B20(void)
(0104) {
(0105) 	unsigned char k;
(0106) 	SET_OUT;
    03DDD 9110 0502 LDS	R17,T_NUM
    03DDF E001      LDI	R16,1
    03DE0 940E 419F CALL	lsl8
    03DE2 9020 0064 LDS	R2,0x64
    03DE4 2A20      OR	R2,R16
    03DE5 9220 0064 STS	0x64,R2
(0107) 	CL_DQ;			//读时间片开始，拉低总线至少1us
    03DE7 9110 0502 LDS	R17,T_NUM
    03DE9 E001      LDI	R16,1
    03DEA 940E 419F CALL	lsl8
    03DEC 2E20      MOV	R2,R16
    03DED 9420      COM	R2
    03DEE 9030 0065 LDS	R3,0x65
    03DF0 2032      AND	R3,R2
    03DF1 9230 0065 STS	0x65,R3
(0108) 	Delay_nus(1);
    03DF3 E001      LDI	R16,1
    03DF4 E010      LDI	R17,0
    03DF5 DF22      RCALL	_Delay_nus
(0109) 	
(0110) 					//SET_DQ;	
(0111) 	SET_IN;
    03DF6 9110 0502 LDS	R17,T_NUM
    03DF8 E001      LDI	R16,1
    03DF9 940E 419F CALL	lsl8
    03DFB 2E20      MOV	R2,R16
    03DFC 9420      COM	R2
    03DFD 9030 0064 LDS	R3,0x64
    03DFF 2032      AND	R3,R2
    03E00 9230 0064 STS	0x64,R3
(0112) 	Delay_nus(4);
    03E02 E004      LDI	R16,4
    03E03 E010      LDI	R17,0
    03E04 DF13      RCALL	_Delay_nus
(0113) 	k=IN_DQ;    	//读数据,从低位开始
    03E05 9110 0502 LDS	R17,T_NUM
    03E07 E001      LDI	R16,1
    03E08 940E 419F CALL	lsl8
    03E0A 90A0 0063 LDS	R10,0x63
    03E0C 22A0      AND	R10,R16
(0114) 	Delay_nus(10);
    03E0D E00A      LDI	R16,0xA
    03E0E E010      LDI	R17,0
    03E0F DF08      RCALL	_Delay_nus
(0115) 	SET_DQ;	
    03E10 9110 0502 LDS	R17,T_NUM
    03E12 E001      LDI	R16,1
    03E13 940E 419F CALL	lsl8
    03E15 9020 0065 LDS	R2,0x65
    03E17 2A20      OR	R2,R16
    03E18 9220 0065 STS	0x65,R2
(0116) 				NOP();
    03E1A 0000      NOP
(0117) 				NOP();
    03E1B 0000      NOP
(0118) 	SET_OUT;
    03E1C 9110 0502 LDS	R17,T_NUM
    03E1E E001      LDI	R16,1
    03E1F 940E 419F CALL	lsl8
    03E21 9020 0064 LDS	R2,0x64
    03E23 2A20      OR	R2,R16
    03E24 9220 0064 STS	0x64,R2
(0119) 	    NOP();
    03E26 0000      NOP
(0120) 					NOP();
    03E27 0000      NOP
(0121) 	if(k){
    03E28 20AA      TST	R10
    03E29 F011      BEQ	0x3E2C
(0122) 	    return 1;
    03E2A E001      LDI	R16,1
    03E2B C001      RJMP	0x3E2D
(0123) 	}else{
(0124) 	    return 0;
    03E2C 2700      CLR	R16
    03E2D 90A9      LD	R10,Y+
    03E2E 9508      RET
_write_byte_18B20:
  i                    --> R20
  data                 --> R10
    03E2F 92AA      ST	-Y,R10
    03E30 934A      ST	-Y,R20
    03E31 2EA0      MOV	R10,R16
(0125) 	}
(0126) 	
(0127) }
(0128) 
(0129) //------------------------------------------------------------------------------
(0130) // 写一个字节到总线
(0131) //------------------------------------------------------------------------------
(0132) void write_byte_18B20(unsigned char data)
(0133) {
(0134) 	unsigned char i;
(0135)    CLI();
    03E32 94F8      BCLR	7
(0136)     for(i=0;i<8;i++)
    03E33 2744      CLR	R20
    03E34 C009      RJMP	0x3E3E
(0137)     {
(0138)         write_bit_18B20(data&(1<<i));
    03E35 E001      LDI	R16,1
    03E36 2F14      MOV	R17,R20
    03E37 940E 419F CALL	lsl8
    03E39 2E20      MOV	R2,R16
    03E3A 2D0A      MOV	R16,R10
    03E3B 2102      AND	R16,R2
    03E3C DF57      RCALL	_write_bit_18B20
    03E3D 9543      INC	R20
    03E3E 3048      CPI	R20,0x8
    03E3F F3A8      BCS	0x3E35
(0139)         
(0140)     }
(0141)     SET_DQ;
    03E40 9110 0502 LDS	R17,T_NUM
    03E42 E001      LDI	R16,1
    03E43 940E 419F CALL	lsl8
    03E45 9020 0065 LDS	R2,0x65
    03E47 2A20      OR	R2,R16
    03E48 9220 0065 STS	0x65,R2
(0142) 				  NOP();
    03E4A 0000      NOP
(0143) 					 NOP();
    03E4B 0000      NOP
(0144)     SEI();
    03E4C 9478      BSET	7
    03E4D 9149      LD	R20,Y+
    03E4E 90A9      LD	R10,Y+
    03E4F 9508      RET
_read_byte_18B20:
  temp                 --> R10
  n                    --> R20
    03E50 92AA      ST	-Y,R10
    03E51 934A      ST	-Y,R20
(0145)     
(0146)     //return;
(0147) }
(0148) 
(0149) //------------------------------------------------------------------------------
(0150) // 读一个字节
(0151) //------------------------------------------------------------------------------
(0152) unsigned char read_byte_18B20(void)
(0153) {
(0154) 	unsigned char temp,n;
(0155)     CLI();
    03E52 94F8      BCLR	7
(0156)   	temp=0;
    03E53 24AA      CLR	R10
(0157)     for(n=0;n<8;n++)
    03E54 2744      CLR	R20
    03E55 C014      RJMP	0x3E6A
(0158)     {
(0159)       	if(read_bit_18B20()){
    03E56 DF85      RCALL	_read_bit_18B20
    03E57 2300      TST	R16
    03E58 F031      BEQ	0x3E5F
(0160)       		temp|=(1<<n);
    03E59 E001      LDI	R16,1
    03E5A 2F14      MOV	R17,R20
    03E5B 940E 419F CALL	lsl8
    03E5D 2AA0      OR	R10,R16
(0161)       	}else{
    03E5E C007      RJMP	0x3E66
(0162)       		temp&=~(1<<n);
    03E5F E001      LDI	R16,1
    03E60 2F14      MOV	R17,R20
    03E61 940E 419F CALL	lsl8
    03E63 2E20      MOV	R2,R16
    03E64 9420      COM	R2
    03E65 20A2      AND	R10,R2
(0163)       	}
(0164)       	Delay_nus(70); //60~120us
    03E66 E406      LDI	R16,0x46
    03E67 E010      LDI	R17,0
    03E68 DEAF      RCALL	_Delay_nus
    03E69 9543      INC	R20
    03E6A 3048      CPI	R20,0x8
    03E6B F350      BCS	0x3E56
(0165)       	
(0166)    }
(0167)    SEI();
    03E6C 9478      BSET	7
(0168) 
(0169)    return temp;
    03E6D 2D0A      MOV	R16,R10
    03E6E 9149      LD	R20,Y+
    03E6F 90A9      LD	R10,Y+
    03E70 9508      RET
(0170) }
(0171) 
(0172) 
(0173) 
(0174) //------------------------------------------------------------------------------
(0175) // 应用函数部分！ 供外部调用
(0176) //------------------------------------------------------------------------------
(0177) //------------------------------------------------------------------------------
(0178) // 单器件/多器件：开始转换
(0179) //------------------------------------------------------------------------------
(0180) void convert_T(void)
(0181) {
(0182) 					if(reset_18B20()){
_convert_T:
    03E71 DEB6      RCALL	_reset_18B20
    03E72 2300      TST	R16
    03E73 F021      BEQ	0x3E78
(0183) 					write_byte_18B20(0xcc);
    03E74 EC0C      LDI	R16,0xCC
    03E75 DFB9      RCALL	_write_byte_18B20
(0184) 					write_byte_18B20(0x44);
    03E76 E404      LDI	R16,0x44
    03E77 DFB7      RCALL	_write_byte_18B20
(0185) 					}
    03E78 9508      RET
_read_T:
  sign                 --> Y,+1
  tmp                  --> Y,+0
  value                --> R10
    03E79 940E 4117 CALL	push_xgset003C
    03E7B 9724      SBIW	R28,4
(0186) }
(0187) 
(0188) //------------------------------------------------------------------------------
(0189) // 单器件：读温度，返回INIT8U型温度数据（原始数据）
(0190) //------------------------------------------------------------------------------
(0191) float read_T(void)
(0192) {
(0193)     unsigned int value=0;
    03E7C 24AA      CLR	R10
    03E7D 24BB      CLR	R11
(0194) 	unsigned char sign;
(0195) 	
(0196) 	float tmp;
(0197)     
(0198)     if(reset_18B20()){
    03E7E DEA9      RCALL	_reset_18B20
    03E7F 2300      TST	R16
    03E80 F021      BEQ	0x3E85
(0199)     	write_byte_18B20(0xcc);
    03E81 EC0C      LDI	R16,0xCC
    03E82 DFAC      RCALL	_write_byte_18B20
(0200)     	write_byte_18B20(0xbe);
    03E83 EB0E      LDI	R16,0xBE
    03E84 DFAA      RCALL	_write_byte_18B20
(0201)     }
(0202)     
(0203)     value = (unsigned int)read_byte_18B20();
    03E85 DFCA      RCALL	_read_byte_18B20
    03E86 2EA0      MOV	R10,R16
    03E87 24BB      CLR	R11
(0204)     value += ((unsigned int)(read_byte_18B20()))<<8;
    03E88 DFC7      RCALL	_read_byte_18B20
    03E89 2EC0      MOV	R12,R16
    03E8A 2C2C      MOV	R2,R12
    03E8B 2433      CLR	R3
    03E8C 2C32      MOV	R3,R2
    03E8D 2422      CLR	R2
    03E8E 0CA2      ADD	R10,R2
    03E8F 1CB3      ADC	R11,R3
(0205) 	/*   if((value&0x8000)==0x8000) //负温度
(0206) 					{
(0207) 					 sign=0;
(0208) 					 data=(~data)+1;       //补码形式，取反加一
(0209) 					}
(0210) 		elae 
(0211) 					{
(0212) 					 sign=1;
(0213) 					}
(0214) 		 xiaoshu1=(unsigned char) ((data&0x000f)*10/16);
(0215) 		 zhengshu=(unsigned char) (data>>4); 
(0216) 		*/
(0217) 	tmp= ((float)value)*0.0625;
    03E90 EC08      LDI	R16,0xC8
    03E91 E010      LDI	R17,0
    03E92 940E 4099 CALL	elpm32
    03E94 0118      MOVW	R2,R16
    03E95 0129      MOVW	R4,R18
    03E96 0185      MOVW	R16,R10
    03E97 940E 426B CALL	uint2fp
    03E99 933A      ST	-Y,R19
    03E9A 932A      ST	-Y,R18
    03E9B 931A      ST	-Y,R17
    03E9C 930A      ST	-Y,R16
    03E9D 0181      MOVW	R16,R2
    03E9E 0192      MOVW	R18,R4
    03E9F 940E 4412 CALL	fpmule2
    03EA1 8308      ST	Y,R16
    03EA2 8319      STD	Y+1,R17
    03EA3 832A      STD	Y+2,R18
    03EA4 833B      STD	Y+3,R19
(0218) 	
(0219)     return( tmp);
    03EA5 8108      LD	R16,Y
    03EA6 8119      LDD	R17,Y+1
    03EA7 812A      LDD	R18,Y+2
    03EA8 813B      LDD	R19,Y+3
    03EA9 9624      ADIW	R28,4
    03EAA 940C 40F1 JMP	pop_xgset003C
_read_T_NUM:
  ttemp                --> Y,+0
  NUM                  --> R10
    03EAC 92AA      ST	-Y,R10
    03EAD 2EA0      MOV	R10,R16
    03EAE 9724      SBIW	R28,4
(0220) }
(0221) 
(0222) float read_T_NUM(unsigned char NUM){
(0223) float ttemp;
(0224) if ( NUM >1) return 123.45;
    03EAF E081      LDI	R24,1
    03EB0 158A      CP	R24,R10
    03EB1 F428      BCC	0x3EB7
    03EB2 EC04      LDI	R16,0xC4
    03EB3 E010      LDI	R17,0
    03EB4 940E 4099 CALL	elpm32
    03EB6 C010      RJMP	0x3EC7
(0225) T_NUM=NUM;//设置访问器件
    03EB7 92A0 0502 STS	T_NUM,R10
(0226) convert_T();//温度转换
    03EB9 DFB7      RCALL	_convert_T
(0227) delayms(800);
    03EBA E200      LDI	R16,0x20
    03EBB E013      LDI	R17,3
    03EBC 940E 240B CALL	_delayms
(0228) ttemp=read_T();
    03EBE DFBA      RCALL	_read_T
    03EBF 8308      ST	Y,R16
    03EC0 8319      STD	Y+1,R17
    03EC1 832A      STD	Y+2,R18
    03EC2 833B      STD	Y+3,R19
(0229) return ttemp;
    03EC3 8108      LD	R16,Y
    03EC4 8119      LDD	R17,Y+1
    03EC5 812A      LDD	R18,Y+2
    03EC6 813B      LDD	R19,Y+3
    03EC7 9624      ADIW	R28,4
    03EC8 90A9      LD	R10,Y+
    03EC9 9508      RET
FILE: D:\LQD\software\master\software_src\ds1302.c
(0001) #include "config.h"
(0002) 
(0003) #define TPORT PORTB
(0004) #define TDDR DDRB
(0005) #define TPIN PINB
(0006) #define PIN_RST	 4
(0007) #define PIN_IO	 5
(0008) #define PIN_SCK	 6
(0009) /******************复位脚*********************/
(0010) #define RST_CLR	TPORT &= ~(1 << PIN_RST)   /*电平置低*/
(0011) #define RST_SET	TPORT |= (1 << PIN_RST)    /*电平置高*/
(0012) #define RST_IN	TDDR &= ~(1 << PIN_RST)    /*方向输入*/
(0013) #define RST_OUT	TDDR |= (1 << PIN_RST)     /*方向输出*/
(0014) 
(0015) /*****************双向数据********************/
(0016) #define IO_CLR	TPORT &= ~(1 << PIN_IO)  /*电平置低*/
(0017) #define IO_SET	TPORT |= (1 << PIN_IO)   /*电平置高*/
(0018) #define IO_R	TPIN & (1 << PIN_IO)     /*电平读取*/
(0019) #define IO_IN	TDDR &= ~(1 << PIN_IO)   /*方向输入*/
(0020) #define IO_OUT	TDDR |= (1 << PIN_IO)    /*方向输出*/
(0021) 
(0022) /*****************时钟信号*******************/
(0023) #define SCK_CLR	TPORT &= ~(1 << PIN_SCK)  /*时钟信号*/
(0024) #define SCK_SET	TPORT |= (1 << PIN_SCK)   /*电平置高*/
(0025) #define SCK_IN	TDDR &= ~(1 << PIN_SCK)   /*方向输入*/
(0026) #define SCK_OUT	TDDR |= (1 << PIN_SCK)    /*方向输出*/
(0027) 
(0028) #define ds1302_sec_add			0x80		//秒数据地址
(0029) #define ds1302_min_add			0x82		//分数据地址
(0030) #define ds1302_hr_add			0x84		//时数据地址
(0031) #define ds1302_date_add			0x86		//日数据地址
(0032) #define ds1302_month_add		0x88		//月数据地址
(0033) #define ds1302_day_add			0x8a		//星期数据地址
(0034) #define ds1302_year_add			0x8c		//年数据地址
(0035) #define ds1302_control_add		0x8e		//控制数据地址
(0036) #define ds1302_charger_add		0x90 					 
(0037) #define ds1302_clkburst_add		0xbe
(0038) 
(0039) unsigned char time_buf[8] = {0x20,0x0c,0x0A,0x1c,0x22,0x46,0x00,0x06};
(0040) /*
(0041)  struct tm {
(0042)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0043)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0044) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0045) 	int tm_mday;  // 日 day of the month, 1 to 31
(0046) 	int tm_mon;   // 月 months since January, 0 to 11
(0047) 	int tm_year;  // 年 years since 1900
(0048) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0049) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0050)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0051)  	};	
(0052) 	*/
(0053) 
(0054) //DS1302初始化函数
(0055) void ds1302_init(void) 
(0056) {
(0057) 	RST_CLR;			/*RST脚置低*/
_ds1302_init:
    03ECA 98C4      CBI	0x18,4
(0058) 	SCK_CLR;			/*SCK脚置低*/
    03ECB 98C6      CBI	0x18,6
(0059) 	RST_OUT;			/*RST脚设置为输出*/
    03ECC 9ABC      SBI	0x17,4
(0060) 	SCK_OUT;			/*SCK脚设置为输出*/
    03ECD 9ABE      SBI	0x17,6
    03ECE 9508      RET
_ds1302_write_byte:
  i                    --> R20
  d                    --> R18
  addr                 --> R16
    03ECF 934A      ST	-Y,R20
(0061) }
(0062) 
(0063) //向DS1302写入一字节数据
(0064) void ds1302_write_byte(unsigned char addr, unsigned char d) {
(0065) 
(0066) 	unsigned char i;
(0067) 	RST_SET;					/*启动DS1302总线*/
    03ED0 9AC4      SBI	0x18,4
(0068) 	
(0069) 	/*写入目标地址：addr*/
(0070) 	IO_OUT;
    03ED1 9ABD      SBI	0x17,5
(0071) 	addr = addr & 0xFE;   //最低位置零，寄存器0位为0时写，为1时读
    03ED2 7F0E      ANDI	R16,0xFE
(0072) 	for (i = 0; i < 8; i ++) {
    03ED3 2744      CLR	R20
    03ED4 C009      RJMP	0x3EDE
(0073) 		if (addr & 0x01) {
    03ED5 FF00      SBRS	R16,0
    03ED6 C002      RJMP	0x3ED9
(0074) 			IO_SET;
    03ED7 9AC5      SBI	0x18,5
(0075) 			}
    03ED8 C001      RJMP	0x3EDA
(0076) 		else {
(0077) 			IO_CLR;
    03ED9 98C5      CBI	0x18,5
(0078) 			}
(0079) 		SCK_SET;      //产生时钟
    03EDA 9AC6      SBI	0x18,6
(0080) 		SCK_CLR;
    03EDB 98C6      CBI	0x18,6
(0081) 		addr = addr >> 1;
    03EDC 9506      LSR	R16
    03EDD 9543      INC	R20
    03EDE 3048      CPI	R20,0x8
    03EDF F3A8      BCS	0x3ED5
(0082) 		}
(0083) 	
(0084) 	/*写入数据：d*/
(0085) 	IO_OUT;
    03EE0 9ABD      SBI	0x17,5
(0086) 	for (i = 0; i < 8; i ++) {
    03EE1 2744      CLR	R20
    03EE2 C009      RJMP	0x3EEC
(0087) 		if (d & 0x01) {
    03EE3 FF20      SBRS	R18,0
    03EE4 C002      RJMP	0x3EE7
(0088) 			IO_SET;
    03EE5 9AC5      SBI	0x18,5
(0089) 			}
    03EE6 C001      RJMP	0x3EE8
(0090) 		else {
(0091) 			IO_CLR;
    03EE7 98C5      CBI	0x18,5
(0092) 			}
(0093) 		SCK_SET;    //产生时钟
    03EE8 9AC6      SBI	0x18,6
(0094) 		SCK_CLR;
    03EE9 98C6      CBI	0x18,6
(0095) 		d = d >> 1;
    03EEA 9526      LSR	R18
    03EEB 9543      INC	R20
    03EEC 3048      CPI	R20,0x8
    03EED F3A8      BCS	0x3EE3
(0096) 		}
(0097) 	RST_CLR;		//停止DS1302总线
    03EEE 98C4      CBI	0x18,4
    03EEF 9149      LD	R20,Y+
    03EF0 9508      RET
_ds1302_read_byte:
  temp                 --> R20
  i                    --> R22
  addr                 --> R16
    03EF1 934A      ST	-Y,R20
    03EF2 936A      ST	-Y,R22
(0098) 	
(0099) }
(0100) 
(0101) //从DS1302读出一字节数据
(0102) unsigned char ds1302_read_byte(unsigned char addr) {
(0103) 
(0104) 	unsigned char i;
(0105) 	unsigned char temp;
(0106) 	RST_SET;					/*启动DS1302总线*/
    03EF3 9AC4      SBI	0x18,4
(0107) 
(0108) 	/*写入目标地址：addr*/
(0109) 	IO_OUT;
    03EF4 9ABD      SBI	0x17,5
(0110) 	addr = addr | 0x01;    //最低位置高，寄存器0位为0时写，为1时读
    03EF5 6001      ORI	R16,1
(0111) 	for (i = 0; i < 8; i ++) {
    03EF6 2766      CLR	R22
    03EF7 C009      RJMP	0x3F01
(0112) 		if (addr & 0x01) {
    03EF8 FF00      SBRS	R16,0
    03EF9 C002      RJMP	0x3EFC
(0113) 			IO_SET;
    03EFA 9AC5      SBI	0x18,5
(0114) 			}
    03EFB C001      RJMP	0x3EFD
(0115) 		else {
(0116) 			IO_CLR;
    03EFC 98C5      CBI	0x18,5
(0117) 			}
(0118) 		SCK_SET;
    03EFD 9AC6      SBI	0x18,6
(0119) 		SCK_CLR;
    03EFE 98C6      CBI	0x18,6
(0120) 		addr = addr >> 1;
    03EFF 9506      LSR	R16
    03F00 9563      INC	R22
    03F01 3068      CPI	R22,0x8
    03F02 F3A8      BCS	0x3EF8
(0121) 		}
(0122) 	
(0123) 	/*输出数据：temp*/
(0124) 	IO_IN;
    03F03 98BD      CBI	0x17,5
(0125) 	for (i = 0; i < 8; i ++) {
    03F04 2766      CLR	R22
    03F05 C009      RJMP	0x3F0F
(0126) 		temp = temp >> 1;
    03F06 9546      LSR	R20
(0127) 		if (IO_R) {
    03F07 9BB5      SBIS	0x16,5
    03F08 C002      RJMP	0x3F0B
(0128) 			temp |= 0x80;
    03F09 6840      ORI	R20,0x80
(0129) 			}
    03F0A C001      RJMP	0x3F0C
(0130) 		else {
(0131) 			temp &= 0x7F;
    03F0B 774F      ANDI	R20,0x7F
(0132) 			}
(0133) 		SCK_SET;
    03F0C 9AC6      SBI	0x18,6
(0134) 		SCK_CLR;
    03F0D 98C6      CBI	0x18,6
    03F0E 9563      INC	R22
    03F0F 3068      CPI	R22,0x8
    03F10 F3A8      BCS	0x3F06
(0135) 		}
(0136) 	
(0137) 	RST_CLR;					/*停止DS1302总线*/
    03F11 98C4      CBI	0x18,4
(0138) 	return temp;
    03F12 2F04      MOV	R16,R20
    03F13 9169      LD	R22,Y+
    03F14 9149      LD	R20,Y+
    03F15 9508      RET
(0139) }
(0140) 
(0141) //向DS302写入时钟数据
(0142) void ds1302_write_time(void) {
(0143) 
(0144) 	ds1302_write_byte(ds1302_control_add,0x00);			//关闭写保护 
_ds1302_write_time:
    03F16 2722      CLR	R18
    03F17 E80E      LDI	R16,0x8E
    03F18 DFB6      RCALL	_ds1302_write_byte
(0145) 	ds1302_write_byte(ds1302_sec_add,0x80);				//暂停时钟 
    03F19 E820      LDI	R18,0x80
    03F1A E800      LDI	R16,0x80
    03F1B DFB3      RCALL	_ds1302_write_byte
(0146) 	//ds1302_write_byte(ds1302_charger_add,0xa9);	    //涓流充电 
(0147) 	ds1302_write_byte(ds1302_year_add,time_buf[1]);		//年 
    03F1C 9120 0504 LDS	R18,time_buf+1
    03F1E E80C      LDI	R16,0x8C
    03F1F DFAF      RCALL	_ds1302_write_byte
(0148) 	ds1302_write_byte(ds1302_month_add,time_buf[2]);	//月 
    03F20 9120 0505 LDS	R18,time_buf+2
    03F22 E808      LDI	R16,0x88
    03F23 DFAB      RCALL	_ds1302_write_byte
(0149) 	ds1302_write_byte(ds1302_date_add,time_buf[3]);		//日 
    03F24 9120 0506 LDS	R18,time_buf+3
    03F26 E806      LDI	R16,0x86
    03F27 DFA7      RCALL	_ds1302_write_byte
(0150) 	ds1302_write_byte(ds1302_hr_add,time_buf[4]);		//时 
    03F28 9120 0507 LDS	R18,time_buf+4
    03F2A E804      LDI	R16,0x84
    03F2B DFA3      RCALL	_ds1302_write_byte
(0151) 	ds1302_write_byte(ds1302_min_add,time_buf[5]);		//分
    03F2C 9120 0508 LDS	R18,time_buf+5
    03F2E E802      LDI	R16,0x82
    03F2F DF9F      RCALL	_ds1302_write_byte
(0152) 	ds1302_write_byte(ds1302_sec_add,time_buf[6]);		//秒
    03F30 9120 0509 LDS	R18,time_buf+6
    03F32 E800      LDI	R16,0x80
    03F33 DF9B      RCALL	_ds1302_write_byte
(0153) 	ds1302_write_byte(ds1302_day_add,time_buf[7]);		//周 
    03F34 9120 050A LDS	R18,time_buf+7
    03F36 E80A      LDI	R16,0x8A
    03F37 DF97      RCALL	_ds1302_write_byte
(0154) 	ds1302_write_byte(ds1302_control_add,0x80);			//打开写保护 
    03F38 E820      LDI	R18,0x80
    03F39 E80E      LDI	R16,0x8E
    03F3A CF94      RJMP	_ds1302_write_byte
_ds1302_read_time:
    03F3B 92AA      ST	-Y,R10
    03F3C 934A      ST	-Y,R20
(0155) }
(0156) 
(0157) //从DS302读出时钟数据
(0158) void ds1302_read_time(void)  { 
(0159) 	time_buf[1]=ds1302_read_byte(ds1302_year_add);		//年 
    03F3D E80C      LDI	R16,0x8C
    03F3E DFB2      RCALL	_ds1302_read_byte
    03F3F 9300 0504 STS	time_buf+1,R16
(0160) 	time_buf[2]=ds1302_read_byte(ds1302_month_add);		//月 
    03F41 E808      LDI	R16,0x88
    03F42 DFAE      RCALL	_ds1302_read_byte
    03F43 9300 0505 STS	time_buf+2,R16
(0161) 	time_buf[3]=ds1302_read_byte(ds1302_date_add);		//日 
    03F45 E806      LDI	R16,0x86
    03F46 DFAA      RCALL	_ds1302_read_byte
    03F47 2EA0      MOV	R10,R16
    03F48 92A0 0506 STS	time_buf+3,R10
(0162) 	time_buf[4]=ds1302_read_byte(ds1302_hr_add);		//时 
    03F4A E804      LDI	R16,0x84
    03F4B DFA5      RCALL	_ds1302_read_byte
    03F4C 2EA0      MOV	R10,R16
    03F4D 92A0 0507 STS	time_buf+4,R10
(0163) 	time_buf[5]=ds1302_read_byte(ds1302_min_add);		//分 
    03F4F E802      LDI	R16,0x82
    03F50 DFA0      RCALL	_ds1302_read_byte
    03F51 2EA0      MOV	R10,R16
    03F52 92A0 0508 STS	time_buf+5,R10
(0164) 	time_buf[6]=(ds1302_read_byte(ds1302_sec_add))&0x7F;//秒，屏蔽秒的第7位，避免超出59
    03F54 E800      LDI	R16,0x80
    03F55 DF9B      RCALL	_ds1302_read_byte
    03F56 2F40      MOV	R20,R16
    03F57 2F84      MOV	R24,R20
    03F58 778F      ANDI	R24,0x7F
    03F59 9380 0509 STS	time_buf+6,R24
(0165) 	time_buf[7]=ds1302_read_byte(ds1302_day_add);		//周 
    03F5B E80A      LDI	R16,0x8A
    03F5C DF94      RCALL	_ds1302_read_byte
    03F5D 2EA0      MOV	R10,R16
    03F5E 92A0 050A STS	time_buf+7,R10
    03F60 9149      LD	R20,Y+
    03F61 90A9      LD	R10,Y+
    03F62 9508      RET
_kbscan:
  key                  --> R20
  temp                 --> Y,+0
    03F63 934A      ST	-Y,R20
    03F64 9724      SBIW	R28,4
FILE: D:\LQD\software\master\software_src\key.c
(0001) #include "config.h"
(0002) //键盘扫描函数
(0003) unsigned char kbscan(void)
(0004)   {
(0005)    unsigned char key;
(0006)    unsigned long temp=0;
    03F65 E080      LDI	R24,0
    03F66 8388      ST	Y,R24
    03F67 8389      STD	Y+1,R24
    03F68 838A      STD	Y+2,R24
    03F69 838B      STD	Y+3,R24
(0007)    DDR_SET;
    03F6A B38A      IN	R24,0x1A
    03F6B 7087      ANDI	R24,7
    03F6C BB8A      OUT	0x1A,R24
(0008)    
(0009)    if((KEY_PIN) != KEY_MASK)         //检测A口按键引脚电平，如果全是高电平则退出
    03F6D B389      IN	R24,0x19
    03F6E 718F      ANDI	R24,0x1F
    03F6F 318F      CPI	R24,0x1F
    03F70 F189      BEQ	0x3FA2
(0010)     {
(0011)      delayms(20);           //防抖
    03F71 E104      LDI	R16,0x14
    03F72 E010      LDI	R17,0
    03F73 940E 240B CALL	_delayms
(0012)      if((KEY_PIN) != KEY_MASK )      //再次检测A口电平，如果不全是高电平则继续执行程序
    03F75 B389      IN	R24,0x19
    03F76 718F      ANDI	R24,0x1F
    03F77 318F      CPI	R24,0x1F
    03F78 F159      BEQ	0x3FA4
(0013)       {
(0014)        key = KEY_PIN ;          //读取PINA，将其存放在key中
    03F79 B349      IN	R20,0x19
    03F7A 714F      ANDI	R20,0x1F
    03F7B C020      RJMP	0x3F9C
(0015)         while((KEY_PIN) != KEY_MASK)
(0016) 		{
(0017) 		 temp++ ;
    03F7C E081      LDI	R24,1
    03F7D E090      LDI	R25,0
    03F7E E0A0      LDI	R26,0
    03F7F E0B0      LDI	R27,0
    03F80 8028      LD	R2,Y
    03F81 8039      LDD	R3,Y+1
    03F82 804A      LDD	R4,Y+2
    03F83 805B      LDD	R5,Y+3
    03F84 0E28      ADD	R2,R24
    03F85 1E39      ADC	R3,R25
    03F86 1E4A      ADC	R4,R26
    03F87 1E5B      ADC	R5,R27
    03F88 8228      ST	Y,R2
    03F89 8239      STD	Y+1,R3
    03F8A 824A      STD	Y+2,R4
    03F8B 825B      STD	Y+3,R5
(0018) 		 if(temp>LONGKEY) 
    03F8C E880      LDI	R24,0x80
    03F8D E398      LDI	R25,0x38
    03F8E E0A1      LDI	R26,1
    03F8F E0B0      LDI	R27,0
    03F90 8028      LD	R2,Y
    03F91 8039      LDD	R3,Y+1
    03F92 804A      LDD	R4,Y+2
    03F93 805B      LDD	R5,Y+3
    03F94 1582      CP	R24,R2
    03F95 0593      CPC	R25,R3
    03F96 05A4      CPC	R26,R4
    03F97 05B5      CPC	R27,R5
    03F98 F418      BCC	0x3F9C
(0019) 		 {  return key+0x80;  };
    03F99 2F04      MOV	R16,R20
    03F9A 5800      SUBI	R16,0x80
    03F9B C009      RJMP	0x3FA5
    03F9C B389      IN	R24,0x19
    03F9D 718F      ANDI	R24,0x1F
    03F9E 318F      CPI	R24,0x1F
    03F9F F6E1      BNE	0x3F7C
(0020) 		}
(0021) 		; //当前有按键处于按下状态，再按其他按键时程序维持当前状态 
(0022)       	
(0023) 		return key;
    03FA0 2F04      MOV	R16,R20
    03FA1 C003      RJMP	0x3FA5
(0024) 	  
(0025) 	  }
(0026)     }
(0027) 	else return NO_KEY;
    03FA2 2700      CLR	R16
    03FA3 C001      RJMP	0x3FA5
(0028) 	
(0029) 	return NO_KEY;
FILE: <library>
    03FA4 2700      CLR	R16
    03FA5 9624      ADIW	R28,4
    03FA6 9149      LD	R20,Y+
    03FA7 9508      RET
_memset:
    03FA8 8188      LD	R24,Y
    03FA9 8199      LDD	R25,Y+1
    03FAA 3080      CPI	R24,0
    03FAB 0789      CPC	R24,R25
    03FAC F029      BEQ	0x3FB2
    03FAD 2FE0      MOV	R30,R16
    03FAE 2FF1      MOV	R31,R17
    03FAF 9321      ST	Z+,R18
    03FB0 9701      SBIW	R24,1
    03FB1 F7E9      BNE	0x3FAF
    03FB2 9508      RET
_strcat:
    03FB3 2FA0      MOV	R26,R16
    03FB4 2FB1      MOV	R27,R17
    03FB5 2FE2      MOV	R30,R18
    03FB6 2FF3      MOV	R31,R19
    03FB7 912D      LD	R18,X+
    03FB8 2322      TST	R18
    03FB9 F7E9      BNE	0x3FB7
    03FBA 9711      SBIW	R26,1
    03FBB 9121      LD	R18,Z+
    03FBC 932D      ST	X+,R18
    03FBD 2322      TST	R18
    03FBE F7E1      BNE	0x3FBB
    03FBF 9508      RET
_strlen:
    03FC0 2FE0      MOV	R30,R16
    03FC1 2FF1      MOV	R31,R17
    03FC2 27AA      CLR	R26
    03FC3 27BB      CLR	R27
    03FC4 9001      LD	R0,Z+
    03FC5 2000      TST	R0
    03FC6 F011      BEQ	0x3FC9
    03FC7 9611      ADIW	R26,1
    03FC8 CFFB      RJMP	0x3FC4
    03FC9 2F0A      MOV	R16,R26
    03FCA 2F1B      MOV	R17,R27
    03FCB 9508      RET
push_arg4:
    03FCC 933A      ST	-Y,R19
    03FCD 932A      ST	-Y,R18
push_arg2:
    03FCE 931A      ST	-Y,R17
    03FCF 930A      ST	-Y,R16
    03FD0 9508      RET
asr32:
    03FD1 920F      PUSH	R0
    03FD2 9009      LD	R0,Y+
    03FD3 2000      TST	R0
    03FD4 F031      BEQ	0x3FDB
    03FD5 9535      ASR	R19
    03FD6 9527      ROR	R18
    03FD7 9517      ROR	R17
    03FD8 9507      ROR	R16
    03FD9 940A      DEC	R0
    03FDA CFF8      RJMP	0x3FD3
    03FDB 900F      POP	R0
    03FDC 9508      RET
mod16s:
    03FDD 9468      BSET	6
    03FDE 92DA      ST	-Y,R13
    03FDF 2ED1      MOV	R13,R17
    03FE0 C004      RJMP	0x3FE5
div16s:
    03FE1 94E8      BCLR	6
    03FE2 92DA      ST	-Y,R13
    03FE3 2ED1      MOV	R13,R17
    03FE4 26D3      EOR	R13,R19
    03FE5 FF17      SBRS	R17,7
    03FE6 C004      RJMP	0x3FEB
    03FE7 9510      COM	R17
    03FE8 9500      COM	R16
    03FE9 5F0F      SUBI	R16,0xFF
    03FEA 4F1F      SBCI	R17,0xFF
    03FEB FF37      SBRS	R19,7
    03FEC C004      RJMP	0x3FF1
    03FED 9530      COM	R19
    03FEE 9520      COM	R18
    03FEF 5F2F      SUBI	R18,0xFF
    03FF0 4F3F      SBCI	R19,0xFF
    03FF1 940E 3FFE CALL	xdiv16u
    03FF3 FED7      SBRS	R13,7
    03FF4 C004      RJMP	0x3FF9
    03FF5 9510      COM	R17
    03FF6 9500      COM	R16
    03FF7 5F0F      SUBI	R16,0xFF
    03FF8 4F1F      SBCI	R17,0xFF
    03FF9 90D9      LD	R13,Y+
    03FFA 9508      RET
mod16u:
    03FFB 9468      BSET	6
    03FFC C001      RJMP	xdiv16u
div16u:
    03FFD 94E8      BCLR	6
xdiv16u:
    03FFE 92EA      ST	-Y,R14
    03FFF 92FA      ST	-Y,R15
    04000 938A      ST	-Y,R24
    04001 24EE      CLR	R14
    04002 24FF      CLR	R15
    04003 E180      LDI	R24,0x10
    04004 0F00      LSL	R16
    04005 1F11      ROL	R17
    04006 1CEE      ROL	R14
    04007 1CFF      ROL	R15
    04008 16E2      CP	R14,R18
    04009 06F3      CPC	R15,R19
    0400A F018      BCS	0x400E
    0400B 1AE2      SUB	R14,R18
    0400C 0AF3      SBC	R15,R19
    0400D 9503      INC	R16
    0400E 958A      DEC	R24
    0400F F7A1      BNE	0x4004
    04010 F416      BRTC	0x4013
    04011 2D0E      MOV	R16,R14
    04012 2D1F      MOV	R17,R15
    04013 9189      LD	R24,Y+
    04014 90F9      LD	R15,Y+
    04015 90E9      LD	R14,Y+
    04016 9508      RET
div32u:
    04017 94E8      BCLR	6
    04018 C001      RJMP	0x401A
mod32u:
    04019 9468      BSET	6
    0401A D030      RCALL	long_div_prolog
    0401B 24CC      CLR	R12
    0401C C009      RJMP	0x4026
div32s:
    0401D 94E8      BCLR	6
    0401E C001      RJMP	0x4020
mod32s:
    0401F 9468      BSET	6
    04020 D02A      RCALL	long_div_prolog
    04021 FD37      SBRC	R19,7
    04022 940E 415E CALL	neg32
    04024 FDB7      SBRC	R27,7
    04025 D052      RCALL	neg_R24_R27
    04026 2477      CLR	R7
    04027 2488      CLR	R8
    04028 2499      CLR	R9
    04029 24AA      CLR	R10
    0402A 24BB      CLR	R11
    0402B D042      RCALL	tst_R16_R19
    0402C F0C1      BEQ	0x4045
    0402D D045      RCALL	tst_R24_R27
    0402E F0B1      BEQ	0x4045
    0402F E2E8      LDI	R30,0x28
    04030 0F00      LSL	R16
    04031 1F11      ROL	R17
    04032 1F22      ROL	R18
    04033 1F33      ROL	R19
    04034 1C77      ROL	R7
    04035 1C88      ROL	R8
    04036 1C99      ROL	R9
    04037 1CAA      ROL	R10
    04038 1CBB      ROL	R11
    04039 1688      CP	R8,R24
    0403A 0699      CPC	R9,R25
    0403B 06AA      CPC	R10,R26
    0403C 06BB      CPC	R11,R27
    0403D F028      BCS	0x4043
    0403E 1A88      SUB	R8,R24
    0403F 0A99      SBC	R9,R25
    04040 0AAA      SBC	R10,R26
    04041 0ABB      SBC	R11,R27
    04042 9503      INC	R16
    04043 95EA      DEC	R30
    04044 F759      BNE	0x4030
    04045 F426      BRTC	0x404A
    04046 2D08      MOV	R16,R8
    04047 2D19      MOV	R17,R9
    04048 2D2A      MOV	R18,R10
    04049 2D3B      MOV	R19,R11
    0404A C013      RJMP	long_div_epilog
long_div_prolog:
    0404B 927A      ST	-Y,R7
    0404C 928A      ST	-Y,R8
    0404D 929A      ST	-Y,R9
    0404E 92AA      ST	-Y,R10
    0404F 92BA      ST	-Y,R11
    04050 92CA      ST	-Y,R12
    04051 93EA      ST	-Y,R30
    04052 938A      ST	-Y,R24
    04053 939A      ST	-Y,R25
    04054 93AA      ST	-Y,R26
    04055 93BA      ST	-Y,R27
    04056 858B      LDD	R24,Y+11
    04057 859C      LDD	R25,Y+12
    04058 85AD      LDD	R26,Y+13
    04059 85BE      LDD	R27,Y+14
    0405A 2EC3      MOV	R12,R19
    0405B F00E      BRTS	0x405D
    0405C 26CB      EOR	R12,R27
    0405D 9508      RET
long_div_epilog:
    0405E FCC7      SBRC	R12,7
    0405F 940E 415E CALL	neg32
    04061 91B9      LD	R27,Y+
    04062 91A9      LD	R26,Y+
    04063 9199      LD	R25,Y+
    04064 9189      LD	R24,Y+
    04065 91E9      LD	R30,Y+
    04066 90C9      LD	R12,Y+
    04067 90B9      LD	R11,Y+
    04068 90A9      LD	R10,Y+
    04069 9099      LD	R9,Y+
    0406A 9089      LD	R8,Y+
    0406B 9079      LD	R7,Y+
    0406C 9624      ADIW	R28,4
    0406D 9508      RET
tst_R16_R19:
    0406E 2FE0      MOV	R30,R16
    0406F 2BE1      OR	R30,R17
    04070 2BE2      OR	R30,R18
    04071 2BE3      OR	R30,R19
    04072 9508      RET
tst_R24_R27:
    04073 2FE8      MOV	R30,R24
    04074 2BE9      OR	R30,R25
    04075 2BEA      OR	R30,R26
    04076 2BEB      OR	R30,R27
    04077 9508      RET
neg_R24_R27:
    04078 9580      COM	R24
    04079 9590      COM	R25
    0407A 95A0      COM	R26
    0407B 95B0      COM	R27
    0407C 5F8F      SUBI	R24,0xFF
    0407D 4F9F      SBCI	R25,0xFF
    0407E 4FAF      SBCI	R26,0xFF
    0407F 4FBF      SBCI	R27,0xFF
    04080 9508      RET
mod8u:
    04081 9468      BSET	6
    04082 C001      RJMP	xdiv8u
div8u:
    04083 94E8      BCLR	6
xdiv8u:
    04084 932A      ST	-Y,R18
    04085 92FA      ST	-Y,R15
    04086 92EA      ST	-Y,R14
    04087 24FF      CLR	R15
    04088 24EE      CLR	R14
    04089 E120      LDI	R18,0x10
    0408A 0F00      LSL	R16
    0408B 1CFF      ROL	R15
    0408C 1CEE      ROL	R14
    0408D 16E1      CP	R14,R17
    0408E F010      BCS	0x4091
    0408F 1AE1      SUB	R14,R17
    04090 9503      INC	R16
    04091 952A      DEC	R18
    04092 F7B9      BNE	0x408A
    04093 F40E      BRTC	0x4095
    04094 2D0E      MOV	R16,R14
    04095 90E9      LD	R14,Y+
    04096 90F9      LD	R15,Y+
    04097 9129      LD	R18,Y+
    04098 9508      RET
elpm32:
    04099 93EA      ST	-Y,R30
    0409A 93FA      ST	-Y,R31
    0409B 920A      ST	-Y,R0
    0409C 2FE0      MOV	R30,R16
    0409D 2FF1      MOV	R31,R17
    0409E 95D8      ELPM
    0409F 2D00      MOV	R16,R0
    040A0 9631      ADIW	R30,1
    040A1 95D8      ELPM
    040A2 2D10      MOV	R17,R0
    040A3 9631      ADIW	R30,1
    040A4 95D8      ELPM
    040A5 2D20      MOV	R18,R0
    040A6 9631      ADIW	R30,1
    040A7 95D8      ELPM
    040A8 2D30      MOV	R19,R0
    040A9 9009      LD	R0,Y+
    040AA 91F9      LD	R31,Y+
    040AB 91E9      LD	R30,Y+
    040AC 9508      RET
empy16s:
    040AD 920A      ST	-Y,R0
    040AE 921A      ST	-Y,R1
    040AF 938A      ST	-Y,R24
    040B0 939A      ST	-Y,R25
    040B1 9F02      MUL	R16,R18
    040B2 01C0      MOVW	R24,R0
    040B3 9F12      MUL	R17,R18
    040B4 0D90      ADD	R25,R0
    040B5 9F03      MUL	R16,R19
    040B6 0D90      ADD	R25,R0
    040B7 018C      MOVW	R16,R24
    040B8 9199      LD	R25,Y+
    040B9 9189      LD	R24,Y+
    040BA 9019      LD	R1,Y+
    040BB 9009      LD	R0,Y+
    040BC 9508      RET
empy32u|empy32s:
    040BD 940E 4167 CALL	long_prolog
    040BF 927A      ST	-Y,R7
    040C0 940E 4180 CALL	tstzero1
    040C2 F159      BEQ	0x40EE
    040C3 2477      CLR	R7
    040C4 940E 4186 CALL	tstzero2
    040C6 F419      BNE	0x40CA
    040C7 018C      MOVW	R16,R24
    040C8 019D      MOVW	R18,R26
    040C9 C024      RJMP	0x40EE
    040CA 920A      ST	-Y,R0
    040CB 921A      ST	-Y,R1
    040CC 9F08      MUL	R16,R24
    040CD 2CB0      MOV	R11,R0
    040CE 2CA1      MOV	R10,R1
    040CF 9F28      MUL	R18,R24
    040D0 2C90      MOV	R9,R0
    040D1 2C81      MOV	R8,R1
    040D2 9F18      MUL	R17,R24
    040D3 0CA0      ADD	R10,R0
    040D4 1C91      ADC	R9,R1
    040D5 1C87      ADC	R8,R7
    040D6 9F09      MUL	R16,R25
    040D7 0CA0      ADD	R10,R0
    040D8 1C91      ADC	R9,R1
    040D9 1C87      ADC	R8,R7
    040DA 9F19      MUL	R17,R25
    040DB 0C90      ADD	R9,R0
    040DC 1C81      ADC	R8,R1
    040DD 9F0A      MUL	R16,R26
    040DE 0C90      ADD	R9,R0
    040DF 1C81      ADC	R8,R1
    040E0 9F38      MUL	R19,R24
    040E1 0C80      ADD	R8,R0
    040E2 9F29      MUL	R18,R25
    040E3 0C80      ADD	R8,R0
    040E4 9F1A      MUL	R17,R26
    040E5 0C80      ADD	R8,R0
    040E6 9F0B      MUL	R16,R27
    040E7 0C80      ADD	R8,R0
    040E8 9019      LD	R1,Y+
    040E9 9009      LD	R0,Y+
    040EA 2D0B      MOV	R16,R11
    040EB 2D1A      MOV	R17,R10
    040EC 2D29      MOV	R18,R9
    040ED 2D38      MOV	R19,R8
    040EE 9079      LD	R7,Y+
    040EF 940C 4175 JMP	long_epilog
pop_xgset003C:
    040F1 90A9      LD	R10,Y+
    040F2 90B9      LD	R11,Y+
    040F3 90C9      LD	R12,Y+
    040F4 90D9      LD	R13,Y+
    040F5 9508      RET
pop_xgset00FC:
    040F6 90A9      LD	R10,Y+
    040F7 90B9      LD	R11,Y+
    040F8 90C9      LD	R12,Y+
    040F9 90D9      LD	R13,Y+
    040FA 90E9      LD	R14,Y+
    040FB 90F9      LD	R15,Y+
    040FC 9508      RET
pop_xgset30FC:
    040FD 90A9      LD	R10,Y+
    040FE 90B9      LD	R11,Y+
    040FF 90C9      LD	R12,Y+
    04100 90D9      LD	R13,Y+
    04101 90E9      LD	R14,Y+
    04102 90F9      LD	R15,Y+
    04103 9149      LD	R20,Y+
    04104 9159      LD	R21,Y+
    04105 9508      RET
pop_xgsetF0FC:
    04106 90A9      LD	R10,Y+
    04107 90B9      LD	R11,Y+
    04108 90C9      LD	R12,Y+
    04109 90D9      LD	R13,Y+
    0410A 90E9      LD	R14,Y+
    0410B 90F9      LD	R15,Y+
    0410C 9149      LD	R20,Y+
    0410D 9159      LD	R21,Y+
    0410E 9169      LD	R22,Y+
    0410F 9179      LD	R23,Y+
    04110 9508      RET
push_xgsetF0FC:
    04111 937A      ST	-Y,R23
    04112 936A      ST	-Y,R22
push_xgset30FC:
    04113 935A      ST	-Y,R21
    04114 934A      ST	-Y,R20
push_xgset00FC:
    04115 92FA      ST	-Y,R15
    04116 92EA      ST	-Y,R14
push_xgset003C:
    04117 92DA      ST	-Y,R13
    04118 92CA      ST	-Y,R12
    04119 92BA      ST	-Y,R11
    0411A 92AA      ST	-Y,R10
    0411B 9508      RET
push_xgset300C:
    0411C 935A      ST	-Y,R21
    0411D 934A      ST	-Y,R20
    0411E 92BA      ST	-Y,R11
    0411F 92AA      ST	-Y,R10
    04120 9508      RET
pop_xgset300C:
    04121 90A9      LD	R10,Y+
    04122 90B9      LD	R11,Y+
    04123 9149      LD	R20,Y+
    04124 9159      LD	R21,Y+
    04125 9508      RET
push_xgsetF000:
    04126 937A      ST	-Y,R23
    04127 936A      ST	-Y,R22
    04128 935A      ST	-Y,R21
    04129 934A      ST	-Y,R20
    0412A 9508      RET
pop_xgsetF000:
    0412B 9149      LD	R20,Y+
    0412C 9159      LD	R21,Y+
    0412D 9169      LD	R22,Y+
    0412E 9179      LD	R23,Y+
    0412F 9508      RET
push_xgsetF00C:
    04130 937A      ST	-Y,R23
    04131 936A      ST	-Y,R22
    04132 935A      ST	-Y,R21
    04133 934A      ST	-Y,R20
    04134 92BA      ST	-Y,R11
    04135 92AA      ST	-Y,R10
    04136 9508      RET
pop_xgsetF00C:
    04137 90A9      LD	R10,Y+
    04138 90B9      LD	R11,Y+
    04139 9149      LD	R20,Y+
    0413A 9159      LD	R21,Y+
    0413B 9169      LD	R22,Y+
    0413C 9179      LD	R23,Y+
    0413D 9508      RET
push_xgset303C:
    0413E 935A      ST	-Y,R21
    0413F 934A      ST	-Y,R20
    04140 92DA      ST	-Y,R13
    04141 92CA      ST	-Y,R12
    04142 92BA      ST	-Y,R11
    04143 92AA      ST	-Y,R10
    04144 9508      RET
pop_xgset303C:
    04145 90A9      LD	R10,Y+
    04146 90B9      LD	R11,Y+
    04147 90C9      LD	R12,Y+
    04148 90D9      LD	R13,Y+
    04149 9149      LD	R20,Y+
    0414A 9159      LD	R21,Y+
    0414B 9508      RET
push_xgsetF03C:
    0414C 937A      ST	-Y,R23
    0414D 936A      ST	-Y,R22
    0414E 935A      ST	-Y,R21
    0414F 934A      ST	-Y,R20
    04150 92DA      ST	-Y,R13
    04151 92CA      ST	-Y,R12
    04152 92BA      ST	-Y,R11
    04153 92AA      ST	-Y,R10
    04154 9508      RET
pop_xgsetF03C:
    04155 90A9      LD	R10,Y+
    04156 90B9      LD	R11,Y+
    04157 90C9      LD	R12,Y+
    04158 90D9      LD	R13,Y+
    04159 9149      LD	R20,Y+
    0415A 9159      LD	R21,Y+
    0415B 9169      LD	R22,Y+
    0415C 9179      LD	R23,Y+
    0415D 9508      RET
neg32:
    0415E 9500      COM	R16
    0415F 9510      COM	R17
    04160 9520      COM	R18
    04161 9530      COM	R19
    04162 5F0F      SUBI	R16,0xFF
    04163 4F1F      SBCI	R17,0xFF
    04164 4F2F      SBCI	R18,0xFF
    04165 4F3F      SBCI	R19,0xFF
    04166 9508      RET
long_prolog:
    04167 928A      ST	-Y,R8
    04168 929A      ST	-Y,R9
    04169 92AA      ST	-Y,R10
    0416A 92BA      ST	-Y,R11
    0416B 93EA      ST	-Y,R30
    0416C 938A      ST	-Y,R24
    0416D 939A      ST	-Y,R25
    0416E 93AA      ST	-Y,R26
    0416F 93BA      ST	-Y,R27
    04170 8589      LDD	R24,Y+9
    04171 859A      LDD	R25,Y+10
    04172 85AB      LDD	R26,Y+11
    04173 85BC      LDD	R27,Y+12
    04174 9508      RET
long_epilog:
    04175 91B9      LD	R27,Y+
    04176 91A9      LD	R26,Y+
    04177 9199      LD	R25,Y+
    04178 9189      LD	R24,Y+
    04179 91E9      LD	R30,Y+
    0417A 90B9      LD	R11,Y+
    0417B 90A9      LD	R10,Y+
    0417C 9099      LD	R9,Y+
    0417D 9089      LD	R8,Y+
    0417E 9624      ADIW	R28,4
    0417F 9508      RET
tstzero1:
    04180 27EE      CLR	R30
    04181 2BE0      OR	R30,R16
    04182 2BE1      OR	R30,R17
    04183 2BE2      OR	R30,R18
    04184 2BE3      OR	R30,R19
    04185 9508      RET
tstzero2:
    04186 27EE      CLR	R30
    04187 2BE8      OR	R30,R24
    04188 2BE9      OR	R30,R25
    04189 2BEA      OR	R30,R26
    0418A 2BEB      OR	R30,R27
    0418B 9508      RET
lsl16:
    0418C 2322      TST	R18
    0418D F021      BEQ	0x4192
    0418E 0F00      LSL	R16
    0418F 1F11      ROL	R17
    04190 952A      DEC	R18
    04191 CFFA      RJMP	lsl16
    04192 9508      RET
lsl32:
    04193 920F      PUSH	R0
    04194 9009      LD	R0,Y+
    04195 2000      TST	R0
    04196 F031      BEQ	0x419D
    04197 0F00      LSL	R16
    04198 1F11      ROL	R17
    04199 1F22      ROL	R18
    0419A 1F33      ROL	R19
    0419B 940A      DEC	R0
    0419C CFF8      RJMP	0x4195
    0419D 900F      POP	R0
    0419E 9508      RET
lsl8:
    0419F 2311      TST	R17
    041A0 F019      BEQ	0x41A4
    041A1 0F00      LSL	R16
    041A2 951A      DEC	R17
    041A3 CFFB      RJMP	lsl8
    041A4 9508      RET
lsr16:
    041A5 2322      TST	R18
    041A6 F021      BEQ	0x41AB
    041A7 9516      LSR	R17
    041A8 9507      ROR	R16
    041A9 952A      DEC	R18
    041AA CFFA      RJMP	lsr16
    041AB 9508      RET
lsr32:
    041AC 920F      PUSH	R0
    041AD 9009      LD	R0,Y+
    041AE 2000      TST	R0
    041AF F031      BEQ	0x41B6
    041B0 9536      LSR	R19
    041B1 9527      ROR	R18
    041B2 9517      ROR	R17
    041B3 9507      ROR	R16
    041B4 940A      DEC	R0
    041B5 CFF8      RJMP	0x41AE
    041B6 900F      POP	R0
    041B7 9508      RET
asgnblk:
    041B8 93AA      ST	-Y,R26
    041B9 93BA      ST	-Y,R27
    041BA 93EA      ST	-Y,R30
    041BB 93FA      ST	-Y,R31
    041BC 920A      ST	-Y,R0
    041BD 81AF      LDD	R26,Y+7
    041BE 85B8      LDD	R27,Y+8
    041BF 81ED      LDD	R30,Y+5
    041C0 81FE      LDD	R31,Y+6
    041C1 3000      CPI	R16,0
    041C2 0701      CPC	R16,R17
    041C3 F029      BEQ	0x41C9
    041C4 9001      LD	R0,Z+
    041C5 920D      ST	X+,R0
    041C6 5001      SUBI	R16,1
    041C7 4010      SBCI	R17,0
    041C8 CFF8      RJMP	0x41C1
    041C9 9009      LD	R0,Y+
    041CA 91F9      LD	R31,Y+
    041CB 91E9      LD	R30,Y+
    041CC 91B9      LD	R27,Y+
    041CD 91A9      LD	R26,Y+
    041CE 9624      ADIW	R28,4
    041CF 9508      RET
fpsub:
    041D0 9468      BSET	6
    041D1 C001      RJMP	fpadd_alt
fpadd:
    041D2 94E8      BCLR	6
fpadd_alt:
    041D3 940E 4397 CALL	saveFPRegs
    041D5 940E 4329 CALL	unpacks
    041D7 F409      BNE	0x41D9
    041D8 C048      RJMP	0x4221
    041D9 2CE6      MOV	R14,R6
    041DA 2CD5      MOV	R13,R5
    041DB 2CC4      MOV	R12,R4
    041DC 2EB3      MOV	R11,R19
    041DD 2EA2      MOV	R10,R18
    041DE 2E91      MOV	R9,R17
    041DF 2E80      MOV	R8,R16
    041E0 8100      LD	R16,Z
    041E1 8111      LDD	R17,Z+1
    041E2 8122      LDD	R18,Z+2
    041E3 8133      LDD	R19,Z+3
    041E4 940E 4329 CALL	unpacks
    041E6 F409      BNE	0x41E8
    041E7 C044      RJMP	0x422C
    041E8 2D84      MOV	R24,R4
    041E9 2D95      MOV	R25,R5
    041EA 198C      SUB	R24,R12
    041EB 099D      SBC	R25,R13
    041EC F0B9      BEQ	0x4204
    041ED F472      BPL	0x41FC
    041EE 9590      COM	R25
    041EF 9580      COM	R24
    041F0 9601      ADIW	R24,1
    041F1 2C4C      MOV	R4,R12
    041F2 2C5D      MOV	R5,R13
    041F3 3188      CPI	R24,0x18
    041F4 F5B8      BCC	0x422C
    041F5 9535      ASR	R19
    041F6 9527      ROR	R18
    041F7 9517      ROR	R17
    041F8 9507      ROR	R16
    041F9 9701      SBIW	R24,1
    041FA F7D1      BNE	0x41F5
    041FB C008      RJMP	0x4204
    041FC 3188      CPI	R24,0x18
    041FD F518      BCC	0x4221
    041FE 94B5      ASR	R11
    041FF 94A7      ROR	R10
    04200 9497      ROR	R9
    04201 9487      ROR	R8
    04202 9701      SBIW	R24,1
    04203 F7D1      BNE	0x41FE
    04204 2466      CLR	R6
    04205 F02E      BRTS	0x420B
    04206 0D08      ADD	R16,R8
    04207 1D19      ADC	R17,R9
    04208 1D2A      ADC	R18,R10
    04209 1D3B      ADC	R19,R11
    0420A C009      RJMP	0x4214
    0420B 1A80      SUB	R8,R16
    0420C 0A91      SBC	R9,R17
    0420D 0AA2      SBC	R10,R18
    0420E 0AB3      SBC	R11,R19
    0420F 2D08      MOV	R16,R8
    04210 2D19      MOV	R17,R9
    04211 2D2A      MOV	R18,R10
    04212 2D3B      MOV	R19,R11
    04213 2333      TST	R19
    04214 F422      BPL	0x4219
    04215 940E 415E CALL	neg32
    04217 E880      LDI	R24,0x80
    04218 2E68      MOV	R6,R24
    04219 940E 4352 CALL	normalize_and_pack
    0421B C002      RJMP	0x421E
    0421C 940E 4387 CALL	pack
    0421E 940E 43A6 CALL	restoreFPRegs
    04220 9508      RET
    04221 8100      LD	R16,Z
    04222 8111      LDD	R17,Z+1
    04223 8122      LDD	R18,Z+2
    04224 8133      LDD	R19,Z+3
    04225 F7C6      BRTC	0x421E
    04226 940E 4331 CALL	tstR16_R19
    04228 F3A9      BEQ	0x421E
    04229 E880      LDI	R24,0x80
    0422A 2738      EOR	R19,R24
    0422B CFF2      RJMP	0x421E
    0422C 2D08      MOV	R16,R8
    0422D 2D19      MOV	R17,R9
    0422E 2D2A      MOV	R18,R10
    0422F 2D3B      MOV	R19,R11
    04230 2C4C      MOV	R4,R12
    04231 2C5D      MOV	R5,R13
    04232 2C6E      MOV	R6,R14
    04233 2333      TST	R19
    04234 F73A      BPL	0x421C
    04235 940E 415E CALL	neg32
    04237 E880      LDI	R24,0x80
    04238 2E68      MOV	R6,R24
    04239 CFE2      RJMP	0x421C
fpadd2:
    0423A 93FA      ST	-Y,R31
    0423B 93EA      ST	-Y,R30
    0423C 2FEC      MOV	R30,R28
    0423D 2FFD      MOV	R31,R29
    0423E 9632      ADIW	R30,2
    0423F 940E 41D2 CALL	fpadd
    04241 91E9      LD	R30,Y+
    04242 91F9      LD	R31,Y+
    04243 9624      ADIW	R28,4
    04244 9508      RET
fpsub2:
    04245 93FA      ST	-Y,R31
    04246 93EA      ST	-Y,R30
    04247 2FEC      MOV	R30,R28
    04248 2FFD      MOV	R31,R29
    04249 9632      ADIW	R30,2
    0424A 940E 41D0 CALL	fpsub
    0424C 91E9      LD	R30,Y+
    0424D 91F9      LD	R31,Y+
    0424E 9624      ADIW	R28,4
    0424F 9508      RET
fpsub1x:
    04250 93FA      ST	-Y,R31
    04251 93EA      ST	-Y,R30
    04252 81EA      LDD	R30,Y+2
    04253 81FB      LDD	R31,Y+3
    04254 940E 41D0 CALL	fpsub
    04256 91E9      LD	R30,Y+
    04257 91F9      LD	R31,Y+
    04258 8339      STD	Y+1,R19
    04259 8328      ST	Y,R18
    0425A 931A      ST	-Y,R17
    0425B 930A      ST	-Y,R16
    0425C 9508      RET
fpsub2x:
    0425D 93FA      ST	-Y,R31
    0425E 93EA      ST	-Y,R30
    0425F 2FEC      MOV	R30,R28
    04260 2FFD      MOV	R31,R29
    04261 9632      ADIW	R30,2
    04262 940E 41D0 CALL	fpsub
    04264 91E9      LD	R30,Y+
    04265 91F9      LD	R31,Y+
    04266 833B      STD	Y+3,R19
    04267 832A      STD	Y+2,R18
    04268 8319      STD	Y+1,R17
    04269 8308      ST	Y,R16
    0426A 9508      RET
uint2fp:
    0426B 9468      BSET	6
    0426C C001      RJMP	0x426E
int2fp:
    0426D 94E8      BCLR	6
    0426E 2722      CLR	R18
    0426F 2733      CLR	R19
    04270 F046      BRTS	0x4279
    04271 FD17      SBRC	R17,7
    04272 9520      COM	R18
    04273 FD17      SBRC	R17,7
    04274 9530      COM	R19
    04275 C003      RJMP	0x4279
ulong2fp:
    04276 9468      BSET	6
    04277 C001      RJMP	0x4279
long2fp:
    04278 94E8      BCLR	6
    04279 924A      ST	-Y,R4
    0427A 925A      ST	-Y,R5
    0427B 926A      ST	-Y,R6
    0427C 938A      ST	-Y,R24
    0427D E187      LDI	R24,0x17
    0427E 2E48      MOV	R4,R24
    0427F 2455      CLR	R5
    04280 2466      CLR	R6
    04281 F036      BRTS	0x4288
    04282 2333      TST	R19
    04283 F422      BPL	0x4288
    04284 940E 415E CALL	neg32
    04286 E880      LDI	R24,0x80
    04287 2E68      MOV	R6,R24
    04288 940E 4352 CALL	normalize_and_pack
    0428A 9189      LD	R24,Y+
    0428B 9069      LD	R6,Y+
    0428C 9059      LD	R5,Y+
    0428D 9049      LD	R4,Y+
    0428E 9508      RET
fpdiv1:
    0428F 93FA      ST	-Y,R31
    04290 93EA      ST	-Y,R30
    04291 81EA      LDD	R30,Y+2
    04292 81FB      LDD	R31,Y+3
    04293 D027      RCALL	0x42BB
    04294 91E9      LD	R30,Y+
    04295 91F9      LD	R31,Y+
    04296 9622      ADIW	R28,2
    04297 9508      RET
fpdiv2:
    04298 93FA      ST	-Y,R31
    04299 93EA      ST	-Y,R30
    0429A 2FEC      MOV	R30,R28
    0429B 2FFD      MOV	R31,R29
    0429C 9632      ADIW	R30,2
    0429D D01D      RCALL	0x42BB
    0429E 91E9      LD	R30,Y+
    0429F 91F9      LD	R31,Y+
    042A0 9624      ADIW	R28,4
    042A1 9508      RET
fpdiv1x:
    042A2 93FA      ST	-Y,R31
    042A3 93EA      ST	-Y,R30
    042A4 81EA      LDD	R30,Y+2
    042A5 81FB      LDD	R31,Y+3
    042A6 D014      RCALL	0x42BB
    042A7 91E9      LD	R30,Y+
    042A8 91F9      LD	R31,Y+
    042A9 8339      STD	Y+1,R19
    042AA 8328      ST	Y,R18
    042AB 931A      ST	-Y,R17
    042AC 930A      ST	-Y,R16
    042AD 9508      RET
fpdiv2x:
    042AE 93FA      ST	-Y,R31
    042AF 93EA      ST	-Y,R30
    042B0 2FEC      MOV	R30,R28
    042B1 2FFD      MOV	R31,R29
    042B2 9632      ADIW	R30,2
    042B3 D007      RCALL	0x42BB
    042B4 91E9      LD	R30,Y+
    042B5 91F9      LD	R31,Y+
    042B6 833B      STD	Y+3,R19
    042B7 832A      STD	Y+2,R18
    042B8 8319      STD	Y+1,R17
    042B9 8308      ST	Y,R16
    042BA 9508      RET
    042BB 920A      ST	-Y,R0
    042BC 921A      ST	-Y,R1
    042BD 922A      ST	-Y,R2
    042BE 923A      ST	-Y,R3
    042BF 940E 4397 CALL	saveFPRegs
    042C1 933A      ST	-Y,R19
    042C2 932A      ST	-Y,R18
    042C3 931A      ST	-Y,R17
    042C4 930A      ST	-Y,R16
    042C5 8100      LD	R16,Z
    042C6 8111      LDD	R17,Z+1
    042C7 8122      LDD	R18,Z+2
    042C8 8133      LDD	R19,Z+3
    042C9 940E 4339 CALL	unpacku
    042CB F409      BNE	0x42CD
    042CC C057      RJMP	0x4324
    042CD 2CE6      MOV	R14,R6
    042CE 2CD5      MOV	R13,R5
    042CF 2CC4      MOV	R12,R4
    042D0 2EB3      MOV	R11,R19
    042D1 2EA2      MOV	R10,R18
    042D2 2E91      MOV	R9,R17
    042D3 2E80      MOV	R8,R16
    042D4 9109      LD	R16,Y+
    042D5 9119      LD	R17,Y+
    042D6 9129      LD	R18,Y+
    042D7 9139      LD	R19,Y+
    042D8 940E 4339 CALL	unpacku
    042DA F1A1      BEQ	0x430F
    042DB 246E      EOR	R6,R14
    042DC 184C      SUB	R4,R12
    042DD 085D      SBC	R5,R13
    042DE E880      LDI	R24,0x80
    042DF 1648      CP	R4,R24
    042E0 0653      CPC	R5,R19
    042E1 F00C      BLT	0x42E3
    042E2 C033      RJMP	0x4316
    042E3 E881      LDI	R24,0x81
    042E4 1648      CP	R4,R24
    042E5 EF8F      LDI	R24,0xFF
    042E6 0658      CPC	R5,R24
    042E7 F40C      BGE	0x42E9
    042E8 C036      RJMP	0x431F
    042E9 E280      LDI	R24,0x20
    042EA 2433      CLR	R3
    042EB 2E23      MOV	R2,R19
    042EC 2E12      MOV	R1,R18
    042ED 2E01      MOV	R0,R17
    042EE 2F30      MOV	R19,R16
    042EF 2722      CLR	R18
    042F0 2711      CLR	R17
    042F1 2700      CLR	R16
    042F2 9426      LSR	R2
    042F3 9417      ROR	R1
    042F4 9407      ROR	R0
    042F5 9537      ROR	R19
    042F6 9527      ROR	R18
    042F7 0F00      LSL	R16
    042F8 1F11      ROL	R17
    042F9 1F22      ROL	R18
    042FA 1F33      ROL	R19
    042FB 1C00      ROL	R0
    042FC 1C11      ROL	R1
    042FD 1C22      ROL	R2
    042FE 1C33      ROL	R3
    042FF F028      BCS	0x4305
    04300 1808      SUB	R0,R8
    04301 0819      SBC	R1,R9
    04302 082A      SBC	R2,R10
    04303 083B      SBC	R3,R11
    04304 C004      RJMP	0x4309
    04305 0C08      ADD	R0,R8
    04306 1C19      ADC	R1,R9
    04307 1C2A      ADC	R2,R10
    04308 1C3B      ADC	R3,R11
    04309 F00A      BMI	0x430B
    0430A 6001      ORI	R16,1
    0430B 958A      DEC	R24
    0430C F751      BNE	0x42F7
    0430D 940E 4352 CALL	normalize_and_pack
    0430F 940E 43A6 CALL	restoreFPRegs
    04311 9039      LD	R3,Y+
    04312 9029      LD	R2,Y+
    04313 9019      LD	R1,Y+
    04314 9009      LD	R0,Y+
    04315 9508      RET
    04316 EF0F      LDI	R16,0xFF
    04317 2F10      MOV	R17,R16
    04318 E72F      LDI	R18,0x7F
    04319 E73F      LDI	R19,0x7F
    0431A 2066      TST	R6
    0431B F399      BEQ	0x430F
    0431C 940E 415E CALL	neg32
    0431E CFF0      RJMP	0x430F
    0431F 2700      CLR	R16
    04320 2F10      MOV	R17,R16
    04321 2F20      MOV	R18,R16
    04322 2F30      MOV	R19,R16
    04323 CFEB      RJMP	0x430F
    04324 9109      LD	R16,Y+
    04325 9119      LD	R17,Y+
    04326 9129      LD	R18,Y+
    04327 9139      LD	R19,Y+
    04328 CFED      RJMP	0x4316
unpacks:
    04329 D00F      RCALL	unpacku
    0432A F029      BEQ	0x4330
    0432B 2066      TST	R6
    0432C F011      BEQ	0x432F
    0432D 940E 415E CALL	neg32
    0432F 9498      BCLR	1
    04330 9508      RET
tstR16_R19:
    04331 2300      TST	R16
    04332 F429      BNE	0x4338
    04333 2311      TST	R17
    04334 F419      BNE	0x4338
    04335 2322      TST	R18
    04336 F409      BNE	0x4338
    04337 2333      TST	R19
    04338 9508      RET
unpacku:
    04339 DFF7      RCALL	tstR16_R19
    0433A F099      BEQ	0x434E
    0433B 938A      ST	-Y,R24
    0433C 2E63      MOV	R6,R19
    0433D E880      LDI	R24,0x80
    0433E 2268      AND	R6,R24
    0433F 0F22      LSL	R18
    04340 1F33      ROL	R19
    04341 2E43      MOV	R4,R19
    04342 E78F      LDI	R24,0x7F
    04343 1A48      SUB	R4,R24
    04344 2455      CLR	R5
    04345 2788      CLR	R24
    04346 0A58      SBC	R5,R24
    04347 9526      LSR	R18
    04348 E830      LDI	R19,0x80
    04349 2B23      OR	R18,R19
    0434A 2733      CLR	R19
    0434B 9189      LD	R24,Y+
    0434C 9498      BCLR	1
    0434D 9508      RET
    0434E 2444      CLR	R4
    0434F 2455      CLR	R5
    04350 2466      CLR	R6
    04351 9508      RET
normalize_and_pack:
    04352 DFDE      RCALL	tstR16_R19
    04353 F409      BNE	0x4355
    04354 9508      RET
    04355 93AA      ST	-Y,R26
    04356 93BA      ST	-Y,R27
    04357 01D2      MOVW	R26,R4
    04358 939A      ST	-Y,R25
    04359 938A      ST	-Y,R24
    0435A E78E      LDI	R24,0x7E
    0435B E090      LDI	R25,0
    0435C 2333      TST	R19
    0435D F049      BEQ	0x4367
    0435E 9536      LSR	R19
    0435F 9527      ROR	R18
    04360 9517      ROR	R17
    04361 9507      ROR	R16
    04362 17A8      CP	R26,R24
    04363 07B9      CPC	R27,R25
    04364 F4CC      BGE	0x437E
    04365 9611      ADIW	R26,1
    04366 CFF5      RJMP	0x435C
    04367 9580      COM	R24
    04368 9590      COM	R25
    04369 9601      ADIW	R24,1
    0436A 2322      TST	R18
    0436B F0BA      BMI	0x4383
    0436C 0F00      LSL	R16
    0436D 1F11      ROL	R17
    0436E 1F22      ROL	R18
    0436F 17A8      CP	R26,R24
    04370 07B9      CPC	R27,R25
    04371 F014      BLT	0x4374
    04372 9711      SBIW	R26,1
    04373 CFF6      RJMP	0x436A
    04374 2700      CLR	R16
    04375 2711      CLR	R17
    04376 2722      CLR	R18
    04377 2733      CLR	R19
    04378 9189      LD	R24,Y+
    04379 9199      LD	R25,Y+
    0437A 012D      MOVW	R4,R26
    0437B 91B9      LD	R27,Y+
    0437C 91A9      LD	R26,Y+
    0437D 9508      RET
    0437E 2733      CLR	R19
    0437F EF0F      LDI	R16,0xFF
    04380 2F10      MOV	R17,R16
    04381 E72F      LDI	R18,0x7F
    04382 2F32      MOV	R19,R18
    04383 9189      LD	R24,Y+
    04384 9199      LD	R25,Y+
    04385 012D      MOVW	R4,R26
    04386 C002      RJMP	0x4389
pack:
    04387 93AA      ST	-Y,R26
    04388 93BA      ST	-Y,R27
    04389 DFA7      RCALL	tstR16_R19
    0438A F049      BEQ	0x4394
    0438B 01D2      MOVW	R26,R4
    0438C 58A1      SUBI	R26,0x81
    0438D 4FBF      SBCI	R27,0xFF
    0438E 012D      MOVW	R4,R26
    0438F 2D34      MOV	R19,R4
    04390 0F22      LSL	R18
    04391 9536      LSR	R19
    04392 9527      ROR	R18
    04393 2936      OR	R19,R6
    04394 91B9      LD	R27,Y+
    04395 91A9      LD	R26,Y+
    04396 9508      RET
saveFPRegs:
    04397 924A      ST	-Y,R4
    04398 925A      ST	-Y,R5
    04399 926A      ST	-Y,R6
    0439A 927A      ST	-Y,R7
    0439B 928A      ST	-Y,R8
    0439C 929A      ST	-Y,R9
    0439D 92AA      ST	-Y,R10
    0439E 92BA      ST	-Y,R11
    0439F 92CA      ST	-Y,R12
    043A0 92DA      ST	-Y,R13
    043A1 92EA      ST	-Y,R14
    043A2 92FA      ST	-Y,R15
    043A3 938A      ST	-Y,R24
    043A4 939A      ST	-Y,R25
    043A5 9508      RET
restoreFPRegs:
    043A6 9199      LD	R25,Y+
    043A7 9189      LD	R24,Y+
    043A8 90F9      LD	R15,Y+
    043A9 90E9      LD	R14,Y+
    043AA 90D9      LD	R13,Y+
    043AB 90C9      LD	R12,Y+
    043AC 90B9      LD	R11,Y+
    043AD 90A9      LD	R10,Y+
    043AE 9099      LD	R9,Y+
    043AF 9089      LD	R8,Y+
    043B0 9079      LD	R7,Y+
    043B1 9069      LD	R6,Y+
    043B2 9059      LD	R5,Y+
    043B3 9049      LD	R4,Y+
    043B4 9508      RET
fpmule:
    043B5 940E 4397 CALL	saveFPRegs
    043B7 93AA      ST	-Y,R26
    043B8 93BA      ST	-Y,R27
    043B9 940E 4339 CALL	unpacku
    043BB F1E1      BEQ	0x43F8
    043BC 2CE6      MOV	R14,R6
    043BD 2CD5      MOV	R13,R5
    043BE 2CC4      MOV	R12,R4
    043BF 2EB3      MOV	R11,R19
    043C0 2EA2      MOV	R10,R18
    043C1 2E91      MOV	R9,R17
    043C2 2E80      MOV	R8,R16
    043C3 8100      LD	R16,Z
    043C4 8111      LDD	R17,Z+1
    043C5 8122      LDD	R18,Z+2
    043C6 8133      LDD	R19,Z+3
    043C7 940E 4339 CALL	unpacku
    043C9 F171      BEQ	0x43F8
    043CA 246E      EOR	R6,R14
    043CB 0C4C      ADD	R4,R12
    043CC 1C5D      ADC	R5,R13
    043CD E880      LDI	R24,0x80
    043CE 1648      CP	R4,R24
    043CF 0653      CPC	R5,R19
    043D0 F564      BGE	0x43FD
    043D1 E881      LDI	R24,0x81
    043D2 1648      CP	R4,R24
    043D3 EF8F      LDI	R24,0xFF
    043D4 0658      CPC	R5,R24
    043D5 F16C      BLT	0x4403
    043D6 9EA2      MUL	R10,R18
    043D7 2DB1      MOV	R27,R1
    043D8 2DA0      MOV	R26,R0
    043D9 9E91      MUL	R9,R17
    043DA 2D91      MOV	R25,R1
    043DB 2D80      MOV	R24,R0
    043DC 9EA0      MUL	R10,R16
    043DD 0D80      ADD	R24,R0
    043DE 1D91      ADC	R25,R1
    043DF 1FA3      ADC	R26,R19
    043E0 1FB3      ADC	R27,R19
    043E1 9E82      MUL	R8,R18
    043E2 0D80      ADD	R24,R0
    043E3 1D91      ADC	R25,R1
    043E4 1FA3      ADC	R26,R19
    043E5 1FB3      ADC	R27,R19
    043E6 9E92      MUL	R9,R18
    043E7 0D90      ADD	R25,R0
    043E8 1DA1      ADC	R26,R1
    043E9 1FB3      ADC	R27,R19
    043EA 9EA1      MUL	R10,R17
    043EB 0D90      ADD	R25,R0
    043EC 1DA1      ADC	R26,R1
    043ED 1FB3      ADC	R27,R19
    043EE 2F2B      MOV	R18,R27
    043EF 2F1A      MOV	R17,R26
    043F0 2F09      MOV	R16,R25
    043F1 0F88      LSL	R24
    043F2 1F00      ROL	R16
    043F3 1F11      ROL	R17
    043F4 1F22      ROL	R18
    043F5 1F33      ROL	R19
    043F6 940E 4352 CALL	normalize_and_pack
    043F8 91B9      LD	R27,Y+
    043F9 91A9      LD	R26,Y+
    043FA 940E 43A6 CALL	restoreFPRegs
    043FC 9508      RET
    043FD EF0F      LDI	R16,0xFF
    043FE 2F10      MOV	R17,R16
    043FF E72F      LDI	R18,0x7F
    04400 E78F      LDI	R24,0x7F
    04401 2E48      MOV	R4,R24
    04402 CFF5      RJMP	0x43F8
    04403 2700      CLR	R16
    04404 2F10      MOV	R17,R16
    04405 2F20      MOV	R18,R16
    04406 2F30      MOV	R19,R16
    04407 CFF0      RJMP	0x43F8
fpmule1:
    04408 93FA      ST	-Y,R31
    04409 93EA      ST	-Y,R30
    0440A 81EA      LDD	R30,Y+2
    0440B 81FB      LDD	R31,Y+3
    0440C 940E 43B5 CALL	fpmule
    0440E 91E9      LD	R30,Y+
    0440F 91F9      LD	R31,Y+
    04410 9622      ADIW	R28,2
    04411 9508      RET
fpmule2:
    04412 93FA      ST	-Y,R31
    04413 93EA      ST	-Y,R30
    04414 2FEC      MOV	R30,R28
    04415 2FFD      MOV	R31,R29
    04416 9632      ADIW	R30,2
    04417 940E 43B5 CALL	fpmule
    04419 91E9      LD	R30,Y+
    0441A 91F9      LD	R31,Y+
    0441B 9624      ADIW	R28,4
    0441C 9508      RET
fpmule1x:
    0441D 93FA      ST	-Y,R31
    0441E 93EA      ST	-Y,R30
    0441F 81EA      LDD	R30,Y+2
    04420 81FB      LDD	R31,Y+3
    04421 940E 43B5 CALL	fpmule
    04423 91E9      LD	R30,Y+
    04424 91F9      LD	R31,Y+
    04425 8339      STD	Y+1,R19
    04426 8328      ST	Y,R18
    04427 931A      ST	-Y,R17
    04428 930A      ST	-Y,R16
    04429 9508      RET
fpcmp:
    0442A 940E 41D0 CALL	fpsub
    0442C 2333      TST	R19
    0442D F03A      BMI	0x4435
    0442E 940E 4331 CALL	tstR16_R19
    04430 F011      BEQ	0x4433
    04431 E001      LDI	R16,1
    04432 9508      RET
    04433 2700      CLR	R16
    04434 9508      RET
    04435 EF0F      LDI	R16,0xFF
    04436 9508      RET
fpcmp2:
    04437 93FA      ST	-Y,R31
    04438 93EA      ST	-Y,R30
    04439 2FEC      MOV	R30,R28
    0443A 2FFD      MOV	R31,R29
    0443B 9632      ADIW	R30,2
    0443C 940E 442A CALL	fpcmp
    0443E 91E9      LD	R30,Y+
    0443F 91F9      LD	R31,Y+
    04440 9624      ADIW	R28,4
    04441 2300      TST	R16
    04442 9508      RET
_itoa:
    04443 940E 3FCC CALL	push_arg4
    04445 940E 4111 CALL	push_xgsetF0FC
    04447 01A9      MOVW	R20,R18
    04448 84EE      LDD	R14,Y+14
    04449 84FF      LDD	R15,Y+15
    0444A 015A      MOVW	R10,R20
    0444B 20AA      TST	R10
    0444C F451      BNE	0x4457
    0444D 20BB      TST	R11
    0444E F441      BNE	0x4457
    0444F E380      LDI	R24,0x30
    04450 85EA      LDD	R30,Y+10
    04451 85FB      LDD	R31,Y+11
    04452 8380      ST	Z,R24
    04453 2422      CLR	R2
    04454 8221      STD	Z+1,R2
    04455 018F      MOVW	R16,R30
    04456 C053      RJMP	0x44AA
    04457 3040      CPI	R20,0
    04458 E0E0      LDI	R30,0
    04459 075E      CPC	R21,R30
    0445A F46C      BGE	0x4468
    0445B 01C7      MOVW	R24,R14
    0445C 308A      CPI	R24,0xA
    0445D E0E0      LDI	R30,0
    0445E 079E      CPC	R25,R30
    0445F F441      BNE	0x4468
    04460 24CC      CLR	R12
    04461 94C3      INC	R12
    04462 01C5      MOVW	R24,R10
    04463 9580      COM	R24
    04464 9590      COM	R25
    04465 9601      ADIW	R24,1
    04466 015C      MOVW	R10,R24
    04467 C001      RJMP	0x4469
    04468 24CC      CLR	R12
    04469 856A      LDD	R22,Y+10
    0446A 857B      LDD	R23,Y+11
    0446B 0197      MOVW	R18,R14
    0446C 0185      MOVW	R16,R10
    0446D 940E 3FFB CALL	mod16u
    0446F 01A8      MOVW	R20,R16
    04470 E089      LDI	R24,0x9
    04471 E090      LDI	R25,0
    04472 1780      CP	R24,R16
    04473 0791      CPC	R25,R17
    04474 F034      BLT	0x447B
    04475 01CA      MOVW	R24,R20
    04476 96C0      ADIW	R24,0x30
    04477 01FB      MOVW	R30,R22
    04478 9381      ST	Z+,R24
    04479 01BF      MOVW	R22,R30
    0447A C006      RJMP	0x4481
    0447B 01CA      MOVW	R24,R20
    0447C 5A89      SUBI	R24,0xA9
    0447D 4F9F      SBCI	R25,0xFF
    0447E 01FB      MOVW	R30,R22
    0447F 9381      ST	Z+,R24
    04480 01BF      MOVW	R22,R30
    04481 0197      MOVW	R18,R14
    04482 0185      MOVW	R16,R10
    04483 940E 3FFD CALL	div16u
    04485 0158      MOVW	R10,R16
    04486 20AA      TST	R10
    04487 F719      BNE	0x446B
    04488 20BB      TST	R11
    04489 F709      BNE	0x446B
    0448A 20CC      TST	R12
    0448B F021      BEQ	0x4490
    0448C E28D      LDI	R24,0x2D
    0448D 01FB      MOVW	R30,R22
    0448E 9381      ST	Z+,R24
    0448F 01BF      MOVW	R22,R30
    04490 012B      MOVW	R4,R22
    04491 5061      SUBI	R22,1
    04492 4070      SBCI	R23,0
    04493 2422      CLR	R2
    04494 01F2      MOVW	R30,R4
    04495 8220      ST	Z,R2
    04496 84AA      LDD	R10,Y+10
    04497 84BB      LDD	R11,Y+11
    04498 C00C      RJMP	0x44A5
    04499 01F5      MOVW	R30,R10
    0449A 80C0      LD	R12,Z
    0449B 01FB      MOVW	R30,R22
    0449C 8020      LD	R2,Z
    0449D 01F5      MOVW	R30,R10
    0449E 9221      ST	Z+,R2
    0449F 015F      MOVW	R10,R30
    044A0 011B      MOVW	R2,R22
    044A1 5061      SUBI	R22,1
    044A2 4070      SBCI	R23,0
    044A3 01F1      MOVW	R30,R2
    044A4 82C0      ST	Z,R12
    044A5 16A6      CP	R10,R22
    044A6 06B7      CPC	R11,R23
    044A7 F388      BCS	0x4499
    044A8 850A      LDD	R16,Y+10
    044A9 851B      LDD	R17,Y+11
    044AA 940E 4106 CALL	pop_xgsetF0FC
    044AC 9624      ADIW	R28,4
    044AD 9508      RET
_ltoa:
    044AE 940E 3FCC CALL	push_arg4
    044B0 940E 4111 CALL	push_xgsetF0FC
    044B2 9724      SBIW	R28,4
    044B3 8828      LDD	R2,Y+16
    044B4 8839      LDD	R3,Y+17
    044B5 884A      LDD	R4,Y+18
    044B6 885B      LDD	R5,Y+19
    044B7 8228      ST	Y,R2
    044B8 8239      STD	Y+1,R3
    044B9 824A      STD	Y+2,R4
    044BA 825B      STD	Y+3,R5
    044BB 8828      LDD	R2,Y+16
    044BC 8839      LDD	R3,Y+17
    044BD 884A      LDD	R4,Y+18
    044BE 885B      LDD	R5,Y+19
    044BF 9488      BCLR	0
    044C0 2022      TST	R2
    044C1 0432      CPC	R3,R2
    044C2 0442      CPC	R4,R2
    044C3 0452      CPC	R5,R2
    044C4 F441      BNE	0x44CD
    044C5 E380      LDI	R24,0x30
    044C6 85EE      LDD	R30,Y+14
    044C7 85FF      LDD	R31,Y+15
    044C8 8380      ST	Z,R24
    044C9 2422      CLR	R2
    044CA 8221      STD	Z+1,R2
    044CB 018F      MOVW	R16,R30
    044CC C094      RJMP	0x4561
    044CD E040      LDI	R20,0
    044CE E050      LDI	R21,0
    044CF E060      LDI	R22,0
    044D0 E070      LDI	R23,0
    044D1 8828      LDD	R2,Y+16
    044D2 8839      LDD	R3,Y+17
    044D3 884A      LDD	R4,Y+18
    044D4 885B      LDD	R5,Y+19
    044D5 1624      CP	R2,R20
    044D6 0635      CPC	R3,R21
    044D7 0646      CPC	R4,R22
    044D8 0657      CPC	R5,R23
    044D9 F4EC      BGE	0x44F7
    044DA 898C      LDD	R24,Y+20
    044DB 899D      LDD	R25,Y+21
    044DC 308A      CPI	R24,0xA
    044DD E0A0      LDI	R26,0
    044DE 079A      CPC	R25,R26
    044DF F4B9      BNE	0x44F7
    044E0 24AA      CLR	R10
    044E1 94A3      INC	R10
    044E2 E041      LDI	R20,1
    044E3 E050      LDI	R21,0
    044E4 E060      LDI	R22,0
    044E5 E070      LDI	R23,0
    044E6 8028      LD	R2,Y
    044E7 8039      LDD	R3,Y+1
    044E8 804A      LDD	R4,Y+2
    044E9 805B      LDD	R5,Y+3
    044EA 9420      COM	R2
    044EB 9430      COM	R3
    044EC 9440      COM	R4
    044ED 9450      COM	R5
    044EE 0E24      ADD	R2,R20
    044EF 1E35      ADC	R3,R21
    044F0 1E46      ADC	R4,R22
    044F1 1E57      ADC	R5,R23
    044F2 8228      ST	Y,R2
    044F3 8239      STD	Y+1,R3
    044F4 824A      STD	Y+2,R4
    044F5 825B      STD	Y+3,R5
    044F6 C001      RJMP	0x44F8
    044F7 24AA      CLR	R10
    044F8 84CE      LDD	R12,Y+14
    044F9 84DF      LDD	R13,Y+15
    044FA 882C      LDD	R2,Y+20
    044FB 883D      LDD	R3,Y+21
    044FC 2444      CLR	R4
    044FD FC37      SBRC	R3,7
    044FE 9440      COM	R4
    044FF 2455      CLR	R5
    04500 FC47      SBRC	R4,7
    04501 9450      COM	R5
    04502 8108      LD	R16,Y
    04503 8119      LDD	R17,Y+1
    04504 812A      LDD	R18,Y+2
    04505 813B      LDD	R19,Y+3
    04506 925A      ST	-Y,R5
    04507 924A      ST	-Y,R4
    04508 923A      ST	-Y,R3
    04509 922A      ST	-Y,R2
    0450A 940E 4019 CALL	mod32u
    0450C 0178      MOVW	R14,R16
    0450D E089      LDI	R24,0x9
    0450E E090      LDI	R25,0
    0450F 1780      CP	R24,R16
    04510 0791      CPC	R25,R17
    04511 F034      BLT	0x4518
    04512 01C7      MOVW	R24,R14
    04513 96C0      ADIW	R24,0x30
    04514 01F6      MOVW	R30,R12
    04515 9381      ST	Z+,R24
    04516 016F      MOVW	R12,R30
    04517 C006      RJMP	0x451E
    04518 01C7      MOVW	R24,R14
    04519 5A89      SUBI	R24,0xA9
    0451A 4F9F      SBCI	R25,0xFF
    0451B 01F6      MOVW	R30,R12
    0451C 9381      ST	Z+,R24
    0451D 016F      MOVW	R12,R30
    0451E 882C      LDD	R2,Y+20
    0451F 883D      LDD	R3,Y+21
    04520 2444      CLR	R4
    04521 FC37      SBRC	R3,7
    04522 9440      COM	R4
    04523 2455      CLR	R5
    04524 FC47      SBRC	R4,7
    04525 9450      COM	R5
    04526 8108      LD	R16,Y
    04527 8119      LDD	R17,Y+1
    04528 812A      LDD	R18,Y+2
    04529 813B      LDD	R19,Y+3
    0452A 925A      ST	-Y,R5
    0452B 924A      ST	-Y,R4
    0452C 923A      ST	-Y,R3
    0452D 922A      ST	-Y,R2
    0452E 940E 4017 CALL	div32u
    04530 8308      ST	Y,R16
    04531 8319      STD	Y+1,R17
    04532 832A      STD	Y+2,R18
    04533 833B      STD	Y+3,R19
    04534 8028      LD	R2,Y
    04535 8039      LDD	R3,Y+1
    04536 804A      LDD	R4,Y+2
    04537 805B      LDD	R5,Y+3
    04538 9488      BCLR	0
    04539 2022      TST	R2
    0453A 0432      CPC	R3,R2
    0453B 0442      CPC	R4,R2
    0453C 0452      CPC	R5,R2
    0453D F009      BEQ	0x453F
    0453E CFBB      RJMP	0x44FA
    0453F 20AA      TST	R10
    04540 F021      BEQ	0x4545
    04541 E28D      LDI	R24,0x2D
    04542 01F6      MOVW	R30,R12
    04543 9381      ST	Z+,R24
    04544 016F      MOVW	R12,R30
    04545 0126      MOVW	R4,R12
    04546 01C2      MOVW	R24,R4
    04547 9701      SBIW	R24,1
    04548 016C      MOVW	R12,R24
    04549 2422      CLR	R2
    0454A 01F2      MOVW	R30,R4
    0454B 8220      ST	Z,R2
    0454C 84EE      LDD	R14,Y+14
    0454D 84FF      LDD	R15,Y+15
    0454E C00D      RJMP	0x455C
    0454F 01F7      MOVW	R30,R14
    04550 80A0      LD	R10,Z
    04551 01F6      MOVW	R30,R12
    04552 8020      LD	R2,Z
    04553 01F7      MOVW	R30,R14
    04554 9221      ST	Z+,R2
    04555 017F      MOVW	R14,R30
    04556 0116      MOVW	R2,R12
    04557 01C1      MOVW	R24,R2
    04558 9701      SBIW	R24,1
    04559 016C      MOVW	R12,R24
    0455A 01F1      MOVW	R30,R2
    0455B 82A0      ST	Z,R10
    0455C 14EC      CP	R14,R12
    0455D 04FD      CPC	R15,R13
    0455E F380      BCS	0x454F
    0455F 850E      LDD	R16,Y+14
    04560 851F      LDD	R17,Y+15
    04561 9624      ADIW	R28,4
    04562 940E 4106 CALL	pop_xgsetF0FC
    04564 9624      ADIW	R28,4
    04565 9508      RET
_ftoa:
    04566 940E 3FCC CALL	push_arg4
    04568 940E 4111 CALL	push_xgsetF0FC
    0456A 9764      SBIW	R28,0x14
    0456B A0CA      LDD	R12,Y+34
    0456C A0DB      LDD	R13,Y+35
    0456D 2422      CLR	R2
    0456E 2433      CLR	R3
    0456F 01F6      MOVW	R30,R12
    04570 8231      STD	Z+1,R3
    04571 8220      ST	Z,R2
    04572 8C2E      LDD	R2,Y+30
    04573 8C3F      LDD	R3,Y+31
    04574 A048      LDD	R4,Y+32
    04575 A059      LDD	R5,Y+33
    04576 EC0C      LDI	R16,0xCC
    04577 E010      LDI	R17,0
    04578 940E 4099 CALL	elpm32
    0457A 933A      ST	-Y,R19
    0457B 932A      ST	-Y,R18
    0457C 931A      ST	-Y,R17
    0457D 930A      ST	-Y,R16
    0457E 0181      MOVW	R16,R2
    0457F 0192      MOVW	R18,R4
    04580 940E 4437 CALL	fpcmp2
    04582 F479      BNE	0x4592
    04583 E380      LDI	R24,0x30
    04584 9380 07E3 STS	config+20,R24
    04586 E28E      LDI	R24,0x2E
    04587 9380 07E4 STS	config+21,R24
    04589 E380      LDI	R24,0x30
    0458A 9380 07E5 STS	config+22,R24
    0458C 2422      CLR	R2
    0458D 9220 07E6 STS	config+23,R2
    0458F EE03      LDI	R16,0xE3
    04590 E017      LDI	R17,7
    04591 C15E      RJMP	0x46F0
    04592 8C2E      LDD	R2,Y+30
    04593 8C3F      LDD	R3,Y+31
    04594 A048      LDD	R4,Y+32
    04595 A059      LDD	R5,Y+33
    04596 8628      STD	Y+8,R2
    04597 8639      STD	Y+9,R3
    04598 864A      STD	Y+10,R4
    04599 865B      STD	Y+11,R5
    0459A E187      LDI	R24,0x17
    0459B E090      LDI	R25,0
    0459C 8508      LDD	R16,Y+8
    0459D 8519      LDD	R17,Y+9
    0459E 852A      LDD	R18,Y+10
    0459F 853B      LDD	R19,Y+11
    045A0 938A      ST	-Y,R24
    045A1 940E 3FD1 CALL	asr32
    045A3 2F80      MOV	R24,R16
    045A4 2799      CLR	R25
    045A5 578F      SUBI	R24,0x7F
    045A6 4090      SBCI	R25,0
    045A7 015C      MOVW	R10,R24
    045A8 EF4F      LDI	R20,0xFF
    045A9 EF5F      LDI	R21,0xFF
    045AA EF6F      LDI	R22,0xFF
    045AB E070      LDI	R23,0
    045AC 8428      LDD	R2,Y+8
    045AD 8439      LDD	R3,Y+9
    045AE 844A      LDD	R4,Y+10
    045AF 845B      LDD	R5,Y+11
    045B0 2224      AND	R2,R20
    045B1 2235      AND	R3,R21
    045B2 2246      AND	R4,R22
    045B3 2257      AND	R5,R23
    045B4 93EF      PUSH	R30
    045B5 2DE4      MOV	R30,R4
    045B6 68E0      ORI	R30,0x80
    045B7 2E4E      MOV	R4,R30
    045B8 91EF      POP	R30
    045B9 8A28      STD	Y+16,R2
    045BA 8A39      STD	Y+17,R3
    045BB 8A4A      STD	Y+18,R4
    045BC 8A5B      STD	Y+19,R5
    045BD E080      LDI	R24,0
    045BE 838C      STD	Y+4,R24
    045BF 838D      STD	Y+5,R24
    045C0 838E      STD	Y+6,R24
    045C1 838F      STD	Y+7,R24
    045C2 E080      LDI	R24,0
    045C3 878C      STD	Y+12,R24
    045C4 878D      STD	Y+13,R24
    045C5 878E      STD	Y+14,R24
    045C6 878F      STD	Y+15,R24
    045C7 01C5      MOVW	R24,R10
    045C8 318F      CPI	R24,0x1F
    045C9 E0E0      LDI	R30,0
    045CA 079E      CPC	R25,R30
    045CB F044      BLT	0x45D4
    045CC EF8E      LDI	R24,0xFE
    045CD EF9F      LDI	R25,0xFF
    045CE 01F6      MOVW	R30,R12
    045CF 8391      STD	Z+1,R25
    045D0 8380      ST	Z,R24
    045D1 2700      CLR	R16
    045D2 2711      CLR	R17
    045D3 C11C      RJMP	0x46F0
    045D4 01C5      MOVW	R24,R10
    045D5 3E89      CPI	R24,0xE9
    045D6 EFEF      LDI	R30,0xFF
    045D7 079E      CPC	R25,R30
    045D8 F444      BGE	0x45E1
    045D9 EF8F      LDI	R24,0xFF
    045DA EF9F      LDI	R25,0xFF
    045DB 01F6      MOVW	R30,R12
    045DC 8391      STD	Z+1,R25
    045DD 8380      ST	Z,R24
    045DE 2700      CLR	R16
    045DF 2711      CLR	R17
    045E0 C10F      RJMP	0x46F0
    045E1 01C5      MOVW	R24,R10
    045E2 3187      CPI	R24,0x17
    045E3 E0A0      LDI	R26,0
    045E4 079A      CPC	R25,R26
    045E5 F06C      BLT	0x45F3
    045E6 9747      SBIW	R24,0x17
    045E7 8908      LDD	R16,Y+16
    045E8 8919      LDD	R17,Y+17
    045E9 892A      LDD	R18,Y+18
    045EA 893B      LDD	R19,Y+19
    045EB 938A      ST	-Y,R24
    045EC 940E 4193 CALL	lsl32
    045EE 870C      STD	Y+12,R16
    045EF 871D      STD	Y+13,R17
    045F0 872E      STD	Y+14,R18
    045F1 873F      STD	Y+15,R19
    045F2 C045      RJMP	0x4638
    045F3 01C5      MOVW	R24,R10
    045F4 3080      CPI	R24,0
    045F5 E0A0      LDI	R26,0
    045F6 079A      CPC	R25,R26
    045F7 F13C      BLT	0x461F
    045F8 E187      LDI	R24,0x17
    045F9 E090      LDI	R25,0
    045FA 198A      SUB	R24,R10
    045FB 099B      SBC	R25,R11
    045FC 8908      LDD	R16,Y+16
    045FD 8919      LDD	R17,Y+17
    045FE 892A      LDD	R18,Y+18
    045FF 893B      LDD	R19,Y+19
    04600 938A      ST	-Y,R24
    04601 940E 3FD1 CALL	asr32
    04603 870C      STD	Y+12,R16
    04604 871D      STD	Y+13,R17
    04605 872E      STD	Y+14,R18
    04606 873F      STD	Y+15,R19
    04607 01C5      MOVW	R24,R10
    04608 9601      ADIW	R24,1
    04609 8908      LDD	R16,Y+16
    0460A 8919      LDD	R17,Y+17
    0460B 892A      LDD	R18,Y+18
    0460C 893B      LDD	R19,Y+19
    0460D 938A      ST	-Y,R24
    0460E 940E 4193 CALL	lsl32
    04610 0118      MOVW	R2,R16
    04611 0129      MOVW	R4,R18
    04612 EF4F      LDI	R20,0xFF
    04613 EF5F      LDI	R21,0xFF
    04614 EF6F      LDI	R22,0xFF
    04615 E070      LDI	R23,0
    04616 2224      AND	R2,R20
    04617 2235      AND	R3,R21
    04618 2246      AND	R4,R22
    04619 2257      AND	R5,R23
    0461A 822C      STD	Y+4,R2
    0461B 823D      STD	Y+5,R3
    0461C 824E      STD	Y+6,R4
    0461D 825F      STD	Y+7,R5
    0461E C019      RJMP	0x4638
    0461F EF4F      LDI	R20,0xFF
    04620 EF5F      LDI	R21,0xFF
    04621 EF6F      LDI	R22,0xFF
    04622 E070      LDI	R23,0
    04623 8908      LDD	R16,Y+16
    04624 8919      LDD	R17,Y+17
    04625 892A      LDD	R18,Y+18
    04626 893B      LDD	R19,Y+19
    04627 2304      AND	R16,R20
    04628 2315      AND	R17,R21
    04629 2326      AND	R18,R22
    0462A 2337      AND	R19,R23
    0462B 01C5      MOVW	R24,R10
    0462C 9601      ADIW	R24,1
    0462D 9580      COM	R24
    0462E 9590      COM	R25
    0462F 5F8F      SUBI	R24,0xFF
    04630 4F9F      SBCI	R25,0xFF
    04631 938A      ST	-Y,R24
    04632 940E 3FD1 CALL	asr32
    04634 830C      STD	Y+4,R16
    04635 831D      STD	Y+5,R17
    04636 832E      STD	Y+6,R18
    04637 833F      STD	Y+7,R19
    04638 EE83      LDI	R24,0xE3
    04639 E097      LDI	R25,7
    0463A 015C      MOVW	R10,R24
    0463B E040      LDI	R20,0
    0463C E050      LDI	R21,0
    0463D E060      LDI	R22,0
    0463E E070      LDI	R23,0
    0463F 8428      LDD	R2,Y+8
    04640 8439      LDD	R3,Y+9
    04641 844A      LDD	R4,Y+10
    04642 845B      LDD	R5,Y+11
    04643 1624      CP	R2,R20
    04644 0635      CPC	R3,R21
    04645 0646      CPC	R4,R22
    04646 0657      CPC	R5,R23
    04647 F424      BGE	0x464C
    04648 E28D      LDI	R24,0x2D
    04649 01F5      MOVW	R30,R10
    0464A 9381      ST	Z+,R24
    0464B 015F      MOVW	R10,R30
    0464C 842C      LDD	R2,Y+12
    0464D 843D      LDD	R3,Y+13
    0464E 844E      LDD	R4,Y+14
    0464F 845F      LDD	R5,Y+15
    04650 9488      BCLR	0
    04651 2022      TST	R2
    04652 0432      CPC	R3,R2
    04653 0442      CPC	R4,R2
    04654 0452      CPC	R5,R2
    04655 F429      BNE	0x465B
    04656 E380      LDI	R24,0x30
    04657 01F5      MOVW	R30,R10
    04658 9381      ST	Z+,R24
    04659 015F      MOVW	R10,R30
    0465A C016      RJMP	0x4671
    0465B E08A      LDI	R24,0xA
    0465C E090      LDI	R25,0
    0465D 839B      STD	Y+3,R25
    0465E 838A      STD	Y+2,R24
    0465F 842C      LDD	R2,Y+12
    04660 843D      LDD	R3,Y+13
    04661 844E      LDD	R4,Y+14
    04662 845F      LDD	R5,Y+15
    04663 8248      ST	Y,R4
    04664 8259      STD	Y+1,R5
    04665 0191      MOVW	R18,R2
    04666 0185      MOVW	R16,R10
    04667 940E 44AE CALL	_ltoa
    04669 C003      RJMP	0x466D
    0466A 01C5      MOVW	R24,R10
    0466B 9601      ADIW	R24,1
    0466C 015C      MOVW	R10,R24
    0466D 01F5      MOVW	R30,R10
    0466E 8020      LD	R2,Z
    0466F 2022      TST	R2
    04670 F7C9      BNE	0x466A
    04671 E28E      LDI	R24,0x2E
    04672 01F5      MOVW	R30,R10
    04673 9381      ST	Z+,R24
    04674 015F      MOVW	R10,R30
    04675 802C      LDD	R2,Y+4
    04676 803D      LDD	R3,Y+5
    04677 804E      LDD	R4,Y+6
    04678 805F      LDD	R5,Y+7
    04679 9488      BCLR	0
    0467A 2022      TST	R2
    0467B 0432      CPC	R3,R2
    0467C 0442      CPC	R4,R2
    0467D 0452      CPC	R5,R2
    0467E F421      BNE	0x4683
    0467F E380      LDI	R24,0x30
    04680 9381      ST	Z+,R24
    04681 015F      MOVW	R10,R30
    04682 C068      RJMP	0x46EB
    04683 EE83      LDI	R24,0xE3
    04684 E097      LDI	R25,7
    04685 0115      MOVW	R2,R10
    04686 1A28      SUB	R2,R24
    04687 0A39      SBC	R3,R25
    04688 E08F      LDI	R24,0xF
    04689 E090      LDI	R25,0
    0468A 1982      SUB	R24,R2
    0468B 0993      SBC	R25,R3
    0468C 9701      SBIW	R24,1
    0468D 2EC8      MOV	R12,R24
    0468E E087      LDI	R24,7
    0468F 158C      CP	R24,R12
    04690 F408      BCC	0x4692
    04691 2EC8      MOV	R12,R24
    04692 24EE      CLR	R14
    04693 C042      RJMP	0x46D6
    04694 E083      LDI	R24,3
    04695 E090      LDI	R25,0
    04696 810C      LDD	R16,Y+4
    04697 811D      LDD	R17,Y+5
    04698 812E      LDD	R18,Y+6
    04699 813F      LDD	R19,Y+7
    0469A 938A      ST	-Y,R24
    0469B 940E 4193 CALL	lsl32
    0469D 0118      MOVW	R2,R16
    0469E 0129      MOVW	R4,R18
    0469F 806C      LDD	R6,Y+4
    046A0 807D      LDD	R7,Y+5
    046A1 808E      LDD	R8,Y+6
    046A2 809F      LDD	R9,Y+7
    046A3 0C66      LSL	R6
    046A4 1C77      ROL	R7
    046A5 1C88      ROL	R8
    046A6 1C99      ROL	R9
    046A7 0C26      ADD	R2,R6
    046A8 1C37      ADC	R3,R7
    046A9 1C48      ADC	R4,R8
    046AA 1C59      ADC	R5,R9
    046AB 822C      STD	Y+4,R2
    046AC 823D      STD	Y+5,R3
    046AD 824E      STD	Y+6,R4
    046AE 825F      STD	Y+7,R5
    046AF E188      LDI	R24,0x18
    046B0 E090      LDI	R25,0
    046B1 810C      LDD	R16,Y+4
    046B2 811D      LDD	R17,Y+5
    046B3 812E      LDD	R18,Y+6
    046B4 813F      LDD	R19,Y+7
    046B5 938A      ST	-Y,R24
    046B6 940E 3FD1 CALL	asr32
    046B8 0118      MOVW	R2,R16
    046B9 0129      MOVW	R4,R18
    046BA E340      LDI	R20,0x30
    046BB E050      LDI	R21,0
    046BC E060      LDI	R22,0
    046BD E070      LDI	R23,0
    046BE 0E24      ADD	R2,R20
    046BF 1E35      ADC	R3,R21
    046C0 1E46      ADC	R4,R22
    046C1 1E57      ADC	R5,R23
    046C2 01F5      MOVW	R30,R10
    046C3 9221      ST	Z+,R2
    046C4 015F      MOVW	R10,R30
    046C5 EF4F      LDI	R20,0xFF
    046C6 EF5F      LDI	R21,0xFF
    046C7 EF6F      LDI	R22,0xFF
    046C8 E070      LDI	R23,0
    046C9 802C      LDD	R2,Y+4
    046CA 803D      LDD	R3,Y+5
    046CB 804E      LDD	R4,Y+6
    046CC 805F      LDD	R5,Y+7
    046CD 2224      AND	R2,R20
    046CE 2235      AND	R3,R21
    046CF 2246      AND	R4,R22
    046D0 2257      AND	R5,R23
    046D1 822C      STD	Y+4,R2
    046D2 823D      STD	Y+5,R3
    046D3 824E      STD	Y+6,R4
    046D4 825F      STD	Y+7,R5
    046D5 94E3      INC	R14
    046D6 14EC      CP	R14,R12
    046D7 F408      BCC	0x46D9
    046D8 CFBB      RJMP	0x4694
    046D9 01C5      MOVW	R24,R10
    046DA 9701      SBIW	R24,1
    046DB 015C      MOVW	R10,R24
    046DC C003      RJMP	0x46E0
    046DD 01C5      MOVW	R24,R10
    046DE 9701      SBIW	R24,1
    046DF 015C      MOVW	R10,R24
    046E0 01F5      MOVW	R30,R10
    046E1 8180      LD	R24,Z
    046E2 3380      CPI	R24,0x30
    046E3 F421      BNE	0x46E8
    046E4 9731      SBIW	R30,1
    046E5 8180      LD	R24,Z
    046E6 328E      CPI	R24,0x2E
    046E7 F7A9      BNE	0x46DD
    046E8 01C5      MOVW	R24,R10
    046E9 9601      ADIW	R24,1
    046EA 015C      MOVW	R10,R24
    046EB 2422      CLR	R2
    046EC 01F5      MOVW	R30,R10
    046ED 8220      ST	Z,R2
    046EE EE03      LDI	R16,0xE3
    046EF E017      LDI	R17,7
    046F0 9664      ADIW	R28,0x14
    046F1 940E 4106 CALL	pop_xgsetF0FC
    046F3 9624      ADIW	R28,4
    046F4 9508      RET
