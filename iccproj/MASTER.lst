Interrupt Vectors
    00000 940C 0253 JMP	__start|__text_start
    0003C 940C 32CB JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    00253 EFCF      LDI	R28,0xFF
    00254 E1D0      LDI	R29,0x10
    00255 BFCD      OUT	0x3D,R28
    00256 BFDE      OUT	0x3E,R29
    00257 51CE      SUBI	R28,0x1E
    00258 40D0      SBCI	R29,0
    00259 EA0A      LDI	R16,0xAA
    0025A 8308      ST	Y,R16
    0025B 2400      CLR	R0
    0025C EDE6      LDI	R30,0xD6
    0025D E0F4      LDI	R31,4
    0025E E017      LDI	R17,7
    0025F 36E6      CPI	R30,0x66
    00260 07F1      CPC	R31,R17
    00261 F011      BEQ	0x0264
    00262 9201      ST	Z+,R0
    00263 CFFB      RJMP	0x025F
    00264 8300      ST	Z,R16
    00265 EDE0      LDI	R30,0xD0
    00266 E0F0      LDI	R31,0
    00267 E0A0      LDI	R26,0
    00268 E0B1      LDI	R27,1
    00269 E014      LDI	R17,4
    0026A E000      LDI	R16,0
    0026B BF0B      OUT	0x3B,R16
    0026C 3AE6      CPI	R30,0xA6
    0026D 07F1      CPC	R31,R17
    0026E F021      BEQ	0x0273
    0026F 95C8      LPM
    00270 9631      ADIW	R30,1
    00271 920D      ST	X+,R0
    00272 CFF9      RJMP	0x026C
    00273 940E 2434 CALL	_main
_exit:
    00275 CFFF      RJMP	_exit
_disk_initialize:
  state                --> R20
  drv                  --> R10
    00276 92AA      ST	-Y,R10
    00277 934A      ST	-Y,R20
    00278 2EA0      MOV	R10,R16
FILE: D:\LQD\software\master\software_src\diskio.c
(0001) 
(0002) 
(0003) /*-----------------------------------------------------------------------*/
(0004) /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
(0005) /*-----------------------------------------------------------------------*/
(0006) /* This is a stub disk I/O module that acts as front end of the existing */
(0007) /* disk I/O modules and attach it to FatFs module with common interface. */
(0008) /*-----------------------------------------------------------------------*/
(0009) 
(0010) #include "diskio.h"
(0011) #include "sd.h"
(0012) 
(0013) 
(0014) /*-----------------------------------------------------------------------*/
(0015) /* Correspondence between physical drive number and physical drive.      */
(0016) /* Note that Tiny-FatFs supports only single drive and always            */
(0017)                                       
(0018) 
(0019) ////////////////////////////
(0020) /*
(0021)    struct tm {
(0022)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0023)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0024) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0025) 	int tm_mday;  // 日 day of the month, 1 to 31
(0026) 	int tm_mon;   // 月 months since January, 0 to 11
(0027) 	int tm_year;  // 年 years since 1900
(0028) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0029) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0030)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0031)  	};
(0032) */
(0033) /*-----------------------------------------------------------------------*/
(0034) /* Inidialize a Drive                                                    */
(0035) 
(0036) DSTATUS disk_initialize ( 
(0037) BYTE drv				/* Physical drive nmuber (0..) */
(0038) )
(0039) {
(0040)     unsigned char state;
(0041) 
(0042)     if(drv)
    00279 20AA      TST	R10
    0027A F011      BEQ	0x027D
(0043)     {
(0044)         return STA_NOINIT;  //仅支持磁盘0的操作
    0027B E001      LDI	R16,1
    0027C C00C      RJMP	0x0289
(0045)     }
(0046) 
(0047)     state = SD_Init();
    0027D 940E 28FA CALL	_SD_Init
    0027F 2F40      MOV	R20,R16
(0048)     if(state == STA_NODISK)
    00280 3002      CPI	R16,2
    00281 F411      BNE	0x0284
(0049)     {
(0050)         return STA_NODISK;
    00282 E002      LDI	R16,2
    00283 C005      RJMP	0x0289
(0051)     }
(0052)     else if(state != 0)
    00284 2344      TST	R20
    00285 F011      BEQ	0x0288
(0053)     {
(0054)         return STA_NOINIT;  //其他错误：初始化失败
    00286 E001      LDI	R16,1
    00287 C001      RJMP	0x0289
(0055)     }
(0056)     else
(0057)     {
(0058)         return 0;           //初始化成功
    00288 2700      CLR	R16
    00289 9149      LD	R20,Y+
    0028A 90A9      LD	R10,Y+
    0028B 9508      RET
(0059)     }
(0060) }
(0061) 
(0062) 
(0063) 
(0064) /*-----------------------------------------------------------------------*/
(0065) /* Return Disk Status                                                    */
(0066) 
(0067) DSTATUS disk_status (
(0068) 	BYTE drv		/* Physical drive nmuber (0..) */
(0069) )
(0070) {
(0071)     if(drv)
_disk_status:
  drv                  --> R16
    0028C 2300      TST	R16
    0028D F011      BEQ	0x0290
(0072)     {
(0073)         return STA_NOINIT;  //仅支持磁盘0操作
    0028E E001      LDI	R16,1
    0028F C001      RJMP	0x0291
(0074)     }
(0075)     return 0;
    00290 2700      CLR	R16
    00291 9508      RET
_disk_read:
  res                  --> R10
  count                --> R20
  sector               --> Y,+10
  buff                 --> R12
  drv                  --> R14
    00292 940E 3C77 CALL	push_xgset30FC
    00294 0169      MOVW	R12,R18
    00295 2EE0      MOV	R14,R16
    00296 9722      SBIW	R28,2
    00297 854E      LDD	R20,Y+14
(0076) }
(0077) 
(0078) 
(0079) 
(0080) /*-----------------------------------------------------------------------*/
(0081) /* Read Sector(s)                                                        */
(0082) 
(0083) DRESULT disk_read (
(0084) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0085) 	BYTE *buff,		/* Data buffer to store read data */
(0086) 	DWORD sector,	/* Sector address (LBA) */
(0087) 	BYTE count		/* Number of sectors to read (1..255) */
(0088) )
(0089) {
(0090) 	unsigned char res=0;
    00298 24AA      CLR	R10
(0091)     if (drv || !count)
    00299 20EE      TST	R14
    0029A F411      BNE	0x029D
    0029B 2344      TST	R20
    0029C F411      BNE	0x029F
(0092)     {    
(0093)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    0029D E004      LDI	R16,4
    0029E C010      RJMP	0x02AF
(0094)     }
(0095) 
(0096)     if(count==1)            //1个sector的读操作      
    0029F 3041      CPI	R20,1
    002A0 F449      BNE	0x02AA
(0097)     {                                                
(0098)         res = SD_Read_Sector(sector, buff);      
    002A1 82D9      STD	Y+1,R13
    002A2 82C8      ST	Y,R12
    002A3 850A      LDD	R16,Y+10
    002A4 851B      LDD	R17,Y+11
    002A5 852C      LDD	R18,Y+12
    002A6 853D      LDD	R19,Y+13
    002A7 940E 29E0 CALL	_SD_Read_Sector
    002A9 2EA0      MOV	R10,R16
(0099)     }                                                                                                 
(0100) 
(0101)     //处理返回值，将SD_driver.c的返回值转成ff.c的返回值
(0102)     if(res == 0x00)
    002AA 20AA      TST	R10
    002AB F411      BNE	0x02AE
(0103)     {
(0104)         return RES_OK;
    002AC 2700      CLR	R16
    002AD C001      RJMP	0x02AF
(0105)     }
(0106)     else
(0107)     {
(0108)         return RES_ERROR;
    002AE E001      LDI	R16,1
    002AF 9622      ADIW	R28,2
    002B0 940C 3C61 JMP	pop_xgset30FC
_disk_write:
  count                --> R12
  sector               --> Y,+8
  buff                 --> R10
  drv                  --> R14
    002B2 940E 3C79 CALL	push_xgset00FC
    002B4 0159      MOVW	R10,R18
    002B5 2EE0      MOV	R14,R16
    002B6 9722      SBIW	R28,2
    002B7 84CC      LDD	R12,Y+12
(0109)     }
(0110) }
(0111) 
(0112) 
(0113) 
(0114) /*-----------------------------------------------------------------------*/
(0115) /* Write Sector(s)                                                       */
(0116) 
(0117) #if _READONLY == 0
(0118) DRESULT disk_write (
(0119) 	BYTE drv,			/* Physical drive nmuber (0..) */
(0120) 	BYTE *buff,	        /* Data to be written */
(0121) 	DWORD sector,		/* Sector address (LBA) */
(0122) 	BYTE count			/* Number of sectors to write (1..255) */
(0123) )
(0124) {
(0125)     if (drv || !count)
    002B8 20EE      TST	R14
    002B9 F411      BNE	0x02BC
    002BA 20CC      TST	R12
    002BB F411      BNE	0x02BE
(0126)     {    
(0127)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002BC E004      LDI	R16,4
    002BD C009      RJMP	0x02C7
(0128)     }   
(0129)    // 读写操作
(0130)     SD_Write_Sector(sector,buff);
    002BE 82B9      STD	Y+1,R11
    002BF 82A8      ST	Y,R10
    002C0 8508      LDD	R16,Y+8
    002C1 8519      LDD	R17,Y+9
    002C2 852A      LDD	R18,Y+10
    002C3 853B      LDD	R19,Y+11
    002C4 940E 295A CALL	_SD_Write_Sector
(0131) 	  
(0132)     return RES_OK;
    002C6 2700      CLR	R16
    002C7 9622      ADIW	R28,2
    002C8 940C 3C5A JMP	pop_xgset00FC
_disk_ioctl:
  buff                 --> Y,+4
  ctrl                 --> Y,+2
  drv                  --> Y,+0
    002CA 940E 3B30 CALL	push_arg4
(0133) }
(0134) #endif /* _READONLY */
(0135) 
(0136) 
(0137) 
(0138) /*-----------------------------------------------------------------------*/
(0139) /* Miscellaneous Functions                                               */
(0140) DRESULT disk_ioctl (
(0141) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0142) 	BYTE ctrl,		/* Control code */
(0143) 	void *buff		/* Buffer to send/receive control data */
(0144) )
(0145) {
(0146)  	drv=drv;
(0147) 	ctrl=ctrl;
(0148) 	buff=buff;
(0149) 	return 0;
    002CC 2700      CLR	R16
    002CD 9624      ADIW	R28,4
    002CE 9508      RET
(0150) }
(0151) DWORD get_fattime (void)
(0152) {
(0153) 
(0154)   return 1950466005;
_get_fattime:
    002CF ED05      LDI	R16,0xD5
    002D0 EB1F      LDI	R17,0xBF
    002D1 E421      LDI	R18,0x41
    002D2 E734      LDI	R19,0x74
    002D3 9508      RET
ff.c:mem_cpy:
  s                    --> R12
  d                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    002D4 940E 3CA2 CALL	push_xgset303C
    002D6 814E      LDD	R20,Y+6
    002D7 815F      LDD	R21,Y+7
FILE: D:\LQD\software\master\software_src\ff.c
(0001) /*----------------------------------------------------------------------------/
(0002) /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
(0003) /-----------------------------------------------------------------------------/
(0004) / FatFs module is a generic FAT file system module for small embedded systems.
(0005) / This is a free software that opened for education, research and commercial
(0006) / developments under license policy of following terms.
(0007) /
(0008) /  Copyright (C) 2011, ChaN, all right reserved.
(0009) /
(0010) / * The FatFs module is a free software and there is NO WARRANTY.
(0011) / * No restriction on use. You can use, modify and redistribute it for
(0012) /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
(0013) / * Redistributions of source code must retain the above copyright notice.
(0014) /
(0015) /-----------------------------------------------------------------------------/
(0016) / Feb 26,'06 R0.00  Prototype.
(0017) /
(0018) / Apr 29,'06 R0.01  First stable version.
(0019) /
(0020) / Jun 01,'06 R0.02  Added FAT12 support.
(0021) /                   Removed unbuffered mode.
(0022) /                   Fixed a problem on small (<32M) partition.
(0023) / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
(0024) /
(0025) / Sep 22,'06 R0.03  Added f_rename().
(0026) /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
(0027) / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
(0028) /                   Fixed f_mkdir() creates incorrect directory on FAT32.
(0029) /
(0030) / Feb 04,'07 R0.04  Supported multiple drive system.
(0031) /                   Changed some interfaces for multiple drive system.
(0032) /                   Changed f_mountdrv() to f_mount().
(0033) /                   Added f_mkfs().
(0034) / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
(0035) /                   Added a capability of extending file size to f_lseek().
(0036) /                   Added minimization level 3.
(0037) /                   Fixed an endian sensitive code in f_mkfs().
(0038) / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
(0039) /                   Added FSInfo support.
(0040) /                   Fixed DBCS name can result FR_INVALID_NAME.
(0041) /                   Fixed short seek (<= csize) collapses the file object.
(0042) /
(0043) / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
(0044) /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
(0045) /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
(0046) / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
(0047) /                   Fixed off by one error at FAT sub-type determination.
(0048) /                   Fixed btr in f_read() can be mistruncated.
(0049) /                   Fixed cached sector is not flushed when create and close without write.
(0050) /
(0051) / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
(0052) /                   Improved performance of f_lseek() on moving to the same or following cluster.
(0053) /
(0054) / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
(0055) /                   Added long file name feature.
(0056) /                   Added multiple code page feature.
(0057) /                   Added re-entrancy for multitask operation.
(0058) /                   Added auto cluster size selection to f_mkfs().
(0059) /                   Added rewind option to f_readdir().
(0060) /                   Changed result code of critical errors.
(0061) /                   Renamed string functions to avoid name collision.
(0062) / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
(0063) /                   Added multiple sector size feature.
(0064) / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
(0065) /                   Fixed wrong cache control in f_lseek().
(0066) /                   Added relative path feature.
(0067) /                   Added f_chdir() and f_chdrive().
(0068) /                   Added proper case conversion to extended char.
(0069) / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
(0070) /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
(0071) /                   Fixed name matching error on the 13 char boundary.
(0072) /                   Added a configuration option, _LFN_UNICODE.
(0073) /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
(0074) /
(0075) / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
(0076) /                   Added file lock feature. (_FS_SHARE)
(0077) /                   Added fast seek feature. (_USE_FASTSEEK)
(0078) /                   Changed some types on the API, XCHAR->TCHAR.
(0079) /                   Changed fname member in the FILINFO structure on Unicode cfg.
(0080) /                   String functions support UTF-8 encoding files on Unicode cfg.
(0081) / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
(0082) /                   Added sector erase feature. (_USE_ERASE)
(0083) /                   Moved file lock semaphore table from fs object to the bss.
(0084) /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
(0085) /                   Fixed f_mkfs() creates wrong FAT32 volume.
(0086) / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
(0087) /                   f_lseek() reports required table size on creating CLMP.
(0088) /                   Extended format syntax of f_printf function.
(0089) /                   Ignores duplicated directory separators in given path names.
(0090) /
(0091) / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
(0092) /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
(0093) /---------------------------------------------------------------------------*/
(0094) 
(0095) #include "ff.h"			/* FatFs configurations and declarations */
(0096) #include "diskio.h"		/* Declarations of low level disk I/O functions */
(0097) #include <string.h>
(0098) 
(0099) /*--------------------------------------------------------------------------
(0100) 
(0101)    Module Private Definitions
(0102) 
(0103) ---------------------------------------------------------------------------*/
(0104) 
(0105) #if _FATFS != 6502	/* Revision ID */
(0106) #error Wrong include file (ff.h).
(0107) #endif
(0108) 
(0109) 
(0110) /* Definitions on sector size */
(0111) #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
(0112) #error Wrong sector size.
(0113) #endif
(0114) #if _MAX_SS != 512
(0115) #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
(0116) #else
(0117) #define	SS(fs)	512U			/* Fixed sector size */
(0118) #endif
(0119) 
(0120) 
(0121) /* Reentrancy related */
(0122) #if _FS_REENTRANT
(0123) #if _USE_LFN == 1
(0124) #error Static LFN work area must not be used in re-entrant configuration.
(0125) #endif
(0126) #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
(0127) #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
(0128) #else
(0129) #define	ENTER_FF(fs)
(0130) #define LEAVE_FF(fs, res)	return res
(0131) #endif
(0132) 
(0133) #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
(0134) 
(0135) 
(0136) /* File shareing feature */
(0137) #if _FS_SHARE
(0138) #if _FS_READONLY
(0139) #error _FS_SHARE must be 0 on read-only cfg.
(0140) #endif
(0141) typedef struct {
(0142) 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
(0143) 	DWORD clu;				/* File ID 2, directory */
(0144) 	WORD idx;				/* File ID 3, directory index */
(0145) 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
(0146) } FILESEM;
(0147) #endif
(0148) 
(0149) 
(0150) /* Misc definitions */
(0151) #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
(0152) #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
(0153) 
(0154) 
(0155) /* DBCS code ranges and SBCS extend char conversion table */
(0156) 
(0157) #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
(0158) #define _DF1S	0x81	/* DBC 1st byte range 1 start */
(0159) #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
(0160) #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
(0161) #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
(0162) #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
(0163) #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
(0164) #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
(0165) #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
(0166) 
(0167) #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
(0168) #define _DF1S	0x81
(0169) #define _DF1E	0xFE
(0170) #define _DS1S	0x40
(0171) #define _DS1E	0x7E
(0172) #define _DS2S	0x80
(0173) #define _DS2E	0xFE
(0174) 
(0175) #elif _CODE_PAGE == 949	/* Korean */
(0176) #define _DF1S	0x81
(0177) #define _DF1E	0xFE
(0178) #define _DS1S	0x41
(0179) #define _DS1E	0x5A
(0180) #define _DS2S	0x61
(0181) #define _DS2E	0x7A
(0182) #define _DS3S	0x81
(0183) #define _DS3E	0xFE
(0184) 
(0185) #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
(0186) #define _DF1S	0x81
(0187) #define _DF1E	0xFE
(0188) #define _DS1S	0x40
(0189) #define _DS1E	0x7E
(0190) #define _DS2S	0xA1
(0191) #define _DS2E	0xFE
(0192) 
(0193) #elif _CODE_PAGE == 437	/* U.S. (OEM) */
(0194) #define _DF1S	0
(0195) #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0196) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0197) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0198) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0199) 
(0200) #elif _CODE_PAGE == 720	/* Arabic (OEM) */
(0201) #define _DF1S	0
(0202) #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0203) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0204) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0205) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0206) 
(0207) #elif _CODE_PAGE == 737	/* Greek (OEM) */
(0208) #define _DF1S	0
(0209) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
(0210) 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0211) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0212) 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0213) 
(0214) #elif _CODE_PAGE == 775	/* Baltic (OEM) */
(0215) #define _DF1S	0
(0216) #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0217) 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0218) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0219) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0220) 
(0221) #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
(0222) #define _DF1S	0
(0223) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0224) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0225) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0226) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0227) 
(0228) #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
(0229) #define _DF1S	0
(0230) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
(0231) 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
(0232) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0233) 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
(0234) 
(0235) #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
(0236) #define _DF1S	0
(0237) #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
(0238) 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
(0239) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
(0240) 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
(0241) 
(0242) #elif _CODE_PAGE == 857	/* Turkish (OEM) */
(0243) #define _DF1S	0
(0244) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
(0245) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0246) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0247) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0248) 
(0249) #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
(0250) #define _DF1S	0
(0251) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0252) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0253) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0254) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0255) 
(0256) #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
(0257) #define _DF1S	0
(0258) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0259) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0260) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0261) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0262) 
(0263) #elif _CODE_PAGE == 866	/* Russian (OEM) */
(0264) #define _DF1S	0
(0265) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0266) 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0267) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0268) 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0269) 
(0270) #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
(0271) #define _DF1S	0
(0272) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0273) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0274) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0275) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0276) 
(0277) #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
(0278) #define _DF1S	0
(0279) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0280) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
(0281) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0282) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0283) 
(0284) #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
(0285) #define _DF1S	0
(0286) #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0287) 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
(0288) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0289) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
(0290) 
(0291) #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
(0292) #define _DF1S	0
(0293) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
(0294) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0295) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0296) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0297) 
(0298) #elif _CODE_PAGE == 1253 /* Greek (Windows) */
(0299) #define _DF1S	0
(0300) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0301) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0302) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
(0303) 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
(0304) 
(0305) #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
(0306) #define _DF1S	0
(0307) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0308) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0309) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0310) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0311) 
(0312) #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
(0313) #define _DF1S	0
(0314) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0315) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0316) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0317) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0318) 
(0319) #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
(0320) #define _DF1S	0
(0321) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0322) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0323) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0324) 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
(0325) 
(0326) #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
(0327) #define _DF1S	0
(0328) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0329) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
(0330) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0331) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0332) 
(0333) #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
(0334) #define _DF1S	0
(0335) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
(0336) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0337) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0338) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
(0339) 
(0340) #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
(0341) #if _USE_LFN
(0342) #error Cannot use LFN feature without valid code page.
(0343) #endif
(0344) #define _DF1S	0
(0345) 
(0346) #else
(0347) #error Unknown code page
(0348) 
(0349) #endif
(0350) 
(0351) 
(0352) /* Character code support macros */
(0353) #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
(0354) #define IsLower(c)	(((c)>='a')&&((c)<='z'))
(0355) #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
(0356) 
(0357) #if _DF1S		/* Code page is DBCS */
(0358) 
(0359) #ifdef _DF2S	/* Two 1st byte areas */
(0360) #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
(0361) #else			/* One 1st byte area */
(0362) #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
(0363) #endif
(0364) 
(0365) #ifdef _DS3S	/* Three 2nd byte areas */
(0366) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
(0367) #else			/* Two 2nd byte areas */
(0368) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
(0369) #endif
(0370) 
(0371) #else			/* Code page is SBCS */
(0372) 
(0373) #define IsDBCS1(c)	0
(0374) #define IsDBCS2(c)	0
(0375) 
(0376) #endif /* _DF1S */
(0377) 
(0378) 
(0379) /* Name status flags */
(0380) #define NS			11		/* Index of name status byte in fn[] */
(0381) #define NS_LOSS		0x01	/* Out of 8.3 format */
(0382) #define NS_LFN		0x02	/* Force to create LFN entry */
(0383) #define NS_LAST		0x04	/* Last segment */
(0384) #define NS_BODY		0x08	/* Lower case flag (body) */
(0385) #define NS_EXT		0x10	/* Lower case flag (ext) */
(0386) #define NS_DOT		0x20	/* Dot entry */
(0387) 
(0388) 
(0389) /* FAT sub-type boundaries */
(0390) /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
(0391) #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
(0392) #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
(0393) 
(0394) 
(0395) /* FatFs refers the members in the FAT structures as byte array instead of
(0396) / structure member because the structure is not binary compatible between
(0397) / different platforms */
(0398) 
(0399) #define BS_jmpBoot			0	/* Jump instruction (3) */
(0400) #define BS_OEMName			3	/* OEM name (8) */
(0401) #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
(0402) #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
(0403) #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
(0404) #define BPB_NumFATs			16	/* Number of FAT copies (1) */
(0405) #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
(0406) #define BPB_TotSec16		19	/* Volume size [sector] (2) */
(0407) #define BPB_Media			21	/* Media descriptor (1) */
(0408) #define BPB_FATSz16			22	/* FAT size [sector] (2) */
(0409) #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
(0410) #define BPB_NumHeads		26	/* Number of heads (2) */
(0411) #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
(0412) #define BPB_TotSec32		32	/* Volume size [sector] (4) */
(0413) #define BS_DrvNum			36	/* Physical drive number (2) */
(0414) #define BS_BootSig			38	/* Extended boot signature (1) */
(0415) #define BS_VolID			39	/* Volume serial number (4) */
(0416) #define BS_VolLab			43	/* Volume label (8) */
(0417) #define BS_FilSysType		54	/* File system type (1) */
(0418) #define BPB_FATSz32			36	/* FAT size [sector] (4) */
(0419) #define BPB_ExtFlags		40	/* Extended flags (2) */
(0420) #define BPB_FSVer			42	/* File system version (2) */
(0421) #define BPB_RootClus		44	/* Root dir first cluster (4) */
(0422) #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
(0423) #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
(0424) #define BS_DrvNum32			64	/* Physical drive number (2) */
(0425) #define BS_BootSig32		66	/* Extended boot signature (1) */
(0426) #define BS_VolID32			67	/* Volume serial number (4) */
(0427) #define BS_VolLab32			71	/* Volume label (8) */
(0428) #define BS_FilSysType32		82	/* File system type (1) */
(0429) #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
(0430) #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
(0431) #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
(0432) #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
(0433) #define MBR_Table			446	/* MBR: Partition table offset (2) */
(0434) #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
(0435) #define BS_55AA				510	/* Boot sector signature (2) */
(0436) 
(0437) #define	DIR_Name			0	/* Short file name (11) */
(0438) #define	DIR_Attr			11	/* Attribute (1) */
(0439) #define	DIR_NTres			12	/* NT flag (1) */
(0440) #define	DIR_CrtTime			14	/* Created time (2) */
(0441) #define	DIR_CrtDate			16	/* Created date (2) */
(0442) #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
(0443) #define	DIR_WrtTime			22	/* Modified time (2) */
(0444) #define	DIR_WrtDate			24	/* Modified date (2) */
(0445) #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
(0446) #define	DIR_FileSize		28	/* File size (4) */
(0447) #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
(0448) #define	LDIR_Attr			11	/* LFN attribute (1) */
(0449) #define	LDIR_Type			12	/* LFN type (1) */
(0450) #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
(0451) #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
(0452) #define	SZ_DIR				32		/* Size of a directory entry */
(0453) #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
(0454) #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
(0455) #define	NDDE				0x05	/* Replacement of a character collides with DDE */
(0456) 
(0457) 
(0458) /*------------------------------------------------------------*/
(0459) /* Module private work area                                   */
(0460) /*------------------------------------------------------------*/
(0461) /* Note that uninitialized variables with static duration are
(0462) /  zeroed/nulled at start-up. If not, the compiler or start-up
(0463) /  routine is out of ANSI-C standard.
(0464) */
(0465) 
(0466) #if _VOLUMES
(0467) static
(0468) FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
(0469) #else
(0470) #error Number of volumes must not be 0.
(0471) #endif
(0472) 
(0473) static
(0474) WORD Fsid;				/* File system mount ID */
(0475) 
(0476) #if _FS_RPATH
(0477) static
(0478) BYTE CurrVol;			/* Current drive */
(0479) #endif
(0480) 
(0481) #if _FS_SHARE
(0482) static
(0483) FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
(0484) #endif
(0485) 
(0486) #if _USE_LFN == 0			/* No LFN feature */
(0487) #define	DEF_NAMEBUF			BYTE sfn[12]
(0488) #define INIT_BUF(dobj)		(dobj).fn = sfn
(0489) #define	FREE_BUF()
(0490) 
(0491) #elif _USE_LFN == 1			/* LFN feature with static working buffer */
(0492) static WCHAR LfnBuf[_MAX_LFN+1];
(0493) #define	DEF_NAMEBUF			BYTE sfn[12]
(0494) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
(0495) #define	FREE_BUF()
(0496) 
(0497) #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
(0498) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
(0499) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
(0500) #define	FREE_BUF()
(0501) 
(0502) #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
(0503) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
(0504) #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
(0505) 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
(0506) 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
(0507) #define	FREE_BUF()			ff_memfree(lfn)
(0508) 
(0509) #else
(0510) #error Wrong LFN configuration.
(0511) #endif
(0512) 
(0513) 
(0514) 
(0515) 
(0516) /*--------------------------------------------------------------------------
(0517) 
(0518)    Module Private Functions
(0519) 
(0520) ---------------------------------------------------------------------------*/
(0521) 
(0522) 
(0523) /*-----------------------------------------------------------------------*/
(0524) /* String functions                                                      */
(0525) /*-----------------------------------------------------------------------*/
(0526) 
(0527) /* Copy memory to memory */
(0528) static
(0529) void mem_cpy (void* dst, const void* src, UINT cnt) {
(0530) 	BYTE *d = (BYTE*)dst;
    002D8 0158      MOVW	R10,R16
(0531) 	const BYTE *s = (const BYTE*)src;
    002D9 0169      MOVW	R12,R18
    002DA C006      RJMP	0x02E1
(0532) 
(0533) #if _WORD_ACCESS == 1
(0534) 	while (cnt >= sizeof(int)) {
(0535) 		*(int*)d = *(int*)s;
(0536) 		d += sizeof(int); s += sizeof(int);
(0537) 		cnt -= sizeof(int);
(0538) 	}
(0539) #endif
(0540) 	while (cnt--)
(0541) 		*d++ = *s++;
    002DB 01F6      MOVW	R30,R12
    002DC 01D5      MOVW	R26,R10
    002DD 9001      LD	R0,Z+
    002DE 016F      MOVW	R12,R30
    002DF 920D      ST	X+,R0
    002E0 015D      MOVW	R10,R26
    002E1 011A      MOVW	R2,R20
    002E2 5041      SUBI	R20,1
    002E3 4050      SBCI	R21,0
    002E4 2022      TST	R2
    002E5 F7A9      BNE	0x02DB
    002E6 2033      TST	R3
    002E7 F799      BNE	0x02DB
    002E8 940C 3CA9 JMP	pop_xgset303C
ff.c:mem_set:
  d                    --> R10
  cnt                  --> R20
  val                  --> R18
  dst                  --> R16
    002EA 940E 3C80 CALL	push_xgset300C
    002EC 814C      LDD	R20,Y+4
    002ED 815D      LDD	R21,Y+5
(0542) }
(0543) 
(0544) /* Fill memory */
(0545) static
(0546) void mem_set (void* dst, int val, UINT cnt) {
(0547) 	BYTE *d = (BYTE*)dst;
    002EE 0158      MOVW	R10,R16
    002EF C003      RJMP	0x02F3
(0548) 
(0549) 	while (cnt--)
(0550) 		*d++ = (BYTE)val;
    002F0 01F5      MOVW	R30,R10
    002F1 9321      ST	Z+,R18
    002F2 015F      MOVW	R10,R30
    002F3 011A      MOVW	R2,R20
    002F4 5041      SUBI	R20,1
    002F5 4050      SBCI	R21,0
    002F6 2022      TST	R2
    002F7 F7C1      BNE	0x02F0
    002F8 2033      TST	R3
    002F9 F7B1      BNE	0x02F0
    002FA 940C 3C85 JMP	pop_xgset300C
ff.c:mem_cmp:
  s                    --> R14
  d                    --> R12
  r                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    002FC 940E 3C77 CALL	push_xgset30FC
    002FE 8548      LDD	R20,Y+8
    002FF 8559      LDD	R21,Y+9
(0551) }
(0552) 
(0553) /* Compare memory to memory */
(0554) static
(0555) int mem_cmp (const void* dst, const void* src, UINT cnt) {
(0556) 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    00300 0168      MOVW	R12,R16
    00301 0179      MOVW	R14,R18
(0557) 	int r = 0;
    00302 24AA      CLR	R10
    00303 24BB      CLR	R11
(0558) 
(0559) 	while (cnt-- && (r = *d++ - *s++) == 0) ;
    00304 011A      MOVW	R2,R20
    00305 5041      SUBI	R20,1
    00306 4050      SBCI	R21,0
    00307 2022      TST	R2
    00308 F411      BNE	0x030B
    00309 2033      TST	R3
    0030A F079      BEQ	0x031A
    0030B 01F7      MOVW	R30,R14
    0030C 9021      LD	R2,Z+
    0030D 017F      MOVW	R14,R30
    0030E 2433      CLR	R3
    0030F 01F6      MOVW	R30,R12
    00310 9041      LD	R4,Z+
    00311 016F      MOVW	R12,R30
    00312 2455      CLR	R5
    00313 1842      SUB	R4,R2
    00314 0853      SBC	R5,R3
    00315 0152      MOVW	R10,R4
    00316 20AA      TST	R10
    00317 F411      BNE	0x031A
    00318 20BB      TST	R11
    00319 F351      BEQ	0x0304
(0560) 	return r;
    0031A 0185      MOVW	R16,R10
    0031B 940C 3C61 JMP	pop_xgset30FC
(0561) }
(0562) 
(0563) /* Check if chr is contained in the string */
(0564) static
(0565) int chk_chr (const char* str, int chr) {
ff.c:chk_chr:
  chr                  --> R18
  str                  --> R16
    0031D C002      RJMP	0x0320
(0566) 	while (*str && *str != chr) str++;
    0031E 5F0F      SUBI	R16,0xFF
    0031F 4F1F      SBCI	R17,0xFF
    00320 01F8      MOVW	R30,R16
    00321 8020      LD	R2,Z
    00322 2433      CLR	R3
    00323 2022      TST	R2
    00324 F021      BEQ	0x0329
    00325 2433      CLR	R3
    00326 1622      CP	R2,R18
    00327 0633      CPC	R3,R19
    00328 F7A9      BNE	0x031E
(0567) 	return *str;
    00329 01F8      MOVW	R30,R16
    0032A 8100      LD	R16,Z
    0032B 2711      CLR	R17
    0032C 9508      RET
ff.c:move_window:
  nf                   --> R10
  wsect                --> Y,+5
  sector               --> Y,+13
  fs                   --> R20
    0032D 933A      ST	-Y,R19
    0032E 932A      ST	-Y,R18
    0032F 940E 3C80 CALL	push_xgset300C
    00331 01A8      MOVW	R20,R16
    00332 9729      SBIW	R28,0x9
(0568) }
(0569) 
(0570) 
(0571) 
(0572) /*-----------------------------------------------------------------------*/
(0573) /* Request/Release grant to access the volume                            */
(0574) /*-----------------------------------------------------------------------*/
(0575) #if _FS_REENTRANT
(0576) 
(0577) static
(0578) int lock_fs (
(0579) 	FATFS *fs		/* File system object */
(0580) )
(0581) {
(0582) 	return ff_req_grant(fs->sobj);
(0583) }
(0584) 
(0585) 
(0586) static
(0587) void unlock_fs (
(0588) 	FATFS *fs,		/* File system object */
(0589) 	FRESULT res		/* Result code to be returned */
(0590) )
(0591) {
(0592) 	if (res != FR_NOT_ENABLED &&
(0593) 		res != FR_INVALID_DRIVE &&
(0594) 		res != FR_INVALID_OBJECT &&
(0595) 		res != FR_TIMEOUT) {
(0596) 		ff_rel_grant(fs->sobj);
(0597) 	}
(0598) }
(0599) #endif
(0600) 
(0601) 
(0602) 
(0603) /*-----------------------------------------------------------------------*/
(0604) /* File shareing control functions                                       */
(0605) /*-----------------------------------------------------------------------*/
(0606) #if _FS_SHARE
(0607) 
(0608) static
(0609) FRESULT chk_lock (	/* Check if the file can be accessed */
(0610) 	DIR* dj,		/* Directory object pointing the file to be checked */
(0611) 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
(0612) )
(0613) {
(0614) 	UINT i, be;
(0615) 
(0616) 	/* Search file semaphore table */
(0617) 	for (i = be = 0; i < _FS_SHARE; i++) {
(0618) 		if (Files[i].fs) {	/* Existing entry */
(0619) 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
(0620) 				Files[i].clu == dj->sclust &&
(0621) 				Files[i].idx == dj->index) break;
(0622) 		} else {			/* Blank entry */
(0623) 			be++;
(0624) 		}
(0625) 	}
(0626) 	if (i == _FS_SHARE)	/* The file is not opened */
(0627) 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
(0628) 
(0629) 	/* The file has been opened. Reject any open against writing file and all write mode open */
(0630) 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
(0631) }
(0632) 
(0633) 
(0634) static
(0635) int enq_lock (void)	/* Check if an entry is available for a new file */
(0636) {
(0637) 	UINT i;
(0638) 
(0639) 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0640) 	return (i == _FS_SHARE) ? 0 : 1;
(0641) }
(0642) 
(0643) 
(0644) static
(0645) UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
(0646) 	DIR* dj,	/* Directory object pointing the file to register or increment */
(0647) 	int acc		/* Desired access mode (0:Read, !0:Write) */
(0648) )
(0649) {
(0650) 	UINT i;
(0651) 
(0652) 
(0653) 	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
(0654) 		if (Files[i].fs == dj->fs &&
(0655) 			Files[i].clu == dj->sclust &&
(0656) 			Files[i].idx == dj->index) break;
(0657) 	}
(0658) 
(0659) 	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
(0660) 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0661) 		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
(0662) 		Files[i].fs = dj->fs;
(0663) 		Files[i].clu = dj->sclust;
(0664) 		Files[i].idx = dj->index;
(0665) 		Files[i].ctr = 0;
(0666) 	}
(0667) 
(0668) 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
(0669) 
(0670) 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
(0671) 
(0672) 	return i + 1;
(0673) }
(0674) 
(0675) 
(0676) static
(0677) FRESULT dec_lock (	/* Decrement file open counter */
(0678) 	UINT i			/* Semaphore index */
(0679) )
(0680) {
(0681) 	WORD n;
(0682) 	FRESULT res;
(0683) 
(0684) 
(0685) 	if (--i < _FS_SHARE) {
(0686) 		n = Files[i].ctr;
(0687) 		if (n == 0x100) n = 0;
(0688) 		if (n) n--;
(0689) 		Files[i].ctr = n;
(0690) 		if (!n) Files[i].fs = 0;
(0691) 		res = FR_OK;
(0692) 	} else {
(0693) 		res = FR_INT_ERR;
(0694) 	}
(0695) 	return res;
(0696) }
(0697) 
(0698) 
(0699) static
(0700) void clear_lock (	/* Clear lock entries of the volume */
(0701) 	FATFS *fs
(0702) )
(0703) {
(0704) 	UINT i;
(0705) 
(0706) 	for (i = 0; i < _FS_SHARE; i++) {
(0707) 		if (Files[i].fs == fs) Files[i].fs = 0;
(0708) 	}
(0709) }
(0710) #endif
(0711) 
(0712) 
(0713) 
(0714) /*-----------------------------------------------------------------------*/
(0715) /* Change window offset                                                  */
(0716) /*-----------------------------------------------------------------------*/
(0717) 
(0718) static
(0719) FRESULT move_window (
(0720) 	FATFS *fs,		/* File system object */
(0721) 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
(0722) )					/* Move to zero only writes back dirty window */
(0723) {
(0724) 	DWORD wsect;
(0725) 
(0726) 
(0727) 	wsect = fs->winsect;
    00333 01FA      MOVW	R30,R20
    00334 96BA      ADIW	R30,0x2A
    00335 8020      LD	R2,Z
    00336 8031      LDD	R3,Z+1
    00337 8042      LDD	R4,Z+2
    00338 8053      LDD	R5,Z+3
    00339 822D      STD	Y+5,R2
    0033A 823E      STD	Y+6,R3
    0033B 824F      STD	Y+7,R4
    0033C 8658      STD	Y+8,R5
(0728) 	if (wsect != sector) {	/* Changed current window */
    0033D 842D      LDD	R2,Y+13
    0033E 843E      LDD	R3,Y+14
    0033F 844F      LDD	R4,Y+15
    00340 8858      LDD	R5,Y+16
    00341 806D      LDD	R6,Y+5
    00342 807E      LDD	R7,Y+6
    00343 808F      LDD	R8,Y+7
    00344 8498      LDD	R9,Y+8
    00345 1462      CP	R6,R2
    00346 0473      CPC	R7,R3
    00347 0484      CPC	R8,R4
    00348 0495      CPC	R9,R5
    00349 F409      BNE	0x034B
    0034A C07E      RJMP	0x03C9
(0729) #if !_FS_READONLY
(0730) 		if (fs->wflag) {	/* Write back dirty window if needed */
    0034B 01FA      MOVW	R30,R20
    0034C 8024      LDD	R2,Z+4
    0034D 2022      TST	R2
    0034E F409      BNE	0x0350
    0034F C055      RJMP	0x03A5
(0731) 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    00350 E081      LDI	R24,1
    00351 838C      STD	Y+4,R24
    00352 0113      MOVW	R2,R6
    00353 0124      MOVW	R4,R8
    00354 8228      ST	Y,R2
    00355 8239      STD	Y+1,R3
    00356 824A      STD	Y+2,R4
    00357 825B      STD	Y+3,R5
    00358 019A      MOVW	R18,R20
    00359 5D22      SUBI	R18,0xD2
    0035A 4F3F      SBCI	R19,0xFF
    0035B 8101      LDD	R16,Z+1
    0035C 940E 02B2 CALL	_disk_write
    0035E 2300      TST	R16
    0035F F011      BEQ	0x0362
(0732) 				return FR_DISK_ERR;
    00360 E001      LDI	R16,1
    00361 C068      RJMP	0x03CA
(0733) 			fs->wflag = 0;
    00362 2422      CLR	R2
    00363 01FA      MOVW	R30,R20
    00364 8224      STD	Z+4,R2
(0734) 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    00365 8C22      LDD	R2,Z+26
    00366 8C33      LDD	R3,Z+27
    00367 8C44      LDD	R4,Z+28
    00368 8C55      LDD	R5,Z+29
    00369 967E      ADIW	R30,0x1E
    0036A 8060      LD	R6,Z
    0036B 8071      LDD	R7,Z+1
    0036C 8082      LDD	R8,Z+2
    0036D 8093      LDD	R9,Z+3
    0036E 0C62      ADD	R6,R2
    0036F 1C73      ADC	R7,R3
    00370 1C84      ADC	R8,R4
    00371 1C95      ADC	R9,R5
    00372 802D      LDD	R2,Y+5
    00373 803E      LDD	R3,Y+6
    00374 804F      LDD	R4,Y+7
    00375 8458      LDD	R5,Y+8
    00376 1426      CP	R2,R6
    00377 0437      CPC	R3,R7
    00378 0448      CPC	R4,R8
    00379 0459      CPC	R5,R9
    0037A F550      BCC	0x03A5
(0735) 				BYTE nf;
(0736) 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    0037B 01FA      MOVW	R30,R20
    0037C 80A3      LDD	R10,Z+3
    0037D C024      RJMP	0x03A2
(0737) 					wsect += fs->fsize;
    0037E 01FA      MOVW	R30,R20
    0037F 967A      ADIW	R30,0x1A
    00380 8020      LD	R2,Z
    00381 8031      LDD	R3,Z+1
    00382 8042      LDD	R4,Z+2
    00383 8053      LDD	R5,Z+3
    00384 806D      LDD	R6,Y+5
    00385 807E      LDD	R7,Y+6
    00386 808F      LDD	R8,Y+7
    00387 8498      LDD	R9,Y+8
    00388 0C62      ADD	R6,R2
    00389 1C73      ADC	R7,R3
    0038A 1C84      ADC	R8,R4
    0038B 1C95      ADC	R9,R5
    0038C 826D      STD	Y+5,R6
    0038D 827E      STD	Y+6,R7
    0038E 828F      STD	Y+7,R8
    0038F 8698      STD	Y+8,R9
(0738) 					disk_write(fs->drv, fs->win, wsect, 1);
    00390 E081      LDI	R24,1
    00391 838C      STD	Y+4,R24
    00392 802D      LDD	R2,Y+5
    00393 803E      LDD	R3,Y+6
    00394 804F      LDD	R4,Y+7
    00395 8458      LDD	R5,Y+8
    00396 8228      ST	Y,R2
    00397 8239      STD	Y+1,R3
    00398 824A      STD	Y+2,R4
    00399 825B      STD	Y+3,R5
    0039A 019A      MOVW	R18,R20
    0039B 5D22      SUBI	R18,0xD2
    0039C 4F3F      SBCI	R19,0xFF
    0039D 01FA      MOVW	R30,R20
    0039E 8101      LDD	R16,Z+1
    0039F 940E 02B2 CALL	_disk_write
    003A1 94AA      DEC	R10
    003A2 E081      LDI	R24,1
    003A3 158A      CP	R24,R10
    003A4 F2C8      BCS	0x037E
(0739) 				}
(0740) 			}
(0741) 		}
(0742) #endif
(0743) 		if (sector) {
    003A5 842D      LDD	R2,Y+13
    003A6 843E      LDD	R3,Y+14
    003A7 844F      LDD	R4,Y+15
    003A8 8858      LDD	R5,Y+16
    003A9 9488      BCLR	0
    003AA 2022      TST	R2
    003AB 0432      CPC	R3,R2
    003AC 0442      CPC	R4,R2
    003AD 0452      CPC	R5,R2
    003AE F0D1      BEQ	0x03C9
(0744) 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    003AF E081      LDI	R24,1
    003B0 838C      STD	Y+4,R24
    003B1 8228      ST	Y,R2
    003B2 8239      STD	Y+1,R3
    003B3 824A      STD	Y+2,R4
    003B4 825B      STD	Y+3,R5
    003B5 019A      MOVW	R18,R20
    003B6 5D22      SUBI	R18,0xD2
    003B7 4F3F      SBCI	R19,0xFF
    003B8 01FA      MOVW	R30,R20
    003B9 8101      LDD	R16,Z+1
    003BA 940E 0292 CALL	_disk_read
    003BC 2300      TST	R16
    003BD F011      BEQ	0x03C0
(0745) 				return FR_DISK_ERR;
    003BE E001      LDI	R16,1
    003BF C00A      RJMP	0x03CA
(0746) 			fs->winsect = sector;
    003C0 842D      LDD	R2,Y+13
    003C1 843E      LDD	R3,Y+14
    003C2 844F      LDD	R4,Y+15
    003C3 8858      LDD	R5,Y+16
    003C4 01FA      MOVW	R30,R20
    003C5 A622      STD	Z+42,R2
    003C6 A633      STD	Z+43,R3
    003C7 A644      STD	Z+44,R4
    003C8 A655      STD	Z+45,R5
(0747) 		}
(0748) 	}
(0749) 
(0750) 	return FR_OK;
    003C9 2700      CLR	R16
    003CA 9629      ADIW	R28,0x9
    003CB 940E 3C85 CALL	pop_xgset300C
    003CD 9622      ADIW	R28,2
    003CE 9508      RET
ff.c:sync:
  res                  --> R20
  fs                   --> R22
    003CF 940E 3C8A CALL	push_xgsetF000
    003D1 01B8      MOVW	R22,R16
    003D2 9725      SBIW	R28,5
(0751) }
(0752) 
(0753) 
(0754) 
(0755) 
(0756) /*-----------------------------------------------------------------------*/
(0757) /* Clean-up cached data                                                  */
(0758) /*-----------------------------------------------------------------------*/
(0759) #if !_FS_READONLY
(0760) static
(0761) FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
(0762) 	FATFS *fs	/* File system object */
(0763) )
(0764) {
(0765) 	FRESULT res;
(0766) 
(0767) 
(0768) 	res = move_window(fs, 0);
    003D3 E080      LDI	R24,0
    003D4 E090      LDI	R25,0
    003D5 E0A0      LDI	R26,0
    003D6 E0B0      LDI	R27,0
    003D7 83A8      ST	Y,R26
    003D8 83B9      STD	Y+1,R27
    003D9 019C      MOVW	R18,R24
    003DA 018B      MOVW	R16,R22
    003DB DF51      RCALL	ff.c:move_window
    003DC 2F40      MOV	R20,R16
(0769) 	if (res == FR_OK) {
    003DD 2300      TST	R16
    003DE F009      BEQ	0x03E0
    003DF C0C0      RJMP	0x04A0
(0770) 		/* Update FSInfo sector if needed */
(0771) 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    003E0 01FB      MOVW	R30,R22
    003E1 8180      LD	R24,Z
    003E2 3083      CPI	R24,3
    003E3 F009      BEQ	0x03E5
    003E4 C0AC      RJMP	0x0491
    003E5 8025      LDD	R2,Z+5
    003E6 2022      TST	R2
    003E7 F409      BNE	0x03E9
    003E8 C0A8      RJMP	0x0491
(0772) 			fs->winsect = 0;
    003E9 96BA      ADIW	R30,0x2A
    003EA E080      LDI	R24,0
    003EB 8380      ST	Z,R24
    003EC 8381      STD	Z+1,R24
    003ED 8382      STD	Z+2,R24
    003EE 8383      STD	Z+3,R24
(0773) 			/* Create FSInfo structure */
(0774) 			mem_set(fs->win, 0, 512);
    003EF E080      LDI	R24,0
    003F0 E092      LDI	R25,2
    003F1 8399      STD	Y+1,R25
    003F2 8388      ST	Y,R24
    003F3 2722      CLR	R18
    003F4 2733      CLR	R19
    003F5 018B      MOVW	R16,R22
    003F6 5D02      SUBI	R16,0xD2
    003F7 4F1F      SBCI	R17,0xFF
    003F8 DEF1      RCALL	ff.c:mem_set
(0775) 			ST_WORD(fs->win+BS_55AA, 0xAA55);
    003F9 E585      LDI	R24,0x55
    003FA 01FB      MOVW	R30,R22
    003FB 5DE4      SUBI	R30,0xD4
    003FC 4FFD      SBCI	R31,0xFD
    003FD 8380      ST	Z,R24
    003FE 52EC      SUBI	R30,0x2C
    003FF 40F2      SBCI	R31,2
    00400 EA8A      LDI	R24,0xAA
    00401 5DE3      SUBI	R30,0xD3
    00402 4FFD      SBCI	R31,0xFD
    00403 8380      ST	Z,R24
    00404 52ED      SUBI	R30,0x2D
    00405 40F2      SBCI	R31,2
(0776) 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    00406 E582      LDI	R24,0x52
    00407 A786      STD	Z+46,R24
    00408 A787      STD	Z+47,R24
    00409 E681      LDI	R24,0x61
    0040A AB80      STD	Z+48,R24
    0040B E481      LDI	R24,0x41
    0040C AB81      STD	Z+49,R24
(0777) 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    0040D E782      LDI	R24,0x72
    0040E 5EEE      SUBI	R30,0xEE
    0040F 4FFD      SBCI	R31,0xFD
    00410 8380      ST	Z,R24
    00411 51E2      SUBI	R30,0x12
    00412 40F2      SBCI	R31,2
    00413 5EED      SUBI	R30,0xED
    00414 4FFD      SBCI	R31,0xFD
    00415 8380      ST	Z,R24
    00416 51E3      SUBI	R30,0x13
    00417 40F2      SBCI	R31,2
    00418 E481      LDI	R24,0x41
    00419 5EEC      SUBI	R30,0xEC
    0041A 4FFD      SBCI	R31,0xFD
    0041B 8380      ST	Z,R24
    0041C 51E4      SUBI	R30,0x14
    0041D 40F2      SBCI	R31,2
    0041E E681      LDI	R24,0x61
    0041F 5EEB      SUBI	R30,0xEB
    00420 4FFD      SBCI	R31,0xFD
    00421 8380      ST	Z,R24
    00422 51E5      SUBI	R30,0x15
    00423 40F2      SBCI	R31,2
(0778) 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    00424 8426      LDD	R2,Z+14
    00425 8437      LDD	R3,Z+15
    00426 8840      LDD	R4,Z+16
    00427 8851      LDD	R5,Z+17
    00428 5EEA      SUBI	R30,0xEA
    00429 4FFD      SBCI	R31,0xFD
    0042A 8220      ST	Z,R2
    0042B 51E6      SUBI	R30,0x16
    0042C 40F2      SBCI	R31,2
    0042D 8426      LDD	R2,Z+14
    0042E 8437      LDD	R3,Z+15
    0042F 2C23      MOV	R2,R3
    00430 2433      CLR	R3
    00431 5EE9      SUBI	R30,0xE9
    00432 4FFD      SBCI	R31,0xFD
    00433 8220      ST	Z,R2
    00434 51E7      SUBI	R30,0x17
    00435 40F2      SBCI	R31,2
    00436 8426      LDD	R2,Z+14
    00437 8437      LDD	R3,Z+15
    00438 8840      LDD	R4,Z+16
    00439 8851      LDD	R5,Z+17
    0043A 0112      MOVW	R2,R4
    0043B 2444      CLR	R4
    0043C 2455      CLR	R5
    0043D 5EE8      SUBI	R30,0xE8
    0043E 4FFD      SBCI	R31,0xFD
    0043F 8220      ST	Z,R2
    00440 51E8      SUBI	R30,0x18
    00441 40F2      SBCI	R31,2
    00442 E188      LDI	R24,0x18
    00443 E090      LDI	R25,0
    00444 8506      LDD	R16,Z+14
    00445 8517      LDD	R17,Z+15
    00446 8920      LDD	R18,Z+16
    00447 8931      LDD	R19,Z+17
    00448 938A      ST	-Y,R24
    00449 940E 3D10 CALL	lsr32
    0044B 01FB      MOVW	R30,R22
    0044C 5EE7      SUBI	R30,0xE7
    0044D 4FFD      SBCI	R31,0xFD
    0044E 8300      ST	Z,R16
    0044F 51E9      SUBI	R30,0x19
    00450 40F2      SBCI	R31,2
(0779) 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    00451 8422      LDD	R2,Z+10
    00452 8433      LDD	R3,Z+11
    00453 8444      LDD	R4,Z+12
    00454 8455      LDD	R5,Z+13
    00455 5EE6      SUBI	R30,0xE6
    00456 4FFD      SBCI	R31,0xFD
    00457 8220      ST	Z,R2
    00458 51EA      SUBI	R30,0x1A
    00459 40F2      SBCI	R31,2
    0045A 8422      LDD	R2,Z+10
    0045B 8433      LDD	R3,Z+11
    0045C 2C23      MOV	R2,R3
    0045D 2433      CLR	R3
    0045E 5EE5      SUBI	R30,0xE5
    0045F 4FFD      SBCI	R31,0xFD
    00460 8220      ST	Z,R2
    00461 51EB      SUBI	R30,0x1B
    00462 40F2      SBCI	R31,2
    00463 8422      LDD	R2,Z+10
    00464 8433      LDD	R3,Z+11
    00465 8444      LDD	R4,Z+12
    00466 8455      LDD	R5,Z+13
    00467 0112      MOVW	R2,R4
    00468 2444      CLR	R4
    00469 2455      CLR	R5
    0046A 5EE4      SUBI	R30,0xE4
    0046B 4FFD      SBCI	R31,0xFD
    0046C 8220      ST	Z,R2
    0046D 51EC      SUBI	R30,0x1C
    0046E 40F2      SBCI	R31,2
    0046F E188      LDI	R24,0x18
    00470 E090      LDI	R25,0
    00471 8502      LDD	R16,Z+10
    00472 8513      LDD	R17,Z+11
    00473 8524      LDD	R18,Z+12
    00474 8535      LDD	R19,Z+13
    00475 938A      ST	-Y,R24
    00476 940E 3D10 CALL	lsr32
    00478 01FB      MOVW	R30,R22
    00479 5EE3      SUBI	R30,0xE3
    0047A 4FFD      SBCI	R31,0xFD
    0047B 8300      ST	Z,R16
    0047C 51ED      SUBI	R30,0x1D
    0047D 40F2      SBCI	R31,2
(0780) 			/* Write it into the FSInfo sector */
(0781) 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    0047E E081      LDI	R24,1
    0047F 838C      STD	Y+4,R24
    00480 8822      LDD	R2,Z+18
    00481 8833      LDD	R3,Z+19
    00482 8844      LDD	R4,Z+20
    00483 8855      LDD	R5,Z+21
    00484 8228      ST	Y,R2
    00485 8239      STD	Y+1,R3
    00486 824A      STD	Y+2,R4
    00487 825B      STD	Y+3,R5
    00488 019F      MOVW	R18,R30
    00489 5D22      SUBI	R18,0xD2
    0048A 4F3F      SBCI	R19,0xFF
    0048B 8101      LDD	R16,Z+1
    0048C 940E 02B2 CALL	_disk_write
(0782) 			fs->fsi_flag = 0;
    0048E 2422      CLR	R2
    0048F 01FB      MOVW	R30,R22
    00490 8225      STD	Z+5,R2
(0783) 		}
(0784) 		/* Make sure that no pending write process in the physical drive */
(0785) 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    00491 2422      CLR	R2
    00492 2433      CLR	R3
    00493 8239      STD	Y+1,R3
    00494 8228      ST	Y,R2
    00495 2722      CLR	R18
    00496 2733      CLR	R19
    00497 01FB      MOVW	R30,R22
    00498 8101      LDD	R16,Z+1
    00499 2711      CLR	R17
    0049A 940E 02CA CALL	_disk_ioctl
    0049C 3000      CPI	R16,0
    0049D 0701      CPC	R16,R17
    0049E F009      BEQ	0x04A0
(0786) 			res = FR_DISK_ERR;
    0049F E041      LDI	R20,1
(0787) 	}
(0788) 
(0789) 	return res;
    004A0 2F04      MOV	R16,R20
    004A1 9625      ADIW	R28,5
    004A2 940C 3C8F JMP	pop_xgsetF000
_clust2sect:
  clst                 --> Y,+6
  fs                   --> R10
    004A4 933A      ST	-Y,R19
    004A5 932A      ST	-Y,R18
    004A6 940E 3C94 CALL	push_xgsetF00C
    004A8 0158      MOVW	R10,R16
(0790) }
(0791) #endif
(0792) 
(0793) 
(0794) 
(0795) 
(0796) /*-----------------------------------------------------------------------*/
(0797) /* Get sector# from cluster#                                             */
(0798) /*-----------------------------------------------------------------------*/
(0799) 
(0800) 
(0801) DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
(0802) 	FATFS *fs,		/* File system object */
(0803) 	DWORD clst		/* Cluster# to be converted */
(0804) )
(0805) {
(0806) 	clst -= 2;
    004A9 E042      LDI	R20,2
    004AA E050      LDI	R21,0
    004AB E060      LDI	R22,0
    004AC E070      LDI	R23,0
    004AD 802E      LDD	R2,Y+6
    004AE 803F      LDD	R3,Y+7
    004AF 8448      LDD	R4,Y+8
    004B0 8459      LDD	R5,Y+9
    004B1 1A24      SUB	R2,R20
    004B2 0A35      SBC	R3,R21
    004B3 0A46      SBC	R4,R22
    004B4 0A57      SBC	R5,R23
    004B5 822E      STD	Y+6,R2
    004B6 823F      STD	Y+7,R3
    004B7 8648      STD	Y+8,R4
    004B8 8659      STD	Y+9,R5
(0807) 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    004B9 E042      LDI	R20,2
    004BA E050      LDI	R21,0
    004BB E060      LDI	R22,0
    004BC E070      LDI	R23,0
    004BD 01F5      MOVW	R30,R10
    004BE 9676      ADIW	R30,0x16
    004BF 8020      LD	R2,Z
    004C0 8031      LDD	R3,Z+1
    004C1 8042      LDD	R4,Z+2
    004C2 8053      LDD	R5,Z+3
    004C3 1A24      SUB	R2,R20
    004C4 0A35      SBC	R3,R21
    004C5 0A46      SBC	R4,R22
    004C6 0A57      SBC	R5,R23
    004C7 806E      LDD	R6,Y+6
    004C8 807F      LDD	R7,Y+7
    004C9 8488      LDD	R8,Y+8
    004CA 8499      LDD	R9,Y+9
    004CB 1462      CP	R6,R2
    004CC 0473      CPC	R7,R3
    004CD 0484      CPC	R8,R4
    004CE 0495      CPC	R9,R5
    004CF F028      BCS	0x04D5
    004D0 E000      LDI	R16,0
    004D1 E010      LDI	R17,0
    004D2 E020      LDI	R18,0
    004D3 E030      LDI	R19,0
    004D4 C01D      RJMP	0x04F2
(0808) 	return clst * fs->csize + fs->database;
    004D5 01F5      MOVW	R30,R10
    004D6 9632      ADIW	R30,2
    004D7 8020      LD	R2,Z
    004D8 2433      CLR	R3
    004D9 2444      CLR	R4
    004DA 2455      CLR	R5
    004DB 810E      LDD	R16,Y+6
    004DC 811F      LDD	R17,Y+7
    004DD 8528      LDD	R18,Y+8
    004DE 8539      LDD	R19,Y+9
    004DF 925A      ST	-Y,R5
    004E0 924A      ST	-Y,R4
    004E1 923A      ST	-Y,R3
    004E2 922A      ST	-Y,R2
    004E3 940E 3C21 CALL	empy32s|empy32u
    004E5 0118      MOVW	R2,R16
    004E6 0129      MOVW	R4,R18
    004E7 01F5      MOVW	R30,R10
    004E8 A066      LDD	R6,Z+38
    004E9 A077      LDD	R7,Z+39
    004EA A480      LDD	R8,Z+40
    004EB A491      LDD	R9,Z+41
    004EC 0C26      ADD	R2,R6
    004ED 1C37      ADC	R3,R7
    004EE 1C48      ADC	R4,R8
    004EF 1C59      ADC	R5,R9
    004F0 0181      MOVW	R16,R2
    004F1 0192      MOVW	R18,R4
    004F2 940E 3C9B CALL	pop_xgsetF00C
    004F4 9622      ADIW	R28,2
    004F5 9508      RET
_get_fat:
  wc                   --> R14
  p                    --> R10
  bc                   --> R10
  clst                 --> Y,+12
  fs                   --> R12
    004F6 933A      ST	-Y,R19
    004F7 932A      ST	-Y,R18
    004F8 940E 3C75 CALL	push_xgsetF0FC
    004FA 0168      MOVW	R12,R16
    004FB 9722      SBIW	R28,2
(0809) }
(0810) 
(0811) 
(0812) 
(0813) 
(0814) /*-----------------------------------------------------------------------*/
(0815) /* FAT access - Read value of a FAT entry                                */
(0816) /*-----------------------------------------------------------------------*/
(0817) 
(0818) 
(0819) DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
(0820) 	FATFS *fs,	/* File system object */
(0821) 	DWORD clst	/* Cluster# to get the link information */
(0822) )
(0823) {
(0824) 	UINT wc, bc;
(0825) 	BYTE *p;
(0826) 
(0827) 
(0828) 	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    004FC E042      LDI	R20,2
    004FD E050      LDI	R21,0
    004FE E060      LDI	R22,0
    004FF E070      LDI	R23,0
    00500 842C      LDD	R2,Y+12
    00501 843D      LDD	R3,Y+13
    00502 844E      LDD	R4,Y+14
    00503 845F      LDD	R5,Y+15
    00504 1624      CP	R2,R20
    00505 0635      CPC	R3,R21
    00506 0646      CPC	R4,R22
    00507 0657      CPC	R5,R23
    00508 F078      BCS	0x0518
    00509 01F6      MOVW	R30,R12
    0050A 9676      ADIW	R30,0x16
    0050B 8020      LD	R2,Z
    0050C 8031      LDD	R3,Z+1
    0050D 8042      LDD	R4,Z+2
    0050E 8053      LDD	R5,Z+3
    0050F 846C      LDD	R6,Y+12
    00510 847D      LDD	R7,Y+13
    00511 848E      LDD	R8,Y+14
    00512 849F      LDD	R9,Y+15
    00513 1462      CP	R6,R2
    00514 0473      CPC	R7,R3
    00515 0484      CPC	R8,R4
    00516 0495      CPC	R9,R5
    00517 F028      BCS	0x051D
(0829) 		return 1;
    00518 E001      LDI	R16,1
    00519 E010      LDI	R17,0
    0051A E020      LDI	R18,0
    0051B E030      LDI	R19,0
    0051C C124      RJMP	0x0641
(0830) 
(0831) 	switch (fs->fs_type) {
    0051D 01F6      MOVW	R30,R12
    0051E 80A0      LD	R10,Z
    0051F 24BB      CLR	R11
    00520 01C5      MOVW	R24,R10
    00521 3081      CPI	R24,1
    00522 E0E0      LDI	R30,0
    00523 079E      CPC	R25,R30
    00524 F059      BEQ	0x0530
    00525 3082      CPI	R24,2
    00526 E0E0      LDI	R30,0
    00527 079E      CPC	R25,R30
    00528 F409      BNE	0x052A
    00529 C06F      RJMP	0x0599
    0052A 3083      CPI	R24,3
    0052B E0E0      LDI	R30,0
    0052C 079E      CPC	R25,R30
    0052D F409      BNE	0x052F
    0052E C0A6      RJMP	0x05D5
    0052F C10D      RJMP	0x063D
(0832) 	case FS_FAT12 :
(0833) 		bc = (UINT)clst; bc += bc / 2;
    00530 84AC      LDD	R10,Y+12
    00531 84BD      LDD	R11,Y+13
    00532 0115      MOVW	R2,R10
    00533 9436      LSR	R3
    00534 9427      ROR	R2
    00535 0CA2      ADD	R10,R2
    00536 1CB3      ADC	R11,R3
(0834) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00537 E029      LDI	R18,0x9
    00538 E030      LDI	R19,0
    00539 0185      MOVW	R16,R10
    0053A 940E 3D09 CALL	lsr16
    0053C 0118      MOVW	R2,R16
    0053D 2444      CLR	R4
    0053E 2455      CLR	R5
    0053F 01F6      MOVW	R30,R12
    00540 8C66      LDD	R6,Z+30
    00541 8C77      LDD	R7,Z+31
    00542 A080      LDD	R8,Z+32
    00543 A091      LDD	R9,Z+33
    00544 0C62      ADD	R6,R2
    00545 1C73      ADC	R7,R3
    00546 1C84      ADC	R8,R4
    00547 1C95      ADC	R9,R5
    00548 8288      ST	Y,R8
    00549 8299      STD	Y+1,R9
    0054A 0193      MOVW	R18,R6
    0054B 018F      MOVW	R16,R30
    0054C DDE0      RCALL	ff.c:move_window
    0054D 2300      TST	R16
    0054E F009      BEQ	0x0550
    0054F C0ED      RJMP	0x063D
(0835) 		wc = fs->win[bc % SS(fs)]; bc++;
    00550 01C6      MOVW	R24,R12
    00551 968E      ADIW	R24,0x2E
    00552 01F5      MOVW	R30,R10
    00553 70F1      ANDI	R31,1
    00554 0FE8      ADD	R30,R24
    00555 1FF9      ADC	R31,R25
    00556 80E0      LD	R14,Z
    00557 24FF      CLR	R15
    00558 01C5      MOVW	R24,R10
    00559 9601      ADIW	R24,1
    0055A 015C      MOVW	R10,R24
(0836) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    0055B E029      LDI	R18,0x9
    0055C E030      LDI	R19,0
    0055D 018C      MOVW	R16,R24
    0055E 940E 3D09 CALL	lsr16
    00560 0118      MOVW	R2,R16
    00561 2444      CLR	R4
    00562 2455      CLR	R5
    00563 01F6      MOVW	R30,R12
    00564 8C66      LDD	R6,Z+30
    00565 8C77      LDD	R7,Z+31
    00566 A080      LDD	R8,Z+32
    00567 A091      LDD	R9,Z+33
    00568 0C62      ADD	R6,R2
    00569 1C73      ADC	R7,R3
    0056A 1C84      ADC	R8,R4
    0056B 1C95      ADC	R9,R5
    0056C 8288      ST	Y,R8
    0056D 8299      STD	Y+1,R9
    0056E 0193      MOVW	R18,R6
    0056F 018F      MOVW	R16,R30
    00570 DDBC      RCALL	ff.c:move_window
    00571 2300      TST	R16
    00572 F009      BEQ	0x0574
    00573 C0C9      RJMP	0x063D
(0837) 		wc |= fs->win[bc % SS(fs)] << 8;
    00574 01C6      MOVW	R24,R12
    00575 968E      ADIW	R24,0x2E
    00576 01F5      MOVW	R30,R10
    00577 70F1      ANDI	R31,1
    00578 0FE8      ADD	R30,R24
    00579 1FF9      ADC	R31,R25
    0057A 8020      LD	R2,Z
    0057B 2433      CLR	R3
    0057C 2C32      MOV	R3,R2
    0057D 2422      CLR	R2
    0057E 28E2      OR	R14,R2
    0057F 28F3      OR	R15,R3
(0838) 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    00580 842C      LDD	R2,Y+12
    00581 843D      LDD	R3,Y+13
    00582 844E      LDD	R4,Y+14
    00583 845F      LDD	R5,Y+15
    00584 2DE2      MOV	R30,R2
    00585 70E1      ANDI	R30,1
    00586 F051      BEQ	0x0591
    00587 0157      MOVW	R10,R14
    00588 94B6      LSR	R11
    00589 94A7      ROR	R10
    0058A 94B6      LSR	R11
    0058B 94A7      ROR	R10
    0058C 94B6      LSR	R11
    0058D 94A7      ROR	R10
    0058E 94B6      LSR	R11
    0058F 94A7      ROR	R10
    00590 C003      RJMP	0x0594
    00591 01C7      MOVW	R24,R14
    00592 709F      ANDI	R25,0xF
    00593 015C      MOVW	R10,R24
    00594 0185      MOVW	R16,R10
    00595 0196      MOVW	R18,R12
    00596 2722      CLR	R18
    00597 2733      CLR	R19
    00598 C0A8      RJMP	0x0641
(0839) 
(0840) 	case FS_FAT16 :
(0841) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    00599 E088      LDI	R24,0x8
    0059A E090      LDI	R25,0
    0059B 850C      LDD	R16,Y+12
    0059C 851D      LDD	R17,Y+13
    0059D 852E      LDD	R18,Y+14
    0059E 853F      LDD	R19,Y+15
    0059F 938A      ST	-Y,R24
    005A0 940E 3D10 CALL	lsr32
    005A2 01F6      MOVW	R30,R12
    005A3 8C26      LDD	R2,Z+30
    005A4 8C37      LDD	R3,Z+31
    005A5 A040      LDD	R4,Z+32
    005A6 A051      LDD	R5,Z+33
    005A7 0E20      ADD	R2,R16
    005A8 1E31      ADC	R3,R17
    005A9 1E42      ADC	R4,R18
    005AA 1E53      ADC	R5,R19
    005AB 8248      ST	Y,R4
    005AC 8259      STD	Y+1,R5
    005AD 0191      MOVW	R18,R2
    005AE 018F      MOVW	R16,R30
    005AF DD7D      RCALL	ff.c:move_window
    005B0 2EA0      MOV	R10,R16
    005B1 2300      TST	R16
    005B2 F009      BEQ	0x05B4
    005B3 C089      RJMP	0x063D
(0842) 		p = &fs->win[clst * 2 % SS(fs)];
    005B4 EF4F      LDI	R20,0xFF
    005B5 E051      LDI	R21,1
    005B6 E060      LDI	R22,0
    005B7 E070      LDI	R23,0
    005B8 842C      LDD	R2,Y+12
    005B9 843D      LDD	R3,Y+13
    005BA 844E      LDD	R4,Y+14
    005BB 845F      LDD	R5,Y+15
    005BC 0C22      LSL	R2
    005BD 1C33      ROL	R3
    005BE 1C44      ROL	R4
    005BF 1C55      ROL	R5
    005C0 2224      AND	R2,R20
    005C1 2235      AND	R3,R21
    005C2 2246      AND	R4,R22
    005C3 2257      AND	R5,R23
    005C4 0151      MOVW	R10,R2
    005C5 01C6      MOVW	R24,R12
    005C6 968E      ADIW	R24,0x2E
    005C7 0EA8      ADD	R10,R24
    005C8 1EB9      ADC	R11,R25
(0843) 		return LD_WORD(p);
    005C9 01F5      MOVW	R30,R10
    005CA 8020      LD	R2,Z
    005CB 2433      CLR	R3
    005CC 8101      LDD	R16,Z+1
    005CD 2711      CLR	R17
    005CE 2F10      MOV	R17,R16
    005CF 2700      CLR	R16
    005D0 2902      OR	R16,R2
    005D1 2913      OR	R17,R3
    005D2 2722      CLR	R18
    005D3 2733      CLR	R19
    005D4 C06C      RJMP	0x0641
(0844) 
(0845) 	case FS_FAT32 :
(0846) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    005D5 E087      LDI	R24,7
    005D6 E090      LDI	R25,0
    005D7 850C      LDD	R16,Y+12
    005D8 851D      LDD	R17,Y+13
    005D9 852E      LDD	R18,Y+14
    005DA 853F      LDD	R19,Y+15
    005DB 938A      ST	-Y,R24
    005DC 940E 3D10 CALL	lsr32
    005DE 01F6      MOVW	R30,R12
    005DF 8C26      LDD	R2,Z+30
    005E0 8C37      LDD	R3,Z+31
    005E1 A040      LDD	R4,Z+32
    005E2 A051      LDD	R5,Z+33
    005E3 0E20      ADD	R2,R16
    005E4 1E31      ADC	R3,R17
    005E5 1E42      ADC	R4,R18
    005E6 1E53      ADC	R5,R19
    005E7 8248      ST	Y,R4
    005E8 8259      STD	Y+1,R5
    005E9 0191      MOVW	R18,R2
    005EA 018F      MOVW	R16,R30
    005EB DD41      RCALL	ff.c:move_window
    005EC 2EE0      MOV	R14,R16
    005ED 2300      TST	R16
    005EE F009      BEQ	0x05F0
    005EF C04D      RJMP	0x063D
(0847) 		p = &fs->win[clst * 4 % SS(fs)];
    005F0 E082      LDI	R24,2
    005F1 E090      LDI	R25,0
    005F2 850C      LDD	R16,Y+12
    005F3 851D      LDD	R17,Y+13
    005F4 852E      LDD	R18,Y+14
    005F5 853F      LDD	R19,Y+15
    005F6 938A      ST	-Y,R24
    005F7 940E 3CF7 CALL	lsl32
    005F9 0118      MOVW	R2,R16
    005FA 0129      MOVW	R4,R18
    005FB EF4F      LDI	R20,0xFF
    005FC E051      LDI	R21,1
    005FD E060      LDI	R22,0
    005FE E070      LDI	R23,0
    005FF 2224      AND	R2,R20
    00600 2235      AND	R3,R21
    00601 2246      AND	R4,R22
    00602 2257      AND	R5,R23
    00603 0151      MOVW	R10,R2
    00604 01C6      MOVW	R24,R12
    00605 968E      ADIW	R24,0x2E
    00606 0EA8      ADD	R10,R24
    00607 1EB9      ADC	R11,R25
(0848) 		return LD_DWORD(p) & 0x0FFFFFFF;
    00608 E188      LDI	R24,0x18
    00609 E090      LDI	R25,0
    0060A 01F5      MOVW	R30,R10
    0060B 8103      LDD	R16,Z+3
    0060C 2711      CLR	R17
    0060D 2722      CLR	R18
    0060E 2733      CLR	R19
    0060F 938A      ST	-Y,R24
    00610 940E 3CF7 CALL	lsl32
    00612 0118      MOVW	R2,R16
    00613 0129      MOVW	R4,R18
    00614 01F5      MOVW	R30,R10
    00615 8062      LDD	R6,Z+2
    00616 2477      CLR	R7
    00617 2488      CLR	R8
    00618 2499      CLR	R9
    00619 0143      MOVW	R8,R6
    0061A 2466      CLR	R6
    0061B 2477      CLR	R7
    0061C 2826      OR	R2,R6
    0061D 2837      OR	R3,R7
    0061E 2848      OR	R4,R8
    0061F 2859      OR	R5,R9
    00620 8061      LDD	R6,Z+1
    00621 2477      CLR	R7
    00622 2C76      MOV	R7,R6
    00623 2466      CLR	R6
    00624 2488      CLR	R8
    00625 2499      CLR	R9
    00626 2826      OR	R2,R6
    00627 2837      OR	R3,R7
    00628 2848      OR	R4,R8
    00629 2859      OR	R5,R9
    0062A 8060      LD	R6,Z
    0062B 2477      CLR	R7
    0062C 2488      CLR	R8
    0062D 2499      CLR	R9
    0062E 2826      OR	R2,R6
    0062F 2837      OR	R3,R7
    00630 2848      OR	R4,R8
    00631 2859      OR	R5,R9
    00632 EF4F      LDI	R20,0xFF
    00633 EF5F      LDI	R21,0xFF
    00634 EF6F      LDI	R22,0xFF
    00635 E07F      LDI	R23,0xF
    00636 2224      AND	R2,R20
    00637 2235      AND	R3,R21
    00638 2246      AND	R4,R22
    00639 2257      AND	R5,R23
    0063A 0181      MOVW	R16,R2
    0063B 0192      MOVW	R18,R4
    0063C C004      RJMP	0x0641
(0849) 	}
(0850) 
(0851) 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    0063D EF0F      LDI	R16,0xFF
    0063E EF1F      LDI	R17,0xFF
    0063F EF2F      LDI	R18,0xFF
    00640 EF3F      LDI	R19,0xFF
    00641 9622      ADIW	R28,2
    00642 940E 3C6A CALL	pop_xgsetF0FC
    00644 9622      ADIW	R28,2
    00645 9508      RET
_put_fat:
  bc                   --> R12
  p                    --> R14
  res                  --> Y,+2
  val                  --> Y,+19
  clst                 --> Y,+15
  fs                   --> Y,+13
    00646 940E 3B30 CALL	push_arg4
    00648 940E 3C75 CALL	push_xgsetF0FC
    0064A 9723      SBIW	R28,3
(0852) }
(0853) 
(0854) 
(0855) 
(0856) 
(0857) /*-----------------------------------------------------------------------*/
(0858) /* FAT access - Change value of a FAT entry                              */
(0859) /*-----------------------------------------------------------------------*/
(0860) #if !_FS_READONLY
(0861) 
(0862) FRESULT put_fat (
(0863) 	FATFS *fs,	/* File system object */
(0864) 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
(0865) 	DWORD val	/* New value to mark the cluster */
(0866) )
(0867) {
(0868) 	UINT bc;
(0869) 	BYTE *p;
(0870) 	FRESULT res;
(0871) 
(0872) 
(0873) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    0064B E042      LDI	R20,2
    0064C E050      LDI	R21,0
    0064D E060      LDI	R22,0
    0064E E070      LDI	R23,0
    0064F 842F      LDD	R2,Y+15
    00650 8838      LDD	R3,Y+16
    00651 8849      LDD	R4,Y+17
    00652 885A      LDD	R5,Y+18
    00653 1624      CP	R2,R20
    00654 0635      CPC	R3,R21
    00655 0646      CPC	R4,R22
    00656 0657      CPC	R5,R23
    00657 F080      BCS	0x0668
    00658 85ED      LDD	R30,Y+13
    00659 85FE      LDD	R31,Y+14
    0065A 9676      ADIW	R30,0x16
    0065B 8020      LD	R2,Z
    0065C 8031      LDD	R3,Z+1
    0065D 8042      LDD	R4,Z+2
    0065E 8053      LDD	R5,Z+3
    0065F 846F      LDD	R6,Y+15
    00660 8878      LDD	R7,Y+16
    00661 8889      LDD	R8,Y+17
    00662 889A      LDD	R9,Y+18
    00663 1462      CP	R6,R2
    00664 0473      CPC	R7,R3
    00665 0484      CPC	R8,R4
    00666 0495      CPC	R9,R5
    00667 F018      BCS	0x066B
(0874) 		res = FR_INT_ERR;
    00668 E082      LDI	R24,2
    00669 838A      STD	Y+2,R24
(0875) 
(0876) 	} else {
    0066A C194      RJMP	0x07FF
(0877) 		switch (fs->fs_type) {
    0066B 85ED      LDD	R30,Y+13
    0066C 85FE      LDD	R31,Y+14
    0066D 80A0      LD	R10,Z
    0066E 24BB      CLR	R11
    0066F 01C5      MOVW	R24,R10
    00670 3081      CPI	R24,1
    00671 E0E0      LDI	R30,0
    00672 079E      CPC	R25,R30
    00673 F059      BEQ	0x067F
    00674 3082      CPI	R24,2
    00675 E0E0      LDI	R30,0
    00676 079E      CPC	R25,R30
    00677 F409      BNE	0x0679
    00678 C0B0      RJMP	0x0729
    00679 3083      CPI	R24,3
    0067A E0E0      LDI	R30,0
    0067B 079E      CPC	R25,R30
    0067C F409      BNE	0x067E
    0067D C0E7      RJMP	0x0765
    0067E C17A      RJMP	0x07F9
(0878) 		case FS_FAT12 :
(0879) 			bc = clst; bc += bc / 2;
    0067F 84CF      LDD	R12,Y+15
    00680 88D8      LDD	R13,Y+16
    00681 0116      MOVW	R2,R12
    00682 9436      LSR	R3
    00683 9427      ROR	R2
    00684 0CC2      ADD	R12,R2
    00685 1CD3      ADC	R13,R3
(0880) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    00686 E029      LDI	R18,0x9
    00687 E030      LDI	R19,0
    00688 0186      MOVW	R16,R12
    00689 940E 3D09 CALL	lsr16
    0068B 0118      MOVW	R2,R16
    0068C 2444      CLR	R4
    0068D 2455      CLR	R5
    0068E 85ED      LDD	R30,Y+13
    0068F 85FE      LDD	R31,Y+14
    00690 8C66      LDD	R6,Z+30
    00691 8C77      LDD	R7,Z+31
    00692 A080      LDD	R8,Z+32
    00693 A091      LDD	R9,Z+33
    00694 0C62      ADD	R6,R2
    00695 1C73      ADC	R7,R3
    00696 1C84      ADC	R8,R4
    00697 1C95      ADC	R9,R5
    00698 8288      ST	Y,R8
    00699 8299      STD	Y+1,R9
    0069A 0193      MOVW	R18,R6
    0069B 018F      MOVW	R16,R30
    0069C DC90      RCALL	ff.c:move_window
    0069D 830A      STD	Y+2,R16
(0881) 			if (res != FR_OK) break;
    0069E 2E00      MOV	R0,R16
    0069F 2300      TST	R16
    006A0 F009      BEQ	0x06A2
    006A1 C159      RJMP	0x07FB
(0882) 			p = &fs->win[bc % SS(fs)];
    006A2 858D      LDD	R24,Y+13
    006A3 859E      LDD	R25,Y+14
    006A4 968E      ADIW	R24,0x2E
    006A5 01F6      MOVW	R30,R12
    006A6 70F1      ANDI	R31,1
    006A7 017F      MOVW	R14,R30
    006A8 0EE8      ADD	R14,R24
    006A9 1EF9      ADC	R15,R25
(0883) 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    006AA 842F      LDD	R2,Y+15
    006AB 8838      LDD	R3,Y+16
    006AC 8849      LDD	R4,Y+17
    006AD 885A      LDD	R5,Y+18
    006AE 93EF      PUSH	R30
    006AF 2DE2      MOV	R30,R2
    006B0 70E1      ANDI	R30,1
    006B1 91EF      POP	R30
    006B2 F0B1      BEQ	0x06C9
    006B3 882B      LDD	R2,Y+19
    006B4 883C      LDD	R3,Y+20
    006B5 884D      LDD	R4,Y+21
    006B6 885E      LDD	R5,Y+22
    006B7 2433      CLR	R3
    006B8 0C22      LSL	R2
    006B9 1C33      ROL	R3
    006BA 0C22      LSL	R2
    006BB 1C33      ROL	R3
    006BC 0C22      LSL	R2
    006BD 1C33      ROL	R3
    006BE 0C22      LSL	R2
    006BF 1C33      ROL	R3
    006C0 01F7      MOVW	R30,R14
    006C1 8180      LD	R24,Z
    006C2 2799      CLR	R25
    006C3 708F      ANDI	R24,0xF
    006C4 7090      ANDI	R25,0
    006C5 015C      MOVW	R10,R24
    006C6 28A2      OR	R10,R2
    006C7 28B3      OR	R11,R3
    006C8 C006      RJMP	0x06CF
    006C9 882B      LDD	R2,Y+19
    006CA 883C      LDD	R3,Y+20
    006CB 884D      LDD	R4,Y+21
    006CC 885E      LDD	R5,Y+22
    006CD 2CA2      MOV	R10,R2
    006CE 24BB      CLR	R11
    006CF 01F7      MOVW	R30,R14
    006D0 82A0      ST	Z,R10
(0884) 			bc++;
    006D1 01C6      MOVW	R24,R12
    006D2 9601      ADIW	R24,1
    006D3 016C      MOVW	R12,R24
(0885) 			fs->wflag = 1;
    006D4 E081      LDI	R24,1
    006D5 85ED      LDD	R30,Y+13
    006D6 85FE      LDD	R31,Y+14
    006D7 8384      STD	Z+4,R24
(0886) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006D8 E029      LDI	R18,0x9
    006D9 E030      LDI	R19,0
    006DA 0186      MOVW	R16,R12
    006DB 940E 3D09 CALL	lsr16
    006DD 0118      MOVW	R2,R16
    006DE 2444      CLR	R4
    006DF 2455      CLR	R5
    006E0 85ED      LDD	R30,Y+13
    006E1 85FE      LDD	R31,Y+14
    006E2 8C66      LDD	R6,Z+30
    006E3 8C77      LDD	R7,Z+31
    006E4 A080      LDD	R8,Z+32
    006E5 A091      LDD	R9,Z+33
    006E6 0C62      ADD	R6,R2
    006E7 1C73      ADC	R7,R3
    006E8 1C84      ADC	R8,R4
    006E9 1C95      ADC	R9,R5
    006EA 8288      ST	Y,R8
    006EB 8299      STD	Y+1,R9
    006EC 0193      MOVW	R18,R6
    006ED 018F      MOVW	R16,R30
    006EE DC3E      RCALL	ff.c:move_window
    006EF 830A      STD	Y+2,R16
(0887) 			if (res != FR_OK) break;
    006F0 2E00      MOV	R0,R16
    006F1 2300      TST	R16
    006F2 F009      BEQ	0x06F4
    006F3 C107      RJMP	0x07FB
(0888) 			p = &fs->win[bc % SS(fs)];
    006F4 858D      LDD	R24,Y+13
    006F5 859E      LDD	R25,Y+14
    006F6 968E      ADIW	R24,0x2E
    006F7 01F6      MOVW	R30,R12
    006F8 70F1      ANDI	R31,1
    006F9 017F      MOVW	R14,R30
    006FA 0EE8      ADD	R14,R24
    006FB 1EF9      ADC	R15,R25
(0889) 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    006FC 842F      LDD	R2,Y+15
    006FD 8838      LDD	R3,Y+16
    006FE 8849      LDD	R4,Y+17
    006FF 885A      LDD	R5,Y+18
    00700 93EF      PUSH	R30
    00701 2DE2      MOV	R30,R2
    00702 70E1      ANDI	R30,1
    00703 91EF      POP	R30
    00704 F061      BEQ	0x0711
    00705 E084      LDI	R24,4
    00706 E090      LDI	R25,0
    00707 890B      LDD	R16,Y+19
    00708 891C      LDD	R17,Y+20
    00709 892D      LDD	R18,Y+21
    0070A 893E      LDD	R19,Y+22
    0070B 938A      ST	-Y,R24
    0070C 940E 3D10 CALL	lsr32
    0070E 2EC0      MOV	R12,R16
    0070F 24DD      CLR	R13
    00710 C015      RJMP	0x0726
    00711 E088      LDI	R24,0x8
    00712 E090      LDI	R25,0
    00713 890B      LDD	R16,Y+19
    00714 891C      LDD	R17,Y+20
    00715 892D      LDD	R18,Y+21
    00716 893E      LDD	R19,Y+22
    00717 938A      ST	-Y,R24
    00718 940E 3D10 CALL	lsr32
    0071A 2F80      MOV	R24,R16
    0071B 2799      CLR	R25
    0071C 708F      ANDI	R24,0xF
    0071D 7090      ANDI	R25,0
    0071E 01F7      MOVW	R30,R14
    0071F 81E0      LD	R30,Z
    00720 27FF      CLR	R31
    00721 7FE0      ANDI	R30,0xF0
    00722 70F0      ANDI	R31,0
    00723 016F      MOVW	R12,R30
    00724 2AC8      OR	R12,R24
    00725 2AD9      OR	R13,R25
    00726 01F7      MOVW	R30,R14
    00727 82C0      ST	Z,R12
(0890) 			break;
    00728 C0D2      RJMP	0x07FB
(0891) 
(0892) 		case FS_FAT16 :
(0893) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    00729 E088      LDI	R24,0x8
    0072A E090      LDI	R25,0
    0072B 850F      LDD	R16,Y+15
    0072C 8918      LDD	R17,Y+16
    0072D 8929      LDD	R18,Y+17
    0072E 893A      LDD	R19,Y+18
    0072F 938A      ST	-Y,R24
    00730 940E 3D10 CALL	lsr32
    00732 85ED      LDD	R30,Y+13
    00733 85FE      LDD	R31,Y+14
    00734 8C26      LDD	R2,Z+30
    00735 8C37      LDD	R3,Z+31
    00736 A040      LDD	R4,Z+32
    00737 A051      LDD	R5,Z+33
    00738 0E20      ADD	R2,R16
    00739 1E31      ADC	R3,R17
    0073A 1E42      ADC	R4,R18
    0073B 1E53      ADC	R5,R19
    0073C 8248      ST	Y,R4
    0073D 8259      STD	Y+1,R5
    0073E 0191      MOVW	R18,R2
    0073F 018F      MOVW	R16,R30
    00740 DBEC      RCALL	ff.c:move_window
    00741 2EC0      MOV	R12,R16
    00742 82CA      STD	Y+2,R12
(0894) 			if (res != FR_OK) break;
    00743 2C0C      MOV	R0,R12
    00744 2300      TST	R16
    00745 F009      BEQ	0x0747
    00746 C0B4      RJMP	0x07FB
(0895) 			p = &fs->win[clst * 2 % SS(fs)];
    00747 EF4F      LDI	R20,0xFF
    00748 E051      LDI	R21,1
    00749 E060      LDI	R22,0
    0074A E070      LDI	R23,0
    0074B 842F      LDD	R2,Y+15
    0074C 8838      LDD	R3,Y+16
    0074D 8849      LDD	R4,Y+17
    0074E 885A      LDD	R5,Y+18
    0074F 0C22      LSL	R2
    00750 1C33      ROL	R3
    00751 1C44      ROL	R4
    00752 1C55      ROL	R5
    00753 2224      AND	R2,R20
    00754 2235      AND	R3,R21
    00755 2246      AND	R4,R22
    00756 2257      AND	R5,R23
    00757 0171      MOVW	R14,R2
    00758 858D      LDD	R24,Y+13
    00759 859E      LDD	R25,Y+14
    0075A 968E      ADIW	R24,0x2E
    0075B 0EE8      ADD	R14,R24
    0075C 1EF9      ADC	R15,R25
(0896) 			ST_WORD(p, (WORD)val);
    0075D 882B      LDD	R2,Y+19
    0075E 883C      LDD	R3,Y+20
    0075F 01F7      MOVW	R30,R14
    00760 8220      ST	Z,R2
    00761 2C23      MOV	R2,R3
    00762 2433      CLR	R3
    00763 8221      STD	Z+1,R2
(0897) 			break;
    00764 C096      RJMP	0x07FB
(0898) 
(0899) 		case FS_FAT32 :
(0900) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    00765 E087      LDI	R24,7
    00766 E090      LDI	R25,0
    00767 850F      LDD	R16,Y+15
    00768 8918      LDD	R17,Y+16
    00769 8929      LDD	R18,Y+17
    0076A 893A      LDD	R19,Y+18
    0076B 938A      ST	-Y,R24
    0076C 940E 3D10 CALL	lsr32
    0076E 85ED      LDD	R30,Y+13
    0076F 85FE      LDD	R31,Y+14
    00770 8C26      LDD	R2,Z+30
    00771 8C37      LDD	R3,Z+31
    00772 A040      LDD	R4,Z+32
    00773 A051      LDD	R5,Z+33
    00774 0E20      ADD	R2,R16
    00775 1E31      ADC	R3,R17
    00776 1E42      ADC	R4,R18
    00777 1E53      ADC	R5,R19
    00778 8248      ST	Y,R4
    00779 8259      STD	Y+1,R5
    0077A 0191      MOVW	R18,R2
    0077B 018F      MOVW	R16,R30
    0077C DBB0      RCALL	ff.c:move_window
    0077D 2EC0      MOV	R12,R16
    0077E 82CA      STD	Y+2,R12
(0901) 			if (res != FR_OK) break;
    0077F 2C0C      MOV	R0,R12
    00780 2300      TST	R16
    00781 F009      BEQ	0x0783
    00782 C078      RJMP	0x07FB
(0902) 			p = &fs->win[clst * 4 % SS(fs)];
    00783 E082      LDI	R24,2
    00784 E090      LDI	R25,0
    00785 850F      LDD	R16,Y+15
    00786 8918      LDD	R17,Y+16
    00787 8929      LDD	R18,Y+17
    00788 893A      LDD	R19,Y+18
    00789 938A      ST	-Y,R24
    0078A 940E 3CF7 CALL	lsl32
    0078C 0118      MOVW	R2,R16
    0078D 0129      MOVW	R4,R18
    0078E EF4F      LDI	R20,0xFF
    0078F E051      LDI	R21,1
    00790 E060      LDI	R22,0
    00791 E070      LDI	R23,0
    00792 2224      AND	R2,R20
    00793 2235      AND	R3,R21
    00794 2246      AND	R4,R22
    00795 2257      AND	R5,R23
    00796 0171      MOVW	R14,R2
    00797 858D      LDD	R24,Y+13
    00798 859E      LDD	R25,Y+14
    00799 968E      ADIW	R24,0x2E
    0079A 0EE8      ADD	R14,R24
    0079B 1EF9      ADC	R15,R25
(0903) 			val |= LD_DWORD(p) & 0xF0000000;
    0079C E188      LDI	R24,0x18
    0079D E090      LDI	R25,0
    0079E 01F7      MOVW	R30,R14
    0079F 8103      LDD	R16,Z+3
    007A0 2711      CLR	R17
    007A1 2722      CLR	R18
    007A2 2733      CLR	R19
    007A3 938A      ST	-Y,R24
    007A4 940E 3CF7 CALL	lsl32
    007A6 0118      MOVW	R2,R16
    007A7 0129      MOVW	R4,R18
    007A8 01F7      MOVW	R30,R14
    007A9 8062      LDD	R6,Z+2
    007AA 2477      CLR	R7
    007AB 2488      CLR	R8
    007AC 2499      CLR	R9
    007AD 0143      MOVW	R8,R6
    007AE 2466      CLR	R6
    007AF 2477      CLR	R7
    007B0 2826      OR	R2,R6
    007B1 2837      OR	R3,R7
    007B2 2848      OR	R4,R8
    007B3 2859      OR	R5,R9
    007B4 8061      LDD	R6,Z+1
    007B5 2477      CLR	R7
    007B6 2C76      MOV	R7,R6
    007B7 2466      CLR	R6
    007B8 2488      CLR	R8
    007B9 2499      CLR	R9
    007BA 2826      OR	R2,R6
    007BB 2837      OR	R3,R7
    007BC 2848      OR	R4,R8
    007BD 2859      OR	R5,R9
    007BE 8060      LD	R6,Z
    007BF 2477      CLR	R7
    007C0 2488      CLR	R8
    007C1 2499      CLR	R9
    007C2 2826      OR	R2,R6
    007C3 2837      OR	R3,R7
    007C4 2848      OR	R4,R8
    007C5 2859      OR	R5,R9
    007C6 E040      LDI	R20,0
    007C7 E050      LDI	R21,0
    007C8 E060      LDI	R22,0
    007C9 EF70      LDI	R23,0xF0
    007CA 2224      AND	R2,R20
    007CB 2235      AND	R3,R21
    007CC 2246      AND	R4,R22
    007CD 2257      AND	R5,R23
    007CE 886B      LDD	R6,Y+19
    007CF 887C      LDD	R7,Y+20
    007D0 888D      LDD	R8,Y+21
    007D1 889E      LDD	R9,Y+22
    007D2 2862      OR	R6,R2
    007D3 2873      OR	R7,R3
    007D4 2884      OR	R8,R4
    007D5 2895      OR	R9,R5
    007D6 8A6B      STD	Y+19,R6
    007D7 8A7C      STD	Y+20,R7
    007D8 8A8D      STD	Y+21,R8
    007D9 8A9E      STD	Y+22,R9
(0904) 			ST_DWORD(p, val);
    007DA 882B      LDD	R2,Y+19
    007DB 883C      LDD	R3,Y+20
    007DC 884D      LDD	R4,Y+21
    007DD 885E      LDD	R5,Y+22
    007DE 8220      ST	Z,R2
    007DF 2C23      MOV	R2,R3
    007E0 2433      CLR	R3
    007E1 9631      ADIW	R30,1
    007E2 8220      ST	Z,R2
    007E3 882B      LDD	R2,Y+19
    007E4 883C      LDD	R3,Y+20
    007E5 884D      LDD	R4,Y+21
    007E6 885E      LDD	R5,Y+22
    007E7 0112      MOVW	R2,R4
    007E8 2444      CLR	R4
    007E9 2455      CLR	R5
    007EA 01F7      MOVW	R30,R14
    007EB 9632      ADIW	R30,2
    007EC 8220      ST	Z,R2
    007ED E188      LDI	R24,0x18
    007EE E090      LDI	R25,0
    007EF 890B      LDD	R16,Y+19
    007F0 891C      LDD	R17,Y+20
    007F1 892D      LDD	R18,Y+21
    007F2 893E      LDD	R19,Y+22
    007F3 938A      ST	-Y,R24
    007F4 940E 3D10 CALL	lsr32
    007F6 01F7      MOVW	R30,R14
    007F7 8303      STD	Z+3,R16
(0905) 			break;
    007F8 C002      RJMP	0x07FB
(0906) 
(0907) 		default :
(0908) 			res = FR_INT_ERR;
    007F9 E082      LDI	R24,2
    007FA 838A      STD	Y+2,R24
(0909) 		}
(0910) 		fs->wflag = 1;
    007FB E081      LDI	R24,1
    007FC 85ED      LDD	R30,Y+13
    007FD 85FE      LDD	R31,Y+14
    007FE 8384      STD	Z+4,R24
(0911) 	}
(0912) 
(0913) 	return res;
    007FF 810A      LDD	R16,Y+2
    00800 9623      ADIW	R28,3
    00801 940E 3C6A CALL	pop_xgsetF0FC
    00803 9624      ADIW	R28,4
    00804 9508      RET
ff.c:remove_chain:
  res                  --> R10
  nxt                  --> Y,+6
  clst                 --> Y,+18
  fs                   --> R12
    00805 933A      ST	-Y,R19
    00806 932A      ST	-Y,R18
    00807 940E 3CB0 CALL	push_xgsetF03C
    00809 0168      MOVW	R12,R16
    0080A 972A      SBIW	R28,0xA
(0914) }
(0915) #endif /* !_FS_READONLY */
(0916) 
(0917) 
(0918) 
(0919) 
(0920) /*-----------------------------------------------------------------------*/
(0921) /* FAT handling - Remove a cluster chain                                 */
(0922) /*-----------------------------------------------------------------------*/
(0923) #if !_FS_READONLY
(0924) static
(0925) FRESULT remove_chain (
(0926) 	FATFS *fs,			/* File system object */
(0927) 	DWORD clst			/* Cluster# to remove a chain from */
(0928) )
(0929) {
(0930) 	FRESULT res;
(0931) 	DWORD nxt;
(0932) #if _USE_ERASE
(0933) 	DWORD scl = clst, ecl = clst, resion[2];
(0934) #endif
(0935) 
(0936) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    0080B E042      LDI	R20,2
    0080C E050      LDI	R21,0
    0080D E060      LDI	R22,0
    0080E E070      LDI	R23,0
    0080F 882A      LDD	R2,Y+18
    00810 883B      LDD	R3,Y+19
    00811 884C      LDD	R4,Y+20
    00812 885D      LDD	R5,Y+21
    00813 1624      CP	R2,R20
    00814 0635      CPC	R3,R21
    00815 0646      CPC	R4,R22
    00816 0657      CPC	R5,R23
    00817 F078      BCS	0x0827
    00818 01F6      MOVW	R30,R12
    00819 9676      ADIW	R30,0x16
    0081A 8020      LD	R2,Z
    0081B 8031      LDD	R3,Z+1
    0081C 8042      LDD	R4,Z+2
    0081D 8053      LDD	R5,Z+3
    0081E 886A      LDD	R6,Y+18
    0081F 887B      LDD	R7,Y+19
    00820 888C      LDD	R8,Y+20
    00821 889D      LDD	R9,Y+21
    00822 1462      CP	R6,R2
    00823 0473      CPC	R7,R3
    00824 0484      CPC	R8,R4
    00825 0495      CPC	R9,R5
    00826 F018      BCS	0x082A
(0937) 		res = FR_INT_ERR;
    00827 E082      LDI	R24,2
    00828 2EA8      MOV	R10,R24
(0938) 
(0939) 	} else {
    00829 C088      RJMP	0x08B2
(0940) 		res = FR_OK;
    0082A 24AA      CLR	R10
    0082B C076      RJMP	0x08A2
(0941) 		while (clst < fs->n_fatent) {			/* Not a last link? */
(0942) 			nxt = get_fat(fs, clst);			/* Get cluster status */
    0082C 882A      LDD	R2,Y+18
    0082D 883B      LDD	R3,Y+19
    0082E 884C      LDD	R4,Y+20
    0082F 885D      LDD	R5,Y+21
    00830 8248      ST	Y,R4
    00831 8259      STD	Y+1,R5
    00832 0191      MOVW	R18,R2
    00833 0186      MOVW	R16,R12
    00834 DCC1      RCALL	_get_fat
    00835 830E      STD	Y+6,R16
    00836 831F      STD	Y+7,R17
    00837 8728      STD	Y+8,R18
    00838 8739      STD	Y+9,R19
(0943) 			if (nxt == 0) break;				/* Empty cluster? */
    00839 802E      LDD	R2,Y+6
    0083A 803F      LDD	R3,Y+7
    0083B 8448      LDD	R4,Y+8
    0083C 8459      LDD	R5,Y+9
    0083D 9488      BCLR	0
    0083E 2022      TST	R2
    0083F 0432      CPC	R3,R2
    00840 0442      CPC	R4,R2
    00841 0452      CPC	R5,R2
    00842 F409      BNE	0x0844
    00843 C06E      RJMP	0x08B2
(0944) 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    00844 E041      LDI	R20,1
    00845 E050      LDI	R21,0
    00846 E060      LDI	R22,0
    00847 E070      LDI	R23,0
    00848 802E      LDD	R2,Y+6
    00849 803F      LDD	R3,Y+7
    0084A 8448      LDD	R4,Y+8
    0084B 8459      LDD	R5,Y+9
    0084C 1624      CP	R2,R20
    0084D 0635      CPC	R3,R21
    0084E 0646      CPC	R4,R22
    0084F 0657      CPC	R5,R23
    00850 F419      BNE	0x0854
    00851 E082      LDI	R24,2
    00852 2EA8      MOV	R10,R24
    00853 C05E      RJMP	0x08B2
(0945) 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    00854 EF4F      LDI	R20,0xFF
    00855 EF5F      LDI	R21,0xFF
    00856 EF6F      LDI	R22,0xFF
    00857 EF7F      LDI	R23,0xFF
    00858 802E      LDD	R2,Y+6
    00859 803F      LDD	R3,Y+7
    0085A 8448      LDD	R4,Y+8
    0085B 8459      LDD	R5,Y+9
    0085C 1624      CP	R2,R20
    0085D 0635      CPC	R3,R21
    0085E 0646      CPC	R4,R22
    0085F 0657      CPC	R5,R23
    00860 F419      BNE	0x0864
    00861 24AA      CLR	R10
    00862 94A3      INC	R10
    00863 C04E      RJMP	0x08B2
(0946) 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    00864 E080      LDI	R24,0
    00865 838A      STD	Y+2,R24
    00866 838B      STD	Y+3,R24
    00867 838C      STD	Y+4,R24
    00868 838D      STD	Y+5,R24
    00869 882A      LDD	R2,Y+18
    0086A 883B      LDD	R3,Y+19
    0086B 884C      LDD	R4,Y+20
    0086C 885D      LDD	R5,Y+21
    0086D 8248      ST	Y,R4
    0086E 8259      STD	Y+1,R5
    0086F 0191      MOVW	R18,R2
    00870 0186      MOVW	R16,R12
    00871 DDD4      RCALL	_put_fat
    00872 2EA0      MOV	R10,R16
(0947) 			if (res != FR_OK) break;
    00873 2300      TST	R16
    00874 F009      BEQ	0x0876
    00875 C03C      RJMP	0x08B2
(0948) 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    00876 EF4F      LDI	R20,0xFF
    00877 EF5F      LDI	R21,0xFF
    00878 EF6F      LDI	R22,0xFF
    00879 EF7F      LDI	R23,0xFF
    0087A 01F6      MOVW	R30,R12
    0087B 8426      LDD	R2,Z+14
    0087C 8437      LDD	R3,Z+15
    0087D 8840      LDD	R4,Z+16
    0087E 8851      LDD	R5,Z+17
    0087F 1624      CP	R2,R20
    00880 0635      CPC	R3,R21
    00881 0646      CPC	R4,R22
    00882 0657      CPC	R5,R23
    00883 F0B1      BEQ	0x089A
(0949) 				fs->free_clust++;
    00884 01CF      MOVW	R24,R30
    00885 960E      ADIW	R24,0xE
    00886 E041      LDI	R20,1
    00887 E050      LDI	R21,0
    00888 E060      LDI	R22,0
    00889 E070      LDI	R23,0
    0088A 01FC      MOVW	R30,R24
    0088B 8020      LD	R2,Z
    0088C 8031      LDD	R3,Z+1
    0088D 8042      LDD	R4,Z+2
    0088E 8053      LDD	R5,Z+3
    0088F 0E24      ADD	R2,R20
    00890 1E35      ADC	R3,R21
    00891 1E46      ADC	R4,R22
    00892 1E57      ADC	R5,R23
    00893 8220      ST	Z,R2
    00894 8231      STD	Z+1,R3
    00895 8242      STD	Z+2,R4
    00896 8253      STD	Z+3,R5
(0950) 				fs->fsi_flag = 1;
    00897 E081      LDI	R24,1
    00898 01F6      MOVW	R30,R12
    00899 8385      STD	Z+5,R24
(0951) 			}
(0952) #if _USE_ERASE
(0953) 			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
(0954) 				ecl = nxt;
(0955) 			} else {				/* End of contiguous clusters */ 
(0956) 				resion[0] = clust2sect(fs, scl);					/* Start sector */
(0957) 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
(0958) 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
(0959) 				scl = ecl = nxt;
(0960) 			}
(0961) #endif
(0962) 			clst = nxt;	/* Next cluster */
    0089A 802E      LDD	R2,Y+6
    0089B 803F      LDD	R3,Y+7
    0089C 8448      LDD	R4,Y+8
    0089D 8459      LDD	R5,Y+9
    0089E 8A2A      STD	Y+18,R2
    0089F 8A3B      STD	Y+19,R3
    008A0 8A4C      STD	Y+20,R4
    008A1 8A5D      STD	Y+21,R5
    008A2 01F6      MOVW	R30,R12
    008A3 9676      ADIW	R30,0x16
    008A4 8020      LD	R2,Z
    008A5 8031      LDD	R3,Z+1
    008A6 8042      LDD	R4,Z+2
    008A7 8053      LDD	R5,Z+3
    008A8 886A      LDD	R6,Y+18
    008A9 887B      LDD	R7,Y+19
    008AA 888C      LDD	R8,Y+20
    008AB 889D      LDD	R9,Y+21
    008AC 1462      CP	R6,R2
    008AD 0473      CPC	R7,R3
    008AE 0484      CPC	R8,R4
    008AF 0495      CPC	R9,R5
    008B0 F408      BCC	0x08B2
    008B1 CF7A      RJMP	0x082C
(0963) 		}
(0964) 	}
(0965) 
(0966) 	return res;
    008B2 2D0A      MOV	R16,R10
    008B3 962A      ADIW	R28,0xA
    008B4 940E 3CB9 CALL	pop_xgsetF03C
    008B6 9622      ADIW	R28,2
    008B7 9508      RET
ff.c:create_chain:
  res                  --> R10
  scl                  --> Y,+14
  cs                   --> Y,+10
  ncl                  --> Y,+6
  clst                 --> Y,+32
  fs                   --> R12
    008B8 933A      ST	-Y,R19
    008B9 932A      ST	-Y,R18
    008BA 940E 3C75 CALL	push_xgsetF0FC
    008BC 0168      MOVW	R12,R16
    008BD 9766      SBIW	R28,0x16
(0967) }
(0968) #endif
(0969) 
(0970) 
(0971) 
(0972) 
(0973) /*-----------------------------------------------------------------------*/
(0974) /* FAT handling - Stretch or Create a cluster chain                      */
(0975) /*-----------------------------------------------------------------------*/
(0976) #if !_FS_READONLY
(0977) static
(0978) DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
(0979) 	FATFS *fs,			/* File system object */
(0980) 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
(0981) )
(0982) {
(0983) 	DWORD cs, ncl, scl;
(0984) 	FRESULT res;
(0985) 
(0986) 
(0987) 	if (clst == 0) {		/* Create a new chain */
    008BE A028      LDD	R2,Y+32
    008BF A039      LDD	R3,Y+33
    008C0 A04A      LDD	R4,Y+34
    008C1 A05B      LDD	R5,Y+35
    008C2 9488      BCLR	0
    008C3 2022      TST	R2
    008C4 0432      CPC	R3,R2
    008C5 0442      CPC	R4,R2
    008C6 0452      CPC	R5,R2
    008C7 F559      BNE	0x08F3
(0988) 		scl = fs->last_clust;			/* Get suggested start point */
    008C8 01F6      MOVW	R30,R12
    008C9 963A      ADIW	R30,0xA
    008CA 8020      LD	R2,Z
    008CB 8031      LDD	R3,Z+1
    008CC 8042      LDD	R4,Z+2
    008CD 8053      LDD	R5,Z+3
    008CE 862E      STD	Y+14,R2
    008CF 863F      STD	Y+15,R3
    008D0 8A48      STD	Y+16,R4
    008D1 8A59      STD	Y+17,R5
(0989) 		if (!scl || scl >= fs->n_fatent) scl = 1;
    008D2 842E      LDD	R2,Y+14
    008D3 843F      LDD	R3,Y+15
    008D4 8848      LDD	R4,Y+16
    008D5 8859      LDD	R5,Y+17
    008D6 9488      BCLR	0
    008D7 2022      TST	R2
    008D8 0432      CPC	R3,R2
    008D9 0442      CPC	R4,R2
    008DA 0452      CPC	R5,R2
    008DB F081      BEQ	0x08EC
    008DC 01F6      MOVW	R30,R12
    008DD 9676      ADIW	R30,0x16
    008DE 8020      LD	R2,Z
    008DF 8031      LDD	R3,Z+1
    008E0 8042      LDD	R4,Z+2
    008E1 8053      LDD	R5,Z+3
    008E2 846E      LDD	R6,Y+14
    008E3 847F      LDD	R7,Y+15
    008E4 8888      LDD	R8,Y+16
    008E5 8899      LDD	R9,Y+17
    008E6 1462      CP	R6,R2
    008E7 0473      CPC	R7,R3
    008E8 0484      CPC	R8,R4
    008E9 0495      CPC	R9,R5
    008EA F408      BCC	0x08EC
    008EB C040      RJMP	0x092C
    008EC E081      LDI	R24,1
    008ED 878E      STD	Y+14,R24
    008EE E080      LDI	R24,0
    008EF 878F      STD	Y+15,R24
    008F0 8B88      STD	Y+16,R24
    008F1 8B89      STD	Y+17,R24
(0990) 	}
    008F2 C039      RJMP	0x092C
(0991) 	else {					/* Stretch the current chain */
(0992) 		cs = get_fat(fs, clst);			/* Check the cluster status */
    008F3 A028      LDD	R2,Y+32
    008F4 A039      LDD	R3,Y+33
    008F5 A04A      LDD	R4,Y+34
    008F6 A05B      LDD	R5,Y+35
    008F7 8248      ST	Y,R4
    008F8 8259      STD	Y+1,R5
    008F9 0191      MOVW	R18,R2
    008FA 0186      MOVW	R16,R12
    008FB DBFA      RCALL	_get_fat
    008FC 870A      STD	Y+10,R16
    008FD 871B      STD	Y+11,R17
    008FE 872C      STD	Y+12,R18
    008FF 873D      STD	Y+13,R19
(0993) 		if (cs < 2) return 1;			/* It is an invalid cluster */
    00900 E042      LDI	R20,2
    00901 E050      LDI	R21,0
    00902 E060      LDI	R22,0
    00903 E070      LDI	R23,0
    00904 842A      LDD	R2,Y+10
    00905 843B      LDD	R3,Y+11
    00906 844C      LDD	R4,Y+12
    00907 845D      LDD	R5,Y+13
    00908 1624      CP	R2,R20
    00909 0635      CPC	R3,R21
    0090A 0646      CPC	R4,R22
    0090B 0657      CPC	R5,R23
    0090C F428      BCC	0x0912
    0090D E001      LDI	R16,1
    0090E E010      LDI	R17,0
    0090F E020      LDI	R18,0
    00910 E030      LDI	R19,0
    00911 C119      RJMP	0x0A2B
(0994) 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    00912 01F6      MOVW	R30,R12
    00913 9676      ADIW	R30,0x16
    00914 8020      LD	R2,Z
    00915 8031      LDD	R3,Z+1
    00916 8042      LDD	R4,Z+2
    00917 8053      LDD	R5,Z+3
    00918 846A      LDD	R6,Y+10
    00919 847B      LDD	R7,Y+11
    0091A 848C      LDD	R8,Y+12
    0091B 849D      LDD	R9,Y+13
    0091C 1462      CP	R6,R2
    0091D 0473      CPC	R7,R3
    0091E 0484      CPC	R8,R4
    0091F 0495      CPC	R9,R5
    00920 F418      BCC	0x0924
    00921 0183      MOVW	R16,R6
    00922 0194      MOVW	R18,R8
    00923 C107      RJMP	0x0A2B
(0995) 		scl = clst;
    00924 A028      LDD	R2,Y+32
    00925 A039      LDD	R3,Y+33
    00926 A04A      LDD	R4,Y+34
    00927 A05B      LDD	R5,Y+35
    00928 862E      STD	Y+14,R2
    00929 863F      STD	Y+15,R3
    0092A 8A48      STD	Y+16,R4
    0092B 8A59      STD	Y+17,R5
(0996) 	}
(0997) 
(0998) 	ncl = scl;				/* Start cluster */
    0092C 842E      LDD	R2,Y+14
    0092D 843F      LDD	R3,Y+15
    0092E 8848      LDD	R4,Y+16
    0092F 8859      LDD	R5,Y+17
    00930 822E      STD	Y+6,R2
    00931 823F      STD	Y+7,R3
    00932 8648      STD	Y+8,R4
    00933 8659      STD	Y+9,R5
(0999) 	for (;;) {
(1000) 		ncl++;							/* Next cluster */
    00934 E041      LDI	R20,1
    00935 E050      LDI	R21,0
    00936 E060      LDI	R22,0
    00937 E070      LDI	R23,0
    00938 802E      LDD	R2,Y+6
    00939 803F      LDD	R3,Y+7
    0093A 8448      LDD	R4,Y+8
    0093B 8459      LDD	R5,Y+9
    0093C 0E24      ADD	R2,R20
    0093D 1E35      ADC	R3,R21
    0093E 1E46      ADC	R4,R22
    0093F 1E57      ADC	R5,R23
    00940 822E      STD	Y+6,R2
    00941 823F      STD	Y+7,R3
    00942 8648      STD	Y+8,R4
    00943 8659      STD	Y+9,R5
(1001) 		if (ncl >= fs->n_fatent) {		/* Wrap around */
    00944 01F6      MOVW	R30,R12
    00945 9676      ADIW	R30,0x16
    00946 8020      LD	R2,Z
    00947 8031      LDD	R3,Z+1
    00948 8042      LDD	R4,Z+2
    00949 8053      LDD	R5,Z+3
    0094A 806E      LDD	R6,Y+6
    0094B 807F      LDD	R7,Y+7
    0094C 8488      LDD	R8,Y+8
    0094D 8499      LDD	R9,Y+9
    0094E 1462      CP	R6,R2
    0094F 0473      CPC	R7,R3
    00950 0484      CPC	R8,R4
    00951 0495      CPC	R9,R5
    00952 F0C0      BCS	0x096B
(1002) 			ncl = 2;
    00953 E082      LDI	R24,2
    00954 838E      STD	Y+6,R24
    00955 E080      LDI	R24,0
    00956 838F      STD	Y+7,R24
    00957 8788      STD	Y+8,R24
    00958 8789      STD	Y+9,R24
(1003) 			if (ncl > scl) return 0;	/* No free cluster */
    00959 842E      LDD	R2,Y+14
    0095A 843F      LDD	R3,Y+15
    0095B 8848      LDD	R4,Y+16
    0095C 8859      LDD	R5,Y+17
    0095D 806E      LDD	R6,Y+6
    0095E 807F      LDD	R7,Y+7
    0095F 8488      LDD	R8,Y+8
    00960 8499      LDD	R9,Y+9
    00961 1426      CP	R2,R6
    00962 0437      CPC	R3,R7
    00963 0448      CPC	R4,R8
    00964 0459      CPC	R5,R9
    00965 F428      BCC	0x096B
    00966 E000      LDI	R16,0
    00967 E010      LDI	R17,0
    00968 E020      LDI	R18,0
    00969 E030      LDI	R19,0
    0096A C0C0      RJMP	0x0A2B
(1004) 		}
(1005) 		cs = get_fat(fs, ncl);			/* Get the cluster status */
    0096B 802E      LDD	R2,Y+6
    0096C 803F      LDD	R3,Y+7
    0096D 8448      LDD	R4,Y+8
    0096E 8459      LDD	R5,Y+9
    0096F 8248      ST	Y,R4
    00970 8259      STD	Y+1,R5
    00971 0191      MOVW	R18,R2
    00972 0186      MOVW	R16,R12
    00973 DB82      RCALL	_get_fat
    00974 870A      STD	Y+10,R16
    00975 871B      STD	Y+11,R17
    00976 872C      STD	Y+12,R18
    00977 873D      STD	Y+13,R19
(1006) 		if (cs == 0) break;				/* Found a free cluster */
    00978 842A      LDD	R2,Y+10
    00979 843B      LDD	R3,Y+11
    0097A 844C      LDD	R4,Y+12
    0097B 845D      LDD	R5,Y+13
    0097C 9488      BCLR	0
    0097D 2022      TST	R2
    0097E 0432      CPC	R3,R2
    0097F 0442      CPC	R4,R2
    00980 0452      CPC	R5,R2
    00981 F409      BNE	0x0983
    00982 C02E      RJMP	0x09B1
(1007) 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    00983 EF4F      LDI	R20,0xFF
    00984 EF5F      LDI	R21,0xFF
    00985 EF6F      LDI	R22,0xFF
    00986 EF7F      LDI	R23,0xFF
    00987 842A      LDD	R2,Y+10
    00988 843B      LDD	R3,Y+11
    00989 844C      LDD	R4,Y+12
    0098A 845D      LDD	R5,Y+13
    0098B 1624      CP	R2,R20
    0098C 0635      CPC	R3,R21
    0098D 0646      CPC	R4,R22
    0098E 0657      CPC	R5,R23
    0098F F049      BEQ	0x0999
    00990 E041      LDI	R20,1
    00991 E050      LDI	R21,0
    00992 E060      LDI	R22,0
    00993 E070      LDI	R23,0
    00994 1624      CP	R2,R20
    00995 0635      CPC	R3,R21
    00996 0646      CPC	R4,R22
    00997 0657      CPC	R5,R23
    00998 F429      BNE	0x099E
(1008) 			return cs;
    00999 850A      LDD	R16,Y+10
    0099A 851B      LDD	R17,Y+11
    0099B 852C      LDD	R18,Y+12
    0099C 853D      LDD	R19,Y+13
    0099D C08D      RJMP	0x0A2B
(1009) 		if (ncl == scl) return 0;		/* No free cluster */
    0099E 842E      LDD	R2,Y+14
    0099F 843F      LDD	R3,Y+15
    009A0 8848      LDD	R4,Y+16
    009A1 8859      LDD	R5,Y+17
    009A2 806E      LDD	R6,Y+6
    009A3 807F      LDD	R7,Y+7
    009A4 8488      LDD	R8,Y+8
    009A5 8499      LDD	R9,Y+9
    009A6 1462      CP	R6,R2
    009A7 0473      CPC	R7,R3
    009A8 0484      CPC	R8,R4
    009A9 0495      CPC	R9,R5
    009AA F009      BEQ	0x09AC
    009AB CF88      RJMP	0x0934
    009AC E000      LDI	R16,0
    009AD E010      LDI	R17,0
    009AE E020      LDI	R18,0
    009AF E030      LDI	R19,0
    009B0 C07A      RJMP	0x0A2B
(1010) 	}
(1011) 
(1012) 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    009B1 EF8F      LDI	R24,0xFF
    009B2 838A      STD	Y+2,R24
    009B3 838B      STD	Y+3,R24
    009B4 838C      STD	Y+4,R24
    009B5 E08F      LDI	R24,0xF
    009B6 838D      STD	Y+5,R24
    009B7 802E      LDD	R2,Y+6
    009B8 803F      LDD	R3,Y+7
    009B9 8448      LDD	R4,Y+8
    009BA 8459      LDD	R5,Y+9
    009BB 8248      ST	Y,R4
    009BC 8259      STD	Y+1,R5
    009BD 0191      MOVW	R18,R2
    009BE 0186      MOVW	R16,R12
    009BF DC86      RCALL	_put_fat
    009C0 2EA0      MOV	R10,R16
(1013) 	if (res == FR_OK && clst != 0) {
    009C1 2300      TST	R16
    009C2 F4E1      BNE	0x09DF
    009C3 A028      LDD	R2,Y+32
    009C4 A039      LDD	R3,Y+33
    009C5 A04A      LDD	R4,Y+34
    009C6 A05B      LDD	R5,Y+35
    009C7 9488      BCLR	0
    009C8 2022      TST	R2
    009C9 0432      CPC	R3,R2
    009CA 0442      CPC	R4,R2
    009CB 0452      CPC	R5,R2
    009CC F091      BEQ	0x09DF
(1014) 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    009CD 802E      LDD	R2,Y+6
    009CE 803F      LDD	R3,Y+7
    009CF 8448      LDD	R4,Y+8
    009D0 8459      LDD	R5,Y+9
    009D1 822A      STD	Y+2,R2
    009D2 823B      STD	Y+3,R3
    009D3 824C      STD	Y+4,R4
    009D4 825D      STD	Y+5,R5
    009D5 A028      LDD	R2,Y+32
    009D6 A039      LDD	R3,Y+33
    009D7 A04A      LDD	R4,Y+34
    009D8 A05B      LDD	R5,Y+35
    009D9 8248      ST	Y,R4
    009DA 8259      STD	Y+1,R5
    009DB 0191      MOVW	R18,R2
    009DC 0186      MOVW	R16,R12
    009DD DC68      RCALL	_put_fat
    009DE 2EA0      MOV	R10,R16
(1015) 	}
(1016) 	if (res == FR_OK) {
    009DF 20AA      TST	R10
    009E0 F009      BEQ	0x09E2
    009E1 C02E      RJMP	0x0A10
(1017) 		fs->last_clust = ncl;			/* Update FSINFO */
    009E2 802E      LDD	R2,Y+6
    009E3 803F      LDD	R3,Y+7
    009E4 8448      LDD	R4,Y+8
    009E5 8459      LDD	R5,Y+9
    009E6 01F6      MOVW	R30,R12
    009E7 8622      STD	Z+10,R2
    009E8 8633      STD	Z+11,R3
    009E9 8644      STD	Z+12,R4
    009EA 8655      STD	Z+13,R5
(1018) 		if (fs->free_clust != 0xFFFFFFFF) {
    009EB EF4F      LDI	R20,0xFF
    009EC EF5F      LDI	R21,0xFF
    009ED EF6F      LDI	R22,0xFF
    009EE EF7F      LDI	R23,0xFF
    009EF 8426      LDD	R2,Z+14
    009F0 8437      LDD	R3,Z+15
    009F1 8840      LDD	R4,Z+16
    009F2 8851      LDD	R5,Z+17
    009F3 1624      CP	R2,R20
    009F4 0635      CPC	R3,R21
    009F5 0646      CPC	R4,R22
    009F6 0657      CPC	R5,R23
    009F7 F179      BEQ	0x0A27
(1019) 			fs->free_clust--;
    009F8 01CF      MOVW	R24,R30
    009F9 960E      ADIW	R24,0xE
    009FA 017C      MOVW	R14,R24
    009FB E041      LDI	R20,1
    009FC E050      LDI	R21,0
    009FD E060      LDI	R22,0
    009FE E070      LDI	R23,0
    009FF 01FC      MOVW	R30,R24
    00A00 8020      LD	R2,Z
    00A01 8031      LDD	R3,Z+1
    00A02 8042      LDD	R4,Z+2
    00A03 8053      LDD	R5,Z+3
    00A04 1A24      SUB	R2,R20
    00A05 0A35      SBC	R3,R21
    00A06 0A46      SBC	R4,R22
    00A07 0A57      SBC	R5,R23
    00A08 8220      ST	Z,R2
    00A09 8231      STD	Z+1,R3
    00A0A 8242      STD	Z+2,R4
    00A0B 8253      STD	Z+3,R5
(1020) 			fs->fsi_flag = 1;
    00A0C E081      LDI	R24,1
    00A0D 01F6      MOVW	R30,R12
    00A0E 8385      STD	Z+5,R24
(1021) 		}
(1022) 	} else {
    00A0F C017      RJMP	0x0A27
(1023) 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    00A10 2D8A      MOV	R24,R10
    00A11 3081      CPI	R24,1
    00A12 F431      BNE	0x0A19
    00A13 EF8F      LDI	R24,0xFF
    00A14 8B8A      STD	Y+18,R24
    00A15 8B8B      STD	Y+19,R24
    00A16 8B8C      STD	Y+20,R24
    00A17 8B8D      STD	Y+21,R24
    00A18 C006      RJMP	0x0A1F
    00A19 E081      LDI	R24,1
    00A1A 8B8A      STD	Y+18,R24
    00A1B E080      LDI	R24,0
    00A1C 8B8B      STD	Y+19,R24
    00A1D 8B8C      STD	Y+20,R24
    00A1E 8B8D      STD	Y+21,R24
    00A1F 882A      LDD	R2,Y+18
    00A20 883B      LDD	R3,Y+19
    00A21 884C      LDD	R4,Y+20
    00A22 885D      LDD	R5,Y+21
    00A23 822E      STD	Y+6,R2
    00A24 823F      STD	Y+7,R3
    00A25 8648      STD	Y+8,R4
    00A26 8659      STD	Y+9,R5
(1024) 	}
(1025) 
(1026) 	return ncl;		/* Return new cluster number or error code */
    00A27 810E      LDD	R16,Y+6
    00A28 811F      LDD	R17,Y+7
    00A29 8528      LDD	R18,Y+8
    00A2A 8539      LDD	R19,Y+9
    00A2B 9666      ADIW	R28,0x16
    00A2C 940E 3C6A CALL	pop_xgsetF0FC
    00A2E 9622      ADIW	R28,2
    00A2F 9508      RET
ff.c:clmt_clust:
  tbl                  --> R10
  cl                   --> Y,+4
  ncl                  --> Y,+0
  ofs                  --> Y,+12
  fp                   --> R12
    00A30 933A      ST	-Y,R19
    00A31 932A      ST	-Y,R18
    00A32 940E 3C7B CALL	push_xgset003C
    00A34 0168      MOVW	R12,R16
    00A35 9728      SBIW	R28,0x8
(1027) }
(1028) #endif /* !_FS_READONLY */
(1029) 
(1030) 
(1031) 
(1032) /*-----------------------------------------------------------------------*/
(1033) /* FAT handling - Convert offset into cluster with link map table        */
(1034) /*-----------------------------------------------------------------------*/
(1035) 
(1036) #if _USE_FASTSEEK
(1037) static
(1038) DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
(1039) 	FIL* fp,		/* Pointer to the file object */
(1040) 	DWORD ofs		/* File offset to be converted to cluster# */
(1041) )
(1042) {
(1043) 	DWORD cl, ncl, *tbl;
(1044) 
(1045) 
(1046) 	tbl = fp->cltbl + 1;	/* Top of CLMT */
    00A36 01F6      MOVW	R30,R12
    00A37 96B0      ADIW	R30,0x20
    00A38 8180      LD	R24,Z
    00A39 8191      LDD	R25,Z+1
    00A3A 9604      ADIW	R24,4
    00A3B 015C      MOVW	R10,R24
(1047) 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
    00A3C E089      LDI	R24,0x9
    00A3D E090      LDI	R25,0
    00A3E 850C      LDD	R16,Y+12
    00A3F 851D      LDD	R17,Y+13
    00A40 852E      LDD	R18,Y+14
    00A41 853F      LDD	R19,Y+15
    00A42 938A      ST	-Y,R24
    00A43 940E 3D10 CALL	lsr32
    00A45 01F6      MOVW	R30,R12
    00A46 93AF      PUSH	R26
    00A47 93BF      PUSH	R27
    00A48 81A0      LD	R26,Z
    00A49 81B1      LDD	R27,Z+1
    00A4A 01FD      MOVW	R30,R26
    00A4B 91BF      POP	R27
    00A4C 91AF      POP	R26
    00A4D 9632      ADIW	R30,2
    00A4E 8020      LD	R2,Z
    00A4F 2433      CLR	R3
    00A50 2444      CLR	R4
    00A51 2455      CLR	R5
    00A52 925A      ST	-Y,R5
    00A53 924A      ST	-Y,R4
    00A54 923A      ST	-Y,R3
    00A55 922A      ST	-Y,R2
    00A56 940E 3B7B CALL	div32u
    00A58 830C      STD	Y+4,R16
    00A59 831D      STD	Y+5,R17
    00A5A 832E      STD	Y+6,R18
    00A5B 833F      STD	Y+7,R19
(1048) 	for (;;) {
(1049) 		ncl = *tbl++;			/* Number of cluters in the fragment */
    00A5C 01F5      MOVW	R30,R10
    00A5D 9021      LD	R2,Z+
    00A5E 9031      LD	R3,Z+
    00A5F 9041      LD	R4,Z+
    00A60 9051      LD	R5,Z+
    00A61 015F      MOVW	R10,R30
    00A62 8228      ST	Y,R2
    00A63 8239      STD	Y+1,R3
    00A64 824A      STD	Y+2,R4
    00A65 825B      STD	Y+3,R5
(1050) 		if (!ncl) return 0;		/* End of table? (error) */
    00A66 8028      LD	R2,Y
    00A67 8039      LDD	R3,Y+1
    00A68 804A      LDD	R4,Y+2
    00A69 805B      LDD	R5,Y+3
    00A6A 9488      BCLR	0
    00A6B 2022      TST	R2
    00A6C 0432      CPC	R3,R2
    00A6D 0442      CPC	R4,R2
    00A6E 0452      CPC	R5,R2
    00A6F F429      BNE	0x0A75
    00A70 E000      LDI	R16,0
    00A71 E010      LDI	R17,0
    00A72 E020      LDI	R18,0
    00A73 E030      LDI	R19,0
    00A74 C02F      RJMP	0x0AA4
(1051) 		if (cl < ncl) break;	/* In this fragment? */
    00A75 8028      LD	R2,Y
    00A76 8039      LDD	R3,Y+1
    00A77 804A      LDD	R4,Y+2
    00A78 805B      LDD	R5,Y+3
    00A79 806C      LDD	R6,Y+4
    00A7A 807D      LDD	R7,Y+5
    00A7B 808E      LDD	R8,Y+6
    00A7C 809F      LDD	R9,Y+7
    00A7D 1462      CP	R6,R2
    00A7E 0473      CPC	R7,R3
    00A7F 0484      CPC	R8,R4
    00A80 0495      CPC	R9,R5
    00A81 F408      BCC	0x0A83
    00A82 C014      RJMP	0x0A97
(1052) 		cl -= ncl; tbl++;		/* Next fragment */
    00A83 8028      LD	R2,Y
    00A84 8039      LDD	R3,Y+1
    00A85 804A      LDD	R4,Y+2
    00A86 805B      LDD	R5,Y+3
    00A87 806C      LDD	R6,Y+4
    00A88 807D      LDD	R7,Y+5
    00A89 808E      LDD	R8,Y+6
    00A8A 809F      LDD	R9,Y+7
    00A8B 1862      SUB	R6,R2
    00A8C 0873      SBC	R7,R3
    00A8D 0884      SBC	R8,R4
    00A8E 0895      SBC	R9,R5
    00A8F 826C      STD	Y+4,R6
    00A90 827D      STD	Y+5,R7
    00A91 828E      STD	Y+6,R8
    00A92 829F      STD	Y+7,R9
    00A93 01C5      MOVW	R24,R10
    00A94 9604      ADIW	R24,4
    00A95 015C      MOVW	R10,R24
    00A96 CFC5      RJMP	0x0A5C
(1053) 	}
(1054) 	return cl + *tbl;	/* Return the cluster number */
    00A97 01F5      MOVW	R30,R10
    00A98 8020      LD	R2,Z
    00A99 8031      LDD	R3,Z+1
    00A9A 8042      LDD	R4,Z+2
    00A9B 8053      LDD	R5,Z+3
    00A9C 810C      LDD	R16,Y+4
    00A9D 811D      LDD	R17,Y+5
    00A9E 812E      LDD	R18,Y+6
    00A9F 813F      LDD	R19,Y+7
    00AA0 0D02      ADD	R16,R2
    00AA1 1D13      ADC	R17,R3
    00AA2 1D24      ADC	R18,R4
    00AA3 1D35      ADC	R19,R5
    00AA4 9628      ADIW	R28,0x8
    00AA5 940E 3C55 CALL	pop_xgset003C
    00AA7 9622      ADIW	R28,2
    00AA8 9508      RET
ff.c:dir_sdi:
  ic                   --> R14
  clst                 --> Y,+2
  idx                  --> R12
  dj                   --> R10
    00AA9 940E 3C75 CALL	push_xgsetF0FC
    00AAB 0169      MOVW	R12,R18
    00AAC 0158      MOVW	R10,R16
    00AAD 9726      SBIW	R28,6
(1055) }
(1056) #endif	/* _USE_FASTSEEK */
(1057) 
(1058) 
(1059) 
(1060) /*-----------------------------------------------------------------------*/
(1061) /* Directory handling - Set directory index                              */
(1062) /*-----------------------------------------------------------------------*/
(1063) 
(1064) static
(1065) FRESULT dir_sdi (
(1066) 	DIR *dj,		/* Pointer to directory object */
(1067) 	WORD idx		/* Directory index number */
(1068) )
(1069) {
(1070) 	DWORD clst;
(1071) 	WORD ic;
(1072) 
(1073) 
(1074) 	dj->index = idx;
    00AAE 01F5      MOVW	R30,R10
    00AAF 82D5      STD	Z+5,R13
    00AB0 82C4      STD	Z+4,R12
(1075) 	clst = dj->sclust;
    00AB1 9636      ADIW	R30,6
    00AB2 8020      LD	R2,Z
    00AB3 8031      LDD	R3,Z+1
    00AB4 8042      LDD	R4,Z+2
    00AB5 8053      LDD	R5,Z+3
    00AB6 822A      STD	Y+2,R2
    00AB7 823B      STD	Y+3,R3
    00AB8 824C      STD	Y+4,R4
    00AB9 825D      STD	Y+5,R5
(1076) 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    00ABA E041      LDI	R20,1
    00ABB E050      LDI	R21,0
    00ABC E060      LDI	R22,0
    00ABD E070      LDI	R23,0
    00ABE 802A      LDD	R2,Y+2
    00ABF 803B      LDD	R3,Y+3
    00AC0 804C      LDD	R4,Y+4
    00AC1 805D      LDD	R5,Y+5
    00AC2 1624      CP	R2,R20
    00AC3 0635      CPC	R3,R21
    00AC4 0646      CPC	R4,R22
    00AC5 0657      CPC	R5,R23
    00AC6 F089      BEQ	0x0AD8
    00AC7 01F5      MOVW	R30,R10
    00AC8 81A0      LD	R26,Z
    00AC9 81B1      LDD	R27,Z+1
    00ACA 9656      ADIW	R26,0x16
    00ACB 902D      LD	R2,X+
    00ACC 903D      LD	R3,X+
    00ACD 904D      LD	R4,X+
    00ACE 905C      LD	R5,X
    00ACF 806A      LDD	R6,Y+2
    00AD0 807B      LDD	R7,Y+3
    00AD1 808C      LDD	R8,Y+4
    00AD2 809D      LDD	R9,Y+5
    00AD3 1462      CP	R6,R2
    00AD4 0473      CPC	R7,R3
    00AD5 0484      CPC	R8,R4
    00AD6 0495      CPC	R9,R5
    00AD7 F010      BCS	0x0ADA
(1077) 		return FR_INT_ERR;
    00AD8 E002      LDI	R16,2
    00AD9 C0D6      RJMP	0x0BB0
(1078) 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    00ADA 802A      LDD	R2,Y+2
    00ADB 803B      LDD	R3,Y+3
    00ADC 804C      LDD	R4,Y+4
    00ADD 805D      LDD	R5,Y+5
    00ADE 9488      BCLR	0
    00ADF 2022      TST	R2
    00AE0 0432      CPC	R3,R2
    00AE1 0442      CPC	R4,R2
    00AE2 0452      CPC	R5,R2
    00AE3 F479      BNE	0x0AF3
    00AE4 01F5      MOVW	R30,R10
    00AE5 81A0      LD	R26,Z
    00AE6 81B1      LDD	R27,Z+1
    00AE7 918C      LD	R24,X
    00AE8 3083      CPI	R24,3
    00AE9 F449      BNE	0x0AF3
(1079) 		clst = dj->fs->dirbase;
    00AEA 9692      ADIW	R26,0x22
    00AEB 902D      LD	R2,X+
    00AEC 903D      LD	R3,X+
    00AED 904D      LD	R4,X+
    00AEE 905C      LD	R5,X
    00AEF 822A      STD	Y+2,R2
    00AF0 823B      STD	Y+3,R3
    00AF1 824C      STD	Y+4,R4
    00AF2 825D      STD	Y+5,R5
(1080) 
(1081) 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    00AF3 802A      LDD	R2,Y+2
    00AF4 803B      LDD	R3,Y+3
    00AF5 804C      LDD	R4,Y+4
    00AF6 805D      LDD	R5,Y+5
    00AF7 9488      BCLR	0
    00AF8 2022      TST	R2
    00AF9 0432      CPC	R3,R2
    00AFA 0442      CPC	R4,R2
    00AFB 0452      CPC	R5,R2
    00AFC F009      BEQ	0x0AFE
    00AFD C02B      RJMP	0x0B29
(1082) 		dj->clust = clst;
    00AFE 01F5      MOVW	R30,R10
    00AFF 8622      STD	Z+10,R2
    00B00 8633      STD	Z+11,R3
    00B01 8644      STD	Z+12,R4
    00B02 8655      STD	Z+13,R5
(1083) 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    00B03 81A0      LD	R26,Z
    00B04 81B1      LDD	R27,Z+1
    00B05 9618      ADIW	R26,0x8
    00B06 902D      LD	R2,X+
    00B07 903C      LD	R3,X
    00B08 14C2      CP	R12,R2
    00B09 04D3      CPC	R13,R3
    00B0A F010      BCS	0x0B0D
(1084) 			return FR_INT_ERR;
    00B0B E002      LDI	R16,2
    00B0C C0A3      RJMP	0x0BB0
(1085) 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B0D 0116      MOVW	R2,R12
    00B0E 9436      LSR	R3
    00B0F 9427      ROR	R2
    00B10 9436      LSR	R3
    00B11 9427      ROR	R2
    00B12 9436      LSR	R3
    00B13 9427      ROR	R2
    00B14 9436      LSR	R3
    00B15 9427      ROR	R2
    00B16 2444      CLR	R4
    00B17 2455      CLR	R5
    00B18 01F5      MOVW	R30,R10
    00B19 81A0      LD	R26,Z
    00B1A 81B1      LDD	R27,Z+1
    00B1B 9692      ADIW	R26,0x22
    00B1C 906D      LD	R6,X+
    00B1D 907D      LD	R7,X+
    00B1E 908D      LD	R8,X+
    00B1F 909C      LD	R9,X
    00B20 0C62      ADD	R6,R2
    00B21 1C73      ADC	R7,R3
    00B22 1C84      ADC	R8,R4
    00B23 1C95      ADC	R9,R5
    00B24 8666      STD	Z+14,R6
    00B25 8677      STD	Z+15,R7
    00B26 8A80      STD	Z+16,R8
    00B27 8A91      STD	Z+17,R9
(1086) 	}
    00B28 C076      RJMP	0x0B9F
(1087) 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
(1088) 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    00B29 01F5      MOVW	R30,R10
    00B2A 93AF      PUSH	R26
    00B2B 93BF      PUSH	R27
    00B2C 81A0      LD	R26,Z
    00B2D 81B1      LDD	R27,Z+1
    00B2E 01FD      MOVW	R30,R26
    00B2F 91BF      POP	R27
    00B30 91AF      POP	R26
    00B31 8022      LDD	R2,Z+2
    00B32 E180      LDI	R24,0x10
    00B33 9D82      MUL	R24,R2
    00B34 0170      MOVW	R14,R0
    00B35 C040      RJMP	0x0B76
(1089) 		while (idx >= ic) {	/* Follow cluster chain */
(1090) 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    00B36 802A      LDD	R2,Y+2
    00B37 803B      LDD	R3,Y+3
    00B38 804C      LDD	R4,Y+4
    00B39 805D      LDD	R5,Y+5
    00B3A 8248      ST	Y,R4
    00B3B 8259      STD	Y+1,R5
    00B3C 0191      MOVW	R18,R2
    00B3D 01F5      MOVW	R30,R10
    00B3E 8100      LD	R16,Z
    00B3F 8111      LDD	R17,Z+1
    00B40 D9B5      RCALL	_get_fat
    00B41 830A      STD	Y+2,R16
    00B42 831B      STD	Y+3,R17
    00B43 832C      STD	Y+4,R18
    00B44 833D      STD	Y+5,R19
(1091) 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    00B45 EF4F      LDI	R20,0xFF
    00B46 EF5F      LDI	R21,0xFF
    00B47 EF6F      LDI	R22,0xFF
    00B48 EF7F      LDI	R23,0xFF
    00B49 802A      LDD	R2,Y+2
    00B4A 803B      LDD	R3,Y+3
    00B4B 804C      LDD	R4,Y+4
    00B4C 805D      LDD	R5,Y+5
    00B4D 1624      CP	R2,R20
    00B4E 0635      CPC	R3,R21
    00B4F 0646      CPC	R4,R22
    00B50 0657      CPC	R5,R23
    00B51 F411      BNE	0x0B54
    00B52 E001      LDI	R16,1
    00B53 C05C      RJMP	0x0BB0
(1092) 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    00B54 E042      LDI	R20,2
    00B55 E050      LDI	R21,0
    00B56 E060      LDI	R22,0
    00B57 E070      LDI	R23,0
    00B58 802A      LDD	R2,Y+2
    00B59 803B      LDD	R3,Y+3
    00B5A 804C      LDD	R4,Y+4
    00B5B 805D      LDD	R5,Y+5
    00B5C 1624      CP	R2,R20
    00B5D 0635      CPC	R3,R21
    00B5E 0646      CPC	R4,R22
    00B5F 0657      CPC	R5,R23
    00B60 F088      BCS	0x0B72
    00B61 01F5      MOVW	R30,R10
    00B62 81A0      LD	R26,Z
    00B63 81B1      LDD	R27,Z+1
    00B64 9656      ADIW	R26,0x16
    00B65 902D      LD	R2,X+
    00B66 903D      LD	R3,X+
    00B67 904D      LD	R4,X+
    00B68 905C      LD	R5,X
    00B69 806A      LDD	R6,Y+2
    00B6A 807B      LDD	R7,Y+3
    00B6B 808C      LDD	R8,Y+4
    00B6C 809D      LDD	R9,Y+5
    00B6D 1462      CP	R6,R2
    00B6E 0473      CPC	R7,R3
    00B6F 0484      CPC	R8,R4
    00B70 0495      CPC	R9,R5
    00B71 F010      BCS	0x0B74
(1093) 				return FR_INT_ERR;
    00B72 E002      LDI	R16,2
    00B73 C03C      RJMP	0x0BB0
(1094) 			idx -= ic;
    00B74 18CE      SUB	R12,R14
    00B75 08DF      SBC	R13,R15
    00B76 14CE      CP	R12,R14
    00B77 04DF      CPC	R13,R15
    00B78 F008      BCS	0x0B7A
    00B79 CFBC      RJMP	0x0B36
(1095) 		}
(1096) 		dj->clust = clst;
    00B7A 802A      LDD	R2,Y+2
    00B7B 803B      LDD	R3,Y+3
    00B7C 804C      LDD	R4,Y+4
    00B7D 805D      LDD	R5,Y+5
    00B7E 01F5      MOVW	R30,R10
    00B7F 8622      STD	Z+10,R2
    00B80 8633      STD	Z+11,R3
    00B81 8644      STD	Z+12,R4
    00B82 8655      STD	Z+13,R5
(1097) 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B83 8248      ST	Y,R4
    00B84 8259      STD	Y+1,R5
    00B85 0191      MOVW	R18,R2
    00B86 8100      LD	R16,Z
    00B87 8111      LDD	R17,Z+1
    00B88 D91B      RCALL	_clust2sect
    00B89 0116      MOVW	R2,R12
    00B8A 9436      LSR	R3
    00B8B 9427      ROR	R2
    00B8C 9436      LSR	R3
    00B8D 9427      ROR	R2
    00B8E 9436      LSR	R3
    00B8F 9427      ROR	R2
    00B90 9436      LSR	R3
    00B91 9427      ROR	R2
    00B92 2444      CLR	R4
    00B93 2455      CLR	R5
    00B94 0138      MOVW	R6,R16
    00B95 0149      MOVW	R8,R18
    00B96 0C62      ADD	R6,R2
    00B97 1C73      ADC	R7,R3
    00B98 1C84      ADC	R8,R4
    00B99 1C95      ADC	R9,R5
    00B9A 01F5      MOVW	R30,R10
    00B9B 8666      STD	Z+14,R6
    00B9C 8677      STD	Z+15,R7
    00B9D 8A80      STD	Z+16,R8
    00B9E 8A91      STD	Z+17,R9
(1098) 	}
(1099) 
(1100) 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    00B9F 0196      MOVW	R18,R12
    00BA0 702F      ANDI	R18,0xF
    00BA1 7030      ANDI	R19,0
    00BA2 E200      LDI	R16,0x20
    00BA3 E010      LDI	R17,0
    00BA4 940E 3C11 CALL	empy16s
    00BA6 0118      MOVW	R2,R16
    00BA7 01F5      MOVW	R30,R10
    00BA8 8180      LD	R24,Z
    00BA9 8191      LDD	R25,Z+1
    00BAA 968E      ADIW	R24,0x2E
    00BAB 0E28      ADD	R2,R24
    00BAC 1E39      ADC	R3,R25
    00BAD 8A33      STD	Z+19,R3
    00BAE 8A22      STD	Z+18,R2
(1101) 
(1102) 	return FR_OK;	/* Seek succeeded */
    00BAF 2700      CLR	R16
    00BB0 9626      ADIW	R28,6
    00BB1 940C 3C6A JMP	pop_xgsetF0FC
ff.c:dir_next:
  c                    --> R10
  clst                 --> Y,+2
  i                    --> R12
  stretch              --> R10
  dj                   --> Y,+16
    00BB3 940E 3B30 CALL	push_arg4
    00BB5 940E 3C75 CALL	push_xgsetF0FC
    00BB7 0159      MOVW	R10,R18
    00BB8 9726      SBIW	R28,6
(1103) }
(1104) 
(1105) 
(1106) 
(1107) 
(1108) /*-----------------------------------------------------------------------*/
(1109) /* Directory handling - Move directory index next                        */
(1110) /*-----------------------------------------------------------------------*/
(1111) 
(1112) static
(1113) FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
(1114) 	DIR *dj,		/* Pointer to directory object */
(1115) 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
(1116) )
(1117) {
(1118) 	DWORD clst;
(1119) 	WORD i;
(1120) 
(1121) 
(1122) 	stretch = stretch;		/* To suppress warning on read-only cfg. */
(1123) 	i = dj->index + 1;
    00BB9 89E8      LDD	R30,Y+16
    00BBA 89F9      LDD	R31,Y+17
    00BBB 8184      LDD	R24,Z+4
    00BBC 8195      LDD	R25,Z+5
    00BBD 9601      ADIW	R24,1
    00BBE 016C      MOVW	R12,R24
(1124) 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    00BBF 3080      CPI	R24,0
    00BC0 0789      CPC	R24,R25
    00BC1 F059      BEQ	0x0BCD
    00BC2 963E      ADIW	R30,0xE
    00BC3 8020      LD	R2,Z
    00BC4 8031      LDD	R3,Z+1
    00BC5 8042      LDD	R4,Z+2
    00BC6 8053      LDD	R5,Z+3
    00BC7 9488      BCLR	0
    00BC8 2022      TST	R2
    00BC9 0432      CPC	R3,R2
    00BCA 0442      CPC	R4,R2
    00BCB 0452      CPC	R5,R2
    00BCC F411      BNE	0x0BCF
(1125) 		return FR_NO_FILE;
    00BCD E004      LDI	R16,4
    00BCE C18D      RJMP	0x0D5C
(1126) 
(1127) 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    00BCF 01C6      MOVW	R24,R12
    00BD0 708F      ANDI	R24,0xF
    00BD1 7090      ANDI	R25,0
    00BD2 3080      CPI	R24,0
    00BD3 0789      CPC	R24,R25
    00BD4 F009      BEQ	0x0BD6
    00BD5 C170      RJMP	0x0D46
(1128) 		dj->sect++;					/* Next sector */
    00BD6 8988      LDD	R24,Y+16
    00BD7 8999      LDD	R25,Y+17
    00BD8 960E      ADIW	R24,0xE
    00BD9 E041      LDI	R20,1
    00BDA E050      LDI	R21,0
    00BDB E060      LDI	R22,0
    00BDC E070      LDI	R23,0
    00BDD 01FC      MOVW	R30,R24
    00BDE 8020      LD	R2,Z
    00BDF 8031      LDD	R3,Z+1
    00BE0 8042      LDD	R4,Z+2
    00BE1 8053      LDD	R5,Z+3
    00BE2 0E24      ADD	R2,R20
    00BE3 1E35      ADC	R3,R21
    00BE4 1E46      ADC	R4,R22
    00BE5 1E57      ADC	R5,R23
    00BE6 8220      ST	Z,R2
    00BE7 8231      STD	Z+1,R3
    00BE8 8242      STD	Z+2,R4
    00BE9 8253      STD	Z+3,R5
(1129) 
(1130) 		if (dj->clust == 0) {	/* Static table */
    00BEA 89E8      LDD	R30,Y+16
    00BEB 89F9      LDD	R31,Y+17
    00BEC 963A      ADIW	R30,0xA
    00BED 8020      LD	R2,Z
    00BEE 8031      LDD	R3,Z+1
    00BEF 8042      LDD	R4,Z+2
    00BF0 8053      LDD	R5,Z+3
    00BF1 9488      BCLR	0
    00BF2 2022      TST	R2
    00BF3 0432      CPC	R3,R2
    00BF4 0442      CPC	R4,R2
    00BF5 0452      CPC	R5,R2
    00BF6 F469      BNE	0x0C04
(1131) 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    00BF7 89E8      LDD	R30,Y+16
    00BF8 89F9      LDD	R31,Y+17
    00BF9 81A0      LD	R26,Z
    00BFA 81B1      LDD	R27,Z+1
    00BFB 9618      ADIW	R26,0x8
    00BFC 902D      LD	R2,X+
    00BFD 903C      LD	R3,X
    00BFE 14C2      CP	R12,R2
    00BFF 04D3      CPC	R13,R3
    00C00 F408      BCC	0x0C02
    00C01 C144      RJMP	0x0D46
(1132) 				return FR_NO_FILE;
    00C02 E004      LDI	R16,4
    00C03 C158      RJMP	0x0D5C
(1133) 		}
(1134) 		else {					/* Dynamic table */
(1135) 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    00C04 89E8      LDD	R30,Y+16
    00C05 89F9      LDD	R31,Y+17
    00C06 93AF      PUSH	R26
    00C07 93BF      PUSH	R27
    00C08 81A0      LD	R26,Z
    00C09 81B1      LDD	R27,Z+1
    00C0A 01FD      MOVW	R30,R26
    00C0B 91BF      POP	R27
    00C0C 91AF      POP	R26
    00C0D 8182      LDD	R24,Z+2
    00C0E 2799      CLR	R25
    00C0F 9701      SBIW	R24,1
    00C10 0116      MOVW	R2,R12
    00C11 9436      LSR	R3
    00C12 9427      ROR	R2
    00C13 9436      LSR	R3
    00C14 9427      ROR	R2
    00C15 9436      LSR	R3
    00C16 9427      ROR	R2
    00C17 9436      LSR	R3
    00C18 9427      ROR	R2
    00C19 2228      AND	R2,R24
    00C1A 2239      AND	R3,R25
    00C1B 2022      TST	R2
    00C1C F009      BEQ	0x0C1E
    00C1D C128      RJMP	0x0D46
    00C1E 2033      TST	R3
    00C1F F009      BEQ	0x0C21
    00C20 C125      RJMP	0x0D46
(1136) 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    00C21 89E8      LDD	R30,Y+16
    00C22 89F9      LDD	R31,Y+17
    00C23 8422      LDD	R2,Z+10
    00C24 8433      LDD	R3,Z+11
    00C25 8444      LDD	R4,Z+12
    00C26 8455      LDD	R5,Z+13
    00C27 8248      ST	Y,R4
    00C28 8259      STD	Y+1,R5
    00C29 0191      MOVW	R18,R2
    00C2A 8100      LD	R16,Z
    00C2B 8111      LDD	R17,Z+1
    00C2C D8C9      RCALL	_get_fat
    00C2D 830A      STD	Y+2,R16
    00C2E 831B      STD	Y+3,R17
    00C2F 832C      STD	Y+4,R18
    00C30 833D      STD	Y+5,R19
(1137) 				if (clst <= 1) return FR_INT_ERR;
    00C31 E041      LDI	R20,1
    00C32 E050      LDI	R21,0
    00C33 E060      LDI	R22,0
    00C34 E070      LDI	R23,0
    00C35 802A      LDD	R2,Y+2
    00C36 803B      LDD	R3,Y+3
    00C37 804C      LDD	R4,Y+4
    00C38 805D      LDD	R5,Y+5
    00C39 1542      CP	R20,R2
    00C3A 0553      CPC	R21,R3
    00C3B 0564      CPC	R22,R4
    00C3C 0575      CPC	R23,R5
    00C3D F010      BCS	0x0C40
    00C3E E002      LDI	R16,2
    00C3F C11C      RJMP	0x0D5C
(1138) 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C40 EF4F      LDI	R20,0xFF
    00C41 EF5F      LDI	R21,0xFF
    00C42 EF6F      LDI	R22,0xFF
    00C43 EF7F      LDI	R23,0xFF
    00C44 802A      LDD	R2,Y+2
    00C45 803B      LDD	R3,Y+3
    00C46 804C      LDD	R4,Y+4
    00C47 805D      LDD	R5,Y+5
    00C48 1624      CP	R2,R20
    00C49 0635      CPC	R3,R21
    00C4A 0646      CPC	R4,R22
    00C4B 0657      CPC	R5,R23
    00C4C F411      BNE	0x0C4F
    00C4D E001      LDI	R16,1
    00C4E C10D      RJMP	0x0D5C
(1139) 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    00C4F 89E8      LDD	R30,Y+16
    00C50 89F9      LDD	R31,Y+17
    00C51 81A0      LD	R26,Z
    00C52 81B1      LDD	R27,Z+1
    00C53 9656      ADIW	R26,0x16
    00C54 902D      LD	R2,X+
    00C55 903D      LD	R3,X+
    00C56 904D      LD	R4,X+
    00C57 905C      LD	R5,X
    00C58 806A      LDD	R6,Y+2
    00C59 807B      LDD	R7,Y+3
    00C5A 808C      LDD	R8,Y+4
    00C5B 809D      LDD	R9,Y+5
    00C5C 1462      CP	R6,R2
    00C5D 0473      CPC	R7,R3
    00C5E 0484      CPC	R8,R4
    00C5F 0495      CPC	R9,R5
    00C60 F408      BCC	0x0C62
    00C61 C0CD      RJMP	0x0D2F
(1140) #if !_FS_READONLY
(1141) 					BYTE c;
(1142) 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    00C62 20AA      TST	R10
    00C63 F421      BNE	0x0C68
    00C64 20BB      TST	R11
    00C65 F411      BNE	0x0C68
    00C66 E004      LDI	R16,4
    00C67 C0F4      RJMP	0x0D5C
(1143) 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    00C68 89E8      LDD	R30,Y+16
    00C69 89F9      LDD	R31,Y+17
    00C6A 8422      LDD	R2,Z+10
    00C6B 8433      LDD	R3,Z+11
    00C6C 8444      LDD	R4,Z+12
    00C6D 8455      LDD	R5,Z+13
    00C6E 8248      ST	Y,R4
    00C6F 8259      STD	Y+1,R5
    00C70 0191      MOVW	R18,R2
    00C71 8100      LD	R16,Z
    00C72 8111      LDD	R17,Z+1
    00C73 DC44      RCALL	ff.c:create_chain
    00C74 830A      STD	Y+2,R16
    00C75 831B      STD	Y+3,R17
    00C76 832C      STD	Y+4,R18
    00C77 833D      STD	Y+5,R19
(1144) 					if (clst == 0) return FR_DENIED;			/* No free cluster */
    00C78 802A      LDD	R2,Y+2
    00C79 803B      LDD	R3,Y+3
    00C7A 804C      LDD	R4,Y+4
    00C7B 805D      LDD	R5,Y+5
    00C7C 9488      BCLR	0
    00C7D 2022      TST	R2
    00C7E 0432      CPC	R3,R2
    00C7F 0442      CPC	R4,R2
    00C80 0452      CPC	R5,R2
    00C81 F411      BNE	0x0C84
    00C82 E007      LDI	R16,7
    00C83 C0D8      RJMP	0x0D5C
(1145) 					if (clst == 1) return FR_INT_ERR;
    00C84 E041      LDI	R20,1
    00C85 E050      LDI	R21,0
    00C86 E060      LDI	R22,0
    00C87 E070      LDI	R23,0
    00C88 802A      LDD	R2,Y+2
    00C89 803B      LDD	R3,Y+3
    00C8A 804C      LDD	R4,Y+4
    00C8B 805D      LDD	R5,Y+5
    00C8C 1624      CP	R2,R20
    00C8D 0635      CPC	R3,R21
    00C8E 0646      CPC	R4,R22
    00C8F 0657      CPC	R5,R23
    00C90 F411      BNE	0x0C93
    00C91 E002      LDI	R16,2
    00C92 C0C9      RJMP	0x0D5C
(1146) 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C93 EF4F      LDI	R20,0xFF
    00C94 EF5F      LDI	R21,0xFF
    00C95 EF6F      LDI	R22,0xFF
    00C96 EF7F      LDI	R23,0xFF
    00C97 802A      LDD	R2,Y+2
    00C98 803B      LDD	R3,Y+3
    00C99 804C      LDD	R4,Y+4
    00C9A 805D      LDD	R5,Y+5
    00C9B 1624      CP	R2,R20
    00C9C 0635      CPC	R3,R21
    00C9D 0646      CPC	R4,R22
    00C9E 0657      CPC	R5,R23
    00C9F F411      BNE	0x0CA2
    00CA0 E001      LDI	R16,1
    00CA1 C0BA      RJMP	0x0D5C
(1147) 					/* Clean-up stretched table */
(1148) 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    00CA2 E040      LDI	R20,0
    00CA3 E050      LDI	R21,0
    00CA4 E060      LDI	R22,0
    00CA5 E070      LDI	R23,0
    00CA6 8368      ST	Y,R22
    00CA7 8379      STD	Y+1,R23
    00CA8 019A      MOVW	R18,R20
    00CA9 89E8      LDD	R30,Y+16
    00CAA 89F9      LDD	R31,Y+17
    00CAB 8100      LD	R16,Z
    00CAC 8111      LDD	R17,Z+1
    00CAD 940E 032D CALL	ff.c:move_window
    00CAF 2300      TST	R16
    00CB0 F011      BEQ	0x0CB3
    00CB1 E001      LDI	R16,1
    00CB2 C0A9      RJMP	0x0D5C
(1149) 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    00CB3 E080      LDI	R24,0
    00CB4 E092      LDI	R25,2
    00CB5 8399      STD	Y+1,R25
    00CB6 8388      ST	Y,R24
    00CB7 2722      CLR	R18
    00CB8 2733      CLR	R19
    00CB9 89E8      LDD	R30,Y+16
    00CBA 89F9      LDD	R31,Y+17
    00CBB 8100      LD	R16,Z
    00CBC 8111      LDD	R17,Z+1
    00CBD 5D02      SUBI	R16,0xD2
    00CBE 4F1F      SBCI	R17,0xFF
    00CBF 940E 02EA CALL	ff.c:mem_set
(1150) 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    00CC1 802A      LDD	R2,Y+2
    00CC2 803B      LDD	R3,Y+3
    00CC3 804C      LDD	R4,Y+4
    00CC4 805D      LDD	R5,Y+5
    00CC5 8248      ST	Y,R4
    00CC6 8259      STD	Y+1,R5
    00CC7 0191      MOVW	R18,R2
    00CC8 89E8      LDD	R30,Y+16
    00CC9 89F9      LDD	R31,Y+17
    00CCA 80A0      LD	R10,Z
    00CCB 80B1      LDD	R11,Z+1
    00CCC 0185      MOVW	R16,R10
    00CCD 940E 04A4 CALL	_clust2sect
    00CCF 01F5      MOVW	R30,R10
    00CD0 A702      STD	Z+42,R16
    00CD1 A713      STD	Z+43,R17
    00CD2 A724      STD	Z+44,R18
    00CD3 A735      STD	Z+45,R19
(1151) 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    00CD4 24AA      CLR	R10
    00CD5 C035      RJMP	0x0D0B
(1152) 						dj->fs->wflag = 1;
    00CD6 E081      LDI	R24,1
    00CD7 89E8      LDD	R30,Y+16
    00CD8 89F9      LDD	R31,Y+17
    00CD9 93AF      PUSH	R26
    00CDA 93BF      PUSH	R27
    00CDB 81A0      LD	R26,Z
    00CDC 81B1      LDD	R27,Z+1
    00CDD 01FD      MOVW	R30,R26
    00CDE 91BF      POP	R27
    00CDF 91AF      POP	R26
    00CE0 8384      STD	Z+4,R24
(1153) 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    00CE1 E040      LDI	R20,0
    00CE2 E050      LDI	R21,0
    00CE3 E060      LDI	R22,0
    00CE4 E070      LDI	R23,0
    00CE5 8368      ST	Y,R22
    00CE6 8379      STD	Y+1,R23
    00CE7 019A      MOVW	R18,R20
    00CE8 89E8      LDD	R30,Y+16
    00CE9 89F9      LDD	R31,Y+17
    00CEA 8100      LD	R16,Z
    00CEB 8111      LDD	R17,Z+1
    00CEC 940E 032D CALL	ff.c:move_window
    00CEE 2EE0      MOV	R14,R16
    00CEF 2300      TST	R16
    00CF0 F011      BEQ	0x0CF3
    00CF1 E001      LDI	R16,1
    00CF2 C069      RJMP	0x0D5C
(1154) 						dj->fs->winsect++;
    00CF3 89E8      LDD	R30,Y+16
    00CF4 89F9      LDD	R31,Y+17
    00CF5 8180      LD	R24,Z
    00CF6 8191      LDD	R25,Z+1
    00CF7 968A      ADIW	R24,0x2A
    00CF8 017C      MOVW	R14,R24
    00CF9 E041      LDI	R20,1
    00CFA E050      LDI	R21,0
    00CFB E060      LDI	R22,0
    00CFC E070      LDI	R23,0
    00CFD 01FC      MOVW	R30,R24
    00CFE 8020      LD	R2,Z
    00CFF 8031      LDD	R3,Z+1
    00D00 8042      LDD	R4,Z+2
    00D01 8053      LDD	R5,Z+3
    00D02 0E24      ADD	R2,R20
    00D03 1E35      ADC	R3,R21
    00D04 1E46      ADC	R4,R22
    00D05 1E57      ADC	R5,R23
    00D06 8220      ST	Z,R2
    00D07 8231      STD	Z+1,R3
    00D08 8242      STD	Z+2,R4
    00D09 8253      STD	Z+3,R5
    00D0A 94A3      INC	R10
    00D0B 89E8      LDD	R30,Y+16
    00D0C 89F9      LDD	R31,Y+17
    00D0D 93AF      PUSH	R26
    00D0E 93BF      PUSH	R27
    00D0F 81A0      LD	R26,Z
    00D10 81B1      LDD	R27,Z+1
    00D11 01FD      MOVW	R30,R26
    00D12 91BF      POP	R27
    00D13 91AF      POP	R26
    00D14 8022      LDD	R2,Z+2
    00D15 14A2      CP	R10,R2
    00D16 F408      BCC	0x0D18
    00D17 CFBE      RJMP	0x0CD6
(1155) 					}
(1156) 					dj->fs->winsect -= c;						/* Rewind window address */
    00D18 89E8      LDD	R30,Y+16
    00D19 89F9      LDD	R31,Y+17
    00D1A 8180      LD	R24,Z
    00D1B 8191      LDD	R25,Z+1
    00D1C 968A      ADIW	R24,0x2A
    00D1D 017C      MOVW	R14,R24
    00D1E 2C2A      MOV	R2,R10
    00D1F 2433      CLR	R3
    00D20 2444      CLR	R4
    00D21 2455      CLR	R5
    00D22 01FC      MOVW	R30,R24
    00D23 8060      LD	R6,Z
    00D24 8071      LDD	R7,Z+1
    00D25 8082      LDD	R8,Z+2
    00D26 8093      LDD	R9,Z+3
    00D27 1862      SUB	R6,R2
    00D28 0873      SBC	R7,R3
    00D29 0884      SBC	R8,R4
    00D2A 0895      SBC	R9,R5
    00D2B 8260      ST	Z,R6
    00D2C 8271      STD	Z+1,R7
    00D2D 8282      STD	Z+2,R8
    00D2E 8293      STD	Z+3,R9
(1157) #else
(1158) 					return FR_NO_FILE;			/* Report EOT */
(1159) #endif
(1160) 				}
(1161) 				dj->clust = clst;				/* Initialize data for new cluster */
    00D2F 802A      LDD	R2,Y+2
    00D30 803B      LDD	R3,Y+3
    00D31 804C      LDD	R4,Y+4
    00D32 805D      LDD	R5,Y+5
    00D33 89E8      LDD	R30,Y+16
    00D34 89F9      LDD	R31,Y+17
    00D35 8622      STD	Z+10,R2
    00D36 8633      STD	Z+11,R3
    00D37 8644      STD	Z+12,R4
    00D38 8655      STD	Z+13,R5
(1162) 				dj->sect = clust2sect(dj->fs, clst);
    00D39 8248      ST	Y,R4
    00D3A 8259      STD	Y+1,R5
    00D3B 0191      MOVW	R18,R2
    00D3C 8100      LD	R16,Z
    00D3D 8111      LDD	R17,Z+1
    00D3E 940E 04A4 CALL	_clust2sect
    00D40 89E8      LDD	R30,Y+16
    00D41 89F9      LDD	R31,Y+17
    00D42 8706      STD	Z+14,R16
    00D43 8717      STD	Z+15,R17
    00D44 8B20      STD	Z+16,R18
    00D45 8B31      STD	Z+17,R19
(1163) 			}
(1164) 		}
(1165) 	}
(1166) 
(1167) 	dj->index = i;
    00D46 89E8      LDD	R30,Y+16
    00D47 89F9      LDD	R31,Y+17
    00D48 82D5      STD	Z+5,R13
    00D49 82C4      STD	Z+4,R12
(1168) 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    00D4A 0196      MOVW	R18,R12
    00D4B 702F      ANDI	R18,0xF
    00D4C 7030      ANDI	R19,0
    00D4D E200      LDI	R16,0x20
    00D4E E010      LDI	R17,0
    00D4F 940E 3C11 CALL	empy16s
    00D51 0118      MOVW	R2,R16
    00D52 89E8      LDD	R30,Y+16
    00D53 89F9      LDD	R31,Y+17
    00D54 8180      LD	R24,Z
    00D55 8191      LDD	R25,Z+1
    00D56 968E      ADIW	R24,0x2E
    00D57 0E28      ADD	R2,R24
    00D58 1E39      ADC	R3,R25
    00D59 8A33      STD	Z+19,R3
    00D5A 8A22      STD	Z+18,R2
(1169) 
(1170) 	return FR_OK;
    00D5B 2700      CLR	R16
    00D5C 9626      ADIW	R28,6
    00D5D 940E 3C6A CALL	pop_xgsetF0FC
    00D5F 9624      ADIW	R28,4
    00D60 9508      RET
ff.c:dir_find:
  c                    --> R12
  dir                  --> R10
  res                  --> R20
  dj                   --> R22
    00D61 940E 3CB0 CALL	push_xgsetF03C
    00D63 01B8      MOVW	R22,R16
    00D64 9722      SBIW	R28,2
(1171) }
(1172) 
(1173) 
(1174) 
(1175) 
(1176) /*-----------------------------------------------------------------------*/
(1177) /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
(1178) /*-----------------------------------------------------------------------*/
(1179) #if _USE_LFN
(1180) static
(1181) const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
(1182) 
(1183) 
(1184) static
(1185) int cmp_lfn (			/* 1:Matched, 0:Not matched */
(1186) 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
(1187) 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
(1188) )
(1189) {
(1190) 	UINT i, s;
(1191) 	WCHAR wc, uc;
(1192) 
(1193) 
(1194) 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
(1195) 	s = 0; wc = 1;
(1196) 	do {
(1197) 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
(1198) 		if (wc) {	/* Last char has not been processed */
(1199) 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
(1200) 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
(1201) 				return 0;				/* Not matched */
(1202) 		} else {
(1203) 			if (uc != 0xFFFF) return 0;	/* Check filler */
(1204) 		}
(1205) 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
(1206) 
(1207) 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
(1208) 		return 0;
(1209) 
(1210) 	return 1;						/* The part of LFN matched */
(1211) }
(1212) 
(1213) 
(1214) 
(1215) static
(1216) int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
(1217) 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
(1218) 	BYTE *dir			/* Pointer to the directory entry */
(1219) )
(1220) {
(1221) 	UINT i, s;
(1222) 	WCHAR wc, uc;
(1223) 
(1224) 
(1225) 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
(1226) 
(1227) 	s = 0; wc = 1;
(1228) 	do {
(1229) 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
(1230) 		if (wc) {	/* Last char has not been processed */
(1231) 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
(1232) 			lfnbuf[i++] = wc = uc;			/* Store it */
(1233) 		} else {
(1234) 			if (uc != 0xFFFF) return 0;		/* Check filler */
(1235) 		}
(1236) 	} while (++s < 13);						/* Read all character in the entry */
(1237) 
(1238) 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
(1239) 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
(1240) 		lfnbuf[i] = 0;
(1241) 	}
(1242) 
(1243) 	return 1;
(1244) }
(1245) 
(1246) 
(1247) #if !_FS_READONLY
(1248) static
(1249) void fit_lfn (
(1250) 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
(1251) 	BYTE *dir,				/* Pointer to the directory entry */
(1252) 	BYTE ord,				/* LFN order (1-20) */
(1253) 	BYTE sum				/* SFN sum */
(1254) )
(1255) {
(1256) 	UINT i, s;
(1257) 	WCHAR wc;
(1258) 
(1259) 
(1260) 	dir[LDIR_Chksum] = sum;			/* Set check sum */
(1261) 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
(1262) 	dir[LDIR_Type] = 0;
(1263) 	ST_WORD(dir+LDIR_FstClusLO, 0);
(1264) 
(1265) 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
(1266) 	s = wc = 0;
(1267) 	do {
(1268) 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
(1269) 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
(1270) 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
(1271) 	} while (++s < 13);
(1272) 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
(1273) 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
(1274) }
(1275) 
(1276) #endif
(1277) #endif
(1278) 
(1279) 
(1280) 
(1281) /*-----------------------------------------------------------------------*/
(1282) /* Create numbered name                                                  */
(1283) /*-----------------------------------------------------------------------*/
(1284) #if _USE_LFN
(1285) void gen_numname (
(1286) 	BYTE *dst,			/* Pointer to generated SFN */
(1287) 	const BYTE *src,	/* Pointer to source SFN to be modified */
(1288) 	const WCHAR *lfn,	/* Pointer to LFN */
(1289) 	WORD seq			/* Sequence number */
(1290) )
(1291) {
(1292) 	BYTE ns[8], c;
(1293) 	UINT i, j;
(1294) 
(1295) 
(1296) 	mem_cpy(dst, src, 11);
(1297) 
(1298) 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
(1299) 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
(1300) 	}
(1301) 
(1302) 	/* itoa (hexdecimal) */
(1303) 	i = 7;
(1304) 	do {
(1305) 		c = (seq % 16) + '0';
(1306) 		if (c > '9') c += 7;
(1307) 		ns[i--] = c;
(1308) 		seq /= 16;
(1309) 	} while (seq);
(1310) 	ns[i] = '~';
(1311) 
(1312) 	/* Append the number */
(1313) 	for (j = 0; j < i && dst[j] != ' '; j++) {
(1314) 		if (IsDBCS1(dst[j])) {
(1315) 			if (j == i - 1) break;
(1316) 			j++;
(1317) 		}
(1318) 	}
(1319) 	do {
(1320) 		dst[j++] = (i < 8) ? ns[i++] : ' ';
(1321) 	} while (j < 8);
(1322) }
(1323) #endif
(1324) 
(1325) 
(1326) 
(1327) 
(1328) /*-----------------------------------------------------------------------*/
(1329) /* Calculate sum of an SFN                                               */
(1330) /*-----------------------------------------------------------------------*/
(1331) #if _USE_LFN
(1332) static
(1333) BYTE sum_sfn (
(1334) 	const BYTE *dir		/* Ptr to directory entry */
(1335) )
(1336) {
(1337) 	BYTE sum = 0;
(1338) 	UINT n = 11;
(1339) 
(1340) 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
(1341) 	return sum;
(1342) }
(1343) #endif
(1344) 
(1345) 
(1346) 
(1347) 
(1348) /*-----------------------------------------------------------------------*/
(1349) /* Directory handling - Find an object in the directory                  */
(1350) /*-----------------------------------------------------------------------*/
(1351) 
(1352) static
(1353) FRESULT dir_find (
(1354) 	DIR *dj			/* Pointer to the directory object linked to the file name */
(1355) )
(1356) {
(1357) 	FRESULT res;
(1358) 	BYTE c, *dir;
(1359) #if _USE_LFN
(1360) 	BYTE a, ord, sum;
(1361) #endif
(1362) 
(1363) 	res = dir_sdi(dj, 0);			/* Rewind directory object */
    00D65 2722      CLR	R18
    00D66 2733      CLR	R19
    00D67 018B      MOVW	R16,R22
    00D68 DD40      RCALL	ff.c:dir_sdi
    00D69 2F40      MOV	R20,R16
(1364) 	if (res != FR_OK) return res;
    00D6A 2300      TST	R16
    00D6B F009      BEQ	0x0D6D
    00D6C C036      RJMP	0x0DA3
(1365) 
(1366) #if _USE_LFN
(1367) 	ord = sum = 0xFF;
(1368) #endif
(1369) 	do {
(1370) 		res = move_window(dj->fs, dj->sect);
    00D6D 01FB      MOVW	R30,R22
    00D6E 8426      LDD	R2,Z+14
    00D6F 8437      LDD	R3,Z+15
    00D70 8840      LDD	R4,Z+16
    00D71 8851      LDD	R5,Z+17
    00D72 8248      ST	Y,R4
    00D73 8259      STD	Y+1,R5
    00D74 0191      MOVW	R18,R2
    00D75 8100      LD	R16,Z
    00D76 8111      LDD	R17,Z+1
    00D77 940E 032D CALL	ff.c:move_window
    00D79 2F40      MOV	R20,R16
(1371) 		if (res != FR_OK) break;
    00D7A 2300      TST	R16
    00D7B F009      BEQ	0x0D7D
    00D7C C025      RJMP	0x0DA2
(1372) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00D7D 01FB      MOVW	R30,R22
    00D7E 88A2      LDD	R10,Z+18
    00D7F 88B3      LDD	R11,Z+19
(1373) 		c = dir[DIR_Name];
    00D80 01F5      MOVW	R30,R10
    00D81 80C0      LD	R12,Z
(1374) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00D82 20CC      TST	R12
    00D83 F411      BNE	0x0D86
    00D84 E044      LDI	R20,4
    00D85 C01C      RJMP	0x0DA2
(1375) #if _USE_LFN	/* LFN configuration */
(1376) 		a = dir[DIR_Attr] & AM_MASK;
(1377) 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1378) 			ord = 0xFF;
(1379) 		} else {
(1380) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1381) 				if (dj->lfn) {
(1382) 					if (c & LLE) {		/* Is it start of LFN sequence? */
(1383) 						sum = dir[LDIR_Chksum];
(1384) 						c &= ~LLE; ord = c;	/* LFN start order */
(1385) 						dj->lfn_idx = dj->index;
(1386) 					}
(1387) 					/* Check validity of the LFN entry and compare it with given name */
(1388) 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1389) 				}
(1390) 			} else {					/* An SFN entry is found */
(1391) 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
(1392) 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
(1393) 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
(1394) 			}
(1395) 		}
(1396) #else		/* Non LFN configuration */
(1397) 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    00D86 01F5      MOVW	R30,R10
    00D87 8423      LDD	R2,Z+11
    00D88 FC23      SBRC	R2,3
    00D89 C00F      RJMP	0x0D99
    00D8A E08B      LDI	R24,0xB
    00D8B E090      LDI	R25,0
    00D8C 8399      STD	Y+1,R25
    00D8D 8388      ST	Y,R24
    00D8E 01FB      MOVW	R30,R22
    00D8F 8924      LDD	R18,Z+20
    00D90 8935      LDD	R19,Z+21
    00D91 0185      MOVW	R16,R10
    00D92 940E 02FC CALL	ff.c:mem_cmp
    00D94 0158      MOVW	R10,R16
    00D95 3000      CPI	R16,0
    00D96 0701      CPC	R16,R17
    00D97 F409      BNE	0x0D99
(1398) 			break;
    00D98 C009      RJMP	0x0DA2
(1399) #endif
(1400) 		res = dir_next(dj, 0);		/* Next entry */
    00D99 2722      CLR	R18
    00D9A 2733      CLR	R19
    00D9B 018B      MOVW	R16,R22
    00D9C DE16      RCALL	ff.c:dir_next
    00D9D 2EA0      MOV	R10,R16
    00D9E 2D4A      MOV	R20,R10
(1401) 	} while (res == FR_OK);
    00D9F 2344      TST	R20
    00DA0 F409      BNE	0x0DA2
    00DA1 CFCB      RJMP	0x0D6D
(1402) 
(1403) 	return res;
    00DA2 2F04      MOV	R16,R20
    00DA3 9622      ADIW	R28,2
    00DA4 940C 3CB9 JMP	pop_xgsetF03C
ff.c:dir_read:
  dir                  --> R10
  c                    --> R12
  res                  --> R20
  dj                   --> R22
    00DA6 940E 3CB0 CALL	push_xgsetF03C
    00DA8 01B8      MOVW	R22,R16
    00DA9 9722      SBIW	R28,2
(1404) }
(1405) 
(1406) 
(1407) 
(1408) 
(1409) /*-----------------------------------------------------------------------*/
(1410) /* Read an object from the directory                                     */
(1411) /*-----------------------------------------------------------------------*/
(1412) #if _FS_MINIMIZE <= 1
(1413) static
(1414) FRESULT dir_read (
(1415) 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
(1416) )
(1417) {
(1418) 	FRESULT res;
(1419) 	BYTE c, *dir;
(1420) #if _USE_LFN
(1421) 	BYTE a, ord = 0xFF, sum = 0xFF;
(1422) #endif
(1423) 
(1424) 	res = FR_NO_FILE;
    00DAA E044      LDI	R20,4
    00DAB C02B      RJMP	0x0DD7
(1425) 	while (dj->sect) {
(1426) 		res = move_window(dj->fs, dj->sect);
    00DAC 01FB      MOVW	R30,R22
    00DAD 8426      LDD	R2,Z+14
    00DAE 8437      LDD	R3,Z+15
    00DAF 8840      LDD	R4,Z+16
    00DB0 8851      LDD	R5,Z+17
    00DB1 8248      ST	Y,R4
    00DB2 8259      STD	Y+1,R5
    00DB3 0191      MOVW	R18,R2
    00DB4 8100      LD	R16,Z
    00DB5 8111      LDD	R17,Z+1
    00DB6 940E 032D CALL	ff.c:move_window
    00DB8 2F40      MOV	R20,R16
(1427) 		if (res != FR_OK) break;
    00DB9 2300      TST	R16
    00DBA F009      BEQ	0x0DBC
    00DBB C028      RJMP	0x0DE4
(1428) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00DBC 01FB      MOVW	R30,R22
    00DBD 88A2      LDD	R10,Z+18
    00DBE 88B3      LDD	R11,Z+19
(1429) 		c = dir[DIR_Name];
    00DBF 01F5      MOVW	R30,R10
    00DC0 80C0      LD	R12,Z
(1430) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00DC1 20CC      TST	R12
    00DC2 F411      BNE	0x0DC5
    00DC3 E044      LDI	R20,4
    00DC4 C01F      RJMP	0x0DE4
(1431) #if _USE_LFN	/* LFN configuration */
(1432) 		a = dir[DIR_Attr] & AM_MASK;
(1433) 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1434) 			ord = 0xFF;
(1435) 		} else {
(1436) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1437) 				if (c & LLE) {			/* Is it start of LFN sequence? */
(1438) 					sum = dir[LDIR_Chksum];
(1439) 					c &= ~LLE; ord = c;
(1440) 					dj->lfn_idx = dj->index;
(1441) 				}
(1442) 				/* Check LFN validity and capture it */
(1443) 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1444) 			} else {					/* An SFN entry is found */
(1445) 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
(1446) 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
(1447) 				break;
(1448) 			}
(1449) 		}
(1450) #else		/* Non LFN configuration */
(1451) 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    00DC5 2D8C      MOV	R24,R12
    00DC6 3E85      CPI	R24,0xE5
    00DC7 F039      BEQ	0x0DCF
    00DC8 328E      CPI	R24,0x2E
    00DC9 F029      BEQ	0x0DCF
    00DCA 01F5      MOVW	R30,R10
    00DCB 8423      LDD	R2,Z+11
    00DCC FC23      SBRC	R2,3
    00DCD C001      RJMP	0x0DCF
(1452) 			break;
    00DCE C015      RJMP	0x0DE4
(1453) #endif
(1454) 		res = dir_next(dj, 0);				/* Next entry */
    00DCF 2722      CLR	R18
    00DD0 2733      CLR	R19
    00DD1 018B      MOVW	R16,R22
    00DD2 DDE0      RCALL	ff.c:dir_next
    00DD3 2F40      MOV	R20,R16
(1455) 		if (res != FR_OK) break;
    00DD4 2300      TST	R16
    00DD5 F009      BEQ	0x0DD7
    00DD6 C00D      RJMP	0x0DE4
    00DD7 01FB      MOVW	R30,R22
    00DD8 963E      ADIW	R30,0xE
    00DD9 8020      LD	R2,Z
    00DDA 8031      LDD	R3,Z+1
    00DDB 8042      LDD	R4,Z+2
    00DDC 8053      LDD	R5,Z+3
    00DDD 9488      BCLR	0
    00DDE 2022      TST	R2
    00DDF 0432      CPC	R3,R2
    00DE0 0442      CPC	R4,R2
    00DE1 0452      CPC	R5,R2
    00DE2 F009      BEQ	0x0DE4
    00DE3 CFC8      RJMP	0x0DAC
(1456) 	}
(1457) 
(1458) 	if (res != FR_OK) dj->sect = 0;
    00DE4 2344      TST	R20
    00DE5 F039      BEQ	0x0DED
    00DE6 01FB      MOVW	R30,R22
    00DE7 963E      ADIW	R30,0xE
    00DE8 E080      LDI	R24,0
    00DE9 8380      ST	Z,R24
    00DEA 8381      STD	Z+1,R24
    00DEB 8382      STD	Z+2,R24
    00DEC 8383      STD	Z+3,R24
(1459) 
(1460) 	return res;
    00DED 2F04      MOV	R16,R20
    00DEE 9622      ADIW	R28,2
    00DEF 940C 3CB9 JMP	pop_xgsetF03C
ff.c:dir_register:
  dir                  --> R12
  c                    --> R22
  res                  --> R10
  dj                   --> R20
    00DF1 940E 3CB0 CALL	push_xgsetF03C
    00DF3 01A8      MOVW	R20,R16
    00DF4 9722      SBIW	R28,2
(1461) }
(1462) #endif
(1463) 
(1464) 
(1465) 
(1466) /*-----------------------------------------------------------------------*/
(1467) /* Register an object to the directory                                   */
(1468) /*-----------------------------------------------------------------------*/
(1469) #if !_FS_READONLY
(1470) static
(1471) FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
(1472) 	DIR *dj				/* Target directory with object name to be created */
(1473) )
(1474) {
(1475) 	FRESULT res;
(1476) 	BYTE c, *dir;
(1477) #if _USE_LFN	/* LFN configuration */
(1478) 	WORD n, ne, is;
(1479) 	BYTE sn[12], *fn, sum;
(1480) 	WCHAR *lfn;
(1481) 
(1482) 
(1483) 	fn = dj->fn; lfn = dj->lfn;
(1484) 	mem_cpy(sn, fn, 12);
(1485) 
(1486) 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
(1487) 		return FR_INVALID_NAME;
(1488) 
(1489) 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
(1490) 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
(1491) 		for (n = 1; n < 100; n++) {
(1492) 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
(1493) 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
(1494) 			if (res != FR_OK) break;
(1495) 		}
(1496) 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
(1497) 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
(1498) 		fn[NS] = sn[NS]; dj->lfn = lfn;
(1499) 	}
(1500) 
(1501) 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
(1502) 		for (ne = 0; lfn[ne]; ne++) ;
(1503) 		ne = (ne + 25) / 13;
(1504) 	} else {						/* Otherwise reserve only an SFN entry. */
(1505) 		ne = 1;
(1506) 	}
(1507) 
(1508) 	/* Reserve contiguous entries */
(1509) 	res = dir_sdi(dj, 0);
(1510) 	if (res != FR_OK) return res;
(1511) 	n = is = 0;
(1512) 	do {
(1513) 		res = move_window(dj->fs, dj->sect);
(1514) 		if (res != FR_OK) break;
(1515) 		c = *dj->dir;				/* Check the entry status */
(1516) 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
(1517) 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
(1518) 			if (++n == ne) break;	/* A contiguous entry that required count is found */
(1519) 		} else {
(1520) 			n = 0;					/* Not a blank entry. Restart to search */
(1521) 		}
(1522) 		res = dir_next(dj, 1);		/* Next entry with table stretch */
(1523) 	} while (res == FR_OK);
(1524) 
(1525) 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
(1526) 		res = dir_sdi(dj, is);
(1527) 		if (res == FR_OK) {
(1528) 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
(1529) 			ne--;
(1530) 			do {					/* Store LFN entries in bottom first */
(1531) 				res = move_window(dj->fs, dj->sect);
(1532) 				if (res != FR_OK) break;
(1533) 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
(1534) 				dj->fs->wflag = 1;
(1535) 				res = dir_next(dj, 0);	/* Next entry */
(1536) 			} while (res == FR_OK && --ne);
(1537) 		}
(1538) 	}
(1539) 
(1540) #else	/* Non LFN configuration */
(1541) 	res = dir_sdi(dj, 0);
    00DF5 2722      CLR	R18
    00DF6 2733      CLR	R19
    00DF7 018A      MOVW	R16,R20
    00DF8 DCB0      RCALL	ff.c:dir_sdi
    00DF9 2EA0      MOV	R10,R16
(1542) 	if (res == FR_OK) {
    00DFA 2300      TST	R16
    00DFB F509      BNE	0x0E1D
(1543) 		do {	/* Find a blank entry for the SFN */
(1544) 			res = move_window(dj->fs, dj->sect);
    00DFC 01FA      MOVW	R30,R20
    00DFD 8426      LDD	R2,Z+14
    00DFE 8437      LDD	R3,Z+15
    00DFF 8840      LDD	R4,Z+16
    00E00 8851      LDD	R5,Z+17
    00E01 8248      ST	Y,R4
    00E02 8259      STD	Y+1,R5
    00E03 0191      MOVW	R18,R2
    00E04 8100      LD	R16,Z
    00E05 8111      LDD	R17,Z+1
    00E06 940E 032D CALL	ff.c:move_window
    00E08 2EA0      MOV	R10,R16
(1545) 			if (res != FR_OK) break;
    00E09 2300      TST	R16
    00E0A F009      BEQ	0x0E0C
    00E0B C011      RJMP	0x0E1D
(1546) 			c = *dj->dir;
    00E0C 01FA      MOVW	R30,R20
    00E0D 89A2      LDD	R26,Z+18
    00E0E 89B3      LDD	R27,Z+19
    00E0F 916C      LD	R22,X
(1547) 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    00E10 3E65      CPI	R22,0xE5
    00E11 F011      BEQ	0x0E14
    00E12 2366      TST	R22
    00E13 F409      BNE	0x0E15
    00E14 C008      RJMP	0x0E1D
(1548) 			res = dir_next(dj, 1);			/* Next entry with table stretch */
    00E15 E021      LDI	R18,1
    00E16 E030      LDI	R19,0
    00E17 018A      MOVW	R16,R20
    00E18 DD9A      RCALL	ff.c:dir_next
    00E19 2EC0      MOV	R12,R16
    00E1A 2CAC      MOV	R10,R12
(1549) 		} while (res == FR_OK);
    00E1B 20AA      TST	R10
    00E1C F2F9      BEQ	0x0DFC
(1550) 	}
(1551) #endif
(1552) 
(1553) 	if (res == FR_OK) {		/* Initialize the SFN entry */
    00E1D 20AA      TST	R10
    00E1E F009      BEQ	0x0E20
    00E1F C030      RJMP	0x0E50
(1554) 		res = move_window(dj->fs, dj->sect);
    00E20 01FA      MOVW	R30,R20
    00E21 8426      LDD	R2,Z+14
    00E22 8437      LDD	R3,Z+15
    00E23 8840      LDD	R4,Z+16
    00E24 8851      LDD	R5,Z+17
    00E25 8248      ST	Y,R4
    00E26 8259      STD	Y+1,R5
    00E27 0191      MOVW	R18,R2
    00E28 8100      LD	R16,Z
    00E29 8111      LDD	R17,Z+1
    00E2A 940E 032D CALL	ff.c:move_window
    00E2C 2EC0      MOV	R12,R16
    00E2D 2CAC      MOV	R10,R12
(1555) 		if (res == FR_OK) {
    00E2E 2300      TST	R16
    00E2F F501      BNE	0x0E50
(1556) 			dir = dj->dir;
    00E30 01FA      MOVW	R30,R20
    00E31 88C2      LDD	R12,Z+18
    00E32 88D3      LDD	R13,Z+19
(1557) 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    00E33 E280      LDI	R24,0x20
    00E34 E090      LDI	R25,0
    00E35 8399      STD	Y+1,R25
    00E36 8388      ST	Y,R24
    00E37 2722      CLR	R18
    00E38 2733      CLR	R19
    00E39 0186      MOVW	R16,R12
    00E3A 940E 02EA CALL	ff.c:mem_set
(1558) 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    00E3C E08B      LDI	R24,0xB
    00E3D E090      LDI	R25,0
    00E3E 8399      STD	Y+1,R25
    00E3F 8388      ST	Y,R24
    00E40 01FA      MOVW	R30,R20
    00E41 8924      LDD	R18,Z+20
    00E42 8935      LDD	R19,Z+21
    00E43 0186      MOVW	R16,R12
    00E44 940E 02D4 CALL	ff.c:mem_cpy
(1559) #if _USE_LFN
(1560) 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
(1561) #endif
(1562) 			dj->fs->wflag = 1;
    00E46 E081      LDI	R24,1
    00E47 01FA      MOVW	R30,R20
    00E48 93AF      PUSH	R26
    00E49 93BF      PUSH	R27
    00E4A 81A0      LD	R26,Z
    00E4B 81B1      LDD	R27,Z+1
    00E4C 01FD      MOVW	R30,R26
    00E4D 91BF      POP	R27
    00E4E 91AF      POP	R26
    00E4F 8384      STD	Z+4,R24
(1563) 		}
(1564) 	}
(1565) 
(1566) 	return res;
    00E50 2D0A      MOV	R16,R10
    00E51 9622      ADIW	R28,2
    00E52 940C 3CB9 JMP	pop_xgsetF03C
ff.c:create_name:
  si                   --> R22
  b                    --> Y,+8
  sfn                  --> Y,+6
  ni                   --> R12
  d                    --> R10
  i                    --> Y,+4
  p                    --> Y,+2
  c                    --> R20
  path                 --> Y,+19
  dj                   --> R20
    00E54 933A      ST	-Y,R19
    00E55 932A      ST	-Y,R18
    00E56 940E 3C75 CALL	push_xgsetF0FC
    00E58 01A8      MOVW	R20,R16
    00E59 9729      SBIW	R28,0x9
(1567) }
(1568) #endif /* !_FS_READONLY */
(1569) 
(1570) 
(1571) 
(1572) 
(1573) /*-----------------------------------------------------------------------*/
(1574) /* Remove an object from the directory                                   */
(1575) /*-----------------------------------------------------------------------*/
(1576) #if !_FS_READONLY && !_FS_MINIMIZE
(1577) static
(1578) FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
(1579) 	DIR *dj				/* Directory object pointing the entry to be removed */
(1580) )
(1581) {
(1582) 	FRESULT res;
(1583) #if _USE_LFN	/* LFN configuration */
(1584) 	WORD i;
(1585) 
(1586) 	i = dj->index;	/* SFN index */
(1587) 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
(1588) 	if (res == FR_OK) {
(1589) 		do {
(1590) 			res = move_window(dj->fs, dj->sect);
(1591) 			if (res != FR_OK) break;
(1592) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1593) 			dj->fs->wflag = 1;
(1594) 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
(1595) 			res = dir_next(dj, 0);		/* Next entry */
(1596) 		} while (res == FR_OK);
(1597) 		if (res == FR_NO_FILE) res = FR_INT_ERR;
(1598) 	}
(1599) 
(1600) #else			/* Non LFN configuration */
(1601) 	res = dir_sdi(dj, dj->index);
(1602) 	if (res == FR_OK) {
(1603) 		res = move_window(dj->fs, dj->sect);
(1604) 		if (res == FR_OK) {
(1605) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1606) 			dj->fs->wflag = 1;
(1607) 		}
(1608) 	}
(1609) #endif
(1610) 
(1611) 	return res;
(1612) }
(1613) #endif /* !_FS_READONLY */
(1614) 
(1615) 
(1616) 
(1617) 
(1618) /*-----------------------------------------------------------------------*/
(1619) /* Pick a segment and create the object name in directory form           */
(1620) /*-----------------------------------------------------------------------*/
(1621) 
(1622) static
(1623) FRESULT create_name (
(1624) 	DIR *dj,			/* Pointer to the directory object */
(1625) 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
(1626) )
(1627) {
(1628) #ifdef _EXCVT
(1629) 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
(1630) #endif
(1631) 
(1632) #if _USE_LFN	/* LFN configuration */
(1633) 	BYTE b, cf;
(1634) 	WCHAR w, *lfn;
(1635) 	UINT i, ni, si, di;
(1636) 	const TCHAR *p;
(1637) 
(1638) 	/* Create LFN in Unicode */
(1639) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
(1640) 	lfn = dj->lfn;
(1641) 	si = di = 0;
(1642) 	for (;;) {
(1643) 		w = p[si++];					/* Get a character */
(1644) 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
(1645) 		if (di >= _MAX_LFN)				/* Reject too long name */
(1646) 			return FR_INVALID_NAME;
(1647) #if !_LFN_UNICODE
(1648) 		w &= 0xFF;
(1649) 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
(1650) 			b = (BYTE)p[si++];			/* Get 2nd byte */
(1651) 			if (!IsDBCS2(b))
(1652) 				return FR_INVALID_NAME;	/* Reject invalid sequence */
(1653) 			w = (w << 8) + b;			/* Create a DBC */
(1654) 		}
(1655) 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
(1656) 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
(1657) #endif
(1658) 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
(1659) 			return FR_INVALID_NAME;
(1660) 		lfn[di++] = w;					/* Store the Unicode char */
(1661) 	}
(1662) 	*path = &p[si];						/* Return pointer to the next segment */
(1663) 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
(1664) #if _FS_RPATH
(1665) 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
(1666) 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
(1667) 		lfn[di] = 0;
(1668) 		for (i = 0; i < 11; i++)
(1669) 			dj->fn[i] = (i < di) ? '.' : ' ';
(1670) 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
(1671) 		return FR_OK;
(1672) 	}
(1673) #endif
(1674) 	while (di) {						/* Strip trailing spaces and dots */
(1675) 		w = lfn[di-1];
(1676) 		if (w != ' ' && w != '.') break;
(1677) 		di--;
(1678) 	}
(1679) 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
(1680) 
(1681) 	lfn[di] = 0;						/* LFN is created */
(1682) 
(1683) 	/* Create SFN in directory form */
(1684) 	mem_set(dj->fn, ' ', 11);
(1685) 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
(1686) 	if (si) cf |= NS_LOSS | NS_LFN;
(1687) 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
(1688) 
(1689) 	b = i = 0; ni = 8;
(1690) 	for (;;) {
(1691) 		w = lfn[si++];					/* Get an LFN char */
(1692) 		if (!w) break;					/* Break on end of the LFN */
(1693) 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
(1694) 			cf |= NS_LOSS | NS_LFN; continue;
(1695) 		}
(1696) 
(1697) 		if (i >= ni || si == di) {		/* Extension or end of SFN */
(1698) 			if (ni == 11) {				/* Long extension */
(1699) 				cf |= NS_LOSS | NS_LFN; break;
(1700) 			}
(1701) 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
(1702) 			if (si > di) break;			/* No extension */
(1703) 			si = di; i = 8; ni = 11;	/* Enter extension section */
(1704) 			b <<= 2; continue;
(1705) 		}
(1706) 
(1707) 		if (w >= 0x80) {				/* Non ASCII char */
(1708) #ifdef _EXCVT
(1709) 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
(1710) 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
(1711) #else
(1712) 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
(1713) #endif
(1714) 			cf |= NS_LFN;				/* Force create LFN entry */
(1715) 		}
(1716) 
(1717) 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
(1718) 			if (i >= ni - 1) {
(1719) 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
(1720) 			}
(1721) 			dj->fn[i++] = (BYTE)(w >> 8);
(1722) 		} else {						/* Single byte char */
(1723) 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
(1724) 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
(1725) 			} else {
(1726) 				if (IsUpper(w)) {		/* ASCII large capital */
(1727) 					b |= 2;
(1728) 				} else {
(1729) 					if (IsLower(w)) {	/* ASCII small capital */
(1730) 						b |= 1; w -= 0x20;
(1731) 					}
(1732) 				}
(1733) 			}
(1734) 		}
(1735) 		dj->fn[i++] = (BYTE)w;
(1736) 	}
(1737) 
(1738) 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
(1739) 
(1740) 	if (ni == 8) b <<= 2;
(1741) 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
(1742) 		cf |= NS_LFN;
(1743) 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
(1744) 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
(1745) 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
(1746) 	}
(1747) 
(1748) 	dj->fn[NS] = cf;	/* SFN is created */
(1749) 
(1750) 	return FR_OK;
(1751) 
(1752) 
(1753) #else	/* Non-LFN configuration */
(1754) 	BYTE b, c, d, *sfn;
(1755) 	UINT ni, si, i;
(1756) 	const char *p;
(1757) 
(1758) 	/* Create file name in directory form */
(1759) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    00E5A 89EB      LDD	R30,Y+19
    00E5B 89FC      LDD	R31,Y+20
    00E5C 8020      LD	R2,Z
    00E5D 8031      LDD	R3,Z+1
    00E5E 823B      STD	Y+3,R3
    00E5F 822A      STD	Y+2,R2
    00E60 C005      RJMP	0x0E66
    00E61 818A      LDD	R24,Y+2
    00E62 819B      LDD	R25,Y+3
    00E63 9601      ADIW	R24,1
    00E64 839B      STD	Y+3,R25
    00E65 838A      STD	Y+2,R24
    00E66 81EA      LDD	R30,Y+2
    00E67 81FB      LDD	R31,Y+3
    00E68 8020      LD	R2,Z
    00E69 2433      CLR	R3
    00E6A 2D82      MOV	R24,R2
    00E6B 328F      CPI	R24,0x2F
    00E6C F3A1      BEQ	0x0E61
    00E6D 358C      CPI	R24,0x5C
    00E6E F391      BEQ	0x0E61
(1760) 	sfn = dj->fn;
    00E6F 01FA      MOVW	R30,R20
    00E70 8824      LDD	R2,Z+20
    00E71 8835      LDD	R3,Z+21
    00E72 823F      STD	Y+7,R3
    00E73 822E      STD	Y+6,R2
(1761) 	mem_set(sfn, ' ', 11);
    00E74 E08B      LDI	R24,0xB
    00E75 E090      LDI	R25,0
    00E76 8399      STD	Y+1,R25
    00E77 8388      ST	Y,R24
    00E78 E220      LDI	R18,0x20
    00E79 E030      LDI	R19,0
    00E7A 0181      MOVW	R16,R2
    00E7B 940E 02EA CALL	ff.c:mem_set
(1762) 	si = i = b = 0; ni = 8;
    00E7D 2400      CLR	R0
    00E7E 8608      STD	Y+8,R0
    00E7F 2422      CLR	R2
    00E80 2433      CLR	R3
    00E81 823D      STD	Y+5,R3
    00E82 822C      STD	Y+4,R2
    00E83 01B1      MOVW	R22,R2
    00E84 E088      LDI	R24,0x8
    00E85 E090      LDI	R25,0
    00E86 016C      MOVW	R12,R24
(1763) #if _FS_RPATH
(1764) 	if (p[si] == '.') { /* Is this a dot entry? */
(1765) 		for (;;) {
(1766) 			c = (BYTE)p[si++];
(1767) 			if (c != '.' || si >= 3) break;
(1768) 			sfn[i++] = c;
(1769) 		}
(1770) 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
(1771) 		*path = &p[si];									/* Return pointer to the next segment */
(1772) 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
(1773) 		return FR_OK;
(1774) 	}
(1775) #endif
(1776) 	for (;;) {
(1777) 		c = (BYTE)p[si++];
    00E87 01AB      MOVW	R20,R22
    00E88 5F6F      SUBI	R22,0xFF
    00E89 4F7F      SBCI	R23,0xFF
    00E8A 01FA      MOVW	R30,R20
    00E8B 800A      LDD	R0,Y+2
    00E8C 801B      LDD	R1,Y+3
    00E8D 0DE0      ADD	R30,R0
    00E8E 1DF1      ADC	R31,R1
    00E8F 8140      LD	R20,Z
(1778) 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    00E90 E280      LDI	R24,0x20
    00E91 1784      CP	R24,R20
    00E92 F420      BCC	0x0E97
    00E93 324F      CPI	R20,0x2F
    00E94 F011      BEQ	0x0E97
    00E95 354C      CPI	R20,0x5C
    00E96 F409      BNE	0x0E98
    00E97 C087      RJMP	0x0F1F
(1779) 		if (c == '.' || i >= ni) {
    00E98 324E      CPI	R20,0x2E
    00E99 F029      BEQ	0x0E9F
    00E9A 800C      LDD	R0,Y+4
    00E9B 801D      LDD	R1,Y+5
    00E9C 140C      CP	R0,R12
    00E9D 041D      CPC	R1,R13
    00E9E F0A0      BCS	0x0EB3
(1780) 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    00E9F 01C6      MOVW	R24,R12
    00EA0 3088      CPI	R24,0x8
    00EA1 E0E0      LDI	R30,0
    00EA2 079E      CPC	R25,R30
    00EA3 F411      BNE	0x0EA6
    00EA4 324E      CPI	R20,0x2E
    00EA5 F011      BEQ	0x0EA8
    00EA6 E006      LDI	R16,6
    00EA7 C0AF      RJMP	0x0F57
(1781) 			i = 8; ni = 11;
    00EA8 E088      LDI	R24,0x8
    00EA9 E090      LDI	R25,0
    00EAA 839D      STD	Y+5,R25
    00EAB 838C      STD	Y+4,R24
    00EAC E08B      LDI	R24,0xB
    00EAD 016C      MOVW	R12,R24
(1782) 			b <<= 2; continue;
    00EAE 8408      LDD	R0,Y+8
    00EAF 0C00      LSL	R0
    00EB0 0C00      LSL	R0
    00EB1 8608      STD	Y+8,R0
    00EB2 CFD4      RJMP	0x0E87
(1783) 		}
(1784) 		if (c >= 0x80) {				/* Extended char? */
    00EB3 3840      CPI	R20,0x80
    00EB4 F018      BCS	0x0EB8
(1785) 			b |= 3;						/* Eliminate NT flag */
    00EB5 8588      LDD	R24,Y+8
    00EB6 6083      ORI	R24,3
    00EB7 8788      STD	Y+8,R24
(1786) #ifdef _EXCVT
(1787) 			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
(1788) #else
(1789) #if !_DF1S	/* ASCII only cfg */
(1790) 			return FR_INVALID_NAME;
(1791) #endif
(1792) #endif
(1793) 		}
(1794) 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    00EB8 3841      CPI	R20,0x81
    00EB9 F408      BCC	0x0EBB
    00EBA C039      RJMP	0x0EF4
    00EBB EF8E      LDI	R24,0xFE
    00EBC 1784      CP	R24,R20
    00EBD F408      BCC	0x0EBF
    00EBE C035      RJMP	0x0EF4
(1795) 			d = (BYTE)p[si++];			/* Get 2nd byte */
    00EBF 015B      MOVW	R10,R22
    00EC0 5F6F      SUBI	R22,0xFF
    00EC1 4F7F      SBCI	R23,0xFF
    00EC2 01F5      MOVW	R30,R10
    00EC3 800A      LDD	R0,Y+2
    00EC4 801B      LDD	R1,Y+3
    00EC5 0DE0      ADD	R30,R0
    00EC6 1DF1      ADC	R31,R1
    00EC7 80A0      LD	R10,Z
(1796) 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    00EC8 2D8A      MOV	R24,R10
    00EC9 3480      CPI	R24,0x40
    00ECA F018      BCS	0x0ECE
    00ECB E78E      LDI	R24,0x7E
    00ECC 158A      CP	R24,R10
    00ECD F430      BCC	0x0ED4
    00ECE 2D8A      MOV	R24,R10
    00ECF 3880      CPI	R24,0x80
    00ED0 F050      BCS	0x0EDB
    00ED1 EF8E      LDI	R24,0xFE
    00ED2 158A      CP	R24,R10
    00ED3 F038      BCS	0x0EDB
    00ED4 01C6      MOVW	R24,R12
    00ED5 9701      SBIW	R24,1
    00ED6 800C      LDD	R0,Y+4
    00ED7 801D      LDD	R1,Y+5
    00ED8 1608      CP	R0,R24
    00ED9 0619      CPC	R1,R25
    00EDA F010      BCS	0x0EDD
(1797) 				return FR_INVALID_NAME;
    00EDB E006      LDI	R16,6
    00EDC C07A      RJMP	0x0F57
(1798) 			sfn[i++] = c;
    00EDD 80EC      LDD	R14,Y+4
    00EDE 80FD      LDD	R15,Y+5
    00EDF 01C7      MOVW	R24,R14
    00EE0 9601      ADIW	R24,1
    00EE1 839D      STD	Y+5,R25
    00EE2 838C      STD	Y+4,R24
    00EE3 01F7      MOVW	R30,R14
    00EE4 800E      LDD	R0,Y+6
    00EE5 801F      LDD	R1,Y+7
    00EE6 0DE0      ADD	R30,R0
    00EE7 1DF1      ADC	R31,R1
    00EE8 8340      ST	Z,R20
(1799) 			sfn[i++] = d;
    00EE9 017C      MOVW	R14,R24
    00EEA 9601      ADIW	R24,1
    00EEB 839D      STD	Y+5,R25
    00EEC 838C      STD	Y+4,R24
    00EED 01F7      MOVW	R30,R14
    00EEE 800E      LDD	R0,Y+6
    00EEF 801F      LDD	R1,Y+7
    00EF0 0DE0      ADD	R30,R0
    00EF1 1DF1      ADC	R31,R1
    00EF2 82A0      ST	Z,R10
(1800) 		} else {						/* Single byte code */
    00EF3 CF93      RJMP	0x0E87
(1801) 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    00EF4 2F24      MOV	R18,R20
    00EF5 2733      CLR	R19
    00EF6 E000      LDI	R16,0
    00EF7 E011      LDI	R17,1
    00EF8 940E 031D CALL	ff.c:chk_chr
    00EFA 0158      MOVW	R10,R16
    00EFB 3000      CPI	R16,0
    00EFC 0701      CPC	R16,R17
    00EFD F011      BEQ	0x0F00
(1802) 				return FR_INVALID_NAME;
    00EFE E006      LDI	R16,6
    00EFF C057      RJMP	0x0F57
(1803) 			if (IsUpper(c)) {			/* ASCII large capital? */
    00F00 3441      CPI	R20,0x41
    00F01 F038      BCS	0x0F09
    00F02 E58A      LDI	R24,0x5A
    00F03 1784      CP	R24,R20
    00F04 F020      BCS	0x0F09
(1804) 				b |= 2;
    00F05 8588      LDD	R24,Y+8
    00F06 6082      ORI	R24,2
    00F07 8788      STD	Y+8,R24
(1805) 			} else {
    00F08 C009      RJMP	0x0F12
(1806) 				if (IsLower(c)) {		/* ASCII small capital? */
    00F09 3641      CPI	R20,0x61
    00F0A F038      BCS	0x0F12
    00F0B E78A      LDI	R24,0x7A
    00F0C 1784      CP	R24,R20
    00F0D F020      BCS	0x0F12
(1807) 					b |= 1; c -= 0x20;
    00F0E 8588      LDD	R24,Y+8
    00F0F 6081      ORI	R24,1
    00F10 8788      STD	Y+8,R24
    00F11 5240      SUBI	R20,0x20
(1808) 				}
(1809) 			}
(1810) 			sfn[i++] = c;
    00F12 80AC      LDD	R10,Y+4
    00F13 80BD      LDD	R11,Y+5
    00F14 01C5      MOVW	R24,R10
    00F15 9601      ADIW	R24,1
    00F16 839D      STD	Y+5,R25
    00F17 838C      STD	Y+4,R24
    00F18 01F5      MOVW	R30,R10
    00F19 800E      LDD	R0,Y+6
    00F1A 801F      LDD	R1,Y+7
    00F1B 0DE0      ADD	R30,R0
    00F1C 1DF1      ADC	R31,R1
    00F1D 8340      ST	Z,R20
    00F1E CF68      RJMP	0x0E87
(1811) 		}
(1812) 	}
(1813) 	*path = &p[si];						/* Return pointer to the next segment */
    00F1F 011B      MOVW	R2,R22
    00F20 800A      LDD	R0,Y+2
    00F21 801B      LDD	R1,Y+3
    00F22 0C20      ADD	R2,R0
    00F23 1C31      ADC	R3,R1
    00F24 89EB      LDD	R30,Y+19
    00F25 89FC      LDD	R31,Y+20
    00F26 8231      STD	Z+1,R3
    00F27 8220      ST	Z,R2
(1814) 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    00F28 E280      LDI	R24,0x20
    00F29 1784      CP	R24,R20
    00F2A F018      BCS	0x0F2E
    00F2B E064      LDI	R22,4
    00F2C E070      LDI	R23,0
    00F2D C002      RJMP	0x0F30
    00F2E 2766      CLR	R22
    00F2F 2777      CLR	R23
    00F30 2F46      MOV	R20,R22
(1815) 
(1816) 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    00F31 800C      LDD	R0,Y+4
    00F32 801D      LDD	R1,Y+5
    00F33 2000      TST	R0
    00F34 F421      BNE	0x0F39
    00F35 2011      TST	R1
    00F36 F411      BNE	0x0F39
    00F37 E006      LDI	R16,6
    00F38 C01E      RJMP	0x0F57
(1817) 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    00F39 81EE      LDD	R30,Y+6
    00F3A 81FF      LDD	R31,Y+7
    00F3B 8180      LD	R24,Z
    00F3C 3E85      CPI	R24,0xE5
    00F3D F411      BNE	0x0F40
    00F3E E085      LDI	R24,5
    00F3F 8380      ST	Z,R24
(1818) 
(1819) 	if (ni == 8) b <<= 2;
    00F40 01C6      MOVW	R24,R12
    00F41 3088      CPI	R24,0x8
    00F42 E0E0      LDI	R30,0
    00F43 079E      CPC	R25,R30
    00F44 F421      BNE	0x0F49
    00F45 8408      LDD	R0,Y+8
    00F46 0C00      LSL	R0
    00F47 0C00      LSL	R0
    00F48 8608      STD	Y+8,R0
(1820) 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    00F49 8588      LDD	R24,Y+8
    00F4A 7083      ANDI	R24,3
    00F4B 3081      CPI	R24,1
    00F4C F409      BNE	0x0F4E
    00F4D 6140      ORI	R20,0x10
(1821) 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    00F4E 8588      LDD	R24,Y+8
    00F4F 708C      ANDI	R24,0xC
    00F50 3084      CPI	R24,4
    00F51 F409      BNE	0x0F53
    00F52 6048      ORI	R20,0x8
(1822) 
(1823) 	sfn[NS] = c;		/* Store NT flag, File name is created */
    00F53 81EE      LDD	R30,Y+6
    00F54 81FF      LDD	R31,Y+7
    00F55 8743      STD	Z+11,R20
(1824) 
(1825) 	return FR_OK;
    00F56 2700      CLR	R16
    00F57 9629      ADIW	R28,0x9
    00F58 940E 3C6A CALL	pop_xgsetF0FC
    00F5A 9622      ADIW	R28,2
    00F5B 9508      RET
ff.c:get_fileinfo:
  nt                   --> R12
  p                    --> R20
  dir                  --> R10
  i                    --> R12
  c                    --> R14
  fno                  --> R22
  dj                   --> R10
    00F5C 940E 3C75 CALL	push_xgsetF0FC
    00F5E 01B9      MOVW	R22,R18
    00F5F 0158      MOVW	R10,R16
(1826) #endif
(1827) }
(1828) 
(1829) 
(1830) 
(1831) 
(1832) /*-----------------------------------------------------------------------*/
(1833) /* Get file information from directory entry                             */
(1834) /*-----------------------------------------------------------------------*/
(1835) #if _FS_MINIMIZE <= 1
(1836) static
(1837) void get_fileinfo (		/* No return code */
(1838) 	DIR *dj,			/* Pointer to the directory object */
(1839) 	FILINFO *fno	 	/* Pointer to the file information to be filled */
(1840) )
(1841) {
(1842) 	UINT i;
(1843) 	BYTE nt, *dir;
(1844) 	TCHAR *p, c;
(1845) 
(1846) 
(1847) 	p = fno->fname;
    00F60 01AB      MOVW	R20,R22
    00F61 5F47      SUBI	R20,0xF7
    00F62 4F5F      SBCI	R21,0xFF
(1848) 	if (dj->sect) {
    00F63 01F5      MOVW	R30,R10
    00F64 963E      ADIW	R30,0xE
    00F65 8020      LD	R2,Z
    00F66 8031      LDD	R3,Z+1
    00F67 8042      LDD	R4,Z+2
    00F68 8053      LDD	R5,Z+3
    00F69 9488      BCLR	0
    00F6A 2022      TST	R2
    00F6B 0432      CPC	R3,R2
    00F6C 0442      CPC	R4,R2
    00F6D 0452      CPC	R5,R2
    00F6E F409      BNE	0x0F70
    00F6F C08A      RJMP	0x0FFA
(1849) 		dir = dj->dir;
    00F70 01F5      MOVW	R30,R10
    00F71 88A2      LDD	R10,Z+18
    00F72 88B3      LDD	R11,Z+19
(1850) 		nt = dir[DIR_NTres];		/* NT flag */
(1851) 		for (i = 0; i < 8; i++) {	/* Copy name body */
    00F73 24CC      CLR	R12
    00F74 24DD      CLR	R13
    00F75 C014      RJMP	0x0F8A
(1852) 			c = dir[i];
    00F76 01F6      MOVW	R30,R12
    00F77 0DEA      ADD	R30,R10
    00F78 1DFB      ADC	R31,R11
    00F79 80E0      LD	R14,Z
(1853) 			if (c == ' ') break;
    00F7A 2D8E      MOV	R24,R14
    00F7B 3280      CPI	R24,0x20
    00F7C F409      BNE	0x0F7E
    00F7D C011      RJMP	0x0F8F
(1854) 			if (c == NDDE) c = (TCHAR)DDE;
    00F7E 2D8E      MOV	R24,R14
    00F7F 3085      CPI	R24,5
    00F80 F411      BNE	0x0F83
    00F81 EE85      LDI	R24,0xE5
    00F82 2EE8      MOV	R14,R24
(1855) 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
    00F83 C000      RJMP	0x0F84
(1856) #if _LFN_UNICODE
(1857) 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
(1858) 				c = (c << 8) | dir[++i];
(1859) 			c = ff_convert(c, 1);
(1860) 			if (!c) c = '?';
(1861) #endif
(1862) 			*p++ = c;
    00F84 01FA      MOVW	R30,R20
    00F85 92E1      ST	Z+,R14
    00F86 01AF      MOVW	R20,R30
    00F87 01C6      MOVW	R24,R12
    00F88 9601      ADIW	R24,1
    00F89 016C      MOVW	R12,R24
    00F8A 01C6      MOVW	R24,R12
    00F8B 3088      CPI	R24,0x8
    00F8C E0E0      LDI	R30,0
    00F8D 079E      CPC	R25,R30
    00F8E F338      BCS	0x0F76
(1863) 		}
(1864) 		if (dir[8] != ' ') {		/* Copy name extension */
    00F8F 01F5      MOVW	R30,R10
    00F90 8580      LDD	R24,Z+8
    00F91 3280      CPI	R24,0x20
    00F92 F0E1      BEQ	0x0FAF
(1865) 			*p++ = '.';
    00F93 E28E      LDI	R24,0x2E
    00F94 01FA      MOVW	R30,R20
    00F95 9381      ST	Z+,R24
    00F96 01AF      MOVW	R20,R30
(1866) 			for (i = 8; i < 11; i++) {
    00F97 E088      LDI	R24,0x8
    00F98 E090      LDI	R25,0
    00F99 016C      MOVW	R12,R24
    00F9A C00F      RJMP	0x0FAA
(1867) 				c = dir[i];
    00F9B 01F6      MOVW	R30,R12
    00F9C 0DEA      ADD	R30,R10
    00F9D 1DFB      ADC	R31,R11
    00F9E 80E0      LD	R14,Z
(1868) 				if (c == ' ') break;
    00F9F 2D8E      MOV	R24,R14
    00FA0 3280      CPI	R24,0x20
    00FA1 F409      BNE	0x0FA3
    00FA2 C00C      RJMP	0x0FAF
(1869) 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
    00FA3 C000      RJMP	0x0FA4
(1870) #if _LFN_UNICODE
(1871) 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
(1872) 					c = (c << 8) | dir[++i];
(1873) 				c = ff_convert(c, 1);
(1874) 				if (!c) c = '?';
(1875) #endif
(1876) 				*p++ = c;
    00FA4 01FA      MOVW	R30,R20
    00FA5 92E1      ST	Z+,R14
    00FA6 01AF      MOVW	R20,R30
    00FA7 01C6      MOVW	R24,R12
    00FA8 9601      ADIW	R24,1
    00FA9 016C      MOVW	R12,R24
    00FAA 01C6      MOVW	R24,R12
    00FAB 308B      CPI	R24,0xB
    00FAC E0E0      LDI	R30,0
    00FAD 079E      CPC	R25,R30
    00FAE F360      BCS	0x0F9B
(1877) 			}
(1878) 		}
(1879) 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    00FAF 01F5      MOVW	R30,R10
    00FB0 8423      LDD	R2,Z+11
    00FB1 01FB      MOVW	R30,R22
    00FB2 8620      STD	Z+8,R2
(1880) 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    00FB3 E188      LDI	R24,0x18
    00FB4 E090      LDI	R25,0
    00FB5 01F5      MOVW	R30,R10
    00FB6 8D07      LDD	R16,Z+31
    00FB7 2711      CLR	R17
    00FB8 2722      CLR	R18
    00FB9 2733      CLR	R19
    00FBA 938A      ST	-Y,R24
    00FBB 940E 3CF7 CALL	lsl32
    00FBD 0118      MOVW	R2,R16
    00FBE 0129      MOVW	R4,R18
    00FBF 01F5      MOVW	R30,R10
    00FC0 8C66      LDD	R6,Z+30
    00FC1 2477      CLR	R7
    00FC2 2488      CLR	R8
    00FC3 2499      CLR	R9
    00FC4 0143      MOVW	R8,R6
    00FC5 2466      CLR	R6
    00FC6 2477      CLR	R7
    00FC7 2826      OR	R2,R6
    00FC8 2837      OR	R3,R7
    00FC9 2848      OR	R4,R8
    00FCA 2859      OR	R5,R9
    00FCB 8C65      LDD	R6,Z+29
    00FCC 2477      CLR	R7
    00FCD 2C76      MOV	R7,R6
    00FCE 2466      CLR	R6
    00FCF 2488      CLR	R8
    00FD0 2499      CLR	R9
    00FD1 2826      OR	R2,R6
    00FD2 2837      OR	R3,R7
    00FD3 2848      OR	R4,R8
    00FD4 2859      OR	R5,R9
    00FD5 8C64      LDD	R6,Z+28
    00FD6 2477      CLR	R7
    00FD7 2488      CLR	R8
    00FD8 2499      CLR	R9
    00FD9 2826      OR	R2,R6
    00FDA 2837      OR	R3,R7
    00FDB 2848      OR	R4,R8
    00FDC 2859      OR	R5,R9
    00FDD 01FB      MOVW	R30,R22
    00FDE 8220      ST	Z,R2
    00FDF 8231      STD	Z+1,R3
    00FE0 8242      STD	Z+2,R4
    00FE1 8253      STD	Z+3,R5
(1881) 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    00FE2 01F5      MOVW	R30,R10
    00FE3 8C20      LDD	R2,Z+24
    00FE4 2433      CLR	R3
    00FE5 8C41      LDD	R4,Z+25
    00FE6 2455      CLR	R5
    00FE7 2C54      MOV	R5,R4
    00FE8 2444      CLR	R4
    00FE9 2842      OR	R4,R2
    00FEA 2853      OR	R5,R3
    00FEB 01FB      MOVW	R30,R22
    00FEC 8255      STD	Z+5,R5
    00FED 8244      STD	Z+4,R4
(1882) 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    00FEE 01F5      MOVW	R30,R10
    00FEF 8826      LDD	R2,Z+22
    00FF0 2433      CLR	R3
    00FF1 8847      LDD	R4,Z+23
    00FF2 2455      CLR	R5
    00FF3 2C54      MOV	R5,R4
    00FF4 2444      CLR	R4
    00FF5 2842      OR	R4,R2
    00FF6 2853      OR	R5,R3
    00FF7 01FB      MOVW	R30,R22
    00FF8 8257      STD	Z+7,R5
    00FF9 8246      STD	Z+6,R4
(1883) 	}
(1884) 	*p = 0;		/* Terminate SFN str by a \0 */
    00FFA 2422      CLR	R2
    00FFB 01FA      MOVW	R30,R20
    00FFC 8220      ST	Z,R2
    00FFD 940C 3C6A JMP	pop_xgsetF0FC
ff.c:follow_path:
  ns                   --> R10
  res                  --> R20
  dir                  --> R10
  path                 --> Y,+6
  dj                   --> R22
    00FFF 933A      ST	-Y,R19
    01000 932A      ST	-Y,R18
    01001 940E 3C94 CALL	push_xgsetF00C
    01003 01B8      MOVW	R22,R16
(1885) 
(1886) #if _USE_LFN
(1887) 	if (fno->lfname && fno->lfsize) {
(1888) 		TCHAR *tp = fno->lfname;
(1889) 		WCHAR w, *lfn;
(1890) 
(1891) 		i = 0;
(1892) 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
(1893) 			lfn = dj->lfn;
(1894) 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
(1895) #if !_LFN_UNICODE
(1896) 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
(1897) 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
(1898) 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
(1899) 					tp[i++] = (TCHAR)(w >> 8);
(1900) #endif
(1901) 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
(1902) 				tp[i++] = (TCHAR)w;
(1903) 			}
(1904) 		}
(1905) 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
(1906) 	}
(1907) #endif
(1908) }
(1909) #endif /* _FS_MINIMIZE <= 1 */
(1910) 
(1911) 
(1912) 
(1913) 
(1914) /*-----------------------------------------------------------------------*/
(1915) /* Follow a file path                                                    */
(1916) /*-----------------------------------------------------------------------*/
(1917) 
(1918) static
(1919) FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
(1920) 	DIR *dj,			/* Directory object to return last directory and found object */
(1921) 	const TCHAR *path	/* Full-path string to find a file or directory */
(1922) )
(1923) {
(1924) 	FRESULT res;
(1925) 	BYTE *dir, ns;
(1926) 
(1927) 
(1928) #if _FS_RPATH
(1929) 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
(1930) 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
(1931) 	} else {							/* No heading separator */
(1932) 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
(1933) 	}
(1934) #else
(1935) 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    01004 81EE      LDD	R30,Y+6
    01005 81FF      LDD	R31,Y+7
    01006 8020      LD	R2,Z
    01007 2433      CLR	R3
    01008 2D82      MOV	R24,R2
    01009 328F      CPI	R24,0x2F
    0100A F011      BEQ	0x100D
    0100B 358C      CPI	R24,0x5C
    0100C F429      BNE	0x1012
(1936) 		path++;
    0100D 818E      LDD	R24,Y+6
    0100E 819F      LDD	R25,Y+7
    0100F 9601      ADIW	R24,1
    01010 839F      STD	Y+7,R25
    01011 838E      STD	Y+6,R24
(1937) 	dj->sclust = 0;						/* Start from the root dir */
    01012 01FB      MOVW	R30,R22
    01013 9636      ADIW	R30,6
    01014 E080      LDI	R24,0
    01015 8380      ST	Z,R24
    01016 8381      STD	Z+1,R24
    01017 8382      STD	Z+2,R24
    01018 8383      STD	Z+3,R24
(1938) #endif
(1939) 
(1940) 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    01019 81EE      LDD	R30,Y+6
    0101A 81FF      LDD	R31,Y+7
    0101B 8180      LD	R24,Z
    0101C 2799      CLR	R25
    0101D 3280      CPI	R24,0x20
    0101E E0E0      LDI	R30,0
    0101F 079E      CPC	R25,R30
    01020 F458      BCC	0x102C
(1941) 		res = dir_sdi(dj, 0);
    01021 2722      CLR	R18
    01022 2733      CLR	R19
    01023 018B      MOVW	R16,R22
    01024 DA84      RCALL	ff.c:dir_sdi
    01025 2F40      MOV	R20,R16
(1942) 		dj->dir = 0;
    01026 2422      CLR	R2
    01027 2433      CLR	R3
    01028 01FB      MOVW	R30,R22
    01029 8A33      STD	Z+19,R3
    0102A 8A22      STD	Z+18,R2
(1943) 
(1944) 	} else {							/* Follow path */
    0102B C052      RJMP	0x107E
(1945) 		for (;;) {
(1946) 			res = create_name(dj, &path);	/* Get a segment */
    0102C 019E      MOVW	R18,R28
    0102D 5F2A      SUBI	R18,0xFA
    0102E 4F3F      SBCI	R19,0xFF
    0102F 018B      MOVW	R16,R22
    01030 DE23      RCALL	ff.c:create_name
    01031 2EA0      MOV	R10,R16
    01032 2D4A      MOV	R20,R10
(1947) 			if (res != FR_OK) break;
    01033 2300      TST	R16
    01034 F009      BEQ	0x1036
    01035 C048      RJMP	0x107E
(1948) 			res = dir_find(dj);				/* Find it */
    01036 018B      MOVW	R16,R22
    01037 DD29      RCALL	ff.c:dir_find
    01038 2EA0      MOV	R10,R16
    01039 2D4A      MOV	R20,R10
(1949) 			ns = *(dj->fn+NS);
    0103A 01FB      MOVW	R30,R22
    0103B 93AF      PUSH	R26
    0103C 93BF      PUSH	R27
    0103D 89A4      LDD	R26,Z+20
    0103E 89B5      LDD	R27,Z+21
    0103F 01FD      MOVW	R30,R26
    01040 91BF      POP	R27
    01041 91AF      POP	R26
    01042 84A3      LDD	R10,Z+11
(1950) 			if (res != FR_OK) {				/* Failed to find the object */
    01043 2300      TST	R16
    01044 F049      BEQ	0x104E
(1951) 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    01045 3004      CPI	R16,4
    01046 F009      BEQ	0x1048
    01047 C036      RJMP	0x107E
(1952) 				/* Object not found */
(1953) 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    01048 C001      RJMP	0x104A
(1954) 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
(1955) 					res = FR_OK;
(1956) 					if (!(ns & NS_LAST)) continue;
    01049 CFE2      RJMP	0x102C
(1957) 				} else {							/* Could not find the object */
(1958) 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    0104A FCA2      SBRC	R10,2
    0104B C032      RJMP	0x107E
    0104C E045      LDI	R20,5
(1959) 				}
(1960) 				break;
    0104D C030      RJMP	0x107E
(1961) 			}
(1962) 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    0104E FEA2      SBRS	R10,2
    0104F C001      RJMP	0x1051
    01050 C02D      RJMP	0x107E
(1963) 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    01051 01FB      MOVW	R30,R22
    01052 88A2      LDD	R10,Z+18
    01053 88B3      LDD	R11,Z+19
(1964) 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    01054 01F5      MOVW	R30,R10
    01055 8423      LDD	R2,Z+11
    01056 FC24      SBRC	R2,4
    01057 C002      RJMP	0x105A
(1965) 				res = FR_NO_PATH; break;
    01058 E045      LDI	R20,5
    01059 C024      RJMP	0x107E
(1966) 			}
(1967) 			dj->sclust = LD_CLUST(dir);
    0105A 01F5      MOVW	R30,R10
    0105B 8C22      LDD	R2,Z+26
    0105C 2433      CLR	R3
    0105D 8C43      LDD	R4,Z+27
    0105E 2455      CLR	R5
    0105F 2C54      MOV	R5,R4
    01060 2444      CLR	R4
    01061 2842      OR	R4,R2
    01062 2853      OR	R5,R3
    01063 0112      MOVW	R2,R4
    01064 2444      CLR	R4
    01065 2455      CLR	R5
    01066 8864      LDD	R6,Z+20
    01067 2477      CLR	R7
    01068 8885      LDD	R8,Z+21
    01069 2499      CLR	R9
    0106A 2C98      MOV	R9,R8
    0106B 2488      CLR	R8
    0106C 2886      OR	R8,R6
    0106D 2897      OR	R9,R7
    0106E 0134      MOVW	R6,R8
    0106F 2488      CLR	R8
    01070 2499      CLR	R9
    01071 0143      MOVW	R8,R6
    01072 2466      CLR	R6
    01073 2477      CLR	R7
    01074 2862      OR	R6,R2
    01075 2873      OR	R7,R3
    01076 2884      OR	R8,R4
    01077 2895      OR	R9,R5
    01078 01FB      MOVW	R30,R22
    01079 8266      STD	Z+6,R6
    0107A 8277      STD	Z+7,R7
    0107B 8680      STD	Z+8,R8
    0107C 8691      STD	Z+9,R9
    0107D CFAE      RJMP	0x102C
(1968) 		}
(1969) 	}
(1970) 
(1971) 	return res;
    0107E 2F04      MOV	R16,R20
    0107F 940E 3C9B CALL	pop_xgsetF00C
    01081 9622      ADIW	R28,2
    01082 9508      RET
ff.c:check_fs:
  sect                 --> Y,+11
  fs                   --> R10
    01083 933A      ST	-Y,R19
    01084 932A      ST	-Y,R18
    01085 940E 3C94 CALL	push_xgsetF00C
    01087 0158      MOVW	R10,R16
    01088 9725      SBIW	R28,5
(1972) }
(1973) 
(1974) 
(1975) 
(1976) 
(1977) /*-----------------------------------------------------------------------*/
(1978) /* Load a sector and check if it is an FAT Volume Boot Record            */
(1979) /*-----------------------------------------------------------------------*/
(1980) 
(1981) static
(1982) BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
(1983) 	FATFS *fs,	/* File system object */
(1984) 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
(1985) )
(1986) {
(1987) 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    01089 E081      LDI	R24,1
    0108A 838C      STD	Y+4,R24
    0108B 842B      LDD	R2,Y+11
    0108C 843C      LDD	R3,Y+12
    0108D 844D      LDD	R4,Y+13
    0108E 845E      LDD	R5,Y+14
    0108F 8228      ST	Y,R2
    01090 8239      STD	Y+1,R3
    01091 824A      STD	Y+2,R4
    01092 825B      STD	Y+3,R5
    01093 0195      MOVW	R18,R10
    01094 5D22      SUBI	R18,0xD2
    01095 4F3F      SBCI	R19,0xFF
    01096 01F5      MOVW	R30,R10
    01097 8101      LDD	R16,Z+1
    01098 940E 0292 CALL	_disk_read
    0109A 2300      TST	R16
    0109B F011      BEQ	0x109E
(1988) 		return 3;
    0109C E003      LDI	R16,3
    0109D C0A8      RJMP	0x1146
(1989) 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    0109E 01F5      MOVW	R30,R10
    0109F 5DE4      SUBI	R30,0xD4
    010A0 4FFD      SBCI	R31,0xFD
    010A1 8020      LD	R2,Z
    010A2 52EC      SUBI	R30,0x2C
    010A3 40F2      SBCI	R31,2
    010A4 2433      CLR	R3
    010A5 5DE3      SUBI	R30,0xD3
    010A6 4FFD      SBCI	R31,0xFD
    010A7 8180      LD	R24,Z
    010A8 2799      CLR	R25
    010A9 2F98      MOV	R25,R24
    010AA 2788      CLR	R24
    010AB 2982      OR	R24,R2
    010AC 2993      OR	R25,R3
    010AD 3585      CPI	R24,0x55
    010AE EAEA      LDI	R30,0xAA
    010AF 079E      CPC	R25,R30
    010B0 F011      BEQ	0x10B3
(1990) 		return 2;
    010B1 E002      LDI	R16,2
    010B2 C093      RJMP	0x1146
(1991) 
(1992) 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    010B3 E188      LDI	R24,0x18
    010B4 E090      LDI	R25,0
    010B5 01F5      MOVW	R30,R10
    010B6 59E9      SUBI	R30,0x99
    010B7 4FFF      SBCI	R31,0xFF
    010B8 8100      LD	R16,Z
    010B9 2711      CLR	R17
    010BA 2722      CLR	R18
    010BB 2733      CLR	R19
    010BC 938A      ST	-Y,R24
    010BD 940E 3CF7 CALL	lsl32
    010BF 0118      MOVW	R2,R16
    010C0 0129      MOVW	R4,R18
    010C1 01F5      MOVW	R30,R10
    010C2 59EA      SUBI	R30,0x9A
    010C3 4FFF      SBCI	R31,0xFF
    010C4 8060      LD	R6,Z
    010C5 56E6      SUBI	R30,0x66
    010C6 40F0      SBCI	R31,0
    010C7 2477      CLR	R7
    010C8 2488      CLR	R8
    010C9 2499      CLR	R9
    010CA 0143      MOVW	R8,R6
    010CB 2466      CLR	R6
    010CC 2477      CLR	R7
    010CD 2826      OR	R2,R6
    010CE 2837      OR	R3,R7
    010CF 2848      OR	R4,R8
    010D0 2859      OR	R5,R9
    010D1 59EB      SUBI	R30,0x9B
    010D2 4FFF      SBCI	R31,0xFF
    010D3 8060      LD	R6,Z
    010D4 56E5      SUBI	R30,0x65
    010D5 40F0      SBCI	R31,0
    010D6 2477      CLR	R7
    010D7 2C76      MOV	R7,R6
    010D8 2466      CLR	R6
    010D9 2488      CLR	R8
    010DA 2499      CLR	R9
    010DB 2826      OR	R2,R6
    010DC 2837      OR	R3,R7
    010DD 2848      OR	R4,R8
    010DE 2859      OR	R5,R9
    010DF 59EC      SUBI	R30,0x9C
    010E0 4FFF      SBCI	R31,0xFF
    010E1 8060      LD	R6,Z
    010E2 2477      CLR	R7
    010E3 2488      CLR	R8
    010E4 2499      CLR	R9
    010E5 2826      OR	R2,R6
    010E6 2837      OR	R3,R7
    010E7 2848      OR	R4,R8
    010E8 2859      OR	R5,R9
    010E9 EF4F      LDI	R20,0xFF
    010EA EF5F      LDI	R21,0xFF
    010EB EF6F      LDI	R22,0xFF
    010EC E070      LDI	R23,0
    010ED 2224      AND	R2,R20
    010EE 2235      AND	R3,R21
    010EF 2246      AND	R4,R22
    010F0 2257      AND	R5,R23
    010F1 E446      LDI	R20,0x46
    010F2 E451      LDI	R21,0x41
    010F3 E564      LDI	R22,0x54
    010F4 E070      LDI	R23,0
    010F5 1624      CP	R2,R20
    010F6 0635      CPC	R3,R21
    010F7 0646      CPC	R4,R22
    010F8 0657      CPC	R5,R23
    010F9 F411      BNE	0x10FC
(1993) 		return 0;
    010FA 2700      CLR	R16
    010FB C04A      RJMP	0x1146
(1994) 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    010FC E188      LDI	R24,0x18
    010FD E090      LDI	R25,0
    010FE 01F5      MOVW	R30,R10
    010FF 57ED      SUBI	R30,0x7D
    01100 4FFF      SBCI	R31,0xFF
    01101 8100      LD	R16,Z
    01102 2711      CLR	R17
    01103 2722      CLR	R18
    01104 2733      CLR	R19
    01105 938A      ST	-Y,R24
    01106 940E 3CF7 CALL	lsl32
    01108 0118      MOVW	R2,R16
    01109 0129      MOVW	R4,R18
    0110A 01F5      MOVW	R30,R10
    0110B 57EE      SUBI	R30,0x7E
    0110C 4FFF      SBCI	R31,0xFF
    0110D 8060      LD	R6,Z
    0110E 58E2      SUBI	R30,0x82
    0110F 40F0      SBCI	R31,0
    01110 2477      CLR	R7
    01111 2488      CLR	R8
    01112 2499      CLR	R9
    01113 0143      MOVW	R8,R6
    01114 2466      CLR	R6
    01115 2477      CLR	R7
    01116 2826      OR	R2,R6
    01117 2837      OR	R3,R7
    01118 2848      OR	R4,R8
    01119 2859      OR	R5,R9
    0111A 57EF      SUBI	R30,0x7F
    0111B 4FFF      SBCI	R31,0xFF
    0111C 8060      LD	R6,Z
    0111D 58E1      SUBI	R30,0x81
    0111E 40F0      SBCI	R31,0
    0111F 2477      CLR	R7
    01120 2C76      MOV	R7,R6
    01121 2466      CLR	R6
    01122 2488      CLR	R8
    01123 2499      CLR	R9
    01124 2826      OR	R2,R6
    01125 2837      OR	R3,R7
    01126 2848      OR	R4,R8
    01127 2859      OR	R5,R9
    01128 58E0      SUBI	R30,0x80
    01129 4FFF      SBCI	R31,0xFF
    0112A 8060      LD	R6,Z
    0112B 2477      CLR	R7
    0112C 2488      CLR	R8
    0112D 2499      CLR	R9
    0112E 2826      OR	R2,R6
    0112F 2837      OR	R3,R7
    01130 2848      OR	R4,R8
    01131 2859      OR	R5,R9
    01132 EF4F      LDI	R20,0xFF
    01133 EF5F      LDI	R21,0xFF
    01134 EF6F      LDI	R22,0xFF
    01135 E070      LDI	R23,0
    01136 2224      AND	R2,R20
    01137 2235      AND	R3,R21
    01138 2246      AND	R4,R22
    01139 2257      AND	R5,R23
    0113A E446      LDI	R20,0x46
    0113B E451      LDI	R21,0x41
    0113C E564      LDI	R22,0x54
    0113D E070      LDI	R23,0
    0113E 1624      CP	R2,R20
    0113F 0635      CPC	R3,R21
    01140 0646      CPC	R4,R22
    01141 0657      CPC	R5,R23
    01142 F411      BNE	0x1145
(1995) 		return 0;
    01143 2700      CLR	R16
    01144 C001      RJMP	0x1146
(1996) 
(1997) 	return 1;
    01145 E001      LDI	R16,1
    01146 9625      ADIW	R28,5
    01147 940E 3C9B CALL	pop_xgsetF00C
    01149 9622      ADIW	R28,2
    0114A 9508      RET
ff.c:chk_mounted:
  pi                   --> R10
  szbfat               --> Y,+25
  tbl                  --> R10
  p                    --> R10
  nrsv                 --> R14
  sysect               --> Y,+21
  bsect                --> Y,+17
  stat                 --> R10
  tsect                --> Y,+13
  nclst                --> Y,+9
  vol                  --> R14
  fasize               --> Y,+5
  b                    --> R14
  fmt                  --> R12
  fs                   --> Y,+37
  chk_wp               --> Y,+51
  rfs                  --> Y,+49
  path                 --> R12
    0114B 933A      ST	-Y,R19
    0114C 932A      ST	-Y,R18
    0114D 940E 3C75 CALL	push_xgsetF0FC
    0114F 0168      MOVW	R12,R16
    01150 97A7      SBIW	R28,0x27
(1998) }
(1999) 
(2000) 
(2001) 
(2002) 
(2003) /*-----------------------------------------------------------------------*/
(2004) /* Check if the file system object is valid or not                       */
(2005) /*-----------------------------------------------------------------------*/
(2006) 
(2007) static
(2008) FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
(2009) 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
(2010) 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
(2011) 	BYTE chk_wp			/* !=0: Check media write protection for write access */
(2012) )
(2013) {
(2014) 	BYTE fmt, b, pi, *tbl;
(2015) 	UINT vol;
(2016) 	DSTATUS stat;
(2017) 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
(2018) 	WORD nrsv;
(2019) 	const TCHAR *p = *path;
    01151 01F6      MOVW	R30,R12
    01152 80A0      LD	R10,Z
    01153 80B1      LDD	R11,Z+1
(2020) 	FATFS *fs;
(2021) 
(2022) 	/* Get logical drive number from the path name */
(2023) 	vol = p[0] - '0';					/* Is there a drive number? */
    01154 01F5      MOVW	R30,R10
    01155 8180      LD	R24,Z
    01156 2799      CLR	R25
    01157 97C0      SBIW	R24,0x30
    01158 017C      MOVW	R14,R24
(2024) 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    01159 E089      LDI	R24,0x9
    0115A E090      LDI	R25,0
    0115B 158E      CP	R24,R14
    0115C 059F      CPC	R25,R15
    0115D F050      BCS	0x1168
    0115E 8181      LDD	R24,Z+1
    0115F 338A      CPI	R24,0x3A
    01160 F439      BNE	0x1168
(2025) 		p += 2; *path = p;				/* Return pointer to the path name */
    01161 01CF      MOVW	R24,R30
    01162 9602      ADIW	R24,2
    01163 015C      MOVW	R10,R24
    01164 01F6      MOVW	R30,R12
    01165 82B1      STD	Z+1,R11
    01166 82A0      ST	Z,R10
(2026) 	} else {							/* No drive number is given */
    01167 C002      RJMP	0x116A
(2027) #if _FS_RPATH
(2028) 		vol = CurrVol;					/* Use current drive */
(2029) #else
(2030) 		vol = 0;						/* Use drive 0 */
    01168 24EE      CLR	R14
    01169 24FF      CLR	R15
(2031) #endif
(2032) 	}
(2033) 
(2034) 	/* Check if the file system object is valid or not */
(2035) 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    0116A 01C7      MOVW	R24,R14
    0116B 3081      CPI	R24,1
    0116C E0E0      LDI	R30,0
    0116D 079E      CPC	R25,R30
    0116E F010      BCS	0x1171
(2036) 		return FR_INVALID_DRIVE;
    0116F E00B      LDI	R16,0xB
    01170 C4CF      RJMP	0x1640
(2037) 	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    01171 ED88      LDI	R24,0xD8
    01172 E094      LDI	R25,4
    01173 01F7      MOVW	R30,R14
    01174 0FEE      LSL	R30
    01175 1FFF      ROL	R31
    01176 0FE8      ADD	R30,R24
    01177 1FF9      ADC	R31,R25
    01178 8020      LD	R2,Z
    01179 8031      LDD	R3,Z+1
    0117A A23E      STD	Y+38,R3
    0117B A22D      STD	Y+37,R2
    0117C A9E9      LDD	R30,Y+49
    0117D A9FA      LDD	R31,Y+50
    0117E 8231      STD	Z+1,R3
    0117F 8220      ST	Z,R2
(2038) 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    01180 0101      MOVW	R0,R2
    01181 2022      TST	R2
    01182 F421      BNE	0x1187
    01183 2033      TST	R3
    01184 F411      BNE	0x1187
    01185 E00C      LDI	R16,0xC
    01186 C4B9      RJMP	0x1640
(2039) 
(2040) 	ENTER_FF(fs);						/* Lock file system */
(2041) 
(2042) 	if (fs->fs_type) {					/* If the logical drive has been mounted */
    01187 A1ED      LDD	R30,Y+37
    01188 A1FE      LDD	R31,Y+38
    01189 8020      LD	R2,Z
    0118A 2022      TST	R2
    0118B F079      BEQ	0x119B
(2043) 		stat = disk_status(fs->drv);
    0118C 8101      LDD	R16,Z+1
    0118D 940E 028C CALL	_disk_status
    0118F 2EA0      MOV	R10,R16
(2044) 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    01190 FD00      SBRC	R16,0
    01191 C009      RJMP	0x119B
(2045) 			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    01192 A80B      LDD	R0,Y+51
    01193 2000      TST	R0
    01194 F021      BEQ	0x1199
    01195 FF02      SBRS	R16,2
    01196 C002      RJMP	0x1199
(2046) 				return FR_WRITE_PROTECTED;
    01197 E00A      LDI	R16,0xA
    01198 C4A7      RJMP	0x1640
(2047) 			return FR_OK;				/* The file system object is valid */
    01199 2700      CLR	R16
    0119A C4A5      RJMP	0x1640
(2048) 		}
(2049) 	}
(2050) 
(2051) 	/* The file system object is not valid. */
(2052) 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
(2053) 
(2054) 	fs->fs_type = 0;					/* Clear the file system object */
    0119B 2422      CLR	R2
    0119C A1ED      LDD	R30,Y+37
    0119D A1FE      LDD	R31,Y+38
    0119E 8220      ST	Z,R2
(2055) 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    0119F 82E1      STD	Z+1,R14
(2056) 	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    011A0 8101      LDD	R16,Z+1
    011A1 940E 0276 CALL	_disk_initialize
    011A3 2EE0      MOV	R14,R16
    011A4 2CAE      MOV	R10,R14
(2057) 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    011A5 FF00      SBRS	R16,0
    011A6 C002      RJMP	0x11A9
(2058) 		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    011A7 E003      LDI	R16,3
    011A8 C497      RJMP	0x1640
(2059) 	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    011A9 A80B      LDD	R0,Y+51
    011AA 2000      TST	R0
    011AB F021      BEQ	0x11B0
    011AC FEA2      SBRS	R10,2
    011AD C002      RJMP	0x11B0
(2060) 		return FR_WRITE_PROTECTED;
    011AE E00A      LDI	R16,0xA
    011AF C490      RJMP	0x1640
(2061) #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
(2062) 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
(2063) 		return FR_DISK_ERR;
(2064) #endif
(2065) 	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
(2066) 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    011B0 E080      LDI	R24,0
    011B1 8B89      STD	Y+17,R24
    011B2 8B8A      STD	Y+18,R24
    011B3 8B8B      STD	Y+19,R24
    011B4 8B8C      STD	Y+20,R24
    011B5 E040      LDI	R20,0
    011B6 E050      LDI	R21,0
    011B7 E060      LDI	R22,0
    011B8 E070      LDI	R23,0
    011B9 8368      ST	Y,R22
    011BA 8379      STD	Y+1,R23
    011BB 019A      MOVW	R18,R20
    011BC A10D      LDD	R16,Y+37
    011BD A11E      LDD	R17,Y+38
    011BE DEC4      RCALL	ff.c:check_fs
    011BF 2EA0      MOV	R10,R16
    011C0 2CCA      MOV	R12,R10
(2067) 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
    011C1 C000      RJMP	0x11C2
(2068) 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    011C2 2D8C      MOV	R24,R12
    011C3 3081      CPI	R24,1
    011C4 F009      BEQ	0x11C6
    011C5 C04C      RJMP	0x1212
(2069) 		/* Check the partition listed in the partition table */
(2070) 		pi = LD2PT(vol);
    011C6 24AA      CLR	R10
(2071) 		if (pi) pi--;
    011C7 F009      BEQ	0x11C9
    011C8 94AA      DEC	R10
(2072) 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
    011C9 E100      LDI	R16,0x10
    011CA 2D1A      MOV	R17,R10
    011CB 0301      MULSU	R16,R17
    011CC 0150      MOVW	R10,R0
    011CD A18D      LDD	R24,Y+37
    011CE A19E      LDD	R25,Y+38
    011CF 5184      SUBI	R24,0x14
    011D0 4F9E      SBCI	R25,0xFE
    011D1 0EA8      ADD	R10,R24
    011D2 1EB9      ADC	R11,R25
(2073) 		if (tbl[4]) {						/* Is the partition existing? */
    011D3 01F5      MOVW	R30,R10
    011D4 8024      LDD	R2,Z+4
    011D5 2022      TST	R2
    011D6 F409      BNE	0x11D8
    011D7 C03A      RJMP	0x1212
(2074) 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    011D8 E188      LDI	R24,0x18
    011D9 E090      LDI	R25,0
    011DA 8503      LDD	R16,Z+11
    011DB 2711      CLR	R17
    011DC 2722      CLR	R18
    011DD 2733      CLR	R19
    011DE 938A      ST	-Y,R24
    011DF 940E 3CF7 CALL	lsl32
    011E1 0118      MOVW	R2,R16
    011E2 0129      MOVW	R4,R18
    011E3 01F5      MOVW	R30,R10
    011E4 8462      LDD	R6,Z+10
    011E5 2477      CLR	R7
    011E6 2488      CLR	R8
    011E7 2499      CLR	R9
    011E8 0143      MOVW	R8,R6
    011E9 2466      CLR	R6
    011EA 2477      CLR	R7
    011EB 2826      OR	R2,R6
    011EC 2837      OR	R3,R7
    011ED 2848      OR	R4,R8
    011EE 2859      OR	R5,R9
    011EF 8461      LDD	R6,Z+9
    011F0 2477      CLR	R7
    011F1 2C76      MOV	R7,R6
    011F2 2466      CLR	R6
    011F3 2488      CLR	R8
    011F4 2499      CLR	R9
    011F5 2826      OR	R2,R6
    011F6 2837      OR	R3,R7
    011F7 2848      OR	R4,R8
    011F8 2859      OR	R5,R9
    011F9 9638      ADIW	R30,0x8
    011FA 8060      LD	R6,Z
    011FB 2477      CLR	R7
    011FC 2488      CLR	R8
    011FD 2499      CLR	R9
    011FE 2826      OR	R2,R6
    011FF 2837      OR	R3,R7
    01200 2848      OR	R4,R8
    01201 2859      OR	R5,R9
    01202 8A29      STD	Y+17,R2
    01203 8A3A      STD	Y+18,R3
    01204 8A4B      STD	Y+19,R4
    01205 8A5C      STD	Y+20,R5
(2075) 			fmt = check_fs(fs, bsect);		/* Check the partition */
    01206 8829      LDD	R2,Y+17
    01207 883A      LDD	R3,Y+18
    01208 884B      LDD	R4,Y+19
    01209 885C      LDD	R5,Y+20
    0120A 8248      ST	Y,R4
    0120B 8259      STD	Y+1,R5
    0120C 0191      MOVW	R18,R2
    0120D A10D      LDD	R16,Y+37
    0120E A11E      LDD	R17,Y+38
    0120F DE73      RCALL	ff.c:check_fs
    01210 2EA0      MOV	R10,R16
    01211 2CCA      MOV	R12,R10
(2076) 		}
(2077) 	}
(2078) 	if (fmt == 3) return FR_DISK_ERR;
    01212 2D8C      MOV	R24,R12
    01213 3083      CPI	R24,3
    01214 F411      BNE	0x1217
    01215 E001      LDI	R16,1
    01216 C429      RJMP	0x1640
(2079) 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    01217 20CC      TST	R12
    01218 F011      BEQ	0x121B
    01219 E00D      LDI	R16,0xD
    0121A C425      RJMP	0x1640
(2080) 
(2081) 	/* An FAT volume is found. Following code initializes the file system object */
(2082) 
(2083) 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    0121B A1ED      LDD	R30,Y+37
    0121C A1FE      LDD	R31,Y+38
    0121D AC21      LDD	R2,Z+57
    0121E 2433      CLR	R3
    0121F AD82      LDD	R24,Z+58
    01220 2799      CLR	R25
    01221 2F98      MOV	R25,R24
    01222 2788      CLR	R24
    01223 2982      OR	R24,R2
    01224 2993      OR	R25,R3
    01225 3080      CPI	R24,0
    01226 E0E2      LDI	R30,2
    01227 079E      CPC	R25,R30
    01228 F011      BEQ	0x122B
(2084) 		return FR_NO_FILESYSTEM;
    01229 E00D      LDI	R16,0xD
    0122A C415      RJMP	0x1640
(2085) 
(2086) 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    0122B A1ED      LDD	R30,Y+37
    0122C A1FE      LDD	R31,Y+38
    0122D 5BEC      SUBI	R30,0xBC
    0122E 4FFF      SBCI	R31,0xFF
    0122F 8020      LD	R2,Z
    01230 54E4      SUBI	R30,0x44
    01231 40F0      SBCI	R31,0
    01232 2433      CLR	R3
    01233 5BEB      SUBI	R30,0xBB
    01234 4FFF      SBCI	R31,0xFF
    01235 8040      LD	R4,Z
    01236 2455      CLR	R5
    01237 2C54      MOV	R5,R4
    01238 2444      CLR	R4
    01239 2842      OR	R4,R2
    0123A 2853      OR	R5,R3
    0123B 0112      MOVW	R2,R4
    0123C 2444      CLR	R4
    0123D 2455      CLR	R5
    0123E 822D      STD	Y+5,R2
    0123F 823E      STD	Y+6,R3
    01240 824F      STD	Y+7,R4
    01241 8658      STD	Y+8,R5
(2087) 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    01242 802D      LDD	R2,Y+5
    01243 803E      LDD	R3,Y+6
    01244 804F      LDD	R4,Y+7
    01245 8458      LDD	R5,Y+8
    01246 9488      BCLR	0
    01247 2022      TST	R2
    01248 0432      CPC	R3,R2
    01249 0442      CPC	R4,R2
    0124A 0452      CPC	R5,R2
    0124B F009      BEQ	0x124D
    0124C C03C      RJMP	0x1289
    0124D E188      LDI	R24,0x18
    0124E E090      LDI	R25,0
    0124F A1ED      LDD	R30,Y+37
    01250 A1FE      LDD	R31,Y+38
    01251 5AEB      SUBI	R30,0xAB
    01252 4FFF      SBCI	R31,0xFF
    01253 8100      LD	R16,Z
    01254 2711      CLR	R17
    01255 2722      CLR	R18
    01256 2733      CLR	R19
    01257 938A      ST	-Y,R24
    01258 940E 3CF7 CALL	lsl32
    0125A 0118      MOVW	R2,R16
    0125B 0129      MOVW	R4,R18
    0125C A1ED      LDD	R30,Y+37
    0125D A1FE      LDD	R31,Y+38
    0125E 5AEC      SUBI	R30,0xAC
    0125F 4FFF      SBCI	R31,0xFF
    01260 8060      LD	R6,Z
    01261 55E4      SUBI	R30,0x54
    01262 40F0      SBCI	R31,0
    01263 2477      CLR	R7
    01264 2488      CLR	R8
    01265 2499      CLR	R9
    01266 0143      MOVW	R8,R6
    01267 2466      CLR	R6
    01268 2477      CLR	R7
    01269 2826      OR	R2,R6
    0126A 2837      OR	R3,R7
    0126B 2848      OR	R4,R8
    0126C 2859      OR	R5,R9
    0126D 5AED      SUBI	R30,0xAD
    0126E 4FFF      SBCI	R31,0xFF
    0126F 8060      LD	R6,Z
    01270 55E3      SUBI	R30,0x53
    01271 40F0      SBCI	R31,0
    01272 2477      CLR	R7
    01273 2C76      MOV	R7,R6
    01274 2466      CLR	R6
    01275 2488      CLR	R8
    01276 2499      CLR	R9
    01277 2826      OR	R2,R6
    01278 2837      OR	R3,R7
    01279 2848      OR	R4,R8
    0127A 2859      OR	R5,R9
    0127B 5AEE      SUBI	R30,0xAE
    0127C 4FFF      SBCI	R31,0xFF
    0127D 8060      LD	R6,Z
    0127E 2477      CLR	R7
    0127F 2488      CLR	R8
    01280 2499      CLR	R9
    01281 2826      OR	R2,R6
    01282 2837      OR	R3,R7
    01283 2848      OR	R4,R8
    01284 2859      OR	R5,R9
    01285 822D      STD	Y+5,R2
    01286 823E      STD	Y+6,R3
    01287 824F      STD	Y+7,R4
    01288 8658      STD	Y+8,R5
(2088) 	fs->fsize = fasize;
    01289 802D      LDD	R2,Y+5
    0128A 803E      LDD	R3,Y+6
    0128B 804F      LDD	R4,Y+7
    0128C 8458      LDD	R5,Y+8
    0128D A1ED      LDD	R30,Y+37
    0128E A1FE      LDD	R31,Y+38
    0128F 8E22      STD	Z+26,R2
    01290 8E33      STD	Z+27,R3
    01291 8E44      STD	Z+28,R4
    01292 8E55      STD	Z+29,R5
(2089) 
(2090) 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    01293 ACA6      LDD	R10,Z+62
    01294 2CEA      MOV	R14,R10
    01295 82A3      STD	Z+3,R10
(2091) 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    01296 2D8E      MOV	R24,R14
    01297 3081      CPI	R24,1
    01298 F021      BEQ	0x129D
    01299 3082      CPI	R24,2
    0129A F011      BEQ	0x129D
    0129B E00D      LDI	R16,0xD
    0129C C3A3      RJMP	0x1640
(2092) 	fasize *= b;										/* Number of sectors for FAT area */
    0129D 2C2E      MOV	R2,R14
    0129E 2433      CLR	R3
    0129F 2444      CLR	R4
    012A0 2455      CLR	R5
    012A1 810D      LDD	R16,Y+5
    012A2 811E      LDD	R17,Y+6
    012A3 812F      LDD	R18,Y+7
    012A4 8538      LDD	R19,Y+8
    012A5 925A      ST	-Y,R5
    012A6 924A      ST	-Y,R4
    012A7 923A      ST	-Y,R3
    012A8 922A      ST	-Y,R2
    012A9 940E 3C21 CALL	empy32s|empy32u
    012AB 830D      STD	Y+5,R16
    012AC 831E      STD	Y+6,R17
    012AD 832F      STD	Y+7,R18
    012AE 8738      STD	Y+8,R19
(2093) 
(2094) 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    012AF A1ED      LDD	R30,Y+37
    012B0 A1FE      LDD	R31,Y+38
    012B1 ACA3      LDD	R10,Z+59
    012B2 2CEA      MOV	R14,R10
    012B3 82A2      STD	Z+2,R10
(2095) 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    012B4 20AA      TST	R10
    012B5 F029      BEQ	0x12BB
    012B6 2D8E      MOV	R24,R14
    012B7 5081      SUBI	R24,1
    012B8 2C2E      MOV	R2,R14
    012B9 2228      AND	R2,R24
    012BA F011      BEQ	0x12BD
    012BB E00D      LDI	R16,0xD
    012BC C383      RJMP	0x1640
(2096) 
(2097) 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    012BD A1ED      LDD	R30,Y+37
    012BE A1FE      LDD	R31,Y+38
    012BF AC27      LDD	R2,Z+63
    012C0 2433      CLR	R3
    012C1 5CE0      SUBI	R30,0xC0
    012C2 4FFF      SBCI	R31,0xFF
    012C3 8040      LD	R4,Z
    012C4 54E0      SUBI	R30,0x40
    012C5 40F0      SBCI	R31,0
    012C6 2455      CLR	R5
    012C7 2C54      MOV	R5,R4
    012C8 2444      CLR	R4
    012C9 2842      OR	R4,R2
    012CA 2853      OR	R5,R3
    012CB 8651      STD	Z+9,R5
    012CC 8640      STD	Z+8,R4
(2098) 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    012CD 8580      LDD	R24,Z+8
    012CE 8591      LDD	R25,Z+9
    012CF 708F      ANDI	R24,0xF
    012D0 7090      ANDI	R25,0
    012D1 3080      CPI	R24,0
    012D2 0789      CPC	R24,R25
    012D3 F011      BEQ	0x12D6
    012D4 E00D      LDI	R16,0xD
    012D5 C36A      RJMP	0x1640
(2099) 
(2100) 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    012D6 A1ED      LDD	R30,Y+37
    012D7 A1FE      LDD	R31,Y+38
    012D8 5BEF      SUBI	R30,0xBF
    012D9 4FFF      SBCI	R31,0xFF
    012DA 8020      LD	R2,Z
    012DB 54E1      SUBI	R30,0x41
    012DC 40F0      SBCI	R31,0
    012DD 2433      CLR	R3
    012DE 5BEE      SUBI	R30,0xBE
    012DF 4FFF      SBCI	R31,0xFF
    012E0 8040      LD	R4,Z
    012E1 2455      CLR	R5
    012E2 2C54      MOV	R5,R4
    012E3 2444      CLR	R4
    012E4 2842      OR	R4,R2
    012E5 2853      OR	R5,R3
    012E6 0112      MOVW	R2,R4
    012E7 2444      CLR	R4
    012E8 2455      CLR	R5
    012E9 862D      STD	Y+13,R2
    012EA 863E      STD	Y+14,R3
    012EB 864F      STD	Y+15,R4
    012EC 8A58      STD	Y+16,R5
(2101) 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    012ED 842D      LDD	R2,Y+13
    012EE 843E      LDD	R3,Y+14
    012EF 844F      LDD	R4,Y+15
    012F0 8858      LDD	R5,Y+16
    012F1 9488      BCLR	0
    012F2 2022      TST	R2
    012F3 0432      CPC	R3,R2
    012F4 0442      CPC	R4,R2
    012F5 0452      CPC	R5,R2
    012F6 F009      BEQ	0x12F8
    012F7 C03C      RJMP	0x1334
    012F8 E188      LDI	R24,0x18
    012F9 E090      LDI	R25,0
    012FA A1ED      LDD	R30,Y+37
    012FB A1FE      LDD	R31,Y+38
    012FC 5AEF      SUBI	R30,0xAF
    012FD 4FFF      SBCI	R31,0xFF
    012FE 8100      LD	R16,Z
    012FF 2711      CLR	R17
    01300 2722      CLR	R18
    01301 2733      CLR	R19
    01302 938A      ST	-Y,R24
    01303 940E 3CF7 CALL	lsl32
    01305 0118      MOVW	R2,R16
    01306 0129      MOVW	R4,R18
    01307 A1ED      LDD	R30,Y+37
    01308 A1FE      LDD	R31,Y+38
    01309 5BE0      SUBI	R30,0xB0
    0130A 4FFF      SBCI	R31,0xFF
    0130B 8060      LD	R6,Z
    0130C 55E0      SUBI	R30,0x50
    0130D 40F0      SBCI	R31,0
    0130E 2477      CLR	R7
    0130F 2488      CLR	R8
    01310 2499      CLR	R9
    01311 0143      MOVW	R8,R6
    01312 2466      CLR	R6
    01313 2477      CLR	R7
    01314 2826      OR	R2,R6
    01315 2837      OR	R3,R7
    01316 2848      OR	R4,R8
    01317 2859      OR	R5,R9
    01318 5BE1      SUBI	R30,0xB1
    01319 4FFF      SBCI	R31,0xFF
    0131A 8060      LD	R6,Z
    0131B 54EF      SUBI	R30,0x4F
    0131C 40F0      SBCI	R31,0
    0131D 2477      CLR	R7
    0131E 2C76      MOV	R7,R6
    0131F 2466      CLR	R6
    01320 2488      CLR	R8
    01321 2499      CLR	R9
    01322 2826      OR	R2,R6
    01323 2837      OR	R3,R7
    01324 2848      OR	R4,R8
    01325 2859      OR	R5,R9
    01326 5BE2      SUBI	R30,0xB2
    01327 4FFF      SBCI	R31,0xFF
    01328 8060      LD	R6,Z
    01329 2477      CLR	R7
    0132A 2488      CLR	R8
    0132B 2499      CLR	R9
    0132C 2826      OR	R2,R6
    0132D 2837      OR	R3,R7
    0132E 2848      OR	R4,R8
    0132F 2859      OR	R5,R9
    01330 862D      STD	Y+13,R2
    01331 863E      STD	Y+14,R3
    01332 864F      STD	Y+15,R4
    01333 8A58      STD	Y+16,R5
(2102) 
(2103) 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    01334 A1ED      LDD	R30,Y+37
    01335 A1FE      LDD	R31,Y+38
    01336 AC24      LDD	R2,Z+60
    01337 2433      CLR	R3
    01338 ACE5      LDD	R14,Z+61
    01339 24FF      CLR	R15
    0133A 2CFE      MOV	R15,R14
    0133B 24EE      CLR	R14
    0133C 28E2      OR	R14,R2
    0133D 28F3      OR	R15,R3
(2104) 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    0133E 20EE      TST	R14
    0133F F421      BNE	0x1344
    01340 20FF      TST	R15
    01341 F411      BNE	0x1344
    01342 E00D      LDI	R16,0xD
    01343 C2FC      RJMP	0x1640
(2105) 
(2106) 	/* Determine the FAT sub type */
(2107) 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    01344 802D      LDD	R2,Y+5
    01345 803E      LDD	R3,Y+6
    01346 804F      LDD	R4,Y+7
    01347 8458      LDD	R5,Y+8
    01348 0137      MOVW	R6,R14
    01349 2488      CLR	R8
    0134A 2499      CLR	R9
    0134B 0C62      ADD	R6,R2
    0134C 1C73      ADC	R7,R3
    0134D 1C84      ADC	R8,R4
    0134E 1C95      ADC	R9,R5
    0134F A1ED      LDD	R30,Y+37
    01350 A1FE      LDD	R31,Y+38
    01351 9638      ADIW	R30,0x8
    01352 8020      LD	R2,Z
    01353 8031      LDD	R3,Z+1
    01354 9436      LSR	R3
    01355 9427      ROR	R2
    01356 9436      LSR	R3
    01357 9427      ROR	R2
    01358 9436      LSR	R3
    01359 9427      ROR	R2
    0135A 9436      LSR	R3
    0135B 9427      ROR	R2
    0135C 2444      CLR	R4
    0135D 2455      CLR	R5
    0135E 0C62      ADD	R6,R2
    0135F 1C73      ADC	R7,R3
    01360 1C84      ADC	R8,R4
    01361 1C95      ADC	R9,R5
    01362 8A6D      STD	Y+21,R6
    01363 8A7E      STD	Y+22,R7
    01364 8A8F      STD	Y+23,R8
    01365 8E98      STD	Y+24,R9
(2108) 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    01366 882D      LDD	R2,Y+21
    01367 883E      LDD	R3,Y+22
    01368 884F      LDD	R4,Y+23
    01369 8C58      LDD	R5,Y+24
    0136A 846D      LDD	R6,Y+13
    0136B 847E      LDD	R7,Y+14
    0136C 848F      LDD	R8,Y+15
    0136D 8898      LDD	R9,Y+16
    0136E 1462      CP	R6,R2
    0136F 0473      CPC	R7,R3
    01370 0484      CPC	R8,R4
    01371 0495      CPC	R9,R5
    01372 F410      BCC	0x1375
    01373 E00D      LDI	R16,0xD
    01374 C2CB      RJMP	0x1640
(2109) 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    01375 882D      LDD	R2,Y+21
    01376 883E      LDD	R3,Y+22
    01377 884F      LDD	R4,Y+23
    01378 8C58      LDD	R5,Y+24
    01379 850D      LDD	R16,Y+13
    0137A 851E      LDD	R17,Y+14
    0137B 852F      LDD	R18,Y+15
    0137C 8938      LDD	R19,Y+16
    0137D 1902      SUB	R16,R2
    0137E 0913      SBC	R17,R3
    0137F 0924      SBC	R18,R4
    01380 0935      SBC	R19,R5
    01381 A1ED      LDD	R30,Y+37
    01382 A1FE      LDD	R31,Y+38
    01383 9632      ADIW	R30,2
    01384 8020      LD	R2,Z
    01385 2433      CLR	R3
    01386 2444      CLR	R4
    01387 2455      CLR	R5
    01388 925A      ST	-Y,R5
    01389 924A      ST	-Y,R4
    0138A 923A      ST	-Y,R3
    0138B 922A      ST	-Y,R2
    0138C 940E 3B7B CALL	div32u
    0138E 8709      STD	Y+9,R16
    0138F 871A      STD	Y+10,R17
    01390 872B      STD	Y+11,R18
    01391 873C      STD	Y+12,R19
(2110) 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    01392 8429      LDD	R2,Y+9
    01393 843A      LDD	R3,Y+10
    01394 844B      LDD	R4,Y+11
    01395 845C      LDD	R5,Y+12
    01396 9488      BCLR	0
    01397 2022      TST	R2
    01398 0432      CPC	R3,R2
    01399 0442      CPC	R4,R2
    0139A 0452      CPC	R5,R2
    0139B F411      BNE	0x139E
    0139C E00D      LDI	R16,0xD
    0139D C2A2      RJMP	0x1640
(2111) 	fmt = FS_FAT12;
    0139E 24CC      CLR	R12
    0139F 94C3      INC	R12
(2112) 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    013A0 EF46      LDI	R20,0xF6
    013A1 E05F      LDI	R21,0xF
    013A2 E060      LDI	R22,0
    013A3 E070      LDI	R23,0
    013A4 8429      LDD	R2,Y+9
    013A5 843A      LDD	R3,Y+10
    013A6 844B      LDD	R4,Y+11
    013A7 845C      LDD	R5,Y+12
    013A8 1624      CP	R2,R20
    013A9 0635      CPC	R3,R21
    013AA 0646      CPC	R4,R22
    013AB 0657      CPC	R5,R23
    013AC F010      BCS	0x13AF
    013AD E082      LDI	R24,2
    013AE 2EC8      MOV	R12,R24
(2113) 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    013AF EF46      LDI	R20,0xF6
    013B0 EF5F      LDI	R21,0xFF
    013B1 E060      LDI	R22,0
    013B2 E070      LDI	R23,0
    013B3 8429      LDD	R2,Y+9
    013B4 843A      LDD	R3,Y+10
    013B5 844B      LDD	R4,Y+11
    013B6 845C      LDD	R5,Y+12
    013B7 1624      CP	R2,R20
    013B8 0635      CPC	R3,R21
    013B9 0646      CPC	R4,R22
    013BA 0657      CPC	R5,R23
    013BB F010      BCS	0x13BE
    013BC E083      LDI	R24,3
    013BD 2EC8      MOV	R12,R24
(2114) 
(2115) 	/* Boundaries and Limits */
(2116) 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    013BE E042      LDI	R20,2
    013BF E050      LDI	R21,0
    013C0 E060      LDI	R22,0
    013C1 E070      LDI	R23,0
    013C2 8429      LDD	R2,Y+9
    013C3 843A      LDD	R3,Y+10
    013C4 844B      LDD	R4,Y+11
    013C5 845C      LDD	R5,Y+12
    013C6 0E24      ADD	R2,R20
    013C7 1E35      ADC	R3,R21
    013C8 1E46      ADC	R4,R22
    013C9 1E57      ADC	R5,R23
    013CA A1ED      LDD	R30,Y+37
    013CB A1FE      LDD	R31,Y+38
    013CC 9676      ADIW	R30,0x16
    013CD 8220      ST	Z,R2
    013CE 8231      STD	Z+1,R3
    013CF 8242      STD	Z+2,R4
    013D0 8253      STD	Z+3,R5
(2117) 	fs->database = bsect + sysect;						/* Data start sector */
    013D1 882D      LDD	R2,Y+21
    013D2 883E      LDD	R3,Y+22
    013D3 884F      LDD	R4,Y+23
    013D4 8C58      LDD	R5,Y+24
    013D5 8869      LDD	R6,Y+17
    013D6 887A      LDD	R7,Y+18
    013D7 888B      LDD	R8,Y+19
    013D8 889C      LDD	R9,Y+20
    013D9 0C62      ADD	R6,R2
    013DA 1C73      ADC	R7,R3
    013DB 1C84      ADC	R8,R4
    013DC 1C95      ADC	R9,R5
    013DD A1ED      LDD	R30,Y+37
    013DE A1FE      LDD	R31,Y+38
    013DF 96B6      ADIW	R30,0x26
    013E0 8260      ST	Z,R6
    013E1 8271      STD	Z+1,R7
    013E2 8282      STD	Z+2,R8
    013E3 8293      STD	Z+3,R9
(2118) 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    013E4 0117      MOVW	R2,R14
    013E5 2444      CLR	R4
    013E6 2455      CLR	R5
    013E7 8869      LDD	R6,Y+17
    013E8 887A      LDD	R7,Y+18
    013E9 888B      LDD	R8,Y+19
    013EA 889C      LDD	R9,Y+20
    013EB 0C62      ADD	R6,R2
    013EC 1C73      ADC	R7,R3
    013ED 1C84      ADC	R8,R4
    013EE 1C95      ADC	R9,R5
    013EF A1ED      LDD	R30,Y+37
    013F0 A1FE      LDD	R31,Y+38
    013F1 8E66      STD	Z+30,R6
    013F2 8E77      STD	Z+31,R7
    013F3 A280      STD	Z+32,R8
    013F4 A291      STD	Z+33,R9
(2119) 	if (fmt == FS_FAT32) {
    013F5 2D8C      MOV	R24,R12
    013F6 3083      CPI	R24,3
    013F7 F009      BEQ	0x13F9
    013F8 C055      RJMP	0x144E
(2120) 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    013F9 8420      LDD	R2,Z+8
    013FA 8431      LDD	R3,Z+9
    013FB 2022      TST	R2
    013FC F411      BNE	0x13FF
    013FD 2033      TST	R3
    013FE F011      BEQ	0x1401
    013FF E00D      LDI	R16,0xD
    01400 C23F      RJMP	0x1640
(2121) 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    01401 E188      LDI	R24,0x18
    01402 E090      LDI	R25,0
    01403 A1ED      LDD	R30,Y+37
    01404 A1FE      LDD	R31,Y+38
    01405 5AE3      SUBI	R30,0xA3
    01406 4FFF      SBCI	R31,0xFF
    01407 8100      LD	R16,Z
    01408 2711      CLR	R17
    01409 2722      CLR	R18
    0140A 2733      CLR	R19
    0140B 938A      ST	-Y,R24
    0140C 940E 3CF7 CALL	lsl32
    0140E 0118      MOVW	R2,R16
    0140F 0129      MOVW	R4,R18
    01410 A1ED      LDD	R30,Y+37
    01411 A1FE      LDD	R31,Y+38
    01412 5AE4      SUBI	R30,0xA4
    01413 4FFF      SBCI	R31,0xFF
    01414 8060      LD	R6,Z
    01415 55EC      SUBI	R30,0x5C
    01416 40F0      SBCI	R31,0
    01417 2477      CLR	R7
    01418 2488      CLR	R8
    01419 2499      CLR	R9
    0141A 0143      MOVW	R8,R6
    0141B 2466      CLR	R6
    0141C 2477      CLR	R7
    0141D 2826      OR	R2,R6
    0141E 2837      OR	R3,R7
    0141F 2848      OR	R4,R8
    01420 2859      OR	R5,R9
    01421 5AE5      SUBI	R30,0xA5
    01422 4FFF      SBCI	R31,0xFF
    01423 8060      LD	R6,Z
    01424 55EB      SUBI	R30,0x5B
    01425 40F0      SBCI	R31,0
    01426 2477      CLR	R7
    01427 2C76      MOV	R7,R6
    01428 2466      CLR	R6
    01429 2488      CLR	R8
    0142A 2499      CLR	R9
    0142B 2826      OR	R2,R6
    0142C 2837      OR	R3,R7
    0142D 2848      OR	R4,R8
    0142E 2859      OR	R5,R9
    0142F 5AE6      SUBI	R30,0xA6
    01430 4FFF      SBCI	R31,0xFF
    01431 8060      LD	R6,Z
    01432 55EA      SUBI	R30,0x5A
    01433 40F0      SBCI	R31,0
    01434 2477      CLR	R7
    01435 2488      CLR	R8
    01436 2499      CLR	R9
    01437 2826      OR	R2,R6
    01438 2837      OR	R3,R7
    01439 2848      OR	R4,R8
    0143A 2859      OR	R5,R9
    0143B A222      STD	Z+34,R2
    0143C A233      STD	Z+35,R3
    0143D A244      STD	Z+36,R4
    0143E A255      STD	Z+37,R5
(2122) 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    0143F E082      LDI	R24,2
    01440 E090      LDI	R25,0
    01441 9676      ADIW	R30,0x16
    01442 8100      LD	R16,Z
    01443 8111      LDD	R17,Z+1
    01444 8122      LDD	R18,Z+2
    01445 8133      LDD	R19,Z+3
    01446 938A      ST	-Y,R24
    01447 940E 3CF7 CALL	lsl32
    01449 8F09      STD	Y+25,R16
    0144A 8F1A      STD	Y+26,R17
    0144B 8F2B      STD	Y+27,R18
    0144C 8F3C      STD	Y+28,R19
(2123) 	} else {
    0144D C06A      RJMP	0x14B8
(2124) 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    0144E A1ED      LDD	R30,Y+37
    0144F A1FE      LDD	R31,Y+38
    01450 8420      LDD	R2,Z+8
    01451 8431      LDD	R3,Z+9
    01452 2022      TST	R2
    01453 F421      BNE	0x1458
    01454 2033      TST	R3
    01455 F411      BNE	0x1458
    01456 E00D      LDI	R16,0xD
    01457 C1E8      RJMP	0x1640
(2125) 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    01458 802D      LDD	R2,Y+5
    01459 803E      LDD	R3,Y+6
    0145A 804F      LDD	R4,Y+7
    0145B 8458      LDD	R5,Y+8
    0145C A1ED      LDD	R30,Y+37
    0145D A1FE      LDD	R31,Y+38
    0145E 8C66      LDD	R6,Z+30
    0145F 8C77      LDD	R7,Z+31
    01460 A080      LDD	R8,Z+32
    01461 A091      LDD	R9,Z+33
    01462 0C62      ADD	R6,R2
    01463 1C73      ADC	R7,R3
    01464 1C84      ADC	R8,R4
    01465 1C95      ADC	R9,R5
    01466 A262      STD	Z+34,R6
    01467 A273      STD	Z+35,R7
    01468 A284      STD	Z+36,R8
    01469 A295      STD	Z+37,R9
(2126) 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    0146A 2D8C      MOV	R24,R12
    0146B 3082      CPI	R24,2
    0146C F471      BNE	0x147B
    0146D 9676      ADIW	R30,0x16
    0146E 8020      LD	R2,Z
    0146F 8031      LDD	R3,Z+1
    01470 8042      LDD	R4,Z+2
    01471 8053      LDD	R5,Z+3
    01472 0C22      LSL	R2
    01473 1C33      ROL	R3
    01474 1C44      ROL	R4
    01475 1C55      ROL	R5
    01476 8E2D      STD	Y+29,R2
    01477 8E3E      STD	Y+30,R3
    01478 8E4F      STD	Y+31,R4
    01479 A258      STD	Y+32,R5
    0147A C035      RJMP	0x14B0
    0147B A1ED      LDD	R30,Y+37
    0147C A1FE      LDD	R31,Y+38
    0147D 9676      ADIW	R30,0x16
    0147E 8020      LD	R2,Z
    0147F 8031      LDD	R3,Z+1
    01480 8042      LDD	R4,Z+2
    01481 8053      LDD	R5,Z+3
    01482 A229      STD	Y+33,R2
    01483 A23A      STD	Y+34,R3
    01484 A24B      STD	Y+35,R4
    01485 A25C      STD	Y+36,R5
    01486 E041      LDI	R20,1
    01487 E050      LDI	R21,0
    01488 E060      LDI	R22,0
    01489 E070      LDI	R23,0
    0148A A029      LDD	R2,Y+33
    0148B A03A      LDD	R3,Y+34
    0148C A04B      LDD	R4,Y+35
    0148D A05C      LDD	R5,Y+36
    0148E 2224      AND	R2,R20
    0148F 2235      AND	R3,R21
    01490 2246      AND	R4,R22
    01491 2257      AND	R5,R23
    01492 A069      LDD	R6,Y+33
    01493 A07A      LDD	R7,Y+34
    01494 A08B      LDD	R8,Y+35
    01495 A09C      LDD	R9,Y+36
    01496 E043      LDI	R20,3
    01497 E050      LDI	R21,0
    01498 E060      LDI	R22,0
    01499 E070      LDI	R23,0
    0149A 929A      ST	-Y,R9
    0149B 928A      ST	-Y,R8
    0149C 927A      ST	-Y,R7
    0149D 926A      ST	-Y,R6
    0149E 018A      MOVW	R16,R20
    0149F 019B      MOVW	R18,R22
    014A0 940E 3C21 CALL	empy32s|empy32u
    014A2 0138      MOVW	R6,R16
    014A3 0149      MOVW	R8,R18
    014A4 9496      LSR	R9
    014A5 9487      ROR	R8
    014A6 9477      ROR	R7
    014A7 9467      ROR	R6
    014A8 0C62      ADD	R6,R2
    014A9 1C73      ADC	R7,R3
    014AA 1C84      ADC	R8,R4
    014AB 1C95      ADC	R9,R5
    014AC 8E6D      STD	Y+29,R6
    014AD 8E7E      STD	Y+30,R7
    014AE 8E8F      STD	Y+31,R8
    014AF A298      STD	Y+32,R9
    014B0 8C2D      LDD	R2,Y+29
    014B1 8C3E      LDD	R3,Y+30
    014B2 8C4F      LDD	R4,Y+31
    014B3 A058      LDD	R5,Y+32
    014B4 8E29      STD	Y+25,R2
    014B5 8E3A      STD	Y+26,R3
    014B6 8E4B      STD	Y+27,R4
    014B7 8E5C      STD	Y+28,R5
(2127) 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
(2128) 	}
(2129) 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    014B8 EF4F      LDI	R20,0xFF
    014B9 E051      LDI	R21,1
    014BA E060      LDI	R22,0
    014BB E070      LDI	R23,0
    014BC 8D09      LDD	R16,Y+25
    014BD 8D1A      LDD	R17,Y+26
    014BE 8D2B      LDD	R18,Y+27
    014BF 8D3C      LDD	R19,Y+28
    014C0 0F04      ADD	R16,R20
    014C1 1F15      ADC	R17,R21
    014C2 1F26      ADC	R18,R22
    014C3 1F37      ADC	R19,R23
    014C4 E089      LDI	R24,0x9
    014C5 E090      LDI	R25,0
    014C6 938A      ST	-Y,R24
    014C7 940E 3D10 CALL	lsr32
    014C9 A1ED      LDD	R30,Y+37
    014CA A1FE      LDD	R31,Y+38
    014CB 8C22      LDD	R2,Z+26
    014CC 8C33      LDD	R3,Z+27
    014CD 8C44      LDD	R4,Z+28
    014CE 8C55      LDD	R5,Z+29
    014CF 1620      CP	R2,R16
    014D0 0631      CPC	R3,R17
    014D1 0642      CPC	R4,R18
    014D2 0653      CPC	R5,R19
    014D3 F410      BCC	0x14D6
(2130) 		return FR_NO_FILESYSTEM;
    014D4 E00D      LDI	R16,0xD
    014D5 C16A      RJMP	0x1640
(2131) 
(2132) #if !_FS_READONLY
(2133) 	/* Initialize cluster allocation information */
(2134) 	fs->free_clust = 0xFFFFFFFF;
    014D6 A1ED      LDD	R30,Y+37
    014D7 A1FE      LDD	R31,Y+38
    014D8 963E      ADIW	R30,0xE
    014D9 EF8F      LDI	R24,0xFF
    014DA 8380      ST	Z,R24
    014DB 8381      STD	Z+1,R24
    014DC 8382      STD	Z+2,R24
    014DD 8383      STD	Z+3,R24
(2135) 	fs->last_clust = 0;
    014DE A1ED      LDD	R30,Y+37
    014DF A1FE      LDD	R31,Y+38
    014E0 963A      ADIW	R30,0xA
    014E1 E080      LDI	R24,0
    014E2 8380      ST	Z,R24
    014E3 8381      STD	Z+1,R24
    014E4 8382      STD	Z+2,R24
    014E5 8383      STD	Z+3,R24
(2136) 
(2137) 	/* Get fsinfo if available */
(2138) 	if (fmt == FS_FAT32) {
    014E6 2D8C      MOV	R24,R12
    014E7 3083      CPI	R24,3
    014E8 F009      BEQ	0x14EA
    014E9 C13C      RJMP	0x1626
(2139) 	 	fs->fsi_flag = 0;
    014EA 2422      CLR	R2
    014EB A1ED      LDD	R30,Y+37
    014EC A1FE      LDD	R31,Y+38
    014ED 8225      STD	Z+5,R2
(2140) 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    014EE 5AE2      SUBI	R30,0xA2
    014EF 4FFF      SBCI	R31,0xFF
    014F0 8020      LD	R2,Z
    014F1 55EE      SUBI	R30,0x5E
    014F2 40F0      SBCI	R31,0
    014F3 2433      CLR	R3
    014F4 5AE1      SUBI	R30,0xA1
    014F5 4FFF      SBCI	R31,0xFF
    014F6 8040      LD	R4,Z
    014F7 2455      CLR	R5
    014F8 2C54      MOV	R5,R4
    014F9 2444      CLR	R4
    014FA 2842      OR	R4,R2
    014FB 2853      OR	R5,R3
    014FC 0112      MOVW	R2,R4
    014FD 2444      CLR	R4
    014FE 2455      CLR	R5
    014FF 8869      LDD	R6,Y+17
    01500 887A      LDD	R7,Y+18
    01501 888B      LDD	R8,Y+19
    01502 889C      LDD	R9,Y+20
    01503 0C62      ADD	R6,R2
    01504 1C73      ADC	R7,R3
    01505 1C84      ADC	R8,R4
    01506 1C95      ADC	R9,R5
    01507 A1ED      LDD	R30,Y+37
    01508 A1FE      LDD	R31,Y+38
    01509 8A62      STD	Z+18,R6
    0150A 8A73      STD	Z+19,R7
    0150B 8A84      STD	Z+20,R8
    0150C 8A95      STD	Z+21,R9
(2141) 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    0150D E081      LDI	R24,1
    0150E 838C      STD	Y+4,R24
    0150F 8822      LDD	R2,Z+18
    01510 8833      LDD	R3,Z+19
    01511 8844      LDD	R4,Z+20
    01512 8855      LDD	R5,Z+21
    01513 8228      ST	Y,R2
    01514 8239      STD	Y+1,R3
    01515 824A      STD	Y+2,R4
    01516 825B      STD	Y+3,R5
    01517 019F      MOVW	R18,R30
    01518 5D22      SUBI	R18,0xD2
    01519 4F3F      SBCI	R19,0xFF
    0151A 8101      LDD	R16,Z+1
    0151B 940E 0292 CALL	_disk_read
    0151D 2EE0      MOV	R14,R16
    0151E 2300      TST	R16
    0151F F009      BEQ	0x1521
    01520 C105      RJMP	0x1626
    01521 A1ED      LDD	R30,Y+37
    01522 A1FE      LDD	R31,Y+38
    01523 5DE4      SUBI	R30,0xD4
    01524 4FFD      SBCI	R31,0xFD
    01525 8020      LD	R2,Z
    01526 52EC      SUBI	R30,0x2C
    01527 40F2      SBCI	R31,2
    01528 2433      CLR	R3
    01529 5DE3      SUBI	R30,0xD3
    0152A 4FFD      SBCI	R31,0xFD
    0152B 8180      LD	R24,Z
    0152C 52ED      SUBI	R30,0x2D
    0152D 40F2      SBCI	R31,2
    0152E 2799      CLR	R25
    0152F 2F98      MOV	R25,R24
    01530 2788      CLR	R24
    01531 2982      OR	R24,R2
    01532 2993      OR	R25,R3
    01533 3585      CPI	R24,0x55
    01534 EAAA      LDI	R26,0xAA
    01535 079A      CPC	R25,R26
    01536 F009      BEQ	0x1538
    01537 C0EE      RJMP	0x1626
    01538 E188      LDI	R24,0x18
    01539 E090      LDI	R25,0
    0153A A901      LDD	R16,Z+49
    0153B 2711      CLR	R17
    0153C 2722      CLR	R18
    0153D 2733      CLR	R19
    0153E 938A      ST	-Y,R24
    0153F 940E 3CF7 CALL	lsl32
    01541 0118      MOVW	R2,R16
    01542 0129      MOVW	R4,R18
    01543 A1ED      LDD	R30,Y+37
    01544 A1FE      LDD	R31,Y+38
    01545 A860      LDD	R6,Z+48
    01546 2477      CLR	R7
    01547 2488      CLR	R8
    01548 2499      CLR	R9
    01549 0143      MOVW	R8,R6
    0154A 2466      CLR	R6
    0154B 2477      CLR	R7
    0154C 2826      OR	R2,R6
    0154D 2837      OR	R3,R7
    0154E 2848      OR	R4,R8
    0154F 2859      OR	R5,R9
    01550 A467      LDD	R6,Z+47
    01551 2477      CLR	R7
    01552 2C76      MOV	R7,R6
    01553 2466      CLR	R6
    01554 2488      CLR	R8
    01555 2499      CLR	R9
    01556 2826      OR	R2,R6
    01557 2837      OR	R3,R7
    01558 2848      OR	R4,R8
    01559 2859      OR	R5,R9
    0155A A466      LDD	R6,Z+46
    0155B 2477      CLR	R7
    0155C 2488      CLR	R8
    0155D 2499      CLR	R9
    0155E 2826      OR	R2,R6
    0155F 2837      OR	R3,R7
    01560 2848      OR	R4,R8
    01561 2859      OR	R5,R9
    01562 E542      LDI	R20,0x52
    01563 E552      LDI	R21,0x52
    01564 E661      LDI	R22,0x61
    01565 E471      LDI	R23,0x41
    01566 1624      CP	R2,R20
    01567 0635      CPC	R3,R21
    01568 0646      CPC	R4,R22
    01569 0657      CPC	R5,R23
    0156A F009      BEQ	0x156C
    0156B C0BA      RJMP	0x1626
    0156C E188      LDI	R24,0x18
    0156D E090      LDI	R25,0
    0156E 5EEB      SUBI	R30,0xEB
    0156F 4FFD      SBCI	R31,0xFD
    01570 8100      LD	R16,Z
    01571 2711      CLR	R17
    01572 2722      CLR	R18
    01573 2733      CLR	R19
    01574 938A      ST	-Y,R24
    01575 940E 3CF7 CALL	lsl32
    01577 0118      MOVW	R2,R16
    01578 0129      MOVW	R4,R18
    01579 A1ED      LDD	R30,Y+37
    0157A A1FE      LDD	R31,Y+38
    0157B 5EEC      SUBI	R30,0xEC
    0157C 4FFD      SBCI	R31,0xFD
    0157D 8060      LD	R6,Z
    0157E 51E4      SUBI	R30,0x14
    0157F 40F2      SBCI	R31,2
    01580 2477      CLR	R7
    01581 2488      CLR	R8
    01582 2499      CLR	R9
    01583 0143      MOVW	R8,R6
    01584 2466      CLR	R6
    01585 2477      CLR	R7
    01586 2826      OR	R2,R6
    01587 2837      OR	R3,R7
    01588 2848      OR	R4,R8
    01589 2859      OR	R5,R9
    0158A 5EED      SUBI	R30,0xED
    0158B 4FFD      SBCI	R31,0xFD
    0158C 8060      LD	R6,Z
    0158D 51E3      SUBI	R30,0x13
    0158E 40F2      SBCI	R31,2
    0158F 2477      CLR	R7
    01590 2C76      MOV	R7,R6
    01591 2466      CLR	R6
    01592 2488      CLR	R8
    01593 2499      CLR	R9
    01594 2826      OR	R2,R6
    01595 2837      OR	R3,R7
    01596 2848      OR	R4,R8
    01597 2859      OR	R5,R9
    01598 5EEE      SUBI	R30,0xEE
    01599 4FFD      SBCI	R31,0xFD
    0159A 8060      LD	R6,Z
    0159B 51E2      SUBI	R30,0x12
    0159C 40F2      SBCI	R31,2
    0159D 2477      CLR	R7
    0159E 2488      CLR	R8
    0159F 2499      CLR	R9
    015A0 2826      OR	R2,R6
    015A1 2837      OR	R3,R7
    015A2 2848      OR	R4,R8
    015A3 2859      OR	R5,R9
    015A4 E742      LDI	R20,0x72
    015A5 E752      LDI	R21,0x72
    015A6 E461      LDI	R22,0x41
    015A7 E671      LDI	R23,0x61
    015A8 1624      CP	R2,R20
    015A9 0635      CPC	R3,R21
    015AA 0646      CPC	R4,R22
    015AB 0657      CPC	R5,R23
    015AC F009      BEQ	0x15AE
    015AD C078      RJMP	0x1626
(2142) 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
(2143) 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
(2144) 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
(2145) 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    015AE E188      LDI	R24,0x18
    015AF E090      LDI	R25,0
    015B0 5EE3      SUBI	R30,0xE3
    015B1 4FFD      SBCI	R31,0xFD
    015B2 8100      LD	R16,Z
    015B3 2711      CLR	R17
    015B4 2722      CLR	R18
    015B5 2733      CLR	R19
    015B6 938A      ST	-Y,R24
    015B7 940E 3CF7 CALL	lsl32
    015B9 0118      MOVW	R2,R16
    015BA 0129      MOVW	R4,R18
    015BB A1ED      LDD	R30,Y+37
    015BC A1FE      LDD	R31,Y+38
    015BD 5EE4      SUBI	R30,0xE4
    015BE 4FFD      SBCI	R31,0xFD
    015BF 8060      LD	R6,Z
    015C0 51EC      SUBI	R30,0x1C
    015C1 40F2      SBCI	R31,2
    015C2 2477      CLR	R7
    015C3 2488      CLR	R8
    015C4 2499      CLR	R9
    015C5 0143      MOVW	R8,R6
    015C6 2466      CLR	R6
    015C7 2477      CLR	R7
    015C8 2826      OR	R2,R6
    015C9 2837      OR	R3,R7
    015CA 2848      OR	R4,R8
    015CB 2859      OR	R5,R9
    015CC 5EE5      SUBI	R30,0xE5
    015CD 4FFD      SBCI	R31,0xFD
    015CE 8060      LD	R6,Z
    015CF 51EB      SUBI	R30,0x1B
    015D0 40F2      SBCI	R31,2
    015D1 2477      CLR	R7
    015D2 2C76      MOV	R7,R6
    015D3 2466      CLR	R6
    015D4 2488      CLR	R8
    015D5 2499      CLR	R9
    015D6 2826      OR	R2,R6
    015D7 2837      OR	R3,R7
    015D8 2848      OR	R4,R8
    015D9 2859      OR	R5,R9
    015DA 5EE6      SUBI	R30,0xE6
    015DB 4FFD      SBCI	R31,0xFD
    015DC 8060      LD	R6,Z
    015DD 51EA      SUBI	R30,0x1A
    015DE 40F2      SBCI	R31,2
    015DF 2477      CLR	R7
    015E0 2488      CLR	R8
    015E1 2499      CLR	R9
    015E2 2826      OR	R2,R6
    015E3 2837      OR	R3,R7
    015E4 2848      OR	R4,R8
    015E5 2859      OR	R5,R9
    015E6 8622      STD	Z+10,R2
    015E7 8633      STD	Z+11,R3
    015E8 8644      STD	Z+12,R4
    015E9 8655      STD	Z+13,R5
(2146) 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    015EA E188      LDI	R24,0x18
    015EB E090      LDI	R25,0
    015EC 5EE7      SUBI	R30,0xE7
    015ED 4FFD      SBCI	R31,0xFD
    015EE 8100      LD	R16,Z
    015EF 2711      CLR	R17
    015F0 2722      CLR	R18
    015F1 2733      CLR	R19
    015F2 938A      ST	-Y,R24
    015F3 940E 3CF7 CALL	lsl32
    015F5 0118      MOVW	R2,R16
    015F6 0129      MOVW	R4,R18
    015F7 A1ED      LDD	R30,Y+37
    015F8 A1FE      LDD	R31,Y+38
    015F9 5EE8      SUBI	R30,0xE8
    015FA 4FFD      SBCI	R31,0xFD
    015FB 8060      LD	R6,Z
    015FC 51E8      SUBI	R30,0x18
    015FD 40F2      SBCI	R31,2
    015FE 2477      CLR	R7
    015FF 2488      CLR	R8
    01600 2499      CLR	R9
    01601 0143      MOVW	R8,R6
    01602 2466      CLR	R6
    01603 2477      CLR	R7
    01604 2826      OR	R2,R6
    01605 2837      OR	R3,R7
    01606 2848      OR	R4,R8
    01607 2859      OR	R5,R9
    01608 5EE9      SUBI	R30,0xE9
    01609 4FFD      SBCI	R31,0xFD
    0160A 8060      LD	R6,Z
    0160B 51E7      SUBI	R30,0x17
    0160C 40F2      SBCI	R31,2
    0160D 2477      CLR	R7
    0160E 2C76      MOV	R7,R6
    0160F 2466      CLR	R6
    01610 2488      CLR	R8
    01611 2499      CLR	R9
    01612 2826      OR	R2,R6
    01613 2837      OR	R3,R7
    01614 2848      OR	R4,R8
    01615 2859      OR	R5,R9
    01616 5EEA      SUBI	R30,0xEA
    01617 4FFD      SBCI	R31,0xFD
    01618 8060      LD	R6,Z
    01619 51E6      SUBI	R30,0x16
    0161A 40F2      SBCI	R31,2
    0161B 2477      CLR	R7
    0161C 2488      CLR	R8
    0161D 2499      CLR	R9
    0161E 2826      OR	R2,R6
    0161F 2837      OR	R3,R7
    01620 2848      OR	R4,R8
    01621 2859      OR	R5,R9
    01622 8626      STD	Z+14,R2
    01623 8637      STD	Z+15,R3
    01624 8A40      STD	Z+16,R4
    01625 8A51      STD	Z+17,R5
(2147) 		}
(2148) 	}
(2149) #endif
(2150) 	fs->fs_type = fmt;		/* FAT sub-type */
    01626 A1ED      LDD	R30,Y+37
    01627 A1FE      LDD	R31,Y+38
    01628 82C0      ST	Z,R12
(2151) 	fs->id = ++Fsid;		/* File system mount ID */
    01629 9180 04D6 LDS	R24,ff.c:Fsid
    0162B 9190 04D7 LDS	R25,ff.c:Fsid+1
    0162D 9601      ADIW	R24,1
    0162E 016C      MOVW	R12,R24
    0162F 92D0 04D7 STS	ff.c:Fsid+1,R13
    01631 92C0 04D6 STS	ff.c:Fsid,R12
    01633 82D7      STD	Z+7,R13
    01634 82C6      STD	Z+6,R12
(2152) 	fs->winsect = 0;		/* Invalidate sector cache */
    01635 96BA      ADIW	R30,0x2A
    01636 E080      LDI	R24,0
    01637 8380      ST	Z,R24
    01638 8381      STD	Z+1,R24
    01639 8382      STD	Z+2,R24
    0163A 8383      STD	Z+3,R24
(2153) 	fs->wflag = 0;
    0163B 2422      CLR	R2
    0163C A1ED      LDD	R30,Y+37
    0163D A1FE      LDD	R31,Y+38
    0163E 8224      STD	Z+4,R2
(2154) #if _FS_RPATH
(2155) 	fs->cdir = 0;			/* Current directory (root dir) */
(2156) #endif
(2157) #if _FS_SHARE				/* Clear file lock semaphores */
(2158) 	clear_lock(fs);
(2159) #endif
(2160) 
(2161) 	return FR_OK;
    0163F 2700      CLR	R16
    01640 96A7      ADIW	R28,0x27
    01641 940E 3C6A CALL	pop_xgsetF0FC
    01643 9622      ADIW	R28,2
    01644 9508      RET
ff.c:validate:
  id                   --> R10
  fs                   --> R20
    01645 940E 3C80 CALL	push_xgset300C
    01647 0159      MOVW	R10,R18
    01648 01A8      MOVW	R20,R16
(2162) }
(2163) 
(2164) 
(2165) 
(2166) 
(2167) /*-----------------------------------------------------------------------*/
(2168) /* Check if the file/dir object is valid or not                          */
(2169) /*-----------------------------------------------------------------------*/
(2170) 
(2171) static
(2172) FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
(2173) 	FATFS *fs,		/* Pointer to the file system object */
(2174) 	WORD id			/* Member id of the target object to be checked */
(2175) )
(2176) {
(2177) 	if (!fs || !fs->fs_type || fs->id != id)
    01649 3040      CPI	R20,0
    0164A 0745      CPC	R20,R21
    0164B F049      BEQ	0x1655
    0164C 01FA      MOVW	R30,R20
    0164D 8020      LD	R2,Z
    0164E 2022      TST	R2
    0164F F029      BEQ	0x1655
    01650 8026      LDD	R2,Z+6
    01651 8037      LDD	R3,Z+7
    01652 142A      CP	R2,R10
    01653 043B      CPC	R3,R11
    01654 F011      BEQ	0x1657
(2178) 		return FR_INVALID_OBJECT;
    01655 E009      LDI	R16,0x9
    01656 C009      RJMP	0x1660
(2179) 
(2180) 	ENTER_FF(fs);		/* Lock file system */
(2181) 
(2182) 	if (disk_status(fs->drv) & STA_NOINIT)
    01657 01FA      MOVW	R30,R20
    01658 8101      LDD	R16,Z+1
    01659 940E 028C CALL	_disk_status
    0165B FF00      SBRS	R16,0
    0165C C002      RJMP	0x165F
(2183) 		return FR_NOT_READY;
    0165D E003      LDI	R16,3
    0165E C001      RJMP	0x1660
(2184) 
(2185) 	return FR_OK;
    0165F 2700      CLR	R16
    01660 940C 3C85 JMP	pop_xgset300C
_f_mount:
  rfs                  --> R10
  fs                   --> R18
  vol                  --> R16
    01662 92AA      ST	-Y,R10
    01663 92BA      ST	-Y,R11
(2186) }
(2187) 
(2188) 
(2189) 
(2190) 
(2191) /*--------------------------------------------------------------------------
(2192) 
(2193)    Public Functions
(2194) 
(2195) --------------------------------------------------------------------------*/
(2196) 
(2197) 
(2198) 
(2199) /*-----------------------------------------------------------------------*/
(2200) /* Mount/Unmount a Logical Drive                                         */
(2201) /*-----------------------------------------------------------------------*/
(2202) 
(2203) FRESULT f_mount (
(2204) 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
(2205) 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
(2206) )
(2207) {
(2208) 	FATFS *rfs;
(2209) 
(2210) 
(2211) 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    01664 3001      CPI	R16,1
    01665 F010      BCS	0x1668
(2212) 		return FR_INVALID_DRIVE;
    01666 E00B      LDI	R16,0xB
    01667 C022      RJMP	0x168A
(2213) 	rfs = FatFs[vol];			/* Get current fs object */
    01668 ED88      LDI	R24,0xD8
    01669 E094      LDI	R25,4
    0166A 2FE0      MOV	R30,R16
    0166B 27FF      CLR	R31
    0166C 0FEE      LSL	R30
    0166D 1FFF      ROL	R31
    0166E 0FE8      ADD	R30,R24
    0166F 1FF9      ADC	R31,R25
    01670 80A0      LD	R10,Z
    01671 80B1      LDD	R11,Z+1
(2214) 
(2215) 	if (rfs) {
    01672 20AA      TST	R10
    01673 F411      BNE	0x1676
    01674 20BB      TST	R11
    01675 F019      BEQ	0x1679
(2216) #if _FS_SHARE
(2217) 		clear_lock(rfs);
(2218) #endif
(2219) #if _FS_REENTRANT				/* Discard sync object of the current volume */
(2220) 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
(2221) #endif
(2222) 		rfs->fs_type = 0;		/* Clear old fs object */
    01676 2422      CLR	R2
    01677 01F5      MOVW	R30,R10
    01678 8220      ST	Z,R2
(2223) 	}
(2224) 
(2225) 	if (fs) {
    01679 3020      CPI	R18,0
    0167A 0723      CPC	R18,R19
    0167B F019      BEQ	0x167F
(2226) 		fs->fs_type = 0;		/* Clear new fs object */
    0167C 2422      CLR	R2
    0167D 01F9      MOVW	R30,R18
    0167E 8220      ST	Z,R2
(2227) #if _FS_REENTRANT				/* Create sync object for the new volume */
(2228) 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
(2229) #endif
(2230) 	}
(2231) 	FatFs[vol] = fs;			/* Register new fs object */
    0167F ED88      LDI	R24,0xD8
    01680 E094      LDI	R25,4
    01681 2FE0      MOV	R30,R16
    01682 27FF      CLR	R31
    01683 0FEE      LSL	R30
    01684 1FFF      ROL	R31
    01685 0FE8      ADD	R30,R24
    01686 1FF9      ADC	R31,R25
    01687 8331      STD	Z+1,R19
    01688 8320      ST	Z,R18
(2232) 
(2233) 	return FR_OK;
    01689 2700      CLR	R16
    0168A 90B9      LD	R11,Y+
    0168B 90A9      LD	R10,Y+
    0168C 9508      RET
_f_open:
  cl                   --> Y,+40
  dw                   --> Y,+36
  sfn                  --> Y,+24
  dj                   --> Y,+2
  res                  --> R10
  dir                  --> R14
  mode                 --> Y,+58
  path                 --> Y,+56
  fp                   --> Y,+54
    0168D 940E 3B30 CALL	push_arg4
    0168F 940E 3C75 CALL	push_xgsetF0FC
    01691 97AC      SBIW	R28,0x2C
(2234) }
(2235) 
(2236) 
(2237) 
(2238) 
(2239) /*-----------------------------------------------------------------------*/
(2240) /* Open or Create a File                                                 */
(2241) /*-----------------------------------------------------------------------*/
(2242) 
(2243) FRESULT f_open (
(2244) 	FIL *fp,			/* Pointer to the blank file object */
(2245) 	const TCHAR *path,	/* Pointer to the file name */
(2246) 	BYTE mode			/* Access mode and file open mode flags */
(2247) )
(2248) {
(2249) 	FRESULT res;
(2250) 	DIR dj;
(2251) 	BYTE *dir;
(2252) 	DEF_NAMEBUF;
(2253) 
(2254) 
(2255) 	fp->fs = 0;			/* Clear file object */
    01692 2422      CLR	R2
    01693 2433      CLR	R3
    01694 A9EE      LDD	R30,Y+54
    01695 A9FF      LDD	R31,Y+55
    01696 8231      STD	Z+1,R3
    01697 8220      ST	Z,R2
(2256) 
(2257) #if !_FS_READONLY
(2258) 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    01698 AD8A      LDD	R24,Y+58
    01699 718F      ANDI	R24,0x1F
    0169A AF8A      STD	Y+58,R24
(2259) 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    0169B 2799      CLR	R25
    0169C 7F8E      ANDI	R24,0xFE
    0169D 8388      ST	Y,R24
    0169E 019E      MOVW	R18,R28
    0169F 5F2E      SUBI	R18,0xFE
    016A0 4F3F      SBCI	R19,0xFF
    016A1 018E      MOVW	R16,R28
    016A2 5C08      SUBI	R16,0xC8
    016A3 4F1F      SBCI	R17,0xFF
    016A4 DAA6      RCALL	ff.c:chk_mounted
    016A5 2EA0      MOV	R10,R16
(2260) #else
(2261) 	mode &= FA_READ;
(2262) 	res = chk_mounted(&path, &dj.fs, 0);
(2263) #endif
(2264) 	INIT_BUF(dj);
    016A6 01CE      MOVW	R24,R28
    016A7 9648      ADIW	R24,0x18
    016A8 8B9F      STD	Y+23,R25
    016A9 8B8E      STD	Y+22,R24
(2265) 	if (res == FR_OK)
    016AA 2300      TST	R16
    016AB F439      BNE	0x16B3
(2266) 		res = follow_path(&dj, path);	/* Follow the file path */
    016AC AD28      LDD	R18,Y+56
    016AD AD39      LDD	R19,Y+57
    016AE 018E      MOVW	R16,R28
    016AF 5F0E      SUBI	R16,0xFE
    016B0 4F1F      SBCI	R17,0xFF
    016B1 D94D      RCALL	ff.c:follow_path
    016B2 2EA0      MOV	R10,R16
(2267) 	dir = dj.dir;
    016B3 88EC      LDD	R14,Y+20
    016B4 88FD      LDD	R15,Y+21
(2268) 
(2269) #if !_FS_READONLY	/* R/W configuration */
(2270) 	if (res == FR_OK) {
    016B5 20AA      TST	R10
    016B6 F431      BNE	0x16BD
(2271) 		if (!dir)	/* Current dir itself */
    016B7 20EE      TST	R14
    016B8 F421      BNE	0x16BD
    016B9 20FF      TST	R15
    016BA F411      BNE	0x16BD
(2272) 			res = FR_INVALID_NAME;
    016BB E086      LDI	R24,6
    016BC 2EA8      MOV	R10,R24
(2273) #if _FS_SHARE
(2274) 		else
(2275) 			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2276) #endif
(2277) 	}
(2278) 	/* Create or Open a file */
(2279) 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    016BD AD8A      LDD	R24,Y+58
    016BE 718C      ANDI	R24,0x1C
    016BF F409      BNE	0x16C1
    016C0 C0C0      RJMP	0x1781
(2280) 		DWORD dw, cl;
(2281) 
(2282) 		if (res != FR_OK) {					/* No file, create new */
    016C1 20AA      TST	R10
    016C2 F081      BEQ	0x16D3
(2283) 			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    016C3 2D8A      MOV	R24,R10
    016C4 3084      CPI	R24,4
    016C5 F439      BNE	0x16CD
(2284) #if _FS_SHARE
(2285) 				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
(2286) #else
(2287) 				res = dir_register(&dj);
    016C6 018E      MOVW	R16,R28
    016C7 5F0E      SUBI	R16,0xFE
    016C8 4F1F      SBCI	R17,0xFF
    016C9 940E 0DF1 CALL	ff.c:dir_register
    016CB 2EC0      MOV	R12,R16
    016CC 2CAC      MOV	R10,R12
(2288) #endif
(2289) 			mode |= FA_CREATE_ALWAYS;		/* File is created */
    016CD AD8A      LDD	R24,Y+58
    016CE 6088      ORI	R24,0x8
    016CF AF8A      STD	Y+58,R24
(2290) 			dir = dj.dir;					/* New entry */
    016D0 88EC      LDD	R14,Y+20
    016D1 88FD      LDD	R15,Y+21
(2291) 		}
    016D2 C00C      RJMP	0x16DF
(2292) 		else {								/* Any object is already existing */
(2293) 			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    016D3 01F7      MOVW	R30,R14
    016D4 8583      LDD	R24,Z+11
    016D5 7181      ANDI	R24,0x11
    016D6 F019      BEQ	0x16DA
(2294) 				res = FR_DENIED;
    016D7 E087      LDI	R24,7
    016D8 2EA8      MOV	R10,R24
(2295) 			} else {
    016D9 C005      RJMP	0x16DF
(2296) 				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    016DA AC0A      LDD	R0,Y+58
    016DB FE02      SBRS	R0,2
    016DC C002      RJMP	0x16DF
(2297) 					res = FR_EXIST;
    016DD E088      LDI	R24,0x8
    016DE 2EA8      MOV	R10,R24
(2298) 			}
(2299) 		}
(2300) 		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    016DF 20AA      TST	R10
    016E0 F009      BEQ	0x16E2
    016E1 C0B1      RJMP	0x1793
    016E2 AC0A      LDD	R0,Y+58
    016E3 FE03      SBRS	R0,3
    016E4 C0AE      RJMP	0x1793
(2301) 			dw = get_fattime();					/* Created time */
    016E5 940E 02CF CALL	_get_fattime
    016E7 A30C      STD	Y+36,R16
    016E8 A31D      STD	Y+37,R17
    016E9 A32E      STD	Y+38,R18
    016EA A33F      STD	Y+39,R19
(2302) 			ST_DWORD(dir+DIR_CrtTime, dw);
    016EB A02C      LDD	R2,Y+36
    016EC A03D      LDD	R3,Y+37
    016ED A04E      LDD	R4,Y+38
    016EE A05F      LDD	R5,Y+39
    016EF 01F7      MOVW	R30,R14
    016F0 8626      STD	Z+14,R2
    016F1 2C23      MOV	R2,R3
    016F2 2433      CLR	R3
    016F3 963F      ADIW	R30,0xF
    016F4 8220      ST	Z,R2
    016F5 A02C      LDD	R2,Y+36
    016F6 A03D      LDD	R3,Y+37
    016F7 A04E      LDD	R4,Y+38
    016F8 A05F      LDD	R5,Y+39
    016F9 0112      MOVW	R2,R4
    016FA 2444      CLR	R4
    016FB 2455      CLR	R5
    016FC 01F7      MOVW	R30,R14
    016FD 9670      ADIW	R30,0x10
    016FE 8220      ST	Z,R2
    016FF E188      LDI	R24,0x18
    01700 E090      LDI	R25,0
    01701 A10C      LDD	R16,Y+36
    01702 A11D      LDD	R17,Y+37
    01703 A12E      LDD	R18,Y+38
    01704 A13F      LDD	R19,Y+39
    01705 938A      ST	-Y,R24
    01706 940E 3D10 CALL	lsr32
    01708 01F7      MOVW	R30,R14
    01709 8B01      STD	Z+17,R16
(2303) 			dir[DIR_Attr] = 0;					/* Reset attribute */
    0170A 2422      CLR	R2
    0170B 8623      STD	Z+11,R2
(2304) 			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    0170C 8E24      STD	Z+28,R2
    0170D 8E25      STD	Z+29,R2
    0170E 8E26      STD	Z+30,R2
    0170F 8E27      STD	Z+31,R2
(2305) 			cl = LD_CLUST(dir);					/* Get start cluster */
    01710 8C22      LDD	R2,Z+26
    01711 2433      CLR	R3
    01712 8C43      LDD	R4,Z+27
    01713 2455      CLR	R5
    01714 2C54      MOV	R5,R4
    01715 2444      CLR	R4
    01716 2842      OR	R4,R2
    01717 2853      OR	R5,R3
    01718 0112      MOVW	R2,R4
    01719 2444      CLR	R4
    0171A 2455      CLR	R5
    0171B 8864      LDD	R6,Z+20
    0171C 2477      CLR	R7
    0171D 9675      ADIW	R30,0x15
    0171E 8080      LD	R8,Z
    0171F 2499      CLR	R9
    01720 2C98      MOV	R9,R8
    01721 2488      CLR	R8
    01722 2886      OR	R8,R6
    01723 2897      OR	R9,R7
    01724 0134      MOVW	R6,R8
    01725 2488      CLR	R8
    01726 2499      CLR	R9
    01727 0143      MOVW	R8,R6
    01728 2466      CLR	R6
    01729 2477      CLR	R7
    0172A 2862      OR	R6,R2
    0172B 2873      OR	R7,R3
    0172C 2884      OR	R8,R4
    0172D 2895      OR	R9,R5
    0172E A668      STD	Y+40,R6
    0172F A679      STD	Y+41,R7
    01730 A68A      STD	Y+42,R8
    01731 A69B      STD	Y+43,R9
(2306) 			ST_CLUST(dir, 0);					/* cluster = 0 */
    01732 2422      CLR	R2
    01733 01F7      MOVW	R30,R14
    01734 8E22      STD	Z+26,R2
    01735 8E23      STD	Z+27,R2
    01736 8A24      STD	Z+20,R2
    01737 8A25      STD	Z+21,R2
(2307) 			dj.fs->wflag = 1;
    01738 E081      LDI	R24,1
    01739 81EA      LDD	R30,Y+2
    0173A 81FB      LDD	R31,Y+3
    0173B 9634      ADIW	R30,4
    0173C 8380      ST	Z,R24
(2308) 			if (cl) {							/* Remove the cluster chain if exist */
    0173D A428      LDD	R2,Y+40
    0173E A439      LDD	R3,Y+41
    0173F A44A      LDD	R4,Y+42
    01740 A45B      LDD	R5,Y+43
    01741 9488      BCLR	0
    01742 2022      TST	R2
    01743 0432      CPC	R3,R2
    01744 0442      CPC	R4,R2
    01745 0452      CPC	R5,R2
    01746 F409      BNE	0x1748
    01747 C04B      RJMP	0x1793
(2309) 				dw = dj.fs->winsect;
    01748 81EA      LDD	R30,Y+2
    01749 81FB      LDD	R31,Y+3
    0174A A422      LDD	R2,Z+42
    0174B A433      LDD	R3,Z+43
    0174C A444      LDD	R4,Z+44
    0174D A455      LDD	R5,Z+45
    0174E A22C      STD	Y+36,R2
    0174F A23D      STD	Y+37,R3
    01750 A24E      STD	Y+38,R4
    01751 A25F      STD	Y+39,R5
(2310) 				res = remove_chain(dj.fs, cl);
    01752 A428      LDD	R2,Y+40
    01753 A439      LDD	R3,Y+41
    01754 A44A      LDD	R4,Y+42
    01755 A45B      LDD	R5,Y+43
    01756 8248      ST	Y,R4
    01757 8259      STD	Y+1,R5
    01758 0191      MOVW	R18,R2
    01759 810A      LDD	R16,Y+2
    0175A 811B      LDD	R17,Y+3
    0175B 940E 0805 CALL	ff.c:remove_chain
    0175D 2EC0      MOV	R12,R16
    0175E 2CAC      MOV	R10,R12
(2311) 				if (res == FR_OK) {
    0175F 2300      TST	R16
    01760 F591      BNE	0x1793
(2312) 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    01761 E041      LDI	R20,1
    01762 E050      LDI	R21,0
    01763 E060      LDI	R22,0
    01764 E070      LDI	R23,0
    01765 A428      LDD	R2,Y+40
    01766 A439      LDD	R3,Y+41
    01767 A44A      LDD	R4,Y+42
    01768 A45B      LDD	R5,Y+43
    01769 1A24      SUB	R2,R20
    0176A 0A35      SBC	R3,R21
    0176B 0A46      SBC	R4,R22
    0176C 0A57      SBC	R5,R23
    0176D 81EA      LDD	R30,Y+2
    0176E 81FB      LDD	R31,Y+3
    0176F 8622      STD	Z+10,R2
    01770 8633      STD	Z+11,R3
    01771 8644      STD	Z+12,R4
    01772 8655      STD	Z+13,R5
(2313) 					res = move_window(dj.fs, dw);
    01773 A02C      LDD	R2,Y+36
    01774 A03D      LDD	R3,Y+37
    01775 A04E      LDD	R4,Y+38
    01776 A05F      LDD	R5,Y+39
    01777 8248      ST	Y,R4
    01778 8259      STD	Y+1,R5
    01779 0191      MOVW	R18,R2
    0177A 810A      LDD	R16,Y+2
    0177B 811B      LDD	R17,Y+3
    0177C 940E 032D CALL	ff.c:move_window
    0177E 2EC0      MOV	R12,R16
    0177F 2CAC      MOV	R10,R12
(2314) 				}
(2315) 			}
(2316) 		}
(2317) 	}
    01780 C012      RJMP	0x1793
(2318) 	else {	/* Open an existing file */
(2319) 		if (res == FR_OK) {						/* Follow succeeded */
    01781 20AA      TST	R10
    01782 F481      BNE	0x1793
(2320) 			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    01783 01F7      MOVW	R30,R14
    01784 8423      LDD	R2,Z+11
    01785 FE24      SBRS	R2,4
    01786 C003      RJMP	0x178A
(2321) 				res = FR_NO_FILE;
    01787 E084      LDI	R24,4
    01788 2EA8      MOV	R10,R24
(2322) 			} else {
    01789 C009      RJMP	0x1793
(2323) 				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    0178A AC0A      LDD	R0,Y+58
    0178B FE01      SBRS	R0,1
    0178C C006      RJMP	0x1793
    0178D 01F7      MOVW	R30,R14
    0178E 8423      LDD	R2,Z+11
    0178F FE20      SBRS	R2,0
    01790 C002      RJMP	0x1793
(2324) 					res = FR_DENIED;
    01791 E087      LDI	R24,7
    01792 2EA8      MOV	R10,R24
(2325) 			}
(2326) 		}
(2327) 	}
(2328) 	if (res == FR_OK) {
    01793 20AA      TST	R10
    01794 F4A1      BNE	0x17A9
(2329) 		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    01795 AC0A      LDD	R0,Y+58
    01796 FE03      SBRS	R0,3
    01797 C003      RJMP	0x179B
(2330) 			mode |= FA__WRITTEN;
    01798 2D80      MOV	R24,R0
    01799 6280      ORI	R24,0x20
    0179A AF8A      STD	Y+58,R24
(2331) 		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    0179B 81EA      LDD	R30,Y+2
    0179C 81FB      LDD	R31,Y+3
    0179D A422      LDD	R2,Z+42
    0179E A433      LDD	R3,Z+43
    0179F A444      LDD	R4,Z+44
    017A0 A455      LDD	R5,Z+45
    017A1 A9EE      LDD	R30,Y+54
    017A2 A9FF      LDD	R31,Y+55
    017A3 8E22      STD	Z+26,R2
    017A4 8E33      STD	Z+27,R3
    017A5 8E44      STD	Z+28,R4
    017A6 8E55      STD	Z+29,R5
(2332) 		fp->dir_ptr = dir;
    017A7 8EF7      STD	Z+31,R15
    017A8 8EE6      STD	Z+30,R14
(2333) #if _FS_SHARE
(2334) 		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2335) 		if (!fp->lockid) res = FR_INT_ERR;
(2336) #endif
(2337) 	}
(2338) 
(2339) #else				/* R/O configuration */
(2340) 	if (res == FR_OK) {					/* Follow succeeded */
(2341) 		if (!dir) {						/* Current dir itself */
(2342) 			res = FR_INVALID_NAME;
(2343) 		} else {
(2344) 			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
(2345) 				res = FR_NO_FILE;
(2346) 		}
(2347) 	}
(2348) #endif
(2349) 	FREE_BUF();
(2350) 
(2351) 	if (res == FR_OK) {
    017A9 20AA      TST	R10
    017AA F009      BEQ	0x17AC
    017AB C077      RJMP	0x1823
(2352) 		fp->flag = mode;					/* File access mode */
    017AC A9EE      LDD	R30,Y+54
    017AD A9FF      LDD	R31,Y+55
    017AE AC0A      LDD	R0,Y+58
    017AF 8204      STD	Z+4,R0
(2353) 		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    017B0 01F7      MOVW	R30,R14
    017B1 8C22      LDD	R2,Z+26
    017B2 2433      CLR	R3
    017B3 8C43      LDD	R4,Z+27
    017B4 2455      CLR	R5
    017B5 2C54      MOV	R5,R4
    017B6 2444      CLR	R4
    017B7 2842      OR	R4,R2
    017B8 2853      OR	R5,R3
    017B9 0112      MOVW	R2,R4
    017BA 2444      CLR	R4
    017BB 2455      CLR	R5
    017BC 8864      LDD	R6,Z+20
    017BD 2477      CLR	R7
    017BE 8885      LDD	R8,Z+21
    017BF 2499      CLR	R9
    017C0 2C98      MOV	R9,R8
    017C1 2488      CLR	R8
    017C2 2886      OR	R8,R6
    017C3 2897      OR	R9,R7
    017C4 0134      MOVW	R6,R8
    017C5 2488      CLR	R8
    017C6 2499      CLR	R9
    017C7 0143      MOVW	R8,R6
    017C8 2466      CLR	R6
    017C9 2477      CLR	R7
    017CA 2862      OR	R6,R2
    017CB 2873      OR	R7,R3
    017CC 2884      OR	R8,R4
    017CD 2895      OR	R9,R5
    017CE A9EE      LDD	R30,Y+54
    017CF A9FF      LDD	R31,Y+55
    017D0 8666      STD	Z+14,R6
    017D1 8677      STD	Z+15,R7
    017D2 8A80      STD	Z+16,R8
    017D3 8A91      STD	Z+17,R9
(2354) 		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    017D4 E188      LDI	R24,0x18
    017D5 E090      LDI	R25,0
    017D6 01F7      MOVW	R30,R14
    017D7 8D07      LDD	R16,Z+31
    017D8 2711      CLR	R17
    017D9 2722      CLR	R18
    017DA 2733      CLR	R19
    017DB 938A      ST	-Y,R24
    017DC 940E 3CF7 CALL	lsl32
    017DE 0118      MOVW	R2,R16
    017DF 0129      MOVW	R4,R18
    017E0 01F7      MOVW	R30,R14
    017E1 8C66      LDD	R6,Z+30
    017E2 2477      CLR	R7
    017E3 2488      CLR	R8
    017E4 2499      CLR	R9
    017E5 0143      MOVW	R8,R6
    017E6 2466      CLR	R6
    017E7 2477      CLR	R7
    017E8 2826      OR	R2,R6
    017E9 2837      OR	R3,R7
    017EA 2848      OR	R4,R8
    017EB 2859      OR	R5,R9
    017EC 8C65      LDD	R6,Z+29
    017ED 2477      CLR	R7
    017EE 2C76      MOV	R7,R6
    017EF 2466      CLR	R6
    017F0 2488      CLR	R8
    017F1 2499      CLR	R9
    017F2 2826      OR	R2,R6
    017F3 2837      OR	R3,R7
    017F4 2848      OR	R4,R8
    017F5 2859      OR	R5,R9
    017F6 8C64      LDD	R6,Z+28
    017F7 2477      CLR	R7
    017F8 2488      CLR	R8
    017F9 2499      CLR	R9
    017FA 2826      OR	R2,R6
    017FB 2837      OR	R3,R7
    017FC 2848      OR	R4,R8
    017FD 2859      OR	R5,R9
    017FE A9EE      LDD	R30,Y+54
    017FF A9FF      LDD	R31,Y+55
    01800 8622      STD	Z+10,R2
    01801 8633      STD	Z+11,R3
    01802 8644      STD	Z+12,R4
    01803 8655      STD	Z+13,R5
(2355) 		fp->fptr = 0;						/* File pointer */
    01804 9636      ADIW	R30,6
    01805 E080      LDI	R24,0
    01806 8380      ST	Z,R24
    01807 8381      STD	Z+1,R24
    01808 8382      STD	Z+2,R24
    01809 8383      STD	Z+3,R24
(2356) 		fp->dsect = 0;
    0180A A9EE      LDD	R30,Y+54
    0180B A9FF      LDD	R31,Y+55
    0180C 9676      ADIW	R30,0x16
    0180D E080      LDI	R24,0
    0180E 8380      ST	Z,R24
    0180F 8381      STD	Z+1,R24
    01810 8382      STD	Z+2,R24
    01811 8383      STD	Z+3,R24
(2357) #if _USE_FASTSEEK
(2358) 		fp->cltbl = 0;						/* Normal seek mode */
    01812 2422      CLR	R2
    01813 2433      CLR	R3
    01814 A9EE      LDD	R30,Y+54
    01815 A9FF      LDD	R31,Y+55
    01816 A231      STD	Z+33,R3
    01817 A220      STD	Z+32,R2
(2359) #endif
(2360) 		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    01818 802A      LDD	R2,Y+2
    01819 803B      LDD	R3,Y+3
    0181A 8231      STD	Z+1,R3
    0181B 8220      ST	Z,R2
    0181C 01F1      MOVW	R30,R2
    0181D 8026      LDD	R2,Z+6
    0181E 8037      LDD	R3,Z+7
    0181F A9EE      LDD	R30,Y+54
    01820 A9FF      LDD	R31,Y+55
    01821 8233      STD	Z+3,R3
    01822 8222      STD	Z+2,R2
(2361) 	}
(2362) 
(2363) 	LEAVE_FF(dj.fs, res);
    01823 2D0A      MOV	R16,R10
    01824 96AC      ADIW	R28,0x2C
    01825 940E 3C6A CALL	pop_xgsetF0FC
    01827 9624      ADIW	R28,4
    01828 9508      RET
_f_read:
  remain               --> Y,+13
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  rbuff                --> R14
  sect                 --> Y,+5
  rcnt                 --> R12
  br                   --> Y,+33
  btr                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01829 940E 3B30 CALL	push_arg4
    0182B 940E 3C75 CALL	push_xgsetF0FC
    0182D 0159      MOVW	R10,R18
    0182E 9761      SBIW	R28,0x11
(2364) }
(2365) 
(2366) 
(2367) 
(2368) 
(2369) /*-----------------------------------------------------------------------*/
(2370) /* Read File                                                             */
(2371) /*-----------------------------------------------------------------------*/
(2372) 
(2373) FRESULT f_read (
(2374) 	FIL *fp, 		/* Pointer to the file object */
(2375) 	void *buff,		/* Pointer to data buffer */
(2376) 	UINT btr,		/* Number of bytes to read */
(2377) 	UINT *br		/* Pointer to number of bytes read */
(2378) )
(2379) {
(2380) 	FRESULT res;
(2381) 	DWORD clst, sect, remain;
(2382) 	UINT rcnt, cc;
(2383) 	BYTE csect, *rbuff = buff;
    0182F 0175      MOVW	R14,R10
(2384) 
(2385) 	memset(buff,0,512);
    01830 E080      LDI	R24,0
    01831 E092      LDI	R25,2
    01832 8399      STD	Y+1,R25
    01833 8388      ST	Y,R24
    01834 2722      CLR	R18
    01835 2733      CLR	R19
    01836 0185      MOVW	R16,R10
    01837 940E 3B0C CALL	_memset
(2386) 
(2387) 	*br = 0;	/* Initialize byte counter */
    01839 2422      CLR	R2
    0183A 2433      CLR	R3
    0183B A1E9      LDD	R30,Y+33
    0183C A1FA      LDD	R31,Y+34
    0183D 8231      STD	Z+1,R3
    0183E 8220      ST	Z,R2
(2388) 
(2389) 	res = validate(fp->fs, fp->id);				/* Check validity */
    0183F 8DEB      LDD	R30,Y+27
    01840 8DFC      LDD	R31,Y+28
    01841 8122      LDD	R18,Z+2
    01842 8133      LDD	R19,Z+3
    01843 8100      LD	R16,Z
    01844 8111      LDD	R17,Z+1
    01845 DDFF      RCALL	ff.c:validate
    01846 2EA0      MOV	R10,R16
(2390) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01847 2300      TST	R16
    01848 F009      BEQ	0x184A
    01849 C245      RJMP	0x1A8F
(2391) 	if (fp->flag & FA__ERROR)					/* Aborted file? */
    0184A 8DEB      LDD	R30,Y+27
    0184B 8DFC      LDD	R31,Y+28
    0184C 8024      LDD	R2,Z+4
    0184D FE27      SBRS	R2,7
    0184E C002      RJMP	0x1851
(2392) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    0184F E002      LDI	R16,2
    01850 C23E      RJMP	0x1A8F
(2393) 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    01851 8DEB      LDD	R30,Y+27
    01852 8DFC      LDD	R31,Y+28
    01853 8024      LDD	R2,Z+4
    01854 FC20      SBRC	R2,0
    01855 C002      RJMP	0x1858
(2394) 		LEAVE_FF(fp->fs, FR_DENIED);
    01856 E007      LDI	R16,7
    01857 C237      RJMP	0x1A8F
(2395) 	remain = fp->fsize - fp->fptr;
    01858 8DEB      LDD	R30,Y+27
    01859 8DFC      LDD	R31,Y+28
    0185A 8026      LDD	R2,Z+6
    0185B 8037      LDD	R3,Z+7
    0185C 8440      LDD	R4,Z+8
    0185D 8451      LDD	R5,Z+9
    0185E 963A      ADIW	R30,0xA
    0185F 8060      LD	R6,Z
    01860 8071      LDD	R7,Z+1
    01861 8082      LDD	R8,Z+2
    01862 8093      LDD	R9,Z+3
    01863 1862      SUB	R6,R2
    01864 0873      SBC	R7,R3
    01865 0884      SBC	R8,R4
    01866 0895      SBC	R9,R5
    01867 866D      STD	Y+13,R6
    01868 867E      STD	Y+14,R7
    01869 868F      STD	Y+15,R8
    0186A 8A98      STD	Y+16,R9
(2396) 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    0186B 842D      LDD	R2,Y+13
    0186C 843E      LDD	R3,Y+14
    0186D 844F      LDD	R4,Y+15
    0186E 8858      LDD	R5,Y+16
    0186F 8C6F      LDD	R6,Y+31
    01870 A078      LDD	R7,Y+32
    01871 2488      CLR	R8
    01872 2499      CLR	R9
    01873 1426      CP	R2,R6
    01874 0437      CPC	R3,R7
    01875 0448      CPC	R4,R8
    01876 0459      CPC	R5,R9
    01877 F008      BCS	0x1879
    01878 C20D      RJMP	0x1A86
    01879 A238      STD	Y+32,R3
    0187A 8E2F      STD	Y+31,R2
(2397) 
(2398) 	for ( ;  btr;								/* Repeat until all data read */
    0187B C20A      RJMP	0x1A86
(2399) 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
(2400) 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    0187C EF4F      LDI	R20,0xFF
    0187D E051      LDI	R21,1
    0187E E060      LDI	R22,0
    0187F E070      LDI	R23,0
    01880 8DEB      LDD	R30,Y+27
    01881 8DFC      LDD	R31,Y+28
    01882 9636      ADIW	R30,6
    01883 8020      LD	R2,Z
    01884 8031      LDD	R3,Z+1
    01885 8042      LDD	R4,Z+2
    01886 8053      LDD	R5,Z+3
    01887 2224      AND	R2,R20
    01888 2235      AND	R3,R21
    01889 2246      AND	R4,R22
    0188A 2257      AND	R5,R23
    0188B 9488      BCLR	0
    0188C 2022      TST	R2
    0188D 0432      CPC	R3,R2
    0188E 0442      CPC	R4,R2
    0188F 0452      CPC	R5,R2
    01890 F009      BEQ	0x1892
    01891 C180      RJMP	0x1A12
(2401) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01892 E089      LDI	R24,0x9
    01893 E090      LDI	R25,0
    01894 8DEB      LDD	R30,Y+27
    01895 8DFC      LDD	R31,Y+28
    01896 8106      LDD	R16,Z+6
    01897 8117      LDD	R17,Z+7
    01898 8520      LDD	R18,Z+8
    01899 8531      LDD	R19,Z+9
    0189A 938A      ST	-Y,R24
    0189B 940E 3D10 CALL	lsr32
    0189D 0118      MOVW	R2,R16
    0189E 0129      MOVW	R4,R18
    0189F 8DEB      LDD	R30,Y+27
    018A0 8DFC      LDD	R31,Y+28
    018A1 93AF      PUSH	R26
    018A2 93BF      PUSH	R27
    018A3 81A0      LD	R26,Z
    018A4 81B1      LDD	R27,Z+1
    018A5 01FD      MOVW	R30,R26
    018A6 91BF      POP	R27
    018A7 91AF      POP	R26
    018A8 8182      LDD	R24,Z+2
    018A9 2799      CLR	R25
    018AA 9701      SBIW	R24,1
    018AB 013C      MOVW	R6,R24
    018AC 2488      CLR	R8
    018AD FC77      SBRC	R7,7
    018AE 9480      COM	R8
    018AF 2499      CLR	R9
    018B0 FC87      SBRC	R8,7
    018B1 9490      COM	R9
    018B2 2026      AND	R2,R6
    018B3 2037      AND	R3,R7
    018B4 2048      AND	R4,R8
    018B5 2059      AND	R5,R9
    018B6 2CC2      MOV	R12,R2
(2402) 			if (!csect) {						/* On the cluster boundary? */
    018B7 2022      TST	R2
    018B8 F009      BEQ	0x18BA
    018B9 C078      RJMP	0x1932
(2403) 				if (fp->fptr == 0) {			/* On the top of the file? */
    018BA 8DEB      LDD	R30,Y+27
    018BB 8DFC      LDD	R31,Y+28
    018BC 9636      ADIW	R30,6
    018BD 8020      LD	R2,Z
    018BE 8031      LDD	R3,Z+1
    018BF 8042      LDD	R4,Z+2
    018C0 8053      LDD	R5,Z+3
    018C1 9488      BCLR	0
    018C2 2022      TST	R2
    018C3 0432      CPC	R3,R2
    018C4 0442      CPC	R4,R2
    018C5 0452      CPC	R5,R2
    018C6 F461      BNE	0x18D3
(2404) 					clst = fp->sclust;			/* Follow from the origin */
    018C7 8DEB      LDD	R30,Y+27
    018C8 8DFC      LDD	R31,Y+28
    018C9 963E      ADIW	R30,0xE
    018CA 8020      LD	R2,Z
    018CB 8031      LDD	R3,Z+1
    018CC 8042      LDD	R4,Z+2
    018CD 8053      LDD	R5,Z+3
    018CE 8629      STD	Y+9,R2
    018CF 863A      STD	Y+10,R3
    018D0 864B      STD	Y+11,R4
    018D1 865C      STD	Y+12,R5
(2405) 				} else {						/* Middle or end of the file */
    018D2 C028      RJMP	0x18FB
(2406) #if _USE_FASTSEEK
(2407) 					if (fp->cltbl)
    018D3 8DEB      LDD	R30,Y+27
    018D4 8DFC      LDD	R31,Y+28
    018D5 A020      LDD	R2,Z+32
    018D6 A031      LDD	R3,Z+33
    018D7 2022      TST	R2
    018D8 F411      BNE	0x18DB
    018D9 2033      TST	R3
    018DA F079      BEQ	0x18EA
(2408) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    018DB 8026      LDD	R2,Z+6
    018DC 8037      LDD	R3,Z+7
    018DD 8440      LDD	R4,Z+8
    018DE 8451      LDD	R5,Z+9
    018DF 8248      ST	Y,R4
    018E0 8259      STD	Y+1,R5
    018E1 0191      MOVW	R18,R2
    018E2 018F      MOVW	R16,R30
    018E3 940E 0A30 CALL	ff.c:clmt_clust
    018E5 8709      STD	Y+9,R16
    018E6 871A      STD	Y+10,R17
    018E7 872B      STD	Y+11,R18
    018E8 873C      STD	Y+12,R19
    018E9 C011      RJMP	0x18FB
(2409) 					else
(2410) #endif
(2411) 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    018EA 8DEB      LDD	R30,Y+27
    018EB 8DFC      LDD	R31,Y+28
    018EC 8822      LDD	R2,Z+18
    018ED 8833      LDD	R3,Z+19
    018EE 8844      LDD	R4,Z+20
    018EF 8855      LDD	R5,Z+21
    018F0 8248      ST	Y,R4
    018F1 8259      STD	Y+1,R5
    018F2 0191      MOVW	R18,R2
    018F3 8100      LD	R16,Z
    018F4 8111      LDD	R17,Z+1
    018F5 940E 04F6 CALL	_get_fat
    018F7 8709      STD	Y+9,R16
    018F8 871A      STD	Y+10,R17
    018F9 872B      STD	Y+11,R18
    018FA 873C      STD	Y+12,R19
(2412) 				}
(2413) 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    018FB E042      LDI	R20,2
    018FC E050      LDI	R21,0
    018FD E060      LDI	R22,0
    018FE E070      LDI	R23,0
    018FF 8429      LDD	R2,Y+9
    01900 843A      LDD	R3,Y+10
    01901 844B      LDD	R4,Y+11
    01902 845C      LDD	R5,Y+12
    01903 1624      CP	R2,R20
    01904 0635      CPC	R3,R21
    01905 0646      CPC	R4,R22
    01906 0657      CPC	R5,R23
    01907 F448      BCC	0x1911
    01908 8D8B      LDD	R24,Y+27
    01909 8D9C      LDD	R25,Y+28
    0190A 9604      ADIW	R24,4
    0190B 01FC      MOVW	R30,R24
    0190C 8180      LD	R24,Z
    0190D 6880      ORI	R24,0x80
    0190E 8380      ST	Z,R24
    0190F E002      LDI	R16,2
    01910 C17E      RJMP	0x1A8F
(2414) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01911 EF4F      LDI	R20,0xFF
    01912 EF5F      LDI	R21,0xFF
    01913 EF6F      LDI	R22,0xFF
    01914 EF7F      LDI	R23,0xFF
    01915 8429      LDD	R2,Y+9
    01916 843A      LDD	R3,Y+10
    01917 844B      LDD	R4,Y+11
    01918 845C      LDD	R5,Y+12
    01919 1624      CP	R2,R20
    0191A 0635      CPC	R3,R21
    0191B 0646      CPC	R4,R22
    0191C 0657      CPC	R5,R23
    0191D F451      BNE	0x1928
    0191E 8D8B      LDD	R24,Y+27
    0191F 8D9C      LDD	R25,Y+28
    01920 9604      ADIW	R24,4
    01921 015C      MOVW	R10,R24
    01922 01FC      MOVW	R30,R24
    01923 8180      LD	R24,Z
    01924 6880      ORI	R24,0x80
    01925 8380      ST	Z,R24
    01926 E001      LDI	R16,1
    01927 C167      RJMP	0x1A8F
(2415) 				fp->clust = clst;				/* Update current cluster */
    01928 8429      LDD	R2,Y+9
    01929 843A      LDD	R3,Y+10
    0192A 844B      LDD	R4,Y+11
    0192B 845C      LDD	R5,Y+12
    0192C 8DEB      LDD	R30,Y+27
    0192D 8DFC      LDD	R31,Y+28
    0192E 8A22      STD	Z+18,R2
    0192F 8A33      STD	Z+19,R3
    01930 8A44      STD	Z+20,R4
    01931 8A55      STD	Z+21,R5
(2416) 			}
(2417) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01932 8DEB      LDD	R30,Y+27
    01933 8DFC      LDD	R31,Y+28
    01934 8822      LDD	R2,Z+18
    01935 8833      LDD	R3,Z+19
    01936 8844      LDD	R4,Z+20
    01937 8855      LDD	R5,Z+21
    01938 8248      ST	Y,R4
    01939 8259      STD	Y+1,R5
    0193A 0191      MOVW	R18,R2
    0193B 8100      LD	R16,Z
    0193C 8111      LDD	R17,Z+1
    0193D 940E 04A4 CALL	_clust2sect
    0193F 830D      STD	Y+5,R16
    01940 831E      STD	Y+6,R17
    01941 832F      STD	Y+7,R18
    01942 8738      STD	Y+8,R19
(2418) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01943 802D      LDD	R2,Y+5
    01944 803E      LDD	R3,Y+6
    01945 804F      LDD	R4,Y+7
    01946 8458      LDD	R5,Y+8
    01947 9488      BCLR	0
    01948 2022      TST	R2
    01949 0432      CPC	R3,R2
    0194A 0442      CPC	R4,R2
    0194B 0452      CPC	R5,R2
    0194C F451      BNE	0x1957
    0194D 8D8B      LDD	R24,Y+27
    0194E 8D9C      LDD	R25,Y+28
    0194F 9604      ADIW	R24,4
    01950 015C      MOVW	R10,R24
    01951 01FC      MOVW	R30,R24
    01952 8180      LD	R24,Z
    01953 6880      ORI	R24,0x80
    01954 8380      ST	Z,R24
    01955 E002      LDI	R16,2
    01956 C138      RJMP	0x1A8F
(2419) 			sect += csect;
    01957 2C2C      MOV	R2,R12
    01958 2433      CLR	R3
    01959 2444      CLR	R4
    0195A 2455      CLR	R5
    0195B 806D      LDD	R6,Y+5
    0195C 807E      LDD	R7,Y+6
    0195D 808F      LDD	R8,Y+7
    0195E 8498      LDD	R9,Y+8
    0195F 0C62      ADD	R6,R2
    01960 1C73      ADC	R7,R3
    01961 1C84      ADC	R8,R4
    01962 1C95      ADC	R9,R5
    01963 826D      STD	Y+5,R6
    01964 827E      STD	Y+6,R7
    01965 828F      STD	Y+7,R8
    01966 8698      STD	Y+8,R9
(2420) 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    01967 E029      LDI	R18,0x9
    01968 E030      LDI	R19,0
    01969 8D0F      LDD	R16,Y+31
    0196A A118      LDD	R17,Y+32
    0196B 940E 3D09 CALL	lsr16
    0196D 0158      MOVW	R10,R16
(2421) 			if (cc) {							/* Read maximum contiguous sectors directly */
    0196E 3000      CPI	R16,0
    0196F 0701      CPC	R16,R17
    01970 F409      BNE	0x1972
    01971 C096      RJMP	0x1A08
(2422) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01972 2C2C      MOV	R2,R12
    01973 2433      CLR	R3
    01974 0E20      ADD	R2,R16
    01975 1E31      ADC	R3,R17
    01976 8DEB      LDD	R30,Y+27
    01977 8DFC      LDD	R31,Y+28
    01978 93AF      PUSH	R26
    01979 93BF      PUSH	R27
    0197A 81A0      LD	R26,Z
    0197B 81B1      LDD	R27,Z+1
    0197C 01FD      MOVW	R30,R26
    0197D 91BF      POP	R27
    0197E 91AF      POP	R26
    0197F 8042      LDD	R4,Z+2
    01980 2455      CLR	R5
    01981 1442      CP	R4,R2
    01982 0453      CPC	R5,R3
    01983 F478      BCC	0x1993
(2423) 					cc = fp->fs->csize - csect;
    01984 2C2C      MOV	R2,R12
    01985 2433      CLR	R3
    01986 8DEB      LDD	R30,Y+27
    01987 8DFC      LDD	R31,Y+28
    01988 93AF      PUSH	R26
    01989 93BF      PUSH	R27
    0198A 81A0      LD	R26,Z
    0198B 81B1      LDD	R27,Z+1
    0198C 01FD      MOVW	R30,R26
    0198D 91BF      POP	R27
    0198E 91AF      POP	R26
    0198F 80A2      LDD	R10,Z+2
    01990 24BB      CLR	R11
    01991 18A2      SUB	R10,R2
    01992 08B3      SBC	R11,R3
(2424) 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    01993 82AC      STD	Y+4,R10
    01994 802D      LDD	R2,Y+5
    01995 803E      LDD	R3,Y+6
    01996 804F      LDD	R4,Y+7
    01997 8458      LDD	R5,Y+8
    01998 8228      ST	Y,R2
    01999 8239      STD	Y+1,R3
    0199A 824A      STD	Y+2,R4
    0199B 825B      STD	Y+3,R5
    0199C 0197      MOVW	R18,R14
    0199D 8DEB      LDD	R30,Y+27
    0199E 8DFC      LDD	R31,Y+28
    0199F 93AF      PUSH	R26
    019A0 93BF      PUSH	R27
    019A1 81A0      LD	R26,Z
    019A2 81B1      LDD	R27,Z+1
    019A3 01FD      MOVW	R30,R26
    019A4 91BF      POP	R27
    019A5 91AF      POP	R26
    019A6 8101      LDD	R16,Z+1
    019A7 940E 0292 CALL	_disk_read
    019A9 2EC0      MOV	R12,R16
    019AA 2300      TST	R16
    019AB F051      BEQ	0x19B6
(2425) 					ABORT(fp->fs, FR_DISK_ERR);
    019AC 8D8B      LDD	R24,Y+27
    019AD 8D9C      LDD	R25,Y+28
    019AE 9604      ADIW	R24,4
    019AF 016C      MOVW	R12,R24
    019B0 01FC      MOVW	R30,R24
    019B1 8180      LD	R24,Z
    019B2 6880      ORI	R24,0x80
    019B3 8380      ST	Z,R24
    019B4 E001      LDI	R16,1
    019B5 C0D9      RJMP	0x1A8F
(2426) #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
(2427) #if _FS_TINY
(2428) 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    019B6 8DEB      LDD	R30,Y+27
    019B7 8DFC      LDD	R31,Y+28
    019B8 80C0      LD	R12,Z
    019B9 80D1      LDD	R13,Z+1
    019BA 01F6      MOVW	R30,R12
    019BB 9634      ADIW	R30,4
    019BC 8020      LD	R2,Z
    019BD 2022      TST	R2
    019BE F409      BNE	0x19C0
    019BF C041      RJMP	0x1A01
    019C0 802D      LDD	R2,Y+5
    019C1 803E      LDD	R3,Y+6
    019C2 804F      LDD	R4,Y+7
    019C3 8458      LDD	R5,Y+8
    019C4 01F6      MOVW	R30,R12
    019C5 A462      LDD	R6,Z+42
    019C6 A473      LDD	R7,Z+43
    019C7 A484      LDD	R8,Z+44
    019C8 A495      LDD	R9,Z+45
    019C9 1862      SUB	R6,R2
    019CA 0873      SBC	R7,R3
    019CB 0884      SBC	R8,R4
    019CC 0895      SBC	R9,R5
    019CD 0115      MOVW	R2,R10
    019CE 2444      CLR	R4
    019CF 2455      CLR	R5
    019D0 1462      CP	R6,R2
    019D1 0473      CPC	R7,R3
    019D2 0484      CPC	R8,R4
    019D3 0495      CPC	R9,R5
    019D4 F560      BCC	0x1A01
(2429) 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
    019D5 E080      LDI	R24,0
    019D6 E092      LDI	R25,2
    019D7 8399      STD	Y+1,R25
    019D8 8388      ST	Y,R24
    019D9 8DEB      LDD	R30,Y+27
    019DA 8DFC      LDD	R31,Y+28
    019DB 80C0      LD	R12,Z
    019DC 80D1      LDD	R13,Z+1
    019DD 0196      MOVW	R18,R12
    019DE 5D22      SUBI	R18,0xD2
    019DF 4F3F      SBCI	R19,0xFF
    019E0 802D      LDD	R2,Y+5
    019E1 803E      LDD	R3,Y+6
    019E2 804F      LDD	R4,Y+7
    019E3 8458      LDD	R5,Y+8
    019E4 01F6      MOVW	R30,R12
    019E5 A462      LDD	R6,Z+42
    019E6 A473      LDD	R7,Z+43
    019E7 A484      LDD	R8,Z+44
    019E8 A495      LDD	R9,Z+45
    019E9 1862      SUB	R6,R2
    019EA 0873      SBC	R7,R3
    019EB 0884      SBC	R8,R4
    019EC 0895      SBC	R9,R5
    019ED E040      LDI	R20,0
    019EE E052      LDI	R21,2
    019EF E060      LDI	R22,0
    019F0 E070      LDI	R23,0
    019F1 932F      PUSH	R18
    019F2 933F      PUSH	R19
    019F3 929A      ST	-Y,R9
    019F4 928A      ST	-Y,R8
    019F5 927A      ST	-Y,R7
    019F6 926A      ST	-Y,R6
    019F7 018A      MOVW	R16,R20
    019F8 019B      MOVW	R18,R22
    019F9 940E 3C21 CALL	empy32s|empy32u
    019FB 913F      POP	R19
    019FC 912F      POP	R18
    019FD 0D0E      ADD	R16,R14
    019FE 1D1F      ADC	R17,R15
    019FF 940E 02D4 CALL	ff.c:mem_cpy
(2430) #else
(2431) 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
(2432) 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
(2433) #endif
(2434) #endif
(2435) 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    01A01 E000      LDI	R16,0
    01A02 E012      LDI	R17,2
    01A03 0195      MOVW	R18,R10
    01A04 940E 3C11 CALL	empy16s
    01A06 0168      MOVW	R12,R16
(2436) 				continue;
    01A07 C05A      RJMP	0x1A62
(2437) 			}
(2438) #if !_FS_TINY
(2439) 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
(2440) #if !_FS_READONLY
(2441) 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2442) 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2443) 						ABORT(fp->fs, FR_DISK_ERR);
(2444) 					fp->flag &= ~FA__DIRTY;
(2445) 				}
(2446) #endif
(2447) 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
(2448) 					ABORT(fp->fs, FR_DISK_ERR);
(2449) 			}
(2450) #endif
(2451) 			fp->dsect = sect;
    01A08 802D      LDD	R2,Y+5
    01A09 803E      LDD	R3,Y+6
    01A0A 804F      LDD	R4,Y+7
    01A0B 8458      LDD	R5,Y+8
    01A0C 8DEB      LDD	R30,Y+27
    01A0D 8DFC      LDD	R31,Y+28
    01A0E 8A26      STD	Z+22,R2
    01A0F 8A37      STD	Z+23,R3
    01A10 8E40      STD	Z+24,R4
    01A11 8E51      STD	Z+25,R5
(2452) 		}
(2453) 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    01A12 EF4F      LDI	R20,0xFF
    01A13 E051      LDI	R21,1
    01A14 E060      LDI	R22,0
    01A15 E070      LDI	R23,0
    01A16 8DEB      LDD	R30,Y+27
    01A17 8DFC      LDD	R31,Y+28
    01A18 8026      LDD	R2,Z+6
    01A19 8037      LDD	R3,Z+7
    01A1A 8440      LDD	R4,Z+8
    01A1B 8451      LDD	R5,Z+9
    01A1C 2224      AND	R2,R20
    01A1D 2235      AND	R3,R21
    01A1E 2246      AND	R4,R22
    01A1F 2257      AND	R5,R23
    01A20 E040      LDI	R20,0
    01A21 E052      LDI	R21,2
    01A22 E060      LDI	R22,0
    01A23 E070      LDI	R23,0
    01A24 1942      SUB	R20,R2
    01A25 0953      SBC	R21,R3
    01A26 0964      SBC	R22,R4
    01A27 0975      SBC	R23,R5
    01A28 016A      MOVW	R12,R20
(2454) 		if (rcnt > btr) rcnt = btr;
    01A29 8C0F      LDD	R0,Y+31
    01A2A A018      LDD	R1,Y+32
    01A2B 1604      CP	R0,R20
    01A2C 0615      CPC	R1,R21
    01A2D F408      BCC	0x1A2F
    01A2E 0160      MOVW	R12,R0
(2455) #if _FS_TINY
(2456) 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    01A2F 8DEB      LDD	R30,Y+27
    01A30 8DFC      LDD	R31,Y+28
    01A31 8826      LDD	R2,Z+22
    01A32 8837      LDD	R3,Z+23
    01A33 8C40      LDD	R4,Z+24
    01A34 8C51      LDD	R5,Z+25
    01A35 8248      ST	Y,R4
    01A36 8259      STD	Y+1,R5
    01A37 0191      MOVW	R18,R2
    01A38 8100      LD	R16,Z
    01A39 8111      LDD	R17,Z+1
    01A3A 940E 032D CALL	ff.c:move_window
    01A3C 2EA0      MOV	R10,R16
    01A3D 2300      TST	R16
    01A3E F051      BEQ	0x1A49
(2457) 			ABORT(fp->fs, FR_DISK_ERR);
    01A3F 8D8B      LDD	R24,Y+27
    01A40 8D9C      LDD	R25,Y+28
    01A41 9604      ADIW	R24,4
    01A42 015C      MOVW	R10,R24
    01A43 01FC      MOVW	R30,R24
    01A44 8180      LD	R24,Z
    01A45 6880      ORI	R24,0x80
    01A46 8380      ST	Z,R24
    01A47 E001      LDI	R16,1
    01A48 C046      RJMP	0x1A8F
(2458) 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    01A49 82D9      STD	Y+1,R13
    01A4A 82C8      ST	Y,R12
    01A4B EF4F      LDI	R20,0xFF
    01A4C E051      LDI	R21,1
    01A4D E060      LDI	R22,0
    01A4E E070      LDI	R23,0
    01A4F 8DEB      LDD	R30,Y+27
    01A50 8DFC      LDD	R31,Y+28
    01A51 8026      LDD	R2,Z+6
    01A52 8037      LDD	R3,Z+7
    01A53 8440      LDD	R4,Z+8
    01A54 8451      LDD	R5,Z+9
    01A55 2224      AND	R2,R20
    01A56 2235      AND	R3,R21
    01A57 2246      AND	R4,R22
    01A58 2257      AND	R5,R23
    01A59 0191      MOVW	R18,R2
    01A5A 8180      LD	R24,Z
    01A5B 8191      LDD	R25,Z+1
    01A5C 968E      ADIW	R24,0x2E
    01A5D 0F28      ADD	R18,R24
    01A5E 1F39      ADC	R19,R25
    01A5F 0187      MOVW	R16,R14
    01A60 940E 02D4 CALL	ff.c:mem_cpy
    01A62 0CEC      ADD	R14,R12
    01A63 1CFD      ADC	R15,R13
    01A64 8D8B      LDD	R24,Y+27
    01A65 8D9C      LDD	R25,Y+28
    01A66 9606      ADIW	R24,6
    01A67 015C      MOVW	R10,R24
    01A68 0116      MOVW	R2,R12
    01A69 2444      CLR	R4
    01A6A 2455      CLR	R5
    01A6B 01FC      MOVW	R30,R24
    01A6C 8060      LD	R6,Z
    01A6D 8071      LDD	R7,Z+1
    01A6E 8082      LDD	R8,Z+2
    01A6F 8093      LDD	R9,Z+3
    01A70 0C62      ADD	R6,R2
    01A71 1C73      ADC	R7,R3
    01A72 1C84      ADC	R8,R4
    01A73 1C95      ADC	R9,R5
    01A74 8260      ST	Z,R6
    01A75 8271      STD	Z+1,R7
    01A76 8282      STD	Z+2,R8
    01A77 8293      STD	Z+3,R9
    01A78 A1E9      LDD	R30,Y+33
    01A79 A1FA      LDD	R31,Y+34
    01A7A 8020      LD	R2,Z
    01A7B 8031      LDD	R3,Z+1
    01A7C 0C2C      ADD	R2,R12
    01A7D 1C3D      ADC	R3,R13
    01A7E 8231      STD	Z+1,R3
    01A7F 8220      ST	Z,R2
    01A80 8C0F      LDD	R0,Y+31
    01A81 A018      LDD	R1,Y+32
    01A82 180C      SUB	R0,R12
    01A83 081D      SBC	R1,R13
    01A84 A218      STD	Y+32,R1
    01A85 8E0F      STD	Y+31,R0
    01A86 8C0F      LDD	R0,Y+31
    01A87 A018      LDD	R1,Y+32
    01A88 2000      TST	R0
    01A89 F009      BEQ	0x1A8B
    01A8A CDF1      RJMP	0x187C
    01A8B 2011      TST	R1
    01A8C F009      BEQ	0x1A8E
    01A8D CDEE      RJMP	0x187C
(2459) #else
(2460) 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
(2461) #endif
(2462) 	}
(2463) 
(2464) 	LEAVE_FF(fp->fs, FR_OK);
    01A8E 2700      CLR	R16
    01A8F 9661      ADIW	R28,0x11
    01A90 940E 3C6A CALL	pop_xgsetF0FC
    01A92 9624      ADIW	R28,4
    01A93 9508      RET
_f_write:
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  wbuff                --> R14
  sect                 --> Y,+5
  wcnt                 --> R12
  bw                   --> Y,+33
  btw                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01A94 940E 3B30 CALL	push_arg4
    01A96 940E 3C75 CALL	push_xgsetF0FC
    01A98 0159      MOVW	R10,R18
    01A99 9761      SBIW	R28,0x11
(2465) }
(2466) 
(2467) 
(2468) 
(2469) 
(2470) #if !_FS_READONLY
(2471) /*-----------------------------------------------------------------------*/
(2472) /* Write File                                                            */
(2473) /*-----------------------------------------------------------------------*/
(2474) 
(2475) FRESULT f_write (
(2476) 	FIL *fp,			/* Pointer to the file object */
(2477) 	const void *buff,	/* Pointer to the data to be written */
(2478) 	UINT btw,			/* Number of bytes to write */
(2479) 	UINT *bw			/* Pointer to number of bytes written */
(2480) )
(2481) {
(2482) 	FRESULT res;
(2483) 	DWORD clst, sect;
(2484) 	UINT wcnt, cc;
(2485) 	const BYTE *wbuff = buff;
    01A9A 0175      MOVW	R14,R10
(2486) 	BYTE csect;
(2487) 
(2488) 
(2489) 	*bw = 0;	/* Initialize byte counter */
    01A9B 2422      CLR	R2
    01A9C 2433      CLR	R3
    01A9D A1E9      LDD	R30,Y+33
    01A9E A1FA      LDD	R31,Y+34
    01A9F 8231      STD	Z+1,R3
    01AA0 8220      ST	Z,R2
(2490) 
(2491) 	res = validate(fp->fs, fp->id);			/* Check validity */
    01AA1 8DEB      LDD	R30,Y+27
    01AA2 8DFC      LDD	R31,Y+28
    01AA3 8122      LDD	R18,Z+2
    01AA4 8133      LDD	R19,Z+3
    01AA5 8100      LD	R16,Z
    01AA6 8111      LDD	R17,Z+1
    01AA7 DB9D      RCALL	ff.c:validate
    01AA8 2EA0      MOV	R10,R16
(2492) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01AA9 2300      TST	R16
    01AAA F009      BEQ	0x1AAC
    01AAB C2FC      RJMP	0x1DA8
(2493) 	if (fp->flag & FA__ERROR)				/* Aborted file? */
    01AAC 8DEB      LDD	R30,Y+27
    01AAD 8DFC      LDD	R31,Y+28
    01AAE 8024      LDD	R2,Z+4
    01AAF FE27      SBRS	R2,7
    01AB0 C002      RJMP	0x1AB3
(2494) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01AB1 E002      LDI	R16,2
    01AB2 C2F5      RJMP	0x1DA8
(2495) 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    01AB3 8DEB      LDD	R30,Y+27
    01AB4 8DFC      LDD	R31,Y+28
    01AB5 8024      LDD	R2,Z+4
    01AB6 FC21      SBRC	R2,1
    01AB7 C002      RJMP	0x1ABA
(2496) 		LEAVE_FF(fp->fs, FR_DENIED);
    01AB8 E007      LDI	R16,7
    01AB9 C2EE      RJMP	0x1DA8
(2497) 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    01ABA 8DEB      LDD	R30,Y+27
    01ABB 8DFC      LDD	R31,Y+28
    01ABC 963A      ADIW	R30,0xA
    01ABD 8020      LD	R2,Z
    01ABE 8031      LDD	R3,Z+1
    01ABF 8042      LDD	R4,Z+2
    01AC0 8053      LDD	R5,Z+3
    01AC1 862D      STD	Y+13,R2
    01AC2 863E      STD	Y+14,R3
    01AC3 864F      STD	Y+15,R4
    01AC4 8A58      STD	Y+16,R5
    01AC5 8C2F      LDD	R2,Y+31
    01AC6 A038      LDD	R3,Y+32
    01AC7 2444      CLR	R4
    01AC8 2455      CLR	R5
    01AC9 846D      LDD	R6,Y+13
    01ACA 847E      LDD	R7,Y+14
    01ACB 848F      LDD	R8,Y+15
    01ACC 8898      LDD	R9,Y+16
    01ACD 0C62      ADD	R6,R2
    01ACE 1C73      ADC	R7,R3
    01ACF 1C84      ADC	R8,R4
    01AD0 1C95      ADC	R9,R5
    01AD1 842D      LDD	R2,Y+13
    01AD2 843E      LDD	R3,Y+14
    01AD3 844F      LDD	R4,Y+15
    01AD4 8858      LDD	R5,Y+16
    01AD5 1462      CP	R6,R2
    01AD6 0473      CPC	R7,R3
    01AD7 0484      CPC	R8,R4
    01AD8 0495      CPC	R9,R5
    01AD9 F008      BCS	0x1ADB
    01ADA C2A5      RJMP	0x1D80
    01ADB 2400      CLR	R0
    01ADC 2411      CLR	R1
    01ADD A218      STD	Y+32,R1
    01ADE 8E0F      STD	Y+31,R0
(2498) 
(2499) 	for ( ;  btw;							/* Repeat until all data written */
    01ADF C2A0      RJMP	0x1D80
(2500) 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
(2501) 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    01AE0 EF4F      LDI	R20,0xFF
    01AE1 E051      LDI	R21,1
    01AE2 E060      LDI	R22,0
    01AE3 E070      LDI	R23,0
    01AE4 8DEB      LDD	R30,Y+27
    01AE5 8DFC      LDD	R31,Y+28
    01AE6 9636      ADIW	R30,6
    01AE7 8020      LD	R2,Z
    01AE8 8031      LDD	R3,Z+1
    01AE9 8042      LDD	R4,Z+2
    01AEA 8053      LDD	R5,Z+3
    01AEB 2224      AND	R2,R20
    01AEC 2235      AND	R3,R21
    01AED 2246      AND	R4,R22
    01AEE 2257      AND	R5,R23
    01AEF 9488      BCLR	0
    01AF0 2022      TST	R2
    01AF1 0432      CPC	R3,R2
    01AF2 0442      CPC	R4,R2
    01AF3 0452      CPC	R5,R2
    01AF4 F009      BEQ	0x1AF6
    01AF5 C20B      RJMP	0x1D01
(2502) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01AF6 E089      LDI	R24,0x9
    01AF7 E090      LDI	R25,0
    01AF8 8DEB      LDD	R30,Y+27
    01AF9 8DFC      LDD	R31,Y+28
    01AFA 8106      LDD	R16,Z+6
    01AFB 8117      LDD	R17,Z+7
    01AFC 8520      LDD	R18,Z+8
    01AFD 8531      LDD	R19,Z+9
    01AFE 938A      ST	-Y,R24
    01AFF 940E 3D10 CALL	lsr32
    01B01 0118      MOVW	R2,R16
    01B02 0129      MOVW	R4,R18
    01B03 8DEB      LDD	R30,Y+27
    01B04 8DFC      LDD	R31,Y+28
    01B05 93AF      PUSH	R26
    01B06 93BF      PUSH	R27
    01B07 81A0      LD	R26,Z
    01B08 81B1      LDD	R27,Z+1
    01B09 01FD      MOVW	R30,R26
    01B0A 91BF      POP	R27
    01B0B 91AF      POP	R26
    01B0C 8182      LDD	R24,Z+2
    01B0D 2799      CLR	R25
    01B0E 9701      SBIW	R24,1
    01B0F 013C      MOVW	R6,R24
    01B10 2488      CLR	R8
    01B11 FC77      SBRC	R7,7
    01B12 9480      COM	R8
    01B13 2499      CLR	R9
    01B14 FC87      SBRC	R8,7
    01B15 9490      COM	R9
    01B16 2026      AND	R2,R6
    01B17 2037      AND	R3,R7
    01B18 2048      AND	R4,R8
    01B19 2059      AND	R5,R9
    01B1A 2CC2      MOV	R12,R2
(2503) 			if (!csect) {					/* On the cluster boundary? */
    01B1B 2022      TST	R2
    01B1C F009      BEQ	0x1B1E
    01B1D C0A5      RJMP	0x1BC3
(2504) 				if (fp->fptr == 0) {		/* On the top of the file? */
    01B1E 8DEB      LDD	R30,Y+27
    01B1F 8DFC      LDD	R31,Y+28
    01B20 9636      ADIW	R30,6
    01B21 8020      LD	R2,Z
    01B22 8031      LDD	R3,Z+1
    01B23 8042      LDD	R4,Z+2
    01B24 8053      LDD	R5,Z+3
    01B25 9488      BCLR	0
    01B26 2022      TST	R2
    01B27 0432      CPC	R3,R2
    01B28 0442      CPC	R4,R2
    01B29 0452      CPC	R5,R2
    01B2A F571      BNE	0x1B59
(2505) 					clst = fp->sclust;		/* Follow from the origin */
    01B2B 8DEB      LDD	R30,Y+27
    01B2C 8DFC      LDD	R31,Y+28
    01B2D 963E      ADIW	R30,0xE
    01B2E 8020      LD	R2,Z
    01B2F 8031      LDD	R3,Z+1
    01B30 8042      LDD	R4,Z+2
    01B31 8053      LDD	R5,Z+3
    01B32 8629      STD	Y+9,R2
    01B33 863A      STD	Y+10,R3
    01B34 864B      STD	Y+11,R4
    01B35 865C      STD	Y+12,R5
(2506) 					if (clst == 0)			/* When no cluster is allocated, */
    01B36 8429      LDD	R2,Y+9
    01B37 843A      LDD	R3,Y+10
    01B38 844B      LDD	R4,Y+11
    01B39 845C      LDD	R5,Y+12
    01B3A 9488      BCLR	0
    01B3B 2022      TST	R2
    01B3C 0432      CPC	R3,R2
    01B3D 0442      CPC	R4,R2
    01B3E 0452      CPC	R5,R2
    01B3F F009      BEQ	0x1B41
    01B40 C040      RJMP	0x1B81
(2507) 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    01B41 E040      LDI	R20,0
    01B42 E050      LDI	R21,0
    01B43 E060      LDI	R22,0
    01B44 E070      LDI	R23,0
    01B45 8368      ST	Y,R22
    01B46 8379      STD	Y+1,R23
    01B47 019A      MOVW	R18,R20
    01B48 8DEB      LDD	R30,Y+27
    01B49 8DFC      LDD	R31,Y+28
    01B4A 8100      LD	R16,Z
    01B4B 8111      LDD	R17,Z+1
    01B4C 940E 08B8 CALL	ff.c:create_chain
    01B4E 8709      STD	Y+9,R16
    01B4F 871A      STD	Y+10,R17
    01B50 872B      STD	Y+11,R18
    01B51 873C      STD	Y+12,R19
    01B52 8DEB      LDD	R30,Y+27
    01B53 8DFC      LDD	R31,Y+28
    01B54 8706      STD	Z+14,R16
    01B55 8717      STD	Z+15,R17
    01B56 8B20      STD	Z+16,R18
    01B57 8B31      STD	Z+17,R19
(2508) 				} else {					/* Middle or end of the file */
    01B58 C028      RJMP	0x1B81
(2509) #if _USE_FASTSEEK
(2510) 					if (fp->cltbl)
    01B59 8DEB      LDD	R30,Y+27
    01B5A 8DFC      LDD	R31,Y+28
    01B5B A020      LDD	R2,Z+32
    01B5C A031      LDD	R3,Z+33
    01B5D 2022      TST	R2
    01B5E F411      BNE	0x1B61
    01B5F 2033      TST	R3
    01B60 F079      BEQ	0x1B70
(2511) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    01B61 8026      LDD	R2,Z+6
    01B62 8037      LDD	R3,Z+7
    01B63 8440      LDD	R4,Z+8
    01B64 8451      LDD	R5,Z+9
    01B65 8248      ST	Y,R4
    01B66 8259      STD	Y+1,R5
    01B67 0191      MOVW	R18,R2
    01B68 018F      MOVW	R16,R30
    01B69 940E 0A30 CALL	ff.c:clmt_clust
    01B6B 8709      STD	Y+9,R16
    01B6C 871A      STD	Y+10,R17
    01B6D 872B      STD	Y+11,R18
    01B6E 873C      STD	Y+12,R19
    01B6F C011      RJMP	0x1B81
(2512) 					else
(2513) #endif
(2514) 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    01B70 8DEB      LDD	R30,Y+27
    01B71 8DFC      LDD	R31,Y+28
    01B72 8822      LDD	R2,Z+18
    01B73 8833      LDD	R3,Z+19
    01B74 8844      LDD	R4,Z+20
    01B75 8855      LDD	R5,Z+21
    01B76 8248      ST	Y,R4
    01B77 8259      STD	Y+1,R5
    01B78 0191      MOVW	R18,R2
    01B79 8100      LD	R16,Z
    01B7A 8111      LDD	R17,Z+1
    01B7B 940E 08B8 CALL	ff.c:create_chain
    01B7D 8709      STD	Y+9,R16
    01B7E 871A      STD	Y+10,R17
    01B7F 872B      STD	Y+11,R18
    01B80 873C      STD	Y+12,R19
(2515) 				}
(2516) 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    01B81 8429      LDD	R2,Y+9
    01B82 843A      LDD	R3,Y+10
    01B83 844B      LDD	R4,Y+11
    01B84 845C      LDD	R5,Y+12
    01B85 9488      BCLR	0
    01B86 2022      TST	R2
    01B87 0432      CPC	R3,R2
    01B88 0442      CPC	R4,R2
    01B89 0452      CPC	R5,R2
    01B8A F409      BNE	0x1B8C
    01B8B C1FC      RJMP	0x1D88
(2517) 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    01B8C E041      LDI	R20,1
    01B8D E050      LDI	R21,0
    01B8E E060      LDI	R22,0
    01B8F E070      LDI	R23,0
    01B90 8429      LDD	R2,Y+9
    01B91 843A      LDD	R3,Y+10
    01B92 844B      LDD	R4,Y+11
    01B93 845C      LDD	R5,Y+12
    01B94 1624      CP	R2,R20
    01B95 0635      CPC	R3,R21
    01B96 0646      CPC	R4,R22
    01B97 0657      CPC	R5,R23
    01B98 F449      BNE	0x1BA2
    01B99 8D8B      LDD	R24,Y+27
    01B9A 8D9C      LDD	R25,Y+28
    01B9B 9604      ADIW	R24,4
    01B9C 01FC      MOVW	R30,R24
    01B9D 8180      LD	R24,Z
    01B9E 6880      ORI	R24,0x80
    01B9F 8380      ST	Z,R24
    01BA0 E002      LDI	R16,2
    01BA1 C206      RJMP	0x1DA8
(2518) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01BA2 EF4F      LDI	R20,0xFF
    01BA3 EF5F      LDI	R21,0xFF
    01BA4 EF6F      LDI	R22,0xFF
    01BA5 EF7F      LDI	R23,0xFF
    01BA6 8429      LDD	R2,Y+9
    01BA7 843A      LDD	R3,Y+10
    01BA8 844B      LDD	R4,Y+11
    01BA9 845C      LDD	R5,Y+12
    01BAA 1624      CP	R2,R20
    01BAB 0635      CPC	R3,R21
    01BAC 0646      CPC	R4,R22
    01BAD 0657      CPC	R5,R23
    01BAE F451      BNE	0x1BB9
    01BAF 8D8B      LDD	R24,Y+27
    01BB0 8D9C      LDD	R25,Y+28
    01BB1 9604      ADIW	R24,4
    01BB2 015C      MOVW	R10,R24
    01BB3 01FC      MOVW	R30,R24
    01BB4 8180      LD	R24,Z
    01BB5 6880      ORI	R24,0x80
    01BB6 8380      ST	Z,R24
    01BB7 E001      LDI	R16,1
    01BB8 C1EF      RJMP	0x1DA8
(2519) 				fp->clust = clst;			/* Update current cluster */
    01BB9 8429      LDD	R2,Y+9
    01BBA 843A      LDD	R3,Y+10
    01BBB 844B      LDD	R4,Y+11
    01BBC 845C      LDD	R5,Y+12
    01BBD 8DEB      LDD	R30,Y+27
    01BBE 8DFC      LDD	R31,Y+28
    01BBF 8A22      STD	Z+18,R2
    01BC0 8A33      STD	Z+19,R3
    01BC1 8A44      STD	Z+20,R4
    01BC2 8A55      STD	Z+21,R5
(2520) 			}
(2521) #if _FS_TINY
(2522) 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
    01BC3 8DEB      LDD	R30,Y+27
    01BC4 8DFC      LDD	R31,Y+28
    01BC5 80A0      LD	R10,Z
    01BC6 80B1      LDD	R11,Z+1
    01BC7 8826      LDD	R2,Z+22
    01BC8 8837      LDD	R3,Z+23
    01BC9 8C40      LDD	R4,Z+24
    01BCA 8C51      LDD	R5,Z+25
    01BCB 01F5      MOVW	R30,R10
    01BCC A462      LDD	R6,Z+42
    01BCD A473      LDD	R7,Z+43
    01BCE A484      LDD	R8,Z+44
    01BCF A495      LDD	R9,Z+45
    01BD0 1462      CP	R6,R2
    01BD1 0473      CPC	R7,R3
    01BD2 0484      CPC	R8,R4
    01BD3 0495      CPC	R9,R5
    01BD4 F4B9      BNE	0x1BEC
    01BD5 E040      LDI	R20,0
    01BD6 E050      LDI	R21,0
    01BD7 E060      LDI	R22,0
    01BD8 E070      LDI	R23,0
    01BD9 8368      ST	Y,R22
    01BDA 8379      STD	Y+1,R23
    01BDB 019A      MOVW	R18,R20
    01BDC 018F      MOVW	R16,R30
    01BDD 940E 032D CALL	ff.c:move_window
    01BDF 2EA0      MOV	R10,R16
    01BE0 2300      TST	R16
    01BE1 F051      BEQ	0x1BEC
(2523) 				ABORT(fp->fs, FR_DISK_ERR);
    01BE2 8D8B      LDD	R24,Y+27
    01BE3 8D9C      LDD	R25,Y+28
    01BE4 9604      ADIW	R24,4
    01BE5 015C      MOVW	R10,R24
    01BE6 01FC      MOVW	R30,R24
    01BE7 8180      LD	R24,Z
    01BE8 6880      ORI	R24,0x80
    01BE9 8380      ST	Z,R24
    01BEA E001      LDI	R16,1
    01BEB C1BC      RJMP	0x1DA8
(2524) #else
(2525) 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
(2526) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2527) 					ABORT(fp->fs, FR_DISK_ERR);
(2528) 				fp->flag &= ~FA__DIRTY;
(2529) 			}
(2530) #endif
(2531) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01BEC 8DEB      LDD	R30,Y+27
    01BED 8DFC      LDD	R31,Y+28
    01BEE 8822      LDD	R2,Z+18
    01BEF 8833      LDD	R3,Z+19
    01BF0 8844      LDD	R4,Z+20
    01BF1 8855      LDD	R5,Z+21
    01BF2 8248      ST	Y,R4
    01BF3 8259      STD	Y+1,R5
    01BF4 0191      MOVW	R18,R2
    01BF5 8100      LD	R16,Z
    01BF6 8111      LDD	R17,Z+1
    01BF7 940E 04A4 CALL	_clust2sect
    01BF9 830D      STD	Y+5,R16
    01BFA 831E      STD	Y+6,R17
    01BFB 832F      STD	Y+7,R18
    01BFC 8738      STD	Y+8,R19
(2532) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01BFD 802D      LDD	R2,Y+5
    01BFE 803E      LDD	R3,Y+6
    01BFF 804F      LDD	R4,Y+7
    01C00 8458      LDD	R5,Y+8
    01C01 9488      BCLR	0
    01C02 2022      TST	R2
    01C03 0432      CPC	R3,R2
    01C04 0442      CPC	R4,R2
    01C05 0452      CPC	R5,R2
    01C06 F451      BNE	0x1C11
    01C07 8D8B      LDD	R24,Y+27
    01C08 8D9C      LDD	R25,Y+28
    01C09 9604      ADIW	R24,4
    01C0A 015C      MOVW	R10,R24
    01C0B 01FC      MOVW	R30,R24
    01C0C 8180      LD	R24,Z
    01C0D 6880      ORI	R24,0x80
    01C0E 8380      ST	Z,R24
    01C0F E002      LDI	R16,2
    01C10 C197      RJMP	0x1DA8
(2533) 			sect += csect;
    01C11 2C2C      MOV	R2,R12
    01C12 2433      CLR	R3
    01C13 2444      CLR	R4
    01C14 2455      CLR	R5
    01C15 806D      LDD	R6,Y+5
    01C16 807E      LDD	R7,Y+6
    01C17 808F      LDD	R8,Y+7
    01C18 8498      LDD	R9,Y+8
    01C19 0C62      ADD	R6,R2
    01C1A 1C73      ADC	R7,R3
    01C1B 1C84      ADC	R8,R4
    01C1C 1C95      ADC	R9,R5
    01C1D 826D      STD	Y+5,R6
    01C1E 827E      STD	Y+6,R7
    01C1F 828F      STD	Y+7,R8
    01C20 8698      STD	Y+8,R9
(2534) 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    01C21 E029      LDI	R18,0x9
    01C22 E030      LDI	R19,0
    01C23 8D0F      LDD	R16,Y+31
    01C24 A118      LDD	R17,Y+32
    01C25 940E 3D09 CALL	lsr16
    01C27 0158      MOVW	R10,R16
(2535) 			if (cc) {						/* Write maximum contiguous sectors directly */
    01C28 3000      CPI	R16,0
    01C29 0701      CPC	R16,R17
    01C2A F409      BNE	0x1C2C
    01C2B C097      RJMP	0x1CC3
(2536) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01C2C 2C2C      MOV	R2,R12
    01C2D 2433      CLR	R3
    01C2E 0E20      ADD	R2,R16
    01C2F 1E31      ADC	R3,R17
    01C30 8DEB      LDD	R30,Y+27
    01C31 8DFC      LDD	R31,Y+28
    01C32 93AF      PUSH	R26
    01C33 93BF      PUSH	R27
    01C34 81A0      LD	R26,Z
    01C35 81B1      LDD	R27,Z+1
    01C36 01FD      MOVW	R30,R26
    01C37 91BF      POP	R27
    01C38 91AF      POP	R26
    01C39 8042      LDD	R4,Z+2
    01C3A 2455      CLR	R5
    01C3B 1442      CP	R4,R2
    01C3C 0453      CPC	R5,R3
    01C3D F478      BCC	0x1C4D
(2537) 					cc = fp->fs->csize - csect;
    01C3E 2C2C      MOV	R2,R12
    01C3F 2433      CLR	R3
    01C40 8DEB      LDD	R30,Y+27
    01C41 8DFC      LDD	R31,Y+28
    01C42 93AF      PUSH	R26
    01C43 93BF      PUSH	R27
    01C44 81A0      LD	R26,Z
    01C45 81B1      LDD	R27,Z+1
    01C46 01FD      MOVW	R30,R26
    01C47 91BF      POP	R27
    01C48 91AF      POP	R26
    01C49 80A2      LDD	R10,Z+2
    01C4A 24BB      CLR	R11
    01C4B 18A2      SUB	R10,R2
    01C4C 08B3      SBC	R11,R3
(2538) 				if (disk_write(fp->fs->drv,(char*)wbuff, sect, (BYTE)cc) != RES_OK)
    01C4D 82AC      STD	Y+4,R10
    01C4E 802D      LDD	R2,Y+5
    01C4F 803E      LDD	R3,Y+6
    01C50 804F      LDD	R4,Y+7
    01C51 8458      LDD	R5,Y+8
    01C52 8228      ST	Y,R2
    01C53 8239      STD	Y+1,R3
    01C54 824A      STD	Y+2,R4
    01C55 825B      STD	Y+3,R5
    01C56 0197      MOVW	R18,R14
    01C57 8DEB      LDD	R30,Y+27
    01C58 8DFC      LDD	R31,Y+28
    01C59 93AF      PUSH	R26
    01C5A 93BF      PUSH	R27
    01C5B 81A0      LD	R26,Z
    01C5C 81B1      LDD	R27,Z+1
    01C5D 01FD      MOVW	R30,R26
    01C5E 91BF      POP	R27
    01C5F 91AF      POP	R26
    01C60 8101      LDD	R16,Z+1
    01C61 940E 02B2 CALL	_disk_write
    01C63 2EC0      MOV	R12,R16
    01C64 2300      TST	R16
    01C65 F051      BEQ	0x1C70
(2539) 					ABORT(fp->fs, FR_DISK_ERR);
    01C66 8D8B      LDD	R24,Y+27
    01C67 8D9C      LDD	R25,Y+28
    01C68 9604      ADIW	R24,4
    01C69 016C      MOVW	R12,R24
    01C6A 01FC      MOVW	R30,R24
    01C6B 8180      LD	R24,Z
    01C6C 6880      ORI	R24,0x80
    01C6D 8380      ST	Z,R24
    01C6E E001      LDI	R16,1
    01C6F C138      RJMP	0x1DA8
(2540) #if _FS_TINY
(2541) 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
    01C70 802D      LDD	R2,Y+5
    01C71 803E      LDD	R3,Y+6
    01C72 804F      LDD	R4,Y+7
    01C73 8458      LDD	R5,Y+8
    01C74 8DEB      LDD	R30,Y+27
    01C75 8DFC      LDD	R31,Y+28
    01C76 81A0      LD	R26,Z
    01C77 81B1      LDD	R27,Z+1
    01C78 969A      ADIW	R26,0x2A
    01C79 906D      LD	R6,X+
    01C7A 907D      LD	R7,X+
    01C7B 908D      LD	R8,X+
    01C7C 909C      LD	R9,X
    01C7D 1862      SUB	R6,R2
    01C7E 0873      SBC	R7,R3
    01C7F 0884      SBC	R8,R4
    01C80 0895      SBC	R9,R5
    01C81 0115      MOVW	R2,R10
    01C82 2444      CLR	R4
    01C83 2455      CLR	R5
    01C84 1462      CP	R6,R2
    01C85 0473      CPC	R7,R3
    01C86 0484      CPC	R8,R4
    01C87 0495      CPC	R9,R5
    01C88 F008      BCS	0x1C8A
    01C89 C032      RJMP	0x1CBC
(2542) 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
    01C8A E080      LDI	R24,0
    01C8B E092      LDI	R25,2
    01C8C 8399      STD	Y+1,R25
    01C8D 8388      ST	Y,R24
    01C8E 80C0      LD	R12,Z
    01C8F 80D1      LDD	R13,Z+1
    01C90 802D      LDD	R2,Y+5
    01C91 803E      LDD	R3,Y+6
    01C92 804F      LDD	R4,Y+7
    01C93 8458      LDD	R5,Y+8
    01C94 01F6      MOVW	R30,R12
    01C95 A462      LDD	R6,Z+42
    01C96 A473      LDD	R7,Z+43
    01C97 A484      LDD	R8,Z+44
    01C98 A495      LDD	R9,Z+45
    01C99 1862      SUB	R6,R2
    01C9A 0873      SBC	R7,R3
    01C9B 0884      SBC	R8,R4
    01C9C 0895      SBC	R9,R5
    01C9D E040      LDI	R20,0
    01C9E E052      LDI	R21,2
    01C9F E060      LDI	R22,0
    01CA0 E070      LDI	R23,0
    01CA1 929A      ST	-Y,R9
    01CA2 928A      ST	-Y,R8
    01CA3 927A      ST	-Y,R7
    01CA4 926A      ST	-Y,R6
    01CA5 018A      MOVW	R16,R20
    01CA6 019B      MOVW	R18,R22
    01CA7 940E 3C21 CALL	empy32s|empy32u
    01CA9 0198      MOVW	R18,R16
    01CAA 0D2E      ADD	R18,R14
    01CAB 1D3F      ADC	R19,R15
    01CAC 0186      MOVW	R16,R12
    01CAD 5D02      SUBI	R16,0xD2
    01CAE 4F1F      SBCI	R17,0xFF
    01CAF 940E 02D4 CALL	ff.c:mem_cpy
(2543) 					fp->fs->wflag = 0;
    01CB1 2422      CLR	R2
    01CB2 8DEB      LDD	R30,Y+27
    01CB3 8DFC      LDD	R31,Y+28
    01CB4 93AF      PUSH	R26
    01CB5 93BF      PUSH	R27
    01CB6 81A0      LD	R26,Z
    01CB7 81B1      LDD	R27,Z+1
    01CB8 01FD      MOVW	R30,R26
    01CB9 91BF      POP	R27
    01CBA 91AF      POP	R26
    01CBB 8224      STD	Z+4,R2
(2544) 				}
(2545) #else
(2546) 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
(2547) 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
(2548) 					fp->flag &= ~FA__DIRTY;
(2549) 				}
(2550) #endif
(2551) 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    01CBC E000      LDI	R16,0
    01CBD E012      LDI	R17,2
    01CBE 0195      MOVW	R18,R10
    01CBF 940E 3C11 CALL	empy16s
    01CC1 0168      MOVW	R12,R16
(2552) 				continue;
    01CC2 C099      RJMP	0x1D5C
(2553) 			}
(2554) #if _FS_TINY
(2555) 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
    01CC3 8DEB      LDD	R30,Y+27
    01CC4 8DFC      LDD	R31,Y+28
    01CC5 8422      LDD	R2,Z+10
    01CC6 8433      LDD	R3,Z+11
    01CC7 8444      LDD	R4,Z+12
    01CC8 8455      LDD	R5,Z+13
    01CC9 8066      LDD	R6,Z+6
    01CCA 8077      LDD	R7,Z+7
    01CCB 8480      LDD	R8,Z+8
    01CCC 8491      LDD	R9,Z+9
    01CCD 1462      CP	R6,R2
    01CCE 0473      CPC	R7,R3
    01CCF 0484      CPC	R8,R4
    01CD0 0495      CPC	R9,R5
    01CD1 F128      BCS	0x1CF7
(2556) 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    01CD2 E040      LDI	R20,0
    01CD3 E050      LDI	R21,0
    01CD4 E060      LDI	R22,0
    01CD5 E070      LDI	R23,0
    01CD6 8368      ST	Y,R22
    01CD7 8379      STD	Y+1,R23
    01CD8 019A      MOVW	R18,R20
    01CD9 8100      LD	R16,Z
    01CDA 8111      LDD	R17,Z+1
    01CDB 940E 032D CALL	ff.c:move_window
    01CDD 2EA0      MOV	R10,R16
    01CDE 2300      TST	R16
    01CDF F051      BEQ	0x1CEA
    01CE0 8D8B      LDD	R24,Y+27
    01CE1 8D9C      LDD	R25,Y+28
    01CE2 9604      ADIW	R24,4
    01CE3 015C      MOVW	R10,R24
    01CE4 01FC      MOVW	R30,R24
    01CE5 8180      LD	R24,Z
    01CE6 6880      ORI	R24,0x80
    01CE7 8380      ST	Z,R24
    01CE8 E001      LDI	R16,1
    01CE9 C0BE      RJMP	0x1DA8
(2557) 				fp->fs->winsect = sect;
    01CEA 802D      LDD	R2,Y+5
    01CEB 803E      LDD	R3,Y+6
    01CEC 804F      LDD	R4,Y+7
    01CED 8458      LDD	R5,Y+8
    01CEE 8DEB      LDD	R30,Y+27
    01CEF 8DFC      LDD	R31,Y+28
    01CF0 81A0      LD	R26,Z
    01CF1 81B1      LDD	R27,Z+1
    01CF2 969A      ADIW	R26,0x2A
    01CF3 922D      ST	X+,R2
    01CF4 923D      ST	X+,R3
    01CF5 924D      ST	X+,R4
    01CF6 925C      ST	X,R5
(2558) 			}
(2559) #else
(2560) 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
(2561) 				if (fp->fptr < fp->fsize &&
(2562) 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
(2563) 						ABORT(fp->fs, FR_DISK_ERR);
(2564) 			}
(2565) #endif
(2566) 			fp->dsect = sect;
    01CF7 802D      LDD	R2,Y+5
    01CF8 803E      LDD	R3,Y+6
    01CF9 804F      LDD	R4,Y+7
    01CFA 8458      LDD	R5,Y+8
    01CFB 8DEB      LDD	R30,Y+27
    01CFC 8DFC      LDD	R31,Y+28
    01CFD 8A26      STD	Z+22,R2
    01CFE 8A37      STD	Z+23,R3
    01CFF 8E40      STD	Z+24,R4
    01D00 8E51      STD	Z+25,R5
(2567) 		}
(2568) 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    01D01 EF4F      LDI	R20,0xFF
    01D02 E051      LDI	R21,1
    01D03 E060      LDI	R22,0
    01D04 E070      LDI	R23,0
    01D05 8DEB      LDD	R30,Y+27
    01D06 8DFC      LDD	R31,Y+28
    01D07 8026      LDD	R2,Z+6
    01D08 8037      LDD	R3,Z+7
    01D09 8440      LDD	R4,Z+8
    01D0A 8451      LDD	R5,Z+9
    01D0B 2224      AND	R2,R20
    01D0C 2235      AND	R3,R21
    01D0D 2246      AND	R4,R22
    01D0E 2257      AND	R5,R23
    01D0F E040      LDI	R20,0
    01D10 E052      LDI	R21,2
    01D11 E060      LDI	R22,0
    01D12 E070      LDI	R23,0
    01D13 1942      SUB	R20,R2
    01D14 0953      SBC	R21,R3
    01D15 0964      SBC	R22,R4
    01D16 0975      SBC	R23,R5
    01D17 016A      MOVW	R12,R20
(2569) 		if (wcnt > btw) wcnt = btw;
    01D18 8C0F      LDD	R0,Y+31
    01D19 A018      LDD	R1,Y+32
    01D1A 1604      CP	R0,R20
    01D1B 0615      CPC	R1,R21
    01D1C F408      BCC	0x1D1E
    01D1D 0160      MOVW	R12,R0
(2570) #if _FS_TINY
(2571) 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
    01D1E 8DEB      LDD	R30,Y+27
    01D1F 8DFC      LDD	R31,Y+28
    01D20 8826      LDD	R2,Z+22
    01D21 8837      LDD	R3,Z+23
    01D22 8C40      LDD	R4,Z+24
    01D23 8C51      LDD	R5,Z+25
    01D24 8248      ST	Y,R4
    01D25 8259      STD	Y+1,R5
    01D26 0191      MOVW	R18,R2
    01D27 8100      LD	R16,Z
    01D28 8111      LDD	R17,Z+1
    01D29 940E 032D CALL	ff.c:move_window
    01D2B 2EA0      MOV	R10,R16
    01D2C 2300      TST	R16
    01D2D F051      BEQ	0x1D38
(2572) 			ABORT(fp->fs, FR_DISK_ERR);
    01D2E 8D8B      LDD	R24,Y+27
    01D2F 8D9C      LDD	R25,Y+28
    01D30 9604      ADIW	R24,4
    01D31 015C      MOVW	R10,R24
    01D32 01FC      MOVW	R30,R24
    01D33 8180      LD	R24,Z
    01D34 6880      ORI	R24,0x80
    01D35 8380      ST	Z,R24
    01D36 E001      LDI	R16,1
    01D37 C070      RJMP	0x1DA8
(2573) 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    01D38 82D9      STD	Y+1,R13
    01D39 82C8      ST	Y,R12
    01D3A 0197      MOVW	R18,R14
    01D3B EF4F      LDI	R20,0xFF
    01D3C E051      LDI	R21,1
    01D3D E060      LDI	R22,0
    01D3E E070      LDI	R23,0
    01D3F 8DEB      LDD	R30,Y+27
    01D40 8DFC      LDD	R31,Y+28
    01D41 8026      LDD	R2,Z+6
    01D42 8037      LDD	R3,Z+7
    01D43 8440      LDD	R4,Z+8
    01D44 8451      LDD	R5,Z+9
    01D45 2224      AND	R2,R20
    01D46 2235      AND	R3,R21
    01D47 2246      AND	R4,R22
    01D48 2257      AND	R5,R23
    01D49 0181      MOVW	R16,R2
    01D4A 8180      LD	R24,Z
    01D4B 8191      LDD	R25,Z+1
    01D4C 968E      ADIW	R24,0x2E
    01D4D 0F08      ADD	R16,R24
    01D4E 1F19      ADC	R17,R25
    01D4F 940E 02D4 CALL	ff.c:mem_cpy
(2574) 		fp->fs->wflag = 1;
    01D51 E081      LDI	R24,1
    01D52 8DEB      LDD	R30,Y+27
    01D53 8DFC      LDD	R31,Y+28
    01D54 93AF      PUSH	R26
    01D55 93BF      PUSH	R27
    01D56 81A0      LD	R26,Z
    01D57 81B1      LDD	R27,Z+1
    01D58 01FD      MOVW	R30,R26
    01D59 91BF      POP	R27
    01D5A 91AF      POP	R26
    01D5B 8384      STD	Z+4,R24
    01D5C 0CEC      ADD	R14,R12
    01D5D 1CFD      ADC	R15,R13
    01D5E 8D8B      LDD	R24,Y+27
    01D5F 8D9C      LDD	R25,Y+28
    01D60 9606      ADIW	R24,6
    01D61 015C      MOVW	R10,R24
    01D62 0116      MOVW	R2,R12
    01D63 2444      CLR	R4
    01D64 2455      CLR	R5
    01D65 01FC      MOVW	R30,R24
    01D66 8060      LD	R6,Z
    01D67 8071      LDD	R7,Z+1
    01D68 8082      LDD	R8,Z+2
    01D69 8093      LDD	R9,Z+3
    01D6A 0C62      ADD	R6,R2
    01D6B 1C73      ADC	R7,R3
    01D6C 1C84      ADC	R8,R4
    01D6D 1C95      ADC	R9,R5
    01D6E 8260      ST	Z,R6
    01D6F 8271      STD	Z+1,R7
    01D70 8282      STD	Z+2,R8
    01D71 8293      STD	Z+3,R9
    01D72 A1E9      LDD	R30,Y+33
    01D73 A1FA      LDD	R31,Y+34
    01D74 8020      LD	R2,Z
    01D75 8031      LDD	R3,Z+1
    01D76 0C2C      ADD	R2,R12
    01D77 1C3D      ADC	R3,R13
    01D78 8231      STD	Z+1,R3
    01D79 8220      ST	Z,R2
    01D7A 8C0F      LDD	R0,Y+31
    01D7B A018      LDD	R1,Y+32
    01D7C 180C      SUB	R0,R12
    01D7D 081D      SBC	R1,R13
    01D7E A218      STD	Y+32,R1
    01D7F 8E0F      STD	Y+31,R0
    01D80 8C0F      LDD	R0,Y+31
    01D81 A018      LDD	R1,Y+32
    01D82 2000      TST	R0
    01D83 F009      BEQ	0x1D85
    01D84 CD5B      RJMP	0x1AE0
    01D85 2011      TST	R1
    01D86 F009      BEQ	0x1D88
    01D87 CD58      RJMP	0x1AE0
(2575) #else
(2576) 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
(2577) 		fp->flag |= FA__DIRTY;
(2578) #endif
(2579) 	}
(2580) 
(2581) 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    01D88 8DEB      LDD	R30,Y+27
    01D89 8DFC      LDD	R31,Y+28
    01D8A 8422      LDD	R2,Z+10
    01D8B 8433      LDD	R3,Z+11
    01D8C 8444      LDD	R4,Z+12
    01D8D 8455      LDD	R5,Z+13
    01D8E 8066      LDD	R6,Z+6
    01D8F 8077      LDD	R7,Z+7
    01D90 8480      LDD	R8,Z+8
    01D91 8491      LDD	R9,Z+9
    01D92 1426      CP	R2,R6
    01D93 0437      CPC	R3,R7
    01D94 0448      CPC	R4,R8
    01D95 0459      CPC	R5,R9
    01D96 F440      BCC	0x1D9F
    01D97 8026      LDD	R2,Z+6
    01D98 8037      LDD	R3,Z+7
    01D99 8440      LDD	R4,Z+8
    01D9A 8451      LDD	R5,Z+9
    01D9B 8622      STD	Z+10,R2
    01D9C 8633      STD	Z+11,R3
    01D9D 8644      STD	Z+12,R4
    01D9E 8655      STD	Z+13,R5
(2582) 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    01D9F 8D8B      LDD	R24,Y+27
    01DA0 8D9C      LDD	R25,Y+28
    01DA1 9604      ADIW	R24,4
    01DA2 015C      MOVW	R10,R24
    01DA3 01FC      MOVW	R30,R24
    01DA4 8180      LD	R24,Z
    01DA5 6280      ORI	R24,0x20
    01DA6 8380      ST	Z,R24
(2583) 
(2584) 	LEAVE_FF(fp->fs, FR_OK);
    01DA7 2700      CLR	R16
    01DA8 9661      ADIW	R28,0x11
    01DA9 940E 3C6A CALL	pop_xgsetF0FC
    01DAB 9624      ADIW	R28,4
    01DAC 9508      RET
_f_sync:
  tim                  --> Y,+2
  dir                  --> R22
  res                  --> R10
  fp                   --> R20
    01DAD 940E 3CB0 CALL	push_xgsetF03C
    01DAF 01A8      MOVW	R20,R16
    01DB0 9726      SBIW	R28,6
(2585) }
(2586) 
(2587) 
(2588) 
(2589) 
(2590) /*-----------------------------------------------------------------------*/
(2591) /* Synchronize the File Object                                           */
(2592) /*-----------------------------------------------------------------------*/
(2593) 
(2594) FRESULT f_sync (
(2595) 	FIL *fp		/* Pointer to the file object */
(2596) )
(2597) {
(2598) 	FRESULT res;
(2599) 	DWORD tim;
(2600) 	BYTE *dir;
(2601) 
(2602) 
(2603) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01DB1 01FA      MOVW	R30,R20
    01DB2 8122      LDD	R18,Z+2
    01DB3 8133      LDD	R19,Z+3
    01DB4 8100      LD	R16,Z
    01DB5 8111      LDD	R17,Z+1
    01DB6 D88E      RCALL	ff.c:validate
    01DB7 2EA0      MOV	R10,R16
(2604) 	if (res == FR_OK) {
    01DB8 2300      TST	R16
    01DB9 F009      BEQ	0x1DBB
    01DBA C09F      RJMP	0x1E5A
(2605) 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    01DBB 01FA      MOVW	R30,R20
    01DBC 8024      LDD	R2,Z+4
    01DBD FE25      SBRS	R2,5
    01DBE C09B      RJMP	0x1E5A
(2606) #if !_FS_TINY	/* Write-back dirty buffer */
(2607) 			if (fp->flag & FA__DIRTY) {
(2608) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2609) 					LEAVE_FF(fp->fs, FR_DISK_ERR);
(2610) 				fp->flag &= ~FA__DIRTY;
(2611) 			}
(2612) #endif
(2613) 			/* Update the directory entry */
(2614) 			res = move_window(fp->fs, fp->dir_sect);
    01DBF 8C22      LDD	R2,Z+26
    01DC0 8C33      LDD	R3,Z+27
    01DC1 8C44      LDD	R4,Z+28
    01DC2 8C55      LDD	R5,Z+29
    01DC3 8248      ST	Y,R4
    01DC4 8259      STD	Y+1,R5
    01DC5 0191      MOVW	R18,R2
    01DC6 8100      LD	R16,Z
    01DC7 8111      LDD	R17,Z+1
    01DC8 940E 032D CALL	ff.c:move_window
    01DCA 2EA0      MOV	R10,R16
(2615) 			if (res == FR_OK) {
    01DCB 2300      TST	R16
    01DCC F009      BEQ	0x1DCE
    01DCD C08C      RJMP	0x1E5A
(2616) 				dir = fp->dir_ptr;
    01DCE 01FA      MOVW	R30,R20
    01DCF 8D66      LDD	R22,Z+30
    01DD0 8D77      LDD	R23,Z+31
(2617) 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    01DD1 01CB      MOVW	R24,R22
    01DD2 960B      ADIW	R24,0xB
    01DD3 01FC      MOVW	R30,R24
    01DD4 8180      LD	R24,Z
    01DD5 6280      ORI	R24,0x20
    01DD6 8380      ST	Z,R24
(2618) 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    01DD7 01FA      MOVW	R30,R20
    01DD8 8422      LDD	R2,Z+10
    01DD9 8433      LDD	R3,Z+11
    01DDA 8444      LDD	R4,Z+12
    01DDB 8455      LDD	R5,Z+13
    01DDC 01FB      MOVW	R30,R22
    01DDD 8E24      STD	Z+28,R2
    01DDE 01FA      MOVW	R30,R20
    01DDF 8422      LDD	R2,Z+10
    01DE0 8433      LDD	R3,Z+11
    01DE1 2C23      MOV	R2,R3
    01DE2 2433      CLR	R3
    01DE3 01FB      MOVW	R30,R22
    01DE4 8E25      STD	Z+29,R2
    01DE5 01FA      MOVW	R30,R20
    01DE6 8422      LDD	R2,Z+10
    01DE7 8433      LDD	R3,Z+11
    01DE8 8444      LDD	R4,Z+12
    01DE9 8455      LDD	R5,Z+13
    01DEA 0112      MOVW	R2,R4
    01DEB 2444      CLR	R4
    01DEC 2455      CLR	R5
    01DED 01FB      MOVW	R30,R22
    01DEE 8E26      STD	Z+30,R2
    01DEF E188      LDI	R24,0x18
    01DF0 E090      LDI	R25,0
    01DF1 01FA      MOVW	R30,R20
    01DF2 8502      LDD	R16,Z+10
    01DF3 8513      LDD	R17,Z+11
    01DF4 8524      LDD	R18,Z+12
    01DF5 8535      LDD	R19,Z+13
    01DF6 938A      ST	-Y,R24
    01DF7 940E 3D10 CALL	lsr32
    01DF9 01FB      MOVW	R30,R22
    01DFA 8F07      STD	Z+31,R16
(2619) 				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    01DFB 01FA      MOVW	R30,R20
    01DFC 8426      LDD	R2,Z+14
    01DFD 8437      LDD	R3,Z+15
    01DFE 8840      LDD	R4,Z+16
    01DFF 8851      LDD	R5,Z+17
    01E00 01FB      MOVW	R30,R22
    01E01 8E22      STD	Z+26,R2
    01E02 01FA      MOVW	R30,R20
    01E03 8426      LDD	R2,Z+14
    01E04 8437      LDD	R3,Z+15
    01E05 2C23      MOV	R2,R3
    01E06 2433      CLR	R3
    01E07 01FB      MOVW	R30,R22
    01E08 8E23      STD	Z+27,R2
    01E09 01FA      MOVW	R30,R20
    01E0A 8426      LDD	R2,Z+14
    01E0B 8437      LDD	R3,Z+15
    01E0C 8840      LDD	R4,Z+16
    01E0D 8851      LDD	R5,Z+17
    01E0E 0112      MOVW	R2,R4
    01E0F 2444      CLR	R4
    01E10 2455      CLR	R5
    01E11 01FB      MOVW	R30,R22
    01E12 8A24      STD	Z+20,R2
    01E13 01FA      MOVW	R30,R20
    01E14 8426      LDD	R2,Z+14
    01E15 8437      LDD	R3,Z+15
    01E16 8840      LDD	R4,Z+16
    01E17 8851      LDD	R5,Z+17
    01E18 0112      MOVW	R2,R4
    01E19 2C23      MOV	R2,R3
    01E1A 2433      CLR	R3
    01E1B 01FB      MOVW	R30,R22
    01E1C 8A25      STD	Z+21,R2
(2620) 				tim = get_fattime();						/* Update updated time */
    01E1D 940E 02CF CALL	_get_fattime
    01E1F 830A      STD	Y+2,R16
    01E20 831B      STD	Y+3,R17
    01E21 832C      STD	Y+4,R18
    01E22 833D      STD	Y+5,R19
(2621) 				ST_DWORD(dir+DIR_WrtTime, tim);
    01E23 802A      LDD	R2,Y+2
    01E24 803B      LDD	R3,Y+3
    01E25 804C      LDD	R4,Y+4
    01E26 805D      LDD	R5,Y+5
    01E27 01FB      MOVW	R30,R22
    01E28 8A26      STD	Z+22,R2
    01E29 2C23      MOV	R2,R3
    01E2A 2433      CLR	R3
    01E2B 9677      ADIW	R30,0x17
    01E2C 8220      ST	Z,R2
    01E2D 802A      LDD	R2,Y+2
    01E2E 803B      LDD	R3,Y+3
    01E2F 804C      LDD	R4,Y+4
    01E30 805D      LDD	R5,Y+5
    01E31 0112      MOVW	R2,R4
    01E32 2444      CLR	R4
    01E33 2455      CLR	R5
    01E34 01FB      MOVW	R30,R22
    01E35 9678      ADIW	R30,0x18
    01E36 8220      ST	Z,R2
    01E37 E188      LDI	R24,0x18
    01E38 E090      LDI	R25,0
    01E39 810A      LDD	R16,Y+2
    01E3A 811B      LDD	R17,Y+3
    01E3B 812C      LDD	R18,Y+4
    01E3C 813D      LDD	R19,Y+5
    01E3D 938A      ST	-Y,R24
    01E3E 940E 3D10 CALL	lsr32
    01E40 01FB      MOVW	R30,R22
    01E41 8F01      STD	Z+25,R16
(2622) 				fp->flag &= ~FA__WRITTEN;
    01E42 01BA      MOVW	R22,R20
    01E43 5F6C      SUBI	R22,0xFC
    01E44 4F7F      SBCI	R23,0xFF
    01E45 01FB      MOVW	R30,R22
    01E46 8180      LD	R24,Z
    01E47 7D8F      ANDI	R24,0xDF
    01E48 8380      ST	Z,R24
(2623) 				fp->fs->wflag = 1;
    01E49 E081      LDI	R24,1
    01E4A 01FA      MOVW	R30,R20
    01E4B 93AF      PUSH	R26
    01E4C 93BF      PUSH	R27
    01E4D 81A0      LD	R26,Z
    01E4E 81B1      LDD	R27,Z+1
    01E4F 01FD      MOVW	R30,R26
    01E50 91BF      POP	R27
    01E51 91AF      POP	R26
    01E52 8384      STD	Z+4,R24
(2624) 				res = sync(fp->fs);
    01E53 01FA      MOVW	R30,R20
    01E54 8100      LD	R16,Z
    01E55 8111      LDD	R17,Z+1
    01E56 940E 03CF CALL	ff.c:sync
    01E58 2EC0      MOV	R12,R16
    01E59 2CAC      MOV	R10,R12
(2625) 			}
(2626) 		}
(2627) 	}
(2628) 
(2629) 	LEAVE_FF(fp->fs, res);
    01E5A 2D0A      MOV	R16,R10
    01E5B 9626      ADIW	R28,6
    01E5C 940C 3CB9 JMP	pop_xgsetF03C
_f_close:
  res                  --> R10
  fp                   --> R12
    01E5E 940E 3C7B CALL	push_xgset003C
    01E60 0168      MOVW	R12,R16
(2630) }
(2631) 
(2632) #endif /* !_FS_READONLY */
(2633) 
(2634) 
(2635) 
(2636) 
(2637) /*-----------------------------------------------------------------------*/
(2638) /* Close File                                                            */
(2639) /*-----------------------------------------------------------------------*/
(2640) 
(2641) FRESULT f_close (
(2642) 	FIL *fp		/* Pointer to the file object to be closed */
(2643) )
(2644) {
(2645) 	FRESULT res;
(2646) 
(2647) #if _FS_READONLY
(2648) 	FATFS *fs = fp->fs;
(2649) 	res = validate(fs, fp->id);
(2650) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
(2651) 	LEAVE_FF(fs, res);
(2652) 
(2653) #else
(2654) 	res = f_sync(fp);		/* Flush cached data */
    01E61 0186      MOVW	R16,R12
    01E62 DF4A      RCALL	_f_sync
    01E63 2EA0      MOV	R10,R16
(2655) #if _FS_SHARE
(2656) 	if (res == FR_OK) {		/* Decrement open counter */
(2657) #if _FS_REENTRANT
(2658) 		res = validate(fp->fs, fp->id);
(2659) 		if (res == FR_OK) {
(2660) 			res = dec_lock(fp->lockid);	
(2661) 			unlock_fs(fp->fs, FR_OK);
(2662) 		}
(2663) #else
(2664) 		res = dec_lock(fp->lockid);
(2665) #endif
(2666) 	}
(2667) #endif
(2668) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    01E64 2300      TST	R16
    01E65 F429      BNE	0x1E6B
    01E66 2422      CLR	R2
    01E67 2433      CLR	R3
    01E68 01F6      MOVW	R30,R12
    01E69 8231      STD	Z+1,R3
    01E6A 8220      ST	Z,R2
(2669) 	return res;
    01E6B 2D0A      MOV	R16,R10
    01E6C 940C 3C55 JMP	pop_xgset003C
_f_lseek:
  ifptr                --> Y,+14
  nsect                --> Y,+10
  bcs                  --> Y,+6
  clst                 --> Y,+2
  dsc                  --> Y,+26
  tlen                 --> Y,+22
  tbl                  --> R14
  tcl                  --> Y,+18
  ulen                 --> Y,+14
  ncl                  --> Y,+10
  pcl                  --> Y,+6
  cl                   --> Y,+2
  res                  --> R10
  ofs                  --> Y,+42
  fp                   --> Y,+40
    01E6E 940E 3B30 CALL	push_arg4
    01E70 940E 3C75 CALL	push_xgsetF0FC
    01E72 976E      SBIW	R28,0x1E
(2670) #endif
(2671) }
(2672) 
(2673) 
(2674) 
(2675) 
(2676) /*-----------------------------------------------------------------------*/
(2677) /* Current Drive/Directory Handlings                                     */
(2678) /*-----------------------------------------------------------------------*/
(2679) 
(2680) #if _FS_RPATH >= 1
(2681) 
(2682) FRESULT f_chdrive (
(2683) 	BYTE drv		/* Drive number */
(2684) )
(2685) {
(2686) 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
(2687) 
(2688) 	CurrVol = drv;
(2689) 
(2690) 	return FR_OK;
(2691) }
(2692) 
(2693) 
(2694) 
(2695) FRESULT f_chdir (
(2696) 	const TCHAR *path	/* Pointer to the directory path */
(2697) )
(2698) {
(2699) 	FRESULT res;
(2700) 	DIR dj;
(2701) 	DEF_NAMEBUF;
(2702) 
(2703) 
(2704) 	res = chk_mounted(&path, &dj.fs, 0);
(2705) 	if (res == FR_OK) {
(2706) 		INIT_BUF(dj);
(2707) 		res = follow_path(&dj, path);		/* Follow the path */
(2708) 		FREE_BUF();
(2709) 		if (res == FR_OK) {					/* Follow completed */
(2710) 			if (!dj.dir) {
(2711) 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
(2712) 			} else {
(2713) 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
(2714) 					dj.fs->cdir = LD_CLUST(dj.dir);
(2715) 				else
(2716) 					res = FR_NO_PATH;		/* Reached but a file */
(2717) 			}
(2718) 		}
(2719) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
(2720) 	}
(2721) 
(2722) 	LEAVE_FF(dj.fs, res);
(2723) }
(2724) 
(2725) 
(2726) #if _FS_RPATH >= 2
(2727) FRESULT f_getcwd (
(2728) 	TCHAR *path,	/* Pointer to the directory path */
(2729) 	UINT sz_path	/* Size of path */
(2730) )
(2731) {
(2732) 	FRESULT res;
(2733) 	DIR dj;
(2734) 	UINT i, n;
(2735) 	DWORD ccl;
(2736) 	TCHAR *tp;
(2737) 	FILINFO fno;
(2738) 	DEF_NAMEBUF;
(2739) 
(2740) 
(2741) 	*path = 0;
(2742) 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
(2743) 	if (res == FR_OK) {
(2744) 		INIT_BUF(dj);
(2745) 		i = sz_path;		/* Bottom of buffer (dir stack base) */
(2746) 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
(2747) 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
(2748) 			res = dir_sdi(&dj, 1);			/* Get parent dir */
(2749) 			if (res != FR_OK) break;
(2750) 			res = dir_read(&dj);
(2751) 			if (res != FR_OK) break;
(2752) 			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
(2753) 			res = dir_sdi(&dj, 0);
(2754) 			if (res != FR_OK) break;
(2755) 			do {							/* Find the entry links to the child dir */
(2756) 				res = dir_read(&dj);
(2757) 				if (res != FR_OK) break;
(2758) 				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
(2759) 				res = dir_next(&dj, 0);	
(2760) 			} while (res == FR_OK);
(2761) 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
(2762) 			if (res != FR_OK) break;
(2763) #if _USE_LFN
(2764) 			fno.lfname = path;
(2765) 			fno.lfsize = i;
(2766) #endif
(2767) 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
(2768) 			tp = fno.fname;
(2769) 			if (_USE_LFN && *path) tp = path;
(2770) 			for (n = 0; tp[n]; n++) ;
(2771) 			if (i < n + 3) {
(2772) 				res = FR_NOT_ENOUGH_CORE; break;
(2773) 			}
(2774) 			while (n) path[--i] = tp[--n];
(2775) 			path[--i] = '/';
(2776) 		}
(2777) 		tp = path;
(2778) 		if (res == FR_OK) {
(2779) 			*tp++ = '0' + CurrVol;			/* Put drive number */
(2780) 			*tp++ = ':';
(2781) 			if (i == sz_path) {				/* Root-dir */
(2782) 				*tp++ = '/';
(2783) 			} else {						/* Sub-dir */
(2784) 				do		/* Add stacked path str */
(2785) 					*tp++ = path[i++];
(2786) 				while (i < sz_path);
(2787) 			}
(2788) 		}
(2789) 		*tp = 0;
(2790) 		FREE_BUF();
(2791) 	}
(2792) 
(2793) 	LEAVE_FF(dj.fs, res);
(2794) }
(2795) #endif /* _FS_RPATH >= 2 */
(2796) #endif /* _FS_RPATH >= 1 */
(2797) 
(2798) 
(2799) 
(2800) #if _FS_MINIMIZE <= 2
(2801) /*-----------------------------------------------------------------------*/
(2802) /* Seek File R/W Pointer                                                 */
(2803) /*-----------------------------------------------------------------------*/
(2804) 
(2805) FRESULT f_lseek (
(2806) 	FIL *fp,		/* Pointer to the file object */
(2807) 	DWORD ofs		/* File pointer from top of file */
(2808) )
(2809) {
(2810) 	FRESULT res;
(2811) 
(2812) 
(2813) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01E73 A5E8      LDD	R30,Y+40
    01E74 A5F9      LDD	R31,Y+41
    01E75 8122      LDD	R18,Z+2
    01E76 8133      LDD	R19,Z+3
    01E77 8100      LD	R16,Z
    01E78 8111      LDD	R17,Z+1
    01E79 940E 1645 CALL	ff.c:validate
    01E7B 2EA0      MOV	R10,R16
(2814) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01E7C 2300      TST	R16
    01E7D F009      BEQ	0x1E7F
    01E7E C4A7      RJMP	0x2326
(2815) 	if (fp->flag & FA__ERROR)			/* Check abort flag */
    01E7F A5E8      LDD	R30,Y+40
    01E80 A5F9      LDD	R31,Y+41
    01E81 8024      LDD	R2,Z+4
    01E82 FE27      SBRS	R2,7
    01E83 C002      RJMP	0x1E86
(2816) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01E84 E002      LDI	R16,2
    01E85 C4A0      RJMP	0x2326
(2817) 
(2818) #if _USE_FASTSEEK
(2819) 	if (fp->cltbl) {	/* Fast seek */
    01E86 A5E8      LDD	R30,Y+40
    01E87 A5F9      LDD	R31,Y+41
    01E88 96B0      ADIW	R30,0x20
    01E89 8020      LD	R2,Z
    01E8A 8031      LDD	R3,Z+1
    01E8B 2022      TST	R2
    01E8C F419      BNE	0x1E90
    01E8D 2033      TST	R3
    01E8E F409      BNE	0x1E90
    01E8F C1E3      RJMP	0x2073
(2820) 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
(2821) 
(2822) 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
    01E90 EF4F      LDI	R20,0xFF
    01E91 EF5F      LDI	R21,0xFF
    01E92 EF6F      LDI	R22,0xFF
    01E93 EF7F      LDI	R23,0xFF
    01E94 A42A      LDD	R2,Y+42
    01E95 A43B      LDD	R3,Y+43
    01E96 A44C      LDD	R4,Y+44
    01E97 A45D      LDD	R5,Y+45
    01E98 1624      CP	R2,R20
    01E99 0635      CPC	R3,R21
    01E9A 0646      CPC	R4,R22
    01E9B 0657      CPC	R5,R23
    01E9C F009      BEQ	0x1E9E
    01E9D C109      RJMP	0x1FA7
(2823) 			tbl = fp->cltbl;
    01E9E A5E8      LDD	R30,Y+40
    01E9F A5F9      LDD	R31,Y+41
    01EA0 A0E0      LDD	R14,Z+32
    01EA1 A0F1      LDD	R15,Z+33
(2824) 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
    01EA2 01F7      MOVW	R30,R14
    01EA3 9021      LD	R2,Z+
    01EA4 9031      LD	R3,Z+
    01EA5 9041      LD	R4,Z+
    01EA6 9051      LD	R5,Z+
    01EA7 017F      MOVW	R14,R30
    01EA8 8A2E      STD	Y+22,R2
    01EA9 8A3F      STD	Y+23,R3
    01EAA 8E48      STD	Y+24,R4
    01EAB 8E59      STD	Y+25,R5
    01EAC E082      LDI	R24,2
    01EAD 878E      STD	Y+14,R24
    01EAE E080      LDI	R24,0
    01EAF 878F      STD	Y+15,R24
    01EB0 8B88      STD	Y+16,R24
    01EB1 8B89      STD	Y+17,R24
(2825) 			cl = fp->sclust;			/* Top of the chain */
    01EB2 A5E8      LDD	R30,Y+40
    01EB3 A5F9      LDD	R31,Y+41
    01EB4 963E      ADIW	R30,0xE
    01EB5 8020      LD	R2,Z
    01EB6 8031      LDD	R3,Z+1
    01EB7 8042      LDD	R4,Z+2
    01EB8 8053      LDD	R5,Z+3
    01EB9 822A      STD	Y+2,R2
    01EBA 823B      STD	Y+3,R3
    01EBB 824C      STD	Y+4,R4
    01EBC 825D      STD	Y+5,R5
(2826) 			if (cl) {
    01EBD 802A      LDD	R2,Y+2
    01EBE 803B      LDD	R3,Y+3
    01EBF 804C      LDD	R4,Y+4
    01EC0 805D      LDD	R5,Y+5
    01EC1 9488      BCLR	0
    01EC2 2022      TST	R2
    01EC3 0432      CPC	R3,R2
    01EC4 0442      CPC	R4,R2
    01EC5 0452      CPC	R5,R2
    01EC6 F409      BNE	0x1EC8
    01EC7 C0BB      RJMP	0x1F83
(2827) 				do {
(2828) 					/* Get a fragment */
(2829) 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
    01EC8 802A      LDD	R2,Y+2
    01EC9 803B      LDD	R3,Y+3
    01ECA 804C      LDD	R4,Y+4
    01ECB 805D      LDD	R5,Y+5
    01ECC 8A2A      STD	Y+18,R2
    01ECD 8A3B      STD	Y+19,R3
    01ECE 8A4C      STD	Y+20,R4
    01ECF 8A5D      STD	Y+21,R5
    01ED0 E080      LDI	R24,0
    01ED1 878A      STD	Y+10,R24
    01ED2 878B      STD	Y+11,R24
    01ED3 878C      STD	Y+12,R24
    01ED4 878D      STD	Y+13,R24
    01ED5 E042      LDI	R20,2
    01ED6 E050      LDI	R21,0
    01ED7 E060      LDI	R22,0
    01ED8 E070      LDI	R23,0
    01ED9 842E      LDD	R2,Y+14
    01EDA 843F      LDD	R3,Y+15
    01EDB 8848      LDD	R4,Y+16
    01EDC 8859      LDD	R5,Y+17
    01EDD 0E24      ADD	R2,R20
    01EDE 1E35      ADC	R3,R21
    01EDF 1E46      ADC	R4,R22
    01EE0 1E57      ADC	R5,R23
    01EE1 862E      STD	Y+14,R2
    01EE2 863F      STD	Y+15,R3
    01EE3 8A48      STD	Y+16,R4
    01EE4 8A59      STD	Y+17,R5
(2830) 					do {
(2831) 						pcl = cl; ncl++;
    01EE5 802A      LDD	R2,Y+2
    01EE6 803B      LDD	R3,Y+3
    01EE7 804C      LDD	R4,Y+4
    01EE8 805D      LDD	R5,Y+5
    01EE9 822E      STD	Y+6,R2
    01EEA 823F      STD	Y+7,R3
    01EEB 8648      STD	Y+8,R4
    01EEC 8659      STD	Y+9,R5
    01EED E041      LDI	R20,1
    01EEE E050      LDI	R21,0
    01EEF E060      LDI	R22,0
    01EF0 E070      LDI	R23,0
    01EF1 842A      LDD	R2,Y+10
    01EF2 843B      LDD	R3,Y+11
    01EF3 844C      LDD	R4,Y+12
    01EF4 845D      LDD	R5,Y+13
    01EF5 0E24      ADD	R2,R20
    01EF6 1E35      ADC	R3,R21
    01EF7 1E46      ADC	R4,R22
    01EF8 1E57      ADC	R5,R23
    01EF9 862A      STD	Y+10,R2
    01EFA 863B      STD	Y+11,R3
    01EFB 864C      STD	Y+12,R4
    01EFC 865D      STD	Y+13,R5
(2832) 						cl = get_fat(fp->fs, cl);
    01EFD 802A      LDD	R2,Y+2
    01EFE 803B      LDD	R3,Y+3
    01EFF 804C      LDD	R4,Y+4
    01F00 805D      LDD	R5,Y+5
    01F01 8248      ST	Y,R4
    01F02 8259      STD	Y+1,R5
    01F03 0191      MOVW	R18,R2
    01F04 A5E8      LDD	R30,Y+40
    01F05 A5F9      LDD	R31,Y+41
    01F06 8100      LD	R16,Z
    01F07 8111      LDD	R17,Z+1
    01F08 940E 04F6 CALL	_get_fat
    01F0A 830A      STD	Y+2,R16
    01F0B 831B      STD	Y+3,R17
    01F0C 832C      STD	Y+4,R18
    01F0D 833D      STD	Y+5,R19
(2833) 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
    01F0E E041      LDI	R20,1
    01F0F E050      LDI	R21,0
    01F10 E060      LDI	R22,0
    01F11 E070      LDI	R23,0
    01F12 802A      LDD	R2,Y+2
    01F13 803B      LDD	R3,Y+3
    01F14 804C      LDD	R4,Y+4
    01F15 805D      LDD	R5,Y+5
    01F16 1542      CP	R20,R2
    01F17 0553      CPC	R21,R3
    01F18 0564      CPC	R22,R4
    01F19 0575      CPC	R23,R5
    01F1A F048      BCS	0x1F24
    01F1B A588      LDD	R24,Y+40
    01F1C A599      LDD	R25,Y+41
    01F1D 9604      ADIW	R24,4
    01F1E 01FC      MOVW	R30,R24
    01F1F 8180      LD	R24,Z
    01F20 6880      ORI	R24,0x80
    01F21 8380      ST	Z,R24
    01F22 E002      LDI	R16,2
    01F23 C402      RJMP	0x2326
(2834) 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01F24 EF4F      LDI	R20,0xFF
    01F25 EF5F      LDI	R21,0xFF
    01F26 EF6F      LDI	R22,0xFF
    01F27 EF7F      LDI	R23,0xFF
    01F28 802A      LDD	R2,Y+2
    01F29 803B      LDD	R3,Y+3
    01F2A 804C      LDD	R4,Y+4
    01F2B 805D      LDD	R5,Y+5
    01F2C 1624      CP	R2,R20
    01F2D 0635      CPC	R3,R21
    01F2E 0646      CPC	R4,R22
    01F2F 0657      CPC	R5,R23
    01F30 F451      BNE	0x1F3B
    01F31 A588      LDD	R24,Y+40
    01F32 A599      LDD	R25,Y+41
    01F33 9604      ADIW	R24,4
    01F34 016C      MOVW	R12,R24
    01F35 01FC      MOVW	R30,R24
    01F36 8180      LD	R24,Z
    01F37 6880      ORI	R24,0x80
    01F38 8380      ST	Z,R24
    01F39 E001      LDI	R16,1
    01F3A C3EB      RJMP	0x2326
(2835) 					} while (cl == pcl + 1);
    01F3B E041      LDI	R20,1
    01F3C E050      LDI	R21,0
    01F3D E060      LDI	R22,0
    01F3E E070      LDI	R23,0
    01F3F 802E      LDD	R2,Y+6
    01F40 803F      LDD	R3,Y+7
    01F41 8448      LDD	R4,Y+8
    01F42 8459      LDD	R5,Y+9
    01F43 0E24      ADD	R2,R20
    01F44 1E35      ADC	R3,R21
    01F45 1E46      ADC	R4,R22
    01F46 1E57      ADC	R5,R23
    01F47 806A      LDD	R6,Y+2
    01F48 807B      LDD	R7,Y+3
    01F49 808C      LDD	R8,Y+4
    01F4A 809D      LDD	R9,Y+5
    01F4B 1462      CP	R6,R2
    01F4C 0473      CPC	R7,R3
    01F4D 0484      CPC	R8,R4
    01F4E 0495      CPC	R9,R5
    01F4F F409      BNE	0x1F51
    01F50 CF94      RJMP	0x1EE5
(2836) 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
    01F51 882E      LDD	R2,Y+22
    01F52 883F      LDD	R3,Y+23
    01F53 8C48      LDD	R4,Y+24
    01F54 8C59      LDD	R5,Y+25
    01F55 846E      LDD	R6,Y+14
    01F56 847F      LDD	R7,Y+15
    01F57 8888      LDD	R8,Y+16
    01F58 8899      LDD	R9,Y+17
    01F59 1426      CP	R2,R6
    01F5A 0437      CPC	R3,R7
    01F5B 0448      CPC	R4,R8
    01F5C 0459      CPC	R5,R9
    01F5D F090      BCS	0x1F70
(2837) 						*tbl++ = ncl; *tbl++ = tcl;
    01F5E 842A      LDD	R2,Y+10
    01F5F 843B      LDD	R3,Y+11
    01F60 844C      LDD	R4,Y+12
    01F61 845D      LDD	R5,Y+13
    01F62 01F7      MOVW	R30,R14
    01F63 9221      ST	Z+,R2
    01F64 9231      ST	Z+,R3
    01F65 9241      ST	Z+,R4
    01F66 9251      ST	Z+,R5
    01F67 882A      LDD	R2,Y+18
    01F68 883B      LDD	R3,Y+19
    01F69 884C      LDD	R4,Y+20
    01F6A 885D      LDD	R5,Y+21
    01F6B 9221      ST	Z+,R2
    01F6C 9231      ST	Z+,R3
    01F6D 9241      ST	Z+,R4
    01F6E 9251      ST	Z+,R5
    01F6F 017F      MOVW	R14,R30
(2838) 					}
(2839) 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
    01F70 A5E8      LDD	R30,Y+40
    01F71 A5F9      LDD	R31,Y+41
    01F72 81A0      LD	R26,Z
    01F73 81B1      LDD	R27,Z+1
    01F74 9656      ADIW	R26,0x16
    01F75 902D      LD	R2,X+
    01F76 903D      LD	R3,X+
    01F77 904D      LD	R4,X+
    01F78 905C      LD	R5,X
    01F79 806A      LDD	R6,Y+2
    01F7A 807B      LDD	R7,Y+3
    01F7B 808C      LDD	R8,Y+4
    01F7C 809D      LDD	R9,Y+5
    01F7D 1462      CP	R6,R2
    01F7E 0473      CPC	R7,R3
    01F7F 0484      CPC	R8,R4
    01F80 0495      CPC	R9,R5
    01F81 F408      BCC	0x1F83
    01F82 CF45      RJMP	0x1EC8
(2840) 			}
(2841) 			*fp->cltbl = ulen;	/* Number of items used */
    01F83 842E      LDD	R2,Y+14
    01F84 843F      LDD	R3,Y+15
    01F85 8848      LDD	R4,Y+16
    01F86 8859      LDD	R5,Y+17
    01F87 A5E8      LDD	R30,Y+40
    01F88 A5F9      LDD	R31,Y+41
    01F89 96B0      ADIW	R30,0x20
    01F8A 81A0      LD	R26,Z
    01F8B 81B1      LDD	R27,Z+1
    01F8C 922D      ST	X+,R2
    01F8D 923D      ST	X+,R3
    01F8E 924D      ST	X+,R4
    01F8F 925C      ST	X,R5
(2842) 			if (ulen <= tlen)
    01F90 882E      LDD	R2,Y+22
    01F91 883F      LDD	R3,Y+23
    01F92 8C48      LDD	R4,Y+24
    01F93 8C59      LDD	R5,Y+25
    01F94 846E      LDD	R6,Y+14
    01F95 847F      LDD	R7,Y+15
    01F96 8888      LDD	R8,Y+16
    01F97 8899      LDD	R9,Y+17
    01F98 1426      CP	R2,R6
    01F99 0437      CPC	R3,R7
    01F9A 0448      CPC	R4,R8
    01F9B 0459      CPC	R5,R9
    01F9C F038      BCS	0x1FA4
(2843) 				*tbl = 0;		/* Terminate table */
    01F9D 01F7      MOVW	R30,R14
    01F9E E080      LDI	R24,0
    01F9F 8380      ST	Z,R24
    01FA0 8381      STD	Z+1,R24
    01FA1 8382      STD	Z+2,R24
    01FA2 8383      STD	Z+3,R24
    01FA3 C381      RJMP	0x2325
(2844) 			else
(2845) 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
    01FA4 E181      LDI	R24,0x11
    01FA5 2EA8      MOV	R10,R24
(2846) 
(2847) 		} else {						/* Fast seek */
    01FA6 C37E      RJMP	0x2325
(2848) 			if (ofs > fp->fsize)		/* Clip offset at the file size */
    01FA7 A5E8      LDD	R30,Y+40
    01FA8 A5F9      LDD	R31,Y+41
    01FA9 963A      ADIW	R30,0xA
    01FAA 8020      LD	R2,Z
    01FAB 8031      LDD	R3,Z+1
    01FAC 8042      LDD	R4,Z+2
    01FAD 8053      LDD	R5,Z+3
    01FAE A46A      LDD	R6,Y+42
    01FAF A47B      LDD	R7,Y+43
    01FB0 A48C      LDD	R8,Y+44
    01FB1 A49D      LDD	R9,Y+45
    01FB2 1426      CP	R2,R6
    01FB3 0437      CPC	R3,R7
    01FB4 0448      CPC	R4,R8
    01FB5 0459      CPC	R5,R9
    01FB6 F458      BCC	0x1FC2
(2849) 				ofs = fp->fsize;
    01FB7 A5E8      LDD	R30,Y+40
    01FB8 A5F9      LDD	R31,Y+41
    01FB9 963A      ADIW	R30,0xA
    01FBA 8020      LD	R2,Z
    01FBB 8031      LDD	R3,Z+1
    01FBC 8042      LDD	R4,Z+2
    01FBD 8053      LDD	R5,Z+3
    01FBE A62A      STD	Y+42,R2
    01FBF A63B      STD	Y+43,R3
    01FC0 A64C      STD	Y+44,R4
    01FC1 A65D      STD	Y+45,R5
(2850) 			fp->fptr = ofs;				/* Set file pointer */
    01FC2 A42A      LDD	R2,Y+42
    01FC3 A43B      LDD	R3,Y+43
    01FC4 A44C      LDD	R4,Y+44
    01FC5 A45D      LDD	R5,Y+45
    01FC6 A5E8      LDD	R30,Y+40
    01FC7 A5F9      LDD	R31,Y+41
    01FC8 9636      ADIW	R30,6
    01FC9 8220      ST	Z,R2
    01FCA 8231      STD	Z+1,R3
    01FCB 8242      STD	Z+2,R4
    01FCC 8253      STD	Z+3,R5
(2851) 			if (ofs) {
    01FCD 9488      BCLR	0
    01FCE 2022      TST	R2
    01FCF 0432      CPC	R3,R2
    01FD0 0442      CPC	R4,R2
    01FD1 0452      CPC	R5,R2
    01FD2 F409      BNE	0x1FD4
    01FD3 C351      RJMP	0x2325
(2852) 				fp->clust = clmt_clust(fp, ofs - 1);
    01FD4 E041      LDI	R20,1
    01FD5 E050      LDI	R21,0
    01FD6 E060      LDI	R22,0
    01FD7 E070      LDI	R23,0
    01FD8 1A24      SUB	R2,R20
    01FD9 0A35      SBC	R3,R21
    01FDA 0A46      SBC	R4,R22
    01FDB 0A57      SBC	R5,R23
    01FDC 8248      ST	Y,R4
    01FDD 8259      STD	Y+1,R5
    01FDE 0191      MOVW	R18,R2
    01FDF A508      LDD	R16,Y+40
    01FE0 A519      LDD	R17,Y+41
    01FE1 940E 0A30 CALL	ff.c:clmt_clust
    01FE3 A5E8      LDD	R30,Y+40
    01FE4 A5F9      LDD	R31,Y+41
    01FE5 8B02      STD	Z+18,R16
    01FE6 8B13      STD	Z+19,R17
    01FE7 8B24      STD	Z+20,R18
    01FE8 8B35      STD	Z+21,R19
(2853) 				dsc = clust2sect(fp->fs, fp->clust);
    01FE9 8822      LDD	R2,Z+18
    01FEA 8833      LDD	R3,Z+19
    01FEB 8844      LDD	R4,Z+20
    01FEC 8855      LDD	R5,Z+21
    01FED 8248      ST	Y,R4
    01FEE 8259      STD	Y+1,R5
    01FEF 0191      MOVW	R18,R2
    01FF0 8100      LD	R16,Z
    01FF1 8111      LDD	R17,Z+1
    01FF2 940E 04A4 CALL	_clust2sect
    01FF4 8F0A      STD	Y+26,R16
    01FF5 8F1B      STD	Y+27,R17
    01FF6 8F2C      STD	Y+28,R18
    01FF7 8F3D      STD	Y+29,R19
(2854) 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
    01FF8 8C2A      LDD	R2,Y+26
    01FF9 8C3B      LDD	R3,Y+27
    01FFA 8C4C      LDD	R4,Y+28
    01FFB 8C5D      LDD	R5,Y+29
    01FFC 9488      BCLR	0
    01FFD 2022      TST	R2
    01FFE 0432      CPC	R3,R2
    01FFF 0442      CPC	R4,R2
    02000 0452      CPC	R5,R2
    02001 F451      BNE	0x200C
    02002 A588      LDD	R24,Y+40
    02003 A599      LDD	R25,Y+41
    02004 9604      ADIW	R24,4
    02005 017C      MOVW	R14,R24
    02006 01FC      MOVW	R30,R24
    02007 8180      LD	R24,Z
    02008 6880      ORI	R24,0x80
    02009 8380      ST	Z,R24
    0200A E002      LDI	R16,2
    0200B C31A      RJMP	0x2326
(2855) 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
    0200C E041      LDI	R20,1
    0200D E050      LDI	R21,0
    0200E E060      LDI	R22,0
    0200F E070      LDI	R23,0
    02010 A50A      LDD	R16,Y+42
    02011 A51B      LDD	R17,Y+43
    02012 A52C      LDD	R18,Y+44
    02013 A53D      LDD	R19,Y+45
    02014 1B04      SUB	R16,R20
    02015 0B15      SBC	R17,R21
    02016 0B26      SBC	R18,R22
    02017 0B37      SBC	R19,R23
    02018 E089      LDI	R24,0x9
    02019 E090      LDI	R25,0
    0201A 938A      ST	-Y,R24
    0201B 940E 3D10 CALL	lsr32
    0201D 0118      MOVW	R2,R16
    0201E 0129      MOVW	R4,R18
    0201F A5E8      LDD	R30,Y+40
    02020 A5F9      LDD	R31,Y+41
    02021 93AF      PUSH	R26
    02022 93BF      PUSH	R27
    02023 81A0      LD	R26,Z
    02024 81B1      LDD	R27,Z+1
    02025 01FD      MOVW	R30,R26
    02026 91BF      POP	R27
    02027 91AF      POP	R26
    02028 9632      ADIW	R30,2
    02029 8180      LD	R24,Z
    0202A 2799      CLR	R25
    0202B 9701      SBIW	R24,1
    0202C 013C      MOVW	R6,R24
    0202D 2488      CLR	R8
    0202E FC77      SBRC	R7,7
    0202F 9480      COM	R8
    02030 2499      CLR	R9
    02031 FC87      SBRC	R8,7
    02032 9490      COM	R9
    02033 2026      AND	R2,R6
    02034 2037      AND	R3,R7
    02035 2048      AND	R4,R8
    02036 2059      AND	R5,R9
    02037 8C6A      LDD	R6,Y+26
    02038 8C7B      LDD	R7,Y+27
    02039 8C8C      LDD	R8,Y+28
    0203A 8C9D      LDD	R9,Y+29
    0203B 0C62      ADD	R6,R2
    0203C 1C73      ADC	R7,R3
    0203D 1C84      ADC	R8,R4
    0203E 1C95      ADC	R9,R5
    0203F 8E6A      STD	Y+26,R6
    02040 8E7B      STD	Y+27,R7
    02041 8E8C      STD	Y+28,R8
    02042 8E9D      STD	Y+29,R9
(2856) 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
    02043 EF4F      LDI	R20,0xFF
    02044 E051      LDI	R21,1
    02045 E060      LDI	R22,0
    02046 E070      LDI	R23,0
    02047 A5E8      LDD	R30,Y+40
    02048 A5F9      LDD	R31,Y+41
    02049 9636      ADIW	R30,6
    0204A 8020      LD	R2,Z
    0204B 8031      LDD	R3,Z+1
    0204C 8042      LDD	R4,Z+2
    0204D 8053      LDD	R5,Z+3
    0204E 2224      AND	R2,R20
    0204F 2235      AND	R3,R21
    02050 2246      AND	R4,R22
    02051 2257      AND	R5,R23
    02052 9488      BCLR	0
    02053 2022      TST	R2
    02054 0432      CPC	R3,R2
    02055 0442      CPC	R4,R2
    02056 0452      CPC	R5,R2
    02057 F409      BNE	0x2059
    02058 C2CC      RJMP	0x2325
    02059 A5E8      LDD	R30,Y+40
    0205A A5F9      LDD	R31,Y+41
    0205B 9676      ADIW	R30,0x16
    0205C 8020      LD	R2,Z
    0205D 8031      LDD	R3,Z+1
    0205E 8042      LDD	R4,Z+2
    0205F 8053      LDD	R5,Z+3
    02060 8C6A      LDD	R6,Y+26
    02061 8C7B      LDD	R7,Y+27
    02062 8C8C      LDD	R8,Y+28
    02063 8C9D      LDD	R9,Y+29
    02064 1462      CP	R6,R2
    02065 0473      CPC	R7,R3
    02066 0484      CPC	R8,R4
    02067 0495      CPC	R9,R5
    02068 F409      BNE	0x206A
    02069 C2BB      RJMP	0x2325
(2857) #if !_FS_TINY
(2858) #if !_FS_READONLY
(2859) 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2860) 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2861) 							ABORT(fp->fs, FR_DISK_ERR);
(2862) 						fp->flag &= ~FA__DIRTY;
(2863) 					}
(2864) #endif
(2865) 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
(2866) 						ABORT(fp->fs, FR_DISK_ERR);
(2867) #endif
(2868) 					fp->dsect = dsc;
    0206A 0113      MOVW	R2,R6
    0206B 0124      MOVW	R4,R8
    0206C A5E8      LDD	R30,Y+40
    0206D A5F9      LDD	R31,Y+41
    0206E 8A26      STD	Z+22,R2
    0206F 8A37      STD	Z+23,R3
    02070 8E40      STD	Z+24,R4
    02071 8E51      STD	Z+25,R5
(2869) 				}
(2870) 			}
(2871) 		}
(2872) 	} else
    02072 C2B2      RJMP	0x2325
(2873) #endif
(2874) 
(2875) 	/* Normal Seek */
(2876) 	{
(2877) 		DWORD clst, bcs, nsect, ifptr;
(2878) 
(2879) 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    02073 A5E8      LDD	R30,Y+40
    02074 A5F9      LDD	R31,Y+41
    02075 963A      ADIW	R30,0xA
    02076 8020      LD	R2,Z
    02077 8031      LDD	R3,Z+1
    02078 8042      LDD	R4,Z+2
    02079 8053      LDD	R5,Z+3
    0207A A46A      LDD	R6,Y+42
    0207B A47B      LDD	R7,Y+43
    0207C A48C      LDD	R8,Y+44
    0207D A49D      LDD	R9,Y+45
    0207E 1426      CP	R2,R6
    0207F 0437      CPC	R3,R7
    02080 0448      CPC	R4,R8
    02081 0459      CPC	R5,R9
    02082 F470      BCC	0x2091
    02083 A5E8      LDD	R30,Y+40
    02084 A5F9      LDD	R31,Y+41
    02085 8024      LDD	R2,Z+4
    02086 FC21      SBRC	R2,1
    02087 C009      RJMP	0x2091
(2880) #if !_FS_READONLY
(2881) 			 && !(fp->flag & FA_WRITE)
(2882) #endif
(2883) 			) ofs = fp->fsize;
    02088 963A      ADIW	R30,0xA
    02089 8020      LD	R2,Z
    0208A 8031      LDD	R3,Z+1
    0208B 8042      LDD	R4,Z+2
    0208C 8053      LDD	R5,Z+3
    0208D A62A      STD	Y+42,R2
    0208E A63B      STD	Y+43,R3
    0208F A64C      STD	Y+44,R4
    02090 A65D      STD	Y+45,R5
(2884) 
(2885) 		ifptr = fp->fptr;
    02091 A5E8      LDD	R30,Y+40
    02092 A5F9      LDD	R31,Y+41
    02093 9636      ADIW	R30,6
    02094 8020      LD	R2,Z
    02095 8031      LDD	R3,Z+1
    02096 8042      LDD	R4,Z+2
    02097 8053      LDD	R5,Z+3
    02098 862E      STD	Y+14,R2
    02099 863F      STD	Y+15,R3
    0209A 8A48      STD	Y+16,R4
    0209B 8A59      STD	Y+17,R5
(2886) 		fp->fptr = nsect = 0;
    0209C E080      LDI	R24,0
    0209D 878A      STD	Y+10,R24
    0209E 878B      STD	Y+11,R24
    0209F 878C      STD	Y+12,R24
    020A0 878D      STD	Y+13,R24
    020A1 A5E8      LDD	R30,Y+40
    020A2 A5F9      LDD	R31,Y+41
    020A3 9636      ADIW	R30,6
    020A4 E080      LDI	R24,0
    020A5 8380      ST	Z,R24
    020A6 8381      STD	Z+1,R24
    020A7 8382      STD	Z+2,R24
    020A8 8383      STD	Z+3,R24
(2887) 		if (ofs) {
    020A9 A42A      LDD	R2,Y+42
    020AA A43B      LDD	R3,Y+43
    020AB A44C      LDD	R4,Y+44
    020AC A45D      LDD	R5,Y+45
    020AD 9488      BCLR	0
    020AE 2022      TST	R2
    020AF 0432      CPC	R3,R2
    020B0 0442      CPC	R4,R2
    020B1 0452      CPC	R5,R2
    020B2 F409      BNE	0x20B4
    020B3 C226      RJMP	0x22DA
(2888) 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    020B4 A5E8      LDD	R30,Y+40
    020B5 A5F9      LDD	R31,Y+41
    020B6 93AF      PUSH	R26
    020B7 93BF      PUSH	R27
    020B8 81A0      LD	R26,Z
    020B9 81B1      LDD	R27,Z+1
    020BA 01FD      MOVW	R30,R26
    020BB 91BF      POP	R27
    020BC 91AF      POP	R26
    020BD 9632      ADIW	R30,2
    020BE 8020      LD	R2,Z
    020BF 2433      CLR	R3
    020C0 2444      CLR	R4
    020C1 2455      CLR	R5
    020C2 E040      LDI	R20,0
    020C3 E052      LDI	R21,2
    020C4 E060      LDI	R22,0
    020C5 E070      LDI	R23,0
    020C6 925A      ST	-Y,R5
    020C7 924A      ST	-Y,R4
    020C8 923A      ST	-Y,R3
    020C9 922A      ST	-Y,R2
    020CA 018A      MOVW	R16,R20
    020CB 019B      MOVW	R18,R22
    020CC 940E 3C21 CALL	empy32s|empy32u
    020CE 830E      STD	Y+6,R16
    020CF 831F      STD	Y+7,R17
    020D0 8728      STD	Y+8,R18
    020D1 8739      STD	Y+9,R19
(2889) 			if (ifptr > 0 &&
    020D2 842E      LDD	R2,Y+14
    020D3 843F      LDD	R3,Y+15
    020D4 8848      LDD	R4,Y+16
    020D5 8859      LDD	R5,Y+17
    020D6 9488      BCLR	0
    020D7 2022      TST	R2
    020D8 0432      CPC	R3,R2
    020D9 0442      CPC	R4,R2
    020DA 0452      CPC	R5,R2
    020DB F409      BNE	0x20DD
    020DC C075      RJMP	0x2152
    020DD E041      LDI	R20,1
    020DE E050      LDI	R21,0
    020DF E060      LDI	R22,0
    020E0 E070      LDI	R23,0
    020E1 0181      MOVW	R16,R2
    020E2 0192      MOVW	R18,R4
    020E3 1B04      SUB	R16,R20
    020E4 0B15      SBC	R17,R21
    020E5 0B26      SBC	R18,R22
    020E6 0B37      SBC	R19,R23
    020E7 802E      LDD	R2,Y+6
    020E8 803F      LDD	R3,Y+7
    020E9 8448      LDD	R4,Y+8
    020EA 8459      LDD	R5,Y+9
    020EB 925A      ST	-Y,R5
    020EC 924A      ST	-Y,R4
    020ED 923A      ST	-Y,R3
    020EE 922A      ST	-Y,R2
    020EF 940E 3B7B CALL	div32u
    020F1 0118      MOVW	R2,R16
    020F2 0129      MOVW	R4,R18
    020F3 E041      LDI	R20,1
    020F4 E050      LDI	R21,0
    020F5 E060      LDI	R22,0
    020F6 E070      LDI	R23,0
    020F7 A50A      LDD	R16,Y+42
    020F8 A51B      LDD	R17,Y+43
    020F9 A52C      LDD	R18,Y+44
    020FA A53D      LDD	R19,Y+45
    020FB 1B04      SUB	R16,R20
    020FC 0B15      SBC	R17,R21
    020FD 0B26      SBC	R18,R22
    020FE 0B37      SBC	R19,R23
    020FF 806E      LDD	R6,Y+6
    02100 807F      LDD	R7,Y+7
    02101 8488      LDD	R8,Y+8
    02102 8499      LDD	R9,Y+9
    02103 929A      ST	-Y,R9
    02104 928A      ST	-Y,R8
    02105 927A      ST	-Y,R7
    02106 926A      ST	-Y,R6
    02107 940E 3B7B CALL	div32u
    02109 1502      CP	R16,R2
    0210A 0513      CPC	R17,R3
    0210B 0524      CPC	R18,R4
    0210C 0535      CPC	R19,R5
    0210D F408      BCC	0x210F
    0210E C043      RJMP	0x2152
(2890) 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
(2891) 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    0210F E041      LDI	R20,1
    02110 E050      LDI	R21,0
    02111 E060      LDI	R22,0
    02112 E070      LDI	R23,0
    02113 802E      LDD	R2,Y+6
    02114 803F      LDD	R3,Y+7
    02115 8448      LDD	R4,Y+8
    02116 8459      LDD	R5,Y+9
    02117 1A24      SUB	R2,R20
    02118 0A35      SBC	R3,R21
    02119 0A46      SBC	R4,R22
    0211A 0A57      SBC	R5,R23
    0211B 9420      COM	R2
    0211C 9430      COM	R3
    0211D 9440      COM	R4
    0211E 9450      COM	R5
    0211F E041      LDI	R20,1
    02120 E050      LDI	R21,0
    02121 E060      LDI	R22,0
    02122 E070      LDI	R23,0
    02123 846E      LDD	R6,Y+14
    02124 847F      LDD	R7,Y+15
    02125 8888      LDD	R8,Y+16
    02126 8899      LDD	R9,Y+17
    02127 1A64      SUB	R6,R20
    02128 0A75      SBC	R7,R21
    02129 0A86      SBC	R8,R22
    0212A 0A97      SBC	R9,R23
    0212B 2062      AND	R6,R2
    0212C 2073      AND	R7,R3
    0212D 2084      AND	R8,R4
    0212E 2095      AND	R9,R5
    0212F A5E8      LDD	R30,Y+40
    02130 A5F9      LDD	R31,Y+41
    02131 8266      STD	Z+6,R6
    02132 8277      STD	Z+7,R7
    02133 8680      STD	Z+8,R8
    02134 8691      STD	Z+9,R9
(2892) 				ofs -= fp->fptr;
    02135 9636      ADIW	R30,6
    02136 8020      LD	R2,Z
    02137 8031      LDD	R3,Z+1
    02138 8042      LDD	R4,Z+2
    02139 8053      LDD	R5,Z+3
    0213A A46A      LDD	R6,Y+42
    0213B A47B      LDD	R7,Y+43
    0213C A48C      LDD	R8,Y+44
    0213D A49D      LDD	R9,Y+45
    0213E 1862      SUB	R6,R2
    0213F 0873      SBC	R7,R3
    02140 0884      SBC	R8,R4
    02141 0895      SBC	R9,R5
    02142 A66A      STD	Y+42,R6
    02143 A67B      STD	Y+43,R7
    02144 A68C      STD	Y+44,R8
    02145 A69D      STD	Y+45,R9
(2893) 				clst = fp->clust;
    02146 A5E8      LDD	R30,Y+40
    02147 A5F9      LDD	R31,Y+41
    02148 9672      ADIW	R30,0x12
    02149 8020      LD	R2,Z
    0214A 8031      LDD	R3,Z+1
    0214B 8042      LDD	R4,Z+2
    0214C 8053      LDD	R5,Z+3
    0214D 822A      STD	Y+2,R2
    0214E 823B      STD	Y+3,R3
    0214F 824C      STD	Y+4,R4
    02150 825D      STD	Y+5,R5
(2894) 			} else {									/* When seek to back cluster, */
    02151 C069      RJMP	0x21BB
(2895) 				clst = fp->sclust;						/* start from the first cluster */
    02152 A5E8      LDD	R30,Y+40
    02153 A5F9      LDD	R31,Y+41
    02154 963E      ADIW	R30,0xE
    02155 8020      LD	R2,Z
    02156 8031      LDD	R3,Z+1
    02157 8042      LDD	R4,Z+2
    02158 8053      LDD	R5,Z+3
    02159 822A      STD	Y+2,R2
    0215A 823B      STD	Y+3,R3
    0215B 824C      STD	Y+4,R4
    0215C 825D      STD	Y+5,R5
(2896) #if !_FS_READONLY
(2897) 				if (clst == 0) {						/* If no cluster chain, create a new chain */
    0215D 802A      LDD	R2,Y+2
    0215E 803B      LDD	R3,Y+3
    0215F 804C      LDD	R4,Y+4
    02160 805D      LDD	R5,Y+5
    02161 9488      BCLR	0
    02162 2022      TST	R2
    02163 0432      CPC	R3,R2
    02164 0442      CPC	R4,R2
    02165 0452      CPC	R5,R2
    02166 F009      BEQ	0x2168
    02167 C049      RJMP	0x21B1
(2898) 					clst = create_chain(fp->fs, 0);
    02168 E040      LDI	R20,0
    02169 E050      LDI	R21,0
    0216A E060      LDI	R22,0
    0216B E070      LDI	R23,0
    0216C 8368      ST	Y,R22
    0216D 8379      STD	Y+1,R23
    0216E 019A      MOVW	R18,R20
    0216F A5E8      LDD	R30,Y+40
    02170 A5F9      LDD	R31,Y+41
    02171 8100      LD	R16,Z
    02172 8111      LDD	R17,Z+1
    02173 940E 08B8 CALL	ff.c:create_chain
    02175 830A      STD	Y+2,R16
    02176 831B      STD	Y+3,R17
    02177 832C      STD	Y+4,R18
    02178 833D      STD	Y+5,R19
(2899) 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    02179 E041      LDI	R20,1
    0217A E050      LDI	R21,0
    0217B E060      LDI	R22,0
    0217C E070      LDI	R23,0
    0217D 802A      LDD	R2,Y+2
    0217E 803B      LDD	R3,Y+3
    0217F 804C      LDD	R4,Y+4
    02180 805D      LDD	R5,Y+5
    02181 1624      CP	R2,R20
    02182 0635      CPC	R3,R21
    02183 0646      CPC	R4,R22
    02184 0657      CPC	R5,R23
    02185 F451      BNE	0x2190
    02186 A588      LDD	R24,Y+40
    02187 A599      LDD	R25,Y+41
    02188 9604      ADIW	R24,4
    02189 017C      MOVW	R14,R24
    0218A 01FC      MOVW	R30,R24
    0218B 8180      LD	R24,Z
    0218C 6880      ORI	R24,0x80
    0218D 8380      ST	Z,R24
    0218E E002      LDI	R16,2
    0218F C196      RJMP	0x2326
(2900) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    02190 EF4F      LDI	R20,0xFF
    02191 EF5F      LDI	R21,0xFF
    02192 EF6F      LDI	R22,0xFF
    02193 EF7F      LDI	R23,0xFF
    02194 802A      LDD	R2,Y+2
    02195 803B      LDD	R3,Y+3
    02196 804C      LDD	R4,Y+4
    02197 805D      LDD	R5,Y+5
    02198 1624      CP	R2,R20
    02199 0635      CPC	R3,R21
    0219A 0646      CPC	R4,R22
    0219B 0657      CPC	R5,R23
    0219C F451      BNE	0x21A7
    0219D A588      LDD	R24,Y+40
    0219E A599      LDD	R25,Y+41
    0219F 9604      ADIW	R24,4
    021A0 017C      MOVW	R14,R24
    021A1 01FC      MOVW	R30,R24
    021A2 8180      LD	R24,Z
    021A3 6880      ORI	R24,0x80
    021A4 8380      ST	Z,R24
    021A5 E001      LDI	R16,1
    021A6 C17F      RJMP	0x2326
(2901) 					fp->sclust = clst;
    021A7 802A      LDD	R2,Y+2
    021A8 803B      LDD	R3,Y+3
    021A9 804C      LDD	R4,Y+4
    021AA 805D      LDD	R5,Y+5
    021AB A5E8      LDD	R30,Y+40
    021AC A5F9      LDD	R31,Y+41
    021AD 8626      STD	Z+14,R2
    021AE 8637      STD	Z+15,R3
    021AF 8A40      STD	Z+16,R4
    021B0 8A51      STD	Z+17,R5
(2902) 				}
(2903) #endif
(2904) 				fp->clust = clst;
    021B1 802A      LDD	R2,Y+2
    021B2 803B      LDD	R3,Y+3
    021B3 804C      LDD	R4,Y+4
    021B4 805D      LDD	R5,Y+5
    021B5 A5E8      LDD	R30,Y+40
    021B6 A5F9      LDD	R31,Y+41
    021B7 8A22      STD	Z+18,R2
    021B8 8A33      STD	Z+19,R3
    021B9 8A44      STD	Z+20,R4
    021BA 8A55      STD	Z+21,R5
(2905) 			}
(2906) 			if (clst != 0) {
    021BB 802A      LDD	R2,Y+2
    021BC 803B      LDD	R3,Y+3
    021BD 804C      LDD	R4,Y+4
    021BE 805D      LDD	R5,Y+5
    021BF 9488      BCLR	0
    021C0 2022      TST	R2
    021C1 0432      CPC	R3,R2
    021C2 0442      CPC	R4,R2
    021C3 0452      CPC	R5,R2
    021C4 F409      BNE	0x21C6
    021C5 C114      RJMP	0x22DA
    021C6 C0A7      RJMP	0x226E
(2907) 				while (ofs > bcs) {						/* Cluster following loop */
(2908) #if !_FS_READONLY
(2909) 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    021C7 A5E8      LDD	R30,Y+40
    021C8 A5F9      LDD	R31,Y+41
    021C9 9634      ADIW	R30,4
    021CA 8020      LD	R2,Z
    021CB FE21      SBRS	R2,1
    021CC C024      RJMP	0x21F1
(2910) 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    021CD 802A      LDD	R2,Y+2
    021CE 803B      LDD	R3,Y+3
    021CF 804C      LDD	R4,Y+4
    021D0 805D      LDD	R5,Y+5
    021D1 8248      ST	Y,R4
    021D2 8259      STD	Y+1,R5
    021D3 0191      MOVW	R18,R2
    021D4 A5E8      LDD	R30,Y+40
    021D5 A5F9      LDD	R31,Y+41
    021D6 8100      LD	R16,Z
    021D7 8111      LDD	R17,Z+1
    021D8 940E 08B8 CALL	ff.c:create_chain
    021DA 830A      STD	Y+2,R16
    021DB 831B      STD	Y+3,R17
    021DC 832C      STD	Y+4,R18
    021DD 833D      STD	Y+5,R19
(2911) 						if (clst == 0) {				/* When disk gets full, clip file size */
    021DE 802A      LDD	R2,Y+2
    021DF 803B      LDD	R3,Y+3
    021E0 804C      LDD	R4,Y+4
    021E1 805D      LDD	R5,Y+5
    021E2 9488      BCLR	0
    021E3 2022      TST	R2
    021E4 0432      CPC	R3,R2
    021E5 0442      CPC	R4,R2
    021E6 0452      CPC	R5,R2
    021E7 F4D1      BNE	0x2202
(2912) 							ofs = bcs; break;
    021E8 802E      LDD	R2,Y+6
    021E9 803F      LDD	R3,Y+7
    021EA 8448      LDD	R4,Y+8
    021EB 8459      LDD	R5,Y+9
    021EC A62A      STD	Y+42,R2
    021ED A63B      STD	Y+43,R3
    021EE A64C      STD	Y+44,R4
    021EF A65D      STD	Y+45,R5
    021F0 C08B      RJMP	0x227C
(2913) 						}
(2914) 					} else
(2915) #endif
(2916) 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    021F1 802A      LDD	R2,Y+2
    021F2 803B      LDD	R3,Y+3
    021F3 804C      LDD	R4,Y+4
    021F4 805D      LDD	R5,Y+5
    021F5 8248      ST	Y,R4
    021F6 8259      STD	Y+1,R5
    021F7 0191      MOVW	R18,R2
    021F8 A5E8      LDD	R30,Y+40
    021F9 A5F9      LDD	R31,Y+41
    021FA 8100      LD	R16,Z
    021FB 8111      LDD	R17,Z+1
    021FC 940E 04F6 CALL	_get_fat
    021FE 830A      STD	Y+2,R16
    021FF 831B      STD	Y+3,R17
    02200 832C      STD	Y+4,R18
    02201 833D      STD	Y+5,R19
(2917) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    02202 EF4F      LDI	R20,0xFF
    02203 EF5F      LDI	R21,0xFF
    02204 EF6F      LDI	R22,0xFF
    02205 EF7F      LDI	R23,0xFF
    02206 802A      LDD	R2,Y+2
    02207 803B      LDD	R3,Y+3
    02208 804C      LDD	R4,Y+4
    02209 805D      LDD	R5,Y+5
    0220A 1624      CP	R2,R20
    0220B 0635      CPC	R3,R21
    0220C 0646      CPC	R4,R22
    0220D 0657      CPC	R5,R23
    0220E F451      BNE	0x2219
    0220F A588      LDD	R24,Y+40
    02210 A599      LDD	R25,Y+41
    02211 9604      ADIW	R24,4
    02212 017C      MOVW	R14,R24
    02213 01FC      MOVW	R30,R24
    02214 8180      LD	R24,Z
    02215 6880      ORI	R24,0x80
    02216 8380      ST	Z,R24
    02217 E001      LDI	R16,1
    02218 C10D      RJMP	0x2326
(2918) 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    02219 E041      LDI	R20,1
    0221A E050      LDI	R21,0
    0221B E060      LDI	R22,0
    0221C E070      LDI	R23,0
    0221D 802A      LDD	R2,Y+2
    0221E 803B      LDD	R3,Y+3
    0221F 804C      LDD	R4,Y+4
    02220 805D      LDD	R5,Y+5
    02221 1542      CP	R20,R2
    02222 0553      CPC	R21,R3
    02223 0564      CPC	R22,R4
    02224 0575      CPC	R23,R5
    02225 F490      BCC	0x2238
    02226 A5E8      LDD	R30,Y+40
    02227 A5F9      LDD	R31,Y+41
    02228 81A0      LD	R26,Z
    02229 81B1      LDD	R27,Z+1
    0222A 9656      ADIW	R26,0x16
    0222B 902D      LD	R2,X+
    0222C 903D      LD	R3,X+
    0222D 904D      LD	R4,X+
    0222E 905C      LD	R5,X
    0222F 806A      LDD	R6,Y+2
    02230 807B      LDD	R7,Y+3
    02231 808C      LDD	R8,Y+4
    02232 809D      LDD	R9,Y+5
    02233 1462      CP	R6,R2
    02234 0473      CPC	R7,R3
    02235 0484      CPC	R8,R4
    02236 0495      CPC	R9,R5
    02237 F050      BCS	0x2242
    02238 A588      LDD	R24,Y+40
    02239 A599      LDD	R25,Y+41
    0223A 9604      ADIW	R24,4
    0223B 017C      MOVW	R14,R24
    0223C 01FC      MOVW	R30,R24
    0223D 8180      LD	R24,Z
    0223E 6880      ORI	R24,0x80
    0223F 8380      ST	Z,R24
    02240 E002      LDI	R16,2
    02241 C0E4      RJMP	0x2326
(2919) 					fp->clust = clst;
    02242 802A      LDD	R2,Y+2
    02243 803B      LDD	R3,Y+3
    02244 804C      LDD	R4,Y+4
    02245 805D      LDD	R5,Y+5
    02246 A5E8      LDD	R30,Y+40
    02247 A5F9      LDD	R31,Y+41
    02248 9672      ADIW	R30,0x12
    02249 8220      ST	Z,R2
    0224A 8231      STD	Z+1,R3
    0224B 8242      STD	Z+2,R4
    0224C 8253      STD	Z+3,R5
(2920) 					fp->fptr += bcs;
    0224D A588      LDD	R24,Y+40
    0224E A599      LDD	R25,Y+41
    0224F 9606      ADIW	R24,6
    02250 017C      MOVW	R14,R24
    02251 802E      LDD	R2,Y+6
    02252 803F      LDD	R3,Y+7
    02253 8448      LDD	R4,Y+8
    02254 8459      LDD	R5,Y+9
    02255 01FC      MOVW	R30,R24
    02256 8060      LD	R6,Z
    02257 8071      LDD	R7,Z+1
    02258 8082      LDD	R8,Z+2
    02259 8093      LDD	R9,Z+3
    0225A 0C62      ADD	R6,R2
    0225B 1C73      ADC	R7,R3
    0225C 1C84      ADC	R8,R4
    0225D 1C95      ADC	R9,R5
    0225E 8260      ST	Z,R6
    0225F 8271      STD	Z+1,R7
    02260 8282      STD	Z+2,R8
    02261 8293      STD	Z+3,R9
(2921) 					ofs -= bcs;
    02262 A46A      LDD	R6,Y+42
    02263 A47B      LDD	R7,Y+43
    02264 A48C      LDD	R8,Y+44
    02265 A49D      LDD	R9,Y+45
    02266 1862      SUB	R6,R2
    02267 0873      SBC	R7,R3
    02268 0884      SBC	R8,R4
    02269 0895      SBC	R9,R5
    0226A A66A      STD	Y+42,R6
    0226B A67B      STD	Y+43,R7
    0226C A68C      STD	Y+44,R8
    0226D A69D      STD	Y+45,R9
    0226E 802E      LDD	R2,Y+6
    0226F 803F      LDD	R3,Y+7
    02270 8448      LDD	R4,Y+8
    02271 8459      LDD	R5,Y+9
    02272 A46A      LDD	R6,Y+42
    02273 A47B      LDD	R7,Y+43
    02274 A48C      LDD	R8,Y+44
    02275 A49D      LDD	R9,Y+45
    02276 1426      CP	R2,R6
    02277 0437      CPC	R3,R7
    02278 0448      CPC	R4,R8
    02279 0459      CPC	R5,R9
    0227A F408      BCC	0x227C
    0227B CF4B      RJMP	0x21C7
(2922) 				}
(2923) 				fp->fptr += ofs;
    0227C A588      LDD	R24,Y+40
    0227D A599      LDD	R25,Y+41
    0227E 9606      ADIW	R24,6
    0227F 017C      MOVW	R14,R24
    02280 A42A      LDD	R2,Y+42
    02281 A43B      LDD	R3,Y+43
    02282 A44C      LDD	R4,Y+44
    02283 A45D      LDD	R5,Y+45
    02284 01FC      MOVW	R30,R24
    02285 8060      LD	R6,Z
    02286 8071      LDD	R7,Z+1
    02287 8082      LDD	R8,Z+2
    02288 8093      LDD	R9,Z+3
    02289 0C62      ADD	R6,R2
    0228A 1C73      ADC	R7,R3
    0228B 1C84      ADC	R8,R4
    0228C 1C95      ADC	R9,R5
    0228D 8260      ST	Z,R6
    0228E 8271      STD	Z+1,R7
    0228F 8282      STD	Z+2,R8
    02290 8293      STD	Z+3,R9
(2924) 				if (ofs % SS(fp->fs)) {
    02291 EF4F      LDI	R20,0xFF
    02292 E051      LDI	R21,1
    02293 E060      LDI	R22,0
    02294 E070      LDI	R23,0
    02295 2224      AND	R2,R20
    02296 2235      AND	R3,R21
    02297 2246      AND	R4,R22
    02298 2257      AND	R5,R23
    02299 9488      BCLR	0
    0229A 2022      TST	R2
    0229B 0432      CPC	R3,R2
    0229C 0442      CPC	R4,R2
    0229D 0452      CPC	R5,R2
    0229E F409      BNE	0x22A0
    0229F C03A      RJMP	0x22DA
(2925) 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    022A0 802A      LDD	R2,Y+2
    022A1 803B      LDD	R3,Y+3
    022A2 804C      LDD	R4,Y+4
    022A3 805D      LDD	R5,Y+5
    022A4 8248      ST	Y,R4
    022A5 8259      STD	Y+1,R5
    022A6 0191      MOVW	R18,R2
    022A7 A5E8      LDD	R30,Y+40
    022A8 A5F9      LDD	R31,Y+41
    022A9 8100      LD	R16,Z
    022AA 8111      LDD	R17,Z+1
    022AB 940E 04A4 CALL	_clust2sect
    022AD 870A      STD	Y+10,R16
    022AE 871B      STD	Y+11,R17
    022AF 872C      STD	Y+12,R18
    022B0 873D      STD	Y+13,R19
(2926) 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    022B1 842A      LDD	R2,Y+10
    022B2 843B      LDD	R3,Y+11
    022B3 844C      LDD	R4,Y+12
    022B4 845D      LDD	R5,Y+13
    022B5 9488      BCLR	0
    022B6 2022      TST	R2
    022B7 0432      CPC	R3,R2
    022B8 0442      CPC	R4,R2
    022B9 0452      CPC	R5,R2
    022BA F451      BNE	0x22C5
    022BB A588      LDD	R24,Y+40
    022BC A599      LDD	R25,Y+41
    022BD 9604      ADIW	R24,4
    022BE 017C      MOVW	R14,R24
    022BF 01FC      MOVW	R30,R24
    022C0 8180      LD	R24,Z
    022C1 6880      ORI	R24,0x80
    022C2 8380      ST	Z,R24
    022C3 E002      LDI	R16,2
    022C4 C061      RJMP	0x2326
(2927) 					nsect += ofs / SS(fp->fs);
    022C5 E089      LDI	R24,0x9
    022C6 E090      LDI	R25,0
    022C7 A50A      LDD	R16,Y+42
    022C8 A51B      LDD	R17,Y+43
    022C9 A52C      LDD	R18,Y+44
    022CA A53D      LDD	R19,Y+45
    022CB 938A      ST	-Y,R24
    022CC 940E 3D10 CALL	lsr32
    022CE 842A      LDD	R2,Y+10
    022CF 843B      LDD	R3,Y+11
    022D0 844C      LDD	R4,Y+12
    022D1 845D      LDD	R5,Y+13
    022D2 0E20      ADD	R2,R16
    022D3 1E31      ADC	R3,R17
    022D4 1E42      ADC	R4,R18
    022D5 1E53      ADC	R5,R19
    022D6 862A      STD	Y+10,R2
    022D7 863B      STD	Y+11,R3
    022D8 864C      STD	Y+12,R4
    022D9 865D      STD	Y+13,R5
(2928) 				}
(2929) 			}
(2930) 		}
(2931) 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    022DA EF4F      LDI	R20,0xFF
    022DB E051      LDI	R21,1
    022DC E060      LDI	R22,0
    022DD E070      LDI	R23,0
    022DE A5E8      LDD	R30,Y+40
    022DF A5F9      LDD	R31,Y+41
    022E0 9636      ADIW	R30,6
    022E1 8020      LD	R2,Z
    022E2 8031      LDD	R3,Z+1
    022E3 8042      LDD	R4,Z+2
    022E4 8053      LDD	R5,Z+3
    022E5 2224      AND	R2,R20
    022E6 2235      AND	R3,R21
    022E7 2246      AND	R4,R22
    022E8 2257      AND	R5,R23
    022E9 9488      BCLR	0
    022EA 2022      TST	R2
    022EB 0432      CPC	R3,R2
    022EC 0442      CPC	R4,R2
    022ED 0452      CPC	R5,R2
    022EE F0C1      BEQ	0x2307
    022EF A5E8      LDD	R30,Y+40
    022F0 A5F9      LDD	R31,Y+41
    022F1 9676      ADIW	R30,0x16
    022F2 8020      LD	R2,Z
    022F3 8031      LDD	R3,Z+1
    022F4 8042      LDD	R4,Z+2
    022F5 8053      LDD	R5,Z+3
    022F6 846A      LDD	R6,Y+10
    022F7 847B      LDD	R7,Y+11
    022F8 848C      LDD	R8,Y+12
    022F9 849D      LDD	R9,Y+13
    022FA 1462      CP	R6,R2
    022FB 0473      CPC	R7,R3
    022FC 0484      CPC	R8,R4
    022FD 0495      CPC	R9,R5
    022FE F041      BEQ	0x2307
(2932) #if !_FS_TINY
(2933) #if !_FS_READONLY
(2934) 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
(2935) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2936) 					ABORT(fp->fs, FR_DISK_ERR);
(2937) 				fp->flag &= ~FA__DIRTY;
(2938) 			}
(2939) #endif
(2940) 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
(2941) 				ABORT(fp->fs, FR_DISK_ERR);
(2942) #endif
(2943) 			fp->dsect = nsect;
    022FF 0113      MOVW	R2,R6
    02300 0124      MOVW	R4,R8
    02301 A5E8      LDD	R30,Y+40
    02302 A5F9      LDD	R31,Y+41
    02303 8A26      STD	Z+22,R2
    02304 8A37      STD	Z+23,R3
    02305 8E40      STD	Z+24,R4
    02306 8E51      STD	Z+25,R5
(2944) 		}
(2945) #if !_FS_READONLY
(2946) 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    02307 A5E8      LDD	R30,Y+40
    02308 A5F9      LDD	R31,Y+41
    02309 8422      LDD	R2,Z+10
    0230A 8433      LDD	R3,Z+11
    0230B 8444      LDD	R4,Z+12
    0230C 8455      LDD	R5,Z+13
    0230D 8066      LDD	R6,Z+6
    0230E 8077      LDD	R7,Z+7
    0230F 8480      LDD	R8,Z+8
    02310 8491      LDD	R9,Z+9
    02311 1426      CP	R2,R6
    02312 0437      CPC	R3,R7
    02313 0448      CPC	R4,R8
    02314 0459      CPC	R5,R9
    02315 F478      BCC	0x2325
(2947) 			fp->fsize = fp->fptr;
    02316 8026      LDD	R2,Z+6
    02317 8037      LDD	R3,Z+7
    02318 8440      LDD	R4,Z+8
    02319 8451      LDD	R5,Z+9
    0231A 8622      STD	Z+10,R2
    0231B 8633      STD	Z+11,R3
    0231C 8644      STD	Z+12,R4
    0231D 8655      STD	Z+13,R5
(2948) 			fp->flag |= FA__WRITTEN;
    0231E 01CF      MOVW	R24,R30
    0231F 9604      ADIW	R24,4
    02320 016C      MOVW	R12,R24
    02321 01FC      MOVW	R30,R24
    02322 8180      LD	R24,Z
    02323 6280      ORI	R24,0x20
    02324 8380      ST	Z,R24
(2949) 		}
(2950) #endif
(2951) 	}
(2952) 
(2953) 	LEAVE_FF(fp->fs, res);
    02325 2D0A      MOV	R16,R10
    02326 966E      ADIW	R28,0x1E
    02327 940E 3C6A CALL	pop_xgsetF0FC
    02329 9624      ADIW	R28,4
    0232A 9508      RET
_f_opendir:
  sfn                  --> Y,+1
  res                  --> R20
  path                 --> Y,+19
  dj                   --> R22
    0232B 933A      ST	-Y,R19
    0232C 932A      ST	-Y,R18
    0232D 940E 3C94 CALL	push_xgsetF00C
    0232F 01B8      MOVW	R22,R16
    02330 972D      SBIW	R28,0xD
(2954) }
(2955) 
(2956) 
(2957) 
(2958) #if _FS_MINIMIZE <= 1
(2959) /*-----------------------------------------------------------------------*/
(2960) /* Create a Directroy Object                                             */
(2961) /*-----------------------------------------------------------------------*/
(2962) 
(2963) FRESULT f_opendir (
(2964) 	DIR *dj,			/* Pointer to directory object to create */
(2965) 	const TCHAR *path	/* Pointer to the directory path */
(2966) )
(2967) {
(2968) 	FRESULT res;
(2969) 	DEF_NAMEBUF;
(2970) 
(2971) 
(2972) 	res = chk_mounted(&path, &dj->fs, 0);
    02331 2422      CLR	R2
    02332 8228      ST	Y,R2
    02333 019B      MOVW	R18,R22
    02334 018E      MOVW	R16,R28
    02335 5E0D      SUBI	R16,0xED
    02336 4F1F      SBCI	R17,0xFF
    02337 940E 114B CALL	ff.c:chk_mounted
    02339 2F40      MOV	R20,R16
(2973) 	if (res == FR_OK) {
    0233A 2300      TST	R16
    0233B F009      BEQ	0x233D
    0233C C05C      RJMP	0x2399
(2974) 		INIT_BUF(*dj);
    0233D 01CE      MOVW	R24,R28
    0233E 9601      ADIW	R24,1
    0233F 01FB      MOVW	R30,R22
    02340 8B95      STD	Z+21,R25
    02341 8B84      STD	Z+20,R24
(2975) 		res = follow_path(dj, path);			/* Follow the path to the directory */
    02342 892B      LDD	R18,Y+19
    02343 893C      LDD	R19,Y+20
    02344 018F      MOVW	R16,R30
    02345 940E 0FFF CALL	ff.c:follow_path
    02347 2F40      MOV	R20,R16
(2976) 		FREE_BUF();
(2977) 		if (res == FR_OK) {						/* Follow completed */
    02348 2300      TST	R16
    02349 F009      BEQ	0x234B
    0234A C04B      RJMP	0x2396
(2978) 			if (dj->dir) {						/* It is not the root dir */
    0234B 01FB      MOVW	R30,R22
    0234C 8822      LDD	R2,Z+18
    0234D 8833      LDD	R3,Z+19
    0234E 2022      TST	R2
    0234F F419      BNE	0x2353
    02350 2033      TST	R3
    02351 F409      BNE	0x2353
    02352 C032      RJMP	0x2385
(2979) 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    02353 93AF      PUSH	R26
    02354 93BF      PUSH	R27
    02355 89A2      LDD	R26,Z+18
    02356 89B3      LDD	R27,Z+19
    02357 01FD      MOVW	R30,R26
    02358 91BF      POP	R27
    02359 91AF      POP	R26
    0235A 8423      LDD	R2,Z+11
    0235B FE24      SBRS	R2,4
    0235C C027      RJMP	0x2384
(2980) 					dj->sclust = LD_CLUST(dj->dir);
    0235D 01FB      MOVW	R30,R22
    0235E 88A2      LDD	R10,Z+18
    0235F 88B3      LDD	R11,Z+19
    02360 01F5      MOVW	R30,R10
    02361 8C22      LDD	R2,Z+26
    02362 2433      CLR	R3
    02363 8C43      LDD	R4,Z+27
    02364 2455      CLR	R5
    02365 2C54      MOV	R5,R4
    02366 2444      CLR	R4
    02367 2842      OR	R4,R2
    02368 2853      OR	R5,R3
    02369 0112      MOVW	R2,R4
    0236A 2444      CLR	R4
    0236B 2455      CLR	R5
    0236C 8864      LDD	R6,Z+20
    0236D 2477      CLR	R7
    0236E 8885      LDD	R8,Z+21
    0236F 2499      CLR	R9
    02370 2C98      MOV	R9,R8
    02371 2488      CLR	R8
    02372 2886      OR	R8,R6
    02373 2897      OR	R9,R7
    02374 0134      MOVW	R6,R8
    02375 2488      CLR	R8
    02376 2499      CLR	R9
    02377 0143      MOVW	R8,R6
    02378 2466      CLR	R6
    02379 2477      CLR	R7
    0237A 2862      OR	R6,R2
    0237B 2873      OR	R7,R3
    0237C 2884      OR	R8,R4
    0237D 2895      OR	R9,R5
    0237E 01FB      MOVW	R30,R22
    0237F 8266      STD	Z+6,R6
    02380 8277      STD	Z+7,R7
    02381 8680      STD	Z+8,R8
    02382 8691      STD	Z+9,R9
(2981) 				} else {						/* The object is not a directory */
    02383 C001      RJMP	0x2385
(2982) 					res = FR_NO_PATH;
    02384 E045      LDI	R20,5
(2983) 				}
(2984) 			}
(2985) 			if (res == FR_OK) {
    02385 2344      TST	R20
    02386 F479      BNE	0x2396
(2986) 				dj->id = dj->fs->id;
    02387 01FB      MOVW	R30,R22
    02388 81A0      LD	R26,Z
    02389 81B1      LDD	R27,Z+1
    0238A 9616      ADIW	R26,6
    0238B 902D      LD	R2,X+
    0238C 903C      LD	R3,X
    0238D 8233      STD	Z+3,R3
    0238E 8222      STD	Z+2,R2
(2987) 				res = dir_sdi(dj, 0);			/* Rewind dir */
    0238F 2722      CLR	R18
    02390 2733      CLR	R19
    02391 018F      MOVW	R16,R30
    02392 940E 0AA9 CALL	ff.c:dir_sdi
    02394 2EA0      MOV	R10,R16
    02395 2D4A      MOV	R20,R10
(2988) 			}
(2989) 		}
(2990) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
    02396 3044      CPI	R20,4
    02397 F409      BNE	0x2399
    02398 E045      LDI	R20,5
(2991) 	}
(2992) 
(2993) 	LEAVE_FF(dj->fs, res);
    02399 2F04      MOV	R16,R20
    0239A 962D      ADIW	R28,0xD
    0239B 940E 3C9B CALL	pop_xgsetF00C
    0239D 9622      ADIW	R28,2
    0239E 9508      RET
_f_readdir:
  sfn                  --> Y,+0
  res                  --> R20
  fno                  --> R10
  dj                   --> R22
    0239F 940E 3CB0 CALL	push_xgsetF03C
    023A1 0159      MOVW	R10,R18
    023A2 01B8      MOVW	R22,R16
    023A3 972C      SBIW	R28,0xC
(2994) }
(2995) 
(2996) 
(2997) 
(2998) 
(2999) /*-----------------------------------------------------------------------*/
(3000) /* Read Directory Entry in Sequense                                      */
(3001) /*-----------------------------------------------------------------------*/
(3002) 
(3003) FRESULT f_readdir (
(3004) 	DIR *dj,			/* Pointer to the open directory object */
(3005) 	FILINFO *fno		/* Pointer to file information to return */
(3006) )
(3007) {
(3008) 	FRESULT res;
(3009) 	DEF_NAMEBUF;
(3010) 
(3011) 
(3012) 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    023A4 01FB      MOVW	R30,R22
    023A5 8122      LDD	R18,Z+2
    023A6 8133      LDD	R19,Z+3
    023A7 8100      LD	R16,Z
    023A8 8111      LDD	R17,Z+1
    023A9 940E 1645 CALL	ff.c:validate
    023AB 2F40      MOV	R20,R16
(3013) 	if (res == FR_OK) {
    023AC 2300      TST	R16
    023AD F009      BEQ	0x23AF
    023AE C035      RJMP	0x23E4
(3014) 		if (!fno) {
    023AF 20AA      TST	R10
    023B0 F449      BNE	0x23BA
    023B1 20BB      TST	R11
    023B2 F439      BNE	0x23BA
(3015) 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    023B3 2722      CLR	R18
    023B4 2733      CLR	R19
    023B5 018B      MOVW	R16,R22
    023B6 940E 0AA9 CALL	ff.c:dir_sdi
    023B8 2F40      MOV	R20,R16
(3016) 		} else {
    023B9 C02A      RJMP	0x23E4
(3017) 			INIT_BUF(*dj);
    023BA 01CE      MOVW	R24,R28
    023BB 01FB      MOVW	R30,R22
    023BC 8B95      STD	Z+21,R25
    023BD 8B84      STD	Z+20,R24
(3018) 			res = dir_read(dj);				/* Read an directory item */
    023BE 018F      MOVW	R16,R30
    023BF 940E 0DA6 CALL	ff.c:dir_read
    023C1 2EC0      MOV	R12,R16
    023C2 2D4C      MOV	R20,R12
(3019) 			if (res == FR_NO_FILE) {		/* Reached end of dir */
    023C3 3004      CPI	R16,4
    023C4 F441      BNE	0x23CD
(3020) 				dj->sect = 0;
    023C5 01FB      MOVW	R30,R22
    023C6 963E      ADIW	R30,0xE
    023C7 E080      LDI	R24,0
    023C8 8380      ST	Z,R24
    023C9 8381      STD	Z+1,R24
    023CA 8382      STD	Z+2,R24
    023CB 8383      STD	Z+3,R24
(3021) 				res = FR_OK;
    023CC 2744      CLR	R20
(3022) 			}
(3023) 			if (res == FR_OK) {				/* A valid entry is found */
    023CD 2344      TST	R20
    023CE F4A9      BNE	0x23E4
(3024) 				get_fileinfo(dj, fno);		/* Get the object information */
    023CF 0195      MOVW	R18,R10
    023D0 018B      MOVW	R16,R22
    023D1 940E 0F5C CALL	ff.c:get_fileinfo
(3025) 				res = dir_next(dj, 0);		/* Increment index for next */
    023D3 2722      CLR	R18
    023D4 2733      CLR	R19
    023D5 018B      MOVW	R16,R22
    023D6 940E 0BB3 CALL	ff.c:dir_next
    023D8 2EA0      MOV	R10,R16
    023D9 2D4A      MOV	R20,R10
(3026) 				if (res == FR_NO_FILE) {
    023DA 3004      CPI	R16,4
    023DB F441      BNE	0x23E4
(3027) 					dj->sect = 0;
    023DC 01FB      MOVW	R30,R22
    023DD 963E      ADIW	R30,0xE
    023DE E080      LDI	R24,0
    023DF 8380      ST	Z,R24
    023E0 8381      STD	Z+1,R24
    023E1 8382      STD	Z+2,R24
    023E2 8383      STD	Z+3,R24
(3028) 					res = FR_OK;
    023E3 2744      CLR	R20
(3029) 				}
(3030) 			}
(3031) 			FREE_BUF();
(3032) 		}
(3033) 	}
(3034) 
(3035) 	LEAVE_FF(dj->fs, res);
    023E4 2F04      MOV	R16,R20
    023E5 962C      ADIW	R28,0xC
    023E6 940C 3CB9 JMP	pop_xgsetF03C
FILE: D:\LQD\software\master\software_src\delay.c
(0001) /*******************************
(0002)  function ：延时函数
(0003) Clock F  :7.3728M 
(0004) Software : ICCAVR7.14C
(0005) ********************************/
(0006) /*---------------------------------------------------------------------------------
(0007)      延时程序计算方法
(0008)      计数个数j = 延时时间/6*晶振频率 - 1
(0009) ---------------------------------------------------------------------------------*/
(0010) void delayus(unsigned int tttt)   // 1.2us 延时子函数   
(0011) { 
(0012)    do
(0013)    {
(0014)        tttt--;
_delayus:
  tttt                 --> R16
    023E8 5001      SUBI	R16,1
    023E9 4010      SBCI	R17,0
(0015)    }
(0016)    while(tttt>1);
    023EA E081      LDI	R24,1
    023EB E090      LDI	R25,0
    023EC 1780      CP	R24,R16
    023ED 0791      CPC	R25,R17
    023EE F3C8      BCS	0x23E8
    023EF 9508      RET
_delayms:
  j                    --> R20
  i                    --> R16
    023F0 934A      ST	-Y,R20
    023F1 935A      ST	-Y,R21
(0017) }
(0018) void delayms(unsigned int i)                 //1ms延时
(0019)    {
    023F2 C00A      RJMP	0x23FD
(0020)     while(i--)
(0021)     {                          
(0022) 	    unsigned int j;                
(0023)         for(j=1;j<=1227;j++)   
    023F3 E041      LDI	R20,1
    023F4 E050      LDI	R21,0
    023F5 C002      RJMP	0x23F8
    023F6 5F4F      SUBI	R20,0xFF
    023F7 4F5F      SBCI	R21,0xFF
    023F8 EC8B      LDI	R24,0xCB
    023F9 E094      LDI	R25,4
    023FA 1784      CP	R24,R20
    023FB 0795      CPC	R25,R21
    023FC F7C8      BCC	0x23F6
    023FD 0118      MOVW	R2,R16
    023FE 5001      SUBI	R16,1
    023FF 4010      SBCI	R17,0
    02400 2022      TST	R2
    02401 F789      BNE	0x23F3
    02402 2033      TST	R3
    02403 F779      BNE	0x23F3
    02404 9159      LD	R21,Y+
    02405 9149      LD	R20,Y+
    02406 9508      RET
_initDevices:
    02407 940E 3C7B CALL	push_xgset003C
FILE: D:\LQD\software\master\software_src\main.c
(0001) #include "config.h"
(0002) #define  N_per_Second  (2.72*60)
(0003) const char tab[]="\t\0";
(0004) const char enter[]="\n\0";
(0005) char buffer[512];
(0006) struct DATA Result;
(0007) struct tm t;
(0008) unsigned long now =0; 
(0009) void debug(UINT8 *str,UINT8 val);
(0010) struct CONFIG config;
(0011) void initDevices(void){
(0012) 	 DDRA=0XFF;
    02409 EF8F      LDI	R24,0xFF
    0240A BB8A      OUT	0x1A,R24
(0013) 	 PORTA=0XFF;
    0240B BB8B      OUT	0x1B,R24
(0014) 	 DDRB=0XFF;
    0240C BB87      OUT	0x17,R24
(0015) 	 PORTB=0XFF; 	 
    0240D BB88      OUT	0x18,R24
(0016) 	 DDRC=0XFF;
    0240E BB84      OUT	0x14,R24
(0017) 	 PORTC=0XFF;
    0240F BB85      OUT	0x15,R24
(0018) 	 DDRG=0XFF;
    02410 9380 0064 STS	0x64,R24
(0019) 	 PORTG=0XFF;	 
    02412 9380 0065 STS	0x65,R24
(0020) 	 SPI_IO_Init(); 
    02414 940E 3490 CALL	_SPI_IO_Init
(0021) 	 SD_Init();
    02416 940E 28FA CALL	_SD_Init
(0022) 	 uart1_init();
    02418 940E 32BA CALL	_uart1_init
(0023) 	 LCD_INT();delayms(50);LCD_INT();
    0241A 940E 34AE CALL	_LCD_INT
    0241C E302      LDI	R16,0x32
    0241D E010      LDI	R17,0
    0241E 940E 23F0 CALL	_delayms
    02420 940E 34AE CALL	_LCD_INT
(0024) 	 LCD_SW(1);
    02422 E001      LDI	R16,1
    02423 940E 34A4 CALL	_LCD_SW
(0025) 	 config.THRESHOLD_delta_sec=10; //一次检测用时
    02425 E08A      LDI	R24,0xA
    02426 9380 074A STS	config+4,R24
    02428 E080      LDI	R24,0
    02429 9380 074B STS	config+5,R24
    0242B 9380 074C STS	config+6,R24
    0242D 9380 074D STS	config+7,R24
(0026) 	 config.autocheck=0;
    0242F 2422      CLR	R2
    02430 9220 0756 STS	config+16,R2
    02432 940C 3C55 JMP	pop_xgset003C
(0027) }
(0028) void WriteFileHead(void) ;
(0029) void selfTest(void);
(0030) void main(void){
(0031) 	 UINT8 tmp,keycode;
(0032) 	 initDevices();
_main:
  keycode              --> Y,+1
  tmp                  --> R20
    02434 DFD2      RCALL	_initDevices
(0033) 	 dateRefresh(1);
    02435 E001      LDI	R16,1
    02436 940E 316E CALL	_dateRefresh
(0034) 	 WriteFileHead();
    02438 D0E3      RCALL	_WriteFileHead
    02439 C00F      RJMP	0x2449
(0035) 	 while(1){
(0036) 	 check();
    0243A D15C      RCALL	_check
(0037) 	 StructToChar();
    0243B D2DA      RCALL	_StructToChar
(0038) 	 Result.Index++;
    0243C 9180 04E4 LDS	R24,Result+10
    0243E 9190 04E5 LDS	R25,Result+11
    02440 9601      ADIW	R24,1
    02441 9390 04E5 STS	Result+11,R25
    02443 9380 04E4 STS	Result+10,R24
(0039) 	 delayms(100);
    02445 E604      LDI	R16,0x64
    02446 E010      LDI	R17,0
    02447 940E 23F0 CALL	_delayms
    02449 CFF0      RJMP	0x243A
(0040) 	 }
(0041) 	 while(1)
(0042) 	 {
(0043) 	  	  tmp=GUI_mainmeu();
    0244A 940E 2AD3 CALL	_GUI_mainmeu
    0244C 2F40      MOV	R20,R16
(0044) 		  delayms(300);
    0244D E20C      LDI	R16,0x2C
    0244E E011      LDI	R17,1
    0244F 940E 23F0 CALL	_delayms
(0045) 	      if(tmp==3) {GUI_check();}//check
    02451 3043      CPI	R20,3
    02452 F411      BNE	0x2455
    02453 940E 2B9F CALL	_GUI_check
(0046) 		  if(tmp==4) {GUI_set_time();}//setclock
    02455 3044      CPI	R20,4
    02456 F411      BNE	0x2459
    02457 940E 2F26 CALL	_GUI_set_time
(0047) 		  if(tmp==5) {}//lookup
    02459 3045      CPI	R20,5
    0245A F401      BNE	0x245B
(0048) 		  if(tmp==6) {}//send data
    0245B 3046      CPI	R20,6
    0245C F401      BNE	0x245D
(0049) 		  if(tmp==7) {selfTest();}//init 
    0245D 3047      CPI	R20,7
    0245E F409      BNE	0x2460
    0245F D003      RCALL	_selfTest
(0050) 		  tmp=0;
    02460 2744      CLR	R20
    02461 CFE8      RJMP	0x244A
    02462 9508      RET
_selfTest:
  str2                 --> Y,+12
  str1                 --> Y,+6
  tmp                  --> Y,+2
    02463 9762      SBIW	R28,0x12
(0051) 	  }
(0052) }
(0053) void selfTest(void){
(0054) 	float tmp=0;
    02464 EB04      LDI	R16,0xB4
    02465 E010      LDI	R17,0
    02466 940E 3BFD CALL	elpm32
    02468 830A      STD	Y+2,R16
    02469 831B      STD	Y+3,R17
    0246A 832C      STD	Y+4,R18
    0246B 833D      STD	Y+5,R19
(0055) 	char str1[6],str2[6];
(0056) 	
(0057) 	 //自检程序
(0058) 	lp("自检程序");delayms(500);
    0246C E300      LDI	R16,0x30
    0246D E012      LDI	R17,2
    0246E 940E 37DD CALL	_lp
    02470 EF04      LDI	R16,0xF4
    02471 E011      LDI	R17,1
    02472 940E 23F0 CALL	_delayms
(0059) 	lp("外部温度 ");
    02474 E206      LDI	R16,0x26
    02475 E012      LDI	R17,2
    02476 940E 37DD CALL	_lp
(0060) 	tmp=read_T_NUM(0);
    02478 2700      CLR	R16
    02479 940E 3A10 CALL	_read_T_NUM
    0247B 830A      STD	Y+2,R16
    0247C 831B      STD	Y+3,R17
    0247D 832C      STD	Y+4,R18
    0247E 833D      STD	Y+5,R19
(0061) 	ftochr(tmp,str1);
    0247F 01CE      MOVW	R24,R28
    02480 9606      ADIW	R24,6
    02481 8399      STD	Y+1,R25
    02482 8388      ST	Y,R24
    02483 810A      LDD	R16,Y+2
    02484 811B      LDD	R17,Y+3
    02485 812C      LDD	R18,Y+4
    02486 813D      LDD	R19,Y+5
    02487 D23D      RCALL	_ftochr
(0062) 	str1[6]=0;
    02488 2422      CLR	R2
    02489 862C      STD	Y+12,R2
(0063) 	lp(str1);
    0248A 018E      MOVW	R16,R28
    0248B 5F0A      SUBI	R16,0xFA
    0248C 4F1F      SBCI	R17,0xFF
    0248D 940E 37DD CALL	_lp
(0064) 	delayms(500);
    0248F EF04      LDI	R16,0xF4
    02490 E011      LDI	R17,1
    02491 940E 23F0 CALL	_delayms
(0065) 	lp("内部温度");
    02493 E10D      LDI	R16,0x1D
    02494 E012      LDI	R17,2
    02495 940E 37DD CALL	_lp
(0066) 	tmp=read_T_NUM(1);
    02497 E001      LDI	R16,1
    02498 940E 3A10 CALL	_read_T_NUM
    0249A 830A      STD	Y+2,R16
    0249B 831B      STD	Y+3,R17
    0249C 832C      STD	Y+4,R18
    0249D 833D      STD	Y+5,R19
(0067) 	ftochr(tmp,str2);
    0249E 01CE      MOVW	R24,R28
    0249F 960C      ADIW	R24,0xC
    024A0 8399      STD	Y+1,R25
    024A1 8388      ST	Y,R24
    024A2 810A      LDD	R16,Y+2
    024A3 811B      LDD	R17,Y+3
    024A4 812C      LDD	R18,Y+4
    024A5 813D      LDD	R19,Y+5
    024A6 D21E      RCALL	_ftochr
(0068) 	str2[6]=0;
    024A7 2422      CLR	R2
    024A8 8A2A      STD	Y+18,R2
(0069) 	lp(str2);
    024A9 018E      MOVW	R16,R28
    024AA 5F04      SUBI	R16,0xF4
    024AB 4F1F      SBCI	R17,0xFF
    024AC 940E 37DD CALL	_lp
(0070) 	delayms(500);
    024AE EF04      LDI	R16,0xF4
    024AF E011      LDI	R17,1
    024B0 940E 23F0 CALL	_delayms
(0071) 	lp("风速脉冲：");delayms(500);
    024B2 E102      LDI	R16,0x12
    024B3 E012      LDI	R17,2
    024B4 940E 37DD CALL	_lp
    024B6 EF04      LDI	R16,0xF4
    024B7 E011      LDI	R17,1
    024B8 940E 23F0 CALL	_delayms
(0072) 	lp("蜂鸣器"); beep(2,2);delayms(500);
    024BA E00B      LDI	R16,0xB
    024BB E012      LDI	R17,2
    024BC 940E 37DD CALL	_lp
    024BE E022      LDI	R18,2
    024BF E002      LDI	R16,2
    024C0 940E 3853 CALL	_beep
    024C2 EF04      LDI	R16,0xF4
    024C3 E011      LDI	R17,1
    024C4 940E 23F0 CALL	_delayms
(0073) 	lp("power 指示灯");
    024C6 EF0E      LDI	R16,0xFE
    024C7 E011      LDI	R17,1
    024C8 940E 37DD CALL	_lp
(0074) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    024CA 9AA7      SBI	0x14,7
    024CB 98AF      CBI	0x15,7
    024CC E604      LDI	R16,0x64
    024CD E010      LDI	R17,0
    024CE 940E 23F0 CALL	_delayms
    024D0 9AA7      SBI	0x14,7
    024D1 9AAF      SBI	0x15,7
    024D2 E604      LDI	R16,0x64
    024D3 E010      LDI	R17,0
    024D4 940E 23F0 CALL	_delayms
(0075) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    024D6 9AA7      SBI	0x14,7
    024D7 98AF      CBI	0x15,7
    024D8 E604      LDI	R16,0x64
    024D9 E010      LDI	R17,0
    024DA 940E 23F0 CALL	_delayms
    024DC 9AA7      SBI	0x14,7
    024DD 9AAF      SBI	0x15,7
    024DE E604      LDI	R16,0x64
    024DF E010      LDI	R17,0
    024E0 940E 23F0 CALL	_delayms
(0076) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    024E2 9AA7      SBI	0x14,7
    024E3 98AF      CBI	0x15,7
    024E4 E604      LDI	R16,0x64
    024E5 E010      LDI	R17,0
    024E6 940E 23F0 CALL	_delayms
    024E8 9AA7      SBI	0x14,7
    024E9 9AAF      SBI	0x15,7
    024EA E604      LDI	R16,0x64
    024EB E010      LDI	R17,0
    024EC 940E 23F0 CALL	_delayms
(0077) 	delayms(500);
    024EE EF04      LDI	R16,0xF4
    024EF E011      LDI	R17,1
    024F0 940E 23F0 CALL	_delayms
(0078) 	lp("加热开关");
    024F2 EF05      LDI	R16,0xF5
    024F3 E011      LDI	R17,1
    024F4 940E 37DD CALL	_lp
(0079) 	RELAY_ON();delayms(100);  
    024F6 9AAD      SBI	0x15,5
    024F7 E604      LDI	R16,0x64
    024F8 E010      LDI	R17,0
    024F9 940E 23F0 CALL	_delayms
(0080) 	RELAY_OFF();delayms(100);
    024FB 98AD      CBI	0x15,5
    024FC E604      LDI	R16,0x64
    024FD E010      LDI	R17,0
    024FE 940E 23F0 CALL	_delayms
(0081) 	RELAY_ON();delayms(100);
    02500 9AAD      SBI	0x15,5
    02501 E604      LDI	R16,0x64
    02502 E010      LDI	R17,0
    02503 940E 23F0 CALL	_delayms
(0082) 	RELAY_OFF();delayms(100);
    02505 98AD      CBI	0x15,5
    02506 E604      LDI	R16,0x64
    02507 E010      LDI	R17,0
    02508 940E 23F0 CALL	_delayms
(0083) 	lp("  ");delayms(500);
    0250A EF02      LDI	R16,0xF2
    0250B E011      LDI	R17,1
    0250C 940E 37DD CALL	_lp
    0250E EF04      LDI	R16,0xF4
    0250F E011      LDI	R17,1
    02510 940E 23F0 CALL	_delayms
(0084) 	lp("完成自检");delayms(500);
    02512 EE09      LDI	R16,0xE9
    02513 E011      LDI	R17,1
    02514 940E 37DD CALL	_lp
    02516 EF04      LDI	R16,0xF4
    02517 E011      LDI	R17,1
    02518 940E 23F0 CALL	_delayms
    0251A 9662      ADIW	R28,0x12
    0251B 9508      RET
_WriteFileHead:
  fs                   --> Y,+177
  bw                   --> Y,+175
  itam                 --> Y,+52
  fnamep               --> Y,+38
  file                 --> Y,+4
  res                  --> R10
    0251C 940E 3C7B CALL	push_xgset003C
    0251E 97EF      SBIW	R28,0x3F
    0251F 97EF      SBIW	R28,0x3F
    02520 97EF      SBIW	R28,0x3F
    02521 97EF      SBIW	R28,0x3F
    02522 97EF      SBIW	R28,0x3F
    02523 97EF      SBIW	R28,0x3F
    02524 97EF      SBIW	R28,0x3F
    02525 97EF      SBIW	R28,0x3F
    02526 97EF      SBIW	R28,0x3F
    02527 97EF      SBIW	R28,0x3F
    02528 97EF      SBIW	R28,0x3F
    02529 97AA      SBIW	R28,0x2A
(0085) 	  
(0086) }
(0087) void WriteFileHead(void)   
(0088) {
(0089)  	 unsigned int bw;
(0090) 	 FRESULT res;
(0091) 	 FATFS fs;
(0092) 	 FIL file;
(0093) 	 char fnamep[]="201301.xls\0\0\0"; 
    0252A E189      LDI	R24,0x19
    0252B E091      LDI	R25,1
    0252C 01FE      MOVW	R30,R28
    0252D 96B6      ADIW	R30,0x26
    0252E E00E      LDI	R16,0xE
    0252F E010      LDI	R17,0
    02530 93FA      ST	-Y,R31
    02531 93EA      ST	-Y,R30
    02532 939A      ST	-Y,R25
    02533 938A      ST	-Y,R24
    02534 940E 3D1C CALL	asgnblk
(0094) 	 UINT8 itam[]="DEV000001\t\t\t\t\t\t\t\t\t\t\t\n序号\t日期\t时分\t温度\t风速\t风冷指数\t等价制冷温度\t相当温度\t冻伤危害性\t安静作业\t中等强度作业\t高强度作业\n\0";
    02536 E287      LDI	R24,0x27
    02537 E091      LDI	R25,1
    02538 01FE      MOVW	R30,R28
    02539 96F4      ADIW	R30,0x34
    0253A E70B      LDI	R16,0x7B
    0253B E010      LDI	R17,0
    0253C 93FA      ST	-Y,R31
    0253D 93EA      ST	-Y,R30
    0253E 939A      ST	-Y,R25
    0253F 938A      ST	-Y,R24
    02540 940E 3D1C CALL	asgnblk
(0095) 	 res=disk_initialize(0);
    02542 2700      CLR	R16
    02543 940E 0276 CALL	_disk_initialize
    02545 2EA0      MOV	R10,R16
(0096) 	 #ifdef _DEBUG
(0097) 	 debug("dinit",res);
    02546 2D2A      MOV	R18,R10
    02547 EE03      LDI	R16,0xE3
    02548 E011      LDI	R17,1
    02549 D361      RCALL	_debug
(0098) 	 #endif
(0099) 	 res = f_mount(0, &fs);
    0254A 019E      MOVW	R18,R28
    0254B 542F      SUBI	R18,0x4F
    0254C 4F3F      SBCI	R19,0xFF
    0254D 2700      CLR	R16
    0254E 940E 1662 CALL	_f_mount
    02550 2EA0      MOV	R10,R16
(0100) 	 #ifdef _DEBUG
(0101)  	 debug("dmnt",res);
    02551 2D2A      MOV	R18,R10
    02552 ED0E      LDI	R16,0xDE
    02553 E011      LDI	R17,1
    02554 D356      RCALL	_debug
(0102) 	 #endif
(0103) 	 res = f_open(&file, get_name(fnamep) , FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    02555 018E      MOVW	R16,R28
    02556 5D0A      SUBI	R16,0xDA
    02557 4F1F      SBCI	R17,0xFF
    02558 D277      RCALL	_get_name
    02559 0168      MOVW	R12,R16
    0255A E182      LDI	R24,0x12
    0255B 8388      ST	Y,R24
    0255C 0196      MOVW	R18,R12
    0255D 018E      MOVW	R16,R28
    0255E 5F0C      SUBI	R16,0xFC
    0255F 4F1F      SBCI	R17,0xFF
    02560 940E 168D CALL	_f_open
    02562 2EC0      MOV	R12,R16
    02563 2CAC      MOV	R10,R12
(0104) 	 #ifdef _DEBUG
(0105) 	 debug("fopen",res);
    02564 2D2A      MOV	R18,R10
    02565 ED08      LDI	R16,0xD8
    02566 E011      LDI	R17,1
    02567 D343      RCALL	_debug
(0106) 	 #endif
(0107) 	 res = f_write(&file,itam,128,&bw);   //bw 已写入字节数
    02568 01CE      MOVW	R24,R28
    02569 5581      SUBI	R24,0x51
    0256A 4F9F      SBCI	R25,0xFF
    0256B 839B      STD	Y+3,R25
    0256C 838A      STD	Y+2,R24
    0256D E880      LDI	R24,0x80
    0256E E090      LDI	R25,0
    0256F 8399      STD	Y+1,R25
    02570 8388      ST	Y,R24
    02571 019E      MOVW	R18,R28
    02572 5C2C      SUBI	R18,0xCC
    02573 4F3F      SBCI	R19,0xFF
    02574 018E      MOVW	R16,R28
    02575 5F0C      SUBI	R16,0xFC
    02576 4F1F      SBCI	R17,0xFF
    02577 940E 1A94 CALL	_f_write
    02579 2EC0      MOV	R12,R16
    0257A 2CAC      MOV	R10,R12
(0108) 	 #ifdef _DEBUG
(0109) 	 debug("fwrite",res);
    0257B 2D2A      MOV	R18,R10
    0257C ED01      LDI	R16,0xD1
    0257D E011      LDI	R17,1
    0257E D32C      RCALL	_debug
(0110) 	 #endif
(0111) 	 f_close(&file);
    0257F 018E      MOVW	R16,R28
    02580 5F0C      SUBI	R16,0xFC
    02581 4F1F      SBCI	R17,0xFF
    02582 940E 1E5E CALL	_f_close
(0112) 	 f_mount(0, NULL);
    02584 2722      CLR	R18
    02585 2733      CLR	R19
    02586 2700      CLR	R16
    02587 940E 1662 CALL	_f_mount
    02589 96EF      ADIW	R28,0x3F
    0258A 96EF      ADIW	R28,0x3F
    0258B 96EF      ADIW	R28,0x3F
    0258C 96EF      ADIW	R28,0x3F
    0258D 96EF      ADIW	R28,0x3F
    0258E 96EF      ADIW	R28,0x3F
    0258F 96EF      ADIW	R28,0x3F
    02590 96EF      ADIW	R28,0x3F
    02591 96EF      ADIW	R28,0x3F
    02592 96EF      ADIW	R28,0x3F
    02593 96EF      ADIW	R28,0x3F
    02594 96AA      ADIW	R28,0x2A
    02595 940C 3C55 JMP	pop_xgset003C
_check:
  WScounter            --> R10
  tmp                  --> R12
    02597 940E 3C7B CALL	push_xgset003C
    02599 9722      SBIW	R28,2
(0113) }
(0114)  
(0115) void check( void )
(0116) {
(0117)  unsigned char tmp;
(0118)  unsigned int WScounter;
(0119)  //检测风速
(0120)  //读计数器1 此步需严格按手册进行。
(0121)  tmp=SREG;
    0259A B6CF      IN	R12,0x3F
(0122)  CLI();
    0259B 94F8      BCLR	7
(0123)  WScounter=TCNT1H*256+TCNT1L;
    0259C B52D      IN	R18,0x2D
    0259D 2733      CLR	R19
    0259E E000      LDI	R16,0
    0259F E011      LDI	R17,1
    025A0 940E 3C11 CALL	empy16s
    025A2 0158      MOVW	R10,R16
    025A3 B42C      IN	R2,0x2C
    025A4 2433      CLR	R3
    025A5 0CA2      ADD	R10,R2
    025A6 1CB3      ADC	R11,R3
(0124)  SREG=tmp;
    025A7 BECF      OUT	0x3F,R12
(0125)  SEI();
    025A8 9478      BSET	7
(0126)  //计算风速
(0127)  Result.WindSpeed=WScounter/N_per_Second;
    025A9 0185      MOVW	R16,R10
    025AA 940E 3DCF CALL	uint2fp
    025AC 0118      MOVW	R2,R16
    025AD 0129      MOVW	R4,R18
    025AE EB00      LDI	R16,0xB0
    025AF E010      LDI	R17,0
    025B0 940E 3BFD CALL	elpm32
    025B2 933A      ST	-Y,R19
    025B3 932A      ST	-Y,R18
    025B4 931A      ST	-Y,R17
    025B5 930A      ST	-Y,R16
    025B6 0181      MOVW	R16,R2
    025B7 0192      MOVW	R18,R4
    025B8 940E 3DFC CALL	fpdiv2
    025BA 9310 050A STS	Result+48,R17
    025BC 9300 0509 STS	Result+47,R16
    025BE 9330 050C STS	Result+50,R19
    025C0 9320 050B STS	Result+49,R18
(0128)  //温度
(0129)  Result.Temperature=read_T_NUM(1);
    025C2 E001      LDI	R16,1
    025C3 940E 3A10 CALL	_read_T_NUM
    025C5 9310 0500 STS	Result+38,R17
    025C7 9300 04FF STS	Result+37,R16
    025C9 9330 0502 STS	Result+40,R19
    025CB 9320 0501 STS	Result+39,R18
(0130)  //WCI风冷指数
(0131)   Result.WCI = 4.18 *(10*SquareRootFloat(Result.WindSpeed) + 10.45 -  Result.WindSpeed  ) *( 33 - Result.Temperature );
    025CD 9120 050B LDS	R18,Result+49
    025CF 9130 050C LDS	R19,Result+50
    025D1 9100 0509 LDS	R16,Result+47
    025D3 9110 050A LDS	R17,Result+48
    025D5 D239      RCALL	_SquareRootFloat
    025D6 0118      MOVW	R2,R16
    025D7 0129      MOVW	R4,R18
    025D8 EA0C      LDI	R16,0xAC
    025D9 E010      LDI	R17,0
    025DA 940E 3BFD CALL	elpm32
    025DC 0138      MOVW	R6,R16
    025DD 0149      MOVW	R8,R18
    025DE EA08      LDI	R16,0xA8
    025DF E010      LDI	R17,0
    025E0 940E 3BFD CALL	elpm32
    025E2 925A      ST	-Y,R5
    025E3 924A      ST	-Y,R4
    025E4 923A      ST	-Y,R3
    025E5 922A      ST	-Y,R2
    025E6 940E 3F76 CALL	fpmule2
    025E8 0118      MOVW	R2,R16
    025E9 0129      MOVW	R4,R18
    025EA EA04      LDI	R16,0xA4
    025EB E010      LDI	R17,0
    025EC 940E 3BFD CALL	elpm32
    025EE 933A      ST	-Y,R19
    025EF 932A      ST	-Y,R18
    025F0 931A      ST	-Y,R17
    025F1 930A      ST	-Y,R16
    025F2 0181      MOVW	R16,R2
    025F3 0192      MOVW	R18,R4
    025F4 940E 3D9E CALL	fpadd2
    025F6 E089      LDI	R24,0x9
    025F7 E095      LDI	R25,5
    025F8 939A      ST	-Y,R25
    025F9 938A      ST	-Y,R24
    025FA 940E 3DB4 CALL	fpsub1x
    025FC 0183      MOVW	R16,R6
    025FD 0194      MOVW	R18,R8
    025FE 940E 3F76 CALL	fpmule2
    02600 0118      MOVW	R2,R16
    02601 0129      MOVW	R4,R18
    02602 EA00      LDI	R16,0xA0
    02603 E010      LDI	R17,0
    02604 940E 3BFD CALL	elpm32
    02606 EF8F      LDI	R24,0xFF
    02607 E094      LDI	R25,4
    02608 939A      ST	-Y,R25
    02609 938A      ST	-Y,R24
    0260A 940E 3DB4 CALL	fpsub1x
    0260C 0181      MOVW	R16,R2
    0260D 0192      MOVW	R18,R4
    0260E 940E 3F76 CALL	fpmule2
    02610 9310 0513 STS	Result+57,R17
    02612 9300 0512 STS	Result+56,R16
    02614 9330 0515 STS	Result+59,R19
    02616 9320 0514 STS	Result+58,R18
(0132)  //ECT等价制冷温度
(0133)  Result.ECT = 33 - 0.01085 * Result.WCI;
    02618 E90C      LDI	R16,0x9C
    02619 E010      LDI	R17,0
    0261A 940E 3BFD CALL	elpm32
    0261C 0118      MOVW	R2,R16
    0261D 0129      MOVW	R4,R18
    0261E E908      LDI	R16,0x98
    0261F E010      LDI	R17,0
    02620 940E 3BFD CALL	elpm32
    02622 E182      LDI	R24,0x12
    02623 E095      LDI	R25,5
    02624 939A      ST	-Y,R25
    02625 938A      ST	-Y,R24
    02626 940E 3F81 CALL	fpmule1x
    02628 0181      MOVW	R16,R2
    02629 0192      MOVW	R18,R4
    0262A 940E 3DA9 CALL	fpsub2
    0262C 9310 051D STS	Result+67,R17
    0262E 9300 051C STS	Result+66,R16
    02630 9330 051F STS	Result+69,R19
    02632 9320 051E STS	Result+68,R18
(0134)  //TEQ 相当温度
(0135)  Result.Teq = Result.Temperature +( (Result.Temperature -36)/10 ) * Result.WindSpeed ;
    02634 9040 0501 LDS	R4,Result+39
    02636 9050 0502 LDS	R5,Result+40
    02638 9020 04FF LDS	R2,Result+37
    0263A 9030 0500 LDS	R3,Result+38
    0263C 0131      MOVW	R6,R2
    0263D 0142      MOVW	R8,R4
    0263E E904      LDI	R16,0x94
    0263F E010      LDI	R17,0
    02640 940E 3BFD CALL	elpm32
    02642 933A      ST	-Y,R19
    02643 932A      ST	-Y,R18
    02644 931A      ST	-Y,R17
    02645 930A      ST	-Y,R16
    02646 0183      MOVW	R16,R6
    02647 0194      MOVW	R18,R8
    02648 940E 3DA9 CALL	fpsub2
    0264A 0138      MOVW	R6,R16
    0264B 0149      MOVW	R8,R18
    0264C EA08      LDI	R16,0xA8
    0264D E010      LDI	R17,0
    0264E 940E 3BFD CALL	elpm32
    02650 933A      ST	-Y,R19
    02651 932A      ST	-Y,R18
    02652 931A      ST	-Y,R17
    02653 930A      ST	-Y,R16
    02654 0183      MOVW	R16,R6
    02655 0194      MOVW	R18,R8
    02656 940E 3DFC CALL	fpdiv2
    02658 E089      LDI	R24,0x9
    02659 E095      LDI	R25,5
    0265A 939A      ST	-Y,R25
    0265B 938A      ST	-Y,R24
    0265C 940E 3F81 CALL	fpmule1x
    0265E 0181      MOVW	R16,R2
    0265F 0192      MOVW	R18,R4
    02660 940E 3D9E CALL	fpadd2
    02662 9310 0527 STS	Result+77,R17
    02664 9300 0526 STS	Result+76,R16
    02666 9330 0529 STS	Result+79,R19
    02668 9320 0528 STS	Result+78,R18
(0136) //将数据转换成字符串
(0137)  
(0138) ftochr(Result.WindSpeed,Result.WSChar);
    0266A E08D      LDI	R24,0xD
    0266B E095      LDI	R25,5
    0266C 8399      STD	Y+1,R25
    0266D 8388      ST	Y,R24
    0266E 9120 050B LDS	R18,Result+49
    02670 9130 050C LDS	R19,Result+50
    02672 9100 0509 LDS	R16,Result+47
    02674 9110 050A LDS	R17,Result+48
    02676 D04E      RCALL	_ftochr
(0139) ftochr(Result.Temperature,Result.TempChar);
    02677 E083      LDI	R24,3
    02678 E095      LDI	R25,5
    02679 8399      STD	Y+1,R25
    0267A 8388      ST	Y,R24
    0267B 9120 0501 LDS	R18,Result+39
    0267D 9130 0502 LDS	R19,Result+40
    0267F 9100 04FF LDS	R16,Result+37
    02681 9110 0500 LDS	R17,Result+38
    02683 D041      RCALL	_ftochr
(0140) ftochr(Result.WCI,Result.WCIChar);
    02684 E186      LDI	R24,0x16
    02685 E095      LDI	R25,5
    02686 8399      STD	Y+1,R25
    02687 8388      ST	Y,R24
    02688 9120 0514 LDS	R18,Result+58
    0268A 9130 0515 LDS	R19,Result+59
    0268C 9100 0512 LDS	R16,Result+56
    0268E 9110 0513 LDS	R17,Result+57
    02690 D034      RCALL	_ftochr
(0141) ftochr(Result.ECT,Result.ECTChar);
    02691 E280      LDI	R24,0x20
    02692 E095      LDI	R25,5
    02693 8399      STD	Y+1,R25
    02694 8388      ST	Y,R24
    02695 9120 051E LDS	R18,Result+68
    02697 9130 051F LDS	R19,Result+69
    02699 9100 051C LDS	R16,Result+66
    0269B 9110 051D LDS	R17,Result+67
    0269D D027      RCALL	_ftochr
(0142) ftochr(Result.Teq,Result.TeqChar);
    0269E E28A      LDI	R24,0x2A
    0269F E095      LDI	R25,5
    026A0 8399      STD	Y+1,R25
    026A1 8388      ST	Y,R24
    026A2 9120 0528 LDS	R18,Result+78
    026A4 9130 0529 LDS	R19,Result+79
    026A6 9100 0526 LDS	R16,Result+76
    026A8 9110 0527 LDS	R17,Result+77
    026AA D01A      RCALL	_ftochr
(0143) itoa(Result.IndexChar,Result.Index,10);
    026AB E08A      LDI	R24,0xA
    026AC E090      LDI	R25,0
    026AD 8399      STD	Y+1,R25
    026AE 8388      ST	Y,R24
    026AF 9120 04E4 LDS	R18,Result+10
    026B1 9130 04E5 LDS	R19,Result+11
    026B3 EE06      LDI	R16,0xE6
    026B4 E014      LDI	R17,4
    026B5 940E 3FA7 CALL	_itoa
(0144) Result.TempChar[6]='\0';
    026B7 2422      CLR	R2
    026B8 9220 0509 STS	Result+47,R2
(0145) Result.WSChar[5]='\0';
    026BA 9220 0512 STS	Result+56,R2
(0146) Result.WCIChar[6]='\0';
    026BC 9220 051C STS	Result+66,R2
(0147) Result.ECTChar[6]='\0';
    026BE 9220 0526 STS	Result+76,R2
(0148) Result.TeqChar[6]='\0';
    026C0 9220 0530 STS	Result+86,R2
(0149)  return ;
    026C2 9622      ADIW	R28,2
    026C3 940C 3C55 JMP	pop_xgset003C
_ftochr:
  status               --> Y,+2
  j                    --> R12
  lenth                --> R20
  res                  --> R12
  i                    --> R10
  dest                 --> R14
  a                    --> Y,+12
    026C5 940E 3B30 CALL	push_arg4
    026C7 940E 3C77 CALL	push_xgset30FC
    026C9 9724      SBIW	R28,4
    026CA 88E8      LDD	R14,Y+16
    026CB 88F9      LDD	R15,Y+17
(0150) }
(0151) ////////////////////////////////////////////
(0152) //				字符串转换函数
(0153) //   浮点 到  字符串
(0154) ////////////////////////////////////////////
(0155) void ftochr(float a,char * dest){//float
(0156) char i=0,j=0,lenth;
(0157) int status;
(0158) char *res;
(0159)  res=ftoa(a,&status);  //float to ascii
    026CC 01CE      MOVW	R24,R28
    026CD 9602      ADIW	R24,2
    026CE 8399      STD	Y+1,R25
    026CF 8388      ST	Y,R24
    026D0 850C      LDD	R16,Y+12
    026D1 851D      LDD	R17,Y+13
    026D2 852E      LDD	R18,Y+14
    026D3 853F      LDD	R19,Y+15
    026D4 940E 40CA CALL	_ftoa
    026D6 0168      MOVW	R12,R16
(0160) lenth=strlen(res);
    026D7 940E 3B24 CALL	_strlen
    026D9 2F40      MOV	R20,R16
(0161) 
(0162) for(i=0;i <lenth;i++) 
    026DA 24AA      CLR	R10
    026DB C023      RJMP	0x26FF
(0163)        {
(0164) 	   	dest[i]=res[i];
    026DC 2DEA      MOV	R30,R10
    026DD 27FF      CLR	R31
    026DE 0DEC      ADD	R30,R12
    026DF 1DFD      ADC	R31,R13
    026E0 8020      LD	R2,Z
    026E1 2DEA      MOV	R30,R10
    026E2 27FF      CLR	R31
    026E3 0DEE      ADD	R30,R14
    026E4 1DFF      ADC	R31,R15
    026E5 8220      ST	Z,R2
(0165) 
(0166) 		if( res[i]=='.'  ) 
    026E6 2DEA      MOV	R30,R10
    026E7 27FF      CLR	R31
    026E8 0DEC      ADD	R30,R12
    026E9 1DFD      ADC	R31,R13
    026EA 8180      LD	R24,Z
    026EB 328E      CPI	R24,0x2E
    026EC F489      BNE	0x26FE
(0167) 			{
(0168) 				dest[i+1]=res[i+1];
    026ED 2DEA      MOV	R30,R10
    026EE 27FF      CLR	R31
    026EF 0DEC      ADD	R30,R12
    026F0 1DFD      ADC	R31,R13
    026F1 8021      LDD	R2,Z+1
    026F2 2DEA      MOV	R30,R10
    026F3 27FF      CLR	R31
    026F4 0DEE      ADD	R30,R14
    026F5 1DFF      ADC	R31,R15
    026F6 8221      STD	Z+1,R2
(0169) 					dest[i+2]='\0';
    026F7 2DEA      MOV	R30,R10
    026F8 27FF      CLR	R31
    026F9 0DEE      ADD	R30,R14
    026FA 1DFF      ADC	R31,R15
    026FB 2422      CLR	R2
    026FC 8222      STD	Z+2,R2
(0170) 						return ;    
    026FD C003      RJMP	0x2701
    026FE 94A3      INC	R10
    026FF 16A4      CP	R10,R20
    02700 F2D8      BCS	0x26DC
    02701 9624      ADIW	R28,4
    02702 940E 3C61 CALL	pop_xgset30FC
    02704 9624      ADIW	R28,4
    02705 9508      RET
_itochr:
  dest                 --> R10
  a                    --> R12
    02706 940E 3C7B CALL	push_xgset003C
    02708 0159      MOVW	R10,R18
    02709 0168      MOVW	R12,R16
    0270A 9722      SBIW	R28,2
(0171) 		    }
(0172)  
(0173)  		}
(0174) }
(0175) //////////////////////////////////////////////////////
(0176) //              整型数据变字符串
(0177) //    a  到  dest
(0178) ///////////////////////////////////////////////////////
(0179) void itochr(int a,char * dest){ //int to ascii
(0180) 	 itoa(dest,a,10); 
    0270B E08A      LDI	R24,0xA
    0270C E090      LDI	R25,0
    0270D 8399      STD	Y+1,R25
    0270E 8388      ST	Y,R24
    0270F 0196      MOVW	R18,R12
    02710 0185      MOVW	R16,R10
    02711 940E 3FA7 CALL	_itoa
    02713 9622      ADIW	R28,2
    02714 940C 3C55 JMP	pop_xgset003C
_StructToChar:
  otherbyte            --> Y,+96
  ary                  --> Y,+80
  Temp_Char            --> Y,+0
  i                    --> R10
    02716 92AA      ST	-Y,R10
    02717 97EF      SBIW	R28,0x3F
    02718 97A9      SBIW	R28,0x29
(0181) }
(0182) //////////////////////////////////////////////////////
(0183) //                  结构体 变字符串
(0184) // 将目前存于结构体的数据转换到Temp_Char中。
(0185) ///////////////////////////////////////////////////////
(0186) void  StructToChar(void)
(0187) { unsigned char i;
(0188)   char Temp_Char[80];
(0189)   char otherbyte[]="0\t0\t0\t0";
    02719 EA82      LDI	R24,0xA2
    0271A E091      LDI	R25,1
    0271B 01FE      MOVW	R30,R28
    0271C 5AE0      SUBI	R30,0xA0
    0271D 4FFF      SBCI	R31,0xFF
    0271E E008      LDI	R16,0x8
    0271F E010      LDI	R17,0
    02720 93FA      ST	-Y,R31
    02721 93EA      ST	-Y,R30
    02722 939A      ST	-Y,R25
    02723 938A      ST	-Y,R24
    02724 940E 3D1C CALL	asgnblk
(0190)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    02726 EA8A      LDI	R24,0xAA
    02727 E091      LDI	R25,1
    02728 01FE      MOVW	R30,R28
    02729 5BE0      SUBI	R30,0xB0
    0272A 4FFF      SBCI	R31,0xFF
    0272B E100      LDI	R16,0x10
    0272C E010      LDI	R17,0
    0272D 93FA      ST	-Y,R31
    0272E 93EA      ST	-Y,R30
    0272F 939A      ST	-Y,R25
    02730 938A      ST	-Y,R24
    02731 940E 3D1C CALL	asgnblk
(0191)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0192) 				Result.TeqChar
(0193) 			   };  //指向数组首地址的指针
(0194)   //strcat(Temp_Char,Result.Name);
(0195)   for(i=0;i<=80;i++) Temp_Char[i]='\0';  //清空数组
    02733 24AA      CLR	R10
    02734 C008      RJMP	0x273D
    02735 01CE      MOVW	R24,R28
    02736 2DEA      MOV	R30,R10
    02737 27FF      CLR	R31
    02738 0FE8      ADD	R30,R24
    02739 1FF9      ADC	R31,R25
    0273A 2422      CLR	R2
    0273B 8220      ST	Z,R2
    0273C 94A3      INC	R10
    0273D E580      LDI	R24,0x50
    0273E 158A      CP	R24,R10
    0273F F7A8      BCC	0x2735
(0196)     for(i=0;i<=7;i++){
    02740 24AA      CLR	R10
    02741 C014      RJMP	0x2756
(0197) 		strcat(Temp_Char,ary[i]);  // 按顺序复制字符串
    02742 01CE      MOVW	R24,R28
    02743 5B80      SUBI	R24,0xB0
    02744 4F9F      SBCI	R25,0xFF
    02745 2DEA      MOV	R30,R10
    02746 27FF      CLR	R31
    02747 0FEE      LSL	R30
    02748 1FFF      ROL	R31
    02749 0FE8      ADD	R30,R24
    0274A 1FF9      ADC	R31,R25
    0274B 8120      LD	R18,Z
    0274C 8131      LDD	R19,Z+1
    0274D 018E      MOVW	R16,R28
    0274E 940E 3B17 CALL	_strcat
(0198) 		strcat(Temp_Char,tab);     //
    02750 E02F      LDI	R18,0xF
    02751 E031      LDI	R19,1
    02752 018E      MOVW	R16,R28
    02753 940E 3B17 CALL	_strcat
    02755 94A3      INC	R10
    02756 E087      LDI	R24,7
    02757 158A      CP	R24,R10
    02758 F748      BCC	0x2742
(0199)     }
(0200) 				 
(0201) 				 otherbyte[0]=otherbyte[0]+Result.WeiHai;
    02759 9020 0530 LDS	R2,Result+86
    0275B 01FE      MOVW	R30,R28
    0275C 5AE0      SUBI	R30,0xA0
    0275D 4FFF      SBCI	R31,0xFF
    0275E 8030      LD	R3,Z
    0275F 0C32      ADD	R3,R2
    02760 01FE      MOVW	R30,R28
    02761 5AE0      SUBI	R30,0xA0
    02762 4FFF      SBCI	R31,0xFF
    02763 8230      ST	Z,R3
(0202) 				 otherbyte[2]=otherbyte[0]+Result.LowLabor;
    02764 9020 0531 LDS	R2,Result+87
    02766 0C32      ADD	R3,R2
    02767 01FE      MOVW	R30,R28
    02768 59EE      SUBI	R30,0x9E
    02769 4FFF      SBCI	R31,0xFF
    0276A 8230      ST	Z,R3
(0203) 				 otherbyte[4]=otherbyte[0]+Result.MidLabor;
    0276B 9020 0532 LDS	R2,Result+88
    0276D 01FE      MOVW	R30,R28
    0276E 5AE0      SUBI	R30,0xA0
    0276F 4FFF      SBCI	R31,0xFF
    02770 8030      LD	R3,Z
    02771 0C32      ADD	R3,R2
    02772 01FE      MOVW	R30,R28
    02773 59EC      SUBI	R30,0x9C
    02774 4FFF      SBCI	R31,0xFF
    02775 8230      ST	Z,R3
(0204) 				 otherbyte[6]=otherbyte[0]+Result.HighLabor;
    02776 9020 0533 LDS	R2,Result+89
    02778 01FE      MOVW	R30,R28
    02779 5AE0      SUBI	R30,0xA0
    0277A 4FFF      SBCI	R31,0xFF
    0277B 8030      LD	R3,Z
    0277C 0C32      ADD	R3,R2
    0277D 01FE      MOVW	R30,R28
    0277E 59EA      SUBI	R30,0x9A
    0277F 4FFF      SBCI	R31,0xFF
    02780 8230      ST	Z,R3
(0205)  
(0206)   strcat(Temp_Char,otherbyte);  
    02781 019E      MOVW	R18,R28
    02782 5A20      SUBI	R18,0xA0
    02783 4F3F      SBCI	R19,0xFF
    02784 018E      MOVW	R16,R28
    02785 940E 3B17 CALL	_strcat
(0207)   strcat(Temp_Char,enter);  
    02787 E122      LDI	R18,0x12
    02788 E031      LDI	R19,1
    02789 018E      MOVW	R16,R28
    0278A 940E 3B17 CALL	_strcat
    0278C 96EF      ADIW	R28,0x3F
    0278D 96A9      ADIW	R28,0x29
    0278E 90A9      LD	R10,Y+
    0278F 9508      RET
_CharToStruct:
  Temp_Char            --> Y,+16
  i                    --> R20
  ary                  --> Y,+0
  j                    --> R14
  p                    --> R10
  q                    --> R12
    02790 940E 3C77 CALL	push_xgset30FC
    02792 97EF      SBIW	R28,0x3F
    02793 97A1      SBIW	R28,0x21
(0208) }
(0209) 
(0210) //////////////////////////////////////////////////////
(0211) //               字符串  变  结构体
(0212) // 
(0213) ///////////////////////////////////////////////////////
(0214) void CharToStruct(void)
(0215) {
(0216)   unsigned char i=0,j=0;
    02794 2744      CLR	R20
    02795 24EE      CLR	R14
(0217)   unsigned char *p,*q;
(0218)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    02796 EB8A      LDI	R24,0xBA
    02797 E091      LDI	R25,1
    02798 01FE      MOVW	R30,R28
    02799 E100      LDI	R16,0x10
    0279A E010      LDI	R17,0
    0279B 93FA      ST	-Y,R31
    0279C 93EA      ST	-Y,R30
    0279D 939A      ST	-Y,R25
    0279E 938A      ST	-Y,R24
    0279F 940E 3D1C CALL	asgnblk
(0219)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0220) 				Result.TeqChar
(0221) 			   };  //指向数组首地址的指针
(0222)   char Temp_Char[80];
(0223)     p=ary[j];
    027A1 01CE      MOVW	R24,R28
    027A2 2DEE      MOV	R30,R14
    027A3 27FF      CLR	R31
    027A4 0FEE      LSL	R30
    027A5 1FFF      ROL	R31
    027A6 0FE8      ADD	R30,R24
    027A7 1FF9      ADC	R31,R25
    027A8 80A0      LD	R10,Z
    027A9 80B1      LDD	R11,Z+1
(0224) 	q=Temp_Char;
    027AA 01CE      MOVW	R24,R28
    027AB 9640      ADIW	R24,0x10
    027AC 016C      MOVW	R12,R24
    027AD C01D      RJMP	0x27CB
(0225) 	while(1){
(0226)     if(*q =='\n') {*p='\0'; return;} ;
    027AE 01F6      MOVW	R30,R12
    027AF 8180      LD	R24,Z
    027B0 308A      CPI	R24,0xA
    027B1 F421      BNE	0x27B6
    027B2 2422      CLR	R2
    027B3 01F5      MOVW	R30,R10
    027B4 8220      ST	Z,R2
    027B5 C016      RJMP	0x27CC
(0227) 	if(*q =='\t') {j++;p=ary[j];i=0;}
    027B6 01F6      MOVW	R30,R12
    027B7 8180      LD	R24,Z
    027B8 3089      CPI	R24,0x9
    027B9 F459      BNE	0x27C5
    027BA 94E3      INC	R14
    027BB 01CE      MOVW	R24,R28
    027BC 2DEE      MOV	R30,R14
    027BD 27FF      CLR	R31
    027BE 0FEE      LSL	R30
    027BF 1FFF      ROL	R31
    027C0 0FE8      ADD	R30,R24
    027C1 1FF9      ADC	R31,R25
    027C2 80A0      LD	R10,Z
    027C3 80B1      LDD	R11,Z+1
    027C4 2744      CLR	R20
(0228)     *p++=*q++;
    027C5 01F6      MOVW	R30,R12
    027C6 01D5      MOVW	R26,R10
    027C7 9001      LD	R0,Z+
    027C8 016F      MOVW	R12,R30
    027C9 920D      ST	X+,R0
    027CA 015D      MOVW	R10,R26
    027CB CFE2      RJMP	0x27AE
    027CC 96EF      ADIW	R28,0x3F
    027CD 96A1      ADIW	R28,0x21
    027CE 940C 3C61 JMP	pop_xgset30FC
_get_name:
  i                    --> R20
  filenamep            --> R16
    027D0 940E 3C8A CALL	push_xgsetF000
(0229) 	}
(0230)   }
(0231)  
(0232)  ////////////////////////////////////////////
(0233) //				根据当前日期获取文件名
(0234) //   
(0235) ////////////////////////////////////////////
(0236) char *get_name( char filenamep[] ){     
(0237) 	  unsigned char i=0;
(0238)  	  for(i=0;i<6;i++) {
    027D2 2744      CLR	R20
    027D3 C00D      RJMP	0x27E1
(0239) 	  				    *(filenamep+i)=Result.Date[i];
    027D4 EE8C      LDI	R24,0xEC
    027D5 E094      LDI	R25,4
    027D6 2FE4      MOV	R30,R20
    027D7 27FF      CLR	R31
    027D8 0FE8      ADD	R30,R24
    027D9 1FF9      ADC	R31,R25
    027DA 8020      LD	R2,Z
    027DB 2FE4      MOV	R30,R20
    027DC 27FF      CLR	R31
    027DD 0FE0      ADD	R30,R16
    027DE 1FF1      ADC	R31,R17
    027DF 8220      ST	Z,R2
    027E0 9543      INC	R20
    027E1 3046      CPI	R20,6
    027E2 F388      BCS	0x27D4
(0240) 	  				   } 
(0241) 	 	*(filenamep+(i++))='.';
    027E3 2E24      MOV	R2,R20
    027E4 2433      CLR	R3
    027E5 5F4F      SUBI	R20,0xFF
    027E6 2DE2      MOV	R30,R2
    027E7 27FF      CLR	R31
    027E8 0FE0      ADD	R30,R16
    027E9 1FF1      ADC	R31,R17
    027EA E28E      LDI	R24,0x2E
    027EB 8380      ST	Z,R24
(0242) 		*(filenamep+(i++))='x';
    027EC 2E24      MOV	R2,R20
    027ED 2433      CLR	R3
    027EE 5F4F      SUBI	R20,0xFF
    027EF 2DE2      MOV	R30,R2
    027F0 27FF      CLR	R31
    027F1 0FE0      ADD	R30,R16
    027F2 1FF1      ADC	R31,R17
    027F3 E788      LDI	R24,0x78
    027F4 8380      ST	Z,R24
(0243) 		*(filenamep+(i++))='l';
    027F5 2F64      MOV	R22,R20
    027F6 2777      CLR	R23
    027F7 5F4F      SUBI	R20,0xFF
    027F8 2FE6      MOV	R30,R22
    027F9 27FF      CLR	R31
    027FA 0FE0      ADD	R30,R16
    027FB 1FF1      ADC	R31,R17
    027FC E68C      LDI	R24,0x6C
    027FD 8380      ST	Z,R24
(0244) 		*(filenamep+(i++))='s';
    027FE 2F64      MOV	R22,R20
    027FF 2777      CLR	R23
    02800 5F4F      SUBI	R20,0xFF
    02801 2FE6      MOV	R30,R22
    02802 27FF      CLR	R31
    02803 0FE0      ADD	R30,R16
    02804 1FF1      ADC	R31,R17
    02805 E783      LDI	R24,0x73
    02806 8380      ST	Z,R24
(0245) 		*(filenamep+(i))='\0';
    02807 2FE4      MOV	R30,R20
    02808 27FF      CLR	R31
    02809 0FE0      ADD	R30,R16
    0280A 1FF1      ADC	R31,R17
    0280B 2422      CLR	R2
    0280C 8220      ST	Z,R2
(0246) 					   
(0247)       return filenamep;
    0280D 940C 3C8F JMP	pop_xgsetF000
_SquareRootFloat:
  f                    --> Y,+12
  x                    --> Y,+8
  i                    --> Y,+4
  y                    --> Y,+0
  number               --> Y,+20
    0280F 940E 3B30 CALL	push_arg4
    02811 940E 3C8A CALL	push_xgsetF000
    02813 9760      SBIW	R28,0x10
(0248) } 
(0249) float SquareRootFloat(float number)
(0250) {
(0251)     long i;
(0252)     float x, y;
(0253)     const float f = 1.5F;
    02814 E900      LDI	R16,0x90
    02815 E010      LDI	R17,0
    02816 940E 3BFD CALL	elpm32
    02818 870C      STD	Y+12,R16
    02819 871D      STD	Y+13,R17
    0281A 872E      STD	Y+14,R18
    0281B 873F      STD	Y+15,R19
(0254)     x = number * 0.5F;
    0281C E80C      LDI	R16,0x8C
    0281D E010      LDI	R17,0
    0281E 940E 3BFD CALL	elpm32
    02820 01CE      MOVW	R24,R28
    02821 9644      ADIW	R24,0x14
    02822 939A      ST	-Y,R25
    02823 938A      ST	-Y,R24
    02824 940E 3F6C CALL	fpmule1
    02826 8708      STD	Y+8,R16
    02827 8719      STD	Y+9,R17
    02828 872A      STD	Y+10,R18
    02829 873B      STD	Y+11,R19
(0255)     y  = number;
    0282A 882C      LDD	R2,Y+20
    0282B 883D      LDD	R3,Y+21
    0282C 884E      LDD	R4,Y+22
    0282D 885F      LDD	R5,Y+23
    0282E 8228      ST	Y,R2
    0282F 8239      STD	Y+1,R3
    02830 824A      STD	Y+2,R4
    02831 825B      STD	Y+3,R5
(0256)     i  = * ( long * ) &y;
    02832 01FE      MOVW	R30,R28
    02833 8020      LD	R2,Z
    02834 8031      LDD	R3,Z+1
    02835 8042      LDD	R4,Z+2
    02836 8053      LDD	R5,Z+3
    02837 822C      STD	Y+4,R2
    02838 823D      STD	Y+5,R3
    02839 824E      STD	Y+6,R4
    0283A 825F      STD	Y+7,R5
(0257)     i  = 0x5f3759df - ( i >> 1 );  //卡马克
    0283B 802C      LDD	R2,Y+4
    0283C 803D      LDD	R3,Y+5
    0283D 804E      LDD	R4,Y+6
    0283E 805F      LDD	R5,Y+7
    0283F 9455      ASR	R5
    02840 9447      ROR	R4
    02841 9437      ROR	R3
    02842 9427      ROR	R2
    02843 ED4F      LDI	R20,0xDF
    02844 E559      LDI	R21,0x59
    02845 E367      LDI	R22,0x37
    02846 E57F      LDI	R23,0x5F
    02847 1942      SUB	R20,R2
    02848 0953      SBC	R21,R3
    02849 0964      SBC	R22,R4
    0284A 0975      SBC	R23,R5
    0284B 834C      STD	Y+4,R20
    0284C 835D      STD	Y+5,R21
    0284D 836E      STD	Y+6,R22
    0284E 837F      STD	Y+7,R23
(0258)   //i  = 0x5f375a86 - ( i >> 1 );  //Lomont
(0259)     y  = * ( float * ) &i;
    0284F 01FE      MOVW	R30,R28
    02850 9634      ADIW	R30,4
    02851 8020      LD	R2,Z
    02852 8031      LDD	R3,Z+1
    02853 8042      LDD	R4,Z+2
    02854 8053      LDD	R5,Z+3
    02855 8228      ST	Y,R2
    02856 8239      STD	Y+1,R3
    02857 824A      STD	Y+2,R4
    02858 825B      STD	Y+3,R5
(0260)     y  = y * ( f - ( x * y * y ) );
    02859 8028      LD	R2,Y
    0285A 8039      LDD	R3,Y+1
    0285B 804A      LDD	R4,Y+2
    0285C 805B      LDD	R5,Y+3
    0285D 846C      LDD	R6,Y+12
    0285E 847D      LDD	R7,Y+13
    0285F 848E      LDD	R8,Y+14
    02860 849F      LDD	R9,Y+15
    02861 8508      LDD	R16,Y+8
    02862 8519      LDD	R17,Y+9
    02863 852A      LDD	R18,Y+10
    02864 853B      LDD	R19,Y+11
    02865 01CE      MOVW	R24,R28
    02866 939A      ST	-Y,R25
    02867 938A      ST	-Y,R24
    02868 940E 3F6C CALL	fpmule1
    0286A 01CE      MOVW	R24,R28
    0286B 939A      ST	-Y,R25
    0286C 938A      ST	-Y,R24
    0286D 940E 3F81 CALL	fpmule1x
    0286F 0183      MOVW	R16,R6
    02870 0194      MOVW	R18,R8
    02871 940E 3DC1 CALL	fpsub2x
    02873 0181      MOVW	R16,R2
    02874 0192      MOVW	R18,R4
    02875 940E 3F76 CALL	fpmule2
    02877 8308      ST	Y,R16
    02878 8319      STD	Y+1,R17
    02879 832A      STD	Y+2,R18
    0287A 833B      STD	Y+3,R19
(0261)     y  = y * ( f - ( x * y * y ) );
    0287B 8028      LD	R2,Y
    0287C 8039      LDD	R3,Y+1
    0287D 804A      LDD	R4,Y+2
    0287E 805B      LDD	R5,Y+3
    0287F 846C      LDD	R6,Y+12
    02880 847D      LDD	R7,Y+13
    02881 848E      LDD	R8,Y+14
    02882 849F      LDD	R9,Y+15
    02883 8508      LDD	R16,Y+8
    02884 8519      LDD	R17,Y+9
    02885 852A      LDD	R18,Y+10
    02886 853B      LDD	R19,Y+11
    02887 01CE      MOVW	R24,R28
    02888 939A      ST	-Y,R25
    02889 938A      ST	-Y,R24
    0288A 940E 3F6C CALL	fpmule1
    0288C 01CE      MOVW	R24,R28
    0288D 939A      ST	-Y,R25
    0288E 938A      ST	-Y,R24
    0288F 940E 3F81 CALL	fpmule1x
    02891 0183      MOVW	R16,R6
    02892 0194      MOVW	R18,R8
    02893 940E 3DC1 CALL	fpsub2x
    02895 0181      MOVW	R16,R2
    02896 0192      MOVW	R18,R4
    02897 940E 3F76 CALL	fpmule2
    02899 8308      ST	Y,R16
    0289A 8319      STD	Y+1,R17
    0289B 832A      STD	Y+2,R18
    0289C 833B      STD	Y+3,R19
(0262)     return number * y;
    0289D 890C      LDD	R16,Y+20
    0289E 891D      LDD	R17,Y+21
    0289F 892E      LDD	R18,Y+22
    028A0 893F      LDD	R19,Y+23
    028A1 01CE      MOVW	R24,R28
    028A2 939A      ST	-Y,R25
    028A3 938A      ST	-Y,R24
    028A4 940E 3F6C CALL	fpmule1
    028A6 9660      ADIW	R28,0x10
    028A7 940E 3C8F CALL	pop_xgsetF000
    028A9 9624      ADIW	R28,4
    028AA 9508      RET
_debug:
  str2                 --> Y,+0
  val                  --> R10
  str                  --> R12
    028AB 940E 3C7B CALL	push_xgset003C
    028AD 2EA2      MOV	R10,R18
    028AE 0168      MOVW	R12,R16
    028AF 9724      SBIW	R28,4
(0263) } 
(0264) //
(0265) //###############################################################//
(0266) //debug
(0267) void debug(UINT8 *str,UINT8 val)
(0268) {
(0269)  UINT8 str2[4]={0,0,0,0};
    028B0 EC8A      LDI	R24,0xCA
    028B1 E091      LDI	R25,1
    028B2 01FE      MOVW	R30,R28
    028B3 E004      LDI	R16,4
    028B4 E010      LDI	R17,0
    028B5 93FA      ST	-Y,R31
    028B6 93EA      ST	-Y,R30
    028B7 939A      ST	-Y,R25
    028B8 938A      ST	-Y,R24
    028B9 940E 3D1C CALL	asgnblk
(0270)  str=str;
(0271)  val=val;
(0272)  #ifdef _UARTDEBUG
(0273)  PrintString("\r\n");
    028BB EC0E      LDI	R16,0xCE
    028BC E011      LDI	R17,1
    028BD 940E 3306 CALL	_PrintString
(0274)  PrintString(str);
    028BF 0186      MOVW	R16,R12
    028C0 940E 3306 CALL	_PrintString
(0275)  PrintChar(val);
    028C2 2D0A      MOV	R16,R10
    028C3 940E 3470 CALL	_PrintChar
    028C5 9624      ADIW	R28,4
    028C6 940C 3C55 JMP	pop_xgset003C
_SD_Write_cmd:
  k                    --> R22
  temp                 --> R20
  p                    --> R20
    028C8 940E 3C8A CALL	push_xgsetF000
    028CA 01A8      MOVW	R20,R16
FILE: D:\LQD\software\master\software_src\sd.c
(0001) //*****************************************************************************//
(0002) //*								数码相框
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SD卡控制
(0006) //*修改者：  桃子
(0007) //*****************************************************************************//
(0008) #include "sd.h"
(0009) 
(0010) //****************************************************************
(0011) //*隶属模块：SD卡控制
(0012) //*函数功能：写6字节数据
(0013) //****************************************************************
(0014) UINT8 SD_Write_cmd(UINT8 *p)
(0015) {	
(0016) 	UINT16 temp,k=0;
    028CB 2766      CLR	R22
    028CC 2777      CLR	R23
(0017) 	SD_CS_DIS();//禁止SPI
    028CD 9AC0      SBI	0x18,0
(0018) 	SPI_Read();//空读一字节
    028CE 940E 349E CALL	_SPI_Read
(0019) 	SD_CS_EN();//使能SPI
    028D0 98C0      CBI	0x18,0
(0020) 
(0021) 	SPI_Write(p[0]);
    028D1 01FA      MOVW	R30,R20
    028D2 8100      LD	R16,Z
    028D3 940E 349A CALL	_SPI_Write
(0022) 	SPI_Write(p[1]);
    028D5 01FA      MOVW	R30,R20
    028D6 8101      LDD	R16,Z+1
    028D7 940E 349A CALL	_SPI_Write
(0023) 	SPI_Write(p[2]);
    028D9 01FA      MOVW	R30,R20
    028DA 8102      LDD	R16,Z+2
    028DB 940E 349A CALL	_SPI_Write
(0024) 	SPI_Write(p[3]);
    028DD 01FA      MOVW	R30,R20
    028DE 8103      LDD	R16,Z+3
    028DF 940E 349A CALL	_SPI_Write
(0025) 	SPI_Write(p[4]);
    028E1 01FA      MOVW	R30,R20
    028E2 8104      LDD	R16,Z+4
    028E3 940E 349A CALL	_SPI_Write
(0026) 	SPI_Write(p[5]);
    028E5 01FA      MOVW	R30,R20
    028E6 8105      LDD	R16,Z+5
    028E7 940E 349A CALL	_SPI_Write
(0027) 
(0028) 	do 
(0029)  	{  
(0030)   		temp = SPI_Read();//一直读，直到读到的不是0xff或超时
    028E9 940E 349E CALL	_SPI_Read
    028EB 2F40      MOV	R20,R16
    028EC 2755      CLR	R21
(0031)  		k++;
    028ED 5F6F      SUBI	R22,0xFF
    028EE 4F7F      SBCI	R23,0xFF
(0032)  	}while((temp==0xff)&&(k<TRY_TIME)); 
    028EF 3F4F      CPI	R20,0xFF
    028F0 E0E0      LDI	R30,0
    028F1 075E      CPC	R21,R30
    028F2 F421      BNE	0x28F7
    028F3 3164      CPI	R22,0x14
    028F4 E0E0      LDI	R30,0
    028F5 077E      CPC	R23,R30
    028F6 F390      BCS	0x28E9
(0033) 
(0034) 	return temp;
    028F7 2F04      MOV	R16,R20
    028F8 940C 3C8F JMP	pop_xgsetF000
_SD_Init:
  pcmd                 --> Y,+0
  temp                 --> R22
  time                 --> R20
    028FA 940E 3C94 CALL	push_xgsetF00C
    028FC 9726      SBIW	R28,6
(0035) }
(0036) //****************************************************************
(0037) //*隶属模块：SD卡控制
(0038) //*函数功能：初始化
(0039) //****************************************************************
(0040) UINT8 SD_Init(void)	
(0041) {  
(0042) 	UINT8 time=0,temp=0;
    028FD 2744      CLR	R20
    028FE 2766      CLR	R22
(0043) 	UINT8 pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; //命令0的字节序列
    028FF E389      LDI	R24,0x39
    02900 E092      LDI	R25,2
    02901 01FE      MOVW	R30,R28
    02902 E006      LDI	R16,6
    02903 E010      LDI	R17,0
    02904 93FA      ST	-Y,R31
    02905 93EA      ST	-Y,R30
    02906 939A      ST	-Y,R25
    02907 938A      ST	-Y,R24
    02908 940E 3D1C CALL	asgnblk
(0044) 	if(SD_DET()==0) return 0x02; //no disk
    0290A B181      IN	R24,0x01
    0290B 9586      LSR	R24
    0290C 9586      LSR	R24
    0290D 9586      LSR	R24
    0290E 9586      LSR	R24
    0290F 9586      LSR	R24
    02910 7081      ANDI	R24,1
    02911 F421      BNE	0x2916
    02912 E081      LDI	R24,1
    02913 E090      LDI	R25,0
    02914 015C      MOVW	R10,R24
    02915 C002      RJMP	0x2918
    02916 24AA      CLR	R10
    02917 24BB      CLR	R11
    02918 20AA      TST	R10
    02919 F421      BNE	0x291E
    0291A 20BB      TST	R11
    0291B F411      BNE	0x291E
    0291C E002      LDI	R16,2
    0291D C039      RJMP	0x2957
(0045) 	SD_PORT |= (1<<SD_CS);
    0291E 9AC0      SBI	0x18,0
(0046) 	SD_DDR |= (1<<SD_CS);
    0291F 9AB8      SBI	0x17,0
(0047) 
(0048) 	SPI_IO_Init();
    02920 940E 3490 CALL	_SPI_IO_Init
(0049) 	SPI_Low();
    02922 E582      LDI	R24,0x52
    02923 B98D      OUT	0x0D,R24
    02924 B18E      IN	R24,0x0E
    02925 7F8F      ANDI	R24,0xFF
    02926 B98E      OUT	0x0E,R24
(0050) 
(0051) 	SD_CS_DIS();  //关闭片选 
    02927 9AC0      SBI	0x18,0
(0052) 	for(time=0;time<10;time++) //初始时，首先要发送最少74个时钟信号，这是必须的！！！
    02928 2744      CLR	R20
    02929 C003      RJMP	0x292D
(0053) 	{
(0054)   		SPI_Read(); 
    0292A 940E 349E CALL	_SPI_Read
    0292C 9543      INC	R20
    0292D 304A      CPI	R20,0xA
    0292E F3D8      BCS	0x292A
(0055) 	}
(0056) 	SD_CS_EN(); //打开片选
    0292F 98C0      CBI	0x18,0
(0057) 	time = 0;
    02930 2744      CLR	R20
(0058) 	do
(0059) 	{ 
(0060) 		temp=SD_Write_cmd(pcmd);//写入CMD0
    02931 018E      MOVW	R16,R28
    02932 DF95      RCALL	_SD_Write_cmd
    02933 2F60      MOV	R22,R16
(0061) 	 	time++;
    02934 9543      INC	R20
(0062) 	 	if(time==TRY_TIME) 
    02935 3144      CPI	R20,0x14
    02936 F419      BNE	0x293A
(0063) 	 	{ 
(0064) 	  		SD_CS_DIS(); //关闭片选
    02937 9AC0      SBI	0x18,0
(0065) 	  		return(INIT_CMD0_ERROR);//CMD0写入失败
    02938 E001      LDI	R16,1
    02939 C01D      RJMP	0x2957
(0066) 	 	}
(0067) 	 }while(temp!=0x01);
    0293A 3061      CPI	R22,1
    0293B F7A9      BNE	0x2931
(0068) 
(0069) 	SD_CS_DIS(); //关闭片选
    0293C 9AC0      SBI	0x18,0
(0070) 	SPI_Read(); //按照SD卡的操作时序在这里补8个时钟 
    0293D 940E 349E CALL	_SPI_Read
(0071) 	SD_CS_EN(); //打开片选
    0293F 98C0      CBI	0x18,0
(0072) 
(0073) 	pcmd[0]=0x41,pcmd[5]=0xff;
    02940 E481      LDI	R24,0x41
    02941 8388      ST	Y,R24
    02942 EF8F      LDI	R24,0xFF
    02943 838D      STD	Y+5,R24
(0074) 	time = 0;
    02944 2744      CLR	R20
(0075) 	do
(0076) 	{ 
(0077) 		temp=SD_Write_cmd(pcmd);
    02945 018E      MOVW	R16,R28
    02946 DF81      RCALL	_SD_Write_cmd
    02947 2F60      MOV	R22,R16
(0078) 		time++;
    02948 9543      INC	R20
(0079) 		if(time==TRY_TIME) 
    02949 3144      CPI	R20,0x14
    0294A F419      BNE	0x294E
(0080) 		{ 
(0081) 		 	SD_CS_DIS(); //关闭片选
    0294B 9AC0      SBI	0x18,0
(0082) 			 return(INIT_CMD1_ERROR);//CMD1写入失败
    0294C E002      LDI	R16,2
    0294D C009      RJMP	0x2957
(0083) 		 }
(0084) 	 }while(temp!=0);
    0294E 2366      TST	R22
    0294F F7A9      BNE	0x2945
(0085)   
(0086) 	 SPI_High();  
    02950 E580      LDI	R24,0x50
    02951 B98D      OUT	0x0D,R24
    02952 9A70      SBI	0x0E,0
(0087) 	 SD_CS_DIS();  //关闭片选 
    02953 9AC0      SBI	0x18,0
(0088) 	 SPI_Read(); //按照SD卡的操作时序在这里补8个时钟
    02954 940E 349E CALL	_SPI_Read
(0089) 	 return SD_TURE; //返回0,说明初始化操作成功
    02956 2700      CLR	R16
    02957 9626      ADIW	R28,6
    02958 940C 3C9B JMP	pop_xgsetF00C
_SD_Write_Sector:
  pcmd                 --> Y,+0
  time                 --> R12
  temp                 --> R20
  i                    --> R22
  buffer               --> R10
  addr                 --> Y,+14
    0295A 940E 3B30 CALL	push_arg4
    0295C 940E 3CB0 CALL	push_xgsetF03C
    0295E 9726      SBIW	R28,6
    0295F 88AA      LDD	R10,Y+18
    02960 88BB      LDD	R11,Y+19
(0090) } 
(0091) //****************************************************************
(0092) //*隶属模块：SD卡控制
(0093) //*函数功能：写512字节数据（一扇区字节）
(0094) //****************************************************************
(0095) UINT16 SD_Write_Sector(UINT32 addr,UINT8 *buffer)
(0096) {  
(0097) 	UINT8 temp=0,time=0;
    02961 2744      CLR	R20
    02962 24CC      CLR	R12
(0098) 	UINT16 i=0;
    02963 2766      CLR	R22
    02964 2777      CLR	R23
(0099) 	UINT8 pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //向SD卡中单个块（512字节，一个扇区）写入数据，用CMD24
    02965 E38F      LDI	R24,0x3F
    02966 E092      LDI	R25,2
    02967 01FE      MOVW	R30,R28
    02968 E006      LDI	R16,6
    02969 E010      LDI	R17,0
    0296A 93FA      ST	-Y,R31
    0296B 93EA      ST	-Y,R30
    0296C 939A      ST	-Y,R25
    0296D 938A      ST	-Y,R24
    0296E 940E 3D1C CALL	asgnblk
(0100) 
(0101) 	 addr<<=9; //将块地址（扇区地址）转为字节地址 ［这里就限制了SD卡的最大容量为4G］
    02970 E089      LDI	R24,0x9
    02971 E090      LDI	R25,0
    02972 850E      LDD	R16,Y+14
    02973 851F      LDD	R17,Y+15
    02974 8928      LDD	R18,Y+16
    02975 8939      LDD	R19,Y+17
    02976 938A      ST	-Y,R24
    02977 940E 3CF7 CALL	lsl32
    02979 870E      STD	Y+14,R16
    0297A 871F      STD	Y+15,R17
    0297B 8B28      STD	Y+16,R18
    0297C 8B39      STD	Y+17,R19
(0102) 
(0103) 	 pcmd[1]=(addr>>24); //将字节地址写入到CMD24字节序列中
    0297D E188      LDI	R24,0x18
    0297E E090      LDI	R25,0
    0297F 850E      LDD	R16,Y+14
    02980 851F      LDD	R17,Y+15
    02981 8928      LDD	R18,Y+16
    02982 8939      LDD	R19,Y+17
    02983 938A      ST	-Y,R24
    02984 940E 3D10 CALL	lsr32
    02986 8309      STD	Y+1,R16
(0104) 	 pcmd[2]=(addr>>16);
    02987 842E      LDD	R2,Y+14
    02988 843F      LDD	R3,Y+15
    02989 8848      LDD	R4,Y+16
    0298A 8859      LDD	R5,Y+17
    0298B 0112      MOVW	R2,R4
    0298C 2444      CLR	R4
    0298D 2455      CLR	R5
    0298E 822A      STD	Y+2,R2
(0105) 	 pcmd[3]=(addr>>8);
    0298F E088      LDI	R24,0x8
    02990 E090      LDI	R25,0
    02991 850E      LDD	R16,Y+14
    02992 851F      LDD	R17,Y+15
    02993 8928      LDD	R18,Y+16
    02994 8939      LDD	R19,Y+17
    02995 938A      ST	-Y,R24
    02996 940E 3D10 CALL	lsr32
    02998 830B      STD	Y+3,R16
(0106) 	// pcmd[4]=offset;	
(0107) 	 SD_CS_EN();//打开SD卡片选
    02999 98C0      CBI	0x18,0
(0108) 
(0109) 	 do
(0110) 	 {  
(0111) 		temp=SD_Write_cmd(pcmd);
    0299A 018E      MOVW	R16,R28
    0299B DF2C      RCALL	_SD_Write_cmd
    0299C 2F40      MOV	R20,R16
(0112)   		time++;
    0299D 94C3      INC	R12
(0113)   		if(time==TRY_TIME) 
    0299E 2D8C      MOV	R24,R12
    0299F 3184      CPI	R24,0x14
    029A0 F419      BNE	0x29A4
(0114)   		{ 
(0115)    			SD_CS_DIS(); //关闭片选
    029A1 9AC0      SBI	0x18,0
(0116)    			return(temp); //命令写入失败
    029A2 2711      CLR	R17
    029A3 C037      RJMP	0x29DB
(0117)   		}
(0118) 	}while(temp!=0); 
    029A4 2344      TST	R20
    029A5 F7A1      BNE	0x299A
(0119) 
(0120) 	for(i=0;i<100;i++) //这里要插入若干时钟信号
    029A6 2766      CLR	R22
    029A7 2777      CLR	R23
    029A8 C004      RJMP	0x29AD
(0121)   		SPI_Read();
    029A9 940E 349E CALL	_SPI_Read
    029AB 5F6F      SUBI	R22,0xFF
    029AC 4F7F      SBCI	R23,0xFF
    029AD 3664      CPI	R22,0x64
    029AE E0E0      LDI	R30,0
    029AF 077E      CPC	R23,R30
    029B0 F3C0      BCS	0x29A9
(0122) 	
(0123) 	SPI_Write(0xfe);//写入开始字节 0xfe，后面就是要写入的512个字节的数据	
    029B1 EF0E      LDI	R16,0xFE
    029B2 940E 349A CALL	_SPI_Write
(0124) 	
(0125) 	for(i=0;i<512;i++) //将缓冲区中要写入的512个字节写入SD卡
    029B4 2766      CLR	R22
    029B5 2777      CLR	R23
    029B6 C007      RJMP	0x29BE
(0126) 		SPI_Write(*buffer++);
    029B7 01F5      MOVW	R30,R10
    029B8 9101      LD	R16,Z+
    029B9 015F      MOVW	R10,R30
    029BA 940E 349A CALL	_SPI_Write
    029BC 5F6F      SUBI	R22,0xFF
    029BD 4F7F      SBCI	R23,0xFF
    029BE 3060      CPI	R22,0
    029BF E0E2      LDI	R30,2
    029C0 077E      CPC	R23,R30
    029C1 F3A8      BCS	0x29B7
(0127)   
(0128) 	SPI_Read(); 
    029C2 940E 349E CALL	_SPI_Read
(0129) 	SPI_Read(); //两个字节的CRC校验码，不用关心
    029C4 940E 349E CALL	_SPI_Read
(0130)    
(0131)     
(0132) 	temp=SPI_Read();   //读取返回值
    029C6 940E 349E CALL	_SPI_Read
    029C8 2F40      MOV	R20,R16
(0133) 	if((temp&0x1F)!=0x05) //如果返回值是 XXX00101说明数据已经被SD卡接受了
    029C9 2F84      MOV	R24,R20
    029CA 718F      ANDI	R24,0x1F
    029CB 3085      CPI	R24,5
    029CC F021      BEQ	0x29D1
(0134) 	{
(0135)  		SD_CS_DIS();
    029CD 9AC0      SBI	0x18,0
(0136)  		return(WRITE_BLOCK_ERROR); //写块数据失败
    029CE E003      LDI	R16,3
    029CF E010      LDI	R17,0
    029D0 C00A      RJMP	0x29DB
(0137) 	}
(0138)  
(0139) 	while(SPI_Read()!=0xff);//等到SD卡不忙（数据被接受以后，SD卡要将这些数据写入到自身的FLASH中，需要一个时间）
    029D1 940E 349E CALL	_SPI_Read
    029D3 2F40      MOV	R20,R16
    029D4 3F0F      CPI	R16,0xFF
    029D5 F7D9      BNE	0x29D1
(0140) 						    //忙时，读回来的值为0x00,不忙时，为0xff
(0141) 
(0142) 	SD_CS_DIS(); //关闭片选
    029D6 9AC0      SBI	0x18,0
(0143) 
(0144) 	SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    029D7 940E 349E CALL	_SPI_Read
(0145) 	return SD_TURE;		 //返回0,说明写扇区操作成功
    029D9 2700      CLR	R16
    029DA 2711      CLR	R17
    029DB 9626      ADIW	R28,6
    029DC 940E 3CB9 CALL	pop_xgsetF03C
    029DE 9624      ADIW	R28,4
    029DF 9508      RET
_SD_Read_Sector:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  buffer               --> R10
  addr                 --> Y,+14
    029E0 940E 3B30 CALL	push_arg4
    029E2 940E 3CB0 CALL	push_xgsetF03C
    029E4 9726      SBIW	R28,6
    029E5 88AA      LDD	R10,Y+18
    029E6 88BB      LDD	R11,Y+19
(0146) } 
(0147) //****************************************************************
(0148) //*隶属模块：SD卡控制
(0149) //*函数功能：读512字节数据（一扇区字节）
(0150) //****************************************************************
(0151) UINT16 SD_Read_Sector(UINT32 addr,UINT8 *buffer)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0152) {
(0153) 
(0154) 	 UINT16 j=0;
    029E7 2744      CLR	R20
    029E8 2755      CLR	R21
(0155) 	 UINT8 time=0,temp=0;
    029E9 2766      CLR	R22
    029EA 24CC      CLR	R12
(0156) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    029EB E485      LDI	R24,0x45
    029EC E092      LDI	R25,2
    029ED 01FE      MOVW	R30,R28
    029EE E006      LDI	R16,6
    029EF E010      LDI	R17,0
    029F0 93FA      ST	-Y,R31
    029F1 93EA      ST	-Y,R30
    029F2 939A      ST	-Y,R25
    029F3 938A      ST	-Y,R24
    029F4 940E 3D1C CALL	asgnblk
(0157) 
(0158) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    029F6 E089      LDI	R24,0x9
    029F7 E090      LDI	R25,0
    029F8 850E      LDD	R16,Y+14
    029F9 851F      LDD	R17,Y+15
    029FA 8928      LDD	R18,Y+16
    029FB 8939      LDD	R19,Y+17
    029FC 938A      ST	-Y,R24
    029FD 940E 3CF7 CALL	lsl32
    029FF 870E      STD	Y+14,R16
    02A00 871F      STD	Y+15,R17
    02A01 8B28      STD	Y+16,R18
    02A02 8B39      STD	Y+17,R19
(0159) 
(0160) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02A03 E188      LDI	R24,0x18
    02A04 E090      LDI	R25,0
    02A05 850E      LDD	R16,Y+14
    02A06 851F      LDD	R17,Y+15
    02A07 8928      LDD	R18,Y+16
    02A08 8939      LDD	R19,Y+17
    02A09 938A      ST	-Y,R24
    02A0A 940E 3D10 CALL	lsr32
    02A0C 8309      STD	Y+1,R16
(0161) 	 pcmd[2] = (addr>>16);
    02A0D 842E      LDD	R2,Y+14
    02A0E 843F      LDD	R3,Y+15
    02A0F 8848      LDD	R4,Y+16
    02A10 8859      LDD	R5,Y+17
    02A11 0112      MOVW	R2,R4
    02A12 2444      CLR	R4
    02A13 2455      CLR	R5
    02A14 822A      STD	Y+2,R2
(0162) 	 pcmd[3] =(addr>>8);
    02A15 E088      LDI	R24,0x8
    02A16 E090      LDI	R25,0
    02A17 850E      LDD	R16,Y+14
    02A18 851F      LDD	R17,Y+15
    02A19 8928      LDD	R18,Y+16
    02A1A 8939      LDD	R19,Y+17
    02A1B 938A      ST	-Y,R24
    02A1C 940E 3D10 CALL	lsr32
    02A1E 830B      STD	Y+3,R16
(0163) 	// pcmd[4] = offset;
(0164) 
(0165) 	 SD_CS_EN();//打开片选 
    02A1F 98C0      CBI	0x18,0
(0166) 
(0167) 	 do
(0168) 	 {  
(0169) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02A20 018E      MOVW	R16,R28
    02A21 DEA6      RCALL	_SD_Write_cmd
    02A22 2EC0      MOV	R12,R16
(0170) 		  time++;
    02A23 9563      INC	R22
(0171) 		  if(time==TRY_TIME) 
    02A24 3164      CPI	R22,0x14
    02A25 F421      BNE	0x2A2A
(0172) 		  {
(0173) 		   SD_CS_DIS();
    02A26 9AC0      SBI	0x18,0
(0174) 		   return(READ_BLOCK_ERROR); //读块失败
    02A27 E004      LDI	R16,4
    02A28 E010      LDI	R17,0
    02A29 C01F      RJMP	0x2A49
(0175) 		  }
(0176) 	 }while(temp!=0); 
    02A2A 20CC      TST	R12
    02A2B F7A1      BNE	0x2A20
(0177)    			
(0178) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02A2C 940E 349E CALL	_SPI_Read
    02A2E 3F0E      CPI	R16,0xFE
    02A2F F7E1      BNE	0x2A2C
(0179)  		   	   	
(0180) 	 for(j=0;j<512;j++)	 //将数据写入到数据缓冲区中
    02A30 2744      CLR	R20
    02A31 2755      CLR	R21
    02A32 C009      RJMP	0x2A3C
(0181) 	 {	
(0182) 	    buffer[j]=SPI_Read();
    02A33 940E 349E CALL	_SPI_Read
    02A35 2EC0      MOV	R12,R16
    02A36 01FA      MOVW	R30,R20
    02A37 0DEA      ADD	R30,R10
    02A38 1DFB      ADC	R31,R11
    02A39 82C0      ST	Z,R12
    02A3A 5F4F      SUBI	R20,0xFF
    02A3B 4F5F      SBCI	R21,0xFF
    02A3C 3040      CPI	R20,0
    02A3D E0E2      LDI	R30,2
    02A3E 075E      CPC	R21,R30
    02A3F F398      BCS	0x2A33
(0183) 	 }
(0184) 
(0185) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02A40 940E 349E CALL	_SPI_Read
(0186) 	 SPI_Read();
    02A42 940E 349E CALL	_SPI_Read
(0187) 
(0188) 	 SD_CS_DIS();  //SD卡关闭片选 
    02A44 9AC0      SBI	0x18,0
(0189) 
(0190) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02A45 940E 349E CALL	_SPI_Read
(0191) 
(0192) 	 return SD_TURE;
    02A47 2700      CLR	R16
    02A48 2711      CLR	R17
    02A49 9626      ADIW	R28,6
    02A4A 940E 3CB9 CALL	pop_xgsetF03C
    02A4C 9624      ADIW	R28,4
    02A4D 9508      RET
_SD_Read_Sector_ndata:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  len                  --> R14
  offset               --> R10
  buffer               --> Y,+20
  addr                 --> Y,+16
    02A4E 940E 3B30 CALL	push_arg4
    02A50 940E 3C75 CALL	push_xgsetF0FC
    02A52 9726      SBIW	R28,6
    02A53 88AE      LDD	R10,Y+22
    02A54 88BF      LDD	R11,Y+23
    02A55 8CE8      LDD	R14,Y+24
    02A56 8CF9      LDD	R15,Y+25
(0193) }
(0194) //****************************************************************
(0195) //*隶属模块：SD卡控制
(0196) //*函数功能：写多扇区数据（多扇区字节）
(0197) //****************************************************************
(0198) UINT16 SD_Read_Sector_ndata(UINT32 addr,UINT8 *buffer,UINT16 offset,UINT16 len)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0199) {
(0200) 
(0201) 	 UINT16 j=0;
    02A57 2744      CLR	R20
    02A58 2755      CLR	R21
(0202) 	 UINT8 time=0,temp=0;
    02A59 2766      CLR	R22
    02A5A 24CC      CLR	R12
(0203) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02A5B E48B      LDI	R24,0x4B
    02A5C E092      LDI	R25,2
    02A5D 01FE      MOVW	R30,R28
    02A5E E006      LDI	R16,6
    02A5F E010      LDI	R17,0
    02A60 93FA      ST	-Y,R31
    02A61 93EA      ST	-Y,R30
    02A62 939A      ST	-Y,R25
    02A63 938A      ST	-Y,R24
    02A64 940E 3D1C CALL	asgnblk
(0204) 
(0205) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02A66 E089      LDI	R24,0x9
    02A67 E090      LDI	R25,0
    02A68 8908      LDD	R16,Y+16
    02A69 8919      LDD	R17,Y+17
    02A6A 892A      LDD	R18,Y+18
    02A6B 893B      LDD	R19,Y+19
    02A6C 938A      ST	-Y,R24
    02A6D 940E 3CF7 CALL	lsl32
    02A6F 8B08      STD	Y+16,R16
    02A70 8B19      STD	Y+17,R17
    02A71 8B2A      STD	Y+18,R18
    02A72 8B3B      STD	Y+19,R19
(0206) 
(0207) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02A73 E188      LDI	R24,0x18
    02A74 E090      LDI	R25,0
    02A75 8908      LDD	R16,Y+16
    02A76 8919      LDD	R17,Y+17
    02A77 892A      LDD	R18,Y+18
    02A78 893B      LDD	R19,Y+19
    02A79 938A      ST	-Y,R24
    02A7A 940E 3D10 CALL	lsr32
    02A7C 8309      STD	Y+1,R16
(0208) 	 pcmd[2] = (addr>>16);
    02A7D 8828      LDD	R2,Y+16
    02A7E 8839      LDD	R3,Y+17
    02A7F 884A      LDD	R4,Y+18
    02A80 885B      LDD	R5,Y+19
    02A81 0112      MOVW	R2,R4
    02A82 2444      CLR	R4
    02A83 2455      CLR	R5
    02A84 822A      STD	Y+2,R2
(0209) 	 pcmd[3] =(addr>>8);
    02A85 E088      LDI	R24,0x8
    02A86 E090      LDI	R25,0
    02A87 8908      LDD	R16,Y+16
    02A88 8919      LDD	R17,Y+17
    02A89 892A      LDD	R18,Y+18
    02A8A 893B      LDD	R19,Y+19
    02A8B 938A      ST	-Y,R24
    02A8C 940E 3D10 CALL	lsr32
    02A8E 830B      STD	Y+3,R16
(0210) 	// pcmd[4] = offset;
(0211) 
(0212) 	 SD_CS_EN();//打开片选 
    02A8F 98C0      CBI	0x18,0
(0213) 
(0214) 	 do
(0215) 	 {  
(0216) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02A90 018E      MOVW	R16,R28
    02A91 DE36      RCALL	_SD_Write_cmd
    02A92 2EC0      MOV	R12,R16
(0217) 		  time++;
    02A93 9563      INC	R22
(0218) 		  if(time==TRY_TIME) 
    02A94 3164      CPI	R22,0x14
    02A95 F421      BNE	0x2A9A
(0219) 		  {
(0220) 		   SD_CS_DIS();
    02A96 9AC0      SBI	0x18,0
(0221) 		   return(READ_BLOCK_ERROR); //读块失败
    02A97 E004      LDI	R16,4
    02A98 E010      LDI	R17,0
    02A99 C034      RJMP	0x2ACE
(0222) 		  }
(0223) 	 }while(temp!=0); 
    02A9A 20CC      TST	R12
    02A9B F7A1      BNE	0x2A90
(0224)    			
(0225) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02A9C 940E 349E CALL	_SPI_Read
    02A9E 3F0E      CPI	R16,0xFE
    02A9F F7E1      BNE	0x2A9C
(0226)  		   	   	
(0227) 	 for(j=0;j<offset;j++)	 //将数据写入到数据缓冲区中
    02AA0 2744      CLR	R20
    02AA1 2755      CLR	R21
    02AA2 C004      RJMP	0x2AA7
(0228) 	    SPI_Read();
    02AA3 940E 349E CALL	_SPI_Read
    02AA5 5F4F      SUBI	R20,0xFF
    02AA6 4F5F      SBCI	R21,0xFF
    02AA7 154A      CP	R20,R10
    02AA8 055B      CPC	R21,R11
    02AA9 F3C8      BCS	0x2AA3
(0229) 	 for(;j<offset+len;j++)	 
    02AAA C00B      RJMP	0x2AB6
(0230) 		buffer[j]=SPI_Read();
    02AAB 940E 349E CALL	_SPI_Read
    02AAD 2F60      MOV	R22,R16
    02AAE 01FA      MOVW	R30,R20
    02AAF 880C      LDD	R0,Y+20
    02AB0 881D      LDD	R1,Y+21
    02AB1 0DE0      ADD	R30,R0
    02AB2 1DF1      ADC	R31,R1
    02AB3 8360      ST	Z,R22
    02AB4 5F4F      SUBI	R20,0xFF
    02AB5 4F5F      SBCI	R21,0xFF
    02AB6 0115      MOVW	R2,R10
    02AB7 0C2E      ADD	R2,R14
    02AB8 1C3F      ADC	R3,R15
    02AB9 1542      CP	R20,R2
    02ABA 0553      CPC	R21,R3
    02ABB F378      BCS	0x2AAB
(0231) 	 for(;j<512;j++)	 
    02ABC C004      RJMP	0x2AC1
(0232) 		SPI_Read();
    02ABD 940E 349E CALL	_SPI_Read
    02ABF 5F4F      SUBI	R20,0xFF
    02AC0 4F5F      SBCI	R21,0xFF
    02AC1 3040      CPI	R20,0
    02AC2 E0E2      LDI	R30,2
    02AC3 075E      CPC	R21,R30
    02AC4 F3C0      BCS	0x2ABD
(0233) 
(0234) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02AC5 940E 349E CALL	_SPI_Read
(0235) 	 SPI_Read();
    02AC7 940E 349E CALL	_SPI_Read
(0236) 
(0237) 	 SD_CS_DIS();  //SD卡关闭片选 
    02AC9 9AC0      SBI	0x18,0
(0238) 
(0239) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02ACA 940E 349E CALL	_SPI_Read
(0240) 
(0241) 	 return SD_TURE;
    02ACC 2700      CLR	R16
    02ACD 2711      CLR	R17
    02ACE 9626      ADIW	R28,6
    02ACF 940E 3C6A CALL	pop_xgsetF0FC
    02AD1 9624      ADIW	R28,4
    02AD2 9508      RET
_GUI_mainmeu:
  select               --> R20
  key                  --> R22
    02AD3 934A      ST	-Y,R20
    02AD4 936A      ST	-Y,R22
    02AD5 9723      SBIW	R28,3
FILE: D:\LQD\software\master\software_src\gui.c
(0001) #include "config.h"
(0002) const char labelH[]="高强度作业：\0";
(0003) const char labelM[]="中等强度作业：\0";
(0004) const char labelL[]="低强度作业：\0";
(0005) const char H01[]="加强劳动监督；\0";
(0006) const char H02[]="增加饮水;\0" ;
(0007) const char H03[]="保持干燥禁裸露。\0";
(0008) #define M01 H01
(0009) #define M02 H03
(0010) const char M03[]="戴面罩。\0";
(0011) const char M04[]="禁油彩。\0";
(0012) #define L01 M03
(0013) #define L02 M04
(0014) const char L03[]="缩短作业时间。";
(0015) //-----//
(0016) #define H11 M04
(0017) #define H12 H03
(0018) const char H13[]="休息注意保暖。\0";
(0019) #define M11 H01
(0020) const char M12[]="减少非必须作业；\0";
(0021) const char M13[]="劳动时间<30min。\0";
(0022) const char L11[]="取消非必须的作业\0";
(0023) const char L12[]="劳动时间<15min；\0";
(0024) #define L13 H03
(0025) //-----//
(0026) #define H21 L11
(0027) #define H22 L12
(0028) #define H23 H03
(0029) const char M21[]="取消户外作业。"; 
(0030) #define L21 M21
(0031) 
(0032) //#define LEDON   PORTC&=~(1<<7)					   
(0033) //#define LEDOFF  PINC|=(1<<7)
(0034) char GUI_date[17]="09月19日18:00:00\0";
(0035) 
(0036) // 主菜单
(0037) unsigned char GUI_mainmeu( void )
(0038) {
(0039)  	unsigned char key=0; //init= nokey
    02AD6 2766      CLR	R22
(0040) 	unsigned char select=3;
    02AD7 E043      LDI	R20,3
(0041) 	LCD_CLR();
    02AD8 940E 357E CALL	_LCD_CLR
(0042)  	Set_White(1,1,8,1);
    02ADA E081      LDI	R24,1
    02ADB 838A      STD	Y+2,R24
    02ADC E088      LDI	R24,0x8
    02ADD 8388      ST	Y,R24
    02ADE E021      LDI	R18,1
    02ADF E001      LDI	R16,1
    02AE0 940E 3608 CALL	_Set_White
(0043) 	Set_White(1,2,8,1);
    02AE2 E081      LDI	R24,1
    02AE3 838A      STD	Y+2,R24
    02AE4 E088      LDI	R24,0x8
    02AE5 8388      ST	Y,R24
    02AE6 E022      LDI	R18,2
    02AE7 E001      LDI	R16,1
    02AE8 940E 3608 CALL	_Set_White
(0044) 	Set_White(1,3,8,1);
    02AEA E081      LDI	R24,1
    02AEB 838A      STD	Y+2,R24
    02AEC E088      LDI	R24,0x8
    02AED 8388      ST	Y,R24
    02AEE E023      LDI	R18,3
    02AEF E001      LDI	R16,1
    02AF0 940E 3608 CALL	_Set_White
(0045) 	Set_White(1,4,8,1);
    02AF2 E081      LDI	R24,1
    02AF3 838A      STD	Y+2,R24
    02AF4 E088      LDI	R24,0x8
    02AF5 8388      ST	Y,R24
    02AF6 E024      LDI	R18,4
    02AF7 E001      LDI	R16,1
    02AF8 940E 3608 CALL	_Set_White
(0046) 	LCD_const_disp(2,1,"  检测  时钟调整");
    02AFA EA81      LDI	R24,0xA1
    02AFB E094      LDI	R25,4
    02AFC 8399      STD	Y+1,R25
    02AFD 8388      ST	Y,R24
    02AFE E021      LDI	R18,1
    02AFF E002      LDI	R16,2
    02B00 940E 34D8 CALL	_LCD_const_disp
(0047) 	LCD_const_disp(3,1,"  查询  数据传输");
    02B02 E980      LDI	R24,0x90
    02B03 E094      LDI	R25,4
    02B04 8399      STD	Y+1,R25
    02B05 8388      ST	Y,R24
    02B06 E021      LDI	R18,1
    02B07 E003      LDI	R16,3
    02B08 940E 34D8 CALL	_LCD_const_disp
(0048) 	LCD_const_disp(4,1,"  初始化");
    02B0A E887      LDI	R24,0x87
    02B0B E094      LDI	R25,4
    02B0C 8399      STD	Y+1,R25
    02B0D 8388      ST	Y,R24
    02B0E E021      LDI	R18,1
    02B0F E004      LDI	R16,4
    02B10 940E 34D8 CALL	_LCD_const_disp
(0049) 	set_white_n(select,0);
    02B12 2722      CLR	R18
    02B13 2F04      MOV	R16,R20
    02B14 940E 369A CALL	_set_white_n
    02B16 C083      RJMP	0x2B9A
(0050) 	while(1)
(0051) 	{
(0052) 	 	key=kbscan();
    02B17 940E 3AC7 CALL	_kbscan
    02B19 2F60      MOV	R22,R16
(0053) 		dateRefresh(1);
    02B1A E001      LDI	R16,1
    02B1B D652      RCALL	_dateRefresh
(0054) 		LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02B1C D3DB      RCALL	_GUI_get_date
    02B1D 8319      STD	Y+1,R17
    02B1E 8308      ST	Y,R16
    02B1F E021      LDI	R18,1
    02B20 E001      LDI	R16,1
    02B21 940E 34D8 CALL	_LCD_const_disp
(0055) 		if((select>3) && (key==left || key==up ) )
    02B23 E083      LDI	R24,3
    02B24 1784      CP	R24,R20
    02B25 F508      BCC	0x2B47
    02B26 316B      CPI	R22,0x1B
    02B27 F011      BEQ	0x2B2A
    02B28 316E      CPI	R22,0x1E
    02B29 F4E9      BNE	0x2B47
(0056) 		{
(0057) 		 Set_White(1,2,8,1);
    02B2A E081      LDI	R24,1
    02B2B 838A      STD	Y+2,R24
    02B2C E088      LDI	R24,0x8
    02B2D 8388      ST	Y,R24
    02B2E E022      LDI	R18,2
    02B2F E001      LDI	R16,1
    02B30 940E 3608 CALL	_Set_White
(0058) 		 Set_White(1,3,8,1);
    02B32 E081      LDI	R24,1
    02B33 838A      STD	Y+2,R24
    02B34 E088      LDI	R24,0x8
    02B35 8388      ST	Y,R24
    02B36 E023      LDI	R18,3
    02B37 E001      LDI	R16,1
    02B38 940E 3608 CALL	_Set_White
(0059) 		 Set_White(1,4,8,1);
    02B3A E081      LDI	R24,1
    02B3B 838A      STD	Y+2,R24
    02B3C E088      LDI	R24,0x8
    02B3D 8388      ST	Y,R24
    02B3E E024      LDI	R18,4
    02B3F E001      LDI	R16,1
    02B40 940E 3608 CALL	_Set_White
(0060) 		 select--;
    02B42 954A      DEC	R20
(0061) 		 set_white_n(select,0);
    02B43 2722      CLR	R18
    02B44 2F04      MOV	R16,R20
    02B45 940E 369A CALL	_set_white_n
(0062) 		}
(0063) 		if((select<7) && (key==right || key==down ) )
    02B47 3047      CPI	R20,7
    02B48 F548      BCC	0x2B72
    02B49 3167      CPI	R22,0x17
    02B4A F011      BEQ	0x2B4D
    02B4B 316D      CPI	R22,0x1D
    02B4C F529      BNE	0x2B72
(0064) 		{
(0065) 		 Set_White(1,1,8,1);
    02B4D E081      LDI	R24,1
    02B4E 838A      STD	Y+2,R24
    02B4F E088      LDI	R24,0x8
    02B50 8388      ST	Y,R24
    02B51 E021      LDI	R18,1
    02B52 E001      LDI	R16,1
    02B53 940E 3608 CALL	_Set_White
(0066) 		 Set_White(1,2,8,1);
    02B55 E081      LDI	R24,1
    02B56 838A      STD	Y+2,R24
    02B57 E088      LDI	R24,0x8
    02B58 8388      ST	Y,R24
    02B59 E022      LDI	R18,2
    02B5A E001      LDI	R16,1
    02B5B 940E 3608 CALL	_Set_White
(0067) 		 Set_White(1,3,8,1);
    02B5D E081      LDI	R24,1
    02B5E 838A      STD	Y+2,R24
    02B5F E088      LDI	R24,0x8
    02B60 8388      ST	Y,R24
    02B61 E023      LDI	R18,3
    02B62 E001      LDI	R16,1
    02B63 940E 3608 CALL	_Set_White
(0068) 		 Set_White(1,4,8,1);
    02B65 E081      LDI	R24,1
    02B66 838A      STD	Y+2,R24
    02B67 E088      LDI	R24,0x8
    02B68 8388      ST	Y,R24
    02B69 E024      LDI	R18,4
    02B6A E001      LDI	R16,1
    02B6B 940E 3608 CALL	_Set_White
(0069) 		 select++;
    02B6D 9543      INC	R20
(0070) 		 set_white_n(select,0);
    02B6E 2722      CLR	R18
    02B6F 2F04      MOV	R16,R20
    02B70 940E 369A CALL	_set_white_n
(0071) 		}
(0072) 		if(key == ok )
    02B72 306F      CPI	R22,0xF
    02B73 F531      BNE	0x2B9A
(0073) 		{
(0074) 		 Set_White(1,1,8,1);
    02B74 E081      LDI	R24,1
    02B75 838A      STD	Y+2,R24
    02B76 E088      LDI	R24,0x8
    02B77 8388      ST	Y,R24
    02B78 E021      LDI	R18,1
    02B79 E001      LDI	R16,1
    02B7A 940E 3608 CALL	_Set_White
(0075) 		 Set_White(1,2,8,1);
    02B7C E081      LDI	R24,1
    02B7D 838A      STD	Y+2,R24
    02B7E E088      LDI	R24,0x8
    02B7F 8388      ST	Y,R24
    02B80 E022      LDI	R18,2
    02B81 E001      LDI	R16,1
    02B82 940E 3608 CALL	_Set_White
(0076) 		 Set_White(1,3,8,1);
    02B84 E081      LDI	R24,1
    02B85 838A      STD	Y+2,R24
    02B86 E088      LDI	R24,0x8
    02B87 8388      ST	Y,R24
    02B88 E023      LDI	R18,3
    02B89 E001      LDI	R16,1
    02B8A 940E 3608 CALL	_Set_White
(0077) 		 Set_White(1,4,8,1);
    02B8C E081      LDI	R24,1
    02B8D 838A      STD	Y+2,R24
    02B8E E088      LDI	R24,0x8
    02B8F 8388      ST	Y,R24
    02B90 E024      LDI	R18,4
    02B91 E001      LDI	R16,1
    02B92 940E 3608 CALL	_Set_White
(0078) 		 beep(3,select);
    02B94 2F24      MOV	R18,R20
    02B95 E003      LDI	R16,3
    02B96 940E 3853 CALL	_beep
(0079) 		 return select;
    02B98 2F04      MOV	R16,R20
    02B99 C001      RJMP	0x2B9B
    02B9A CF7C      RJMP	0x2B17
    02B9B 9623      ADIW	R28,3
    02B9C 9169      LD	R22,Y+
    02B9D 9149      LD	R20,Y+
    02B9E 9508      RET
_GUI_check:
  is_on                --> R22
  selectCheckMode      --> R12
  page                 --> R20
  key                  --> R10
    02B9F 940E 3CB0 CALL	push_xgsetF03C
    02BA1 9723      SBIW	R28,3
(0080) 		}
(0081) 		
(0082) 		
(0083) 	}
(0084) 	return 0xff; //error
(0085) 	
(0086) }
(0087) 
(0088) //”检测 “菜单
(0089) void GUI_check(void)
(0090) {
(0091)  char key;
(0092)  char page=0,is_on=0;
    02BA2 2744      CLR	R20
    02BA3 2766      CLR	R22
(0093)  char selectCheckMode=config.autocheck;
    02BA4 90C0 0756 LDS	R12,config+16
(0094)  LCD_CLR();
    02BA6 940E 357E CALL	_LCD_CLR
(0095)  LCD_const_disp(1,1,"菜单/ 检测");
    02BA8 E78C      LDI	R24,0x7C
    02BA9 E094      LDI	R25,4
    02BAA 8399      STD	Y+1,R25
    02BAB 8388      ST	Y,R24
    02BAC E021      LDI	R18,1
    02BAD E001      LDI	R16,1
    02BAE 940E 34D8 CALL	_LCD_const_disp
(0096)  LCD_const_disp(2,3,"自动");
    02BB0 E787      LDI	R24,0x77
    02BB1 E094      LDI	R25,4
    02BB2 8399      STD	Y+1,R25
    02BB3 8388      ST	Y,R24
    02BB4 E023      LDI	R18,3
    02BB5 E002      LDI	R16,2
    02BB6 940E 34D8 CALL	_LCD_const_disp
(0097)  LCD_const_disp(3,3,"手动");
    02BB8 E782      LDI	R24,0x72
    02BB9 E094      LDI	R25,4
    02BBA 8399      STD	Y+1,R25
    02BBB 8388      ST	Y,R24
    02BBC E023      LDI	R18,3
    02BBD E003      LDI	R16,3
    02BBE 940E 34D8 CALL	_LCD_const_disp
(0098)  if(selectCheckMode==1) {
    02BC0 2D8C      MOV	R24,R12
    02BC1 3081      CPI	R24,1
    02BC2 F489      BNE	0x2BD4
(0099)  Set_White(1,2,8,0);
    02BC3 2422      CLR	R2
    02BC4 822A      STD	Y+2,R2
    02BC5 E088      LDI	R24,0x8
    02BC6 8388      ST	Y,R24
    02BC7 E022      LDI	R18,2
    02BC8 E001      LDI	R16,1
    02BC9 940E 3608 CALL	_Set_White
(0100)  Set_White(1,3,8,1);
    02BCB E081      LDI	R24,1
    02BCC 838A      STD	Y+2,R24
    02BCD E088      LDI	R24,0x8
    02BCE 8388      ST	Y,R24
    02BCF E023      LDI	R18,3
    02BD0 E001      LDI	R16,1
    02BD1 940E 3608 CALL	_Set_White
(0101)  }
    02BD3 C060      RJMP	0x2C34
(0102)  else {
(0103)  Set_White(1,2,8,1);
    02BD4 E081      LDI	R24,1
    02BD5 838A      STD	Y+2,R24
    02BD6 E088      LDI	R24,0x8
    02BD7 8388      ST	Y,R24
    02BD8 E022      LDI	R18,2
    02BD9 E001      LDI	R16,1
    02BDA 940E 3608 CALL	_Set_White
(0104)  Set_White(1,3,8,0);
    02BDC 2422      CLR	R2
    02BDD 822A      STD	Y+2,R2
    02BDE E088      LDI	R24,0x8
    02BDF 8388      ST	Y,R24
    02BE0 E023      LDI	R18,3
    02BE1 E001      LDI	R16,1
    02BE2 940E 3608 CALL	_Set_White
(0105)  }
    02BE4 C04F      RJMP	0x2C34
(0106)  while(1){
(0107)  	key=kbscan();
    02BE5 940E 3AC7 CALL	_kbscan
    02BE7 2EA0      MOV	R10,R16
(0108) 	if(key==left && selectCheckMode > 0){  
    02BE8 310B      CPI	R16,0x1B
    02BE9 F4A1      BNE	0x2BFE
    02BEA E080      LDI	R24,0
    02BEB 158C      CP	R24,R12
    02BEC F488      BCC	0x2BFE
(0109) 		selectCheckMode=0;
    02BED 24CC      CLR	R12
(0110) 		Set_White(1,2,8,0);
    02BEE 2422      CLR	R2
    02BEF 822A      STD	Y+2,R2
    02BF0 E088      LDI	R24,0x8
    02BF1 8388      ST	Y,R24
    02BF2 E022      LDI	R18,2
    02BF3 E001      LDI	R16,1
    02BF4 940E 3608 CALL	_Set_White
(0111)  		Set_White(1,3,8,1);
    02BF6 E081      LDI	R24,1
    02BF7 838A      STD	Y+2,R24
    02BF8 E088      LDI	R24,0x8
    02BF9 8388      ST	Y,R24
    02BFA E023      LDI	R18,3
    02BFB E001      LDI	R16,1
    02BFC 940E 3608 CALL	_Set_White
(0112) 		//delayms(500);
(0113) 		}
(0114) 	if(key==right && selectCheckMode < 1){  
    02BFE 2D8A      MOV	R24,R10
    02BFF 3187      CPI	R24,0x17
    02C00 F4A9      BNE	0x2C16
    02C01 2D8C      MOV	R24,R12
    02C02 3081      CPI	R24,1
    02C03 F490      BCC	0x2C16
(0115) 		selectCheckMode=1;
    02C04 24CC      CLR	R12
    02C05 94C3      INC	R12
(0116) 		Set_White(1,2,8,1);
    02C06 E081      LDI	R24,1
    02C07 838A      STD	Y+2,R24
    02C08 E088      LDI	R24,0x8
    02C09 8388      ST	Y,R24
    02C0A E022      LDI	R18,2
    02C0B E001      LDI	R16,1
    02C0C 940E 3608 CALL	_Set_White
(0117)  		Set_White(1,3,8,0);
    02C0E 2422      CLR	R2
    02C0F 822A      STD	Y+2,R2
    02C10 E088      LDI	R24,0x8
    02C11 8388      ST	Y,R24
    02C12 E023      LDI	R18,3
    02C13 E001      LDI	R16,1
    02C14 940E 3608 CALL	_Set_White
(0118) 	//delayms(500);
(0119) 	}
(0120) 	if(key == up) {
    02C16 2D8A      MOV	R24,R10
    02C17 318E      CPI	R24,0x1E
    02C18 F4B9      BNE	0x2C30
(0121) 		config.autocheck=selectCheckMode; 
    02C19 92C0 0756 STS	config+16,R12
(0122) 		Set_White(1,2,8,1);
    02C1B E081      LDI	R24,1
    02C1C 838A      STD	Y+2,R24
    02C1D E088      LDI	R24,0x8
    02C1E 8388      ST	Y,R24
    02C1F E022      LDI	R18,2
    02C20 E001      LDI	R16,1
    02C21 940E 3608 CALL	_Set_White
(0123)  		Set_White(1,3,8,1);
    02C23 E081      LDI	R24,1
    02C24 838A      STD	Y+2,R24
    02C25 E088      LDI	R24,0x8
    02C26 8388      ST	Y,R24
    02C27 E023      LDI	R18,3
    02C28 E001      LDI	R16,1
    02C29 940E 3608 CALL	_Set_White
(0124) 		delayms(500);
    02C2B EF04      LDI	R16,0xF4
    02C2C E011      LDI	R17,1
    02C2D 940E 23F0 CALL	_delayms
(0125) 		break ;		
    02C2F C2C4      RJMP	0x2EF4
(0126) 	}
(0127) 	if(key == down) {
    02C30 2D8A      MOV	R24,R10
    02C31 318D      CPI	R24,0x1D
    02C32 F409      BNE	0x2C34
(0128) 		return ;		
    02C33 C2C1      RJMP	0x2EF5
    02C34 CFB0      RJMP	0x2BE5
(0129) 	}
(0130) 	
(0131)  }
(0132) 
(0133)  while(1)
(0134)  {    
(0135)      key=kbscan();
    02C35 940E 3AC7 CALL	_kbscan
    02C37 2EA0      MOV	R10,R16
(0136) 	 dateRefresh(1);
    02C38 E001      LDI	R16,1
    02C39 D534      RCALL	_dateRefresh
(0137) 	
(0138) if(page == 0){
    02C3A 2344      TST	R20
    02C3B F009      BEQ	0x2C3D
    02C3C C04B      RJMP	0x2C88
(0139)  	 //显示日期时间
(0140) 	 LCD_var_disp(1,1,GUI_get_date());
    02C3D D2BA      RCALL	_GUI_get_date
    02C3E 0168      MOVW	R12,R16
    02C3F 82D9      STD	Y+1,R13
    02C40 82C8      ST	Y,R12
    02C41 E021      LDI	R18,1
    02C42 E001      LDI	R16,1
    02C43 940E 3505 CALL	_LCD_var_disp
(0141) 	//显示温度
(0142) 	 LCD_const_disp(2,1,"温度 (℃):");
    02C45 E687      LDI	R24,0x67
    02C46 E094      LDI	R25,4
    02C47 8399      STD	Y+1,R25
    02C48 8388      ST	Y,R24
    02C49 E021      LDI	R18,1
    02C4A E002      LDI	R16,2
    02C4B 940E 34D8 CALL	_LCD_const_disp
(0143) 	 LCD_var_disp(2,6,Result.TempChar);
    02C4D E083      LDI	R24,3
    02C4E E095      LDI	R25,5
    02C4F 8399      STD	Y+1,R25
    02C50 8388      ST	Y,R24
    02C51 E026      LDI	R18,6
    02C52 E002      LDI	R16,2
    02C53 940E 3505 CALL	_LCD_var_disp
(0144) 	//显示风速
(0145) 	 LCD_const_disp(3,1,"风速(m/s): ");
    02C55 E58B      LDI	R24,0x5B
    02C56 E094      LDI	R25,4
    02C57 8399      STD	Y+1,R25
    02C58 8388      ST	Y,R24
    02C59 E021      LDI	R18,1
    02C5A E003      LDI	R16,3
    02C5B 940E 34D8 CALL	_LCD_const_disp
(0146) 	 LCD_const_disp(3,6,Result.WSChar);
    02C5D E08D      LDI	R24,0xD
    02C5E E095      LDI	R25,5
    02C5F 8399      STD	Y+1,R25
    02C60 8388      ST	Y,R24
    02C61 E026      LDI	R18,6
    02C62 E003      LDI	R16,3
    02C63 940E 34D8 CALL	_LCD_const_disp
(0147) 	 if(is_on == 1)
    02C65 3061      CPI	R22,1
    02C66 F4C9      BNE	0x2C80
(0148) 	 {
(0149) 	  LCD_const_disp(4,1,"倒计时: ");
    02C67 E582      LDI	R24,0x52
    02C68 E094      LDI	R25,4
    02C69 8399      STD	Y+1,R25
    02C6A 8388      ST	Y,R24
    02C6B E021      LDI	R18,1
    02C6C E004      LDI	R16,4
    02C6D 940E 34D8 CALL	_LCD_const_disp
(0150) 	 LCD_print4num(4,5,config.time1-config.now);
    02C6F 9020 0752 LDS	R2,config+12
    02C71 9030 0753 LDS	R3,config+13
    02C73 9040 074E LDS	R4,config+8
    02C75 9050 074F LDS	R5,config+9
    02C77 1842      SUB	R4,R2
    02C78 0853      SBC	R5,R3
    02C79 8259      STD	Y+1,R5
    02C7A 8248      ST	Y,R4
    02C7B E025      LDI	R18,5
    02C7C E004      LDI	R16,4
    02C7D 940E 379A CALL	_LCD_print4num
(0151) 	 }else 
    02C7F C008      RJMP	0x2C88
(0152) 	 {LCD_const_disp(4,1,"            ");}
    02C80 E485      LDI	R24,0x45
    02C81 E094      LDI	R25,4
    02C82 8399      STD	Y+1,R25
    02C83 8388      ST	Y,R24
    02C84 E021      LDI	R18,1
    02C85 E004      LDI	R16,4
    02C86 940E 34D8 CALL	_LCD_const_disp
(0153) 	 
(0154) 	 
(0155) 	} 
(0156) if(page == 1){
    02C88 3041      CPI	R20,1
    02C89 F5C1      BNE	0x2CC2
(0157) 	LCD_var_disp(1,1,GUI_get_date());
    02C8A D26D      RCALL	_GUI_get_date
    02C8B 0168      MOVW	R12,R16
    02C8C 82D9      STD	Y+1,R13
    02C8D 82C8      ST	Y,R12
    02C8E E021      LDI	R18,1
    02C8F E001      LDI	R16,1
    02C90 940E 3505 CALL	_LCD_var_disp
(0158) 	LCD_const_disp(2,1,"风冷指数: ");
    02C92 E38A      LDI	R24,0x3A
    02C93 E094      LDI	R25,4
    02C94 8399      STD	Y+1,R25
    02C95 8388      ST	Y,R24
    02C96 E021      LDI	R18,1
    02C97 E002      LDI	R16,2
    02C98 940E 34D8 CALL	_LCD_const_disp
(0159) 	LCD_var_disp(2,6,Result.WCIChar);						
    02C9A E186      LDI	R24,0x16
    02C9B E095      LDI	R25,5
    02C9C 8399      STD	Y+1,R25
    02C9D 8388      ST	Y,R24
    02C9E E026      LDI	R18,6
    02C9F E002      LDI	R16,2
    02CA0 940E 3505 CALL	_LCD_var_disp
(0160) 	LCD_const_disp(3,1,"等价温度: ");
    02CA2 E28F      LDI	R24,0x2F
    02CA3 E094      LDI	R25,4
    02CA4 8399      STD	Y+1,R25
    02CA5 8388      ST	Y,R24
    02CA6 E021      LDI	R18,1
    02CA7 E003      LDI	R16,3
    02CA8 940E 34D8 CALL	_LCD_const_disp
(0161) 	LCD_var_disp(3,6,Result.ECTChar);	 
    02CAA E280      LDI	R24,0x20
    02CAB E095      LDI	R25,5
    02CAC 8399      STD	Y+1,R25
    02CAD 8388      ST	Y,R24
    02CAE E026      LDI	R18,6
    02CAF E003      LDI	R16,3
    02CB0 940E 3505 CALL	_LCD_var_disp
(0162) 	LCD_const_disp(4,1,"相当温度: ");
    02CB2 E284      LDI	R24,0x24
    02CB3 E094      LDI	R25,4
    02CB4 8399      STD	Y+1,R25
    02CB5 8388      ST	Y,R24
    02CB6 E021      LDI	R18,1
    02CB7 E004      LDI	R16,4
    02CB8 940E 34D8 CALL	_LCD_const_disp
(0163) 	LCD_var_disp(4,6,Result.TeqChar);	
    02CBA E28A      LDI	R24,0x2A
    02CBB E095      LDI	R25,5
    02CBC 8399      STD	Y+1,R25
    02CBD 8388      ST	Y,R24
    02CBE E026      LDI	R18,6
    02CBF E004      LDI	R16,4
    02CC0 940E 3505 CALL	_LCD_var_disp
(0164) 	}
(0165) if(page == 2){
    02CC2 3042      CPI	R20,2
    02CC3 F009      BEQ	0x2CC5
    02CC4 C03F      RJMP	0x2D04
(0166) 	LCD_var_disp(1,1,GUI_get_date());
    02CC5 D232      RCALL	_GUI_get_date
    02CC6 0168      MOVW	R12,R16
    02CC7 82D9      STD	Y+1,R13
    02CC8 82C8      ST	Y,R12
    02CC9 E021      LDI	R18,1
    02CCA E001      LDI	R16,1
    02CCB 940E 3505 CALL	_LCD_var_disp
(0167) 	LCD_const_disp(2,1,"冻伤危害性:");
    02CCD E188      LDI	R24,0x18
    02CCE E094      LDI	R25,4
    02CCF 8399      STD	Y+1,R25
    02CD0 8388      ST	Y,R24
    02CD1 E021      LDI	R18,1
    02CD2 E002      LDI	R16,2
    02CD3 940E 34D8 CALL	_LCD_const_disp
(0168) 	if(Result.WeiHai==0){LCD_const_disp(3,1,"  冻伤危害性小");			 }
    02CD5 9020 0530 LDS	R2,Result+86
    02CD7 2022      TST	R2
    02CD8 F449      BNE	0x2CE2
    02CD9 E089      LDI	R24,0x9
    02CDA E094      LDI	R25,4
    02CDB 8399      STD	Y+1,R25
    02CDC 8388      ST	Y,R24
    02CDD E021      LDI	R18,1
    02CDE E003      LDI	R16,3
    02CDF 940E 34D8 CALL	_LCD_const_disp
    02CE1 C022      RJMP	0x2D04
(0169) 	else if(Result.WeiHai==1){	LCD_const_disp(3,1,"  冻伤危害性较大");	 }
    02CE2 9180 0530 LDS	R24,Result+86
    02CE4 3081      CPI	R24,1
    02CE5 F449      BNE	0x2CEF
    02CE6 EF88      LDI	R24,0xF8
    02CE7 E093      LDI	R25,3
    02CE8 8399      STD	Y+1,R25
    02CE9 8388      ST	Y,R24
    02CEA E021      LDI	R18,1
    02CEB E003      LDI	R16,3
    02CEC 940E 34D8 CALL	_LCD_const_disp
    02CEE C015      RJMP	0x2D04
(0170) 	else if(Result.WeiHai==2){	LCD_const_disp(3,1,"  冻伤危害性很大");	 }
    02CEF 9180 0530 LDS	R24,Result+86
    02CF1 3082      CPI	R24,2
    02CF2 F449      BNE	0x2CFC
    02CF3 EE87      LDI	R24,0xE7
    02CF4 E093      LDI	R25,3
    02CF5 8399      STD	Y+1,R25
    02CF6 8388      ST	Y,R24
    02CF7 E021      LDI	R18,1
    02CF8 E003      LDI	R16,3
    02CF9 940E 34D8 CALL	_LCD_const_disp
    02CFB C008      RJMP	0x2D04
(0171) 	else LCD_const_disp(3,1,"冻伤危害性小。");
    02CFC ED88      LDI	R24,0xD8
    02CFD E093      LDI	R25,3
    02CFE 8399      STD	Y+1,R25
    02CFF 8388      ST	Y,R24
    02D00 E021      LDI	R18,1
    02D01 E003      LDI	R16,3
    02D02 940E 34D8 CALL	_LCD_const_disp
(0172) 	}	  
(0173) if(page==3){
    02D04 3043      CPI	R20,3
    02D05 F009      BEQ	0x2D07
    02D06 C063      RJMP	0x2D6A
(0174) 	 LCD_const_disp(1,1,labelH);		
    02D07 E581      LDI	R24,0x51
    02D08 E092      LDI	R25,2
    02D09 8399      STD	Y+1,R25
    02D0A 8388      ST	Y,R24
    02D0B E021      LDI	R18,1
    02D0C E001      LDI	R16,1
    02D0D 940E 34D8 CALL	_LCD_const_disp
(0175) 	 switch( Result.WeiHai )
    02D0F 90C0 0530 LDS	R12,Result+86
    02D11 24DD      CLR	R13
    02D12 20CC      TST	R12
    02D13 F411      BNE	0x2D16
    02D14 20DD      TST	R13
    02D15 F051      BEQ	0x2D20
    02D16 01C6      MOVW	R24,R12
    02D17 3081      CPI	R24,1
    02D18 E0E0      LDI	R30,0
    02D19 079E      CPC	R25,R30
    02D1A F0F1      BEQ	0x2D39
    02D1B 3082      CPI	R24,2
    02D1C E0E0      LDI	R30,0
    02D1D 079E      CPC	R25,R30
    02D1E F199      BEQ	0x2D52
    02D1F C04A      RJMP	0x2D6A
(0176) 	 {
(0177) 			case 0 :
(0178) 			LCD_const_disp(2,1,H01);
    02D20 E78D      LDI	R24,0x7D
    02D21 E092      LDI	R25,2
    02D22 8399      STD	Y+1,R25
    02D23 8388      ST	Y,R24
    02D24 E021      LDI	R18,1
    02D25 E002      LDI	R16,2
    02D26 940E 34D8 CALL	_LCD_const_disp
(0179) 			LCD_const_disp(3,1,H02);
    02D28 E88D      LDI	R24,0x8D
    02D29 E092      LDI	R25,2
    02D2A 8399      STD	Y+1,R25
    02D2B 8388      ST	Y,R24
    02D2C E021      LDI	R18,1
    02D2D E003      LDI	R16,3
    02D2E 940E 34D8 CALL	_LCD_const_disp
(0180) 			LCD_const_disp(4,1,H03);
    02D30 E988      LDI	R24,0x98
    02D31 E092      LDI	R25,2
    02D32 8399      STD	Y+1,R25
    02D33 8388      ST	Y,R24
    02D34 E021      LDI	R18,1
    02D35 E004      LDI	R16,4
    02D36 940E 34D8 CALL	_LCD_const_disp
(0181) 			break;
    02D38 C031      RJMP	0x2D6A
(0182) 			case 1 : 
(0183) 			LCD_const_disp(2,1,H11);
    02D39 EB84      LDI	R24,0xB4
    02D3A E092      LDI	R25,2
    02D3B 8399      STD	Y+1,R25
    02D3C 8388      ST	Y,R24
    02D3D E021      LDI	R18,1
    02D3E E002      LDI	R16,2
    02D3F 940E 34D8 CALL	_LCD_const_disp
(0184) 			LCD_const_disp(3,1,H12);
    02D41 E988      LDI	R24,0x98
    02D42 E092      LDI	R25,2
    02D43 8399      STD	Y+1,R25
    02D44 8388      ST	Y,R24
    02D45 E021      LDI	R18,1
    02D46 E003      LDI	R16,3
    02D47 940E 34D8 CALL	_LCD_const_disp
(0185) 			LCD_const_disp(4,1,H13);
    02D49 EC8D      LDI	R24,0xCD
    02D4A E092      LDI	R25,2
    02D4B 8399      STD	Y+1,R25
    02D4C 8388      ST	Y,R24
    02D4D E021      LDI	R18,1
    02D4E E004      LDI	R16,4
    02D4F 940E 34D8 CALL	_LCD_const_disp
(0186) 			break ;	
    02D51 C018      RJMP	0x2D6A
(0187) 			case 2 :
(0188) 			LCD_const_disp(2,1,H21);
    02D52 E081      LDI	R24,1
    02D53 E093      LDI	R25,3
    02D54 8399      STD	Y+1,R25
    02D55 8388      ST	Y,R24
    02D56 E021      LDI	R18,1
    02D57 E002      LDI	R16,2
    02D58 940E 34D8 CALL	_LCD_const_disp
(0189) 			LCD_const_disp(3,1,H22);
    02D5A E183      LDI	R24,0x13
    02D5B E093      LDI	R25,3
    02D5C 8399      STD	Y+1,R25
    02D5D 8388      ST	Y,R24
    02D5E E021      LDI	R18,1
    02D5F E003      LDI	R16,3
    02D60 940E 34D8 CALL	_LCD_const_disp
(0190) 			LCD_const_disp(4,1,H23);
    02D62 E988      LDI	R24,0x98
    02D63 E092      LDI	R25,2
    02D64 8399      STD	Y+1,R25
    02D65 8388      ST	Y,R24
    02D66 E021      LDI	R18,1
    02D67 E004      LDI	R16,4
    02D68 940E 34D8 CALL	_LCD_const_disp
(0191) 			break;
(0192) 			default :
(0193) 			;
(0194) 		}
(0195) 			
(0196) } 
(0197) if(page==4){
    02D6A 3044      CPI	R20,4
    02D6B F009      BEQ	0x2D6D
    02D6C C088      RJMP	0x2DF5
(0198) 	 LCD_const_disp(1,1,labelM);		
    02D6D E58F      LDI	R24,0x5F
    02D6E E092      LDI	R25,2
    02D6F 8399      STD	Y+1,R25
    02D70 8388      ST	Y,R24
    02D71 E021      LDI	R18,1
    02D72 E001      LDI	R16,1
    02D73 940E 34D8 CALL	_LCD_const_disp
(0199) 	 switch( Result.WeiHai )
    02D75 90C0 0530 LDS	R12,Result+86
    02D77 24DD      CLR	R13
    02D78 20CC      TST	R12
    02D79 F411      BNE	0x2D7C
    02D7A 20DD      TST	R13
    02D7B F061      BEQ	0x2D88
    02D7C 01C6      MOVW	R24,R12
    02D7D 3081      CPI	R24,1
    02D7E E0E0      LDI	R30,0
    02D7F 079E      CPC	R25,R30
    02D80 F409      BNE	0x2D82
    02D81 C052      RJMP	0x2DD4
    02D82 3082      CPI	R24,2
    02D83 E0E0      LDI	R30,0
    02D84 079E      CPC	R25,R30
    02D85 F409      BNE	0x2D87
    02D86 C066      RJMP	0x2DED
    02D87 C06D      RJMP	0x2DF5
(0200) 	 {
(0201) 	 		case 0 :
(0202) 			LCD_const_disp(2,1,M01);
    02D88 E78D      LDI	R24,0x7D
    02D89 E092      LDI	R25,2
    02D8A 8399      STD	Y+1,R25
    02D8B 8388      ST	Y,R24
    02D8C E021      LDI	R18,1
    02D8D E002      LDI	R16,2
    02D8E 940E 34D8 CALL	_LCD_const_disp
(0203) 			LCD_const_disp(3,1,M02);
    02D90 E988      LDI	R24,0x98
    02D91 E092      LDI	R25,2
    02D92 8399      STD	Y+1,R25
    02D93 8388      ST	Y,R24
    02D94 E021      LDI	R18,1
    02D95 E003      LDI	R16,3
    02D96 940E 34D8 CALL	_LCD_const_disp
(0204) 			if(Result.Temperature < 17.7) 
    02D98 9040 0501 LDS	R4,Result+39
    02D9A 9050 0502 LDS	R5,Result+40
    02D9C 9020 04FF LDS	R2,Result+37
    02D9E 9030 0500 LDS	R3,Result+38
    02DA0 EC00      LDI	R16,0xC0
    02DA1 E010      LDI	R17,0
    02DA2 940E 3BFD CALL	elpm32
    02DA4 933A      ST	-Y,R19
    02DA5 932A      ST	-Y,R18
    02DA6 931A      ST	-Y,R17
    02DA7 930A      ST	-Y,R16
    02DA8 0181      MOVW	R16,R2
    02DA9 0192      MOVW	R18,R4
    02DAA 940E 3F9B CALL	fpcmp2
    02DAC F44C      BGE	0x2DB6
(0205) 				{LCD_const_disp(4,1,"戴面罩；禁油彩。");}
    02DAD EC87      LDI	R24,0xC7
    02DAE E093      LDI	R25,3
    02DAF 8399      STD	Y+1,R25
    02DB0 8388      ST	Y,R24
    02DB1 E021      LDI	R18,1
    02DB2 E004      LDI	R16,4
    02DB3 940E 34D8 CALL	_LCD_const_disp
    02DB5 C03F      RJMP	0x2DF5
(0206) 			else if(Result.Temperature < 12)
    02DB6 9040 0501 LDS	R4,Result+39
    02DB8 9050 0502 LDS	R5,Result+40
    02DBA 9020 04FF LDS	R2,Result+37
    02DBC 9030 0500 LDS	R3,Result+38
    02DBE EB0C      LDI	R16,0xBC
    02DBF E010      LDI	R17,0
    02DC0 940E 3BFD CALL	elpm32
    02DC2 933A      ST	-Y,R19
    02DC3 932A      ST	-Y,R18
    02DC4 931A      ST	-Y,R17
    02DC5 930A      ST	-Y,R16
    02DC6 0181      MOVW	R16,R2
    02DC7 0192      MOVW	R18,R4
    02DC8 940E 3F9B CALL	fpcmp2
    02DCA F554      BGE	0x2DF5
(0207) 				 {LCD_const_disp(4,1,"禁油彩。        \0");}
    02DCB EB85      LDI	R24,0xB5
    02DCC E093      LDI	R25,3
    02DCD 8399      STD	Y+1,R25
    02DCE 8388      ST	Y,R24
    02DCF E021      LDI	R18,1
    02DD0 E004      LDI	R16,4
    02DD1 940E 34D8 CALL	_LCD_const_disp
(0208) 			break;
    02DD3 C021      RJMP	0x2DF5
(0209) 			
(0210) 			case 1 : 
(0211) 			LCD_const_disp(2,1,M11);
    02DD4 E78D      LDI	R24,0x7D
    02DD5 E092      LDI	R25,2
    02DD6 8399      STD	Y+1,R25
    02DD7 8388      ST	Y,R24
    02DD8 E021      LDI	R18,1
    02DD9 E002      LDI	R16,2
    02DDA 940E 34D8 CALL	_LCD_const_disp
(0212) 			LCD_const_disp(3,1,M12);
    02DDC ED8D      LDI	R24,0xDD
    02DDD E092      LDI	R25,2
    02DDE 8399      STD	Y+1,R25
    02DDF 8388      ST	Y,R24
    02DE0 E021      LDI	R18,1
    02DE1 E003      LDI	R16,3
    02DE2 940E 34D8 CALL	_LCD_const_disp
(0213) 			LCD_const_disp(4,1,M13);
    02DE4 EE8F      LDI	R24,0xEF
    02DE5 E092      LDI	R25,2
    02DE6 8399      STD	Y+1,R25
    02DE7 8388      ST	Y,R24
    02DE8 E021      LDI	R18,1
    02DE9 E004      LDI	R16,4
    02DEA 940E 34D8 CALL	_LCD_const_disp
(0214) 			break ;
    02DEC C008      RJMP	0x2DF5
(0215) 			case 2 :
(0216) 			LCD_const_disp(2,1,M21);
    02DED E285      LDI	R24,0x25
    02DEE E093      LDI	R25,3
    02DEF 8399      STD	Y+1,R25
    02DF0 8388      ST	Y,R24
    02DF1 E021      LDI	R18,1
    02DF2 E002      LDI	R16,2
    02DF3 940E 34D8 CALL	_LCD_const_disp
(0217) 			break ;
(0218) 			default :
(0219) 			;
(0220) 	}
(0221) 			
(0222) }
(0223) if(page==5){
    02DF5 3045      CPI	R20,5
    02DF6 F009      BEQ	0x2DF8
    02DF7 C073      RJMP	0x2E6B
(0224) 	 LCD_const_disp(1,1,labelL);		
    02DF8 E68F      LDI	R24,0x6F
    02DF9 E092      LDI	R25,2
    02DFA 8399      STD	Y+1,R25
    02DFB 8388      ST	Y,R24
    02DFC E021      LDI	R18,1
    02DFD E001      LDI	R16,1
    02DFE 940E 34D8 CALL	_LCD_const_disp
(0225) 	 switch( Result.WeiHai )
    02E00 90C0 0530 LDS	R12,Result+86
    02E02 24DD      CLR	R13
    02E03 20CC      TST	R12
    02E04 F411      BNE	0x2E07
    02E05 20DD      TST	R13
    02E06 F061      BEQ	0x2E13
    02E07 01C6      MOVW	R24,R12
    02E08 3081      CPI	R24,1
    02E09 E0E0      LDI	R30,0
    02E0A 079E      CPC	R25,R30
    02E0B F409      BNE	0x2E0D
    02E0C C03D      RJMP	0x2E4A
    02E0D 3082      CPI	R24,2
    02E0E E0E0      LDI	R30,0
    02E0F 079E      CPC	R25,R30
    02E10 F409      BNE	0x2E12
    02E11 C051      RJMP	0x2E63
    02E12 C058      RJMP	0x2E6B
(0226) 	  {	
(0227) 			case 0 :
(0228) 			LCD_const_disp(2,1,L01);
    02E13 EA8A      LDI	R24,0xAA
    02E14 E092      LDI	R25,2
    02E15 8399      STD	Y+1,R25
    02E16 8388      ST	Y,R24
    02E17 E021      LDI	R18,1
    02E18 E002      LDI	R16,2
    02E19 940E 34D8 CALL	_LCD_const_disp
(0229) 			if(Result.Temperature < -12) {
    02E1B 9040 0501 LDS	R4,Result+39
    02E1D 9050 0502 LDS	R5,Result+40
    02E1F 9020 04FF LDS	R2,Result+37
    02E21 9030 0500 LDS	R3,Result+38
    02E23 EB08      LDI	R16,0xB8
    02E24 E010      LDI	R17,0
    02E25 940E 3BFD CALL	elpm32
    02E27 933A      ST	-Y,R19
    02E28 932A      ST	-Y,R18
    02E29 931A      ST	-Y,R17
    02E2A 930A      ST	-Y,R16
    02E2B 0181      MOVW	R16,R2
    02E2C 0192      MOVW	R18,R4
    02E2D 940E 3F9B CALL	fpcmp2
    02E2F F48C      BGE	0x2E41
(0230) 			LCD_const_disp(3,1,L02);
    02E30 EB84      LDI	R24,0xB4
    02E31 E092      LDI	R25,2
    02E32 8399      STD	Y+1,R25
    02E33 8388      ST	Y,R24
    02E34 E021      LDI	R18,1
    02E35 E003      LDI	R16,3
    02E36 940E 34D8 CALL	_LCD_const_disp
(0231) 			LCD_const_disp(4,1,L03);
    02E38 EB8E      LDI	R24,0xBE
    02E39 E092      LDI	R25,2
    02E3A 8399      STD	Y+1,R25
    02E3B 8388      ST	Y,R24
    02E3C E021      LDI	R18,1
    02E3D E004      LDI	R16,4
    02E3E 940E 34D8 CALL	_LCD_const_disp
(0232) 			} else 
    02E40 C02A      RJMP	0x2E6B
(0233) 			{
(0234) 			 LCD_const_disp(3,1,L03);
    02E41 EB8E      LDI	R24,0xBE
    02E42 E092      LDI	R25,2
    02E43 8399      STD	Y+1,R25
    02E44 8388      ST	Y,R24
    02E45 E021      LDI	R18,1
    02E46 E003      LDI	R16,3
    02E47 940E 34D8 CALL	_LCD_const_disp
(0235) 			}
(0236) 			break;
    02E49 C021      RJMP	0x2E6B
(0237) 			case 1: 
(0238) 			LCD_const_disp(2,1,L11);
    02E4A E081      LDI	R24,1
    02E4B E093      LDI	R25,3
    02E4C 8399      STD	Y+1,R25
    02E4D 8388      ST	Y,R24
    02E4E E021      LDI	R18,1
    02E4F E002      LDI	R16,2
    02E50 940E 34D8 CALL	_LCD_const_disp
(0239) 			LCD_const_disp(3,1,L12);
    02E52 E183      LDI	R24,0x13
    02E53 E093      LDI	R25,3
    02E54 8399      STD	Y+1,R25
    02E55 8388      ST	Y,R24
    02E56 E021      LDI	R18,1
    02E57 E003      LDI	R16,3
    02E58 940E 34D8 CALL	_LCD_const_disp
(0240) 			LCD_const_disp(3,1,L13);
    02E5A E988      LDI	R24,0x98
    02E5B E092      LDI	R25,2
    02E5C 8399      STD	Y+1,R25
    02E5D 8388      ST	Y,R24
    02E5E E021      LDI	R18,1
    02E5F E003      LDI	R16,3
    02E60 940E 34D8 CALL	_LCD_const_disp
(0241) 			break ;
    02E62 C008      RJMP	0x2E6B
(0242) 			case 2 :
(0243) 			LCD_const_disp(2,1,L21);
    02E63 E285      LDI	R24,0x25
    02E64 E093      LDI	R25,3
    02E65 8399      STD	Y+1,R25
    02E66 8388      ST	Y,R24
    02E67 E021      LDI	R18,1
    02E68 E002      LDI	R16,2
    02E69 940E 34D8 CALL	_LCD_const_disp
(0244) 			break;
(0245) 			default :
(0246) 			;
(0247) 			} //end switch
(0248) 			
(0249) }  //end if
(0250) 	 //LCD_print2num(4,4,is_on);
(0251) 	  if(key==ok){ //按ok键开始测量
    02E6B 2D8A      MOV	R24,R10
    02E6C 308F      CPI	R24,0xF
    02E6D F509      BNE	0x2E8F
(0252) 	  			 beep(1,0);
    02E6E 2722      CLR	R18
    02E6F E001      LDI	R16,1
    02E70 940E 3853 CALL	_beep
(0253) 	  			 //fwrite; 
(0254) 				 config.time1=config.now+config.THRESHOLD_delta_sec;
    02E72 9040 074C LDS	R4,config+6
    02E74 9050 074D LDS	R5,config+7
    02E76 9020 074A LDS	R2,config+4
    02E78 9030 074B LDS	R3,config+5
    02E7A 9080 0754 LDS	R8,config+14
    02E7C 9090 0755 LDS	R9,config+15
    02E7E 9060 0752 LDS	R6,config+12
    02E80 9070 0753 LDS	R7,config+13
    02E82 0C62      ADD	R6,R2
    02E83 1C73      ADC	R7,R3
    02E84 1C84      ADC	R8,R4
    02E85 1C95      ADC	R9,R5
    02E86 9270 074F STS	config+9,R7
    02E88 9260 074E STS	config+8,R6
    02E8A 9290 0751 STS	config+11,R9
    02E8C 9280 0750 STS	config+10,R8
(0255) 				 is_on=1; //start count
    02E8E E061      LDI	R22,1
(0256) 	 //			 timer1_init(); //计数
(0257) 				}			
(0258) 	if(is_on == 1 && config.now>=config.time1 )
    02E8F 3061      CPI	R22,1
    02E90 F4C1      BNE	0x2EA9
    02E91 9040 0750 LDS	R4,config+10
    02E93 9050 0751 LDS	R5,config+11
    02E95 9020 074E LDS	R2,config+8
    02E97 9030 074F LDS	R3,config+9
    02E99 9080 0754 LDS	R8,config+14
    02E9B 9090 0755 LDS	R9,config+15
    02E9D 9060 0752 LDS	R6,config+12
    02E9F 9070 0753 LDS	R7,config+13
    02EA1 1462      CP	R6,R2
    02EA2 0473      CPC	R7,R3
    02EA3 0484      CPC	R8,R4
    02EA4 0495      CPC	R9,R5
    02EA5 F01C      BLT	0x2EA9
(0259) 	{
(0260) 	 is_on=0;
    02EA6 2766      CLR	R22
(0261) 	 check(); //检测
    02EA7 940E 2597 CALL	_check
(0262) 	 //storage(); //存储
(0263)  
(0264) 	} 	
(0265) 	
(0266) 	  
(0267)     if(key==left) //左键 : 页面减
    02EA9 2D8A      MOV	R24,R10
    02EAA 318B      CPI	R24,0x1B
    02EAB F441      BNE	0x2EB4
(0268) 	{ 
(0269) 	  if(page>0) page--;
    02EAC E080      LDI	R24,0
    02EAD 1784      CP	R24,R20
    02EAE F408      BCC	0x2EB0
    02EAF 954A      DEC	R20
(0270) 	  LCD_CLR();
    02EB0 940E 357E CALL	_LCD_CLR
(0271) 	  LCD_Init();
    02EB2 940E 354C CALL	_LCD_Init
(0272) 	}
(0273) 	 
(0274)   if(key==right) //右键 ： 页面加
    02EB4 2D8A      MOV	R24,R10
    02EB5 3187      CPI	R24,0x17
    02EB6 F449      BNE	0x2EC0
(0275) 	{ 
(0276) 	  if(page<5) page++;
    02EB7 3045      CPI	R20,5
    02EB8 F410      BCC	0x2EBB
    02EB9 9543      INC	R20
    02EBA C001      RJMP	0x2EBC
(0277) 	  else page = 0;
    02EBB 2744      CLR	R20
(0278) 	  LCD_CLR();
    02EBC 940E 357E CALL	_LCD_CLR
(0279) 	  LCD_Init();
    02EBE 940E 354C CALL	_LCD_Init
(0280) 	}
(0281) 	if(key==lright && is_on==0)	//长安右键 退出
    02EC0 2D8A      MOV	R24,R10
    02EC1 3987      CPI	R24,0x97
    02EC2 F569      BNE	0x2EF0
    02EC3 2366      TST	R22
    02EC4 F559      BNE	0x2EF0
(0282) 	{ 
(0283) 	 LCD_CLR();
    02EC5 940E 357E CALL	_LCD_CLR
(0284) 	 LCD_Init();	  
    02EC7 940E 354C CALL	_LCD_Init
(0285)  	 LCD_const_disp(4,5,"退出    "); 
    02EC9 EA8C      LDI	R24,0xAC
    02ECA E093      LDI	R25,3
    02ECB 8399      STD	Y+1,R25
    02ECC 8388      ST	Y,R24
    02ECD E025      LDI	R18,5
    02ECE E004      LDI	R16,4
    02ECF 940E 34D8 CALL	_LCD_const_disp
(0286) 	 delayms(200);
    02ED1 EC08      LDI	R16,0xC8
    02ED2 E010      LDI	R17,0
    02ED3 940E 23F0 CALL	_delayms
(0287) 	 LCD_const_disp(4,7,".."); 
    02ED5 EA89      LDI	R24,0xA9
    02ED6 E093      LDI	R25,3
    02ED7 8399      STD	Y+1,R25
    02ED8 8388      ST	Y,R24
    02ED9 E027      LDI	R18,7
    02EDA E004      LDI	R16,4
    02EDB 940E 34D8 CALL	_LCD_const_disp
(0288) 	 delayms(200);
    02EDD EC08      LDI	R16,0xC8
    02EDE E010      LDI	R17,0
    02EDF 940E 23F0 CALL	_delayms
(0289) 	 LCD_const_disp(4,8,".."); 	
    02EE1 EA89      LDI	R24,0xA9
    02EE2 E093      LDI	R25,3
    02EE3 8399      STD	Y+1,R25
    02EE4 8388      ST	Y,R24
    02EE5 E028      LDI	R18,0x8
    02EE6 E004      LDI	R16,4
    02EE7 940E 34D8 CALL	_LCD_const_disp
(0290) 	 delayms(500);
    02EE9 EF04      LDI	R16,0xF4
    02EEA E011      LDI	R17,1
    02EEB 940E 23F0 CALL	_delayms
(0291) 	 LCD_CLR();
    02EED 940E 357E CALL	_LCD_CLR
(0292) 	 return ;
    02EEF C005      RJMP	0x2EF5
(0293) 	}
(0294)     delayms(100); 
    02EF0 E604      LDI	R16,0x64
    02EF1 E010      LDI	R17,0
    02EF2 940E 23F0 CALL	_delayms
    02EF4 CD40      RJMP	0x2C35
    02EF5 9623      ADIW	R28,3
    02EF6 940C 3CB9 JMP	pop_xgsetF03C
(0295) }//end while
(0296) 
(0297) }
(0298) 
(0299) char * GUI_get_date(void) 
(0300) {  
(0301)    //2012年12月11日19:00:00
(0302)   GUI_date[0]=Result.Date[4]; 
_GUI_get_date:
    02EF8 9020 04F0 LDS	R2,Result+22
    02EFA 9220 0334 STS	GUI_date,R2
(0303)   GUI_date[1]=Result.Date[5];
    02EFC 9020 04F1 LDS	R2,Result+23
    02EFE 9220 0335 STS	GUI_date+1,R2
(0304)   GUI_date[4]=Result.Date[6];
    02F00 9020 04F2 LDS	R2,Result+24
    02F02 9220 0338 STS	GUI_date+4,R2
(0305)   GUI_date[5]=Result.Date[7];
    02F04 9020 04F3 LDS	R2,Result+25
    02F06 9220 0339 STS	GUI_date+5,R2
(0306)   GUI_date[8]=Result.Time[0];
    02F08 9020 04F5 LDS	R2,Result+27
    02F0A 9220 033C STS	GUI_date+8,R2
(0307)   GUI_date[9]=Result.Time[1];
    02F0C 9020 04F6 LDS	R2,Result+28
    02F0E 9220 033D STS	GUI_date+9,R2
(0308)   GUI_date[11]=Result.Time[4];
    02F10 9020 04F9 LDS	R2,Result+31
    02F12 9220 033F STS	GUI_date+11,R2
(0309)   GUI_date[12]=Result.Time[5];
    02F14 9020 04FA LDS	R2,Result+32
    02F16 9220 0340 STS	GUI_date+12,R2
(0310)   GUI_date[14]=Result.Time[8];
    02F18 9020 04FD LDS	R2,Result+35
    02F1A 9220 0342 STS	GUI_date+14,R2
(0311)   GUI_date[15]=Result.Time[9];
    02F1C 9020 04FE LDS	R2,Result+36
    02F1E 9220 0343 STS	GUI_date+15,R2
(0312)   GUI_date[16]='\0';
    02F20 2422      CLR	R2
    02F21 9220 0344 STS	GUI_date+16,R2
(0313)   return GUI_date;
    02F23 E304      LDI	R16,0x34
    02F24 E013      LDI	R17,3
    02F25 9508      RET
_GUI_set_time:
  GUI_down             --> Y,+5
  GUI_up               --> Y,+2
  pT                   --> R14
  ary                  --> R12
  p                    --> Y,+10
  i                    --> R20
  keyc                 --> R22
  pD                   --> Y,+8
    02F26 940E 3C75 CALL	push_xgsetF0FC
    02F28 972B      SBIW	R28,0xB
(0314) }
(0315) //设置时间 菜单 
(0316) void GUI_set_time(void)
(0317)  {
(0318)  
(0319)  unsigned char p=2;
    02F29 E082      LDI	R24,2
    02F2A 878A      STD	Y+10,R24
(0320)  char GUI_up[]= "↑";
    02F2B E485      LDI	R24,0x45
    02F2C E093      LDI	R25,3
    02F2D 01FE      MOVW	R30,R28
    02F2E 9632      ADIW	R30,2
    02F2F E003      LDI	R16,3
    02F30 E010      LDI	R17,0
    02F31 93FA      ST	-Y,R31
    02F32 93EA      ST	-Y,R30
    02F33 939A      ST	-Y,R25
    02F34 938A      ST	-Y,R24
    02F35 940E 3D1C CALL	asgnblk
(0321)  char GUI_down[]= "↓";
    02F37 E488      LDI	R24,0x48
    02F38 E093      LDI	R25,3
    02F39 01FE      MOVW	R30,R28
    02F3A 9635      ADIW	R30,5
    02F3B E003      LDI	R16,3
    02F3C E010      LDI	R17,0
    02F3D 93FA      ST	-Y,R31
    02F3E 93EA      ST	-Y,R30
    02F3F 939A      ST	-Y,R25
    02F40 938A      ST	-Y,R24
    02F41 940E 3D1C CALL	asgnblk
(0322)  char *pD=NULL,*pT=NULL;
    02F43 2400      CLR	R0
    02F44 2411      CLR	R1
    02F45 8619      STD	Y+9,R1
    02F46 8608      STD	Y+8,R0
(0323)  char *ary=GUI_up;
    02F47 01CE      MOVW	R24,R28
    02F48 9602      ADIW	R24,2
    02F49 016C      MOVW	R12,R24
(0324)  unsigned char i=0,keyc=NO_KEY;
    02F4A 2744      CLR	R20
    02F4B 2766      CLR	R22
(0325) LCD_CLR(); //清屏
    02F4C 940E 357E CALL	_LCD_CLR
(0326) pD="2012年12月31日\0";
    02F4E E989      LDI	R24,0x99
    02F4F E093      LDI	R25,3
    02F50 8799      STD	Y+9,R25
    02F51 8788      STD	Y+8,R24
(0327) pT=Result.Time;
    02F52 EF85      LDI	R24,0xF5
    02F53 E094      LDI	R25,4
    02F54 017C      MOVW	R14,R24
(0328) LCD_const_disp(1,1,"时间设置:       ");
    02F55 E888      LDI	R24,0x88
    02F56 E093      LDI	R25,3
    02F57 8399      STD	Y+1,R25
    02F58 8388      ST	Y,R24
    02F59 E021      LDI	R18,1
    02F5A E001      LDI	R16,1
    02F5B 940E 34D8 CALL	_LCD_const_disp
(0329) LCD_const_disp(4,7,"保存");
    02F5D E883      LDI	R24,0x83
    02F5E E093      LDI	R25,3
    02F5F 8399      STD	Y+1,R25
    02F60 8388      ST	Y,R24
    02F61 E027      LDI	R18,7
    02F62 E004      LDI	R16,4
    02F63 940E 34D8 CALL	_LCD_const_disp
(0330)   
(0331) LCD_var_disp(3,p,ary);
    02F65 82D9      STD	Y+1,R13
    02F66 82C8      ST	Y,R12
    02F67 852A      LDD	R18,Y+10
    02F68 E003      LDI	R16,3
    02F69 940E 3505 CALL	_LCD_var_disp
(0332) LCD_var_disp(2,1,pD);
    02F6B 8408      LDD	R0,Y+8
    02F6C 8419      LDD	R1,Y+9
    02F6D 8219      STD	Y+1,R1
    02F6E 8208      ST	Y,R0
    02F6F E021      LDI	R18,1
    02F70 E002      LDI	R16,2
    02F71 940E 3505 CALL	_LCD_var_disp
(0333) LCD_var_disp(4,1,pT);
    02F73 82F9      STD	Y+1,R15
    02F74 82E8      ST	Y,R14
    02F75 E021      LDI	R18,1
    02F76 E004      LDI	R16,4
    02F77 940E 3505 CALL	_LCD_var_disp
(0334) delayms(250);
    02F79 EF0A      LDI	R16,0xFA
    02F7A E010      LDI	R17,0
    02F7B 940E 23F0 CALL	_delayms
    02F7D C1EC      RJMP	0x316A
(0335) while(1)
(0336) {
(0337) keyc=kbscan();
    02F7E 940E 3AC7 CALL	_kbscan
    02F80 2F60      MOV	R22,R16
(0338) pD[2]=Result.Date[2];
    02F81 9020 04EE LDS	R2,Result+20
    02F83 85E8      LDD	R30,Y+8
    02F84 85F9      LDD	R31,Y+9
    02F85 8222      STD	Z+2,R2
(0339) pD[3]=Result.Date[3];
    02F86 9020 04EF LDS	R2,Result+21
    02F88 8223      STD	Z+3,R2
(0340) pD[6]=Result.Date[4];
    02F89 9020 04F0 LDS	R2,Result+22
    02F8B 8226      STD	Z+6,R2
(0341) pD[7]=Result.Date[5];
    02F8C 9020 04F1 LDS	R2,Result+23
    02F8E 8227      STD	Z+7,R2
(0342) pD[10]=Result.Date[6];
    02F8F 9020 04F2 LDS	R2,Result+24
    02F91 8622      STD	Z+10,R2
(0343) pD[11]=Result.Date[7];  
    02F92 9020 04F3 LDS	R2,Result+25
    02F94 8623      STD	Z+11,R2
(0344) 
(0345) switch(i){
    02F95 2EA4      MOV	R10,R20
    02F96 24BB      CLR	R11
    02F97 20AA      TST	R10
    02F98 F411      BNE	0x2F9B
    02F99 20BB      TST	R11
    02F9A F0D9      BEQ	0x2FB6
    02F9B 01C5      MOVW	R24,R10
    02F9C 3081      CPI	R24,1
    02F9D E0E0      LDI	R30,0
    02F9E 079E      CPC	R25,R30
    02F9F F409      BNE	0x2FA1
    02FA0 C049      RJMP	0x2FEA
    02FA1 3082      CPI	R24,2
    02FA2 E0E0      LDI	R30,0
    02FA3 079E      CPC	R25,R30
    02FA4 F409      BNE	0x2FA6
    02FA5 C07D      RJMP	0x3023
    02FA6 3083      CPI	R24,3
    02FA7 E0E0      LDI	R30,0
    02FA8 079E      CPC	R25,R30
    02FA9 F409      BNE	0x2FAB
    02FAA C0C1      RJMP	0x306C
    02FAB 3084      CPI	R24,4
    02FAC E0E0      LDI	R30,0
    02FAD 079E      CPC	R25,R30
    02FAE F409      BNE	0x2FB0
    02FAF C0F6      RJMP	0x30A6
    02FB0 3085      CPI	R24,5
    02FB1 E0E0      LDI	R30,0
    02FB2 079E      CPC	R25,R30
    02FB3 F409      BNE	0x2FB5
    02FB4 C12A      RJMP	0x30DF
    02FB5 C165      RJMP	0x311B
(0346)          case 0: p=2;ary=GUI_up;  //年
    02FB6 E082      LDI	R24,2
    02FB7 878A      STD	Y+10,R24
    02FB8 01CE      MOVW	R24,R28
    02FB9 9602      ADIW	R24,2
    02FBA 016C      MOVW	R12,R24
(0347) 		 	  	 if(keyc==up){ if(time_buf[1]<0x99){ time_buf[1]++;
    02FBB 316E      CPI	R22,0x1E
    02FBC F491      BNE	0x2FCF
    02FBD 9180 04CF LDS	R24,time_buf+1
    02FBF 3989      CPI	R24,0x99
    02FC0 F008      BCS	0x2FC2
    02FC1 C159      RJMP	0x311B
    02FC2 5F8F      SUBI	R24,0xFF
    02FC3 9380 04CF STS	time_buf+1,R24
(0348) 												  if((time_buf[1]&0x0f)==0x0a) time_buf[1]=time_buf[1]+6;
    02FC5 708F      ANDI	R24,0xF
    02FC6 308A      CPI	R24,0xA
    02FC7 F009      BEQ	0x2FC9
    02FC8 C152      RJMP	0x311B
    02FC9 9180 04CF LDS	R24,time_buf+1
    02FCB 5F8A      SUBI	R24,0xFA
    02FCC 9380 04CF STS	time_buf+1,R24
(0349) 												   }
(0350) 												     
(0351) 								 }				  
    02FCE C14C      RJMP	0x311B
(0352)  					        
(0353) 			     else if(keyc==down){ if(time_buf[1]>0x00){  time_buf[1]--;
    02FCF 316D      CPI	R22,0x1D
    02FD0 F4A1      BNE	0x2FE5
    02FD1 E080      LDI	R24,0
    02FD2 9020 04CF LDS	R2,time_buf+1
    02FD4 1582      CP	R24,R2
    02FD5 F008      BCS	0x2FD7
    02FD6 C144      RJMP	0x311B
    02FD7 2D82      MOV	R24,R2
    02FD8 5081      SUBI	R24,1
    02FD9 9380 04CF STS	time_buf+1,R24
(0354) 				 	  			   						 if((time_buf[1]&0x0f)==0x0f) time_buf[1]=time_buf[1]-6;
    02FDB 708F      ANDI	R24,0xF
    02FDC 308F      CPI	R24,0xF
    02FDD F009      BEQ	0x2FDF
    02FDE C13C      RJMP	0x311B
    02FDF 9180 04CF LDS	R24,time_buf+1
    02FE1 5086      SUBI	R24,6
    02FE2 9380 04CF STS	time_buf+1,R24
(0355) 		 	  	 			  					        }
(0356) 												   
(0357) 								 }			   		
    02FE4 C136      RJMP	0x311B
(0358) 				else if(keyc==right) {i=1;}
    02FE5 3167      CPI	R22,0x17
    02FE6 F009      BEQ	0x2FE8
    02FE7 C133      RJMP	0x311B
    02FE8 E041      LDI	R20,1
(0359) 				break;
    02FE9 C131      RJMP	0x311B
(0360) 		 case 1: p=4;ary=GUI_up;  //月
    02FEA E084      LDI	R24,4
    02FEB 878A      STD	Y+10,R24
    02FEC 01CE      MOVW	R24,R28
    02FED 9602      ADIW	R24,2
    02FEE 016C      MOVW	R12,R24
(0361) 		  	  	if(keyc==up){ if(time_buf[2]<0x12){  time_buf[2]++;	
    02FEF 316E      CPI	R22,0x1E
    02FF0 F499      BNE	0x3004
    02FF1 9180 04D0 LDS	R24,time_buf+2
    02FF3 3182      CPI	R24,0x12
    02FF4 F460      BCC	0x3001
    02FF5 5F8F      SUBI	R24,0xFF
    02FF6 9380 04D0 STS	time_buf+2,R24
(0362) 													if((time_buf[2]&0x0f)==0x0a) time_buf[2]+=6;
    02FF8 708F      ANDI	R24,0xF
    02FF9 308A      CPI	R24,0xA
    02FFA F449      BNE	0x3004
    02FFB 9180 04D0 LDS	R24,time_buf+2
    02FFD 5F8A      SUBI	R24,0xFA
    02FFE 9380 04D0 STS	time_buf+2,R24
(0363) 													 
(0364) 													
(0365) 												 }
    03000 C003      RJMP	0x3004
(0366) 							else time_buf[2]=0x01;
    03001 E081      LDI	R24,1
    03002 9380 04D0 STS	time_buf+2,R24
(0367) 						  }						 
(0368) 				if(keyc==down){ if(time_buf[2]>0x01){  time_buf[2]--;	
    03004 316D      CPI	R22,0x1D
    03005 F4A9      BNE	0x301B
    03006 E081      LDI	R24,1
    03007 9020 04D0 LDS	R2,time_buf+2
    03009 1582      CP	R24,R2
    0300A F468      BCC	0x3018
    0300B 2D82      MOV	R24,R2
    0300C 5081      SUBI	R24,1
    0300D 9380 04D0 STS	time_buf+2,R24
(0369) 													if((time_buf[2]&0x0f)==0x0f) time_buf[2]-=6;
    0300F 708F      ANDI	R24,0xF
    03010 308F      CPI	R24,0xF
    03011 F449      BNE	0x301B
    03012 9180 04D0 LDS	R24,time_buf+2
    03014 5086      SUBI	R24,6
    03015 9380 04D0 STS	time_buf+2,R24
(0370) 													
(0371) 												 }
    03017 C003      RJMP	0x301B
(0372) 							 else time_buf[2]=0x12;						
    03018 E182      LDI	R24,0x12
    03019 9380 04D0 STS	time_buf+2,R24
(0373) 						  }						 							
(0374) 				if(keyc==left) {i=0;   }									
    0301B 316B      CPI	R22,0x1B
    0301C F409      BNE	0x301E
    0301D 2744      CLR	R20
(0375) 				if(keyc==right) {i=2;   }  
    0301E 3167      CPI	R22,0x17
    0301F F009      BEQ	0x3021
    03020 C0FA      RJMP	0x311B
    03021 E042      LDI	R20,2
(0376) 				 break;
    03022 C0F8      RJMP	0x311B
(0377) 				 
(0378) 				 									
(0379)          
(0380) 		 case 2: p=6;ary=GUI_up;
    03023 E086      LDI	R24,6
    03024 878A      STD	Y+10,R24
    03025 01CE      MOVW	R24,R28
    03026 9602      ADIW	R24,2
    03027 016C      MOVW	R12,R24
(0381) 		 	  	 if(keyc==up){ if(time_buf[3]<0x31){ time_buf[3]++;
    03028 316E      CPI	R22,0x1E
    03029 F519      BNE	0x304D
    0302A 9180 04D1 LDS	R24,time_buf+3
    0302C 3381      CPI	R24,0x31
    0302D F5B0      BCC	0x3064
    0302E 5F8F      SUBI	R24,0xFF
    0302F 9380 04D1 STS	time_buf+3,R24
(0382) 												  if ((time_buf[3]&0x0f)==0x0a) time_buf[3]=time_buf[3]+6;
    03031 708F      ANDI	R24,0xF
    03032 308A      CPI	R24,0xA
    03033 F429      BNE	0x3039
    03034 9180 04D1 LDS	R24,time_buf+3
    03036 5F8A      SUBI	R24,0xFA
    03037 9380 04D1 STS	time_buf+3,R24
(0383) 											
(0384) 											if(  //2 4 6 9 11 月最大30天
(0385) 											( ((time_buf[2]==0x02) || (time_buf[2]==0x04)|| (time_buf[2]==0x06)||
    03039 9180 04D0 LDS	R24,time_buf+2
    0303B 3082      CPI	R24,2
    0303C F041      BEQ	0x3045
    0303D 3084      CPI	R24,4
    0303E F031      BEQ	0x3045
    0303F 3086      CPI	R24,6
    03040 F021      BEQ	0x3045
    03041 3089      CPI	R24,0x9
    03042 F011      BEQ	0x3045
    03043 3181      CPI	R24,0x11
    03044 F4F9      BNE	0x3064
    03045 9180 04D1 LDS	R24,time_buf+3
    03047 3381      CPI	R24,0x31
    03048 F4D9      BNE	0x3064
(0386) 											  (time_buf[2]==0x09)||(time_buf[2]==0x11))&&(time_buf[3]==0x31) 
(0387) 											)  
(0388) 											  )
(0389) 											{time_buf[3]=0x30;}
    03049 E380      LDI	R24,0x30
    0304A 9380 04D1 STS	time_buf+3,R24
(0390) 											      }
(0391)  									  
(0392)  					         }
    0304C C017      RJMP	0x3064
(0393) 			     else if(keyc==down){ if(time_buf[3]>0x01){  time_buf[3]--;
    0304D 316D      CPI	R22,0x1D
    0304E F4A9      BNE	0x3064
    0304F E081      LDI	R24,1
    03050 9020 04D1 LDS	R2,time_buf+3
    03052 1582      CP	R24,R2
    03053 F468      BCC	0x3061
    03054 2D82      MOV	R24,R2
    03055 5081      SUBI	R24,1
    03056 9380 04D1 STS	time_buf+3,R24
(0394) 				 	  			   						 if((time_buf[3]&0x0f)==0x0f) time_buf[3]=time_buf[3]-6;
    03058 708F      ANDI	R24,0xF
    03059 308F      CPI	R24,0xF
    0305A F449      BNE	0x3064
    0305B 9180 04D1 LDS	R24,time_buf+3
    0305D 5086      SUBI	R24,6
    0305E 9380 04D1 STS	time_buf+3,R24
(0395) 		 	  	 			  					        }
    03060 C003      RJMP	0x3064
(0396) 								   else time_buf[3]=0x31;						
    03061 E381      LDI	R24,0x31
    03062 9380 04D1 STS	time_buf+3,R24
(0397) 												   
(0398) 								 }
(0399) 				if(keyc==left) {i=1;  }						 			   		
    03064 316B      CPI	R22,0x1B
    03065 F409      BNE	0x3067
    03066 E041      LDI	R20,1
(0400) 				if(keyc==right) {i=3;    }  	
    03067 3167      CPI	R22,0x17
    03068 F009      BEQ	0x306A
    03069 C0B1      RJMP	0x311B
    0306A E043      LDI	R20,3
(0401) 				 break;
    0306B C0AF      RJMP	0x311B
(0402) 							
(0403) 				
(0404)  case 3:p=1;ary=GUI_down;
    0306C 2400      CLR	R0
    0306D 9403      INC	R0
    0306E 860A      STD	Y+10,R0
    0306F 01CE      MOVW	R24,R28
    03070 9605      ADIW	R24,5
    03071 016C      MOVW	R12,R24
(0405)  	  	if(keyc==up){ if(time_buf[4]<0x23){  time_buf[4]++;	
    03072 316E      CPI	R22,0x1E
    03073 F499      BNE	0x3087
    03074 9180 04D2 LDS	R24,time_buf+4
    03076 3283      CPI	R24,0x23
    03077 F460      BCC	0x3084
    03078 5F8F      SUBI	R24,0xFF
    03079 9380 04D2 STS	time_buf+4,R24
(0406) 													if((time_buf[4]&0x0f)==0x0a) time_buf[4]+=6;
    0307B 708F      ANDI	R24,0xF
    0307C 308A      CPI	R24,0xA
    0307D F449      BNE	0x3087
    0307E 9180 04D2 LDS	R24,time_buf+4
    03080 5F8A      SUBI	R24,0xFA
    03081 9380 04D2 STS	time_buf+4,R24
(0407) 													 
(0408) 													
(0409) 												 }
    03083 C003      RJMP	0x3087
(0410) 							else time_buf[4]=0x00;
    03084 2422      CLR	R2
    03085 9220 04D2 STS	time_buf+4,R2
(0411) 						  }						 
(0412) 				if(keyc==down){ if(time_buf[4]>0x00){  time_buf[4]--;	
    03087 316D      CPI	R22,0x1D
    03088 F4A9      BNE	0x309E
    03089 E080      LDI	R24,0
    0308A 9020 04D2 LDS	R2,time_buf+4
    0308C 1582      CP	R24,R2
    0308D F468      BCC	0x309B
    0308E 2D82      MOV	R24,R2
    0308F 5081      SUBI	R24,1
    03090 9380 04D2 STS	time_buf+4,R24
(0413) 													if((time_buf[4]&0x0f)==0x0f) time_buf[4]-=6;
    03092 708F      ANDI	R24,0xF
    03093 308F      CPI	R24,0xF
    03094 F449      BNE	0x309E
    03095 9180 04D2 LDS	R24,time_buf+4
    03097 5086      SUBI	R24,6
    03098 9380 04D2 STS	time_buf+4,R24
(0414) 													
(0415) 												 }
    0309A C003      RJMP	0x309E
(0416) 							 else time_buf[4]=0x23;						
    0309B E283      LDI	R24,0x23
    0309C 9380 04D2 STS	time_buf+4,R24
(0417) 						  }	
(0418) 		if(keyc==left ) {i=2;   } 				  
    0309E 316B      CPI	R22,0x1B
    0309F F409      BNE	0x30A1
    030A0 E042      LDI	R20,2
(0419) 		if(keyc==right) {i=4;    } 
    030A1 3167      CPI	R22,0x17
    030A2 F009      BEQ	0x30A4
    030A3 C077      RJMP	0x311B
    030A4 E044      LDI	R20,4
(0420) 		break;						  					 			
    030A5 C075      RJMP	0x311B
(0421)  case 4:p=3;ary=GUI_down;
    030A6 E083      LDI	R24,3
    030A7 878A      STD	Y+10,R24
    030A8 01CE      MOVW	R24,R28
    030A9 9605      ADIW	R24,5
    030AA 016C      MOVW	R12,R24
(0422)  	  	if(keyc==up){ if(time_buf[5]<0x59){  time_buf[5]++;	
    030AB 316E      CPI	R22,0x1E
    030AC F499      BNE	0x30C0
    030AD 9180 04D3 LDS	R24,time_buf+5
    030AF 3589      CPI	R24,0x59
    030B0 F460      BCC	0x30BD
    030B1 5F8F      SUBI	R24,0xFF
    030B2 9380 04D3 STS	time_buf+5,R24
(0423) 											 if((time_buf[5]&0x0f)==0x0a) time_buf[5]+=6;
    030B4 708F      ANDI	R24,0xF
    030B5 308A      CPI	R24,0xA
    030B6 F449      BNE	0x30C0
    030B7 9180 04D3 LDS	R24,time_buf+5
    030B9 5F8A      SUBI	R24,0xFA
    030BA 9380 04D3 STS	time_buf+5,R24
(0424) 										  }
    030BC C003      RJMP	0x30C0
(0425) 					  else time_buf[5]=0x00;
    030BD 2422      CLR	R2
    030BE 9220 04D3 STS	time_buf+5,R2
(0426) 					}						 
(0427) 		if(keyc==down){ if(time_buf[5]>0x00){  time_buf[5]--;	
    030C0 316D      CPI	R22,0x1D
    030C1 F4A9      BNE	0x30D7
    030C2 E080      LDI	R24,0
    030C3 9020 04D3 LDS	R2,time_buf+5
    030C5 1582      CP	R24,R2
    030C6 F468      BCC	0x30D4
    030C7 2D82      MOV	R24,R2
    030C8 5081      SUBI	R24,1
    030C9 9380 04D3 STS	time_buf+5,R24
(0428) 												if((time_buf[5]&0x0f)==0x0f) time_buf[5]-=6;
    030CB 708F      ANDI	R24,0xF
    030CC 308F      CPI	R24,0xF
    030CD F449      BNE	0x30D7
    030CE 9180 04D3 LDS	R24,time_buf+5
    030D0 5086      SUBI	R24,6
    030D1 9380 04D3 STS	time_buf+5,R24
(0429) 											}
    030D3 C003      RJMP	0x30D7
(0430) 						else time_buf[5]=0x59;						
    030D4 E589      LDI	R24,0x59
    030D5 9380 04D3 STS	time_buf+5,R24
(0431) 					  }
(0432) 		if(keyc==left ) {i=3;    } 		  						 								  			
    030D7 316B      CPI	R22,0x1B
    030D8 F409      BNE	0x30DA
    030D9 E043      LDI	R20,3
(0433)  		if(keyc==right) {i=5;   }	
    030DA 3167      CPI	R22,0x17
    030DB F009      BEQ	0x30DD
    030DC C03E      RJMP	0x311B
    030DD E045      LDI	R20,5
(0434) 		break;			   
    030DE C03C      RJMP	0x311B
(0435)  case 5:p=5;ary=GUI_down;
    030DF E085      LDI	R24,5
    030E0 878A      STD	Y+10,R24
    030E1 01CE      MOVW	R24,R28
    030E2 9605      ADIW	R24,5
    030E3 016C      MOVW	R12,R24
(0436)  	  	if(keyc==up){ if(time_buf[6]<0x59){  time_buf[6]++;	
    030E4 316E      CPI	R22,0x1E
    030E5 F499      BNE	0x30F9
    030E6 9180 04D4 LDS	R24,time_buf+6
    030E8 3589      CPI	R24,0x59
    030E9 F460      BCC	0x30F6
    030EA 5F8F      SUBI	R24,0xFF
    030EB 9380 04D4 STS	time_buf+6,R24
(0437) 											 if((time_buf[6]&0x0f)==0x0a) time_buf[6]+=6;
    030ED 708F      ANDI	R24,0xF
    030EE 308A      CPI	R24,0xA
    030EF F449      BNE	0x30F9
    030F0 9180 04D4 LDS	R24,time_buf+6
    030F2 5F8A      SUBI	R24,0xFA
    030F3 9380 04D4 STS	time_buf+6,R24
(0438) 										 }
    030F5 C003      RJMP	0x30F9
(0439) 					  else time_buf[6]=0x00;
    030F6 2422      CLR	R2
    030F7 9220 04D4 STS	time_buf+6,R2
(0440) 					}						 
(0441) 		if(keyc==down){ if(time_buf[6]>0x00){  time_buf[6]--;	
    030F9 316D      CPI	R22,0x1D
    030FA F4A9      BNE	0x3110
    030FB E080      LDI	R24,0
    030FC 9020 04D4 LDS	R2,time_buf+6
    030FE 1582      CP	R24,R2
    030FF F468      BCC	0x310D
    03100 2D82      MOV	R24,R2
    03101 5081      SUBI	R24,1
    03102 9380 04D4 STS	time_buf+6,R24
(0442) 						if((time_buf[6]&0x0f)==0x0f) time_buf[6]-=6;
    03104 708F      ANDI	R24,0xF
    03105 308F      CPI	R24,0xF
    03106 F449      BNE	0x3110
    03107 9180 04D4 LDS	R24,time_buf+6
    03109 5086      SUBI	R24,6
    0310A 9380 04D4 STS	time_buf+6,R24
(0443) 					  }
    0310C C003      RJMP	0x3110
(0444) 		else time_buf[6]=0x59;		}				
    0310D E589      LDI	R24,0x59
    0310E 9380 04D4 STS	time_buf+6,R24
(0445) 		if(keyc==left ) {i=4;    } 		  				 														   
    03110 316B      CPI	R22,0x1B
    03111 F409      BNE	0x3113
    03112 E044      LDI	R20,4
(0446) 		if(keyc==right) {i=6;p=1;ary=NULL;}  
    03113 3167      CPI	R22,0x17
    03114 F431      BNE	0x311B
    03115 E046      LDI	R20,6
    03116 2400      CLR	R0
    03117 9403      INC	R0
    03118 860A      STD	Y+10,R0
    03119 24CC      CLR	R12
    0311A 24DD      CLR	R13
(0447) 		break;           
(0448) 							 
(0449) 		 }//endcase
(0450)  		 dateRefresh(0);
    0311B 2700      CLR	R16
    0311C D051      RCALL	_dateRefresh
(0451) 		 
(0452) 		 LCD_const_disp(3,1,"                "); //清空箭头 
    0311D E782      LDI	R24,0x72
    0311E E093      LDI	R25,3
    0311F 8399      STD	Y+1,R25
    03120 8388      ST	Y,R24
    03121 E021      LDI	R18,1
    03122 E003      LDI	R16,3
    03123 940E 34D8 CALL	_LCD_const_disp
(0453)  		 LCD_var_disp(3,p,ary); //显示箭头 
    03125 82D9      STD	Y+1,R13
    03126 82C8      ST	Y,R12
    03127 852A      LDD	R18,Y+10
    03128 E003      LDI	R16,3
    03129 940E 3505 CALL	_LCD_var_disp
(0454)  		 LCD_var_disp(2,1,pD);  //显示日期
    0312B 8408      LDD	R0,Y+8
    0312C 8419      LDD	R1,Y+9
    0312D 8219      STD	Y+1,R1
    0312E 8208      ST	Y,R0
    0312F E021      LDI	R18,1
    03130 E002      LDI	R16,2
    03131 940E 3505 CALL	_LCD_var_disp
(0455)  		 LCD_var_disp(4,1,pT);  //显示时间
    03133 82F9      STD	Y+1,R15
    03134 82E8      ST	Y,R14
    03135 E021      LDI	R18,1
    03136 E004      LDI	R16,4
    03137 940E 3505 CALL	_LCD_var_disp
(0456)  if(keyc==lright) {		  
    03139 3967      CPI	R22,0x97
    0313A F479      BNE	0x314A
(0457)  		  LCD_const_disp(3,1,"        放弃修改"); 
    0313B E681      LDI	R24,0x61
    0313C E093      LDI	R25,3
    0313D 8399      STD	Y+1,R25
    0313E 8388      ST	Y,R24
    0313F E021      LDI	R18,1
    03140 E003      LDI	R16,3
    03141 940E 34D8 CALL	_LCD_const_disp
(0458) 		  delayms(500);
    03143 EF04      LDI	R16,0xF4
    03144 E011      LDI	R17,1
    03145 940E 23F0 CALL	_delayms
(0459) 		  LCD_CLR(); //清屏
    03147 940E 357E CALL	_LCD_CLR
(0460) 		  return ;} 
    03149 C021      RJMP	0x316B
(0461)  keyc=NO_KEY;
    0314A 2766      CLR	R22
(0462)  if(i==6){    //各值改变完成后 显示已保存 清屏 返回
    0314B 3046      CPI	R20,6
    0314C F4C9      BNE	0x3166
(0463) 		  ds1302_write_time(); 
    0314D 940E 3A7A CALL	_ds1302_write_time
(0464)           LCD_const_disp(4,7,"    ");		  
    0314F E58C      LDI	R24,0x5C
    03150 E093      LDI	R25,3
    03151 8399      STD	Y+1,R25
    03152 8388      ST	Y,R24
    03153 E027      LDI	R18,7
    03154 E004      LDI	R16,4
    03155 940E 34D8 CALL	_LCD_const_disp
(0465) 		  LCD_const_disp(3,1,"          已保存"); 
    03157 E48B      LDI	R24,0x4B
    03158 E093      LDI	R25,3
    03159 8399      STD	Y+1,R25
    0315A 8388      ST	Y,R24
    0315B E021      LDI	R18,1
    0315C E003      LDI	R16,3
    0315D 940E 34D8 CALL	_LCD_const_disp
(0466) 		  delayms(500);
    0315F EF04      LDI	R16,0xF4
    03160 E011      LDI	R17,1
    03161 940E 23F0 CALL	_delayms
(0467) 		  LCD_CLR(); //清屏
    03163 940E 357E CALL	_LCD_CLR
(0468) 		  return ;
    03165 C005      RJMP	0x316B
(0469) 		  }
(0470)  delayms(2);	  
    03166 E002      LDI	R16,2
    03167 E010      LDI	R17,0
    03168 940E 23F0 CALL	_delayms
    0316A CE13      RJMP	0x2F7E
    0316B 962B      ADIW	R28,0xB
    0316C 940C 3C6A JMP	pop_xgsetF0FC
_dateRefresh:
  readhardware         --> R20
    0316E 934A      ST	-Y,R20
    0316F 2F40      MOV	R20,R16
(0471) }//endwhile(1)
(0472) 
(0473) 
(0474) }
(0475) ////////////////////////////////////
(0476) //  函数作用
(0477) //   将ds1302中缓存的时钟数据转换进结构体中
(0478) ////////////////////////////////////
(0479) void dateRefresh(unsigned char readhardware)
(0480) {	
(0481) 	if( readhardware==1 ){
    03170 3041      CPI	R20,1
    03171 F411      BNE	0x3174
(0482) 		ds1302_read_time();
    03172 940E 3A9F CALL	_ds1302_read_time
(0483) 	}
(0484) 	t.tm_sec=(((time_buf[6]&0x70)>>4)*10)+(time_buf[6]&0x0f);
    03174 9110 04D4 LDS	R17,time_buf+6
    03176 7710      ANDI	R17,0x70
    03177 9512      SWAP	R17
    03178 701F      ANDI	R17,0xF
    03179 E00A      LDI	R16,0xA
    0317A 0301      MULSU	R16,R17
    0317B 0110      MOVW	R2,R0
    0317C 9180 04D4 LDS	R24,time_buf+6
    0317E 2799      CLR	R25
    0317F 708F      ANDI	R24,0xF
    03180 7090      ANDI	R25,0
    03181 0E28      ADD	R2,R24
    03182 1E39      ADC	R3,R25
    03183 9230 0735 STS	t+1,R3
    03185 9220 0734 STS	t,R2
(0485) 	t.tm_min=  (((time_buf[5]&0x70)>>4)*10)+(time_buf[5]&0x0f);
    03187 9110 04D3 LDS	R17,time_buf+5
    03189 7710      ANDI	R17,0x70
    0318A 9512      SWAP	R17
    0318B 701F      ANDI	R17,0xF
    0318C 0301      MULSU	R16,R17
    0318D 0110      MOVW	R2,R0
    0318E 9180 04D3 LDS	R24,time_buf+5
    03190 2799      CLR	R25
    03191 708F      ANDI	R24,0xF
    03192 7090      ANDI	R25,0
    03193 0E28      ADD	R2,R24
    03194 1E39      ADC	R3,R25
    03195 9230 0737 STS	t+3,R3
    03197 9220 0736 STS	t+2,R2
(0486) 	t.tm_hour=  (((time_buf[4]&0x70)>>4)*10)+(time_buf[4]&0x0f);
    03199 9110 04D2 LDS	R17,time_buf+4
    0319B 7710      ANDI	R17,0x70
    0319C 9512      SWAP	R17
    0319D 701F      ANDI	R17,0xF
    0319E 0301      MULSU	R16,R17
    0319F 0110      MOVW	R2,R0
    031A0 9180 04D2 LDS	R24,time_buf+4
    031A2 2799      CLR	R25
    031A3 708F      ANDI	R24,0xF
    031A4 7090      ANDI	R25,0
    031A5 0E28      ADD	R2,R24
    031A6 1E39      ADC	R3,R25
    031A7 9230 0739 STS	t+5,R3
    031A9 9220 0738 STS	t+4,R2
(0487) 	t.tm_mday=	(((time_buf[3]&0x70)>>4)*10)+(time_buf[3]&0x0f);
    031AB 9110 04D1 LDS	R17,time_buf+3
    031AD 7710      ANDI	R17,0x70
    031AE 9512      SWAP	R17
    031AF 701F      ANDI	R17,0xF
    031B0 0301      MULSU	R16,R17
    031B1 0110      MOVW	R2,R0
    031B2 9180 04D1 LDS	R24,time_buf+3
    031B4 2799      CLR	R25
    031B5 708F      ANDI	R24,0xF
    031B6 7090      ANDI	R25,0
    031B7 0E28      ADD	R2,R24
    031B8 1E39      ADC	R3,R25
    031B9 9230 073B STS	t+7,R3
    031BB 9220 073A STS	t+6,R2
(0488) 	t.tm_mon= (((time_buf[2]&0x70)>>4)*10)+(time_buf[2]&0x0f);
    031BD 9110 04D0 LDS	R17,time_buf+2
    031BF 7710      ANDI	R17,0x70
    031C0 9512      SWAP	R17
    031C1 701F      ANDI	R17,0xF
    031C2 0301      MULSU	R16,R17
    031C3 0110      MOVW	R2,R0
    031C4 9180 04D0 LDS	R24,time_buf+2
    031C6 2799      CLR	R25
    031C7 708F      ANDI	R24,0xF
    031C8 7090      ANDI	R25,0
    031C9 0E28      ADD	R2,R24
    031CA 1E39      ADC	R3,R25
    031CB 9230 073D STS	t+9,R3
    031CD 9220 073C STS	t+8,R2
(0489) 	t.tm_wday=	(time_buf[7]&0x0f);
    031CF 9180 04D5 LDS	R24,time_buf+7
    031D1 2799      CLR	R25
    031D2 708F      ANDI	R24,0xF
    031D3 7090      ANDI	R25,0
    031D4 9390 0741 STS	t+13,R25
    031D6 9380 0740 STS	t+12,R24
(0490)     t.tm_year=	(((time_buf[1]&0x70)>>4)*10)+(time_buf[1]&0x0f);
    031D8 9110 04CF LDS	R17,time_buf+1
    031DA 7710      ANDI	R17,0x70
    031DB 9512      SWAP	R17
    031DC 701F      ANDI	R17,0xF
    031DD 0301      MULSU	R16,R17
    031DE 0110      MOVW	R2,R0
    031DF 9180 04CF LDS	R24,time_buf+1
    031E1 2799      CLR	R25
    031E2 708F      ANDI	R24,0xF
    031E3 7090      ANDI	R25,0
    031E4 0E28      ADD	R2,R24
    031E5 1E39      ADC	R3,R25
    031E6 9230 073F STS	t+11,R3
    031E8 9220 073E STS	t+10,R2
(0491) 	Result.Date[0]='2';
    031EA E382      LDI	R24,0x32
    031EB 9380 04EC STS	Result+18,R24
(0492) 	Result.Date[1]='0';
    031ED E380      LDI	R24,0x30
    031EE 9380 04ED STS	Result+19,R24
(0493) 	Result.Date[2]=t.tm_year/10+'0';
    031F0 E02A      LDI	R18,0xA
    031F1 E030      LDI	R19,0
    031F2 0181      MOVW	R16,R2
    031F3 940E 3B45 CALL	div16s
    031F5 01C8      MOVW	R24,R16
    031F6 96C0      ADIW	R24,0x30
    031F7 9380 04EE STS	Result+20,R24
(0494) 	Result.Date[3]=t.tm_year%10+'0';
    031F9 E02A      LDI	R18,0xA
    031FA E030      LDI	R19,0
    031FB 9100 073E LDS	R16,t+10
    031FD 9110 073F LDS	R17,t+11
    031FF 940E 3B41 CALL	mod16s
    03201 01C8      MOVW	R24,R16
    03202 96C0      ADIW	R24,0x30
    03203 9380 04EF STS	Result+21,R24
(0495) 	Result.Date[4]=t.tm_mon/10+'0';
    03205 E02A      LDI	R18,0xA
    03206 E030      LDI	R19,0
    03207 9100 073C LDS	R16,t+8
    03209 9110 073D LDS	R17,t+9
    0320B 940E 3B45 CALL	div16s
    0320D 01C8      MOVW	R24,R16
    0320E 96C0      ADIW	R24,0x30
    0320F 9380 04F0 STS	Result+22,R24
(0496) 	Result.Date[5]=t.tm_mon%10+'0';
    03211 E02A      LDI	R18,0xA
    03212 E030      LDI	R19,0
    03213 9100 073C LDS	R16,t+8
    03215 9110 073D LDS	R17,t+9
    03217 940E 3B41 CALL	mod16s
    03219 01C8      MOVW	R24,R16
    0321A 96C0      ADIW	R24,0x30
    0321B 9380 04F1 STS	Result+23,R24
(0497) 	Result.Date[6]=t.tm_mday/10+'0';
    0321D E02A      LDI	R18,0xA
    0321E E030      LDI	R19,0
    0321F 9100 073A LDS	R16,t+6
    03221 9110 073B LDS	R17,t+7
    03223 940E 3B45 CALL	div16s
    03225 01C8      MOVW	R24,R16
    03226 96C0      ADIW	R24,0x30
    03227 9380 04F2 STS	Result+24,R24
(0498) 	Result.Date[7]=t.tm_mday%10+'0';
    03229 E02A      LDI	R18,0xA
    0322A E030      LDI	R19,0
    0322B 9100 073A LDS	R16,t+6
    0322D 9110 073B LDS	R17,t+7
    0322F 940E 3B41 CALL	mod16s
    03231 01C8      MOVW	R24,R16
    03232 96C0      ADIW	R24,0x30
    03233 9380 04F3 STS	Result+25,R24
(0499)     Result.Date[8]='\0';
    03235 2422      CLR	R2
    03236 9220 04F4 STS	Result+26,R2
(0500) 	Result.Time[0]=t.tm_hour/10+'0';
    03238 E02A      LDI	R18,0xA
    03239 E030      LDI	R19,0
    0323A 9100 0738 LDS	R16,t+4
    0323C 9110 0739 LDS	R17,t+5
    0323E 940E 3B45 CALL	div16s
    03240 01C8      MOVW	R24,R16
    03241 96C0      ADIW	R24,0x30
    03242 9380 04F5 STS	Result+27,R24
(0501) 	Result.Time[1]=t.tm_hour%10+'0';
    03244 E02A      LDI	R18,0xA
    03245 E030      LDI	R19,0
    03246 9100 0738 LDS	R16,t+4
    03248 9110 0739 LDS	R17,t+5
    0324A 940E 3B41 CALL	mod16s
    0324C 01C8      MOVW	R24,R16
    0324D 96C0      ADIW	R24,0x30
    0324E 9380 04F6 STS	Result+28,R24
(0502) 	Result.Time[2]=':';
    03250 E38A      LDI	R24,0x3A
    03251 9380 04F7 STS	Result+29,R24
(0503) 	Result.Time[3]=' ';
    03253 E280      LDI	R24,0x20
    03254 9380 04F8 STS	Result+30,R24
(0504) 	Result.Time[4]=t.tm_min/10+'0';
    03256 E02A      LDI	R18,0xA
    03257 E030      LDI	R19,0
    03258 9100 0736 LDS	R16,t+2
    0325A 9110 0737 LDS	R17,t+3
    0325C 940E 3B45 CALL	div16s
    0325E 01C8      MOVW	R24,R16
    0325F 96C0      ADIW	R24,0x30
    03260 9380 04F9 STS	Result+31,R24
(0505) 	Result.Time[5]=t.tm_min%10+'0';
    03262 E02A      LDI	R18,0xA
    03263 E030      LDI	R19,0
    03264 9100 0736 LDS	R16,t+2
    03266 9110 0737 LDS	R17,t+3
    03268 940E 3B41 CALL	mod16s
    0326A 01C8      MOVW	R24,R16
    0326B 96C0      ADIW	R24,0x30
    0326C 9380 04FA STS	Result+32,R24
(0506) 	Result.Time[6]=':';
    0326E E38A      LDI	R24,0x3A
    0326F 9380 04FB STS	Result+33,R24
(0507) 	Result.Time[7]=' ';
    03271 E280      LDI	R24,0x20
    03272 9380 04FC STS	Result+34,R24
(0508) 	Result.Time[8]=t.tm_sec/10+'0';
    03274 E02A      LDI	R18,0xA
    03275 E030      LDI	R19,0
    03276 9100 0734 LDS	R16,t
    03278 9110 0735 LDS	R17,t+1
    0327A 940E 3B45 CALL	div16s
    0327C 01C8      MOVW	R24,R16
    0327D 96C0      ADIW	R24,0x30
    0327E 9380 04FD STS	Result+35,R24
(0509) 	Result.Time[9]=t.tm_sec%10+'0';
    03280 E02A      LDI	R18,0xA
    03281 E030      LDI	R19,0
    03282 9100 0734 LDS	R16,t
    03284 9110 0735 LDS	R17,t+1
    03286 940E 3B41 CALL	mod16s
    03288 01C8      MOVW	R24,R16
    03289 96C0      ADIW	R24,0x30
    0328A 9380 04FE STS	Result+36,R24
(0510) 	Result.Time[10]='\0'; 
    0328C 2422      CLR	R2
    0328D 9220 04FF STS	Result+37,R2
(0511) 	//
(0512) 	config.now =t.tm_hour*3600 + t.tm_min*60 + t.tm_sec;
    0328F 9120 0736 LDS	R18,t+2
    03291 9130 0737 LDS	R19,t+3
    03293 E30C      LDI	R16,0x3C
    03294 E010      LDI	R17,0
    03295 940E 3C11 CALL	empy16s
    03297 0118      MOVW	R2,R16
    03298 9120 0738 LDS	R18,t+4
    0329A 9130 0739 LDS	R19,t+5
    0329C E100      LDI	R16,0x10
    0329D E01E      LDI	R17,0xE
    0329E 940E 3C11 CALL	empy16s
    032A0 0128      MOVW	R4,R16
    032A1 0C42      ADD	R4,R2
    032A2 1C53      ADC	R5,R3
    032A3 9020 0734 LDS	R2,t
    032A5 9030 0735 LDS	R3,t+1
    032A7 0C42      ADD	R4,R2
    032A8 1C53      ADC	R5,R3
    032A9 0112      MOVW	R2,R4
    032AA 2444      CLR	R4
    032AB FC37      SBRC	R3,7
    032AC 9440      COM	R4
    032AD 2455      CLR	R5
    032AE FC47      SBRC	R4,7
    032AF 9450      COM	R5
    032B0 9230 0753 STS	config+13,R3
    032B2 9220 0752 STS	config+12,R2
    032B4 9250 0755 STS	config+15,R5
    032B6 9240 0754 STS	config+14,R4
    032B8 9149      LD	R20,Y+
    032B9 9508      RET
FILE: D:\LQD\software\master\software_src\usart.c
(0001) #include "config.h"
(0002) 
(0003) 
(0004) #define fosc 7372800UL //晶振7.3728MHZ
(0005) #define baud 38400  //波特率
(0006) //串口通信初始化  MEGA128
(0007) //UART1 initialize
(0008) // desired baud rate:38400
(0009) // actual baud rate:38400 (0.0%)
(0010) // char size: 8 bit
(0011) // parity: Disabled
(0012) void uart1_init(void)
(0013) {
(0014)  	 UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    032BA 2422      CLR	R2
    032BB 9220 009A STS	0x9A,R2
(0015)      UCSR1A = 0x00;
    032BD 9220 009B STS	0x9B,R2
(0016)      UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//8bit+1bit stop
    032BF E086      LDI	R24,6
    032C0 9380 009D STS	0x9D,R24
(0017)      UBRR1L=(fosc/16/(baud+1))%256;
    032C2 E08B      LDI	R24,0xB
    032C3 9380 0099 STS	0x99,R24
(0018)      UBRR1H=(fosc/16/(baud+1))/256;
    032C5 9220 0098 STS	0x98,R2
(0019)      UCSR1B =(1<<RXEN1)|(1<<TXEN1);//RXCEN TXCEN
    032C7 E188      LDI	R24,0x18
    032C8 9380 009A STS	0x9A,R24
    032CA 9508      RET
_uart1_rx_isr:
  tmp                  --> R16
    032CB 930A      ST	-Y,R16
    032CC B70F      IN	R16,0x3F
    032CD 930A      ST	-Y,R16
(0020) }
(0021) 
(0022) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0023) void uart1_rx_isr(void){   
(0024) 	 char tmp;
(0025) 	 tmp=UDR1;
    032CE 9100 009C LDS	R16,0x9C
    032D0 9109      LD	R16,Y+
    032D1 BF0F      OUT	0x3F,R16
    032D2 9109      LD	R16,Y+
    032D3 9518      RETI
(0026) }
(0027) 
(0028) void Usart_Transmit(char c)
(0029) {
(0030)  	 while (!(UCSR1A&(1<<UDRE1)));//表明发送器一准备就绪
_Usart_Transmit:
  c                    --> R16
    032D4 9020 009B LDS	R2,0x9B
    032D6 FE25      SBRS	R2,5
    032D7 CFFC      RJMP	_Usart_Transmit
(0031) 	 UDR1=c;
    032D8 9300 009C STS	0x9C,R16
    032DA 9508      RET
_Puts:
  s                    --> R20
    032DB 934A      ST	-Y,R20
    032DC 935A      ST	-Y,R21
    032DD 01A8      MOVW	R20,R16
(0032) }
(0033) 
(0034) //串口输出字符串
(0035) void Puts( unsigned char *s)
(0036) { 
    032DE C00B      RJMP	0x32EA
(0037) 	 while (*s) 
(0038)       { 
(0039) 	  //为数据间的隔断创造一个串口能显示的隔断字符 即'/t'  ->  ' '
(0040) 	  if(*s==0x09)  
    032DF 01FA      MOVW	R30,R20
    032E0 8180      LD	R24,Z
    032E1 3089      CPI	R24,0x9
    032E2 F411      BNE	0x32E5
(0041) 	  {   Usart_Transmit(' ');    }
    032E3 E200      LDI	R16,0x20
    032E4 DFEF      RCALL	_Usart_Transmit
(0042) 	 Usart_Transmit(*s);
    032E5 01FA      MOVW	R30,R20
    032E6 8100      LD	R16,Z
    032E7 DFEC      RCALL	_Usart_Transmit
(0043) 	 s++;
    032E8 5F4F      SUBI	R20,0xFF
    032E9 4F5F      SBCI	R21,0xFF
    032EA 01FA      MOVW	R30,R20
    032EB 8020      LD	R2,Z
    032EC 2022      TST	R2
    032ED F789      BNE	0x32DF
    032EE 9159      LD	R21,Y+
    032EF 9149      LD	R20,Y+
    032F0 9508      RET
_Send_nByte:
  i                    --> R20
  len                  --> R10
  p                    --> R12
    032F1 940E 3CA2 CALL	push_xgset303C
    032F3 2EA2      MOV	R10,R18
    032F4 0168      MOVW	R12,R16
(0044) 	
(0045) 	
(0046)       }
(0047) }
(0048) 
(0049) 
(0050) 
(0051) void Send_nByte(unsigned char *p, unsigned char len)
(0052) { 
(0053)   int i = 0;
(0054)   for(i=0;i<len;i++)
    032F5 2744      CLR	R20
    032F6 2755      CLR	R21
    032F7 C007      RJMP	0x32FF
(0055)   {
(0056)    	Usart_Transmit(*(p+i));
    032F8 01FA      MOVW	R30,R20
    032F9 0DEC      ADD	R30,R12
    032FA 1DFD      ADC	R31,R13
    032FB 8100      LD	R16,Z
    032FC DFD7      RCALL	_Usart_Transmit
    032FD 5F4F      SUBI	R20,0xFF
    032FE 4F5F      SBCI	R21,0xFF
    032FF 2C2A      MOV	R2,R10
    03300 2433      CLR	R3
    03301 1542      CP	R20,R2
    03302 0553      CPC	R21,R3
    03303 F3A4      BLT	0x32F8
    03304 940C 3CA9 JMP	pop_xgset303C
_PrintString:
  str                  --> R10
    03306 92AA      ST	-Y,R10
    03307 92BA      ST	-Y,R11
    03308 0158      MOVW	R10,R16
(0057)   }
(0058) }
(0059) 
(0060) void  PrintString(const unsigned char *str)
(0061) {    
    03309 C004      RJMP	0x330E
(0062) 	while(*str!=0)	Usart_Transmit(*str++);
    0330A 01F5      MOVW	R30,R10
    0330B 9101      LD	R16,Z+
    0330C 015F      MOVW	R10,R30
    0330D DFC6      RCALL	_Usart_Transmit
    0330E 01F5      MOVW	R30,R10
    0330F 8020      LD	R2,Z
    03310 2022      TST	R2
    03311 F7C1      BNE	0x330A
    03312 90B9      LD	R11,Y+
    03313 90A9      LD	R10,Y+
    03314 9508      RET
_PrintString_n:
  str                  --> R10
    03315 92AA      ST	-Y,R10
    03316 92BA      ST	-Y,R11
    03317 0158      MOVW	R10,R16
(0063) }
(0064) void  PrintString_n(const unsigned char *str)
(0065) {   
(0066) 	Usart_Transmit('\r');
    03318 E00D      LDI	R16,0xD
    03319 DFBA      RCALL	_Usart_Transmit
(0067) 	Usart_Transmit('\n'); 
    0331A E00A      LDI	R16,0xA
    0331B DFB8      RCALL	_Usart_Transmit
    0331C C004      RJMP	0x3321
(0068) 	while(*str!=0)	Usart_Transmit(*str++);
    0331D 01F5      MOVW	R30,R10
    0331E 9101      LD	R16,Z+
    0331F 015F      MOVW	R10,R30
    03320 DFB3      RCALL	_Usart_Transmit
    03321 01F5      MOVW	R30,R10
    03322 8020      LD	R2,Z
    03323 2022      TST	R2
    03324 F7C1      BNE	0x331D
    03325 90B9      LD	R11,Y+
    03326 90A9      LD	R10,Y+
    03327 9508      RET
_PrintLong:
  i                    --> R20
  da                   --> Y,+0
  data                 --> Y,+9
    03328 940E 3B30 CALL	push_arg4
    0332A 934A      ST	-Y,R20
    0332B 9728      SBIW	R28,0x8
(0069) 
(0070) } 
(0071)  
(0072) void PrintLong(unsigned long data)
(0073) {
(0074)  
(0075) 	unsigned char da[8];
(0076) 	unsigned char i;
(0077) 	for(i=0;i<8;i++)	da[i]=0;
    0332C 2744      CLR	R20
    0332D C008      RJMP	0x3336
    0332E 01CE      MOVW	R24,R28
    0332F 2FE4      MOV	R30,R20
    03330 27FF      CLR	R31
    03331 0FE8      ADD	R30,R24
    03332 1FF9      ADC	R31,R25
    03333 2422      CLR	R2
    03334 8220      ST	Z,R2
    03335 9543      INC	R20
    03336 3048      CPI	R20,0x8
    03337 F3B0      BCS	0x332E
    03338 C013      RJMP	0x334C
(0078) 	while(data>=10000000L){ ++da[7];data-=10000000L;}
    03339 818F      LDD	R24,Y+7
    0333A 5F8F      SUBI	R24,0xFF
    0333B 838F      STD	Y+7,R24
    0333C E880      LDI	R24,0x80
    0333D E996      LDI	R25,0x96
    0333E E9A8      LDI	R26,0x98
    0333F E0B0      LDI	R27,0
    03340 8429      LDD	R2,Y+9
    03341 843A      LDD	R3,Y+10
    03342 844B      LDD	R4,Y+11
    03343 845C      LDD	R5,Y+12
    03344 1A28      SUB	R2,R24
    03345 0A39      SBC	R3,R25
    03346 0A4A      SBC	R4,R26
    03347 0A5B      SBC	R5,R27
    03348 8629      STD	Y+9,R2
    03349 863A      STD	Y+10,R3
    0334A 864B      STD	Y+11,R4
    0334B 865C      STD	Y+12,R5
    0334C E880      LDI	R24,0x80
    0334D E996      LDI	R25,0x96
    0334E E9A8      LDI	R26,0x98
    0334F E0B0      LDI	R27,0
    03350 8429      LDD	R2,Y+9
    03351 843A      LDD	R3,Y+10
    03352 844B      LDD	R4,Y+11
    03353 845C      LDD	R5,Y+12
    03354 1628      CP	R2,R24
    03355 0639      CPC	R3,R25
    03356 064A      CPC	R4,R26
    03357 065B      CPC	R5,R27
    03358 F700      BCC	0x3339
(0079) 	if(da[7])	i=0;
    03359 802F      LDD	R2,Y+7
    0335A 2022      TST	R2
    0335B F009      BEQ	0x335D
    0335C 2744      CLR	R20
(0080) 	if(i==0)	Usart_Transmit('0'+da[7]);
    0335D 2344      TST	R20
    0335E F4B9      BNE	0x3376
    0335F 810F      LDD	R16,Y+7
    03360 5D00      SUBI	R16,0xD0
    03361 DF72      RCALL	_Usart_Transmit
    03362 C013      RJMP	0x3376
(0081) 	while(data>=1000000L) { ++da[6];data-=1000000L;}
    03363 818E      LDD	R24,Y+6
    03364 5F8F      SUBI	R24,0xFF
    03365 838E      STD	Y+6,R24
    03366 E480      LDI	R24,0x40
    03367 E492      LDI	R25,0x42
    03368 E0AF      LDI	R26,0xF
    03369 E0B0      LDI	R27,0
    0336A 8429      LDD	R2,Y+9
    0336B 843A      LDD	R3,Y+10
    0336C 844B      LDD	R4,Y+11
    0336D 845C      LDD	R5,Y+12
    0336E 1A28      SUB	R2,R24
    0336F 0A39      SBC	R3,R25
    03370 0A4A      SBC	R4,R26
    03371 0A5B      SBC	R5,R27
    03372 8629      STD	Y+9,R2
    03373 863A      STD	Y+10,R3
    03374 864B      STD	Y+11,R4
    03375 865C      STD	Y+12,R5
    03376 E480      LDI	R24,0x40
    03377 E492      LDI	R25,0x42
    03378 E0AF      LDI	R26,0xF
    03379 E0B0      LDI	R27,0
    0337A 8429      LDD	R2,Y+9
    0337B 843A      LDD	R3,Y+10
    0337C 844B      LDD	R4,Y+11
    0337D 845C      LDD	R5,Y+12
    0337E 1628      CP	R2,R24
    0337F 0639      CPC	R3,R25
    03380 064A      CPC	R4,R26
    03381 065B      CPC	R5,R27
    03382 F700      BCC	0x3363
(0082) 	if(da[6])	i=0;
    03383 802E      LDD	R2,Y+6
    03384 2022      TST	R2
    03385 F009      BEQ	0x3387
    03386 2744      CLR	R20
(0083) 	if(i==0)	Usart_Transmit('0'+da[6]);
    03387 2344      TST	R20
    03388 F4B9      BNE	0x33A0
    03389 810E      LDD	R16,Y+6
    0338A 5D00      SUBI	R16,0xD0
    0338B DF48      RCALL	_Usart_Transmit
    0338C C013      RJMP	0x33A0
(0084) 	while(data>=100000L)  { ++da[5];data-=100000L;}
    0338D 818D      LDD	R24,Y+5
    0338E 5F8F      SUBI	R24,0xFF
    0338F 838D      STD	Y+5,R24
    03390 EA80      LDI	R24,0xA0
    03391 E896      LDI	R25,0x86
    03392 E0A1      LDI	R26,1
    03393 E0B0      LDI	R27,0
    03394 8429      LDD	R2,Y+9
    03395 843A      LDD	R3,Y+10
    03396 844B      LDD	R4,Y+11
    03397 845C      LDD	R5,Y+12
    03398 1A28      SUB	R2,R24
    03399 0A39      SBC	R3,R25
    0339A 0A4A      SBC	R4,R26
    0339B 0A5B      SBC	R5,R27
    0339C 8629      STD	Y+9,R2
    0339D 863A      STD	Y+10,R3
    0339E 864B      STD	Y+11,R4
    0339F 865C      STD	Y+12,R5
    033A0 EA80      LDI	R24,0xA0
    033A1 E896      LDI	R25,0x86
    033A2 E0A1      LDI	R26,1
    033A3 E0B0      LDI	R27,0
    033A4 8429      LDD	R2,Y+9
    033A5 843A      LDD	R3,Y+10
    033A6 844B      LDD	R4,Y+11
    033A7 845C      LDD	R5,Y+12
    033A8 1628      CP	R2,R24
    033A9 0639      CPC	R3,R25
    033AA 064A      CPC	R4,R26
    033AB 065B      CPC	R5,R27
    033AC F700      BCC	0x338D
(0085) 	if(da[5])	i=0;
    033AD 802D      LDD	R2,Y+5
    033AE 2022      TST	R2
    033AF F009      BEQ	0x33B1
    033B0 2744      CLR	R20
(0086) 	if(i==0)	Usart_Transmit('0'+da[5]);
    033B1 2344      TST	R20
    033B2 F4B9      BNE	0x33CA
    033B3 810D      LDD	R16,Y+5
    033B4 5D00      SUBI	R16,0xD0
    033B5 DF1E      RCALL	_Usart_Transmit
    033B6 C013      RJMP	0x33CA
(0087) 	while(data>=10000L)   { ++da[4];data-=10000L;}
    033B7 818C      LDD	R24,Y+4
    033B8 5F8F      SUBI	R24,0xFF
    033B9 838C      STD	Y+4,R24
    033BA E180      LDI	R24,0x10
    033BB E297      LDI	R25,0x27
    033BC E0A0      LDI	R26,0
    033BD E0B0      LDI	R27,0
    033BE 8429      LDD	R2,Y+9
    033BF 843A      LDD	R3,Y+10
    033C0 844B      LDD	R4,Y+11
    033C1 845C      LDD	R5,Y+12
    033C2 1A28      SUB	R2,R24
    033C3 0A39      SBC	R3,R25
    033C4 0A4A      SBC	R4,R26
    033C5 0A5B      SBC	R5,R27
    033C6 8629      STD	Y+9,R2
    033C7 863A      STD	Y+10,R3
    033C8 864B      STD	Y+11,R4
    033C9 865C      STD	Y+12,R5
    033CA E180      LDI	R24,0x10
    033CB E297      LDI	R25,0x27
    033CC E0A0      LDI	R26,0
    033CD E0B0      LDI	R27,0
    033CE 8429      LDD	R2,Y+9
    033CF 843A      LDD	R3,Y+10
    033D0 844B      LDD	R4,Y+11
    033D1 845C      LDD	R5,Y+12
    033D2 1628      CP	R2,R24
    033D3 0639      CPC	R3,R25
    033D4 064A      CPC	R4,R26
    033D5 065B      CPC	R5,R27
    033D6 F700      BCC	0x33B7
(0088) 	if(da[4])	i=0;
    033D7 802C      LDD	R2,Y+4
    033D8 2022      TST	R2
    033D9 F009      BEQ	0x33DB
    033DA 2744      CLR	R20
(0089) 	if(i==0)	Usart_Transmit('0'+da[4]);
    033DB 2344      TST	R20
    033DC F4B9      BNE	0x33F4
    033DD 810C      LDD	R16,Y+4
    033DE 5D00      SUBI	R16,0xD0
    033DF DEF4      RCALL	_Usart_Transmit
    033E0 C013      RJMP	0x33F4
(0090) 	while(data>=1000L)    { ++da[3];data-=1000L;}
    033E1 818B      LDD	R24,Y+3
    033E2 5F8F      SUBI	R24,0xFF
    033E3 838B      STD	Y+3,R24
    033E4 EE88      LDI	R24,0xE8
    033E5 E093      LDI	R25,3
    033E6 E0A0      LDI	R26,0
    033E7 E0B0      LDI	R27,0
    033E8 8429      LDD	R2,Y+9
    033E9 843A      LDD	R3,Y+10
    033EA 844B      LDD	R4,Y+11
    033EB 845C      LDD	R5,Y+12
    033EC 1A28      SUB	R2,R24
    033ED 0A39      SBC	R3,R25
    033EE 0A4A      SBC	R4,R26
    033EF 0A5B      SBC	R5,R27
    033F0 8629      STD	Y+9,R2
    033F1 863A      STD	Y+10,R3
    033F2 864B      STD	Y+11,R4
    033F3 865C      STD	Y+12,R5
    033F4 EE88      LDI	R24,0xE8
    033F5 E093      LDI	R25,3
    033F6 E0A0      LDI	R26,0
    033F7 E0B0      LDI	R27,0
    033F8 8429      LDD	R2,Y+9
    033F9 843A      LDD	R3,Y+10
    033FA 844B      LDD	R4,Y+11
    033FB 845C      LDD	R5,Y+12
    033FC 1628      CP	R2,R24
    033FD 0639      CPC	R3,R25
    033FE 064A      CPC	R4,R26
    033FF 065B      CPC	R5,R27
    03400 F700      BCC	0x33E1
(0091) 	if(da[3])	i=0;
    03401 802B      LDD	R2,Y+3
    03402 2022      TST	R2
    03403 F009      BEQ	0x3405
    03404 2744      CLR	R20
(0092) 	if(i==0)	Usart_Transmit('0'+da[3]);
    03405 2344      TST	R20
    03406 F4B9      BNE	0x341E
    03407 810B      LDD	R16,Y+3
    03408 5D00      SUBI	R16,0xD0
    03409 DECA      RCALL	_Usart_Transmit
    0340A C013      RJMP	0x341E
(0093) 	while(data>=100L)     { ++da[2];data-=100L;}
    0340B 818A      LDD	R24,Y+2
    0340C 5F8F      SUBI	R24,0xFF
    0340D 838A      STD	Y+2,R24
    0340E E684      LDI	R24,0x64
    0340F E090      LDI	R25,0
    03410 E0A0      LDI	R26,0
    03411 E0B0      LDI	R27,0
    03412 8429      LDD	R2,Y+9
    03413 843A      LDD	R3,Y+10
    03414 844B      LDD	R4,Y+11
    03415 845C      LDD	R5,Y+12
    03416 1A28      SUB	R2,R24
    03417 0A39      SBC	R3,R25
    03418 0A4A      SBC	R4,R26
    03419 0A5B      SBC	R5,R27
    0341A 8629      STD	Y+9,R2
    0341B 863A      STD	Y+10,R3
    0341C 864B      STD	Y+11,R4
    0341D 865C      STD	Y+12,R5
    0341E E684      LDI	R24,0x64
    0341F E090      LDI	R25,0
    03420 E0A0      LDI	R26,0
    03421 E0B0      LDI	R27,0
    03422 8429      LDD	R2,Y+9
    03423 843A      LDD	R3,Y+10
    03424 844B      LDD	R4,Y+11
    03425 845C      LDD	R5,Y+12
    03426 1628      CP	R2,R24
    03427 0639      CPC	R3,R25
    03428 064A      CPC	R4,R26
    03429 065B      CPC	R5,R27
    0342A F700      BCC	0x340B
(0094) 	if(da[2])	i=0;
    0342B 802A      LDD	R2,Y+2
    0342C 2022      TST	R2
    0342D F009      BEQ	0x342F
    0342E 2744      CLR	R20
(0095) 	if(i==0)	Usart_Transmit('0'+da[2]);
    0342F 2344      TST	R20
    03430 F4B9      BNE	0x3448
    03431 810A      LDD	R16,Y+2
    03432 5D00      SUBI	R16,0xD0
    03433 DEA0      RCALL	_Usart_Transmit
    03434 C013      RJMP	0x3448
(0096) 	while(data>=10L)      { ++da[1];data-=10L;}
    03435 8189      LDD	R24,Y+1
    03436 5F8F      SUBI	R24,0xFF
    03437 8389      STD	Y+1,R24
    03438 E08A      LDI	R24,0xA
    03439 E090      LDI	R25,0
    0343A E0A0      LDI	R26,0
    0343B E0B0      LDI	R27,0
    0343C 8429      LDD	R2,Y+9
    0343D 843A      LDD	R3,Y+10
    0343E 844B      LDD	R4,Y+11
    0343F 845C      LDD	R5,Y+12
    03440 1A28      SUB	R2,R24
    03441 0A39      SBC	R3,R25
    03442 0A4A      SBC	R4,R26
    03443 0A5B      SBC	R5,R27
    03444 8629      STD	Y+9,R2
    03445 863A      STD	Y+10,R3
    03446 864B      STD	Y+11,R4
    03447 865C      STD	Y+12,R5
    03448 E08A      LDI	R24,0xA
    03449 E090      LDI	R25,0
    0344A E0A0      LDI	R26,0
    0344B E0B0      LDI	R27,0
    0344C 8429      LDD	R2,Y+9
    0344D 843A      LDD	R3,Y+10
    0344E 844B      LDD	R4,Y+11
    0344F 845C      LDD	R5,Y+12
    03450 1628      CP	R2,R24
    03451 0639      CPC	R3,R25
    03452 064A      CPC	R4,R26
    03453 065B      CPC	R5,R27
    03454 F700      BCC	0x3435
(0097) 	if(da[1])	i=0;
    03455 8029      LDD	R2,Y+1
    03456 2022      TST	R2
    03457 F009      BEQ	0x3459
    03458 2744      CLR	R20
(0098) 	if(i==0)	Usart_Transmit('0'+da[1]);
    03459 2344      TST	R20
    0345A F419      BNE	0x345E
    0345B 8109      LDD	R16,Y+1
    0345C 5D00      SUBI	R16,0xD0
    0345D DE76      RCALL	_Usart_Transmit
(0099) 	Usart_Transmit('0'+data);
    0345E E380      LDI	R24,0x30
    0345F E090      LDI	R25,0
    03460 E0A0      LDI	R26,0
    03461 E0B0      LDI	R27,0
    03462 8429      LDD	R2,Y+9
    03463 843A      LDD	R3,Y+10
    03464 844B      LDD	R4,Y+11
    03465 845C      LDD	R5,Y+12
    03466 0E28      ADD	R2,R24
    03467 1E39      ADC	R3,R25
    03468 1E4A      ADC	R4,R26
    03469 1E5B      ADC	R5,R27
    0346A 2D02      MOV	R16,R2
    0346B DE68      RCALL	_Usart_Transmit
    0346C 9628      ADIW	R28,0x8
    0346D 9149      LD	R20,Y+
    0346E 9624      ADIW	R28,4
    0346F 9508      RET
_PrintChar:
  h                    --> R20
  d                    --> R22
    03470 934A      ST	-Y,R20
    03471 936A      ST	-Y,R22
    03472 2F60      MOV	R22,R16
(0100)  
(0101) }
(0102)  
(0103) void PrintChar(unsigned char d)
(0104) {
(0105) 	unsigned char h=(d&0xF0)>>4;
    03473 2F46      MOV	R20,R22
    03474 7F40      ANDI	R20,0xF0
    03475 9542      SWAP	R20
    03476 704F      ANDI	R20,0xF
(0106) 	if(h<10)	Usart_Transmit('0'+h);
    03477 304A      CPI	R20,0xA
    03478 F420      BCC	0x347D
    03479 2F04      MOV	R16,R20
    0347A 5D00      SUBI	R16,0xD0
    0347B DE58      RCALL	_Usart_Transmit
    0347C C003      RJMP	0x3480
(0107) 	else		Usart_Transmit('A'-10+h);
    0347D 2F04      MOV	R16,R20
    0347E 5C09      SUBI	R16,0xC9
    0347F DE54      RCALL	_Usart_Transmit
(0108) 	h=d&0x0f;
    03480 2F46      MOV	R20,R22
    03481 704F      ANDI	R20,0xF
(0109) 	if(h<10)	Usart_Transmit('0'+h);
    03482 304A      CPI	R20,0xA
    03483 F420      BCC	0x3488
    03484 2F04      MOV	R16,R20
    03485 5D00      SUBI	R16,0xD0
    03486 DE4D      RCALL	_Usart_Transmit
    03487 C003      RJMP	0x348B
(0110) 	else		Usart_Transmit('A'-10+h);
    03488 2F04      MOV	R16,R20
    03489 5C09      SUBI	R16,0xC9
    0348A DE49      RCALL	_Usart_Transmit
(0111) 	Usart_Transmit(' ');
    0348B E200      LDI	R16,0x20
    0348C DE47      RCALL	_Usart_Transmit
    0348D 9169      LD	R22,Y+
    0348E 9149      LD	R20,Y+
    0348F 9508      RET
FILE: D:\LQD\software\master\software_src\SPI.c
(0001) //*****************************************************************************//
(0002) //*								 
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SPI接口控制
(0006) //*****************************************************************************//
(0007) #include "SPI.h"
(0008) 
(0009) /******************************************************************
(0010) SPI接口函数初始化
(0011) ******************************************************************/
(0012) void SPI_IO_Init(void)
(0013) {
(0014) 	SPI_PORT |= (1<<SS);////拉高CS
_SPI_IO_Init:
    03490 9AC0      SBI	0x18,0
(0015) 	SPI_DDR |= (1<<SCLK)|(1<<MOSI)|(1<<SS);////CS,CLK,MOSI设为输出
    03491 B387      IN	R24,0x17
    03492 6087      ORI	R24,7
    03493 BB87      OUT	0x17,R24
(0016) 	SPI_DDR &=~(1<<MISO);//MISO设为输入
    03494 98BB      CBI	0x17,3
(0017) 	SPI_PORT |= (1<<SCLK);//拉高CLK
    03495 9AC1      SBI	0x18,1
(0018) 	SPI_High();//SPI高通
    03496 E580      LDI	R24,0x50
    03497 B98D      OUT	0x0D,R24
    03498 9A70      SBI	0x0E,0
    03499 9508      RET
(0019) }
(0020) /******************************************************************
(0021) SPI写一个字节
(0022) ******************************************************************/
(0023) void SPI_Write(UINT8 data)
(0024) {
(0025) 	SPDR = data;
_SPI_Write:
  data                 --> R16
    0349A B90F      OUT	0x0F,R16
(0026) 	while ((SPSR&(1<<SPIF))==0);
    0349B 9B77      SBIS	0x0E,7
    0349C CFFE      RJMP	0x349B
    0349D 9508      RET
(0027) 	//loop_until_bit_is_set(SPSR,SPIF);
(0028) }
(0029) /******************************************************************
(0030) SPI读一个字节
(0031) ******************************************************************/
(0032) unsigned char SPI_Read(void)
(0033) {
(0034) 	SPDR = 0xFF;//写0xFF启动SPI
_SPI_Read:
    0349E EF8F      LDI	R24,0xFF
    0349F B98F      OUT	0x0F,R24
(0035) 	while ((SPSR&(1<<SPIF))==0);
    034A0 9B77      SBIS	0x0E,7
    034A1 CFFE      RJMP	0x34A0
(0036) 	//loop_until_bit_is_set(SPSR,SPIF);//等待SPIF为高电平
(0037) 	return  SPDR;//返回读取值
    034A2 B10F      IN	R16,0x0F
    034A3 9508      RET
FILE: D:\LQD\software\master\software_src\lcd.c
(0001) #include "config.h"
(0002) 
(0003) //此硬件引脚适合冷强度检测仪第2版电路  mega128
(0004) #define LCD_PIN_CS   4
(0005) #define LCD_PIN_SID  3
(0006) #define LCD_PIN_SCLK 2
(0007) #define LCD_PIN_RST  1
(0008) #define LCD_BACKLIGHT_SW		0
(0009) #define LCD_PORT PORTC
(0010) #define LCD_PIN_DDR DDRC
(0011) #define Set_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT |= (1<<LCD_PIN_CS) 
(0012) #define Set_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT |= (1<<LCD_PIN_SID) 
(0013) #define Set_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT |= (1<<LCD_PIN_SCLK) 
(0014) #define LCD_LIGHT_ON()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT |= (1<<LCD_BACKLIGHT_SW) 
(0015) #define Set_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT |= (1<<LCD_PIN_RST) 
(0016) 
(0017) #define Clr_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT &=~(1<<LCD_PIN_CS) 
(0018) #define Clr_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT &=~(1<<LCD_PIN_SID) 
(0019) #define Clr_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT &=~(1<<LCD_PIN_SCLK) 
(0020) #define LCD_LIGHT_OFF()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT &=~(1<<LCD_BACKLIGHT_SW) 
(0021) #define Clr_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT &=~(1<<LCD_PIN_RST) 
(0022)  
(0023) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data); 
(0024) void Write_8bits(unsigned int W_bits); 
(0025) void LCD_Init(void); 
(0026) unsigned char LCD_INT(void); 
(0027) 
(0028) unsigned char LCD_SW(unsigned char i)
(0029) {
(0030)  if(i==0){
_LCD_SW:
  i                    --> R16
    034A4 2300      TST	R16
    034A5 F421      BNE	0x34AA
(0031)  LCD_LIGHT_OFF();
    034A6 9AA0      SBI	0x14,0
    034A7 98A8      CBI	0x15,0
(0032)  return 0;
    034A8 2700      CLR	R16
    034A9 C003      RJMP	0x34AD
(0033)  }
(0034)  else{
(0035)  LCD_LIGHT_ON();
    034AA 9AA0      SBI	0x14,0
    034AB 9AA8      SBI	0x15,0
(0036)  return 1;
    034AC E001      LDI	R16,1
    034AD 9508      RET
(0037)  }
(0038)  
(0039) }
(0040)  
(0041) unsigned char LCD_INT(void) 
(0042) { 
(0043)   Clr_CS(); 
_LCD_INT:
    034AE 9AA4      SBI	0x14,4
    034AF 98AC      CBI	0x15,4
(0044)   Clr_SID(); 
    034B0 9AA3      SBI	0x14,3
    034B1 98AB      CBI	0x15,3
(0045)   Clr_SCLK(); 
    034B2 9AA2      SBI	0x14,2
    034B3 98AA      CBI	0x15,2
(0046)   LCD_Init(); 
    034B4 D097      RCALL	_LCD_Init
(0047)   return (0);
    034B5 2700      CLR	R16
    034B6 9508      RET
_address:
  a                    --> R20
  y                    --> R18
  x                    --> R16
    034B7 940E 3C8A CALL	push_xgsetF000
(0048) } 
(0049)   
(0050) /******************************************************************** 
(0051) 函数 名：address
(0052) 入口参数：地址转换
(0053) 出口参数：无 
(0054) 函数作用： 
(0055) 说        明： 
(0056) ********************************************************************/ 
(0057) unsigned char address(unsigned char x,unsigned char y)
(0058) {  
(0059)  unsigned char a;
(0060) 
(0061) switch(x) 
    034B9 2F60      MOV	R22,R16
    034BA 2777      CLR	R23
    034BB 3061      CPI	R22,1
    034BC E0E0      LDI	R30,0
    034BD 077E      CPC	R23,R30
    034BE F069      BEQ	0x34CC
    034BF 3062      CPI	R22,2
    034C0 E0E0      LDI	R30,0
    034C1 077E      CPC	R23,R30
    034C2 F059      BEQ	0x34CE
    034C3 3063      CPI	R22,3
    034C4 E0E0      LDI	R30,0
    034C5 077E      CPC	R23,R30
    034C6 F049      BEQ	0x34D0
    034C7 3064      CPI	R22,4
    034C8 E0E0      LDI	R30,0
    034C9 077E      CPC	R23,R30
    034CA F039      BEQ	0x34D2
    034CB C007      RJMP	0x34D3
(0062) { 
(0063) case 1: 
(0064) {a=0x80;break;} 
    034CC E840      LDI	R20,0x80
    034CD C005      RJMP	0x34D3
(0065) case 2: 
(0066) {a=0x90;break;} 
    034CE E940      LDI	R20,0x90
    034CF C003      RJMP	0x34D3
(0067)   case 3: 
(0068) {a=0x88;break;} 
    034D0 E848      LDI	R20,0x88
    034D1 C001      RJMP	0x34D3
(0069)   case 4: 
(0070) {a=0x98;break;} 
    034D2 E948      LDI	R20,0x98
(0071) } 
(0072) a=a+y-1;
    034D3 0F42      ADD	R20,R18
    034D4 5041      SUBI	R20,1
(0073) 
(0074) return a;
    034D5 2F04      MOV	R16,R20
    034D6 940C 3C8F JMP	pop_xgsetF000
_LCD_const_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    034D8 940E 3C77 CALL	push_xgset30FC
    034DA 2EE2      MOV	R14,R18
    034DB 2EC0      MOV	R12,R16
    034DC 9721      SBIW	R28,1
    034DD 84A9      LDD	R10,Y+9
    034DE 84BA      LDD	R11,Y+10
(0075) }
(0076)  
(0077) //////////////////////////////////////////////////////////////
(0078) 
(0079) /******************************************************************** 
(0080) 函数 名：LCD_const_disp
(0081) 入口参数：x y  *single_data
(0082) 出口参数：无 
(0083) 函数作用：负责 显示一串常量
(0084) 说        明： 
(0085) ********************************************************************/ 
(0086) void LCD_const_disp(unsigned char x, unsigned char y, const unsigned char *single_data) 
(0087) { 
(0088) unsigned char  a,i; 
(0089) a=address(x,y);
    034DF 2D2E      MOV	R18,R14
    034E0 2D0C      MOV	R16,R12
    034E1 DFD5      RCALL	_address
    034E2 2EC0      MOV	R12,R16
(0090) W_1byte(0,0,a);     //显示的地址 
    034E3 82C8      ST	Y,R12
    034E4 2722      CLR	R18
    034E5 2700      CLR	R16
    034E6 D0B7      RCALL	_W_1byte
(0091)    for(i=0; single_data[i]!='\0';i++) 
    034E7 2744      CLR	R20
    034E8 C00D      RJMP	0x34F6
(0092)    {
(0093)     if(i>=16) break; 
    034E9 3140      CPI	R20,0x10
    034EA F008      BCS	0x34EC
    034EB C011      RJMP	0x34FD
(0094)     W_1byte(0,1,single_data[i]); 
    034EC 2FE4      MOV	R30,R20
    034ED 27FF      CLR	R31
    034EE 0DEA      ADD	R30,R10
    034EF 1DFB      ADC	R31,R11
    034F0 8020      LD	R2,Z
    034F1 8228      ST	Y,R2
    034F2 E021      LDI	R18,1
    034F3 2700      CLR	R16
    034F4 D0A9      RCALL	_W_1byte
    034F5 9543      INC	R20
    034F6 2FE4      MOV	R30,R20
    034F7 27FF      CLR	R31
    034F8 0DEA      ADD	R30,R10
    034F9 1DFB      ADC	R31,R11
    034FA 8020      LD	R2,Z
    034FB 2022      TST	R2
    034FC F761      BNE	0x34E9
(0095)     
(0096)    } 
(0097)    W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    034FD EF8F      LDI	R24,0xFF
    034FE 8388      ST	Y,R24
    034FF 2722      CLR	R18
    03500 2700      CLR	R16
    03501 D09C      RCALL	_W_1byte
    03502 9621      ADIW	R28,1
    03503 940C 3C61 JMP	pop_xgset30FC
_LCD_var_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    03505 940E 3C77 CALL	push_xgset30FC
    03507 2EE2      MOV	R14,R18
    03508 2EC0      MOV	R12,R16
    03509 9721      SBIW	R28,1
    0350A 84A9      LDD	R10,Y+9
    0350B 84BA      LDD	R11,Y+10
(0098)  
(0099) } 
(0100) 
(0101) /******************************************************************** 
(0102) 函数 名：LCD_var_disp
(0103) 入口参数：single_row single_line  *single_data
(0104) 出口参数：无 
(0105) 函数作用：负责 显示一串变量
(0106) 说        明： 
(0107) ********************************************************************/ 
(0108) 
(0109) void LCD_var_disp(unsigned char x, unsigned char y, unsigned char *single_data) 
(0110) { 
(0111) unsigned char  a,i; 
(0112) 
(0113) #if _debug == 1 
(0114) 	PrintString_n(single_data);
(0115) #endif 
(0116) 
(0117) a=address( x,y);
    0350C 2D2E      MOV	R18,R14
    0350D 2D0C      MOV	R16,R12
    0350E DFA8      RCALL	_address
    0350F 2EC0      MOV	R12,R16
(0118) W_1byte(0,0,a);     //显示的地址0x88 
    03510 82C8      ST	Y,R12
    03511 2722      CLR	R18
    03512 2700      CLR	R16
    03513 D08A      RCALL	_W_1byte
(0119) 
(0120) for(i=0; single_data[i]!='\0';i++) 
    03514 2744      CLR	R20
    03515 C00D      RJMP	0x3523
(0121)    { 
(0122)     if(i>=16) break;
    03516 3140      CPI	R20,0x10
    03517 F008      BCS	0x3519
    03518 C011      RJMP	0x352A
(0123)     W_1byte(0,1,single_data[i]); 
    03519 2FE4      MOV	R30,R20
    0351A 27FF      CLR	R31
    0351B 0DEA      ADD	R30,R10
    0351C 1DFB      ADC	R31,R11
    0351D 8020      LD	R2,Z
    0351E 8228      ST	Y,R2
    0351F E021      LDI	R18,1
    03520 2700      CLR	R16
    03521 D07C      RCALL	_W_1byte
    03522 9543      INC	R20
    03523 2FE4      MOV	R30,R20
    03524 27FF      CLR	R31
    03525 0DEA      ADD	R30,R10
    03526 1DFB      ADC	R31,R11
    03527 8020      LD	R2,Z
    03528 2022      TST	R2
    03529 F761      BNE	0x3516
(0124) 	} 
(0125)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    0352A EF8F      LDI	R24,0xFF
    0352B 8388      ST	Y,R24
    0352C 2722      CLR	R18
    0352D 2700      CLR	R16
    0352E D06F      RCALL	_W_1byte
    0352F 9621      ADIW	R28,1
    03530 940C 3C61 JMP	pop_xgset30FC
_LCD_char_disp:
  a                    --> R12
  data                 --> R10
  y                    --> R14
  x                    --> R12
    03532 940E 3C79 CALL	push_xgset00FC
    03534 2EE2      MOV	R14,R18
    03535 2EC0      MOV	R12,R16
    03536 9721      SBIW	R28,1
    03537 80AF      LDD	R10,Y+7
(0126) } 
(0127) /******************************************************************** 
(0128) 函数 名：LCD_char_disp
(0129) 入口参数：single_row single_line  data
(0130) 出口参数：无 
(0131) 函数作用：负责 显示一个 变量
(0132) 说        明： 
(0133) ********************************************************************/ 
(0134) 
(0135) void LCD_char_disp(unsigned char x, unsigned char y, unsigned char data) 
(0136) { 
(0137) unsigned char a; 
(0138) a=address(x,y);
    03538 2D2E      MOV	R18,R14
    03539 2D0C      MOV	R16,R12
    0353A DF7C      RCALL	_address
    0353B 2EC0      MOV	R12,R16
(0139) W_1byte(0,0,a);     //显示的地址 
    0353C 82C8      ST	Y,R12
    0353D 2722      CLR	R18
    0353E 2700      CLR	R16
    0353F D05E      RCALL	_W_1byte
(0140) W_1byte(0,1,data);  //显示内容
    03540 82A8      ST	Y,R10
    03541 E021      LDI	R18,1
    03542 2700      CLR	R16
    03543 D05A      RCALL	_W_1byte
(0141)  
(0142)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03544 EF8F      LDI	R24,0xFF
    03545 8388      ST	Y,R24
    03546 2722      CLR	R18
    03547 2700      CLR	R16
    03548 D055      RCALL	_W_1byte
    03549 9621      ADIW	R28,1
    0354A 940C 3C5A JMP	pop_xgset00FC
_LCD_Init:
  cmd                  --> R20
    0354C 934A      ST	-Y,R20
    0354D 9721      SBIW	R28,1
(0143) } 
(0144) 
(0145) /******************************************************************** 
(0146) 函数 名：LCD_Init
(0147) 入口参数：无
(0148) 出口参数：unsigned char  0/1
(0149) 函数作用：负责 清空液晶显示
(0150) 说        明： 
(0151) ********************************************************************/ 
(0152) void LCD_Init(void) 
(0153) { 
(0154)    unsigned char cmd; 
(0155)    cmd=0x30;      //功能设置 8 位数据，基本指令 
    0354E E340      LDI	R20,0x30
(0156)   W_1byte(0,0,cmd); 
    0354F 8348      ST	Y,R20
    03550 2722      CLR	R18
    03551 2700      CLR	R16
    03552 D04B      RCALL	_W_1byte
(0157)   delayms(2); 
    03553 E002      LDI	R16,2
    03554 E010      LDI	R17,0
    03555 940E 23F0 CALL	_delayms
(0158)   cmd=0x0C;      //显示状态 ON，游标OFF，反白OFF 
    03557 E04C      LDI	R20,0xC
(0159)   W_1byte(0,0,cmd); //写指令 
    03558 8348      ST	Y,R20
    03559 2722      CLR	R18
    0355A 2700      CLR	R16
    0355B D042      RCALL	_W_1byte
(0160)   delayms(2); 
    0355C E002      LDI	R16,2
    0355D E010      LDI	R17,0
    0355E 940E 23F0 CALL	_delayms
(0161)   cmd=0x01;      //清除显示 
    03560 E041      LDI	R20,1
(0162)   W_1byte(0,0,cmd); //写指令 
    03561 8348      ST	Y,R20
    03562 2722      CLR	R18
    03563 2700      CLR	R16
    03564 D039      RCALL	_W_1byte
(0163)   delayms(2); 
    03565 E002      LDI	R16,2
    03566 E010      LDI	R17,0
    03567 940E 23F0 CALL	_delayms
(0164)   cmd=0x02;      //地址归位 
    03569 E042      LDI	R20,2
(0165)   W_1byte(0,0,cmd); //写指令 
    0356A 8348      ST	Y,R20
    0356B 2722      CLR	R18
    0356C 2700      CLR	R16
    0356D D030      RCALL	_W_1byte
(0166)   delayms(2); 
    0356E E002      LDI	R16,2
    0356F E010      LDI	R17,0
    03570 940E 23F0 CALL	_delayms
(0167)   cmd=0x80;      //设置DDRAM 地址 
    03572 E840      LDI	R20,0x80
(0168)   W_1byte(0,0,cmd); //写指令 
    03573 8348      ST	Y,R20
    03574 2722      CLR	R18
    03575 2700      CLR	R16
    03576 D027      RCALL	_W_1byte
(0169)   delayms(2);     //延时 
    03577 E002      LDI	R16,2
    03578 E010      LDI	R17,0
    03579 940E 23F0 CALL	_delayms
    0357B 9621      ADIW	R28,1
    0357C 9149      LD	R20,Y+
    0357D 9508      RET
_LCD_CLR:
  cmd                  --> R20
    0357E 934A      ST	-Y,R20
    0357F 9721      SBIW	R28,1
(0170) } 
(0171) 
(0172) void LCD_CLR(void)
(0173) {
(0174) unsigned char cmd;
(0175)   cmd=0x01;      //清除显示 
    03580 E041      LDI	R20,1
(0176)   W_1byte(0,0,cmd); //写指令 
    03581 8348      ST	Y,R20
    03582 2722      CLR	R18
    03583 2700      CLR	R16
    03584 D019      RCALL	_W_1byte
(0177)   delayms(1); 
    03585 E001      LDI	R16,1
    03586 E010      LDI	R17,0
    03587 940E 23F0 CALL	_delayms
(0178)   cmd=0x02;      //地址归位 
    03589 E042      LDI	R20,2
(0179)   W_1byte(0,0,cmd); //写指令 
    0358A 8348      ST	Y,R20
    0358B 2722      CLR	R18
    0358C 2700      CLR	R16
    0358D D010      RCALL	_W_1byte
(0180)   delayms(1); 
    0358E E001      LDI	R16,1
    0358F E010      LDI	R17,0
    03590 940E 23F0 CALL	_delayms
(0181)   cmd=0x80;      //设置DDRAM 地址 
    03592 E840      LDI	R20,0x80
(0182)   W_1byte(0,0,cmd); //写指令 
    03593 8348      ST	Y,R20
    03594 2722      CLR	R18
    03595 2700      CLR	R16
    03596 D007      RCALL	_W_1byte
(0183)   delayms(1);     //延时
    03597 E001      LDI	R16,1
    03598 E010      LDI	R17,0
    03599 940E 23F0 CALL	_delayms
    0359B 9621      ADIW	R28,1
    0359C 9149      LD	R20,Y+
    0359D 9508      RET
_W_1byte:
  H_data               --> R22
  S_ID                 --> R10
  L_data               --> R20
  W_data               --> R12
  RS                   --> R14
  RW                   --> R20
    0359E 940E 3C75 CALL	push_xgsetF0FC
    035A0 2EE2      MOV	R14,R18
    035A1 2F40      MOV	R20,R16
    035A2 84CA      LDD	R12,Y+10
(0184) 
(0185) }
(0186)  
(0187) /*******************************************************************
(0188) 函 数 名：W_1byte
(0189) 入口参数：RW、RS、W_data
(0190) 出口参数：无
(0191) 建立日期：2007年3月3日
(0192) 修改日期：
(0193) 函数作用：写一个字节的数据到12864液晶，包括指令和数据
(0194) 说    明：RW=1，从液晶读数据到MCU；RW=0，写一个数据到液晶；
(0195) 		 （一般RW都设为0，即只向液晶写数据，不读数据）
(0196)           RS=1，写入的是数据；RS=0，写入的是指令；
(0197) 		  一般模式：RW=0，RS=1;写数据
(0198) 		  			RW=0，RS=0;写指令
(0199) ********************************************************************/
(0200) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data)
(0201) {
(0202) 	unsigned int H_data,L_data,S_ID = 0xf8;	 //11111RWRS0
    035A3 EF88      LDI	R24,0xF8
    035A4 E090      LDI	R25,0
    035A5 015C      MOVW	R10,R24
(0203) 	if(RW == 0)
    035A6 2344      TST	R20
    035A7 F419      BNE	0x35AB
(0204) 	{
(0205) 	 	S_ID &=~ 0x04;
    035A8 7F8B      ANDI	R24,0xFB
    035A9 015C      MOVW	R10,R24
(0206) 	}
    035AA C003      RJMP	0x35AE
(0207) 	else					//if(RW==1)
(0208) 	{
(0209) 	 	S_ID |= 0X04;
    035AB 01C5      MOVW	R24,R10
    035AC 6084      ORI	R24,4
    035AD 015C      MOVW	R10,R24
(0210) 	}
(0211) 	if(RS == 0)
    035AE 20EE      TST	R14
    035AF F421      BNE	0x35B4
(0212) 	{
(0213) 	 	S_ID &=~ 0x02;
    035B0 01C5      MOVW	R24,R10
    035B1 7F8D      ANDI	R24,0xFD
    035B2 015C      MOVW	R10,R24
(0214) 	}
    035B3 C003      RJMP	0x35B7
(0215) 	else					//if(RS==1)
(0216) 	{
(0217) 	 	S_ID |= 0X02;
    035B4 01C5      MOVW	R24,R10
    035B5 6082      ORI	R24,2
    035B6 015C      MOVW	R10,R24
(0218) 	}
(0219) 	H_data = W_data;
    035B7 2D6C      MOV	R22,R12
    035B8 2777      CLR	R23
(0220) 	H_data &= 0xf0;			//屏蔽低4位的数据
    035B9 7F60      ANDI	R22,0xF0
    035BA 7070      ANDI	R23,0
(0221) 	L_data = W_data;	   	//xxxx0000格式
    035BB 2D4C      MOV	R20,R12
    035BC 2755      CLR	R21
(0222) 	L_data &= 0x0f;			//屏蔽高4位的数据
    035BD 704F      ANDI	R20,0xF
    035BE 7050      ANDI	R21,0
(0223) 	L_data <<= 4;			//xxxx0000格式
    035BF 0F44      LSL	R20
    035C0 1F55      ROL	R21
    035C1 0F44      LSL	R20
    035C2 1F55      ROL	R21
    035C3 0F44      LSL	R20
    035C4 1F55      ROL	R21
    035C5 0F44      LSL	R20
    035C6 1F55      ROL	R21
(0224) 	Set_CS();
    035C7 9AA4      SBI	0x14,4
    035C8 9AAC      SBI	0x15,4
(0225) 	Write_8bits(S_ID); 		//发送S_ID
    035C9 0185      MOVW	R16,R10
    035CA D00C      RCALL	_Write_8bits
(0226) 	Write_8bits(H_data);	//发送H_data
    035CB 018B      MOVW	R16,R22
    035CC D00A      RCALL	_Write_8bits
(0227) 	Write_8bits(L_data);	//发送L_data
    035CD 018A      MOVW	R16,R20
    035CE D008      RCALL	_Write_8bits
(0228) 	Clr_CS();	Clr_CS();	Clr_CS();	
    035CF 9AA4      SBI	0x14,4
    035D0 98AC      CBI	0x15,4
    035D1 9AA4      SBI	0x14,4
    035D2 98AC      CBI	0x15,4
    035D3 9AA4      SBI	0x14,4
    035D4 98AC      CBI	0x15,4
    035D5 940C 3C6A JMP	pop_xgsetF0FC
_Write_8bits:
  Temp_data            --> R12
  i                    --> R20
  W_bits               --> R10
    035D7 940E 3CA2 CALL	push_xgset303C
    035D9 0158      MOVW	R10,R16
(0229) 	 
(0230) 
(0231) }
(0232) /********************************************************************
(0233) 函 数 名：Write_8bits
(0234) 入口参数：W_bits
(0235) 出口参数：无
(0236) 建立日期：2007年3月3日
(0237) 修改日期：
(0238) 函数作用：负责串行输出8个bit位
(0239) 说    明：
(0240) ********************************************************************/
(0241) void Write_8bits(unsigned int W_bits)
(0242) {
(0243) 	unsigned int i,Temp_data;
(0244) 	for(i=0; i<8; i++)
    035DA 2744      CLR	R20
    035DB 2755      CLR	R21
    035DC C019      RJMP	0x35F6
(0245) 	{
(0246) 		Temp_data = W_bits;
    035DD 0165      MOVW	R12,R10
(0247) 		Temp_data <<= i;
    035DE 019A      MOVW	R18,R20
    035DF 0186      MOVW	R16,R12
    035E0 940E 3CF0 CALL	lsl16
    035E2 0168      MOVW	R12,R16
(0248) 		if((Temp_data&0x80)==0) 
    035E3 FD07      SBRC	R16,7
    035E4 C003      RJMP	0x35E8
(0249) 		{
(0250) 		 	Clr_SID();
    035E5 9AA3      SBI	0x14,3
    035E6 98AB      CBI	0x15,3
(0251) 		}
    035E7 C002      RJMP	0x35EA
(0252) 		else
(0253) 		{
(0254) 		 	Set_SID();
    035E8 9AA3      SBI	0x14,3
    035E9 9AAB      SBI	0x15,3
(0255) 		} 
(0256) 		NOP();
    035EA 0000      NOP
(0257) 		Set_SCLK();
    035EB 9AA2      SBI	0x14,2
    035EC 9AAA      SBI	0x15,2
(0258) 		NOP();
    035ED 0000      NOP
(0259) 		NOP();
    035EE 0000      NOP
(0260) 		Clr_SCLK();
    035EF 9AA2      SBI	0x14,2
    035F0 98AA      CBI	0x15,2
(0261) 		NOP();
    035F1 0000      NOP
(0262) 		Clr_SID();
    035F2 9AA3      SBI	0x14,3
    035F3 98AB      CBI	0x15,3
    035F4 5F4F      SUBI	R20,0xFF
    035F5 4F5F      SBCI	R21,0xFF
    035F6 3048      CPI	R20,0x8
    035F7 E0E0      LDI	R30,0
    035F8 075E      CPC	R21,R30
    035F9 F318      BCS	0x35DD
    035FA 940C 3CA9 JMP	pop_xgset303C
_Set_Draw:
    035FC 9721      SBIW	R28,1
(0263) 	}
(0264) }
(0265)  
(0266) /********************************************************************
(0267) 函 数 名：Set_Draw(
(0268) 入口参数：无
(0269) 出口参数：无
(0270) 函数作用：设置为绘图模式
(0271) 说    明：
(0272) ********************************************************************/
(0273) void Set_Draw(void)
(0274) {  	
(0275) 	//W_1byte(0,0,0x34);			//8BIT控制界面，扩充指令集,，绘图显示OFF
(0276) 	W_1byte(0,0,0x36);
    035FD E386      LDI	R24,0x36
    035FE 8388      ST	Y,R24
    035FF 2722      CLR	R18
    03600 2700      CLR	R16
    03601 DF9C      RCALL	_W_1byte
(0277) 	delayms(1);					//延时
    03602 E001      LDI	R16,1
    03603 E010      LDI	R17,0
    03604 940E 23F0 CALL	_delayms
    03606 9621      ADIW	R28,1
    03607 9508      RET
_Set_White:
  clr_y                --> R10
  clr_x                --> R20
  white_y              --> Y,+2
  white_x              --> Y,+1
  i                    --> R22
  white_end_x          --> R12
  j                    --> R14
  clear                --> Y,+15
  end_x                --> R12
  y                    --> R14
  x                    --> R22
    03608 940E 3C75 CALL	push_xgsetF0FC
    0360A 2EE2      MOV	R14,R18
    0360B 2F60      MOV	R22,R16
    0360C 9723      SBIW	R28,3
    0360D 84CD      LDD	R12,Y+13
(0278) } 
(0279)  
(0280) 
(0281) /******************************************************************** 
(0282) 函数 名：Set_White 
(0283) 入口参数：  x,   y,  end_x,  clear
(0284) 出口参数：无 
(0285) 函数作用： 设置反显
(0286) 说        明： 
(0287) ********************************************************************/ 
(0288) void Set_White(unsigned char x,unsigned char y,unsigned char end_x,unsigned char clear)
(0289) {
(0290)  
(0291) 	unsigned char i, j, white_x, white_y,white_end_x,clr_x,clr_y ;		//
(0292)   
(0293) 	W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    0360E E386      LDI	R24,0x36
    0360F 8388      ST	Y,R24
    03610 2722      CLR	R18
    03611 2700      CLR	R16
    03612 DF8B      RCALL	_W_1byte
(0294) 	delayus(20);					//延时
    03613 E104      LDI	R16,0x14
    03614 E010      LDI	R17,0
    03615 940E 23E8 CALL	_delayus
(0295)  
(0296) 	white_end_x = (end_x-x+1);
    03617 2D8C      MOV	R24,R12
    03618 1B86      SUB	R24,R22
    03619 5F8F      SUBI	R24,0xFF
    0361A 2EC8      MOV	R12,R24
(0297) 	white_end_x <<= 1;
    0361B 0CCC      LSL	R12
(0298) 	if(y==1)   //x,1  a=80+x-1                   
    0361C 2D8E      MOV	R24,R14
    0361D 3081      CPI	R24,1
    0361E F449      BNE	0x3628
(0299) 	{
(0300) 	 	white_x = (0x80+x-1); 
    0361F 2F86      MOV	R24,R22
    03620 5880      SUBI	R24,0x80
    03621 5081      SUBI	R24,1
    03622 8389      STD	Y+1,R24
(0301) 		white_y = 0x80;
    03623 E880      LDI	R24,0x80
    03624 838A      STD	Y+2,R24
(0302) 		clr_x = 0x80;
    03625 E840      LDI	R20,0x80
(0303) 		clr_y = 0x80;
    03626 2EA8      MOV	R10,R24
(0304) 	}
    03627 C023      RJMP	0x364B
(0305) 	else if(y==2)
    03628 2D8E      MOV	R24,R14
    03629 3082      CPI	R24,2
    0362A F449      BNE	0x3634
(0306) 	{
(0307) 	 	white_x = (0x80+x-1);
    0362B 2F86      MOV	R24,R22
    0362C 5880      SUBI	R24,0x80
    0362D 5081      SUBI	R24,1
    0362E 8389      STD	Y+1,R24
(0308) 		white_y = 0x90;
    0362F E980      LDI	R24,0x90
    03630 838A      STD	Y+2,R24
(0309) 		clr_x = 0x80;
    03631 E840      LDI	R20,0x80
(0310) 		clr_y = 0x90;
    03632 2EA8      MOV	R10,R24
(0311) 	}
    03633 C017      RJMP	0x364B
(0312) 	else if(y==3)
    03634 2D8E      MOV	R24,R14
    03635 3083      CPI	R24,3
    03636 F449      BNE	0x3640
(0313) 	{
(0314) 	 	white_x = (0x88+x-1);
    03637 2F86      MOV	R24,R22
    03638 5788      SUBI	R24,0x78
    03639 5081      SUBI	R24,1
    0363A 8389      STD	Y+1,R24
(0315) 		white_y = 0x80;
    0363B E880      LDI	R24,0x80
    0363C 838A      STD	Y+2,R24
(0316) 		clr_x = 0x88;
    0363D E848      LDI	R20,0x88
(0317) 		clr_y = 0x80;
    0363E 2EA8      MOV	R10,R24
(0318) 	}
    0363F C00B      RJMP	0x364B
(0319) 	else if(y==4)
    03640 2D8E      MOV	R24,R14
    03641 3084      CPI	R24,4
    03642 F441      BNE	0x364B
(0320) 	{
(0321) 	 	white_x = (0x88+x-1);
    03643 2F86      MOV	R24,R22
    03644 5788      SUBI	R24,0x78
    03645 5081      SUBI	R24,1
    03646 8389      STD	Y+1,R24
(0322) 		white_y = 0x90;
    03647 E980      LDI	R24,0x90
    03648 838A      STD	Y+2,R24
(0323) 		clr_x = 0x88;
    03649 E848      LDI	R20,0x88
(0324) 		clr_y = 0x90;
    0364A 2EA8      MOV	R10,R24
(0325) 	}
(0326)   if(clear==0)//要反白时，先将整行的液晶全部清成不反白（此处行指y）
    0364B 840F      LDD	R0,Y+15
    0364C 2000      TST	R0
    0364D F4E9      BNE	0x366B
(0327) 	{
(0328) 	 	for(i=0;i<16;i++ )			//16行
    0364E 2766      CLR	R22
    0364F C019      RJMP	0x3669
(0329) 		{
(0330) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03650 2C2A      MOV	R2,R10
    03651 2D82      MOV	R24,R2
    03652 5F8F      SUBI	R24,0xFF
    03653 2EA8      MOV	R10,R24
    03654 8228      ST	Y,R2
    03655 2722      CLR	R18
    03656 2700      CLR	R16
    03657 DF46      RCALL	_W_1byte
(0331) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03658 8348      ST	Y,R20
    03659 2722      CLR	R18
    0365A 2700      CLR	R16
    0365B DF42      RCALL	_W_1byte
(0332) 			for(j=0;j<16;j++)		//
    0365C 24EE      CLR	R14
    0365D C007      RJMP	0x3665
(0333) 			{
(0334) 			 	W_1byte(0,1,0x00);	//清成不反白
    0365E 2422      CLR	R2
    0365F 8228      ST	Y,R2
    03660 E021      LDI	R18,1
    03661 2700      CLR	R16
    03662 DF3B      RCALL	_W_1byte
(0335) 			 	nop();
    03663 0000      NOP
    03664 94E3      INC	R14
    03665 2D8E      MOV	R24,R14
    03666 3180      CPI	R24,0x10
    03667 F3B0      BCS	0x365E
    03668 9563      INC	R22
    03669 3160      CPI	R22,0x10
    0366A F328      BCS	0x3650
(0336) 			}
(0337) 		}
(0338) 	}
(0339) 	nop();
    0366B 0000      NOP
(0340) //	
(0341) 	for(i=0;i<16;i++ )				//16行，因为是16*16汉字
    0366C 2766      CLR	R22
    0366D C022      RJMP	0x3690
(0342) 	{
(0343) 		W_1byte(0,0,white_y++);		//设置绘图区的Y地址坐标0
    0366E 802A      LDD	R2,Y+2
    0366F 2D82      MOV	R24,R2
    03670 5F8F      SUBI	R24,0xFF
    03671 838A      STD	Y+2,R24
    03672 8228      ST	Y,R2
    03673 2722      CLR	R18
    03674 2700      CLR	R16
    03675 DF28      RCALL	_W_1byte
(0344) 		W_1byte(0,0,white_x);		//设置绘图区的X地址坐标0
    03676 8009      LDD	R0,Y+1
    03677 8208      ST	Y,R0
    03678 2722      CLR	R18
    03679 2700      CLR	R16
    0367A DF23      RCALL	_W_1byte
(0345) 		for(j=0;j<white_end_x;j++)	//
    0367B 24EE      CLR	R14
    0367C C010      RJMP	0x368D
(0346) 		{
(0347) 			 if(clear==1)
    0367D 858F      LDD	R24,Y+15
    0367E 3081      CPI	R24,1
    0367F F431      BNE	0x3686
(0348) 			 {
(0349) 			  	W_1byte(0,1,0x00); //取消这一行的8个点的反白，液晶地址自动加1
    03680 2422      CLR	R2
    03681 8228      ST	Y,R2
    03682 E021      LDI	R18,1
    03683 2700      CLR	R16
    03684 DF19      RCALL	_W_1byte
(0350) 								   //（此处行指一个一个液晶点所组成的行）
(0351) 			 }
    03685 C005      RJMP	0x368B
(0352) 			 else
(0353) 			 {
(0354) 				W_1byte(0,1,0xff); //反白这一行的8个点，液晶地址自动加1
    03686 EF8F      LDI	R24,0xFF
    03687 8388      ST	Y,R24
    03688 E021      LDI	R18,1
    03689 2700      CLR	R16
    0368A DF13      RCALL	_W_1byte
(0355) 								   //（此处行指一个一个液晶点所组成的行）
(0356) 			 }
(0357) 			nop();
    0368B 0000      NOP
    0368C 94E3      INC	R14
    0368D 14EC      CP	R14,R12
    0368E F370      BCS	0x367D
    0368F 9563      INC	R22
    03690 3160      CPI	R22,0x10
    03691 F2E0      BCS	0x366E
(0358) 		}
(0359) 	}
(0360) 	W_1byte(0,0,0x30);		//基本指令集,，绘图显示OFF
    03692 E380      LDI	R24,0x30
    03693 8388      ST	Y,R24
    03694 2722      CLR	R18
    03695 2700      CLR	R16
    03696 DF07      RCALL	_W_1byte
    03697 9623      ADIW	R28,3
    03698 940C 3C6A JMP	pop_xgsetF0FC
_set_white_n:
  tempendx             --> R10
  tempy                --> R22
  tempx                --> R20
  clear                --> R12
  n                    --> R14
    0369A 940E 3C75 CALL	push_xgsetF0FC
    0369C 2EC2      MOV	R12,R18
    0369D 2EE0      MOV	R14,R16
    0369E 9723      SBIW	R28,3
(0361)  }
(0362) 
(0363) /******************************************************************** 
(0364) 函数 名：set_white_n
(0365) 入口参数： n ,  clear
(0366) 出口参数：无 
(0367) 函数作用：   将四行分成八个位置。n代表位置1-8。本函数用于反显或取消反显
(0368)           某一位置的文字。
(0369) 说        明： 例如 set_white_n(1,0); 表示反显第一行前四个字
(0370) ********************************************************************/ 
(0371) void set_white_n(unsigned char n,unsigned char clear)
(0372) {
(0373) unsigned char tempx,tempy,tempendx;
(0374) if(n==1) {tempx=1;tempy=1;tempendx=4;}
    0369F 2D8E      MOV	R24,R14
    036A0 3081      CPI	R24,1
    036A1 F429      BNE	0x36A7
    036A2 E041      LDI	R20,1
    036A3 E061      LDI	R22,1
    036A4 E084      LDI	R24,4
    036A5 2EA8      MOV	R10,R24
    036A6 C037      RJMP	0x36DE
(0375) else if(n==2) {tempx=5;tempy=1;tempendx=8;}
    036A7 2D8E      MOV	R24,R14
    036A8 3082      CPI	R24,2
    036A9 F429      BNE	0x36AF
    036AA E045      LDI	R20,5
    036AB E061      LDI	R22,1
    036AC E088      LDI	R24,0x8
    036AD 2EA8      MOV	R10,R24
    036AE C02F      RJMP	0x36DE
(0376) else if(n==3) {tempx=1;tempy=2;tempendx=4;}
    036AF 2D8E      MOV	R24,R14
    036B0 3083      CPI	R24,3
    036B1 F429      BNE	0x36B7
    036B2 E041      LDI	R20,1
    036B3 E062      LDI	R22,2
    036B4 E084      LDI	R24,4
    036B5 2EA8      MOV	R10,R24
    036B6 C027      RJMP	0x36DE
(0377) else if(n==4) {tempx=5;tempy=2;tempendx=8;}
    036B7 2D8E      MOV	R24,R14
    036B8 3084      CPI	R24,4
    036B9 F429      BNE	0x36BF
    036BA E045      LDI	R20,5
    036BB E062      LDI	R22,2
    036BC E088      LDI	R24,0x8
    036BD 2EA8      MOV	R10,R24
    036BE C01F      RJMP	0x36DE
(0378) else if(n==5) {tempx=1;tempy=3;tempendx=4;}
    036BF 2D8E      MOV	R24,R14
    036C0 3085      CPI	R24,5
    036C1 F429      BNE	0x36C7
    036C2 E041      LDI	R20,1
    036C3 E063      LDI	R22,3
    036C4 E084      LDI	R24,4
    036C5 2EA8      MOV	R10,R24
    036C6 C017      RJMP	0x36DE
(0379) else if(n==6) {tempx=5;tempy=3;tempendx=8;}
    036C7 2D8E      MOV	R24,R14
    036C8 3086      CPI	R24,6
    036C9 F429      BNE	0x36CF
    036CA E045      LDI	R20,5
    036CB E063      LDI	R22,3
    036CC E088      LDI	R24,0x8
    036CD 2EA8      MOV	R10,R24
    036CE C00F      RJMP	0x36DE
(0380) else if(n==7) {tempx=1;tempy=4;tempendx=4;}
    036CF 2D8E      MOV	R24,R14
    036D0 3087      CPI	R24,7
    036D1 F429      BNE	0x36D7
    036D2 E041      LDI	R20,1
    036D3 E064      LDI	R22,4
    036D4 E084      LDI	R24,4
    036D5 2EA8      MOV	R10,R24
    036D6 C007      RJMP	0x36DE
(0381) else if(n==8) {tempx=5;tempy=4;tempendx=8;}
    036D7 2D8E      MOV	R24,R14
    036D8 3088      CPI	R24,0x8
    036D9 F421      BNE	0x36DE
    036DA E045      LDI	R20,5
    036DB E064      LDI	R22,4
    036DC E088      LDI	R24,0x8
    036DD 2EA8      MOV	R10,R24
(0382) Set_White(tempx,tempy,tempendx,clear);
    036DE 82CA      STD	Y+2,R12
    036DF 82A8      ST	Y,R10
    036E0 2F26      MOV	R18,R22
    036E1 2F04      MOV	R16,R20
    036E2 DF25      RCALL	_Set_White
    036E3 9623      ADIW	R28,3
    036E4 940C 3C6A JMP	pop_xgsetF0FC
_clr_white:
  clr_x                --> R10
  clr_y                --> R20
  i                    --> R22
  j                    --> R12
    036E6 940E 3C75 CALL	push_xgsetF0FC
    036E8 9721      SBIW	R28,1
(0383) 
(0384) }
(0385)  
(0386) /******************************************************************** 
(0387) 函数 名：clr_white
(0388) 入口参数： 清所有 反白
(0389) 出口参数：无 
(0390) 函数作用： 
(0391) 说        明： 
(0392) ********************************************************************/ 
(0393) void clr_white(void)
(0394) {      unsigned char i,j;
(0395) 
(0396)        unsigned char  clr_y=0x80;
    036E9 E840      LDI	R20,0x80
(0397) 	   unsigned char  clr_x=0x80;
    036EA E880      LDI	R24,0x80
    036EB 2EA8      MOV	R10,R24
(0398) 	   W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    036EC E386      LDI	R24,0x36
    036ED 8388      ST	Y,R24
    036EE 2722      CLR	R18
    036EF 2700      CLR	R16
    036F0 DEAD      RCALL	_W_1byte
(0399) 	 	for(i=0;i<16;i++ )			//16行
    036F1 2766      CLR	R22
    036F2 C017      RJMP	0x370A
(0400) 		{
(0401) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    036F3 2E24      MOV	R2,R20
    036F4 5F4F      SUBI	R20,0xFF
    036F5 8228      ST	Y,R2
    036F6 2722      CLR	R18
    036F7 2700      CLR	R16
    036F8 DEA5      RCALL	_W_1byte
(0402) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    036F9 82A8      ST	Y,R10
    036FA 2722      CLR	R18
    036FB 2700      CLR	R16
    036FC DEA1      RCALL	_W_1byte
(0403) 			for(j=0;j<16;j++)		//
    036FD 24CC      CLR	R12
    036FE C007      RJMP	0x3706
(0404) 			{
(0405) 			 	W_1byte(0,1,0x00);	//清成不反白
    036FF 2422      CLR	R2
    03700 8228      ST	Y,R2
    03701 E021      LDI	R18,1
    03702 2700      CLR	R16
    03703 DE9A      RCALL	_W_1byte
(0406) 			 	nop();
    03704 0000      NOP
    03705 94C3      INC	R12
    03706 2D8C      MOV	R24,R12
    03707 3180      CPI	R24,0x10
    03708 F3B0      BCS	0x36FF
    03709 9563      INC	R22
    0370A 3160      CPI	R22,0x10
    0370B F338      BCS	0x36F3
(0407) 			}
(0408) 		}
(0409) 	
(0410) 	    clr_y=0x80;
    0370C E840      LDI	R20,0x80
(0411) 	    clr_x=0x90;
    0370D E980      LDI	R24,0x90
    0370E 2EA8      MOV	R10,R24
(0412) 		 	for(i=0;i<16;i++ )			//16行
    0370F 2766      CLR	R22
    03710 C017      RJMP	0x3728
(0413) 		{
(0414) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03711 2E24      MOV	R2,R20
    03712 5F4F      SUBI	R20,0xFF
    03713 8228      ST	Y,R2
    03714 2722      CLR	R18
    03715 2700      CLR	R16
    03716 DE87      RCALL	_W_1byte
(0415) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03717 82A8      ST	Y,R10
    03718 2722      CLR	R18
    03719 2700      CLR	R16
    0371A DE83      RCALL	_W_1byte
(0416) 			for(j=0;j<16;j++)		//
    0371B 24CC      CLR	R12
    0371C C007      RJMP	0x3724
(0417) 			{
(0418) 			 	W_1byte(0,1,0x00);	//清成不反白
    0371D 2422      CLR	R2
    0371E 8228      ST	Y,R2
    0371F E021      LDI	R18,1
    03720 2700      CLR	R16
    03721 DE7C      RCALL	_W_1byte
(0419) 			 	nop();
    03722 0000      NOP
    03723 94C3      INC	R12
    03724 2D8C      MOV	R24,R12
    03725 3180      CPI	R24,0x10
    03726 F3B0      BCS	0x371D
    03727 9563      INC	R22
    03728 3160      CPI	R22,0x10
    03729 F338      BCS	0x3711
(0420) 			}
(0421) 		}   
(0422) 	   
(0423) 	     clr_y=0x88;
    0372A E848      LDI	R20,0x88
(0424) 	     clr_x=0x80;
    0372B E880      LDI	R24,0x80
    0372C 2EA8      MOV	R10,R24
(0425) 		 	for(i=0;i<16;i++ )			//16行
    0372D 2766      CLR	R22
    0372E C017      RJMP	0x3746
(0426) 		{
(0427) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    0372F 2EE4      MOV	R14,R20
    03730 5F4F      SUBI	R20,0xFF
    03731 82E8      ST	Y,R14
    03732 2722      CLR	R18
    03733 2700      CLR	R16
    03734 DE69      RCALL	_W_1byte
(0428) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03735 82A8      ST	Y,R10
    03736 2722      CLR	R18
    03737 2700      CLR	R16
    03738 DE65      RCALL	_W_1byte
(0429) 			for(j=0;j<16;j++)		//
    03739 24CC      CLR	R12
    0373A C007      RJMP	0x3742
(0430) 			{
(0431) 			 	W_1byte(0,1,0x00);	//清成不反白
    0373B 2422      CLR	R2
    0373C 8228      ST	Y,R2
    0373D E021      LDI	R18,1
    0373E 2700      CLR	R16
    0373F DE5E      RCALL	_W_1byte
(0432) 			 	nop();
    03740 0000      NOP
    03741 94C3      INC	R12
    03742 2D8C      MOV	R24,R12
    03743 3180      CPI	R24,0x10
    03744 F3B0      BCS	0x373B
    03745 9563      INC	R22
    03746 3160      CPI	R22,0x10
    03747 F338      BCS	0x372F
(0433) 			}
(0434) 		} 
(0435) 	     clr_y=0x88;
    03748 E848      LDI	R20,0x88
(0436) 	     clr_x=0x90;
    03749 E980      LDI	R24,0x90
    0374A 2EA8      MOV	R10,R24
(0437) 		 	for(i=0;i<16;i++ )			//16行
    0374B 2766      CLR	R22
    0374C C017      RJMP	0x3764
(0438) 		{
(0439) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    0374D 2EE4      MOV	R14,R20
    0374E 5F4F      SUBI	R20,0xFF
    0374F 82E8      ST	Y,R14
    03750 2722      CLR	R18
    03751 2700      CLR	R16
    03752 DE4B      RCALL	_W_1byte
(0440) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03753 82A8      ST	Y,R10
    03754 2722      CLR	R18
    03755 2700      CLR	R16
    03756 DE47      RCALL	_W_1byte
(0441) 			for(j=0;j<16;j++)		//
    03757 24CC      CLR	R12
    03758 C007      RJMP	0x3760
(0442) 			{
(0443) 			 	W_1byte(0,1,0x00);	//清成不反白
    03759 2422      CLR	R2
    0375A 8228      ST	Y,R2
    0375B E021      LDI	R18,1
    0375C 2700      CLR	R16
    0375D DE40      RCALL	_W_1byte
(0444) 			 	nop();
    0375E 0000      NOP
    0375F 94C3      INC	R12
    03760 2D8C      MOV	R24,R12
    03761 3180      CPI	R24,0x10
    03762 F3B0      BCS	0x3759
    03763 9563      INC	R22
    03764 3160      CPI	R22,0x10
    03765 F338      BCS	0x374D
(0445) 			}
(0446) 		} 		
(0447)   W_1byte(0,0,0x30);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03766 E380      LDI	R24,0x30
    03767 8388      ST	Y,R24
    03768 2722      CLR	R18
    03769 2700      CLR	R16
    0376A DE33      RCALL	_W_1byte
    0376B 9621      ADIW	R28,1
    0376C 940C 3C6A JMP	pop_xgsetF0FC
_LCD_print2num:
  a                    --> R12
  tem                  --> R20
  num                  --> R10
  y                    --> R14
  x                    --> R12
    0376E 940E 3C77 CALL	push_xgset30FC
    03770 2EE2      MOV	R14,R18
    03771 2EC0      MOV	R12,R16
    03772 9721      SBIW	R28,1
    03773 84A9      LDD	R10,Y+9
(0448) 	}
(0449) /******************************************************************** 
(0450) 函数 名：LCD_print2num
(0451) 入口参数： 显示2数字
(0452) 出口参数：无 
(0453) 函数作用： 
(0454) 说        明： 
(0455) ********************************************************************/ 
(0456) void LCD_print2num(unsigned char x,unsigned char y,unsigned char num){
(0457) unsigned char tem;
(0458) unsigned char a; 
(0459) 
(0460) a=address(x,y);
    03774 2D2E      MOV	R18,R14
    03775 2D0C      MOV	R16,R12
    03776 DD40      RCALL	_address
    03777 2EC0      MOV	R12,R16
(0461) W_1byte(0,0,a);     //显示的地址 
    03778 82C8      ST	Y,R12
    03779 2722      CLR	R18
    0377A 2700      CLR	R16
    0377B DE22      RCALL	_W_1byte
(0462) tem=num/10;
    0377C E01A      LDI	R17,0xA
    0377D 2D0A      MOV	R16,R10
    0377E 940E 3BE7 CALL	div8u
    03780 2F40      MOV	R20,R16
(0463) W_1byte(0,1,tem+0x30);
    03781 2F84      MOV	R24,R20
    03782 5D80      SUBI	R24,0xD0
    03783 8388      ST	Y,R24
    03784 E021      LDI	R18,1
    03785 2700      CLR	R16
    03786 DE17      RCALL	_W_1byte
(0464) tem=num%10;
    03787 E01A      LDI	R17,0xA
    03788 2D0A      MOV	R16,R10
    03789 940E 3BE5 CALL	mod8u
    0378B 2F40      MOV	R20,R16
(0465) W_1byte(0,1,tem+0x30); 
    0378C 2F84      MOV	R24,R20
    0378D 5D80      SUBI	R24,0xD0
    0378E 8388      ST	Y,R24
    0378F E021      LDI	R18,1
    03790 2700      CLR	R16
    03791 DE0C      RCALL	_W_1byte
(0466) W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03792 EF8F      LDI	R24,0xFF
    03793 8388      ST	Y,R24
    03794 2722      CLR	R18
    03795 2700      CLR	R16
    03796 DE07      RCALL	_W_1byte
    03797 9621      ADIW	R28,1
    03798 940C 3C61 JMP	pop_xgset30FC
_LCD_print4num:
  tem                  --> R12
  num                  --> R14
  y                    --> R20
  x                    --> R10
    0379A 940E 3C77 CALL	push_xgset30FC
    0379C 2F42      MOV	R20,R18
    0379D 2EA0      MOV	R10,R16
    0379E 9721      SBIW	R28,1
    0379F 84E9      LDD	R14,Y+9
    037A0 84FA      LDD	R15,Y+10
(0467) }
(0468)  
(0469) /******************************************************************** 
(0470) 函数 名：LCD_print4num
(0471) 入口参数： 显示4数字
(0472) 出口参数：无 
(0473) 函数作用： 
(0474) 说        明： 
(0475) ********************************************************************/ 
(0476) void LCD_print4num(unsigned char x,unsigned char y,unsigned int num){
(0477) unsigned char tem;
(0478) tem=num/100;
    037A1 E624      LDI	R18,0x64
    037A2 E030      LDI	R19,0
    037A3 0187      MOVW	R16,R14
    037A4 940E 3B61 CALL	div16u
    037A6 2EC0      MOV	R12,R16
(0479) LCD_print2num(x,y,tem);
    037A7 82C8      ST	Y,R12
    037A8 2F24      MOV	R18,R20
    037A9 2D0A      MOV	R16,R10
    037AA DFC3      RCALL	_LCD_print2num
(0480) 
(0481) tem=num%100;   
    037AB E624      LDI	R18,0x64
    037AC E030      LDI	R19,0
    037AD 0187      MOVW	R16,R14
    037AE 940E 3B5F CALL	mod16u
    037B0 2EC0      MOV	R12,R16
(0482) LCD_print2num(x,y+1,tem);
    037B1 82C8      ST	Y,R12
    037B2 2F24      MOV	R18,R20
    037B3 5F2F      SUBI	R18,0xFF
    037B4 2D0A      MOV	R16,R10
    037B5 DFB8      RCALL	_LCD_print2num
(0483) 
(0484) 
(0485)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    037B6 EF8F      LDI	R24,0xFF
    037B7 8388      ST	Y,R24
    037B8 2722      CLR	R18
    037B9 2700      CLR	R16
    037BA DDE3      RCALL	_W_1byte
    037BB 9621      ADIW	R28,1
    037BC 940C 3C61 JMP	pop_xgset30FC
_LCD_print:
  a                    --> R12
  ch                   --> R10
  y                    --> R14
  x                    --> R12
    037BE 940E 3C79 CALL	push_xgset00FC
    037C0 2EE2      MOV	R14,R18
    037C1 2EC0      MOV	R12,R16
    037C2 9721      SBIW	R28,1
    037C3 80AF      LDD	R10,Y+7
(0486) }
(0487)  
(0488) //////////////////////////////////////////////////////////////
(0489) 
(0490) /******************************************************************** 
(0491) 函数 名：LCD_print 
(0492) 入口参数： 显示1 ascii
(0493) 出口参数：无 
(0494) 函数作用： 
(0495) 说        明： 
(0496) ********************************************************************/ 
(0497) void LCD_print(unsigned char x,unsigned char y,unsigned char ch)
(0498) {  
(0499) unsigned char a; 
(0500) a=address(x,y);
    037C4 2D2E      MOV	R18,R14
    037C5 2D0C      MOV	R16,R12
    037C6 DCF0      RCALL	_address
    037C7 2EC0      MOV	R12,R16
(0501) W_1byte(0,0,a);     //显示的地址 
    037C8 82C8      ST	Y,R12
    037C9 2722      CLR	R18
    037CA 2700      CLR	R16
    037CB DDD2      RCALL	_W_1byte
(0502) W_1byte(0,1,ch); 
    037CC 82A8      ST	Y,R10
    037CD E021      LDI	R18,1
    037CE 2700      CLR	R16
    037CF DDCE      RCALL	_W_1byte
    037D0 9621      ADIW	R28,1
    037D1 940C 3C5A JMP	pop_xgset00FC
_LCD_print1:
  ch                   --> R10
    037D3 92AA      ST	-Y,R10
    037D4 2EA0      MOV	R10,R16
    037D5 9721      SBIW	R28,1
(0503) 
(0504) 
(0505) 
(0506) }
(0507) /******************************************************************** 
(0508) 函数 名：LCD_print1 
(0509) 入口参数： 显示1 ascii
(0510) 出口参数：无 
(0511) 函数作用：接着上文地址显示，不重设地址 
(0512) 说        明： 
(0513) ********************************************************************/ 
(0514) void LCD_print1(char ch)
(0515) {  
(0516) W_1byte(0,1,ch); 
    037D6 82A8      ST	Y,R10
    037D7 E021      LDI	R18,1
    037D8 2700      CLR	R16
    037D9 DDC4      RCALL	_W_1byte
    037DA 9621      ADIW	R28,1
    037DB 90A9      LD	R10,Y+
    037DC 9508      RET
_lp:
  p                    --> R10
    037DD 92AA      ST	-Y,R10
    037DE 92BA      ST	-Y,R11
    037DF 0158      MOVW	R10,R16
    037E0 9722      SBIW	R28,2
(0517) }
(0518) //////////////////////////////////////////////////////////////
(0519) 
(0520) 
(0521) 
(0522)  void lp(unsigned char *p)
(0523)  {
(0524)  static unsigned char *p1=" ",*p2=" ",*p3=" ",*p4=" ";
(0525)  p4=p3;
    037E1 9020 04B6 LDS	R2,lcd.c:p3
    037E3 9030 04B7 LDS	R3,lcd.c:p3+1
    037E5 9230 04B9 STS	lcd.c:p4+1,R3
    037E7 9220 04B8 STS	lcd.c:p4,R2
(0526)  p3=p2;
    037E9 9020 04B4 LDS	R2,lcd.c:p2
    037EB 9030 04B5 LDS	R3,lcd.c:p2+1
    037ED 9230 04B7 STS	lcd.c:p3+1,R3
    037EF 9220 04B6 STS	lcd.c:p3,R2
(0527)  p2=p1;
    037F1 9020 04B2 LDS	R2,lcd.c:p1
    037F3 9030 04B3 LDS	R3,lcd.c:p1+1
    037F5 9230 04B5 STS	lcd.c:p2+1,R3
    037F7 9220 04B4 STS	lcd.c:p2,R2
(0528)  p1=p;
    037F9 92B0 04B3 STS	lcd.c:p1+1,R11
    037FB 92A0 04B2 STS	lcd.c:p1,R10
(0529)   LCD_const_disp(1,1,"                ");
    037FD EB8A      LDI	R24,0xBA
    037FE E094      LDI	R25,4
    037FF 8399      STD	Y+1,R25
    03800 8388      ST	Y,R24
    03801 E021      LDI	R18,1
    03802 E001      LDI	R16,1
    03803 DCD4      RCALL	_LCD_const_disp
(0530)   LCD_const_disp(2,1,"                ");
    03804 EB8A      LDI	R24,0xBA
    03805 E094      LDI	R25,4
    03806 8399      STD	Y+1,R25
    03807 8388      ST	Y,R24
    03808 E021      LDI	R18,1
    03809 E002      LDI	R16,2
    0380A DCCD      RCALL	_LCD_const_disp
(0531)   LCD_const_disp(3,1,"                ");
    0380B EB8A      LDI	R24,0xBA
    0380C E094      LDI	R25,4
    0380D 8399      STD	Y+1,R25
    0380E 8388      ST	Y,R24
    0380F E021      LDI	R18,1
    03810 E003      LDI	R16,3
    03811 DCC6      RCALL	_LCD_const_disp
(0532)   LCD_const_disp(4,1,"                ");
    03812 EB8A      LDI	R24,0xBA
    03813 E094      LDI	R25,4
    03814 8399      STD	Y+1,R25
    03815 8388      ST	Y,R24
    03816 E021      LDI	R18,1
    03817 E004      LDI	R16,4
    03818 DCBF      RCALL	_LCD_const_disp
(0533)   LCD_var_disp(1,1,p4);
    03819 9020 04B8 LDS	R2,lcd.c:p4
    0381B 9030 04B9 LDS	R3,lcd.c:p4+1
    0381D 8239      STD	Y+1,R3
    0381E 8228      ST	Y,R2
    0381F E021      LDI	R18,1
    03820 E001      LDI	R16,1
    03821 DCE3      RCALL	_LCD_var_disp
(0534)   LCD_var_disp(2,1,p3);
    03822 9020 04B6 LDS	R2,lcd.c:p3
    03824 9030 04B7 LDS	R3,lcd.c:p3+1
    03826 8239      STD	Y+1,R3
    03827 8228      ST	Y,R2
    03828 E021      LDI	R18,1
    03829 E002      LDI	R16,2
    0382A DCDA      RCALL	_LCD_var_disp
(0535)   LCD_var_disp(3,1,p2);
    0382B 9020 04B4 LDS	R2,lcd.c:p2
    0382D 9030 04B5 LDS	R3,lcd.c:p2+1
    0382F 8239      STD	Y+1,R3
    03830 8228      ST	Y,R2
    03831 E021      LDI	R18,1
    03832 E003      LDI	R16,3
    03833 DCD1      RCALL	_LCD_var_disp
(0536)   LCD_var_disp(4,1,p1);
    03834 9020 04B2 LDS	R2,lcd.c:p1
    03836 9030 04B3 LDS	R3,lcd.c:p1+1
    03838 8239      STD	Y+1,R3
    03839 8228      ST	Y,R2
    0383A E021      LDI	R18,1
    0383B E004      LDI	R16,4
    0383C DCC8      RCALL	_LCD_var_disp
(0537)   delayms(300);
    0383D E20C      LDI	R16,0x2C
    0383E E011      LDI	R17,1
    0383F 940E 23F0 CALL	_delayms
    03841 9622      ADIW	R28,2
    03842 90B9      LD	R11,Y+
    03843 90A9      LD	R10,Y+
    03844 9508      RET
FILE: D:\LQD\software\master\software_src\relay.c
(0001) #include "config.h"
(0002) /*继电器初始化
(0003) *设置端口
(0004) *初始化关闭
(0005) */
(0006) void relay_init(void){
(0007) 	
(0008) 		RELAY_DDR_SET() ;
_relay_init:
    03845 9AA5      SBI	0x14,5
(0009) 		RELAY_OFF();
    03846 98AD      CBI	0x15,5
    03847 9508      RET
(0010) 		//state.Relay = 0;
(0011) 	}	
(0012) 
(0013) /*继电器控制
(0014) *传入 ： 温度
(0015) *传出 ： 当前继电器状态
(0016) *
(0017) */
(0018) unsigned char  relay(int temp)
(0019) {
(0020) 	if(temp<HEAT_THRESHOLD)
_relay:
  temp                 --> R16
    03848 3005      CPI	R16,5
    03849 E0E0      LDI	R30,0
    0384A 071E      CPC	R17,R30
    0384B F41C      BGE	0x384F
(0021) 	{
(0022) 	 		RELAY_DDR_SET();
    0384C 9AA5      SBI	0x14,5
(0023) 			RELAY_ON();
    0384D 9AAD      SBI	0x15,5
(0024) 			//state.Relay = 1 ;
(0025) 	}
    0384E C002      RJMP	0x3851
(0026) 	else
(0027) 	{
(0028) 	 	RELAY_DDR_SET();
    0384F 9AA5      SBI	0x14,5
(0029) 		RELAY_OFF();
    03850 98AD      CBI	0x15,5
(0030) 		//state.Relay = 0 ;
(0031) 	}		
(0032) 	//return state.Relay;
(0033) 	return 0;
    03851 2700      CLR	R16
    03852 9508      RET
_beep:
  i                    --> R10
  short_beep           --> R12
  long_beep            --> R14
    03853 940E 3C79 CALL	push_xgset00FC
    03855 2EC2      MOV	R12,R18
    03856 2EE0      MOV	R14,R16
FILE: D:\LQD\software\master\software_src\beep.c
(0001) #include "config.h"
(0002) 
(0003) #define BEEP_PORT	PORTC
(0004) #define BEEP_PIN	6
(0005) #define BEEP_OFF() BEEP_PORT|=(1<<BEEP_PIN)
(0006) #define BEEP_ON()  BEEP_PORT&=~(1<<BEEP_PIN)
(0007) //楦ｅ
(0008) void beep(unsigned char long_beep,unsigned char short_beep)
(0009) { 
(0010) unsigned char i;
(0011) DDRB|=(1<<0);
    03857 9AB8      SBI	0x17,0
(0012) for(i=0;i<long_beep;i++)
    03858 24AA      CLR	R10
    03859 C00B      RJMP	0x3865
(0013) {
(0014) BEEP_ON();  delayms(200);
    0385A 98AE      CBI	0x15,6
    0385B EC08      LDI	R16,0xC8
    0385C E010      LDI	R17,0
    0385D 940E 23F0 CALL	_delayms
(0015) BEEP_OFF(); delayms(50);
    0385F 9AAE      SBI	0x15,6
    03860 E302      LDI	R16,0x32
    03861 E010      LDI	R17,0
    03862 940E 23F0 CALL	_delayms
    03864 94A3      INC	R10
    03865 14AE      CP	R10,R14
    03866 F398      BCS	0x385A
(0016) }
(0017) delayms(100);
    03867 E604      LDI	R16,0x64
    03868 E010      LDI	R17,0
    03869 940E 23F0 CALL	_delayms
(0018) for(i=0;i<short_beep;i++)
    0386B 24AA      CLR	R10
    0386C C00B      RJMP	0x3878
(0019) {
(0020) BEEP_ON();  delayms(80);
    0386D 98AE      CBI	0x15,6
    0386E E500      LDI	R16,0x50
    0386F E010      LDI	R17,0
    03870 940E 23F0 CALL	_delayms
(0021) BEEP_OFF(); delayms(50);
    03872 9AAE      SBI	0x15,6
    03873 E302      LDI	R16,0x32
    03874 E010      LDI	R17,0
    03875 940E 23F0 CALL	_delayms
    03877 94A3      INC	R10
    03878 14AC      CP	R10,R12
    03879 F398      BCS	0x386D
    0387A 940C 3C5A JMP	pop_xgset00FC
_Delay_nus:
  i                    --> R20
  n                    --> R16
    0387C 934A      ST	-Y,R20
    0387D 935A      ST	-Y,R21
FILE: D:\LQD\software\master\software_src\DS18B20_driver.c
(0001) //------------------------------------------------------------------------------
(0002) // 文件名：DS18B20_driver.c
(0003) // 说明：  DS18B20驱动头文件
(0004) // 功能：  实现1-wire器件的读写
(0005) // 使用方法：   void Delay_nus(unsigned int n);             //延时n微秒函数
(0006) //              unsigned char reset_18B20(void);            //18B20复位
(0007) //              void write_bit_18B20(char bitval);          //写一位到18B20
(0008) //              unsigned char read_bit_18B20(void);         //读一位从18B20
(0009) //              void write_byte_18B20(unsigned char data);  //写一字节到18B20
(0010) //              unsigned char read_18B20(void);             //读一字节到18B20
(0011) //
(0012) // 运行平台：   AVR 8bit (M16已验证)
(0013) // 依存关系：   DS18B20_driver.h    DS18B20基本驱动头文件（函数声明）
(0014) // 移植人：     
(0015) // 最后修改：   
(0016) //------------------------------------------------------------------------------
(0017) 
(0018) #include "config.h"
(0019) #define DS18B20_PORT PORTG
(0020) #define DS18B20_PIN  PING
(0021) #define DS18B20_DDR  DDRG
(0022) #define CL_DQ   DS18B20_PORT&=~(1<<T_NUM)					   
(0023) #define SET_DQ  DS18B20_PORT|=(1<<T_NUM)			   
(0024) #define SET_OUT DS18B20_DDR|=(1<<T_NUM)				   
(0025) #define SET_IN  DS18B20_DDR&=~(1<<T_NUM)			   
(0026) #define IN_DQ   DS18B20_PIN&(1<<T_NUM)				  
(0027) unsigned char T_NUM=0;
(0028) 
(0029) 
(0030) //------------------------------------------------------------------------------
(0031) // 延时N微秒程序 供控制读写DS18B20时序使用
(0032) //------------------------------------------------------------------------------
(0033) void Delay_nus(unsigned int n)   
(0034) {  unsigned int i;
(0035) 	  for (i=0;i<n;i++) 
    0387E 2744      CLR	R20
    0387F 2755      CLR	R21
    03880 C005      RJMP	0x3886
(0036) 	  		{NOP();
    03881 0000      NOP
(0037) 						NOP();
    03882 0000      NOP
(0038) 						NOP();				        //20--300//比较接近
    03883 0000      NOP
    03884 5F4F      SUBI	R20,0xFF
    03885 4F5F      SBCI	R21,0xFF
    03886 1740      CP	R20,R16
    03887 0751      CPC	R21,R17
    03888 F3C0      BCS	0x3881
    03889 9159      LD	R21,Y+
    0388A 9149      LD	R20,Y+
    0388B 9508      RET
_reset_18B20:
  bus_flag             --> R10
    0388C 92AA      ST	-Y,R10
(0039) 					}
(0040) }
(0041) 
(0042) 
(0043) //------------------------------------------------------------------------------
(0044) // 1-wire总线复位
(0045) //------------------------------------------------------------------------------
(0046) unsigned char reset_18B20(void)
(0047) {
(0048) 	char bus_flag;
(0049) 	CLI();
    0388D 94F8      BCLR	7
(0050) 	SET_DQ;
    0388E 9110 04CD LDS	R17,T_NUM
    03890 E001      LDI	R16,1
    03891 940E 3D03 CALL	lsl8
    03893 9020 0065 LDS	R2,0x65
    03895 2A20      OR	R2,R16
    03896 9220 0065 STS	0x65,R2
(0051) 	SET_OUT;
    03898 9110 04CD LDS	R17,T_NUM
    0389A E001      LDI	R16,1
    0389B 940E 3D03 CALL	lsl8
    0389D 9020 0064 LDS	R2,0x64
    0389F 2A20      OR	R2,R16
    038A0 9220 0064 STS	0x64,R2
(0052)  	
(0053)   	Delay_nus(1);
    038A2 E001      LDI	R16,1
    038A3 E010      LDI	R17,0
    038A4 DFD7      RCALL	_Delay_nus
(0054)   	CL_DQ;
    038A5 9110 04CD LDS	R17,T_NUM
    038A7 E001      LDI	R16,1
    038A8 940E 3D03 CALL	lsl8
    038AA 2E20      MOV	R2,R16
    038AB 9420      COM	R2
    038AC 9030 0065 LDS	R3,0x65
    038AE 2032      AND	R3,R2
    038AF 9230 0065 STS	0x65,R3
(0055)   	Delay_nus(550);		//拉低至少480us时间
    038B1 E206      LDI	R16,0x26
    038B2 E012      LDI	R17,2
    038B3 DFC8      RCALL	_Delay_nus
(0056)   	SET_DQ;				//释放
    038B4 9110 04CD LDS	R17,T_NUM
    038B6 E001      LDI	R16,1
    038B7 940E 3D03 CALL	lsl8
    038B9 9020 0065 LDS	R2,0x65
    038BB 2A20      OR	R2,R16
    038BC 9220 0065 STS	0x65,R2
(0057) 					NOP();
    038BE 0000      NOP
(0058) 					NOP();
    038BF 0000      NOP
(0059)   	SET_IN;				//输入
    038C0 9110 04CD LDS	R17,T_NUM
    038C2 E001      LDI	R16,1
    038C3 940E 3D03 CALL	lsl8
    038C5 2E20      MOV	R2,R16
    038C6 9420      COM	R2
    038C7 9030 0064 LDS	R3,0x64
    038C9 2032      AND	R3,R2
    038CA 9230 0064 STS	0x64,R3
(0060)   	Delay_nus(60);
    038CC E30C      LDI	R16,0x3C
    038CD E010      LDI	R17,0
    038CE DFAD      RCALL	_Delay_nus
(0061)   	
(0062) 						//等待回复
(0063)   	bus_flag = IN_DQ;
    038CF 9110 04CD LDS	R17,T_NUM
    038D1 E001      LDI	R16,1
    038D2 940E 3D03 CALL	lsl8
    038D4 90A0 0063 LDS	R10,0x63
    038D6 22A0      AND	R10,R16
(0064)   	
(0065)   	Delay_nus(240);		//回复的低电平在60到240US
    038D7 EF00      LDI	R16,0xF0
    038D8 E010      LDI	R17,0
    038D9 DFA2      RCALL	_Delay_nus
(0066)   	SET_OUT;
    038DA 9110 04CD LDS	R17,T_NUM
    038DC E001      LDI	R16,1
    038DD 940E 3D03 CALL	lsl8
    038DF 9020 0064 LDS	R2,0x64
    038E1 2A20      OR	R2,R16
    038E2 9220 0064 STS	0x64,R2
(0067) 					NOP();
    038E4 0000      NOP
(0068) 					NOP();
    038E5 0000      NOP
(0069)   	SET_DQ;				//回到初始DQ=1；
    038E6 9110 04CD LDS	R17,T_NUM
    038E8 E001      LDI	R16,1
    038E9 940E 3D03 CALL	lsl8
    038EB 9020 0065 LDS	R2,0x65
    038ED 2A20      OR	R2,R16
    038EE 9220 0065 STS	0x65,R2
(0070) 
(0071)   	SEI();
    038F0 9478      BSET	7
(0072) 	if(bus_flag){
    038F1 20AA      TST	R10
    038F2 F011      BEQ	0x38F5
(0073) 		return FALSE;
    038F3 2700      CLR	R16
    038F4 C001      RJMP	0x38F6
(0074) 	}else{
(0075) 		return TRUE;
    038F5 E001      LDI	R16,1
    038F6 90A9      LD	R10,Y+
    038F7 9508      RET
_write_bit_18B20:
  bitval               --> R10
    038F8 92AA      ST	-Y,R10
    038F9 2EA0      MOV	R10,R16
(0076) 	}
(0077) 
(0078) }
(0079) 
(0080) //------------------------------------------------------------------------------
(0081) // 写一位到总线
(0082) //------------------------------------------------------------------------------
(0083) void write_bit_18B20(char bitval)
(0084) {
(0085)     SET_OUT;
    038FA 9110 04CD LDS	R17,T_NUM
    038FC E001      LDI	R16,1
    038FD 940E 3D03 CALL	lsl8
    038FF 9020 0064 LDS	R2,0x64
    03901 2A20      OR	R2,R16
    03902 9220 0064 STS	0x64,R2
(0086) 					NOP();
    03904 0000      NOP
(0087) 					NOP();
    03905 0000      NOP
(0088) 			 CL_DQ;
    03906 9110 04CD LDS	R17,T_NUM
    03908 E001      LDI	R16,1
    03909 940E 3D03 CALL	lsl8
    0390B 2E20      MOV	R2,R16
    0390C 9420      COM	R2
    0390D 9030 0065 LDS	R3,0x65
    0390F 2032      AND	R3,R2
    03910 9230 0065 STS	0x65,R3
(0089) 	   Delay_nus(1);
    03912 E001      LDI	R16,1
    03913 E010      LDI	R17,0
    03914 DF67      RCALL	_Delay_nus
(0090) 	   if(bitval){    //写数据，从低位开始
    03915 20AA      TST	R10
    03916 F059      BEQ	0x3922
(0091) 		     SET_DQ;
    03917 9110 04CD LDS	R17,T_NUM
    03919 E001      LDI	R16,1
    0391A 940E 3D03 CALL	lsl8
    0391C 9020 0065 LDS	R2,0x65
    0391E 2A20      OR	R2,R16
    0391F 9220 0065 STS	0x65,R2
(0092) 	  }else{
    03921 C00C      RJMP	0x392E
(0093) 		     CL_DQ;
    03922 9110 04CD LDS	R17,T_NUM
    03924 E001      LDI	R16,1
    03925 940E 3D03 CALL	lsl8
    03927 2E20      MOV	R2,R16
    03928 9420      COM	R2
    03929 9030 0065 LDS	R3,0x65
    0392B 2032      AND	R3,R2
    0392C 9230 0065 STS	0x65,R3
(0094) 	  }
(0095) 	Delay_nus(40);		//15~60us
    0392E E208      LDI	R16,0x28
    0392F E010      LDI	R17,0
    03930 DF4B      RCALL	_Delay_nus
(0096) 	SET_DQ;
    03931 9110 04CD LDS	R17,T_NUM
    03933 E001      LDI	R16,1
    03934 940E 3D03 CALL	lsl8
    03936 9020 0065 LDS	R2,0x65
    03938 2A20      OR	R2,R16
    03939 9220 0065 STS	0x65,R2
(0097) 	Delay_nus(10);
    0393B E00A      LDI	R16,0xA
    0393C E010      LDI	R17,0
    0393D DF3E      RCALL	_Delay_nus
    0393E 90A9      LD	R10,Y+
    0393F 9508      RET
_read_bit_18B20:
  k                    --> R10
    03940 92AA      ST	-Y,R10
(0098) }
(0099) 
(0100) //------------------------------------------------------------------------------
(0101) // 读一位从总线
(0102) //------------------------------------------------------------------------------
(0103) unsigned char read_bit_18B20(void)
(0104) {
(0105) 	unsigned char k;
(0106) 	SET_OUT;
    03941 9110 04CD LDS	R17,T_NUM
    03943 E001      LDI	R16,1
    03944 940E 3D03 CALL	lsl8
    03946 9020 0064 LDS	R2,0x64
    03948 2A20      OR	R2,R16
    03949 9220 0064 STS	0x64,R2
(0107) 	CL_DQ;			//读时间片开始，拉低总线至少1us
    0394B 9110 04CD LDS	R17,T_NUM
    0394D E001      LDI	R16,1
    0394E 940E 3D03 CALL	lsl8
    03950 2E20      MOV	R2,R16
    03951 9420      COM	R2
    03952 9030 0065 LDS	R3,0x65
    03954 2032      AND	R3,R2
    03955 9230 0065 STS	0x65,R3
(0108) 	Delay_nus(1);
    03957 E001      LDI	R16,1
    03958 E010      LDI	R17,0
    03959 DF22      RCALL	_Delay_nus
(0109) 	
(0110) 					//SET_DQ;	
(0111) 	SET_IN;
    0395A 9110 04CD LDS	R17,T_NUM
    0395C E001      LDI	R16,1
    0395D 940E 3D03 CALL	lsl8
    0395F 2E20      MOV	R2,R16
    03960 9420      COM	R2
    03961 9030 0064 LDS	R3,0x64
    03963 2032      AND	R3,R2
    03964 9230 0064 STS	0x64,R3
(0112) 	Delay_nus(4);
    03966 E004      LDI	R16,4
    03967 E010      LDI	R17,0
    03968 DF13      RCALL	_Delay_nus
(0113) 	k=IN_DQ;    	//读数据,从低位开始
    03969 9110 04CD LDS	R17,T_NUM
    0396B E001      LDI	R16,1
    0396C 940E 3D03 CALL	lsl8
    0396E 90A0 0063 LDS	R10,0x63
    03970 22A0      AND	R10,R16
(0114) 	Delay_nus(10);
    03971 E00A      LDI	R16,0xA
    03972 E010      LDI	R17,0
    03973 DF08      RCALL	_Delay_nus
(0115) 	SET_DQ;	
    03974 9110 04CD LDS	R17,T_NUM
    03976 E001      LDI	R16,1
    03977 940E 3D03 CALL	lsl8
    03979 9020 0065 LDS	R2,0x65
    0397B 2A20      OR	R2,R16
    0397C 9220 0065 STS	0x65,R2
(0116) 				NOP();
    0397E 0000      NOP
(0117) 				NOP();
    0397F 0000      NOP
(0118) 	SET_OUT;
    03980 9110 04CD LDS	R17,T_NUM
    03982 E001      LDI	R16,1
    03983 940E 3D03 CALL	lsl8
    03985 9020 0064 LDS	R2,0x64
    03987 2A20      OR	R2,R16
    03988 9220 0064 STS	0x64,R2
(0119) 	    NOP();
    0398A 0000      NOP
(0120) 					NOP();
    0398B 0000      NOP
(0121) 	if(k){
    0398C 20AA      TST	R10
    0398D F011      BEQ	0x3990
(0122) 	    return 1;
    0398E E001      LDI	R16,1
    0398F C001      RJMP	0x3991
(0123) 	}else{
(0124) 	    return 0;
    03990 2700      CLR	R16
    03991 90A9      LD	R10,Y+
    03992 9508      RET
_write_byte_18B20:
  i                    --> R20
  data                 --> R10
    03993 92AA      ST	-Y,R10
    03994 934A      ST	-Y,R20
    03995 2EA0      MOV	R10,R16
(0125) 	}
(0126) 	
(0127) }
(0128) 
(0129) //------------------------------------------------------------------------------
(0130) // 写一个字节到总线
(0131) //------------------------------------------------------------------------------
(0132) void write_byte_18B20(unsigned char data)
(0133) {
(0134) 	unsigned char i;
(0135)    CLI();
    03996 94F8      BCLR	7
(0136)     for(i=0;i<8;i++)
    03997 2744      CLR	R20
    03998 C009      RJMP	0x39A2
(0137)     {
(0138)         write_bit_18B20(data&(1<<i));
    03999 E001      LDI	R16,1
    0399A 2F14      MOV	R17,R20
    0399B 940E 3D03 CALL	lsl8
    0399D 2E20      MOV	R2,R16
    0399E 2D0A      MOV	R16,R10
    0399F 2102      AND	R16,R2
    039A0 DF57      RCALL	_write_bit_18B20
    039A1 9543      INC	R20
    039A2 3048      CPI	R20,0x8
    039A3 F3A8      BCS	0x3999
(0139)         
(0140)     }
(0141)     SET_DQ;
    039A4 9110 04CD LDS	R17,T_NUM
    039A6 E001      LDI	R16,1
    039A7 940E 3D03 CALL	lsl8
    039A9 9020 0065 LDS	R2,0x65
    039AB 2A20      OR	R2,R16
    039AC 9220 0065 STS	0x65,R2
(0142) 				  NOP();
    039AE 0000      NOP
(0143) 					 NOP();
    039AF 0000      NOP
(0144)     SEI();
    039B0 9478      BSET	7
    039B1 9149      LD	R20,Y+
    039B2 90A9      LD	R10,Y+
    039B3 9508      RET
_read_byte_18B20:
  temp                 --> R10
  n                    --> R20
    039B4 92AA      ST	-Y,R10
    039B5 934A      ST	-Y,R20
(0145)     
(0146)     //return;
(0147) }
(0148) 
(0149) //------------------------------------------------------------------------------
(0150) // 读一个字节
(0151) //------------------------------------------------------------------------------
(0152) unsigned char read_byte_18B20(void)
(0153) {
(0154) 	unsigned char temp,n;
(0155)     CLI();
    039B6 94F8      BCLR	7
(0156)   	temp=0;
    039B7 24AA      CLR	R10
(0157)     for(n=0;n<8;n++)
    039B8 2744      CLR	R20
    039B9 C014      RJMP	0x39CE
(0158)     {
(0159)       	if(read_bit_18B20()){
    039BA DF85      RCALL	_read_bit_18B20
    039BB 2300      TST	R16
    039BC F031      BEQ	0x39C3
(0160)       		temp|=(1<<n);
    039BD E001      LDI	R16,1
    039BE 2F14      MOV	R17,R20
    039BF 940E 3D03 CALL	lsl8
    039C1 2AA0      OR	R10,R16
(0161)       	}else{
    039C2 C007      RJMP	0x39CA
(0162)       		temp&=~(1<<n);
    039C3 E001      LDI	R16,1
    039C4 2F14      MOV	R17,R20
    039C5 940E 3D03 CALL	lsl8
    039C7 2E20      MOV	R2,R16
    039C8 9420      COM	R2
    039C9 20A2      AND	R10,R2
(0163)       	}
(0164)       	Delay_nus(70); //60~120us
    039CA E406      LDI	R16,0x46
    039CB E010      LDI	R17,0
    039CC DEAF      RCALL	_Delay_nus
    039CD 9543      INC	R20
    039CE 3048      CPI	R20,0x8
    039CF F350      BCS	0x39BA
(0165)       	
(0166)    }
(0167)    SEI();
    039D0 9478      BSET	7
(0168) 
(0169)    return temp;
    039D1 2D0A      MOV	R16,R10
    039D2 9149      LD	R20,Y+
    039D3 90A9      LD	R10,Y+
    039D4 9508      RET
(0170) }
(0171) 
(0172) 
(0173) 
(0174) //------------------------------------------------------------------------------
(0175) // 应用函数部分！ 供外部调用
(0176) //------------------------------------------------------------------------------
(0177) //------------------------------------------------------------------------------
(0178) // 单器件/多器件：开始转换
(0179) //------------------------------------------------------------------------------
(0180) void convert_T(void)
(0181) {
(0182) 					if(reset_18B20()){
_convert_T:
    039D5 DEB6      RCALL	_reset_18B20
    039D6 2300      TST	R16
    039D7 F021      BEQ	0x39DC
(0183) 					write_byte_18B20(0xcc);
    039D8 EC0C      LDI	R16,0xCC
    039D9 DFB9      RCALL	_write_byte_18B20
(0184) 					write_byte_18B20(0x44);
    039DA E404      LDI	R16,0x44
    039DB DFB7      RCALL	_write_byte_18B20
(0185) 					}
    039DC 9508      RET
_read_T:
  sign                 --> Y,+1
  tmp                  --> Y,+0
  value                --> R10
    039DD 940E 3C7B CALL	push_xgset003C
    039DF 9724      SBIW	R28,4
(0186) }
(0187) 
(0188) //------------------------------------------------------------------------------
(0189) // 单器件：读温度，返回INIT8U型温度数据（原始数据）
(0190) //------------------------------------------------------------------------------
(0191) float read_T(void)
(0192) {
(0193)     unsigned int value=0;
    039E0 24AA      CLR	R10
    039E1 24BB      CLR	R11
(0194) 	unsigned char sign;
(0195) 	
(0196) 	float tmp;
(0197)     
(0198)     if(reset_18B20()){
    039E2 DEA9      RCALL	_reset_18B20
    039E3 2300      TST	R16
    039E4 F021      BEQ	0x39E9
(0199)     	write_byte_18B20(0xcc);
    039E5 EC0C      LDI	R16,0xCC
    039E6 DFAC      RCALL	_write_byte_18B20
(0200)     	write_byte_18B20(0xbe);
    039E7 EB0E      LDI	R16,0xBE
    039E8 DFAA      RCALL	_write_byte_18B20
(0201)     }
(0202)     
(0203)     value = (unsigned int)read_byte_18B20();
    039E9 DFCA      RCALL	_read_byte_18B20
    039EA 2EA0      MOV	R10,R16
    039EB 24BB      CLR	R11
(0204)     value += ((unsigned int)(read_byte_18B20()))<<8;
    039EC DFC7      RCALL	_read_byte_18B20
    039ED 2EC0      MOV	R12,R16
    039EE 2C2C      MOV	R2,R12
    039EF 2433      CLR	R3
    039F0 2C32      MOV	R3,R2
    039F1 2422      CLR	R2
    039F2 0CA2      ADD	R10,R2
    039F3 1CB3      ADC	R11,R3
(0205) 	/*   if((value&0x8000)==0x8000) //负温度
(0206) 					{
(0207) 					 sign=0;
(0208) 					 data=(~data)+1;       //补码形式，取反加一
(0209) 					}
(0210) 		elae 
(0211) 					{
(0212) 					 sign=1;
(0213) 					}
(0214) 		 xiaoshu1=(unsigned char) ((data&0x000f)*10/16);
(0215) 		 zhengshu=(unsigned char) (data>>4); 
(0216) 		*/
(0217) 	tmp= ((float)value)*0.0625;
    039F4 EC08      LDI	R16,0xC8
    039F5 E010      LDI	R17,0
    039F6 940E 3BFD CALL	elpm32
    039F8 0118      MOVW	R2,R16
    039F9 0129      MOVW	R4,R18
    039FA 0185      MOVW	R16,R10
    039FB 940E 3DCF CALL	uint2fp
    039FD 933A      ST	-Y,R19
    039FE 932A      ST	-Y,R18
    039FF 931A      ST	-Y,R17
    03A00 930A      ST	-Y,R16
    03A01 0181      MOVW	R16,R2
    03A02 0192      MOVW	R18,R4
    03A03 940E 3F76 CALL	fpmule2
    03A05 8308      ST	Y,R16
    03A06 8319      STD	Y+1,R17
    03A07 832A      STD	Y+2,R18
    03A08 833B      STD	Y+3,R19
(0218) 	
(0219)     return( tmp);
    03A09 8108      LD	R16,Y
    03A0A 8119      LDD	R17,Y+1
    03A0B 812A      LDD	R18,Y+2
    03A0C 813B      LDD	R19,Y+3
    03A0D 9624      ADIW	R28,4
    03A0E 940C 3C55 JMP	pop_xgset003C
_read_T_NUM:
  ttemp                --> Y,+0
  NUM                  --> R10
    03A10 92AA      ST	-Y,R10
    03A11 2EA0      MOV	R10,R16
    03A12 9724      SBIW	R28,4
(0220) }
(0221) 
(0222) float read_T_NUM(unsigned char NUM){
(0223) float ttemp;
(0224) if ( NUM >1) return 123.45;
    03A13 E081      LDI	R24,1
    03A14 158A      CP	R24,R10
    03A15 F428      BCC	0x3A1B
    03A16 EC04      LDI	R16,0xC4
    03A17 E010      LDI	R17,0
    03A18 940E 3BFD CALL	elpm32
    03A1A C010      RJMP	0x3A2B
(0225) T_NUM=NUM;//设置访问器件
    03A1B 92A0 04CD STS	T_NUM,R10
(0226) convert_T();//温度转换
    03A1D DFB7      RCALL	_convert_T
(0227) delayms(800);
    03A1E E200      LDI	R16,0x20
    03A1F E013      LDI	R17,3
    03A20 940E 23F0 CALL	_delayms
(0228) ttemp=read_T();
    03A22 DFBA      RCALL	_read_T
    03A23 8308      ST	Y,R16
    03A24 8319      STD	Y+1,R17
    03A25 832A      STD	Y+2,R18
    03A26 833B      STD	Y+3,R19
(0229) return ttemp;
    03A27 8108      LD	R16,Y
    03A28 8119      LDD	R17,Y+1
    03A29 812A      LDD	R18,Y+2
    03A2A 813B      LDD	R19,Y+3
    03A2B 9624      ADIW	R28,4
    03A2C 90A9      LD	R10,Y+
    03A2D 9508      RET
FILE: D:\LQD\software\master\software_src\ds1302.c
(0001) #include "config.h"
(0002) 
(0003) #define TPORT PORTB
(0004) #define TDDR DDRB
(0005) #define TPIN PINB
(0006) #define PIN_RST	 4
(0007) #define PIN_IO	 5
(0008) #define PIN_SCK	 6
(0009) /******************复位脚*********************/
(0010) #define RST_CLR	TPORT &= ~(1 << PIN_RST)   /*电平置低*/
(0011) #define RST_SET	TPORT |= (1 << PIN_RST)    /*电平置高*/
(0012) #define RST_IN	TDDR &= ~(1 << PIN_RST)    /*方向输入*/
(0013) #define RST_OUT	TDDR |= (1 << PIN_RST)     /*方向输出*/
(0014) 
(0015) /*****************双向数据********************/
(0016) #define IO_CLR	TPORT &= ~(1 << PIN_IO)  /*电平置低*/
(0017) #define IO_SET	TPORT |= (1 << PIN_IO)   /*电平置高*/
(0018) #define IO_R	TPIN & (1 << PIN_IO)     /*电平读取*/
(0019) #define IO_IN	TDDR &= ~(1 << PIN_IO)   /*方向输入*/
(0020) #define IO_OUT	TDDR |= (1 << PIN_IO)    /*方向输出*/
(0021) 
(0022) /*****************时钟信号*******************/
(0023) #define SCK_CLR	TPORT &= ~(1 << PIN_SCK)  /*时钟信号*/
(0024) #define SCK_SET	TPORT |= (1 << PIN_SCK)   /*电平置高*/
(0025) #define SCK_IN	TDDR &= ~(1 << PIN_SCK)   /*方向输入*/
(0026) #define SCK_OUT	TDDR |= (1 << PIN_SCK)    /*方向输出*/
(0027) 
(0028) #define ds1302_sec_add			0x80		//秒数据地址
(0029) #define ds1302_min_add			0x82		//分数据地址
(0030) #define ds1302_hr_add			0x84		//时数据地址
(0031) #define ds1302_date_add			0x86		//日数据地址
(0032) #define ds1302_month_add		0x88		//月数据地址
(0033) #define ds1302_day_add			0x8a		//星期数据地址
(0034) #define ds1302_year_add			0x8c		//年数据地址
(0035) #define ds1302_control_add		0x8e		//控制数据地址
(0036) #define ds1302_charger_add		0x90 					 
(0037) #define ds1302_clkburst_add		0xbe
(0038) 
(0039) unsigned char time_buf[8] = {0x20,0x0c,0x0A,0x1c,0x22,0x46,0x00,0x06};
(0040) /*
(0041)  struct tm {
(0042)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0043)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0044) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0045) 	int tm_mday;  // 日 day of the month, 1 to 31
(0046) 	int tm_mon;   // 月 months since January, 0 to 11
(0047) 	int tm_year;  // 年 years since 1900
(0048) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0049) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0050)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0051)  	};	
(0052) 	*/
(0053) 
(0054) //DS1302初始化函数
(0055) void ds1302_init(void) 
(0056) {
(0057) 	RST_CLR;			/*RST脚置低*/
_ds1302_init:
    03A2E 98C4      CBI	0x18,4
(0058) 	SCK_CLR;			/*SCK脚置低*/
    03A2F 98C6      CBI	0x18,6
(0059) 	RST_OUT;			/*RST脚设置为输出*/
    03A30 9ABC      SBI	0x17,4
(0060) 	SCK_OUT;			/*SCK脚设置为输出*/
    03A31 9ABE      SBI	0x17,6
    03A32 9508      RET
_ds1302_write_byte:
  i                    --> R20
  d                    --> R18
  addr                 --> R16
    03A33 934A      ST	-Y,R20
(0061) }
(0062) 
(0063) //向DS1302写入一字节数据
(0064) void ds1302_write_byte(unsigned char addr, unsigned char d) {
(0065) 
(0066) 	unsigned char i;
(0067) 	RST_SET;					/*启动DS1302总线*/
    03A34 9AC4      SBI	0x18,4
(0068) 	
(0069) 	/*写入目标地址：addr*/
(0070) 	IO_OUT;
    03A35 9ABD      SBI	0x17,5
(0071) 	addr = addr & 0xFE;   //最低位置零，寄存器0位为0时写，为1时读
    03A36 7F0E      ANDI	R16,0xFE
(0072) 	for (i = 0; i < 8; i ++) {
    03A37 2744      CLR	R20
    03A38 C009      RJMP	0x3A42
(0073) 		if (addr & 0x01) {
    03A39 FF00      SBRS	R16,0
    03A3A C002      RJMP	0x3A3D
(0074) 			IO_SET;
    03A3B 9AC5      SBI	0x18,5
(0075) 			}
    03A3C C001      RJMP	0x3A3E
(0076) 		else {
(0077) 			IO_CLR;
    03A3D 98C5      CBI	0x18,5
(0078) 			}
(0079) 		SCK_SET;      //产生时钟
    03A3E 9AC6      SBI	0x18,6
(0080) 		SCK_CLR;
    03A3F 98C6      CBI	0x18,6
(0081) 		addr = addr >> 1;
    03A40 9506      LSR	R16
    03A41 9543      INC	R20
    03A42 3048      CPI	R20,0x8
    03A43 F3A8      BCS	0x3A39
(0082) 		}
(0083) 	
(0084) 	/*写入数据：d*/
(0085) 	IO_OUT;
    03A44 9ABD      SBI	0x17,5
(0086) 	for (i = 0; i < 8; i ++) {
    03A45 2744      CLR	R20
    03A46 C009      RJMP	0x3A50
(0087) 		if (d & 0x01) {
    03A47 FF20      SBRS	R18,0
    03A48 C002      RJMP	0x3A4B
(0088) 			IO_SET;
    03A49 9AC5      SBI	0x18,5
(0089) 			}
    03A4A C001      RJMP	0x3A4C
(0090) 		else {
(0091) 			IO_CLR;
    03A4B 98C5      CBI	0x18,5
(0092) 			}
(0093) 		SCK_SET;    //产生时钟
    03A4C 9AC6      SBI	0x18,6
(0094) 		SCK_CLR;
    03A4D 98C6      CBI	0x18,6
(0095) 		d = d >> 1;
    03A4E 9526      LSR	R18
    03A4F 9543      INC	R20
    03A50 3048      CPI	R20,0x8
    03A51 F3A8      BCS	0x3A47
(0096) 		}
(0097) 	RST_CLR;		//停止DS1302总线
    03A52 98C4      CBI	0x18,4
    03A53 9149      LD	R20,Y+
    03A54 9508      RET
_ds1302_read_byte:
  temp                 --> R20
  i                    --> R22
  addr                 --> R16
    03A55 934A      ST	-Y,R20
    03A56 936A      ST	-Y,R22
(0098) 	
(0099) }
(0100) 
(0101) //从DS1302读出一字节数据
(0102) unsigned char ds1302_read_byte(unsigned char addr) {
(0103) 
(0104) 	unsigned char i;
(0105) 	unsigned char temp;
(0106) 	RST_SET;					/*启动DS1302总线*/
    03A57 9AC4      SBI	0x18,4
(0107) 
(0108) 	/*写入目标地址：addr*/
(0109) 	IO_OUT;
    03A58 9ABD      SBI	0x17,5
(0110) 	addr = addr | 0x01;    //最低位置高，寄存器0位为0时写，为1时读
    03A59 6001      ORI	R16,1
(0111) 	for (i = 0; i < 8; i ++) {
    03A5A 2766      CLR	R22
    03A5B C009      RJMP	0x3A65
(0112) 		if (addr & 0x01) {
    03A5C FF00      SBRS	R16,0
    03A5D C002      RJMP	0x3A60
(0113) 			IO_SET;
    03A5E 9AC5      SBI	0x18,5
(0114) 			}
    03A5F C001      RJMP	0x3A61
(0115) 		else {
(0116) 			IO_CLR;
    03A60 98C5      CBI	0x18,5
(0117) 			}
(0118) 		SCK_SET;
    03A61 9AC6      SBI	0x18,6
(0119) 		SCK_CLR;
    03A62 98C6      CBI	0x18,6
(0120) 		addr = addr >> 1;
    03A63 9506      LSR	R16
    03A64 9563      INC	R22
    03A65 3068      CPI	R22,0x8
    03A66 F3A8      BCS	0x3A5C
(0121) 		}
(0122) 	
(0123) 	/*输出数据：temp*/
(0124) 	IO_IN;
    03A67 98BD      CBI	0x17,5
(0125) 	for (i = 0; i < 8; i ++) {
    03A68 2766      CLR	R22
    03A69 C009      RJMP	0x3A73
(0126) 		temp = temp >> 1;
    03A6A 9546      LSR	R20
(0127) 		if (IO_R) {
    03A6B 9BB5      SBIS	0x16,5
    03A6C C002      RJMP	0x3A6F
(0128) 			temp |= 0x80;
    03A6D 6840      ORI	R20,0x80
(0129) 			}
    03A6E C001      RJMP	0x3A70
(0130) 		else {
(0131) 			temp &= 0x7F;
    03A6F 774F      ANDI	R20,0x7F
(0132) 			}
(0133) 		SCK_SET;
    03A70 9AC6      SBI	0x18,6
(0134) 		SCK_CLR;
    03A71 98C6      CBI	0x18,6
    03A72 9563      INC	R22
    03A73 3068      CPI	R22,0x8
    03A74 F3A8      BCS	0x3A6A
(0135) 		}
(0136) 	
(0137) 	RST_CLR;					/*停止DS1302总线*/
    03A75 98C4      CBI	0x18,4
(0138) 	return temp;
    03A76 2F04      MOV	R16,R20
    03A77 9169      LD	R22,Y+
    03A78 9149      LD	R20,Y+
    03A79 9508      RET
(0139) }
(0140) 
(0141) //向DS302写入时钟数据
(0142) void ds1302_write_time(void) {
(0143) 
(0144) 	ds1302_write_byte(ds1302_control_add,0x00);			//关闭写保护 
_ds1302_write_time:
    03A7A 2722      CLR	R18
    03A7B E80E      LDI	R16,0x8E
    03A7C DFB6      RCALL	_ds1302_write_byte
(0145) 	ds1302_write_byte(ds1302_sec_add,0x80);				//暂停时钟 
    03A7D E820      LDI	R18,0x80
    03A7E E800      LDI	R16,0x80
    03A7F DFB3      RCALL	_ds1302_write_byte
(0146) 	//ds1302_write_byte(ds1302_charger_add,0xa9);	    //涓流充电 
(0147) 	ds1302_write_byte(ds1302_year_add,time_buf[1]);		//年 
    03A80 9120 04CF LDS	R18,time_buf+1
    03A82 E80C      LDI	R16,0x8C
    03A83 DFAF      RCALL	_ds1302_write_byte
(0148) 	ds1302_write_byte(ds1302_month_add,time_buf[2]);	//月 
    03A84 9120 04D0 LDS	R18,time_buf+2
    03A86 E808      LDI	R16,0x88
    03A87 DFAB      RCALL	_ds1302_write_byte
(0149) 	ds1302_write_byte(ds1302_date_add,time_buf[3]);		//日 
    03A88 9120 04D1 LDS	R18,time_buf+3
    03A8A E806      LDI	R16,0x86
    03A8B DFA7      RCALL	_ds1302_write_byte
(0150) 	ds1302_write_byte(ds1302_hr_add,time_buf[4]);		//时 
    03A8C 9120 04D2 LDS	R18,time_buf+4
    03A8E E804      LDI	R16,0x84
    03A8F DFA3      RCALL	_ds1302_write_byte
(0151) 	ds1302_write_byte(ds1302_min_add,time_buf[5]);		//分
    03A90 9120 04D3 LDS	R18,time_buf+5
    03A92 E802      LDI	R16,0x82
    03A93 DF9F      RCALL	_ds1302_write_byte
(0152) 	ds1302_write_byte(ds1302_sec_add,time_buf[6]);		//秒
    03A94 9120 04D4 LDS	R18,time_buf+6
    03A96 E800      LDI	R16,0x80
    03A97 DF9B      RCALL	_ds1302_write_byte
(0153) 	ds1302_write_byte(ds1302_day_add,time_buf[7]);		//周 
    03A98 9120 04D5 LDS	R18,time_buf+7
    03A9A E80A      LDI	R16,0x8A
    03A9B DF97      RCALL	_ds1302_write_byte
(0154) 	ds1302_write_byte(ds1302_control_add,0x80);			//打开写保护 
    03A9C E820      LDI	R18,0x80
    03A9D E80E      LDI	R16,0x8E
    03A9E CF94      RJMP	_ds1302_write_byte
_ds1302_read_time:
    03A9F 92AA      ST	-Y,R10
    03AA0 934A      ST	-Y,R20
(0155) }
(0156) 
(0157) //从DS302读出时钟数据
(0158) void ds1302_read_time(void)  { 
(0159) 	time_buf[1]=ds1302_read_byte(ds1302_year_add);		//年 
    03AA1 E80C      LDI	R16,0x8C
    03AA2 DFB2      RCALL	_ds1302_read_byte
    03AA3 9300 04CF STS	time_buf+1,R16
(0160) 	time_buf[2]=ds1302_read_byte(ds1302_month_add);		//月 
    03AA5 E808      LDI	R16,0x88
    03AA6 DFAE      RCALL	_ds1302_read_byte
    03AA7 9300 04D0 STS	time_buf+2,R16
(0161) 	time_buf[3]=ds1302_read_byte(ds1302_date_add);		//日 
    03AA9 E806      LDI	R16,0x86
    03AAA DFAA      RCALL	_ds1302_read_byte
    03AAB 2EA0      MOV	R10,R16
    03AAC 92A0 04D1 STS	time_buf+3,R10
(0162) 	time_buf[4]=ds1302_read_byte(ds1302_hr_add);		//时 
    03AAE E804      LDI	R16,0x84
    03AAF DFA5      RCALL	_ds1302_read_byte
    03AB0 2EA0      MOV	R10,R16
    03AB1 92A0 04D2 STS	time_buf+4,R10
(0163) 	time_buf[5]=ds1302_read_byte(ds1302_min_add);		//分 
    03AB3 E802      LDI	R16,0x82
    03AB4 DFA0      RCALL	_ds1302_read_byte
    03AB5 2EA0      MOV	R10,R16
    03AB6 92A0 04D3 STS	time_buf+5,R10
(0164) 	time_buf[6]=(ds1302_read_byte(ds1302_sec_add))&0x7F;//秒，屏蔽秒的第7位，避免超出59
    03AB8 E800      LDI	R16,0x80
    03AB9 DF9B      RCALL	_ds1302_read_byte
    03ABA 2F40      MOV	R20,R16
    03ABB 2F84      MOV	R24,R20
    03ABC 778F      ANDI	R24,0x7F
    03ABD 9380 04D4 STS	time_buf+6,R24
(0165) 	time_buf[7]=ds1302_read_byte(ds1302_day_add);		//周 
    03ABF E80A      LDI	R16,0x8A
    03AC0 DF94      RCALL	_ds1302_read_byte
    03AC1 2EA0      MOV	R10,R16
    03AC2 92A0 04D5 STS	time_buf+7,R10
    03AC4 9149      LD	R20,Y+
    03AC5 90A9      LD	R10,Y+
    03AC6 9508      RET
_kbscan:
  key                  --> R20
  temp                 --> Y,+0
    03AC7 934A      ST	-Y,R20
    03AC8 9724      SBIW	R28,4
FILE: D:\LQD\software\master\software_src\key.c
(0001) #include "config.h"
(0002) //键盘扫描函数
(0003) unsigned char kbscan(void)
(0004)   {
(0005)    unsigned char key;
(0006)    unsigned long temp=0;
    03AC9 E080      LDI	R24,0
    03ACA 8388      ST	Y,R24
    03ACB 8389      STD	Y+1,R24
    03ACC 838A      STD	Y+2,R24
    03ACD 838B      STD	Y+3,R24
(0007)    DDR_SET;
    03ACE B38A      IN	R24,0x1A
    03ACF 7087      ANDI	R24,7
    03AD0 BB8A      OUT	0x1A,R24
(0008)    
(0009)    if((KEY_PIN) != KEY_MASK)         //检测A口按键引脚电平，如果全是高电平则退出
    03AD1 B389      IN	R24,0x19
    03AD2 718F      ANDI	R24,0x1F
    03AD3 318F      CPI	R24,0x1F
    03AD4 F189      BEQ	0x3B06
(0010)     {
(0011)      delayms(20);           //防抖
    03AD5 E104      LDI	R16,0x14
    03AD6 E010      LDI	R17,0
    03AD7 940E 23F0 CALL	_delayms
(0012)      if((KEY_PIN) != KEY_MASK )      //再次检测A口电平，如果不全是高电平则继续执行程序
    03AD9 B389      IN	R24,0x19
    03ADA 718F      ANDI	R24,0x1F
    03ADB 318F      CPI	R24,0x1F
    03ADC F159      BEQ	0x3B08
(0013)       {
(0014)        key = KEY_PIN ;          //读取PINA，将其存放在key中
    03ADD B349      IN	R20,0x19
    03ADE 714F      ANDI	R20,0x1F
    03ADF C020      RJMP	0x3B00
(0015)         while((KEY_PIN) != KEY_MASK)
(0016) 		{
(0017) 		 temp++ ;
    03AE0 E081      LDI	R24,1
    03AE1 E090      LDI	R25,0
    03AE2 E0A0      LDI	R26,0
    03AE3 E0B0      LDI	R27,0
    03AE4 8028      LD	R2,Y
    03AE5 8039      LDD	R3,Y+1
    03AE6 804A      LDD	R4,Y+2
    03AE7 805B      LDD	R5,Y+3
    03AE8 0E28      ADD	R2,R24
    03AE9 1E39      ADC	R3,R25
    03AEA 1E4A      ADC	R4,R26
    03AEB 1E5B      ADC	R5,R27
    03AEC 8228      ST	Y,R2
    03AED 8239      STD	Y+1,R3
    03AEE 824A      STD	Y+2,R4
    03AEF 825B      STD	Y+3,R5
(0018) 		 if(temp>LONGKEY) 
    03AF0 E880      LDI	R24,0x80
    03AF1 E398      LDI	R25,0x38
    03AF2 E0A1      LDI	R26,1
    03AF3 E0B0      LDI	R27,0
    03AF4 8028      LD	R2,Y
    03AF5 8039      LDD	R3,Y+1
    03AF6 804A      LDD	R4,Y+2
    03AF7 805B      LDD	R5,Y+3
    03AF8 1582      CP	R24,R2
    03AF9 0593      CPC	R25,R3
    03AFA 05A4      CPC	R26,R4
    03AFB 05B5      CPC	R27,R5
    03AFC F418      BCC	0x3B00
(0019) 		 {  return key+0x80;  };
    03AFD 2F04      MOV	R16,R20
    03AFE 5800      SUBI	R16,0x80
    03AFF C009      RJMP	0x3B09
    03B00 B389      IN	R24,0x19
    03B01 718F      ANDI	R24,0x1F
    03B02 318F      CPI	R24,0x1F
    03B03 F6E1      BNE	0x3AE0
(0020) 		}
(0021) 		; //当前有按键处于按下状态，再按其他按键时程序维持当前状态 
(0022)       	
(0023) 		return key;
    03B04 2F04      MOV	R16,R20
    03B05 C003      RJMP	0x3B09
(0024) 	  
(0025) 	  }
(0026)     }
(0027) 	else return NO_KEY;
    03B06 2700      CLR	R16
    03B07 C001      RJMP	0x3B09
(0028) 	
(0029) 	return NO_KEY;
FILE: <library>
    03B08 2700      CLR	R16
    03B09 9624      ADIW	R28,4
    03B0A 9149      LD	R20,Y+
    03B0B 9508      RET
_memset:
    03B0C 8188      LD	R24,Y
    03B0D 8199      LDD	R25,Y+1
    03B0E 3080      CPI	R24,0
    03B0F 0789      CPC	R24,R25
    03B10 F029      BEQ	0x3B16
    03B11 2FE0      MOV	R30,R16
    03B12 2FF1      MOV	R31,R17
    03B13 9321      ST	Z+,R18
    03B14 9701      SBIW	R24,1
    03B15 F7E9      BNE	0x3B13
    03B16 9508      RET
_strcat:
    03B17 2FA0      MOV	R26,R16
    03B18 2FB1      MOV	R27,R17
    03B19 2FE2      MOV	R30,R18
    03B1A 2FF3      MOV	R31,R19
    03B1B 912D      LD	R18,X+
    03B1C 2322      TST	R18
    03B1D F7E9      BNE	0x3B1B
    03B1E 9711      SBIW	R26,1
    03B1F 9121      LD	R18,Z+
    03B20 932D      ST	X+,R18
    03B21 2322      TST	R18
    03B22 F7E1      BNE	0x3B1F
    03B23 9508      RET
_strlen:
    03B24 2FE0      MOV	R30,R16
    03B25 2FF1      MOV	R31,R17
    03B26 27AA      CLR	R26
    03B27 27BB      CLR	R27
    03B28 9001      LD	R0,Z+
    03B29 2000      TST	R0
    03B2A F011      BEQ	0x3B2D
    03B2B 9611      ADIW	R26,1
    03B2C CFFB      RJMP	0x3B28
    03B2D 2F0A      MOV	R16,R26
    03B2E 2F1B      MOV	R17,R27
    03B2F 9508      RET
push_arg4:
    03B30 933A      ST	-Y,R19
    03B31 932A      ST	-Y,R18
push_arg2:
    03B32 931A      ST	-Y,R17
    03B33 930A      ST	-Y,R16
    03B34 9508      RET
asr32:
    03B35 920F      PUSH	R0
    03B36 9009      LD	R0,Y+
    03B37 2000      TST	R0
    03B38 F031      BEQ	0x3B3F
    03B39 9535      ASR	R19
    03B3A 9527      ROR	R18
    03B3B 9517      ROR	R17
    03B3C 9507      ROR	R16
    03B3D 940A      DEC	R0
    03B3E CFF8      RJMP	0x3B37
    03B3F 900F      POP	R0
    03B40 9508      RET
mod16s:
    03B41 9468      BSET	6
    03B42 92DA      ST	-Y,R13
    03B43 2ED1      MOV	R13,R17
    03B44 C004      RJMP	0x3B49
div16s:
    03B45 94E8      BCLR	6
    03B46 92DA      ST	-Y,R13
    03B47 2ED1      MOV	R13,R17
    03B48 26D3      EOR	R13,R19
    03B49 FF17      SBRS	R17,7
    03B4A C004      RJMP	0x3B4F
    03B4B 9510      COM	R17
    03B4C 9500      COM	R16
    03B4D 5F0F      SUBI	R16,0xFF
    03B4E 4F1F      SBCI	R17,0xFF
    03B4F FF37      SBRS	R19,7
    03B50 C004      RJMP	0x3B55
    03B51 9530      COM	R19
    03B52 9520      COM	R18
    03B53 5F2F      SUBI	R18,0xFF
    03B54 4F3F      SBCI	R19,0xFF
    03B55 940E 3B62 CALL	xdiv16u
    03B57 FED7      SBRS	R13,7
    03B58 C004      RJMP	0x3B5D
    03B59 9510      COM	R17
    03B5A 9500      COM	R16
    03B5B 5F0F      SUBI	R16,0xFF
    03B5C 4F1F      SBCI	R17,0xFF
    03B5D 90D9      LD	R13,Y+
    03B5E 9508      RET
mod16u:
    03B5F 9468      BSET	6
    03B60 C001      RJMP	xdiv16u
div16u:
    03B61 94E8      BCLR	6
xdiv16u:
    03B62 92EA      ST	-Y,R14
    03B63 92FA      ST	-Y,R15
    03B64 938A      ST	-Y,R24
    03B65 24EE      CLR	R14
    03B66 24FF      CLR	R15
    03B67 E180      LDI	R24,0x10
    03B68 0F00      LSL	R16
    03B69 1F11      ROL	R17
    03B6A 1CEE      ROL	R14
    03B6B 1CFF      ROL	R15
    03B6C 16E2      CP	R14,R18
    03B6D 06F3      CPC	R15,R19
    03B6E F018      BCS	0x3B72
    03B6F 1AE2      SUB	R14,R18
    03B70 0AF3      SBC	R15,R19
    03B71 9503      INC	R16
    03B72 958A      DEC	R24
    03B73 F7A1      BNE	0x3B68
    03B74 F416      BRTC	0x3B77
    03B75 2D0E      MOV	R16,R14
    03B76 2D1F      MOV	R17,R15
    03B77 9189      LD	R24,Y+
    03B78 90F9      LD	R15,Y+
    03B79 90E9      LD	R14,Y+
    03B7A 9508      RET
div32u:
    03B7B 94E8      BCLR	6
    03B7C C001      RJMP	0x3B7E
mod32u:
    03B7D 9468      BSET	6
    03B7E D030      RCALL	long_div_prolog
    03B7F 24CC      CLR	R12
    03B80 C009      RJMP	0x3B8A
div32s:
    03B81 94E8      BCLR	6
    03B82 C001      RJMP	0x3B84
mod32s:
    03B83 9468      BSET	6
    03B84 D02A      RCALL	long_div_prolog
    03B85 FD37      SBRC	R19,7
    03B86 940E 3CC2 CALL	neg32
    03B88 FDB7      SBRC	R27,7
    03B89 D052      RCALL	neg_R24_R27
    03B8A 2477      CLR	R7
    03B8B 2488      CLR	R8
    03B8C 2499      CLR	R9
    03B8D 24AA      CLR	R10
    03B8E 24BB      CLR	R11
    03B8F D042      RCALL	tst_R16_R19
    03B90 F0C1      BEQ	0x3BA9
    03B91 D045      RCALL	tst_R24_R27
    03B92 F0B1      BEQ	0x3BA9
    03B93 E2E8      LDI	R30,0x28
    03B94 0F00      LSL	R16
    03B95 1F11      ROL	R17
    03B96 1F22      ROL	R18
    03B97 1F33      ROL	R19
    03B98 1C77      ROL	R7
    03B99 1C88      ROL	R8
    03B9A 1C99      ROL	R9
    03B9B 1CAA      ROL	R10
    03B9C 1CBB      ROL	R11
    03B9D 1688      CP	R8,R24
    03B9E 0699      CPC	R9,R25
    03B9F 06AA      CPC	R10,R26
    03BA0 06BB      CPC	R11,R27
    03BA1 F028      BCS	0x3BA7
    03BA2 1A88      SUB	R8,R24
    03BA3 0A99      SBC	R9,R25
    03BA4 0AAA      SBC	R10,R26
    03BA5 0ABB      SBC	R11,R27
    03BA6 9503      INC	R16
    03BA7 95EA      DEC	R30
    03BA8 F759      BNE	0x3B94
    03BA9 F426      BRTC	0x3BAE
    03BAA 2D08      MOV	R16,R8
    03BAB 2D19      MOV	R17,R9
    03BAC 2D2A      MOV	R18,R10
    03BAD 2D3B      MOV	R19,R11
    03BAE C013      RJMP	long_div_epilog
long_div_prolog:
    03BAF 927A      ST	-Y,R7
    03BB0 928A      ST	-Y,R8
    03BB1 929A      ST	-Y,R9
    03BB2 92AA      ST	-Y,R10
    03BB3 92BA      ST	-Y,R11
    03BB4 92CA      ST	-Y,R12
    03BB5 93EA      ST	-Y,R30
    03BB6 938A      ST	-Y,R24
    03BB7 939A      ST	-Y,R25
    03BB8 93AA      ST	-Y,R26
    03BB9 93BA      ST	-Y,R27
    03BBA 858B      LDD	R24,Y+11
    03BBB 859C      LDD	R25,Y+12
    03BBC 85AD      LDD	R26,Y+13
    03BBD 85BE      LDD	R27,Y+14
    03BBE 2EC3      MOV	R12,R19
    03BBF F00E      BRTS	0x3BC1
    03BC0 26CB      EOR	R12,R27
    03BC1 9508      RET
long_div_epilog:
    03BC2 FCC7      SBRC	R12,7
    03BC3 940E 3CC2 CALL	neg32
    03BC5 91B9      LD	R27,Y+
    03BC6 91A9      LD	R26,Y+
    03BC7 9199      LD	R25,Y+
    03BC8 9189      LD	R24,Y+
    03BC9 91E9      LD	R30,Y+
    03BCA 90C9      LD	R12,Y+
    03BCB 90B9      LD	R11,Y+
    03BCC 90A9      LD	R10,Y+
    03BCD 9099      LD	R9,Y+
    03BCE 9089      LD	R8,Y+
    03BCF 9079      LD	R7,Y+
    03BD0 9624      ADIW	R28,4
    03BD1 9508      RET
tst_R16_R19:
    03BD2 2FE0      MOV	R30,R16
    03BD3 2BE1      OR	R30,R17
    03BD4 2BE2      OR	R30,R18
    03BD5 2BE3      OR	R30,R19
    03BD6 9508      RET
tst_R24_R27:
    03BD7 2FE8      MOV	R30,R24
    03BD8 2BE9      OR	R30,R25
    03BD9 2BEA      OR	R30,R26
    03BDA 2BEB      OR	R30,R27
    03BDB 9508      RET
neg_R24_R27:
    03BDC 9580      COM	R24
    03BDD 9590      COM	R25
    03BDE 95A0      COM	R26
    03BDF 95B0      COM	R27
    03BE0 5F8F      SUBI	R24,0xFF
    03BE1 4F9F      SBCI	R25,0xFF
    03BE2 4FAF      SBCI	R26,0xFF
    03BE3 4FBF      SBCI	R27,0xFF
    03BE4 9508      RET
mod8u:
    03BE5 9468      BSET	6
    03BE6 C001      RJMP	xdiv8u
div8u:
    03BE7 94E8      BCLR	6
xdiv8u:
    03BE8 932A      ST	-Y,R18
    03BE9 92FA      ST	-Y,R15
    03BEA 92EA      ST	-Y,R14
    03BEB 24FF      CLR	R15
    03BEC 24EE      CLR	R14
    03BED E120      LDI	R18,0x10
    03BEE 0F00      LSL	R16
    03BEF 1CFF      ROL	R15
    03BF0 1CEE      ROL	R14
    03BF1 16E1      CP	R14,R17
    03BF2 F010      BCS	0x3BF5
    03BF3 1AE1      SUB	R14,R17
    03BF4 9503      INC	R16
    03BF5 952A      DEC	R18
    03BF6 F7B9      BNE	0x3BEE
    03BF7 F40E      BRTC	0x3BF9
    03BF8 2D0E      MOV	R16,R14
    03BF9 90E9      LD	R14,Y+
    03BFA 90F9      LD	R15,Y+
    03BFB 9129      LD	R18,Y+
    03BFC 9508      RET
elpm32:
    03BFD 93EA      ST	-Y,R30
    03BFE 93FA      ST	-Y,R31
    03BFF 920A      ST	-Y,R0
    03C00 2FE0      MOV	R30,R16
    03C01 2FF1      MOV	R31,R17
    03C02 95D8      ELPM
    03C03 2D00      MOV	R16,R0
    03C04 9631      ADIW	R30,1
    03C05 95D8      ELPM
    03C06 2D10      MOV	R17,R0
    03C07 9631      ADIW	R30,1
    03C08 95D8      ELPM
    03C09 2D20      MOV	R18,R0
    03C0A 9631      ADIW	R30,1
    03C0B 95D8      ELPM
    03C0C 2D30      MOV	R19,R0
    03C0D 9009      LD	R0,Y+
    03C0E 91F9      LD	R31,Y+
    03C0F 91E9      LD	R30,Y+
    03C10 9508      RET
empy16s:
    03C11 920A      ST	-Y,R0
    03C12 921A      ST	-Y,R1
    03C13 938A      ST	-Y,R24
    03C14 939A      ST	-Y,R25
    03C15 9F02      MUL	R16,R18
    03C16 01C0      MOVW	R24,R0
    03C17 9F12      MUL	R17,R18
    03C18 0D90      ADD	R25,R0
    03C19 9F03      MUL	R16,R19
    03C1A 0D90      ADD	R25,R0
    03C1B 018C      MOVW	R16,R24
    03C1C 9199      LD	R25,Y+
    03C1D 9189      LD	R24,Y+
    03C1E 9019      LD	R1,Y+
    03C1F 9009      LD	R0,Y+
    03C20 9508      RET
empy32s|empy32u:
    03C21 940E 3CCB CALL	long_prolog
    03C23 927A      ST	-Y,R7
    03C24 940E 3CE4 CALL	tstzero1
    03C26 F159      BEQ	0x3C52
    03C27 2477      CLR	R7
    03C28 940E 3CEA CALL	tstzero2
    03C2A F419      BNE	0x3C2E
    03C2B 018C      MOVW	R16,R24
    03C2C 019D      MOVW	R18,R26
    03C2D C024      RJMP	0x3C52
    03C2E 920A      ST	-Y,R0
    03C2F 921A      ST	-Y,R1
    03C30 9F08      MUL	R16,R24
    03C31 2CB0      MOV	R11,R0
    03C32 2CA1      MOV	R10,R1
    03C33 9F28      MUL	R18,R24
    03C34 2C90      MOV	R9,R0
    03C35 2C81      MOV	R8,R1
    03C36 9F18      MUL	R17,R24
    03C37 0CA0      ADD	R10,R0
    03C38 1C91      ADC	R9,R1
    03C39 1C87      ADC	R8,R7
    03C3A 9F09      MUL	R16,R25
    03C3B 0CA0      ADD	R10,R0
    03C3C 1C91      ADC	R9,R1
    03C3D 1C87      ADC	R8,R7
    03C3E 9F19      MUL	R17,R25
    03C3F 0C90      ADD	R9,R0
    03C40 1C81      ADC	R8,R1
    03C41 9F0A      MUL	R16,R26
    03C42 0C90      ADD	R9,R0
    03C43 1C81      ADC	R8,R1
    03C44 9F38      MUL	R19,R24
    03C45 0C80      ADD	R8,R0
    03C46 9F29      MUL	R18,R25
    03C47 0C80      ADD	R8,R0
    03C48 9F1A      MUL	R17,R26
    03C49 0C80      ADD	R8,R0
    03C4A 9F0B      MUL	R16,R27
    03C4B 0C80      ADD	R8,R0
    03C4C 9019      LD	R1,Y+
    03C4D 9009      LD	R0,Y+
    03C4E 2D0B      MOV	R16,R11
    03C4F 2D1A      MOV	R17,R10
    03C50 2D29      MOV	R18,R9
    03C51 2D38      MOV	R19,R8
    03C52 9079      LD	R7,Y+
    03C53 940C 3CD9 JMP	long_epilog
pop_xgset003C:
    03C55 90A9      LD	R10,Y+
    03C56 90B9      LD	R11,Y+
    03C57 90C9      LD	R12,Y+
    03C58 90D9      LD	R13,Y+
    03C59 9508      RET
pop_xgset00FC:
    03C5A 90A9      LD	R10,Y+
    03C5B 90B9      LD	R11,Y+
    03C5C 90C9      LD	R12,Y+
    03C5D 90D9      LD	R13,Y+
    03C5E 90E9      LD	R14,Y+
    03C5F 90F9      LD	R15,Y+
    03C60 9508      RET
pop_xgset30FC:
    03C61 90A9      LD	R10,Y+
    03C62 90B9      LD	R11,Y+
    03C63 90C9      LD	R12,Y+
    03C64 90D9      LD	R13,Y+
    03C65 90E9      LD	R14,Y+
    03C66 90F9      LD	R15,Y+
    03C67 9149      LD	R20,Y+
    03C68 9159      LD	R21,Y+
    03C69 9508      RET
pop_xgsetF0FC:
    03C6A 90A9      LD	R10,Y+
    03C6B 90B9      LD	R11,Y+
    03C6C 90C9      LD	R12,Y+
    03C6D 90D9      LD	R13,Y+
    03C6E 90E9      LD	R14,Y+
    03C6F 90F9      LD	R15,Y+
    03C70 9149      LD	R20,Y+
    03C71 9159      LD	R21,Y+
    03C72 9169      LD	R22,Y+
    03C73 9179      LD	R23,Y+
    03C74 9508      RET
push_xgsetF0FC:
    03C75 937A      ST	-Y,R23
    03C76 936A      ST	-Y,R22
push_xgset30FC:
    03C77 935A      ST	-Y,R21
    03C78 934A      ST	-Y,R20
push_xgset00FC:
    03C79 92FA      ST	-Y,R15
    03C7A 92EA      ST	-Y,R14
push_xgset003C:
    03C7B 92DA      ST	-Y,R13
    03C7C 92CA      ST	-Y,R12
    03C7D 92BA      ST	-Y,R11
    03C7E 92AA      ST	-Y,R10
    03C7F 9508      RET
push_xgset300C:
    03C80 935A      ST	-Y,R21
    03C81 934A      ST	-Y,R20
    03C82 92BA      ST	-Y,R11
    03C83 92AA      ST	-Y,R10
    03C84 9508      RET
pop_xgset300C:
    03C85 90A9      LD	R10,Y+
    03C86 90B9      LD	R11,Y+
    03C87 9149      LD	R20,Y+
    03C88 9159      LD	R21,Y+
    03C89 9508      RET
push_xgsetF000:
    03C8A 937A      ST	-Y,R23
    03C8B 936A      ST	-Y,R22
    03C8C 935A      ST	-Y,R21
    03C8D 934A      ST	-Y,R20
    03C8E 9508      RET
pop_xgsetF000:
    03C8F 9149      LD	R20,Y+
    03C90 9159      LD	R21,Y+
    03C91 9169      LD	R22,Y+
    03C92 9179      LD	R23,Y+
    03C93 9508      RET
push_xgsetF00C:
    03C94 937A      ST	-Y,R23
    03C95 936A      ST	-Y,R22
    03C96 935A      ST	-Y,R21
    03C97 934A      ST	-Y,R20
    03C98 92BA      ST	-Y,R11
    03C99 92AA      ST	-Y,R10
    03C9A 9508      RET
pop_xgsetF00C:
    03C9B 90A9      LD	R10,Y+
    03C9C 90B9      LD	R11,Y+
    03C9D 9149      LD	R20,Y+
    03C9E 9159      LD	R21,Y+
    03C9F 9169      LD	R22,Y+
    03CA0 9179      LD	R23,Y+
    03CA1 9508      RET
push_xgset303C:
    03CA2 935A      ST	-Y,R21
    03CA3 934A      ST	-Y,R20
    03CA4 92DA      ST	-Y,R13
    03CA5 92CA      ST	-Y,R12
    03CA6 92BA      ST	-Y,R11
    03CA7 92AA      ST	-Y,R10
    03CA8 9508      RET
pop_xgset303C:
    03CA9 90A9      LD	R10,Y+
    03CAA 90B9      LD	R11,Y+
    03CAB 90C9      LD	R12,Y+
    03CAC 90D9      LD	R13,Y+
    03CAD 9149      LD	R20,Y+
    03CAE 9159      LD	R21,Y+
    03CAF 9508      RET
push_xgsetF03C:
    03CB0 937A      ST	-Y,R23
    03CB1 936A      ST	-Y,R22
    03CB2 935A      ST	-Y,R21
    03CB3 934A      ST	-Y,R20
    03CB4 92DA      ST	-Y,R13
    03CB5 92CA      ST	-Y,R12
    03CB6 92BA      ST	-Y,R11
    03CB7 92AA      ST	-Y,R10
    03CB8 9508      RET
pop_xgsetF03C:
    03CB9 90A9      LD	R10,Y+
    03CBA 90B9      LD	R11,Y+
    03CBB 90C9      LD	R12,Y+
    03CBC 90D9      LD	R13,Y+
    03CBD 9149      LD	R20,Y+
    03CBE 9159      LD	R21,Y+
    03CBF 9169      LD	R22,Y+
    03CC0 9179      LD	R23,Y+
    03CC1 9508      RET
neg32:
    03CC2 9500      COM	R16
    03CC3 9510      COM	R17
    03CC4 9520      COM	R18
    03CC5 9530      COM	R19
    03CC6 5F0F      SUBI	R16,0xFF
    03CC7 4F1F      SBCI	R17,0xFF
    03CC8 4F2F      SBCI	R18,0xFF
    03CC9 4F3F      SBCI	R19,0xFF
    03CCA 9508      RET
long_prolog:
    03CCB 928A      ST	-Y,R8
    03CCC 929A      ST	-Y,R9
    03CCD 92AA      ST	-Y,R10
    03CCE 92BA      ST	-Y,R11
    03CCF 93EA      ST	-Y,R30
    03CD0 938A      ST	-Y,R24
    03CD1 939A      ST	-Y,R25
    03CD2 93AA      ST	-Y,R26
    03CD3 93BA      ST	-Y,R27
    03CD4 8589      LDD	R24,Y+9
    03CD5 859A      LDD	R25,Y+10
    03CD6 85AB      LDD	R26,Y+11
    03CD7 85BC      LDD	R27,Y+12
    03CD8 9508      RET
long_epilog:
    03CD9 91B9      LD	R27,Y+
    03CDA 91A9      LD	R26,Y+
    03CDB 9199      LD	R25,Y+
    03CDC 9189      LD	R24,Y+
    03CDD 91E9      LD	R30,Y+
    03CDE 90B9      LD	R11,Y+
    03CDF 90A9      LD	R10,Y+
    03CE0 9099      LD	R9,Y+
    03CE1 9089      LD	R8,Y+
    03CE2 9624      ADIW	R28,4
    03CE3 9508      RET
tstzero1:
    03CE4 27EE      CLR	R30
    03CE5 2BE0      OR	R30,R16
    03CE6 2BE1      OR	R30,R17
    03CE7 2BE2      OR	R30,R18
    03CE8 2BE3      OR	R30,R19
    03CE9 9508      RET
tstzero2:
    03CEA 27EE      CLR	R30
    03CEB 2BE8      OR	R30,R24
    03CEC 2BE9      OR	R30,R25
    03CED 2BEA      OR	R30,R26
    03CEE 2BEB      OR	R30,R27
    03CEF 9508      RET
lsl16:
    03CF0 2322      TST	R18
    03CF1 F021      BEQ	0x3CF6
    03CF2 0F00      LSL	R16
    03CF3 1F11      ROL	R17
    03CF4 952A      DEC	R18
    03CF5 CFFA      RJMP	lsl16
    03CF6 9508      RET
lsl32:
    03CF7 920F      PUSH	R0
    03CF8 9009      LD	R0,Y+
    03CF9 2000      TST	R0
    03CFA F031      BEQ	0x3D01
    03CFB 0F00      LSL	R16
    03CFC 1F11      ROL	R17
    03CFD 1F22      ROL	R18
    03CFE 1F33      ROL	R19
    03CFF 940A      DEC	R0
    03D00 CFF8      RJMP	0x3CF9
    03D01 900F      POP	R0
    03D02 9508      RET
lsl8:
    03D03 2311      TST	R17
    03D04 F019      BEQ	0x3D08
    03D05 0F00      LSL	R16
    03D06 951A      DEC	R17
    03D07 CFFB      RJMP	lsl8
    03D08 9508      RET
lsr16:
    03D09 2322      TST	R18
    03D0A F021      BEQ	0x3D0F
    03D0B 9516      LSR	R17
    03D0C 9507      ROR	R16
    03D0D 952A      DEC	R18
    03D0E CFFA      RJMP	lsr16
    03D0F 9508      RET
lsr32:
    03D10 920F      PUSH	R0
    03D11 9009      LD	R0,Y+
    03D12 2000      TST	R0
    03D13 F031      BEQ	0x3D1A
    03D14 9536      LSR	R19
    03D15 9527      ROR	R18
    03D16 9517      ROR	R17
    03D17 9507      ROR	R16
    03D18 940A      DEC	R0
    03D19 CFF8      RJMP	0x3D12
    03D1A 900F      POP	R0
    03D1B 9508      RET
asgnblk:
    03D1C 93AA      ST	-Y,R26
    03D1D 93BA      ST	-Y,R27
    03D1E 93EA      ST	-Y,R30
    03D1F 93FA      ST	-Y,R31
    03D20 920A      ST	-Y,R0
    03D21 81AF      LDD	R26,Y+7
    03D22 85B8      LDD	R27,Y+8
    03D23 81ED      LDD	R30,Y+5
    03D24 81FE      LDD	R31,Y+6
    03D25 3000      CPI	R16,0
    03D26 0701      CPC	R16,R17
    03D27 F029      BEQ	0x3D2D
    03D28 9001      LD	R0,Z+
    03D29 920D      ST	X+,R0
    03D2A 5001      SUBI	R16,1
    03D2B 4010      SBCI	R17,0
    03D2C CFF8      RJMP	0x3D25
    03D2D 9009      LD	R0,Y+
    03D2E 91F9      LD	R31,Y+
    03D2F 91E9      LD	R30,Y+
    03D30 91B9      LD	R27,Y+
    03D31 91A9      LD	R26,Y+
    03D32 9624      ADIW	R28,4
    03D33 9508      RET
fpsub:
    03D34 9468      BSET	6
    03D35 C001      RJMP	fpadd_alt
fpadd:
    03D36 94E8      BCLR	6
fpadd_alt:
    03D37 940E 3EFB CALL	saveFPRegs
    03D39 940E 3E8D CALL	unpacks
    03D3B F409      BNE	0x3D3D
    03D3C C048      RJMP	0x3D85
    03D3D 2CE6      MOV	R14,R6
    03D3E 2CD5      MOV	R13,R5
    03D3F 2CC4      MOV	R12,R4
    03D40 2EB3      MOV	R11,R19
    03D41 2EA2      MOV	R10,R18
    03D42 2E91      MOV	R9,R17
    03D43 2E80      MOV	R8,R16
    03D44 8100      LD	R16,Z
    03D45 8111      LDD	R17,Z+1
    03D46 8122      LDD	R18,Z+2
    03D47 8133      LDD	R19,Z+3
    03D48 940E 3E8D CALL	unpacks
    03D4A F409      BNE	0x3D4C
    03D4B C044      RJMP	0x3D90
    03D4C 2D84      MOV	R24,R4
    03D4D 2D95      MOV	R25,R5
    03D4E 198C      SUB	R24,R12
    03D4F 099D      SBC	R25,R13
    03D50 F0B9      BEQ	0x3D68
    03D51 F472      BPL	0x3D60
    03D52 9590      COM	R25
    03D53 9580      COM	R24
    03D54 9601      ADIW	R24,1
    03D55 2C4C      MOV	R4,R12
    03D56 2C5D      MOV	R5,R13
    03D57 3188      CPI	R24,0x18
    03D58 F5B8      BCC	0x3D90
    03D59 9535      ASR	R19
    03D5A 9527      ROR	R18
    03D5B 9517      ROR	R17
    03D5C 9507      ROR	R16
    03D5D 9701      SBIW	R24,1
    03D5E F7D1      BNE	0x3D59
    03D5F C008      RJMP	0x3D68
    03D60 3188      CPI	R24,0x18
    03D61 F518      BCC	0x3D85
    03D62 94B5      ASR	R11
    03D63 94A7      ROR	R10
    03D64 9497      ROR	R9
    03D65 9487      ROR	R8
    03D66 9701      SBIW	R24,1
    03D67 F7D1      BNE	0x3D62
    03D68 2466      CLR	R6
    03D69 F02E      BRTS	0x3D6F
    03D6A 0D08      ADD	R16,R8
    03D6B 1D19      ADC	R17,R9
    03D6C 1D2A      ADC	R18,R10
    03D6D 1D3B      ADC	R19,R11
    03D6E C009      RJMP	0x3D78
    03D6F 1A80      SUB	R8,R16
    03D70 0A91      SBC	R9,R17
    03D71 0AA2      SBC	R10,R18
    03D72 0AB3      SBC	R11,R19
    03D73 2D08      MOV	R16,R8
    03D74 2D19      MOV	R17,R9
    03D75 2D2A      MOV	R18,R10
    03D76 2D3B      MOV	R19,R11
    03D77 2333      TST	R19
    03D78 F422      BPL	0x3D7D
    03D79 940E 3CC2 CALL	neg32
    03D7B E880      LDI	R24,0x80
    03D7C 2E68      MOV	R6,R24
    03D7D 940E 3EB6 CALL	normalize_and_pack
    03D7F C002      RJMP	0x3D82
    03D80 940E 3EEB CALL	pack
    03D82 940E 3F0A CALL	restoreFPRegs
    03D84 9508      RET
    03D85 8100      LD	R16,Z
    03D86 8111      LDD	R17,Z+1
    03D87 8122      LDD	R18,Z+2
    03D88 8133      LDD	R19,Z+3
    03D89 F7C6      BRTC	0x3D82
    03D8A 940E 3E95 CALL	tstR16_R19
    03D8C F3A9      BEQ	0x3D82
    03D8D E880      LDI	R24,0x80
    03D8E 2738      EOR	R19,R24
    03D8F CFF2      RJMP	0x3D82
    03D90 2D08      MOV	R16,R8
    03D91 2D19      MOV	R17,R9
    03D92 2D2A      MOV	R18,R10
    03D93 2D3B      MOV	R19,R11
    03D94 2C4C      MOV	R4,R12
    03D95 2C5D      MOV	R5,R13
    03D96 2C6E      MOV	R6,R14
    03D97 2333      TST	R19
    03D98 F73A      BPL	0x3D80
    03D99 940E 3CC2 CALL	neg32
    03D9B E880      LDI	R24,0x80
    03D9C 2E68      MOV	R6,R24
    03D9D CFE2      RJMP	0x3D80
fpadd2:
    03D9E 93FA      ST	-Y,R31
    03D9F 93EA      ST	-Y,R30
    03DA0 2FEC      MOV	R30,R28
    03DA1 2FFD      MOV	R31,R29
    03DA2 9632      ADIW	R30,2
    03DA3 940E 3D36 CALL	fpadd
    03DA5 91E9      LD	R30,Y+
    03DA6 91F9      LD	R31,Y+
    03DA7 9624      ADIW	R28,4
    03DA8 9508      RET
fpsub2:
    03DA9 93FA      ST	-Y,R31
    03DAA 93EA      ST	-Y,R30
    03DAB 2FEC      MOV	R30,R28
    03DAC 2FFD      MOV	R31,R29
    03DAD 9632      ADIW	R30,2
    03DAE 940E 3D34 CALL	fpsub
    03DB0 91E9      LD	R30,Y+
    03DB1 91F9      LD	R31,Y+
    03DB2 9624      ADIW	R28,4
    03DB3 9508      RET
fpsub1x:
    03DB4 93FA      ST	-Y,R31
    03DB5 93EA      ST	-Y,R30
    03DB6 81EA      LDD	R30,Y+2
    03DB7 81FB      LDD	R31,Y+3
    03DB8 940E 3D34 CALL	fpsub
    03DBA 91E9      LD	R30,Y+
    03DBB 91F9      LD	R31,Y+
    03DBC 8339      STD	Y+1,R19
    03DBD 8328      ST	Y,R18
    03DBE 931A      ST	-Y,R17
    03DBF 930A      ST	-Y,R16
    03DC0 9508      RET
fpsub2x:
    03DC1 93FA      ST	-Y,R31
    03DC2 93EA      ST	-Y,R30
    03DC3 2FEC      MOV	R30,R28
    03DC4 2FFD      MOV	R31,R29
    03DC5 9632      ADIW	R30,2
    03DC6 940E 3D34 CALL	fpsub
    03DC8 91E9      LD	R30,Y+
    03DC9 91F9      LD	R31,Y+
    03DCA 833B      STD	Y+3,R19
    03DCB 832A      STD	Y+2,R18
    03DCC 8319      STD	Y+1,R17
    03DCD 8308      ST	Y,R16
    03DCE 9508      RET
uint2fp:
    03DCF 9468      BSET	6
    03DD0 C001      RJMP	0x3DD2
int2fp:
    03DD1 94E8      BCLR	6
    03DD2 2722      CLR	R18
    03DD3 2733      CLR	R19
    03DD4 F046      BRTS	0x3DDD
    03DD5 FD17      SBRC	R17,7
    03DD6 9520      COM	R18
    03DD7 FD17      SBRC	R17,7
    03DD8 9530      COM	R19
    03DD9 C003      RJMP	0x3DDD
ulong2fp:
    03DDA 9468      BSET	6
    03DDB C001      RJMP	0x3DDD
long2fp:
    03DDC 94E8      BCLR	6
    03DDD 924A      ST	-Y,R4
    03DDE 925A      ST	-Y,R5
    03DDF 926A      ST	-Y,R6
    03DE0 938A      ST	-Y,R24
    03DE1 E187      LDI	R24,0x17
    03DE2 2E48      MOV	R4,R24
    03DE3 2455      CLR	R5
    03DE4 2466      CLR	R6
    03DE5 F036      BRTS	0x3DEC
    03DE6 2333      TST	R19
    03DE7 F422      BPL	0x3DEC
    03DE8 940E 3CC2 CALL	neg32
    03DEA E880      LDI	R24,0x80
    03DEB 2E68      MOV	R6,R24
    03DEC 940E 3EB6 CALL	normalize_and_pack
    03DEE 9189      LD	R24,Y+
    03DEF 9069      LD	R6,Y+
    03DF0 9059      LD	R5,Y+
    03DF1 9049      LD	R4,Y+
    03DF2 9508      RET
fpdiv1:
    03DF3 93FA      ST	-Y,R31
    03DF4 93EA      ST	-Y,R30
    03DF5 81EA      LDD	R30,Y+2
    03DF6 81FB      LDD	R31,Y+3
    03DF7 D027      RCALL	0x3E1F
    03DF8 91E9      LD	R30,Y+
    03DF9 91F9      LD	R31,Y+
    03DFA 9622      ADIW	R28,2
    03DFB 9508      RET
fpdiv2:
    03DFC 93FA      ST	-Y,R31
    03DFD 93EA      ST	-Y,R30
    03DFE 2FEC      MOV	R30,R28
    03DFF 2FFD      MOV	R31,R29
    03E00 9632      ADIW	R30,2
    03E01 D01D      RCALL	0x3E1F
    03E02 91E9      LD	R30,Y+
    03E03 91F9      LD	R31,Y+
    03E04 9624      ADIW	R28,4
    03E05 9508      RET
fpdiv1x:
    03E06 93FA      ST	-Y,R31
    03E07 93EA      ST	-Y,R30
    03E08 81EA      LDD	R30,Y+2
    03E09 81FB      LDD	R31,Y+3
    03E0A D014      RCALL	0x3E1F
    03E0B 91E9      LD	R30,Y+
    03E0C 91F9      LD	R31,Y+
    03E0D 8339      STD	Y+1,R19
    03E0E 8328      ST	Y,R18
    03E0F 931A      ST	-Y,R17
    03E10 930A      ST	-Y,R16
    03E11 9508      RET
fpdiv2x:
    03E12 93FA      ST	-Y,R31
    03E13 93EA      ST	-Y,R30
    03E14 2FEC      MOV	R30,R28
    03E15 2FFD      MOV	R31,R29
    03E16 9632      ADIW	R30,2
    03E17 D007      RCALL	0x3E1F
    03E18 91E9      LD	R30,Y+
    03E19 91F9      LD	R31,Y+
    03E1A 833B      STD	Y+3,R19
    03E1B 832A      STD	Y+2,R18
    03E1C 8319      STD	Y+1,R17
    03E1D 8308      ST	Y,R16
    03E1E 9508      RET
    03E1F 920A      ST	-Y,R0
    03E20 921A      ST	-Y,R1
    03E21 922A      ST	-Y,R2
    03E22 923A      ST	-Y,R3
    03E23 940E 3EFB CALL	saveFPRegs
    03E25 933A      ST	-Y,R19
    03E26 932A      ST	-Y,R18
    03E27 931A      ST	-Y,R17
    03E28 930A      ST	-Y,R16
    03E29 8100      LD	R16,Z
    03E2A 8111      LDD	R17,Z+1
    03E2B 8122      LDD	R18,Z+2
    03E2C 8133      LDD	R19,Z+3
    03E2D 940E 3E9D CALL	unpacku
    03E2F F409      BNE	0x3E31
    03E30 C057      RJMP	0x3E88
    03E31 2CE6      MOV	R14,R6
    03E32 2CD5      MOV	R13,R5
    03E33 2CC4      MOV	R12,R4
    03E34 2EB3      MOV	R11,R19
    03E35 2EA2      MOV	R10,R18
    03E36 2E91      MOV	R9,R17
    03E37 2E80      MOV	R8,R16
    03E38 9109      LD	R16,Y+
    03E39 9119      LD	R17,Y+
    03E3A 9129      LD	R18,Y+
    03E3B 9139      LD	R19,Y+
    03E3C 940E 3E9D CALL	unpacku
    03E3E F1A1      BEQ	0x3E73
    03E3F 246E      EOR	R6,R14
    03E40 184C      SUB	R4,R12
    03E41 085D      SBC	R5,R13
    03E42 E880      LDI	R24,0x80
    03E43 1648      CP	R4,R24
    03E44 0653      CPC	R5,R19
    03E45 F00C      BLT	0x3E47
    03E46 C033      RJMP	0x3E7A
    03E47 E881      LDI	R24,0x81
    03E48 1648      CP	R4,R24
    03E49 EF8F      LDI	R24,0xFF
    03E4A 0658      CPC	R5,R24
    03E4B F40C      BGE	0x3E4D
    03E4C C036      RJMP	0x3E83
    03E4D E280      LDI	R24,0x20
    03E4E 2433      CLR	R3
    03E4F 2E23      MOV	R2,R19
    03E50 2E12      MOV	R1,R18
    03E51 2E01      MOV	R0,R17
    03E52 2F30      MOV	R19,R16
    03E53 2722      CLR	R18
    03E54 2711      CLR	R17
    03E55 2700      CLR	R16
    03E56 9426      LSR	R2
    03E57 9417      ROR	R1
    03E58 9407      ROR	R0
    03E59 9537      ROR	R19
    03E5A 9527      ROR	R18
    03E5B 0F00      LSL	R16
    03E5C 1F11      ROL	R17
    03E5D 1F22      ROL	R18
    03E5E 1F33      ROL	R19
    03E5F 1C00      ROL	R0
    03E60 1C11      ROL	R1
    03E61 1C22      ROL	R2
    03E62 1C33      ROL	R3
    03E63 F028      BCS	0x3E69
    03E64 1808      SUB	R0,R8
    03E65 0819      SBC	R1,R9
    03E66 082A      SBC	R2,R10
    03E67 083B      SBC	R3,R11
    03E68 C004      RJMP	0x3E6D
    03E69 0C08      ADD	R0,R8
    03E6A 1C19      ADC	R1,R9
    03E6B 1C2A      ADC	R2,R10
    03E6C 1C3B      ADC	R3,R11
    03E6D F00A      BMI	0x3E6F
    03E6E 6001      ORI	R16,1
    03E6F 958A      DEC	R24
    03E70 F751      BNE	0x3E5B
    03E71 940E 3EB6 CALL	normalize_and_pack
    03E73 940E 3F0A CALL	restoreFPRegs
    03E75 9039      LD	R3,Y+
    03E76 9029      LD	R2,Y+
    03E77 9019      LD	R1,Y+
    03E78 9009      LD	R0,Y+
    03E79 9508      RET
    03E7A EF0F      LDI	R16,0xFF
    03E7B 2F10      MOV	R17,R16
    03E7C E72F      LDI	R18,0x7F
    03E7D E73F      LDI	R19,0x7F
    03E7E 2066      TST	R6
    03E7F F399      BEQ	0x3E73
    03E80 940E 3CC2 CALL	neg32
    03E82 CFF0      RJMP	0x3E73
    03E83 2700      CLR	R16
    03E84 2F10      MOV	R17,R16
    03E85 2F20      MOV	R18,R16
    03E86 2F30      MOV	R19,R16
    03E87 CFEB      RJMP	0x3E73
    03E88 9109      LD	R16,Y+
    03E89 9119      LD	R17,Y+
    03E8A 9129      LD	R18,Y+
    03E8B 9139      LD	R19,Y+
    03E8C CFED      RJMP	0x3E7A
unpacks:
    03E8D D00F      RCALL	unpacku
    03E8E F029      BEQ	0x3E94
    03E8F 2066      TST	R6
    03E90 F011      BEQ	0x3E93
    03E91 940E 3CC2 CALL	neg32
    03E93 9498      BCLR	1
    03E94 9508      RET
tstR16_R19:
    03E95 2300      TST	R16
    03E96 F429      BNE	0x3E9C
    03E97 2311      TST	R17
    03E98 F419      BNE	0x3E9C
    03E99 2322      TST	R18
    03E9A F409      BNE	0x3E9C
    03E9B 2333      TST	R19
    03E9C 9508      RET
unpacku:
    03E9D DFF7      RCALL	tstR16_R19
    03E9E F099      BEQ	0x3EB2
    03E9F 938A      ST	-Y,R24
    03EA0 2E63      MOV	R6,R19
    03EA1 E880      LDI	R24,0x80
    03EA2 2268      AND	R6,R24
    03EA3 0F22      LSL	R18
    03EA4 1F33      ROL	R19
    03EA5 2E43      MOV	R4,R19
    03EA6 E78F      LDI	R24,0x7F
    03EA7 1A48      SUB	R4,R24
    03EA8 2455      CLR	R5
    03EA9 2788      CLR	R24
    03EAA 0A58      SBC	R5,R24
    03EAB 9526      LSR	R18
    03EAC E830      LDI	R19,0x80
    03EAD 2B23      OR	R18,R19
    03EAE 2733      CLR	R19
    03EAF 9189      LD	R24,Y+
    03EB0 9498      BCLR	1
    03EB1 9508      RET
    03EB2 2444      CLR	R4
    03EB3 2455      CLR	R5
    03EB4 2466      CLR	R6
    03EB5 9508      RET
normalize_and_pack:
    03EB6 DFDE      RCALL	tstR16_R19
    03EB7 F409      BNE	0x3EB9
    03EB8 9508      RET
    03EB9 93AA      ST	-Y,R26
    03EBA 93BA      ST	-Y,R27
    03EBB 01D2      MOVW	R26,R4
    03EBC 939A      ST	-Y,R25
    03EBD 938A      ST	-Y,R24
    03EBE E78E      LDI	R24,0x7E
    03EBF E090      LDI	R25,0
    03EC0 2333      TST	R19
    03EC1 F049      BEQ	0x3ECB
    03EC2 9536      LSR	R19
    03EC3 9527      ROR	R18
    03EC4 9517      ROR	R17
    03EC5 9507      ROR	R16
    03EC6 17A8      CP	R26,R24
    03EC7 07B9      CPC	R27,R25
    03EC8 F4CC      BGE	0x3EE2
    03EC9 9611      ADIW	R26,1
    03ECA CFF5      RJMP	0x3EC0
    03ECB 9580      COM	R24
    03ECC 9590      COM	R25
    03ECD 9601      ADIW	R24,1
    03ECE 2322      TST	R18
    03ECF F0BA      BMI	0x3EE7
    03ED0 0F00      LSL	R16
    03ED1 1F11      ROL	R17
    03ED2 1F22      ROL	R18
    03ED3 17A8      CP	R26,R24
    03ED4 07B9      CPC	R27,R25
    03ED5 F014      BLT	0x3ED8
    03ED6 9711      SBIW	R26,1
    03ED7 CFF6      RJMP	0x3ECE
    03ED8 2700      CLR	R16
    03ED9 2711      CLR	R17
    03EDA 2722      CLR	R18
    03EDB 2733      CLR	R19
    03EDC 9189      LD	R24,Y+
    03EDD 9199      LD	R25,Y+
    03EDE 012D      MOVW	R4,R26
    03EDF 91B9      LD	R27,Y+
    03EE0 91A9      LD	R26,Y+
    03EE1 9508      RET
    03EE2 2733      CLR	R19
    03EE3 EF0F      LDI	R16,0xFF
    03EE4 2F10      MOV	R17,R16
    03EE5 E72F      LDI	R18,0x7F
    03EE6 2F32      MOV	R19,R18
    03EE7 9189      LD	R24,Y+
    03EE8 9199      LD	R25,Y+
    03EE9 012D      MOVW	R4,R26
    03EEA C002      RJMP	0x3EED
pack:
    03EEB 93AA      ST	-Y,R26
    03EEC 93BA      ST	-Y,R27
    03EED DFA7      RCALL	tstR16_R19
    03EEE F049      BEQ	0x3EF8
    03EEF 01D2      MOVW	R26,R4
    03EF0 58A1      SUBI	R26,0x81
    03EF1 4FBF      SBCI	R27,0xFF
    03EF2 012D      MOVW	R4,R26
    03EF3 2D34      MOV	R19,R4
    03EF4 0F22      LSL	R18
    03EF5 9536      LSR	R19
    03EF6 9527      ROR	R18
    03EF7 2936      OR	R19,R6
    03EF8 91B9      LD	R27,Y+
    03EF9 91A9      LD	R26,Y+
    03EFA 9508      RET
saveFPRegs:
    03EFB 924A      ST	-Y,R4
    03EFC 925A      ST	-Y,R5
    03EFD 926A      ST	-Y,R6
    03EFE 927A      ST	-Y,R7
    03EFF 928A      ST	-Y,R8
    03F00 929A      ST	-Y,R9
    03F01 92AA      ST	-Y,R10
    03F02 92BA      ST	-Y,R11
    03F03 92CA      ST	-Y,R12
    03F04 92DA      ST	-Y,R13
    03F05 92EA      ST	-Y,R14
    03F06 92FA      ST	-Y,R15
    03F07 938A      ST	-Y,R24
    03F08 939A      ST	-Y,R25
    03F09 9508      RET
restoreFPRegs:
    03F0A 9199      LD	R25,Y+
    03F0B 9189      LD	R24,Y+
    03F0C 90F9      LD	R15,Y+
    03F0D 90E9      LD	R14,Y+
    03F0E 90D9      LD	R13,Y+
    03F0F 90C9      LD	R12,Y+
    03F10 90B9      LD	R11,Y+
    03F11 90A9      LD	R10,Y+
    03F12 9099      LD	R9,Y+
    03F13 9089      LD	R8,Y+
    03F14 9079      LD	R7,Y+
    03F15 9069      LD	R6,Y+
    03F16 9059      LD	R5,Y+
    03F17 9049      LD	R4,Y+
    03F18 9508      RET
fpmule:
    03F19 940E 3EFB CALL	saveFPRegs
    03F1B 93AA      ST	-Y,R26
    03F1C 93BA      ST	-Y,R27
    03F1D 940E 3E9D CALL	unpacku
    03F1F F1E1      BEQ	0x3F5C
    03F20 2CE6      MOV	R14,R6
    03F21 2CD5      MOV	R13,R5
    03F22 2CC4      MOV	R12,R4
    03F23 2EB3      MOV	R11,R19
    03F24 2EA2      MOV	R10,R18
    03F25 2E91      MOV	R9,R17
    03F26 2E80      MOV	R8,R16
    03F27 8100      LD	R16,Z
    03F28 8111      LDD	R17,Z+1
    03F29 8122      LDD	R18,Z+2
    03F2A 8133      LDD	R19,Z+3
    03F2B 940E 3E9D CALL	unpacku
    03F2D F171      BEQ	0x3F5C
    03F2E 246E      EOR	R6,R14
    03F2F 0C4C      ADD	R4,R12
    03F30 1C5D      ADC	R5,R13
    03F31 E880      LDI	R24,0x80
    03F32 1648      CP	R4,R24
    03F33 0653      CPC	R5,R19
    03F34 F564      BGE	0x3F61
    03F35 E881      LDI	R24,0x81
    03F36 1648      CP	R4,R24
    03F37 EF8F      LDI	R24,0xFF
    03F38 0658      CPC	R5,R24
    03F39 F16C      BLT	0x3F67
    03F3A 9EA2      MUL	R10,R18
    03F3B 2DB1      MOV	R27,R1
    03F3C 2DA0      MOV	R26,R0
    03F3D 9E91      MUL	R9,R17
    03F3E 2D91      MOV	R25,R1
    03F3F 2D80      MOV	R24,R0
    03F40 9EA0      MUL	R10,R16
    03F41 0D80      ADD	R24,R0
    03F42 1D91      ADC	R25,R1
    03F43 1FA3      ADC	R26,R19
    03F44 1FB3      ADC	R27,R19
    03F45 9E82      MUL	R8,R18
    03F46 0D80      ADD	R24,R0
    03F47 1D91      ADC	R25,R1
    03F48 1FA3      ADC	R26,R19
    03F49 1FB3      ADC	R27,R19
    03F4A 9E92      MUL	R9,R18
    03F4B 0D90      ADD	R25,R0
    03F4C 1DA1      ADC	R26,R1
    03F4D 1FB3      ADC	R27,R19
    03F4E 9EA1      MUL	R10,R17
    03F4F 0D90      ADD	R25,R0
    03F50 1DA1      ADC	R26,R1
    03F51 1FB3      ADC	R27,R19
    03F52 2F2B      MOV	R18,R27
    03F53 2F1A      MOV	R17,R26
    03F54 2F09      MOV	R16,R25
    03F55 0F88      LSL	R24
    03F56 1F00      ROL	R16
    03F57 1F11      ROL	R17
    03F58 1F22      ROL	R18
    03F59 1F33      ROL	R19
    03F5A 940E 3EB6 CALL	normalize_and_pack
    03F5C 91B9      LD	R27,Y+
    03F5D 91A9      LD	R26,Y+
    03F5E 940E 3F0A CALL	restoreFPRegs
    03F60 9508      RET
    03F61 EF0F      LDI	R16,0xFF
    03F62 2F10      MOV	R17,R16
    03F63 E72F      LDI	R18,0x7F
    03F64 E78F      LDI	R24,0x7F
    03F65 2E48      MOV	R4,R24
    03F66 CFF5      RJMP	0x3F5C
    03F67 2700      CLR	R16
    03F68 2F10      MOV	R17,R16
    03F69 2F20      MOV	R18,R16
    03F6A 2F30      MOV	R19,R16
    03F6B CFF0      RJMP	0x3F5C
fpmule1:
    03F6C 93FA      ST	-Y,R31
    03F6D 93EA      ST	-Y,R30
    03F6E 81EA      LDD	R30,Y+2
    03F6F 81FB      LDD	R31,Y+3
    03F70 940E 3F19 CALL	fpmule
    03F72 91E9      LD	R30,Y+
    03F73 91F9      LD	R31,Y+
    03F74 9622      ADIW	R28,2
    03F75 9508      RET
fpmule2:
    03F76 93FA      ST	-Y,R31
    03F77 93EA      ST	-Y,R30
    03F78 2FEC      MOV	R30,R28
    03F79 2FFD      MOV	R31,R29
    03F7A 9632      ADIW	R30,2
    03F7B 940E 3F19 CALL	fpmule
    03F7D 91E9      LD	R30,Y+
    03F7E 91F9      LD	R31,Y+
    03F7F 9624      ADIW	R28,4
    03F80 9508      RET
fpmule1x:
    03F81 93FA      ST	-Y,R31
    03F82 93EA      ST	-Y,R30
    03F83 81EA      LDD	R30,Y+2
    03F84 81FB      LDD	R31,Y+3
    03F85 940E 3F19 CALL	fpmule
    03F87 91E9      LD	R30,Y+
    03F88 91F9      LD	R31,Y+
    03F89 8339      STD	Y+1,R19
    03F8A 8328      ST	Y,R18
    03F8B 931A      ST	-Y,R17
    03F8C 930A      ST	-Y,R16
    03F8D 9508      RET
fpcmp:
    03F8E 940E 3D34 CALL	fpsub
    03F90 2333      TST	R19
    03F91 F03A      BMI	0x3F99
    03F92 940E 3E95 CALL	tstR16_R19
    03F94 F011      BEQ	0x3F97
    03F95 E001      LDI	R16,1
    03F96 9508      RET
    03F97 2700      CLR	R16
    03F98 9508      RET
    03F99 EF0F      LDI	R16,0xFF
    03F9A 9508      RET
fpcmp2:
    03F9B 93FA      ST	-Y,R31
    03F9C 93EA      ST	-Y,R30
    03F9D 2FEC      MOV	R30,R28
    03F9E 2FFD      MOV	R31,R29
    03F9F 9632      ADIW	R30,2
    03FA0 940E 3F8E CALL	fpcmp
    03FA2 91E9      LD	R30,Y+
    03FA3 91F9      LD	R31,Y+
    03FA4 9624      ADIW	R28,4
    03FA5 2300      TST	R16
    03FA6 9508      RET
_itoa:
    03FA7 940E 3B30 CALL	push_arg4
    03FA9 940E 3C75 CALL	push_xgsetF0FC
    03FAB 01A9      MOVW	R20,R18
    03FAC 84EE      LDD	R14,Y+14
    03FAD 84FF      LDD	R15,Y+15
    03FAE 015A      MOVW	R10,R20
    03FAF 20AA      TST	R10
    03FB0 F451      BNE	0x3FBB
    03FB1 20BB      TST	R11
    03FB2 F441      BNE	0x3FBB
    03FB3 E380      LDI	R24,0x30
    03FB4 85EA      LDD	R30,Y+10
    03FB5 85FB      LDD	R31,Y+11
    03FB6 8380      ST	Z,R24
    03FB7 2422      CLR	R2
    03FB8 8221      STD	Z+1,R2
    03FB9 018F      MOVW	R16,R30
    03FBA C053      RJMP	0x400E
    03FBB 3040      CPI	R20,0
    03FBC E0E0      LDI	R30,0
    03FBD 075E      CPC	R21,R30
    03FBE F46C      BGE	0x3FCC
    03FBF 01C7      MOVW	R24,R14
    03FC0 308A      CPI	R24,0xA
    03FC1 E0E0      LDI	R30,0
    03FC2 079E      CPC	R25,R30
    03FC3 F441      BNE	0x3FCC
    03FC4 24CC      CLR	R12
    03FC5 94C3      INC	R12
    03FC6 01C5      MOVW	R24,R10
    03FC7 9580      COM	R24
    03FC8 9590      COM	R25
    03FC9 9601      ADIW	R24,1
    03FCA 015C      MOVW	R10,R24
    03FCB C001      RJMP	0x3FCD
    03FCC 24CC      CLR	R12
    03FCD 856A      LDD	R22,Y+10
    03FCE 857B      LDD	R23,Y+11
    03FCF 0197      MOVW	R18,R14
    03FD0 0185      MOVW	R16,R10
    03FD1 940E 3B5F CALL	mod16u
    03FD3 01A8      MOVW	R20,R16
    03FD4 E089      LDI	R24,0x9
    03FD5 E090      LDI	R25,0
    03FD6 1780      CP	R24,R16
    03FD7 0791      CPC	R25,R17
    03FD8 F034      BLT	0x3FDF
    03FD9 01CA      MOVW	R24,R20
    03FDA 96C0      ADIW	R24,0x30
    03FDB 01FB      MOVW	R30,R22
    03FDC 9381      ST	Z+,R24
    03FDD 01BF      MOVW	R22,R30
    03FDE C006      RJMP	0x3FE5
    03FDF 01CA      MOVW	R24,R20
    03FE0 5A89      SUBI	R24,0xA9
    03FE1 4F9F      SBCI	R25,0xFF
    03FE2 01FB      MOVW	R30,R22
    03FE3 9381      ST	Z+,R24
    03FE4 01BF      MOVW	R22,R30
    03FE5 0197      MOVW	R18,R14
    03FE6 0185      MOVW	R16,R10
    03FE7 940E 3B61 CALL	div16u
    03FE9 0158      MOVW	R10,R16
    03FEA 20AA      TST	R10
    03FEB F719      BNE	0x3FCF
    03FEC 20BB      TST	R11
    03FED F709      BNE	0x3FCF
    03FEE 20CC      TST	R12
    03FEF F021      BEQ	0x3FF4
    03FF0 E28D      LDI	R24,0x2D
    03FF1 01FB      MOVW	R30,R22
    03FF2 9381      ST	Z+,R24
    03FF3 01BF      MOVW	R22,R30
    03FF4 012B      MOVW	R4,R22
    03FF5 5061      SUBI	R22,1
    03FF6 4070      SBCI	R23,0
    03FF7 2422      CLR	R2
    03FF8 01F2      MOVW	R30,R4
    03FF9 8220      ST	Z,R2
    03FFA 84AA      LDD	R10,Y+10
    03FFB 84BB      LDD	R11,Y+11
    03FFC C00C      RJMP	0x4009
    03FFD 01F5      MOVW	R30,R10
    03FFE 80C0      LD	R12,Z
    03FFF 01FB      MOVW	R30,R22
    04000 8020      LD	R2,Z
    04001 01F5      MOVW	R30,R10
    04002 9221      ST	Z+,R2
    04003 015F      MOVW	R10,R30
    04004 011B      MOVW	R2,R22
    04005 5061      SUBI	R22,1
    04006 4070      SBCI	R23,0
    04007 01F1      MOVW	R30,R2
    04008 82C0      ST	Z,R12
    04009 16A6      CP	R10,R22
    0400A 06B7      CPC	R11,R23
    0400B F388      BCS	0x3FFD
    0400C 850A      LDD	R16,Y+10
    0400D 851B      LDD	R17,Y+11
    0400E 940E 3C6A CALL	pop_xgsetF0FC
    04010 9624      ADIW	R28,4
    04011 9508      RET
_ltoa:
    04012 940E 3B30 CALL	push_arg4
    04014 940E 3C75 CALL	push_xgsetF0FC
    04016 9724      SBIW	R28,4
    04017 8828      LDD	R2,Y+16
    04018 8839      LDD	R3,Y+17
    04019 884A      LDD	R4,Y+18
    0401A 885B      LDD	R5,Y+19
    0401B 8228      ST	Y,R2
    0401C 8239      STD	Y+1,R3
    0401D 824A      STD	Y+2,R4
    0401E 825B      STD	Y+3,R5
    0401F 8828      LDD	R2,Y+16
    04020 8839      LDD	R3,Y+17
    04021 884A      LDD	R4,Y+18
    04022 885B      LDD	R5,Y+19
    04023 9488      BCLR	0
    04024 2022      TST	R2
    04025 0432      CPC	R3,R2
    04026 0442      CPC	R4,R2
    04027 0452      CPC	R5,R2
    04028 F441      BNE	0x4031
    04029 E380      LDI	R24,0x30
    0402A 85EE      LDD	R30,Y+14
    0402B 85FF      LDD	R31,Y+15
    0402C 8380      ST	Z,R24
    0402D 2422      CLR	R2
    0402E 8221      STD	Z+1,R2
    0402F 018F      MOVW	R16,R30
    04030 C094      RJMP	0x40C5
    04031 E040      LDI	R20,0
    04032 E050      LDI	R21,0
    04033 E060      LDI	R22,0
    04034 E070      LDI	R23,0
    04035 8828      LDD	R2,Y+16
    04036 8839      LDD	R3,Y+17
    04037 884A      LDD	R4,Y+18
    04038 885B      LDD	R5,Y+19
    04039 1624      CP	R2,R20
    0403A 0635      CPC	R3,R21
    0403B 0646      CPC	R4,R22
    0403C 0657      CPC	R5,R23
    0403D F4EC      BGE	0x405B
    0403E 898C      LDD	R24,Y+20
    0403F 899D      LDD	R25,Y+21
    04040 308A      CPI	R24,0xA
    04041 E0A0      LDI	R26,0
    04042 079A      CPC	R25,R26
    04043 F4B9      BNE	0x405B
    04044 24AA      CLR	R10
    04045 94A3      INC	R10
    04046 E041      LDI	R20,1
    04047 E050      LDI	R21,0
    04048 E060      LDI	R22,0
    04049 E070      LDI	R23,0
    0404A 8028      LD	R2,Y
    0404B 8039      LDD	R3,Y+1
    0404C 804A      LDD	R4,Y+2
    0404D 805B      LDD	R5,Y+3
    0404E 9420      COM	R2
    0404F 9430      COM	R3
    04050 9440      COM	R4
    04051 9450      COM	R5
    04052 0E24      ADD	R2,R20
    04053 1E35      ADC	R3,R21
    04054 1E46      ADC	R4,R22
    04055 1E57      ADC	R5,R23
    04056 8228      ST	Y,R2
    04057 8239      STD	Y+1,R3
    04058 824A      STD	Y+2,R4
    04059 825B      STD	Y+3,R5
    0405A C001      RJMP	0x405C
    0405B 24AA      CLR	R10
    0405C 84CE      LDD	R12,Y+14
    0405D 84DF      LDD	R13,Y+15
    0405E 882C      LDD	R2,Y+20
    0405F 883D      LDD	R3,Y+21
    04060 2444      CLR	R4
    04061 FC37      SBRC	R3,7
    04062 9440      COM	R4
    04063 2455      CLR	R5
    04064 FC47      SBRC	R4,7
    04065 9450      COM	R5
    04066 8108      LD	R16,Y
    04067 8119      LDD	R17,Y+1
    04068 812A      LDD	R18,Y+2
    04069 813B      LDD	R19,Y+3
    0406A 925A      ST	-Y,R5
    0406B 924A      ST	-Y,R4
    0406C 923A      ST	-Y,R3
    0406D 922A      ST	-Y,R2
    0406E 940E 3B7D CALL	mod32u
    04070 0178      MOVW	R14,R16
    04071 E089      LDI	R24,0x9
    04072 E090      LDI	R25,0
    04073 1780      CP	R24,R16
    04074 0791      CPC	R25,R17
    04075 F034      BLT	0x407C
    04076 01C7      MOVW	R24,R14
    04077 96C0      ADIW	R24,0x30
    04078 01F6      MOVW	R30,R12
    04079 9381      ST	Z+,R24
    0407A 016F      MOVW	R12,R30
    0407B C006      RJMP	0x4082
    0407C 01C7      MOVW	R24,R14
    0407D 5A89      SUBI	R24,0xA9
    0407E 4F9F      SBCI	R25,0xFF
    0407F 01F6      MOVW	R30,R12
    04080 9381      ST	Z+,R24
    04081 016F      MOVW	R12,R30
    04082 882C      LDD	R2,Y+20
    04083 883D      LDD	R3,Y+21
    04084 2444      CLR	R4
    04085 FC37      SBRC	R3,7
    04086 9440      COM	R4
    04087 2455      CLR	R5
    04088 FC47      SBRC	R4,7
    04089 9450      COM	R5
    0408A 8108      LD	R16,Y
    0408B 8119      LDD	R17,Y+1
    0408C 812A      LDD	R18,Y+2
    0408D 813B      LDD	R19,Y+3
    0408E 925A      ST	-Y,R5
    0408F 924A      ST	-Y,R4
    04090 923A      ST	-Y,R3
    04091 922A      ST	-Y,R2
    04092 940E 3B7B CALL	div32u
    04094 8308      ST	Y,R16
    04095 8319      STD	Y+1,R17
    04096 832A      STD	Y+2,R18
    04097 833B      STD	Y+3,R19
    04098 8028      LD	R2,Y
    04099 8039      LDD	R3,Y+1
    0409A 804A      LDD	R4,Y+2
    0409B 805B      LDD	R5,Y+3
    0409C 9488      BCLR	0
    0409D 2022      TST	R2
    0409E 0432      CPC	R3,R2
    0409F 0442      CPC	R4,R2
    040A0 0452      CPC	R5,R2
    040A1 F009      BEQ	0x40A3
    040A2 CFBB      RJMP	0x405E
    040A3 20AA      TST	R10
    040A4 F021      BEQ	0x40A9
    040A5 E28D      LDI	R24,0x2D
    040A6 01F6      MOVW	R30,R12
    040A7 9381      ST	Z+,R24
    040A8 016F      MOVW	R12,R30
    040A9 0126      MOVW	R4,R12
    040AA 01C2      MOVW	R24,R4
    040AB 9701      SBIW	R24,1
    040AC 016C      MOVW	R12,R24
    040AD 2422      CLR	R2
    040AE 01F2      MOVW	R30,R4
    040AF 8220      ST	Z,R2
    040B0 84EE      LDD	R14,Y+14
    040B1 84FF      LDD	R15,Y+15
    040B2 C00D      RJMP	0x40C0
    040B3 01F7      MOVW	R30,R14
    040B4 80A0      LD	R10,Z
    040B5 01F6      MOVW	R30,R12
    040B6 8020      LD	R2,Z
    040B7 01F7      MOVW	R30,R14
    040B8 9221      ST	Z+,R2
    040B9 017F      MOVW	R14,R30
    040BA 0116      MOVW	R2,R12
    040BB 01C1      MOVW	R24,R2
    040BC 9701      SBIW	R24,1
    040BD 016C      MOVW	R12,R24
    040BE 01F1      MOVW	R30,R2
    040BF 82A0      ST	Z,R10
    040C0 14EC      CP	R14,R12
    040C1 04FD      CPC	R15,R13
    040C2 F380      BCS	0x40B3
    040C3 850E      LDD	R16,Y+14
    040C4 851F      LDD	R17,Y+15
    040C5 9624      ADIW	R28,4
    040C6 940E 3C6A CALL	pop_xgsetF0FC
    040C8 9624      ADIW	R28,4
    040C9 9508      RET
_ftoa:
    040CA 940E 3B30 CALL	push_arg4
    040CC 940E 3C75 CALL	push_xgsetF0FC
    040CE 9764      SBIW	R28,0x14
    040CF A0CA      LDD	R12,Y+34
    040D0 A0DB      LDD	R13,Y+35
    040D1 2422      CLR	R2
    040D2 2433      CLR	R3
    040D3 01F6      MOVW	R30,R12
    040D4 8231      STD	Z+1,R3
    040D5 8220      ST	Z,R2
    040D6 8C2E      LDD	R2,Y+30
    040D7 8C3F      LDD	R3,Y+31
    040D8 A048      LDD	R4,Y+32
    040D9 A059      LDD	R5,Y+33
    040DA EC0C      LDI	R16,0xCC
    040DB E010      LDI	R17,0
    040DC 940E 3BFD CALL	elpm32
    040DE 933A      ST	-Y,R19
    040DF 932A      ST	-Y,R18
    040E0 931A      ST	-Y,R17
    040E1 930A      ST	-Y,R16
    040E2 0181      MOVW	R16,R2
    040E3 0192      MOVW	R18,R4
    040E4 940E 3F9B CALL	fpcmp2
    040E6 F479      BNE	0x40F6
    040E7 E380      LDI	R24,0x30
    040E8 9380 0757 STS	config+17,R24
    040EA E28E      LDI	R24,0x2E
    040EB 9380 0758 STS	config+18,R24
    040ED E380      LDI	R24,0x30
    040EE 9380 0759 STS	config+19,R24
    040F0 2422      CLR	R2
    040F1 9220 075A STS	config+20,R2
    040F3 E507      LDI	R16,0x57
    040F4 E017      LDI	R17,7
    040F5 C15E      RJMP	0x4254
    040F6 8C2E      LDD	R2,Y+30
    040F7 8C3F      LDD	R3,Y+31
    040F8 A048      LDD	R4,Y+32
    040F9 A059      LDD	R5,Y+33
    040FA 8628      STD	Y+8,R2
    040FB 8639      STD	Y+9,R3
    040FC 864A      STD	Y+10,R4
    040FD 865B      STD	Y+11,R5
    040FE E187      LDI	R24,0x17
    040FF E090      LDI	R25,0
    04100 8508      LDD	R16,Y+8
    04101 8519      LDD	R17,Y+9
    04102 852A      LDD	R18,Y+10
    04103 853B      LDD	R19,Y+11
    04104 938A      ST	-Y,R24
    04105 940E 3B35 CALL	asr32
    04107 2F80      MOV	R24,R16
    04108 2799      CLR	R25
    04109 578F      SUBI	R24,0x7F
    0410A 4090      SBCI	R25,0
    0410B 015C      MOVW	R10,R24
    0410C EF4F      LDI	R20,0xFF
    0410D EF5F      LDI	R21,0xFF
    0410E EF6F      LDI	R22,0xFF
    0410F E070      LDI	R23,0
    04110 8428      LDD	R2,Y+8
    04111 8439      LDD	R3,Y+9
    04112 844A      LDD	R4,Y+10
    04113 845B      LDD	R5,Y+11
    04114 2224      AND	R2,R20
    04115 2235      AND	R3,R21
    04116 2246      AND	R4,R22
    04117 2257      AND	R5,R23
    04118 93EF      PUSH	R30
    04119 2DE4      MOV	R30,R4
    0411A 68E0      ORI	R30,0x80
    0411B 2E4E      MOV	R4,R30
    0411C 91EF      POP	R30
    0411D 8A28      STD	Y+16,R2
    0411E 8A39      STD	Y+17,R3
    0411F 8A4A      STD	Y+18,R4
    04120 8A5B      STD	Y+19,R5
    04121 E080      LDI	R24,0
    04122 838C      STD	Y+4,R24
    04123 838D      STD	Y+5,R24
    04124 838E      STD	Y+6,R24
    04125 838F      STD	Y+7,R24
    04126 E080      LDI	R24,0
    04127 878C      STD	Y+12,R24
    04128 878D      STD	Y+13,R24
    04129 878E      STD	Y+14,R24
    0412A 878F      STD	Y+15,R24
    0412B 01C5      MOVW	R24,R10
    0412C 318F      CPI	R24,0x1F
    0412D E0E0      LDI	R30,0
    0412E 079E      CPC	R25,R30
    0412F F044      BLT	0x4138
    04130 EF8E      LDI	R24,0xFE
    04131 EF9F      LDI	R25,0xFF
    04132 01F6      MOVW	R30,R12
    04133 8391      STD	Z+1,R25
    04134 8380      ST	Z,R24
    04135 2700      CLR	R16
    04136 2711      CLR	R17
    04137 C11C      RJMP	0x4254
    04138 01C5      MOVW	R24,R10
    04139 3E89      CPI	R24,0xE9
    0413A EFEF      LDI	R30,0xFF
    0413B 079E      CPC	R25,R30
    0413C F444      BGE	0x4145
    0413D EF8F      LDI	R24,0xFF
    0413E EF9F      LDI	R25,0xFF
    0413F 01F6      MOVW	R30,R12
    04140 8391      STD	Z+1,R25
    04141 8380      ST	Z,R24
    04142 2700      CLR	R16
    04143 2711      CLR	R17
    04144 C10F      RJMP	0x4254
    04145 01C5      MOVW	R24,R10
    04146 3187      CPI	R24,0x17
    04147 E0A0      LDI	R26,0
    04148 079A      CPC	R25,R26
    04149 F06C      BLT	0x4157
    0414A 9747      SBIW	R24,0x17
    0414B 8908      LDD	R16,Y+16
    0414C 8919      LDD	R17,Y+17
    0414D 892A      LDD	R18,Y+18
    0414E 893B      LDD	R19,Y+19
    0414F 938A      ST	-Y,R24
    04150 940E 3CF7 CALL	lsl32
    04152 870C      STD	Y+12,R16
    04153 871D      STD	Y+13,R17
    04154 872E      STD	Y+14,R18
    04155 873F      STD	Y+15,R19
    04156 C045      RJMP	0x419C
    04157 01C5      MOVW	R24,R10
    04158 3080      CPI	R24,0
    04159 E0A0      LDI	R26,0
    0415A 079A      CPC	R25,R26
    0415B F13C      BLT	0x4183
    0415C E187      LDI	R24,0x17
    0415D E090      LDI	R25,0
    0415E 198A      SUB	R24,R10
    0415F 099B      SBC	R25,R11
    04160 8908      LDD	R16,Y+16
    04161 8919      LDD	R17,Y+17
    04162 892A      LDD	R18,Y+18
    04163 893B      LDD	R19,Y+19
    04164 938A      ST	-Y,R24
    04165 940E 3B35 CALL	asr32
    04167 870C      STD	Y+12,R16
    04168 871D      STD	Y+13,R17
    04169 872E      STD	Y+14,R18
    0416A 873F      STD	Y+15,R19
    0416B 01C5      MOVW	R24,R10
    0416C 9601      ADIW	R24,1
    0416D 8908      LDD	R16,Y+16
    0416E 8919      LDD	R17,Y+17
    0416F 892A      LDD	R18,Y+18
    04170 893B      LDD	R19,Y+19
    04171 938A      ST	-Y,R24
    04172 940E 3CF7 CALL	lsl32
    04174 0118      MOVW	R2,R16
    04175 0129      MOVW	R4,R18
    04176 EF4F      LDI	R20,0xFF
    04177 EF5F      LDI	R21,0xFF
    04178 EF6F      LDI	R22,0xFF
    04179 E070      LDI	R23,0
    0417A 2224      AND	R2,R20
    0417B 2235      AND	R3,R21
    0417C 2246      AND	R4,R22
    0417D 2257      AND	R5,R23
    0417E 822C      STD	Y+4,R2
    0417F 823D      STD	Y+5,R3
    04180 824E      STD	Y+6,R4
    04181 825F      STD	Y+7,R5
    04182 C019      RJMP	0x419C
    04183 EF4F      LDI	R20,0xFF
    04184 EF5F      LDI	R21,0xFF
    04185 EF6F      LDI	R22,0xFF
    04186 E070      LDI	R23,0
    04187 8908      LDD	R16,Y+16
    04188 8919      LDD	R17,Y+17
    04189 892A      LDD	R18,Y+18
    0418A 893B      LDD	R19,Y+19
    0418B 2304      AND	R16,R20
    0418C 2315      AND	R17,R21
    0418D 2326      AND	R18,R22
    0418E 2337      AND	R19,R23
    0418F 01C5      MOVW	R24,R10
    04190 9601      ADIW	R24,1
    04191 9580      COM	R24
    04192 9590      COM	R25
    04193 5F8F      SUBI	R24,0xFF
    04194 4F9F      SBCI	R25,0xFF
    04195 938A      ST	-Y,R24
    04196 940E 3B35 CALL	asr32
    04198 830C      STD	Y+4,R16
    04199 831D      STD	Y+5,R17
    0419A 832E      STD	Y+6,R18
    0419B 833F      STD	Y+7,R19
    0419C E587      LDI	R24,0x57
    0419D E097      LDI	R25,7
    0419E 015C      MOVW	R10,R24
    0419F E040      LDI	R20,0
    041A0 E050      LDI	R21,0
    041A1 E060      LDI	R22,0
    041A2 E070      LDI	R23,0
    041A3 8428      LDD	R2,Y+8
    041A4 8439      LDD	R3,Y+9
    041A5 844A      LDD	R4,Y+10
    041A6 845B      LDD	R5,Y+11
    041A7 1624      CP	R2,R20
    041A8 0635      CPC	R3,R21
    041A9 0646      CPC	R4,R22
    041AA 0657      CPC	R5,R23
    041AB F424      BGE	0x41B0
    041AC E28D      LDI	R24,0x2D
    041AD 01F5      MOVW	R30,R10
    041AE 9381      ST	Z+,R24
    041AF 015F      MOVW	R10,R30
    041B0 842C      LDD	R2,Y+12
    041B1 843D      LDD	R3,Y+13
    041B2 844E      LDD	R4,Y+14
    041B3 845F      LDD	R5,Y+15
    041B4 9488      BCLR	0
    041B5 2022      TST	R2
    041B6 0432      CPC	R3,R2
    041B7 0442      CPC	R4,R2
    041B8 0452      CPC	R5,R2
    041B9 F429      BNE	0x41BF
    041BA E380      LDI	R24,0x30
    041BB 01F5      MOVW	R30,R10
    041BC 9381      ST	Z+,R24
    041BD 015F      MOVW	R10,R30
    041BE C016      RJMP	0x41D5
    041BF E08A      LDI	R24,0xA
    041C0 E090      LDI	R25,0
    041C1 839B      STD	Y+3,R25
    041C2 838A      STD	Y+2,R24
    041C3 842C      LDD	R2,Y+12
    041C4 843D      LDD	R3,Y+13
    041C5 844E      LDD	R4,Y+14
    041C6 845F      LDD	R5,Y+15
    041C7 8248      ST	Y,R4
    041C8 8259      STD	Y+1,R5
    041C9 0191      MOVW	R18,R2
    041CA 0185      MOVW	R16,R10
    041CB 940E 4012 CALL	_ltoa
    041CD C003      RJMP	0x41D1
    041CE 01C5      MOVW	R24,R10
    041CF 9601      ADIW	R24,1
    041D0 015C      MOVW	R10,R24
    041D1 01F5      MOVW	R30,R10
    041D2 8020      LD	R2,Z
    041D3 2022      TST	R2
    041D4 F7C9      BNE	0x41CE
    041D5 E28E      LDI	R24,0x2E
    041D6 01F5      MOVW	R30,R10
    041D7 9381      ST	Z+,R24
    041D8 015F      MOVW	R10,R30
    041D9 802C      LDD	R2,Y+4
    041DA 803D      LDD	R3,Y+5
    041DB 804E      LDD	R4,Y+6
    041DC 805F      LDD	R5,Y+7
    041DD 9488      BCLR	0
    041DE 2022      TST	R2
    041DF 0432      CPC	R3,R2
    041E0 0442      CPC	R4,R2
    041E1 0452      CPC	R5,R2
    041E2 F421      BNE	0x41E7
    041E3 E380      LDI	R24,0x30
    041E4 9381      ST	Z+,R24
    041E5 015F      MOVW	R10,R30
    041E6 C068      RJMP	0x424F
    041E7 E587      LDI	R24,0x57
    041E8 E097      LDI	R25,7
    041E9 0115      MOVW	R2,R10
    041EA 1A28      SUB	R2,R24
    041EB 0A39      SBC	R3,R25
    041EC E08F      LDI	R24,0xF
    041ED E090      LDI	R25,0
    041EE 1982      SUB	R24,R2
    041EF 0993      SBC	R25,R3
    041F0 9701      SBIW	R24,1
    041F1 2EC8      MOV	R12,R24
    041F2 E087      LDI	R24,7
    041F3 158C      CP	R24,R12
    041F4 F408      BCC	0x41F6
    041F5 2EC8      MOV	R12,R24
    041F6 24EE      CLR	R14
    041F7 C042      RJMP	0x423A
    041F8 E083      LDI	R24,3
    041F9 E090      LDI	R25,0
    041FA 810C      LDD	R16,Y+4
    041FB 811D      LDD	R17,Y+5
    041FC 812E      LDD	R18,Y+6
    041FD 813F      LDD	R19,Y+7
    041FE 938A      ST	-Y,R24
    041FF 940E 3CF7 CALL	lsl32
    04201 0118      MOVW	R2,R16
    04202 0129      MOVW	R4,R18
    04203 806C      LDD	R6,Y+4
    04204 807D      LDD	R7,Y+5
    04205 808E      LDD	R8,Y+6
    04206 809F      LDD	R9,Y+7
    04207 0C66      LSL	R6
    04208 1C77      ROL	R7
    04209 1C88      ROL	R8
    0420A 1C99      ROL	R9
    0420B 0C26      ADD	R2,R6
    0420C 1C37      ADC	R3,R7
    0420D 1C48      ADC	R4,R8
    0420E 1C59      ADC	R5,R9
    0420F 822C      STD	Y+4,R2
    04210 823D      STD	Y+5,R3
    04211 824E      STD	Y+6,R4
    04212 825F      STD	Y+7,R5
    04213 E188      LDI	R24,0x18
    04214 E090      LDI	R25,0
    04215 810C      LDD	R16,Y+4
    04216 811D      LDD	R17,Y+5
    04217 812E      LDD	R18,Y+6
    04218 813F      LDD	R19,Y+7
    04219 938A      ST	-Y,R24
    0421A 940E 3B35 CALL	asr32
    0421C 0118      MOVW	R2,R16
    0421D 0129      MOVW	R4,R18
    0421E E340      LDI	R20,0x30
    0421F E050      LDI	R21,0
    04220 E060      LDI	R22,0
    04221 E070      LDI	R23,0
    04222 0E24      ADD	R2,R20
    04223 1E35      ADC	R3,R21
    04224 1E46      ADC	R4,R22
    04225 1E57      ADC	R5,R23
    04226 01F5      MOVW	R30,R10
    04227 9221      ST	Z+,R2
    04228 015F      MOVW	R10,R30
    04229 EF4F      LDI	R20,0xFF
    0422A EF5F      LDI	R21,0xFF
    0422B EF6F      LDI	R22,0xFF
    0422C E070      LDI	R23,0
    0422D 802C      LDD	R2,Y+4
    0422E 803D      LDD	R3,Y+5
    0422F 804E      LDD	R4,Y+6
    04230 805F      LDD	R5,Y+7
    04231 2224      AND	R2,R20
    04232 2235      AND	R3,R21
    04233 2246      AND	R4,R22
    04234 2257      AND	R5,R23
    04235 822C      STD	Y+4,R2
    04236 823D      STD	Y+5,R3
    04237 824E      STD	Y+6,R4
    04238 825F      STD	Y+7,R5
    04239 94E3      INC	R14
    0423A 14EC      CP	R14,R12
    0423B F408      BCC	0x423D
    0423C CFBB      RJMP	0x41F8
    0423D 01C5      MOVW	R24,R10
    0423E 9701      SBIW	R24,1
    0423F 015C      MOVW	R10,R24
    04240 C003      RJMP	0x4244
    04241 01C5      MOVW	R24,R10
    04242 9701      SBIW	R24,1
    04243 015C      MOVW	R10,R24
    04244 01F5      MOVW	R30,R10
    04245 8180      LD	R24,Z
    04246 3380      CPI	R24,0x30
    04247 F421      BNE	0x424C
    04248 9731      SBIW	R30,1
    04249 8180      LD	R24,Z
    0424A 328E      CPI	R24,0x2E
    0424B F7A9      BNE	0x4241
    0424C 01C5      MOVW	R24,R10
    0424D 9601      ADIW	R24,1
    0424E 015C      MOVW	R10,R24
    0424F 2422      CLR	R2
    04250 01F5      MOVW	R30,R10
    04251 8220      ST	Z,R2
    04252 E507      LDI	R16,0x57
    04253 E017      LDI	R17,7
    04254 9664      ADIW	R28,0x14
    04255 940E 3C6A CALL	pop_xgsetF0FC
    04257 9624      ADIW	R28,4
    04258 9508      RET
