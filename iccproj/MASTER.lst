Interrupt Vectors
    00000 940C 02A3 JMP	__start|__text_start
    0003C 940C 38FB JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    002A3 EFCF      LDI	R28,0xFF
    002A4 E1D0      LDI	R29,0x10
    002A5 BFCD      OUT	0x3D,R28
    002A6 BFDE      OUT	0x3E,R29
    002A7 51CE      SUBI	R28,0x1E
    002A8 40D0      SBCI	R29,0
    002A9 EA0A      LDI	R16,0xAA
    002AA 8308      ST	Y,R16
    002AB 2400      CLR	R0
    002AC E7E5      LDI	R30,0x75
    002AD E0F5      LDI	R31,5
    002AE E018      LDI	R17,0x8
    002AF 35EE      CPI	R30,0x5E
    002B0 07F1      CPC	R31,R17
    002B1 F011      BEQ	0x02B4
    002B2 9201      ST	Z+,R0
    002B3 CFFB      RJMP	0x02AF
    002B4 8300      ST	Z,R16
    002B5 EDE0      LDI	R30,0xD0
    002B6 E0F0      LDI	R31,0
    002B7 E0A0      LDI	R26,0
    002B8 E0B1      LDI	R27,1
    002B9 E015      LDI	R17,5
    002BA E000      LDI	R16,0
    002BB BF0B      OUT	0x3B,R16
    002BC 34E5      CPI	R30,0x45
    002BD 07F1      CPC	R31,R17
    002BE F021      BEQ	0x02C3
    002BF 95C8      LPM
    002C0 9631      ADIW	R30,1
    002C1 920D      ST	X+,R0
    002C2 CFF9      RJMP	0x02BC
    002C3 940E 2494 CALL	_main
_exit:
    002C5 CFFF      RJMP	_exit
_disk_initialize:
  state                --> R20
  drv                  --> R10
    002C6 92AA      ST	-Y,R10
    002C7 934A      ST	-Y,R20
    002C8 2EA0      MOV	R10,R16
FILE: D:\LQD\software\software_src\diskio.c
(0001) 
(0002) 
(0003) /*-----------------------------------------------------------------------*/
(0004) /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
(0005) /*-----------------------------------------------------------------------*/
(0006) /* This is a stub disk I/O module that acts as front end of the existing */
(0007) /* disk I/O modules and attach it to FatFs module with common interface. */
(0008) /*-----------------------------------------------------------------------*/
(0009) 
(0010) #include "diskio.h"
(0011) #include "sd.h"
(0012) 
(0013) 
(0014) /*-----------------------------------------------------------------------*/
(0015) /* Correspondence between physical drive number and physical drive.      */
(0016) /* Note that Tiny-FatFs supports only single drive and always            */
(0017)                                       
(0018) 
(0019) ////////////////////////////
(0020) /*
(0021)    struct tm {
(0022)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0023)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0024) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0025) 	int tm_mday;  // 日 day of the month, 1 to 31
(0026) 	int tm_mon;   // 月 months since January, 0 to 11
(0027) 	int tm_year;  // 年 years since 1900
(0028) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0029) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0030)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0031)  	};
(0032) */
(0033) /*-----------------------------------------------------------------------*/
(0034) /* Inidialize a Drive                                                    */
(0035) 
(0036) DSTATUS disk_initialize ( 
(0037) BYTE drv				/* Physical drive nmuber (0..) */
(0038) )
(0039) {
(0040)     unsigned char state;
(0041) 
(0042)     if(drv)
    002C9 20AA      TST	R10
    002CA F011      BEQ	0x02CD
(0043)     {
(0044)         return STA_NOINIT;  //仅支持磁盘0的操作
    002CB E001      LDI	R16,1
    002CC C00C      RJMP	0x02D9
(0045)     }
(0046) 
(0047)     state = SD_Init();
    002CD 940E 2C3A CALL	_SD_Init
    002CF 2F40      MOV	R20,R16
(0048)     if(state == STA_NODISK)
    002D0 3002      CPI	R16,2
    002D1 F411      BNE	0x02D4
(0049)     {
(0050)         return STA_NODISK;
    002D2 E002      LDI	R16,2
    002D3 C005      RJMP	0x02D9
(0051)     }
(0052)     else if(state != 0)
    002D4 2344      TST	R20
    002D5 F011      BEQ	0x02D8
(0053)     {
(0054)         return STA_NOINIT;  //其他错误：初始化失败
    002D6 E001      LDI	R16,1
    002D7 C001      RJMP	0x02D9
(0055)     }
(0056)     else
(0057)     {
(0058)         return 0;           //初始化成功
    002D8 2700      CLR	R16
    002D9 9149      LD	R20,Y+
    002DA 90A9      LD	R10,Y+
    002DB 9508      RET
(0059)     }
(0060) }
(0061) 
(0062) 
(0063) 
(0064) /*-----------------------------------------------------------------------*/
(0065) /* Return Disk Status                                                    */
(0066) 
(0067) DSTATUS disk_status (
(0068) 	BYTE drv		/* Physical drive nmuber (0..) */
(0069) )
(0070) {
(0071)     if(drv)
_disk_status:
  drv                  --> R16
    002DC 2300      TST	R16
    002DD F011      BEQ	0x02E0
(0072)     {
(0073)         return STA_NOINIT;  //仅支持磁盘0操作
    002DE E001      LDI	R16,1
    002DF C001      RJMP	0x02E1
(0074)     }
(0075)     return 0;
    002E0 2700      CLR	R16
    002E1 9508      RET
_disk_read:
  res                  --> R10
  count                --> R20
  sector               --> Y,+10
  buff                 --> R12
  drv                  --> R14
    002E2 940E 42A6 CALL	push_xgset30FC
    002E4 0169      MOVW	R12,R18
    002E5 2EE0      MOV	R14,R16
    002E6 9722      SBIW	R28,2
    002E7 854E      LDD	R20,Y+14
(0076) }
(0077) 
(0078) 
(0079) 
(0080) /*-----------------------------------------------------------------------*/
(0081) /* Read Sector(s)                                                        */
(0082) 
(0083) DRESULT disk_read (
(0084) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0085) 	BYTE *buff,		/* Data buffer to store read data */
(0086) 	DWORD sector,	/* Sector address (LBA) */
(0087) 	BYTE count		/* Number of sectors to read (1..255) */
(0088) )
(0089) {
(0090) 	unsigned char res=0;
    002E8 24AA      CLR	R10
(0091)     if (drv || !count)
    002E9 20EE      TST	R14
    002EA F411      BNE	0x02ED
    002EB 2344      TST	R20
    002EC F411      BNE	0x02EF
(0092)     {    
(0093)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002ED E004      LDI	R16,4
    002EE C010      RJMP	0x02FF
(0094)     }
(0095) 
(0096)     if(count==1)            //1个sector的读操作      
    002EF 3041      CPI	R20,1
    002F0 F449      BNE	0x02FA
(0097)     {                                                
(0098)         res = SD_Read_Sector(sector, buff);      
    002F1 82D9      STD	Y+1,R13
    002F2 82C8      ST	Y,R12
    002F3 850A      LDD	R16,Y+10
    002F4 851B      LDD	R17,Y+11
    002F5 852C      LDD	R18,Y+12
    002F6 853D      LDD	R19,Y+13
    002F7 940E 2D20 CALL	_SD_Read_Sector
    002F9 2EA0      MOV	R10,R16
(0099)     }                                                                                                 
(0100) 
(0101)     //处理返回值，将SD_driver.c的返回值转成ff.c的返回值
(0102)     if(res == 0x00)
    002FA 20AA      TST	R10
    002FB F411      BNE	0x02FE
(0103)     {
(0104)         return RES_OK;
    002FC 2700      CLR	R16
    002FD C001      RJMP	0x02FF
(0105)     }
(0106)     else
(0107)     {
(0108)         return RES_ERROR;
    002FE E001      LDI	R16,1
    002FF 9622      ADIW	R28,2
    00300 940C 4290 JMP	pop_xgset30FC
_disk_write:
  count                --> R12
  sector               --> Y,+8
  buff                 --> R10
  drv                  --> R14
    00302 940E 42A8 CALL	push_xgset00FC
    00304 0159      MOVW	R10,R18
    00305 2EE0      MOV	R14,R16
    00306 9722      SBIW	R28,2
    00307 84CC      LDD	R12,Y+12
(0109)     }
(0110) }
(0111) 
(0112) 
(0113) 
(0114) /*-----------------------------------------------------------------------*/
(0115) /* Write Sector(s)                                                       */
(0116) 
(0117) #if _READONLY == 0
(0118) DRESULT disk_write (
(0119) 	BYTE drv,			/* Physical drive nmuber (0..) */
(0120) 	BYTE *buff,	        /* Data to be written */
(0121) 	DWORD sector,		/* Sector address (LBA) */
(0122) 	BYTE count			/* Number of sectors to write (1..255) */
(0123) )
(0124) {
(0125)     if (drv || !count)
    00308 20EE      TST	R14
    00309 F411      BNE	0x030C
    0030A 20CC      TST	R12
    0030B F411      BNE	0x030E
(0126)     {    
(0127)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    0030C E004      LDI	R16,4
    0030D C009      RJMP	0x0317
(0128)     }   
(0129)    // 读写操作
(0130)     SD_Write_Sector(sector,buff);
    0030E 82B9      STD	Y+1,R11
    0030F 82A8      ST	Y,R10
    00310 8508      LDD	R16,Y+8
    00311 8519      LDD	R17,Y+9
    00312 852A      LDD	R18,Y+10
    00313 853B      LDD	R19,Y+11
    00314 940E 2C9A CALL	_SD_Write_Sector
(0131) 	  
(0132)     return RES_OK;
    00316 2700      CLR	R16
    00317 9622      ADIW	R28,2
    00318 940C 4289 JMP	pop_xgset00FC
_disk_ioctl:
  buff                 --> Y,+4
  ctrl                 --> Y,+2
  drv                  --> Y,+0
    0031A 940E 415F CALL	push_arg4
(0133) }
(0134) #endif /* _READONLY */
(0135) 
(0136) 
(0137) 
(0138) /*-----------------------------------------------------------------------*/
(0139) /* Miscellaneous Functions                                               */
(0140) DRESULT disk_ioctl (
(0141) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0142) 	BYTE ctrl,		/* Control code */
(0143) 	void *buff		/* Buffer to send/receive control data */
(0144) )
(0145) {
(0146)  	drv=drv;
(0147) 	ctrl=ctrl;
(0148) 	buff=buff;
(0149) 	return 0;
    0031C 2700      CLR	R16
    0031D 9624      ADIW	R28,4
    0031E 9508      RET
(0150) }
(0151) DWORD get_fattime (void)
(0152) {
(0153) 
(0154)   return 1950466005;
_get_fattime:
    0031F ED05      LDI	R16,0xD5
    00320 EB1F      LDI	R17,0xBF
    00321 E421      LDI	R18,0x41
    00322 E734      LDI	R19,0x74
    00323 9508      RET
ff.c:mem_cpy:
  s                    --> R12
  d                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    00324 940E 42D1 CALL	push_xgset303C
    00326 814E      LDD	R20,Y+6
    00327 815F      LDD	R21,Y+7
FILE: D:\LQD\software\software_src\ff.c
(0001) /*----------------------------------------------------------------------------/
(0002) /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
(0003) /-----------------------------------------------------------------------------/
(0004) / FatFs module is a generic FAT file system module for small embedded systems.
(0005) / This is a free software that opened for education, research and commercial
(0006) / developments under license policy of following terms.
(0007) /
(0008) /  Copyright (C) 2011, ChaN, all right reserved.
(0009) /
(0010) / * The FatFs module is a free software and there is NO WARRANTY.
(0011) / * No restriction on use. You can use, modify and redistribute it for
(0012) /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
(0013) / * Redistributions of source code must retain the above copyright notice.
(0014) /
(0015) /-----------------------------------------------------------------------------/
(0016) / Feb 26,'06 R0.00  Prototype.
(0017) /
(0018) / Apr 29,'06 R0.01  First stable version.
(0019) /
(0020) / Jun 01,'06 R0.02  Added FAT12 support.
(0021) /                   Removed unbuffered mode.
(0022) /                   Fixed a problem on small (<32M) partition.
(0023) / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
(0024) /
(0025) / Sep 22,'06 R0.03  Added f_rename().
(0026) /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
(0027) / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
(0028) /                   Fixed f_mkdir() creates incorrect directory on FAT32.
(0029) /
(0030) / Feb 04,'07 R0.04  Supported multiple drive system.
(0031) /                   Changed some interfaces for multiple drive system.
(0032) /                   Changed f_mountdrv() to f_mount().
(0033) /                   Added f_mkfs().
(0034) / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
(0035) /                   Added a capability of extending file size to f_lseek().
(0036) /                   Added minimization level 3.
(0037) /                   Fixed an endian sensitive code in f_mkfs().
(0038) / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
(0039) /                   Added FSInfo support.
(0040) /                   Fixed DBCS name can result FR_INVALID_NAME.
(0041) /                   Fixed short seek (<= csize) collapses the file object.
(0042) /
(0043) / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
(0044) /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
(0045) /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
(0046) / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
(0047) /                   Fixed off by one error at FAT sub-type determination.
(0048) /                   Fixed btr in f_read() can be mistruncated.
(0049) /                   Fixed cached sector is not flushed when create and close without write.
(0050) /
(0051) / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
(0052) /                   Improved performance of f_lseek() on moving to the same or following cluster.
(0053) /
(0054) / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
(0055) /                   Added long file name feature.
(0056) /                   Added multiple code page feature.
(0057) /                   Added re-entrancy for multitask operation.
(0058) /                   Added auto cluster size selection to f_mkfs().
(0059) /                   Added rewind option to f_readdir().
(0060) /                   Changed result code of critical errors.
(0061) /                   Renamed string functions to avoid name collision.
(0062) / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
(0063) /                   Added multiple sector size feature.
(0064) / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
(0065) /                   Fixed wrong cache control in f_lseek().
(0066) /                   Added relative path feature.
(0067) /                   Added f_chdir() and f_chdrive().
(0068) /                   Added proper case conversion to extended char.
(0069) / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
(0070) /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
(0071) /                   Fixed name matching error on the 13 char boundary.
(0072) /                   Added a configuration option, _LFN_UNICODE.
(0073) /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
(0074) /
(0075) / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
(0076) /                   Added file lock feature. (_FS_SHARE)
(0077) /                   Added fast seek feature. (_USE_FASTSEEK)
(0078) /                   Changed some types on the API, XCHAR->TCHAR.
(0079) /                   Changed fname member in the FILINFO structure on Unicode cfg.
(0080) /                   String functions support UTF-8 encoding files on Unicode cfg.
(0081) / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
(0082) /                   Added sector erase feature. (_USE_ERASE)
(0083) /                   Moved file lock semaphore table from fs object to the bss.
(0084) /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
(0085) /                   Fixed f_mkfs() creates wrong FAT32 volume.
(0086) / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
(0087) /                   f_lseek() reports required table size on creating CLMP.
(0088) /                   Extended format syntax of f_printf function.
(0089) /                   Ignores duplicated directory separators in given path names.
(0090) /
(0091) / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
(0092) /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
(0093) /---------------------------------------------------------------------------*/
(0094) 
(0095) #include "ff.h"			/* FatFs configurations and declarations */
(0096) #include "diskio.h"		/* Declarations of low level disk I/O functions */
(0097) #include <string.h>
(0098) 
(0099) /*--------------------------------------------------------------------------
(0100) 
(0101)    Module Private Definitions
(0102) 
(0103) ---------------------------------------------------------------------------*/
(0104) 
(0105) #if _FATFS != 6502	/* Revision ID */
(0106) #error Wrong include file (ff.h).
(0107) #endif
(0108) 
(0109) 
(0110) /* Definitions on sector size */
(0111) #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
(0112) #error Wrong sector size.
(0113) #endif
(0114) #if _MAX_SS != 512
(0115) #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
(0116) #else
(0117) #define	SS(fs)	512U			/* Fixed sector size */
(0118) #endif
(0119) 
(0120) 
(0121) /* Reentrancy related */
(0122) #if _FS_REENTRANT
(0123) #if _USE_LFN == 1
(0124) #error Static LFN work area must not be used in re-entrant configuration.
(0125) #endif
(0126) #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
(0127) #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
(0128) #else
(0129) #define	ENTER_FF(fs)
(0130) #define LEAVE_FF(fs, res)	return res
(0131) #endif
(0132) 
(0133) #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
(0134) 
(0135) 
(0136) /* File shareing feature */
(0137) #if _FS_SHARE
(0138) #if _FS_READONLY
(0139) #error _FS_SHARE must be 0 on read-only cfg.
(0140) #endif
(0141) typedef struct {
(0142) 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
(0143) 	DWORD clu;				/* File ID 2, directory */
(0144) 	WORD idx;				/* File ID 3, directory index */
(0145) 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
(0146) } FILESEM;
(0147) #endif
(0148) 
(0149) 
(0150) /* Misc definitions */
(0151) #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
(0152) #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
(0153) 
(0154) 
(0155) /* DBCS code ranges and SBCS extend char conversion table */
(0156) 
(0157) #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
(0158) #define _DF1S	0x81	/* DBC 1st byte range 1 start */
(0159) #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
(0160) #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
(0161) #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
(0162) #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
(0163) #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
(0164) #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
(0165) #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
(0166) 
(0167) #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
(0168) #define _DF1S	0x81
(0169) #define _DF1E	0xFE
(0170) #define _DS1S	0x40
(0171) #define _DS1E	0x7E
(0172) #define _DS2S	0x80
(0173) #define _DS2E	0xFE
(0174) 
(0175) #elif _CODE_PAGE == 949	/* Korean */
(0176) #define _DF1S	0x81
(0177) #define _DF1E	0xFE
(0178) #define _DS1S	0x41
(0179) #define _DS1E	0x5A
(0180) #define _DS2S	0x61
(0181) #define _DS2E	0x7A
(0182) #define _DS3S	0x81
(0183) #define _DS3E	0xFE
(0184) 
(0185) #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
(0186) #define _DF1S	0x81
(0187) #define _DF1E	0xFE
(0188) #define _DS1S	0x40
(0189) #define _DS1E	0x7E
(0190) #define _DS2S	0xA1
(0191) #define _DS2E	0xFE
(0192) 
(0193) #elif _CODE_PAGE == 437	/* U.S. (OEM) */
(0194) #define _DF1S	0
(0195) #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0196) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0197) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0198) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0199) 
(0200) #elif _CODE_PAGE == 720	/* Arabic (OEM) */
(0201) #define _DF1S	0
(0202) #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0203) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0204) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0205) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0206) 
(0207) #elif _CODE_PAGE == 737	/* Greek (OEM) */
(0208) #define _DF1S	0
(0209) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
(0210) 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0211) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0212) 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0213) 
(0214) #elif _CODE_PAGE == 775	/* Baltic (OEM) */
(0215) #define _DF1S	0
(0216) #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0217) 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0218) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0219) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0220) 
(0221) #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
(0222) #define _DF1S	0
(0223) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0224) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0225) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0226) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0227) 
(0228) #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
(0229) #define _DF1S	0
(0230) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
(0231) 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
(0232) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0233) 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
(0234) 
(0235) #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
(0236) #define _DF1S	0
(0237) #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
(0238) 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
(0239) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
(0240) 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
(0241) 
(0242) #elif _CODE_PAGE == 857	/* Turkish (OEM) */
(0243) #define _DF1S	0
(0244) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
(0245) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0246) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0247) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0248) 
(0249) #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
(0250) #define _DF1S	0
(0251) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0252) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0253) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0254) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0255) 
(0256) #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
(0257) #define _DF1S	0
(0258) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0259) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0260) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0261) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0262) 
(0263) #elif _CODE_PAGE == 866	/* Russian (OEM) */
(0264) #define _DF1S	0
(0265) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0266) 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0267) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0268) 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0269) 
(0270) #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
(0271) #define _DF1S	0
(0272) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0273) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0274) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0275) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0276) 
(0277) #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
(0278) #define _DF1S	0
(0279) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0280) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
(0281) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0282) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0283) 
(0284) #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
(0285) #define _DF1S	0
(0286) #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0287) 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
(0288) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0289) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
(0290) 
(0291) #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
(0292) #define _DF1S	0
(0293) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
(0294) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0295) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0296) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0297) 
(0298) #elif _CODE_PAGE == 1253 /* Greek (Windows) */
(0299) #define _DF1S	0
(0300) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0301) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0302) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
(0303) 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
(0304) 
(0305) #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
(0306) #define _DF1S	0
(0307) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0308) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0309) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0310) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0311) 
(0312) #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
(0313) #define _DF1S	0
(0314) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0315) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0316) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0317) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0318) 
(0319) #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
(0320) #define _DF1S	0
(0321) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0322) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0323) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0324) 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
(0325) 
(0326) #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
(0327) #define _DF1S	0
(0328) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0329) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
(0330) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0331) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0332) 
(0333) #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
(0334) #define _DF1S	0
(0335) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
(0336) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0337) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0338) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
(0339) 
(0340) #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
(0341) #if _USE_LFN
(0342) #error Cannot use LFN feature without valid code page.
(0343) #endif
(0344) #define _DF1S	0
(0345) 
(0346) #else
(0347) #error Unknown code page
(0348) 
(0349) #endif
(0350) 
(0351) 
(0352) /* Character code support macros */
(0353) #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
(0354) #define IsLower(c)	(((c)>='a')&&((c)<='z'))
(0355) #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
(0356) 
(0357) #if _DF1S		/* Code page is DBCS */
(0358) 
(0359) #ifdef _DF2S	/* Two 1st byte areas */
(0360) #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
(0361) #else			/* One 1st byte area */
(0362) #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
(0363) #endif
(0364) 
(0365) #ifdef _DS3S	/* Three 2nd byte areas */
(0366) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
(0367) #else			/* Two 2nd byte areas */
(0368) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
(0369) #endif
(0370) 
(0371) #else			/* Code page is SBCS */
(0372) 
(0373) #define IsDBCS1(c)	0
(0374) #define IsDBCS2(c)	0
(0375) 
(0376) #endif /* _DF1S */
(0377) 
(0378) 
(0379) /* Name status flags */
(0380) #define NS			11		/* Index of name status byte in fn[] */
(0381) #define NS_LOSS		0x01	/* Out of 8.3 format */
(0382) #define NS_LFN		0x02	/* Force to create LFN entry */
(0383) #define NS_LAST		0x04	/* Last segment */
(0384) #define NS_BODY		0x08	/* Lower case flag (body) */
(0385) #define NS_EXT		0x10	/* Lower case flag (ext) */
(0386) #define NS_DOT		0x20	/* Dot entry */
(0387) 
(0388) 
(0389) /* FAT sub-type boundaries */
(0390) /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
(0391) #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
(0392) #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
(0393) 
(0394) 
(0395) /* FatFs refers the members in the FAT structures as byte array instead of
(0396) / structure member because the structure is not binary compatible between
(0397) / different platforms */
(0398) 
(0399) #define BS_jmpBoot			0	/* Jump instruction (3) */
(0400) #define BS_OEMName			3	/* OEM name (8) */
(0401) #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
(0402) #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
(0403) #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
(0404) #define BPB_NumFATs			16	/* Number of FAT copies (1) */
(0405) #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
(0406) #define BPB_TotSec16		19	/* Volume size [sector] (2) */
(0407) #define BPB_Media			21	/* Media descriptor (1) */
(0408) #define BPB_FATSz16			22	/* FAT size [sector] (2) */
(0409) #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
(0410) #define BPB_NumHeads		26	/* Number of heads (2) */
(0411) #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
(0412) #define BPB_TotSec32		32	/* Volume size [sector] (4) */
(0413) #define BS_DrvNum			36	/* Physical drive number (2) */
(0414) #define BS_BootSig			38	/* Extended boot signature (1) */
(0415) #define BS_VolID			39	/* Volume serial number (4) */
(0416) #define BS_VolLab			43	/* Volume label (8) */
(0417) #define BS_FilSysType		54	/* File system type (1) */
(0418) #define BPB_FATSz32			36	/* FAT size [sector] (4) */
(0419) #define BPB_ExtFlags		40	/* Extended flags (2) */
(0420) #define BPB_FSVer			42	/* File system version (2) */
(0421) #define BPB_RootClus		44	/* Root dir first cluster (4) */
(0422) #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
(0423) #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
(0424) #define BS_DrvNum32			64	/* Physical drive number (2) */
(0425) #define BS_BootSig32		66	/* Extended boot signature (1) */
(0426) #define BS_VolID32			67	/* Volume serial number (4) */
(0427) #define BS_VolLab32			71	/* Volume label (8) */
(0428) #define BS_FilSysType32		82	/* File system type (1) */
(0429) #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
(0430) #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
(0431) #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
(0432) #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
(0433) #define MBR_Table			446	/* MBR: Partition table offset (2) */
(0434) #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
(0435) #define BS_55AA				510	/* Boot sector signature (2) */
(0436) 
(0437) #define	DIR_Name			0	/* Short file name (11) */
(0438) #define	DIR_Attr			11	/* Attribute (1) */
(0439) #define	DIR_NTres			12	/* NT flag (1) */
(0440) #define	DIR_CrtTime			14	/* Created time (2) */
(0441) #define	DIR_CrtDate			16	/* Created date (2) */
(0442) #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
(0443) #define	DIR_WrtTime			22	/* Modified time (2) */
(0444) #define	DIR_WrtDate			24	/* Modified date (2) */
(0445) #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
(0446) #define	DIR_FileSize		28	/* File size (4) */
(0447) #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
(0448) #define	LDIR_Attr			11	/* LFN attribute (1) */
(0449) #define	LDIR_Type			12	/* LFN type (1) */
(0450) #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
(0451) #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
(0452) #define	SZ_DIR				32		/* Size of a directory entry */
(0453) #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
(0454) #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
(0455) #define	NDDE				0x05	/* Replacement of a character collides with DDE */
(0456) 
(0457) 
(0458) /*------------------------------------------------------------*/
(0459) /* Module private work area                                   */
(0460) /*------------------------------------------------------------*/
(0461) /* Note that uninitialized variables with static duration are
(0462) /  zeroed/nulled at start-up. If not, the compiler or start-up
(0463) /  routine is out of ANSI-C standard.
(0464) */
(0465) 
(0466) #if _VOLUMES
(0467) static
(0468) FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
(0469) #else
(0470) #error Number of volumes must not be 0.
(0471) #endif
(0472) 
(0473) static
(0474) WORD Fsid;				/* File system mount ID */
(0475) 
(0476) #if _FS_RPATH
(0477) static
(0478) BYTE CurrVol;			/* Current drive */
(0479) #endif
(0480) 
(0481) #if _FS_SHARE
(0482) static
(0483) FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
(0484) #endif
(0485) 
(0486) #if _USE_LFN == 0			/* No LFN feature */
(0487) #define	DEF_NAMEBUF			BYTE sfn[12]
(0488) #define INIT_BUF(dobj)		(dobj).fn = sfn
(0489) #define	FREE_BUF()
(0490) 
(0491) #elif _USE_LFN == 1			/* LFN feature with static working buffer */
(0492) static WCHAR LfnBuf[_MAX_LFN+1];
(0493) #define	DEF_NAMEBUF			BYTE sfn[12]
(0494) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
(0495) #define	FREE_BUF()
(0496) 
(0497) #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
(0498) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
(0499) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
(0500) #define	FREE_BUF()
(0501) 
(0502) #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
(0503) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
(0504) #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
(0505) 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
(0506) 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
(0507) #define	FREE_BUF()			ff_memfree(lfn)
(0508) 
(0509) #else
(0510) #error Wrong LFN configuration.
(0511) #endif
(0512) 
(0513) 
(0514) 
(0515) 
(0516) /*--------------------------------------------------------------------------
(0517) 
(0518)    Module Private Functions
(0519) 
(0520) ---------------------------------------------------------------------------*/
(0521) 
(0522) 
(0523) /*-----------------------------------------------------------------------*/
(0524) /* String functions                                                      */
(0525) /*-----------------------------------------------------------------------*/
(0526) 
(0527) /* Copy memory to memory */
(0528) static
(0529) void mem_cpy (void* dst, const void* src, UINT cnt) {
(0530) 	BYTE *d = (BYTE*)dst;
    00328 0158      MOVW	R10,R16
(0531) 	const BYTE *s = (const BYTE*)src;
    00329 0169      MOVW	R12,R18
    0032A C006      RJMP	0x0331
(0532) 
(0533) #if _WORD_ACCESS == 1
(0534) 	while (cnt >= sizeof(int)) {
(0535) 		*(int*)d = *(int*)s;
(0536) 		d += sizeof(int); s += sizeof(int);
(0537) 		cnt -= sizeof(int);
(0538) 	}
(0539) #endif
(0540) 	while (cnt--)
(0541) 		*d++ = *s++;
    0032B 01F6      MOVW	R30,R12
    0032C 01D5      MOVW	R26,R10
    0032D 9001      LD	R0,Z+
    0032E 016F      MOVW	R12,R30
    0032F 920D      ST	X+,R0
    00330 015D      MOVW	R10,R26
    00331 011A      MOVW	R2,R20
    00332 5041      SUBI	R20,1
    00333 4050      SBCI	R21,0
    00334 2022      TST	R2
    00335 F7A9      BNE	0x032B
    00336 2033      TST	R3
    00337 F799      BNE	0x032B
    00338 940C 42D8 JMP	pop_xgset303C
ff.c:mem_set:
  d                    --> R10
  cnt                  --> R20
  val                  --> R18
  dst                  --> R16
    0033A 940E 42AF CALL	push_xgset300C
    0033C 814C      LDD	R20,Y+4
    0033D 815D      LDD	R21,Y+5
(0542) }
(0543) 
(0544) /* Fill memory */
(0545) static
(0546) void mem_set (void* dst, int val, UINT cnt) {
(0547) 	BYTE *d = (BYTE*)dst;
    0033E 0158      MOVW	R10,R16
    0033F C003      RJMP	0x0343
(0548) 
(0549) 	while (cnt--)
(0550) 		*d++ = (BYTE)val;
    00340 01F5      MOVW	R30,R10
    00341 9321      ST	Z+,R18
    00342 015F      MOVW	R10,R30
    00343 011A      MOVW	R2,R20
    00344 5041      SUBI	R20,1
    00345 4050      SBCI	R21,0
    00346 2022      TST	R2
    00347 F7C1      BNE	0x0340
    00348 2033      TST	R3
    00349 F7B1      BNE	0x0340
    0034A 940C 42B4 JMP	pop_xgset300C
ff.c:mem_cmp:
  s                    --> R14
  d                    --> R12
  r                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    0034C 940E 42A6 CALL	push_xgset30FC
    0034E 8548      LDD	R20,Y+8
    0034F 8559      LDD	R21,Y+9
(0551) }
(0552) 
(0553) /* Compare memory to memory */
(0554) static
(0555) int mem_cmp (const void* dst, const void* src, UINT cnt) {
(0556) 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    00350 0168      MOVW	R12,R16
    00351 0179      MOVW	R14,R18
(0557) 	int r = 0;
    00352 24AA      CLR	R10
    00353 24BB      CLR	R11
(0558) 
(0559) 	while (cnt-- && (r = *d++ - *s++) == 0) ;
    00354 011A      MOVW	R2,R20
    00355 5041      SUBI	R20,1
    00356 4050      SBCI	R21,0
    00357 2022      TST	R2
    00358 F411      BNE	0x035B
    00359 2033      TST	R3
    0035A F079      BEQ	0x036A
    0035B 01F7      MOVW	R30,R14
    0035C 9021      LD	R2,Z+
    0035D 017F      MOVW	R14,R30
    0035E 2433      CLR	R3
    0035F 01F6      MOVW	R30,R12
    00360 9041      LD	R4,Z+
    00361 016F      MOVW	R12,R30
    00362 2455      CLR	R5
    00363 1842      SUB	R4,R2
    00364 0853      SBC	R5,R3
    00365 0152      MOVW	R10,R4
    00366 20AA      TST	R10
    00367 F411      BNE	0x036A
    00368 20BB      TST	R11
    00369 F351      BEQ	0x0354
(0560) 	return r;
    0036A 0185      MOVW	R16,R10
    0036B 940C 4290 JMP	pop_xgset30FC
(0561) }
(0562) 
(0563) /* Check if chr is contained in the string */
(0564) static
(0565) int chk_chr (const char* str, int chr) {
ff.c:chk_chr:
  chr                  --> R18
  str                  --> R16
    0036D C002      RJMP	0x0370
(0566) 	while (*str && *str != chr) str++;
    0036E 5F0F      SUBI	R16,0xFF
    0036F 4F1F      SBCI	R17,0xFF
    00370 01F8      MOVW	R30,R16
    00371 8020      LD	R2,Z
    00372 2433      CLR	R3
    00373 2022      TST	R2
    00374 F021      BEQ	0x0379
    00375 2433      CLR	R3
    00376 1622      CP	R2,R18
    00377 0633      CPC	R3,R19
    00378 F7A9      BNE	0x036E
(0567) 	return *str;
    00379 01F8      MOVW	R30,R16
    0037A 8100      LD	R16,Z
    0037B 2711      CLR	R17
    0037C 9508      RET
ff.c:move_window:
  nf                   --> R10
  wsect                --> Y,+5
  sector               --> Y,+13
  fs                   --> R20
    0037D 933A      ST	-Y,R19
    0037E 932A      ST	-Y,R18
    0037F 940E 42AF CALL	push_xgset300C
    00381 01A8      MOVW	R20,R16
    00382 9729      SBIW	R28,0x9
(0568) }
(0569) 
(0570) 
(0571) 
(0572) /*-----------------------------------------------------------------------*/
(0573) /* Request/Release grant to access the volume                            */
(0574) /*-----------------------------------------------------------------------*/
(0575) #if _FS_REENTRANT
(0576) 
(0577) static
(0578) int lock_fs (
(0579) 	FATFS *fs		/* File system object */
(0580) )
(0581) {
(0582) 	return ff_req_grant(fs->sobj);
(0583) }
(0584) 
(0585) 
(0586) static
(0587) void unlock_fs (
(0588) 	FATFS *fs,		/* File system object */
(0589) 	FRESULT res		/* Result code to be returned */
(0590) )
(0591) {
(0592) 	if (res != FR_NOT_ENABLED &&
(0593) 		res != FR_INVALID_DRIVE &&
(0594) 		res != FR_INVALID_OBJECT &&
(0595) 		res != FR_TIMEOUT) {
(0596) 		ff_rel_grant(fs->sobj);
(0597) 	}
(0598) }
(0599) #endif
(0600) 
(0601) 
(0602) 
(0603) /*-----------------------------------------------------------------------*/
(0604) /* File shareing control functions                                       */
(0605) /*-----------------------------------------------------------------------*/
(0606) #if _FS_SHARE
(0607) 
(0608) static
(0609) FRESULT chk_lock (	/* Check if the file can be accessed */
(0610) 	DIR* dj,		/* Directory object pointing the file to be checked */
(0611) 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
(0612) )
(0613) {
(0614) 	UINT i, be;
(0615) 
(0616) 	/* Search file semaphore table */
(0617) 	for (i = be = 0; i < _FS_SHARE; i++) {
(0618) 		if (Files[i].fs) {	/* Existing entry */
(0619) 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
(0620) 				Files[i].clu == dj->sclust &&
(0621) 				Files[i].idx == dj->index) break;
(0622) 		} else {			/* Blank entry */
(0623) 			be++;
(0624) 		}
(0625) 	}
(0626) 	if (i == _FS_SHARE)	/* The file is not opened */
(0627) 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
(0628) 
(0629) 	/* The file has been opened. Reject any open against writing file and all write mode open */
(0630) 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
(0631) }
(0632) 
(0633) 
(0634) static
(0635) int enq_lock (void)	/* Check if an entry is available for a new file */
(0636) {
(0637) 	UINT i;
(0638) 
(0639) 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0640) 	return (i == _FS_SHARE) ? 0 : 1;
(0641) }
(0642) 
(0643) 
(0644) static
(0645) UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
(0646) 	DIR* dj,	/* Directory object pointing the file to register or increment */
(0647) 	int acc		/* Desired access mode (0:Read, !0:Write) */
(0648) )
(0649) {
(0650) 	UINT i;
(0651) 
(0652) 
(0653) 	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
(0654) 		if (Files[i].fs == dj->fs &&
(0655) 			Files[i].clu == dj->sclust &&
(0656) 			Files[i].idx == dj->index) break;
(0657) 	}
(0658) 
(0659) 	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
(0660) 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0661) 		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
(0662) 		Files[i].fs = dj->fs;
(0663) 		Files[i].clu = dj->sclust;
(0664) 		Files[i].idx = dj->index;
(0665) 		Files[i].ctr = 0;
(0666) 	}
(0667) 
(0668) 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
(0669) 
(0670) 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
(0671) 
(0672) 	return i + 1;
(0673) }
(0674) 
(0675) 
(0676) static
(0677) FRESULT dec_lock (	/* Decrement file open counter */
(0678) 	UINT i			/* Semaphore index */
(0679) )
(0680) {
(0681) 	WORD n;
(0682) 	FRESULT res;
(0683) 
(0684) 
(0685) 	if (--i < _FS_SHARE) {
(0686) 		n = Files[i].ctr;
(0687) 		if (n == 0x100) n = 0;
(0688) 		if (n) n--;
(0689) 		Files[i].ctr = n;
(0690) 		if (!n) Files[i].fs = 0;
(0691) 		res = FR_OK;
(0692) 	} else {
(0693) 		res = FR_INT_ERR;
(0694) 	}
(0695) 	return res;
(0696) }
(0697) 
(0698) 
(0699) static
(0700) void clear_lock (	/* Clear lock entries of the volume */
(0701) 	FATFS *fs
(0702) )
(0703) {
(0704) 	UINT i;
(0705) 
(0706) 	for (i = 0; i < _FS_SHARE; i++) {
(0707) 		if (Files[i].fs == fs) Files[i].fs = 0;
(0708) 	}
(0709) }
(0710) #endif
(0711) 
(0712) 
(0713) 
(0714) /*-----------------------------------------------------------------------*/
(0715) /* Change window offset                                                  */
(0716) /*-----------------------------------------------------------------------*/
(0717) 
(0718) static
(0719) FRESULT move_window (
(0720) 	FATFS *fs,		/* File system object */
(0721) 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
(0722) )					/* Move to zero only writes back dirty window */
(0723) {
(0724) 	DWORD wsect;
(0725) 
(0726) 
(0727) 	wsect = fs->winsect;
    00383 01FA      MOVW	R30,R20
    00384 96BA      ADIW	R30,0x2A
    00385 8020      LD	R2,Z
    00386 8031      LDD	R3,Z+1
    00387 8042      LDD	R4,Z+2
    00388 8053      LDD	R5,Z+3
    00389 822D      STD	Y+5,R2
    0038A 823E      STD	Y+6,R3
    0038B 824F      STD	Y+7,R4
    0038C 8658      STD	Y+8,R5
(0728) 	if (wsect != sector) {	/* Changed current window */
    0038D 842D      LDD	R2,Y+13
    0038E 843E      LDD	R3,Y+14
    0038F 844F      LDD	R4,Y+15
    00390 8858      LDD	R5,Y+16
    00391 806D      LDD	R6,Y+5
    00392 807E      LDD	R7,Y+6
    00393 808F      LDD	R8,Y+7
    00394 8498      LDD	R9,Y+8
    00395 1462      CP	R6,R2
    00396 0473      CPC	R7,R3
    00397 0484      CPC	R8,R4
    00398 0495      CPC	R9,R5
    00399 F409      BNE	0x039B
    0039A C07E      RJMP	0x0419
(0729) #if !_FS_READONLY
(0730) 		if (fs->wflag) {	/* Write back dirty window if needed */
    0039B 01FA      MOVW	R30,R20
    0039C 8024      LDD	R2,Z+4
    0039D 2022      TST	R2
    0039E F409      BNE	0x03A0
    0039F C055      RJMP	0x03F5
(0731) 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    003A0 E081      LDI	R24,1
    003A1 838C      STD	Y+4,R24
    003A2 0113      MOVW	R2,R6
    003A3 0124      MOVW	R4,R8
    003A4 8228      ST	Y,R2
    003A5 8239      STD	Y+1,R3
    003A6 824A      STD	Y+2,R4
    003A7 825B      STD	Y+3,R5
    003A8 019A      MOVW	R18,R20
    003A9 5D22      SUBI	R18,0xD2
    003AA 4F3F      SBCI	R19,0xFF
    003AB 8101      LDD	R16,Z+1
    003AC 940E 0302 CALL	_disk_write
    003AE 2300      TST	R16
    003AF F011      BEQ	0x03B2
(0732) 				return FR_DISK_ERR;
    003B0 E001      LDI	R16,1
    003B1 C068      RJMP	0x041A
(0733) 			fs->wflag = 0;
    003B2 2422      CLR	R2
    003B3 01FA      MOVW	R30,R20
    003B4 8224      STD	Z+4,R2
(0734) 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    003B5 8C22      LDD	R2,Z+26
    003B6 8C33      LDD	R3,Z+27
    003B7 8C44      LDD	R4,Z+28
    003B8 8C55      LDD	R5,Z+29
    003B9 967E      ADIW	R30,0x1E
    003BA 8060      LD	R6,Z
    003BB 8071      LDD	R7,Z+1
    003BC 8082      LDD	R8,Z+2
    003BD 8093      LDD	R9,Z+3
    003BE 0C62      ADD	R6,R2
    003BF 1C73      ADC	R7,R3
    003C0 1C84      ADC	R8,R4
    003C1 1C95      ADC	R9,R5
    003C2 802D      LDD	R2,Y+5
    003C3 803E      LDD	R3,Y+6
    003C4 804F      LDD	R4,Y+7
    003C5 8458      LDD	R5,Y+8
    003C6 1426      CP	R2,R6
    003C7 0437      CPC	R3,R7
    003C8 0448      CPC	R4,R8
    003C9 0459      CPC	R5,R9
    003CA F550      BCC	0x03F5
(0735) 				BYTE nf;
(0736) 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    003CB 01FA      MOVW	R30,R20
    003CC 80A3      LDD	R10,Z+3
    003CD C024      RJMP	0x03F2
(0737) 					wsect += fs->fsize;
    003CE 01FA      MOVW	R30,R20
    003CF 967A      ADIW	R30,0x1A
    003D0 8020      LD	R2,Z
    003D1 8031      LDD	R3,Z+1
    003D2 8042      LDD	R4,Z+2
    003D3 8053      LDD	R5,Z+3
    003D4 806D      LDD	R6,Y+5
    003D5 807E      LDD	R7,Y+6
    003D6 808F      LDD	R8,Y+7
    003D7 8498      LDD	R9,Y+8
    003D8 0C62      ADD	R6,R2
    003D9 1C73      ADC	R7,R3
    003DA 1C84      ADC	R8,R4
    003DB 1C95      ADC	R9,R5
    003DC 826D      STD	Y+5,R6
    003DD 827E      STD	Y+6,R7
    003DE 828F      STD	Y+7,R8
    003DF 8698      STD	Y+8,R9
(0738) 					disk_write(fs->drv, fs->win, wsect, 1);
    003E0 E081      LDI	R24,1
    003E1 838C      STD	Y+4,R24
    003E2 802D      LDD	R2,Y+5
    003E3 803E      LDD	R3,Y+6
    003E4 804F      LDD	R4,Y+7
    003E5 8458      LDD	R5,Y+8
    003E6 8228      ST	Y,R2
    003E7 8239      STD	Y+1,R3
    003E8 824A      STD	Y+2,R4
    003E9 825B      STD	Y+3,R5
    003EA 019A      MOVW	R18,R20
    003EB 5D22      SUBI	R18,0xD2
    003EC 4F3F      SBCI	R19,0xFF
    003ED 01FA      MOVW	R30,R20
    003EE 8101      LDD	R16,Z+1
    003EF 940E 0302 CALL	_disk_write
    003F1 94AA      DEC	R10
    003F2 E081      LDI	R24,1
    003F3 158A      CP	R24,R10
    003F4 F2C8      BCS	0x03CE
(0739) 				}
(0740) 			}
(0741) 		}
(0742) #endif
(0743) 		if (sector) {
    003F5 842D      LDD	R2,Y+13
    003F6 843E      LDD	R3,Y+14
    003F7 844F      LDD	R4,Y+15
    003F8 8858      LDD	R5,Y+16
    003F9 9488      BCLR	0
    003FA 2022      TST	R2
    003FB 0432      CPC	R3,R2
    003FC 0442      CPC	R4,R2
    003FD 0452      CPC	R5,R2
    003FE F0D1      BEQ	0x0419
(0744) 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    003FF E081      LDI	R24,1
    00400 838C      STD	Y+4,R24
    00401 8228      ST	Y,R2
    00402 8239      STD	Y+1,R3
    00403 824A      STD	Y+2,R4
    00404 825B      STD	Y+3,R5
    00405 019A      MOVW	R18,R20
    00406 5D22      SUBI	R18,0xD2
    00407 4F3F      SBCI	R19,0xFF
    00408 01FA      MOVW	R30,R20
    00409 8101      LDD	R16,Z+1
    0040A 940E 02E2 CALL	_disk_read
    0040C 2300      TST	R16
    0040D F011      BEQ	0x0410
(0745) 				return FR_DISK_ERR;
    0040E E001      LDI	R16,1
    0040F C00A      RJMP	0x041A
(0746) 			fs->winsect = sector;
    00410 842D      LDD	R2,Y+13
    00411 843E      LDD	R3,Y+14
    00412 844F      LDD	R4,Y+15
    00413 8858      LDD	R5,Y+16
    00414 01FA      MOVW	R30,R20
    00415 A622      STD	Z+42,R2
    00416 A633      STD	Z+43,R3
    00417 A644      STD	Z+44,R4
    00418 A655      STD	Z+45,R5
(0747) 		}
(0748) 	}
(0749) 
(0750) 	return FR_OK;
    00419 2700      CLR	R16
    0041A 9629      ADIW	R28,0x9
    0041B 940E 42B4 CALL	pop_xgset300C
    0041D 9622      ADIW	R28,2
    0041E 9508      RET
ff.c:sync:
  res                  --> R20
  fs                   --> R22
    0041F 940E 42B9 CALL	push_xgsetF000
    00421 01B8      MOVW	R22,R16
    00422 9725      SBIW	R28,5
(0751) }
(0752) 
(0753) 
(0754) 
(0755) 
(0756) /*-----------------------------------------------------------------------*/
(0757) /* Clean-up cached data                                                  */
(0758) /*-----------------------------------------------------------------------*/
(0759) #if !_FS_READONLY
(0760) static
(0761) FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
(0762) 	FATFS *fs	/* File system object */
(0763) )
(0764) {
(0765) 	FRESULT res;
(0766) 
(0767) 
(0768) 	res = move_window(fs, 0);
    00423 E080      LDI	R24,0
    00424 E090      LDI	R25,0
    00425 E0A0      LDI	R26,0
    00426 E0B0      LDI	R27,0
    00427 83A8      ST	Y,R26
    00428 83B9      STD	Y+1,R27
    00429 019C      MOVW	R18,R24
    0042A 018B      MOVW	R16,R22
    0042B DF51      RCALL	ff.c:move_window
    0042C 2F40      MOV	R20,R16
(0769) 	if (res == FR_OK) {
    0042D 2300      TST	R16
    0042E F009      BEQ	0x0430
    0042F C0C0      RJMP	0x04F0
(0770) 		/* Update FSInfo sector if needed */
(0771) 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    00430 01FB      MOVW	R30,R22
    00431 8180      LD	R24,Z
    00432 3083      CPI	R24,3
    00433 F009      BEQ	0x0435
    00434 C0AC      RJMP	0x04E1
    00435 8025      LDD	R2,Z+5
    00436 2022      TST	R2
    00437 F409      BNE	0x0439
    00438 C0A8      RJMP	0x04E1
(0772) 			fs->winsect = 0;
    00439 96BA      ADIW	R30,0x2A
    0043A E080      LDI	R24,0
    0043B 8380      ST	Z,R24
    0043C 8381      STD	Z+1,R24
    0043D 8382      STD	Z+2,R24
    0043E 8383      STD	Z+3,R24
(0773) 			/* Create FSInfo structure */
(0774) 			mem_set(fs->win, 0, 512);
    0043F E080      LDI	R24,0
    00440 E092      LDI	R25,2
    00441 8399      STD	Y+1,R25
    00442 8388      ST	Y,R24
    00443 2722      CLR	R18
    00444 2733      CLR	R19
    00445 018B      MOVW	R16,R22
    00446 5D02      SUBI	R16,0xD2
    00447 4F1F      SBCI	R17,0xFF
    00448 DEF1      RCALL	ff.c:mem_set
(0775) 			ST_WORD(fs->win+BS_55AA, 0xAA55);
    00449 E585      LDI	R24,0x55
    0044A 01FB      MOVW	R30,R22
    0044B 5DE4      SUBI	R30,0xD4
    0044C 4FFD      SBCI	R31,0xFD
    0044D 8380      ST	Z,R24
    0044E 52EC      SUBI	R30,0x2C
    0044F 40F2      SBCI	R31,2
    00450 EA8A      LDI	R24,0xAA
    00451 5DE3      SUBI	R30,0xD3
    00452 4FFD      SBCI	R31,0xFD
    00453 8380      ST	Z,R24
    00454 52ED      SUBI	R30,0x2D
    00455 40F2      SBCI	R31,2
(0776) 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    00456 E582      LDI	R24,0x52
    00457 A786      STD	Z+46,R24
    00458 A787      STD	Z+47,R24
    00459 E681      LDI	R24,0x61
    0045A AB80      STD	Z+48,R24
    0045B E481      LDI	R24,0x41
    0045C AB81      STD	Z+49,R24
(0777) 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    0045D E782      LDI	R24,0x72
    0045E 5EEE      SUBI	R30,0xEE
    0045F 4FFD      SBCI	R31,0xFD
    00460 8380      ST	Z,R24
    00461 51E2      SUBI	R30,0x12
    00462 40F2      SBCI	R31,2
    00463 5EED      SUBI	R30,0xED
    00464 4FFD      SBCI	R31,0xFD
    00465 8380      ST	Z,R24
    00466 51E3      SUBI	R30,0x13
    00467 40F2      SBCI	R31,2
    00468 E481      LDI	R24,0x41
    00469 5EEC      SUBI	R30,0xEC
    0046A 4FFD      SBCI	R31,0xFD
    0046B 8380      ST	Z,R24
    0046C 51E4      SUBI	R30,0x14
    0046D 40F2      SBCI	R31,2
    0046E E681      LDI	R24,0x61
    0046F 5EEB      SUBI	R30,0xEB
    00470 4FFD      SBCI	R31,0xFD
    00471 8380      ST	Z,R24
    00472 51E5      SUBI	R30,0x15
    00473 40F2      SBCI	R31,2
(0778) 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    00474 8426      LDD	R2,Z+14
    00475 8437      LDD	R3,Z+15
    00476 8840      LDD	R4,Z+16
    00477 8851      LDD	R5,Z+17
    00478 5EEA      SUBI	R30,0xEA
    00479 4FFD      SBCI	R31,0xFD
    0047A 8220      ST	Z,R2
    0047B 51E6      SUBI	R30,0x16
    0047C 40F2      SBCI	R31,2
    0047D 8426      LDD	R2,Z+14
    0047E 8437      LDD	R3,Z+15
    0047F 2C23      MOV	R2,R3
    00480 2433      CLR	R3
    00481 5EE9      SUBI	R30,0xE9
    00482 4FFD      SBCI	R31,0xFD
    00483 8220      ST	Z,R2
    00484 51E7      SUBI	R30,0x17
    00485 40F2      SBCI	R31,2
    00486 8426      LDD	R2,Z+14
    00487 8437      LDD	R3,Z+15
    00488 8840      LDD	R4,Z+16
    00489 8851      LDD	R5,Z+17
    0048A 0112      MOVW	R2,R4
    0048B 2444      CLR	R4
    0048C 2455      CLR	R5
    0048D 5EE8      SUBI	R30,0xE8
    0048E 4FFD      SBCI	R31,0xFD
    0048F 8220      ST	Z,R2
    00490 51E8      SUBI	R30,0x18
    00491 40F2      SBCI	R31,2
    00492 E188      LDI	R24,0x18
    00493 E090      LDI	R25,0
    00494 8506      LDD	R16,Z+14
    00495 8517      LDD	R17,Z+15
    00496 8920      LDD	R18,Z+16
    00497 8931      LDD	R19,Z+17
    00498 938A      ST	-Y,R24
    00499 940E 433F CALL	lsr32
    0049B 01FB      MOVW	R30,R22
    0049C 5EE7      SUBI	R30,0xE7
    0049D 4FFD      SBCI	R31,0xFD
    0049E 8300      ST	Z,R16
    0049F 51E9      SUBI	R30,0x19
    004A0 40F2      SBCI	R31,2
(0779) 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    004A1 8422      LDD	R2,Z+10
    004A2 8433      LDD	R3,Z+11
    004A3 8444      LDD	R4,Z+12
    004A4 8455      LDD	R5,Z+13
    004A5 5EE6      SUBI	R30,0xE6
    004A6 4FFD      SBCI	R31,0xFD
    004A7 8220      ST	Z,R2
    004A8 51EA      SUBI	R30,0x1A
    004A9 40F2      SBCI	R31,2
    004AA 8422      LDD	R2,Z+10
    004AB 8433      LDD	R3,Z+11
    004AC 2C23      MOV	R2,R3
    004AD 2433      CLR	R3
    004AE 5EE5      SUBI	R30,0xE5
    004AF 4FFD      SBCI	R31,0xFD
    004B0 8220      ST	Z,R2
    004B1 51EB      SUBI	R30,0x1B
    004B2 40F2      SBCI	R31,2
    004B3 8422      LDD	R2,Z+10
    004B4 8433      LDD	R3,Z+11
    004B5 8444      LDD	R4,Z+12
    004B6 8455      LDD	R5,Z+13
    004B7 0112      MOVW	R2,R4
    004B8 2444      CLR	R4
    004B9 2455      CLR	R5
    004BA 5EE4      SUBI	R30,0xE4
    004BB 4FFD      SBCI	R31,0xFD
    004BC 8220      ST	Z,R2
    004BD 51EC      SUBI	R30,0x1C
    004BE 40F2      SBCI	R31,2
    004BF E188      LDI	R24,0x18
    004C0 E090      LDI	R25,0
    004C1 8502      LDD	R16,Z+10
    004C2 8513      LDD	R17,Z+11
    004C3 8524      LDD	R18,Z+12
    004C4 8535      LDD	R19,Z+13
    004C5 938A      ST	-Y,R24
    004C6 940E 433F CALL	lsr32
    004C8 01FB      MOVW	R30,R22
    004C9 5EE3      SUBI	R30,0xE3
    004CA 4FFD      SBCI	R31,0xFD
    004CB 8300      ST	Z,R16
    004CC 51ED      SUBI	R30,0x1D
    004CD 40F2      SBCI	R31,2
(0780) 			/* Write it into the FSInfo sector */
(0781) 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    004CE E081      LDI	R24,1
    004CF 838C      STD	Y+4,R24
    004D0 8822      LDD	R2,Z+18
    004D1 8833      LDD	R3,Z+19
    004D2 8844      LDD	R4,Z+20
    004D3 8855      LDD	R5,Z+21
    004D4 8228      ST	Y,R2
    004D5 8239      STD	Y+1,R3
    004D6 824A      STD	Y+2,R4
    004D7 825B      STD	Y+3,R5
    004D8 019F      MOVW	R18,R30
    004D9 5D22      SUBI	R18,0xD2
    004DA 4F3F      SBCI	R19,0xFF
    004DB 8101      LDD	R16,Z+1
    004DC 940E 0302 CALL	_disk_write
(0782) 			fs->fsi_flag = 0;
    004DE 2422      CLR	R2
    004DF 01FB      MOVW	R30,R22
    004E0 8225      STD	Z+5,R2
(0783) 		}
(0784) 		/* Make sure that no pending write process in the physical drive */
(0785) 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    004E1 2422      CLR	R2
    004E2 2433      CLR	R3
    004E3 8239      STD	Y+1,R3
    004E4 8228      ST	Y,R2
    004E5 2722      CLR	R18
    004E6 2733      CLR	R19
    004E7 01FB      MOVW	R30,R22
    004E8 8101      LDD	R16,Z+1
    004E9 2711      CLR	R17
    004EA 940E 031A CALL	_disk_ioctl
    004EC 3000      CPI	R16,0
    004ED 0701      CPC	R16,R17
    004EE F009      BEQ	0x04F0
(0786) 			res = FR_DISK_ERR;
    004EF E041      LDI	R20,1
(0787) 	}
(0788) 
(0789) 	return res;
    004F0 2F04      MOV	R16,R20
    004F1 9625      ADIW	R28,5
    004F2 940C 42BE JMP	pop_xgsetF000
_clust2sect:
  clst                 --> Y,+6
  fs                   --> R10
    004F4 933A      ST	-Y,R19
    004F5 932A      ST	-Y,R18
    004F6 940E 42C3 CALL	push_xgsetF00C
    004F8 0158      MOVW	R10,R16
(0790) }
(0791) #endif
(0792) 
(0793) 
(0794) 
(0795) 
(0796) /*-----------------------------------------------------------------------*/
(0797) /* Get sector# from cluster#                                             */
(0798) /*-----------------------------------------------------------------------*/
(0799) 
(0800) 
(0801) DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
(0802) 	FATFS *fs,		/* File system object */
(0803) 	DWORD clst		/* Cluster# to be converted */
(0804) )
(0805) {
(0806) 	clst -= 2;
    004F9 E042      LDI	R20,2
    004FA E050      LDI	R21,0
    004FB E060      LDI	R22,0
    004FC E070      LDI	R23,0
    004FD 802E      LDD	R2,Y+6
    004FE 803F      LDD	R3,Y+7
    004FF 8448      LDD	R4,Y+8
    00500 8459      LDD	R5,Y+9
    00501 1A24      SUB	R2,R20
    00502 0A35      SBC	R3,R21
    00503 0A46      SBC	R4,R22
    00504 0A57      SBC	R5,R23
    00505 822E      STD	Y+6,R2
    00506 823F      STD	Y+7,R3
    00507 8648      STD	Y+8,R4
    00508 8659      STD	Y+9,R5
(0807) 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    00509 E042      LDI	R20,2
    0050A E050      LDI	R21,0
    0050B E060      LDI	R22,0
    0050C E070      LDI	R23,0
    0050D 01F5      MOVW	R30,R10
    0050E 9676      ADIW	R30,0x16
    0050F 8020      LD	R2,Z
    00510 8031      LDD	R3,Z+1
    00511 8042      LDD	R4,Z+2
    00512 8053      LDD	R5,Z+3
    00513 1A24      SUB	R2,R20
    00514 0A35      SBC	R3,R21
    00515 0A46      SBC	R4,R22
    00516 0A57      SBC	R5,R23
    00517 806E      LDD	R6,Y+6
    00518 807F      LDD	R7,Y+7
    00519 8488      LDD	R8,Y+8
    0051A 8499      LDD	R9,Y+9
    0051B 1462      CP	R6,R2
    0051C 0473      CPC	R7,R3
    0051D 0484      CPC	R8,R4
    0051E 0495      CPC	R9,R5
    0051F F028      BCS	0x0525
    00520 E000      LDI	R16,0
    00521 E010      LDI	R17,0
    00522 E020      LDI	R18,0
    00523 E030      LDI	R19,0
    00524 C01D      RJMP	0x0542
(0808) 	return clst * fs->csize + fs->database;
    00525 01F5      MOVW	R30,R10
    00526 9632      ADIW	R30,2
    00527 8020      LD	R2,Z
    00528 2433      CLR	R3
    00529 2444      CLR	R4
    0052A 2455      CLR	R5
    0052B 810E      LDD	R16,Y+6
    0052C 811F      LDD	R17,Y+7
    0052D 8528      LDD	R18,Y+8
    0052E 8539      LDD	R19,Y+9
    0052F 925A      ST	-Y,R5
    00530 924A      ST	-Y,R4
    00531 923A      ST	-Y,R3
    00532 922A      ST	-Y,R2
    00533 940E 4250 CALL	empy32u|empy32s
    00535 0118      MOVW	R2,R16
    00536 0129      MOVW	R4,R18
    00537 01F5      MOVW	R30,R10
    00538 A066      LDD	R6,Z+38
    00539 A077      LDD	R7,Z+39
    0053A A480      LDD	R8,Z+40
    0053B A491      LDD	R9,Z+41
    0053C 0C26      ADD	R2,R6
    0053D 1C37      ADC	R3,R7
    0053E 1C48      ADC	R4,R8
    0053F 1C59      ADC	R5,R9
    00540 0181      MOVW	R16,R2
    00541 0192      MOVW	R18,R4
    00542 940E 42CA CALL	pop_xgsetF00C
    00544 9622      ADIW	R28,2
    00545 9508      RET
_get_fat:
  wc                   --> R14
  p                    --> R10
  bc                   --> R10
  clst                 --> Y,+12
  fs                   --> R12
    00546 933A      ST	-Y,R19
    00547 932A      ST	-Y,R18
    00548 940E 42A4 CALL	push_xgsetF0FC
    0054A 0168      MOVW	R12,R16
    0054B 9722      SBIW	R28,2
(0809) }
(0810) 
(0811) 
(0812) 
(0813) 
(0814) /*-----------------------------------------------------------------------*/
(0815) /* FAT access - Read value of a FAT entry                                */
(0816) /*-----------------------------------------------------------------------*/
(0817) 
(0818) 
(0819) DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
(0820) 	FATFS *fs,	/* File system object */
(0821) 	DWORD clst	/* Cluster# to get the link information */
(0822) )
(0823) {
(0824) 	UINT wc, bc;
(0825) 	BYTE *p;
(0826) 
(0827) 
(0828) 	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    0054C E042      LDI	R20,2
    0054D E050      LDI	R21,0
    0054E E060      LDI	R22,0
    0054F E070      LDI	R23,0
    00550 842C      LDD	R2,Y+12
    00551 843D      LDD	R3,Y+13
    00552 844E      LDD	R4,Y+14
    00553 845F      LDD	R5,Y+15
    00554 1624      CP	R2,R20
    00555 0635      CPC	R3,R21
    00556 0646      CPC	R4,R22
    00557 0657      CPC	R5,R23
    00558 F078      BCS	0x0568
    00559 01F6      MOVW	R30,R12
    0055A 9676      ADIW	R30,0x16
    0055B 8020      LD	R2,Z
    0055C 8031      LDD	R3,Z+1
    0055D 8042      LDD	R4,Z+2
    0055E 8053      LDD	R5,Z+3
    0055F 846C      LDD	R6,Y+12
    00560 847D      LDD	R7,Y+13
    00561 848E      LDD	R8,Y+14
    00562 849F      LDD	R9,Y+15
    00563 1462      CP	R6,R2
    00564 0473      CPC	R7,R3
    00565 0484      CPC	R8,R4
    00566 0495      CPC	R9,R5
    00567 F028      BCS	0x056D
(0829) 		return 1;
    00568 E001      LDI	R16,1
    00569 E010      LDI	R17,0
    0056A E020      LDI	R18,0
    0056B E030      LDI	R19,0
    0056C C124      RJMP	0x0691
(0830) 
(0831) 	switch (fs->fs_type) {
    0056D 01F6      MOVW	R30,R12
    0056E 80A0      LD	R10,Z
    0056F 24BB      CLR	R11
    00570 01C5      MOVW	R24,R10
    00571 3081      CPI	R24,1
    00572 E0E0      LDI	R30,0
    00573 079E      CPC	R25,R30
    00574 F059      BEQ	0x0580
    00575 3082      CPI	R24,2
    00576 E0E0      LDI	R30,0
    00577 079E      CPC	R25,R30
    00578 F409      BNE	0x057A
    00579 C06F      RJMP	0x05E9
    0057A 3083      CPI	R24,3
    0057B E0E0      LDI	R30,0
    0057C 079E      CPC	R25,R30
    0057D F409      BNE	0x057F
    0057E C0A6      RJMP	0x0625
    0057F C10D      RJMP	0x068D
(0832) 	case FS_FAT12 :
(0833) 		bc = (UINT)clst; bc += bc / 2;
    00580 84AC      LDD	R10,Y+12
    00581 84BD      LDD	R11,Y+13
    00582 0115      MOVW	R2,R10
    00583 9436      LSR	R3
    00584 9427      ROR	R2
    00585 0CA2      ADD	R10,R2
    00586 1CB3      ADC	R11,R3
(0834) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00587 E029      LDI	R18,0x9
    00588 E030      LDI	R19,0
    00589 0185      MOVW	R16,R10
    0058A 940E 4338 CALL	lsr16
    0058C 0118      MOVW	R2,R16
    0058D 2444      CLR	R4
    0058E 2455      CLR	R5
    0058F 01F6      MOVW	R30,R12
    00590 8C66      LDD	R6,Z+30
    00591 8C77      LDD	R7,Z+31
    00592 A080      LDD	R8,Z+32
    00593 A091      LDD	R9,Z+33
    00594 0C62      ADD	R6,R2
    00595 1C73      ADC	R7,R3
    00596 1C84      ADC	R8,R4
    00597 1C95      ADC	R9,R5
    00598 8288      ST	Y,R8
    00599 8299      STD	Y+1,R9
    0059A 0193      MOVW	R18,R6
    0059B 018F      MOVW	R16,R30
    0059C DDE0      RCALL	ff.c:move_window
    0059D 2300      TST	R16
    0059E F009      BEQ	0x05A0
    0059F C0ED      RJMP	0x068D
(0835) 		wc = fs->win[bc % SS(fs)]; bc++;
    005A0 01C6      MOVW	R24,R12
    005A1 968E      ADIW	R24,0x2E
    005A2 01F5      MOVW	R30,R10
    005A3 70F1      ANDI	R31,1
    005A4 0FE8      ADD	R30,R24
    005A5 1FF9      ADC	R31,R25
    005A6 80E0      LD	R14,Z
    005A7 24FF      CLR	R15
    005A8 01C5      MOVW	R24,R10
    005A9 9601      ADIW	R24,1
    005AA 015C      MOVW	R10,R24
(0836) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    005AB E029      LDI	R18,0x9
    005AC E030      LDI	R19,0
    005AD 018C      MOVW	R16,R24
    005AE 940E 4338 CALL	lsr16
    005B0 0118      MOVW	R2,R16
    005B1 2444      CLR	R4
    005B2 2455      CLR	R5
    005B3 01F6      MOVW	R30,R12
    005B4 8C66      LDD	R6,Z+30
    005B5 8C77      LDD	R7,Z+31
    005B6 A080      LDD	R8,Z+32
    005B7 A091      LDD	R9,Z+33
    005B8 0C62      ADD	R6,R2
    005B9 1C73      ADC	R7,R3
    005BA 1C84      ADC	R8,R4
    005BB 1C95      ADC	R9,R5
    005BC 8288      ST	Y,R8
    005BD 8299      STD	Y+1,R9
    005BE 0193      MOVW	R18,R6
    005BF 018F      MOVW	R16,R30
    005C0 DDBC      RCALL	ff.c:move_window
    005C1 2300      TST	R16
    005C2 F009      BEQ	0x05C4
    005C3 C0C9      RJMP	0x068D
(0837) 		wc |= fs->win[bc % SS(fs)] << 8;
    005C4 01C6      MOVW	R24,R12
    005C5 968E      ADIW	R24,0x2E
    005C6 01F5      MOVW	R30,R10
    005C7 70F1      ANDI	R31,1
    005C8 0FE8      ADD	R30,R24
    005C9 1FF9      ADC	R31,R25
    005CA 8020      LD	R2,Z
    005CB 2433      CLR	R3
    005CC 2C32      MOV	R3,R2
    005CD 2422      CLR	R2
    005CE 28E2      OR	R14,R2
    005CF 28F3      OR	R15,R3
(0838) 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    005D0 842C      LDD	R2,Y+12
    005D1 843D      LDD	R3,Y+13
    005D2 844E      LDD	R4,Y+14
    005D3 845F      LDD	R5,Y+15
    005D4 2DE2      MOV	R30,R2
    005D5 70E1      ANDI	R30,1
    005D6 F051      BEQ	0x05E1
    005D7 0157      MOVW	R10,R14
    005D8 94B6      LSR	R11
    005D9 94A7      ROR	R10
    005DA 94B6      LSR	R11
    005DB 94A7      ROR	R10
    005DC 94B6      LSR	R11
    005DD 94A7      ROR	R10
    005DE 94B6      LSR	R11
    005DF 94A7      ROR	R10
    005E0 C003      RJMP	0x05E4
    005E1 01C7      MOVW	R24,R14
    005E2 709F      ANDI	R25,0xF
    005E3 015C      MOVW	R10,R24
    005E4 0185      MOVW	R16,R10
    005E5 0196      MOVW	R18,R12
    005E6 2722      CLR	R18
    005E7 2733      CLR	R19
    005E8 C0A8      RJMP	0x0691
(0839) 
(0840) 	case FS_FAT16 :
(0841) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    005E9 E088      LDI	R24,0x8
    005EA E090      LDI	R25,0
    005EB 850C      LDD	R16,Y+12
    005EC 851D      LDD	R17,Y+13
    005ED 852E      LDD	R18,Y+14
    005EE 853F      LDD	R19,Y+15
    005EF 938A      ST	-Y,R24
    005F0 940E 433F CALL	lsr32
    005F2 01F6      MOVW	R30,R12
    005F3 8C26      LDD	R2,Z+30
    005F4 8C37      LDD	R3,Z+31
    005F5 A040      LDD	R4,Z+32
    005F6 A051      LDD	R5,Z+33
    005F7 0E20      ADD	R2,R16
    005F8 1E31      ADC	R3,R17
    005F9 1E42      ADC	R4,R18
    005FA 1E53      ADC	R5,R19
    005FB 8248      ST	Y,R4
    005FC 8259      STD	Y+1,R5
    005FD 0191      MOVW	R18,R2
    005FE 018F      MOVW	R16,R30
    005FF DD7D      RCALL	ff.c:move_window
    00600 2EA0      MOV	R10,R16
    00601 2300      TST	R16
    00602 F009      BEQ	0x0604
    00603 C089      RJMP	0x068D
(0842) 		p = &fs->win[clst * 2 % SS(fs)];
    00604 EF4F      LDI	R20,0xFF
    00605 E051      LDI	R21,1
    00606 E060      LDI	R22,0
    00607 E070      LDI	R23,0
    00608 842C      LDD	R2,Y+12
    00609 843D      LDD	R3,Y+13
    0060A 844E      LDD	R4,Y+14
    0060B 845F      LDD	R5,Y+15
    0060C 0C22      LSL	R2
    0060D 1C33      ROL	R3
    0060E 1C44      ROL	R4
    0060F 1C55      ROL	R5
    00610 2224      AND	R2,R20
    00611 2235      AND	R3,R21
    00612 2246      AND	R4,R22
    00613 2257      AND	R5,R23
    00614 0151      MOVW	R10,R2
    00615 01C6      MOVW	R24,R12
    00616 968E      ADIW	R24,0x2E
    00617 0EA8      ADD	R10,R24
    00618 1EB9      ADC	R11,R25
(0843) 		return LD_WORD(p);
    00619 01F5      MOVW	R30,R10
    0061A 8020      LD	R2,Z
    0061B 2433      CLR	R3
    0061C 8101      LDD	R16,Z+1
    0061D 2711      CLR	R17
    0061E 2F10      MOV	R17,R16
    0061F 2700      CLR	R16
    00620 2902      OR	R16,R2
    00621 2913      OR	R17,R3
    00622 2722      CLR	R18
    00623 2733      CLR	R19
    00624 C06C      RJMP	0x0691
(0844) 
(0845) 	case FS_FAT32 :
(0846) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    00625 E087      LDI	R24,7
    00626 E090      LDI	R25,0
    00627 850C      LDD	R16,Y+12
    00628 851D      LDD	R17,Y+13
    00629 852E      LDD	R18,Y+14
    0062A 853F      LDD	R19,Y+15
    0062B 938A      ST	-Y,R24
    0062C 940E 433F CALL	lsr32
    0062E 01F6      MOVW	R30,R12
    0062F 8C26      LDD	R2,Z+30
    00630 8C37      LDD	R3,Z+31
    00631 A040      LDD	R4,Z+32
    00632 A051      LDD	R5,Z+33
    00633 0E20      ADD	R2,R16
    00634 1E31      ADC	R3,R17
    00635 1E42      ADC	R4,R18
    00636 1E53      ADC	R5,R19
    00637 8248      ST	Y,R4
    00638 8259      STD	Y+1,R5
    00639 0191      MOVW	R18,R2
    0063A 018F      MOVW	R16,R30
    0063B DD41      RCALL	ff.c:move_window
    0063C 2EE0      MOV	R14,R16
    0063D 2300      TST	R16
    0063E F009      BEQ	0x0640
    0063F C04D      RJMP	0x068D
(0847) 		p = &fs->win[clst * 4 % SS(fs)];
    00640 E082      LDI	R24,2
    00641 E090      LDI	R25,0
    00642 850C      LDD	R16,Y+12
    00643 851D      LDD	R17,Y+13
    00644 852E      LDD	R18,Y+14
    00645 853F      LDD	R19,Y+15
    00646 938A      ST	-Y,R24
    00647 940E 4326 CALL	lsl32
    00649 0118      MOVW	R2,R16
    0064A 0129      MOVW	R4,R18
    0064B EF4F      LDI	R20,0xFF
    0064C E051      LDI	R21,1
    0064D E060      LDI	R22,0
    0064E E070      LDI	R23,0
    0064F 2224      AND	R2,R20
    00650 2235      AND	R3,R21
    00651 2246      AND	R4,R22
    00652 2257      AND	R5,R23
    00653 0151      MOVW	R10,R2
    00654 01C6      MOVW	R24,R12
    00655 968E      ADIW	R24,0x2E
    00656 0EA8      ADD	R10,R24
    00657 1EB9      ADC	R11,R25
(0848) 		return LD_DWORD(p) & 0x0FFFFFFF;
    00658 E188      LDI	R24,0x18
    00659 E090      LDI	R25,0
    0065A 01F5      MOVW	R30,R10
    0065B 8103      LDD	R16,Z+3
    0065C 2711      CLR	R17
    0065D 2722      CLR	R18
    0065E 2733      CLR	R19
    0065F 938A      ST	-Y,R24
    00660 940E 4326 CALL	lsl32
    00662 0118      MOVW	R2,R16
    00663 0129      MOVW	R4,R18
    00664 01F5      MOVW	R30,R10
    00665 8062      LDD	R6,Z+2
    00666 2477      CLR	R7
    00667 2488      CLR	R8
    00668 2499      CLR	R9
    00669 0143      MOVW	R8,R6
    0066A 2466      CLR	R6
    0066B 2477      CLR	R7
    0066C 2826      OR	R2,R6
    0066D 2837      OR	R3,R7
    0066E 2848      OR	R4,R8
    0066F 2859      OR	R5,R9
    00670 8061      LDD	R6,Z+1
    00671 2477      CLR	R7
    00672 2C76      MOV	R7,R6
    00673 2466      CLR	R6
    00674 2488      CLR	R8
    00675 2499      CLR	R9
    00676 2826      OR	R2,R6
    00677 2837      OR	R3,R7
    00678 2848      OR	R4,R8
    00679 2859      OR	R5,R9
    0067A 8060      LD	R6,Z
    0067B 2477      CLR	R7
    0067C 2488      CLR	R8
    0067D 2499      CLR	R9
    0067E 2826      OR	R2,R6
    0067F 2837      OR	R3,R7
    00680 2848      OR	R4,R8
    00681 2859      OR	R5,R9
    00682 EF4F      LDI	R20,0xFF
    00683 EF5F      LDI	R21,0xFF
    00684 EF6F      LDI	R22,0xFF
    00685 E07F      LDI	R23,0xF
    00686 2224      AND	R2,R20
    00687 2235      AND	R3,R21
    00688 2246      AND	R4,R22
    00689 2257      AND	R5,R23
    0068A 0181      MOVW	R16,R2
    0068B 0192      MOVW	R18,R4
    0068C C004      RJMP	0x0691
(0849) 	}
(0850) 
(0851) 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    0068D EF0F      LDI	R16,0xFF
    0068E EF1F      LDI	R17,0xFF
    0068F EF2F      LDI	R18,0xFF
    00690 EF3F      LDI	R19,0xFF
    00691 9622      ADIW	R28,2
    00692 940E 4299 CALL	pop_xgsetF0FC
    00694 9622      ADIW	R28,2
    00695 9508      RET
_put_fat:
  bc                   --> R12
  p                    --> R14
  res                  --> Y,+2
  val                  --> Y,+19
  clst                 --> Y,+15
  fs                   --> Y,+13
    00696 940E 415F CALL	push_arg4
    00698 940E 42A4 CALL	push_xgsetF0FC
    0069A 9723      SBIW	R28,3
(0852) }
(0853) 
(0854) 
(0855) 
(0856) 
(0857) /*-----------------------------------------------------------------------*/
(0858) /* FAT access - Change value of a FAT entry                              */
(0859) /*-----------------------------------------------------------------------*/
(0860) #if !_FS_READONLY
(0861) 
(0862) FRESULT put_fat (
(0863) 	FATFS *fs,	/* File system object */
(0864) 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
(0865) 	DWORD val	/* New value to mark the cluster */
(0866) )
(0867) {
(0868) 	UINT bc;
(0869) 	BYTE *p;
(0870) 	FRESULT res;
(0871) 
(0872) 
(0873) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    0069B E042      LDI	R20,2
    0069C E050      LDI	R21,0
    0069D E060      LDI	R22,0
    0069E E070      LDI	R23,0
    0069F 842F      LDD	R2,Y+15
    006A0 8838      LDD	R3,Y+16
    006A1 8849      LDD	R4,Y+17
    006A2 885A      LDD	R5,Y+18
    006A3 1624      CP	R2,R20
    006A4 0635      CPC	R3,R21
    006A5 0646      CPC	R4,R22
    006A6 0657      CPC	R5,R23
    006A7 F080      BCS	0x06B8
    006A8 85ED      LDD	R30,Y+13
    006A9 85FE      LDD	R31,Y+14
    006AA 9676      ADIW	R30,0x16
    006AB 8020      LD	R2,Z
    006AC 8031      LDD	R3,Z+1
    006AD 8042      LDD	R4,Z+2
    006AE 8053      LDD	R5,Z+3
    006AF 846F      LDD	R6,Y+15
    006B0 8878      LDD	R7,Y+16
    006B1 8889      LDD	R8,Y+17
    006B2 889A      LDD	R9,Y+18
    006B3 1462      CP	R6,R2
    006B4 0473      CPC	R7,R3
    006B5 0484      CPC	R8,R4
    006B6 0495      CPC	R9,R5
    006B7 F018      BCS	0x06BB
(0874) 		res = FR_INT_ERR;
    006B8 E082      LDI	R24,2
    006B9 838A      STD	Y+2,R24
(0875) 
(0876) 	} else {
    006BA C194      RJMP	0x084F
(0877) 		switch (fs->fs_type) {
    006BB 85ED      LDD	R30,Y+13
    006BC 85FE      LDD	R31,Y+14
    006BD 80A0      LD	R10,Z
    006BE 24BB      CLR	R11
    006BF 01C5      MOVW	R24,R10
    006C0 3081      CPI	R24,1
    006C1 E0E0      LDI	R30,0
    006C2 079E      CPC	R25,R30
    006C3 F059      BEQ	0x06CF
    006C4 3082      CPI	R24,2
    006C5 E0E0      LDI	R30,0
    006C6 079E      CPC	R25,R30
    006C7 F409      BNE	0x06C9
    006C8 C0B0      RJMP	0x0779
    006C9 3083      CPI	R24,3
    006CA E0E0      LDI	R30,0
    006CB 079E      CPC	R25,R30
    006CC F409      BNE	0x06CE
    006CD C0E7      RJMP	0x07B5
    006CE C17A      RJMP	0x0849
(0878) 		case FS_FAT12 :
(0879) 			bc = clst; bc += bc / 2;
    006CF 84CF      LDD	R12,Y+15
    006D0 88D8      LDD	R13,Y+16
    006D1 0116      MOVW	R2,R12
    006D2 9436      LSR	R3
    006D3 9427      ROR	R2
    006D4 0CC2      ADD	R12,R2
    006D5 1CD3      ADC	R13,R3
(0880) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006D6 E029      LDI	R18,0x9
    006D7 E030      LDI	R19,0
    006D8 0186      MOVW	R16,R12
    006D9 940E 4338 CALL	lsr16
    006DB 0118      MOVW	R2,R16
    006DC 2444      CLR	R4
    006DD 2455      CLR	R5
    006DE 85ED      LDD	R30,Y+13
    006DF 85FE      LDD	R31,Y+14
    006E0 8C66      LDD	R6,Z+30
    006E1 8C77      LDD	R7,Z+31
    006E2 A080      LDD	R8,Z+32
    006E3 A091      LDD	R9,Z+33
    006E4 0C62      ADD	R6,R2
    006E5 1C73      ADC	R7,R3
    006E6 1C84      ADC	R8,R4
    006E7 1C95      ADC	R9,R5
    006E8 8288      ST	Y,R8
    006E9 8299      STD	Y+1,R9
    006EA 0193      MOVW	R18,R6
    006EB 018F      MOVW	R16,R30
    006EC DC90      RCALL	ff.c:move_window
    006ED 830A      STD	Y+2,R16
(0881) 			if (res != FR_OK) break;
    006EE 2E00      MOV	R0,R16
    006EF 2300      TST	R16
    006F0 F009      BEQ	0x06F2
    006F1 C159      RJMP	0x084B
(0882) 			p = &fs->win[bc % SS(fs)];
    006F2 858D      LDD	R24,Y+13
    006F3 859E      LDD	R25,Y+14
    006F4 968E      ADIW	R24,0x2E
    006F5 01F6      MOVW	R30,R12
    006F6 70F1      ANDI	R31,1
    006F7 017F      MOVW	R14,R30
    006F8 0EE8      ADD	R14,R24
    006F9 1EF9      ADC	R15,R25
(0883) 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    006FA 842F      LDD	R2,Y+15
    006FB 8838      LDD	R3,Y+16
    006FC 8849      LDD	R4,Y+17
    006FD 885A      LDD	R5,Y+18
    006FE 93EF      PUSH	R30
    006FF 2DE2      MOV	R30,R2
    00700 70E1      ANDI	R30,1
    00701 91EF      POP	R30
    00702 F0B1      BEQ	0x0719
    00703 882B      LDD	R2,Y+19
    00704 883C      LDD	R3,Y+20
    00705 884D      LDD	R4,Y+21
    00706 885E      LDD	R5,Y+22
    00707 2433      CLR	R3
    00708 0C22      LSL	R2
    00709 1C33      ROL	R3
    0070A 0C22      LSL	R2
    0070B 1C33      ROL	R3
    0070C 0C22      LSL	R2
    0070D 1C33      ROL	R3
    0070E 0C22      LSL	R2
    0070F 1C33      ROL	R3
    00710 01F7      MOVW	R30,R14
    00711 8180      LD	R24,Z
    00712 2799      CLR	R25
    00713 708F      ANDI	R24,0xF
    00714 7090      ANDI	R25,0
    00715 015C      MOVW	R10,R24
    00716 28A2      OR	R10,R2
    00717 28B3      OR	R11,R3
    00718 C006      RJMP	0x071F
    00719 882B      LDD	R2,Y+19
    0071A 883C      LDD	R3,Y+20
    0071B 884D      LDD	R4,Y+21
    0071C 885E      LDD	R5,Y+22
    0071D 2CA2      MOV	R10,R2
    0071E 24BB      CLR	R11
    0071F 01F7      MOVW	R30,R14
    00720 82A0      ST	Z,R10
(0884) 			bc++;
    00721 01C6      MOVW	R24,R12
    00722 9601      ADIW	R24,1
    00723 016C      MOVW	R12,R24
(0885) 			fs->wflag = 1;
    00724 E081      LDI	R24,1
    00725 85ED      LDD	R30,Y+13
    00726 85FE      LDD	R31,Y+14
    00727 8384      STD	Z+4,R24
(0886) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    00728 E029      LDI	R18,0x9
    00729 E030      LDI	R19,0
    0072A 0186      MOVW	R16,R12
    0072B 940E 4338 CALL	lsr16
    0072D 0118      MOVW	R2,R16
    0072E 2444      CLR	R4
    0072F 2455      CLR	R5
    00730 85ED      LDD	R30,Y+13
    00731 85FE      LDD	R31,Y+14
    00732 8C66      LDD	R6,Z+30
    00733 8C77      LDD	R7,Z+31
    00734 A080      LDD	R8,Z+32
    00735 A091      LDD	R9,Z+33
    00736 0C62      ADD	R6,R2
    00737 1C73      ADC	R7,R3
    00738 1C84      ADC	R8,R4
    00739 1C95      ADC	R9,R5
    0073A 8288      ST	Y,R8
    0073B 8299      STD	Y+1,R9
    0073C 0193      MOVW	R18,R6
    0073D 018F      MOVW	R16,R30
    0073E DC3E      RCALL	ff.c:move_window
    0073F 830A      STD	Y+2,R16
(0887) 			if (res != FR_OK) break;
    00740 2E00      MOV	R0,R16
    00741 2300      TST	R16
    00742 F009      BEQ	0x0744
    00743 C107      RJMP	0x084B
(0888) 			p = &fs->win[bc % SS(fs)];
    00744 858D      LDD	R24,Y+13
    00745 859E      LDD	R25,Y+14
    00746 968E      ADIW	R24,0x2E
    00747 01F6      MOVW	R30,R12
    00748 70F1      ANDI	R31,1
    00749 017F      MOVW	R14,R30
    0074A 0EE8      ADD	R14,R24
    0074B 1EF9      ADC	R15,R25
(0889) 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    0074C 842F      LDD	R2,Y+15
    0074D 8838      LDD	R3,Y+16
    0074E 8849      LDD	R4,Y+17
    0074F 885A      LDD	R5,Y+18
    00750 93EF      PUSH	R30
    00751 2DE2      MOV	R30,R2
    00752 70E1      ANDI	R30,1
    00753 91EF      POP	R30
    00754 F061      BEQ	0x0761
    00755 E084      LDI	R24,4
    00756 E090      LDI	R25,0
    00757 890B      LDD	R16,Y+19
    00758 891C      LDD	R17,Y+20
    00759 892D      LDD	R18,Y+21
    0075A 893E      LDD	R19,Y+22
    0075B 938A      ST	-Y,R24
    0075C 940E 433F CALL	lsr32
    0075E 2EC0      MOV	R12,R16
    0075F 24DD      CLR	R13
    00760 C015      RJMP	0x0776
    00761 E088      LDI	R24,0x8
    00762 E090      LDI	R25,0
    00763 890B      LDD	R16,Y+19
    00764 891C      LDD	R17,Y+20
    00765 892D      LDD	R18,Y+21
    00766 893E      LDD	R19,Y+22
    00767 938A      ST	-Y,R24
    00768 940E 433F CALL	lsr32
    0076A 2F80      MOV	R24,R16
    0076B 2799      CLR	R25
    0076C 708F      ANDI	R24,0xF
    0076D 7090      ANDI	R25,0
    0076E 01F7      MOVW	R30,R14
    0076F 81E0      LD	R30,Z
    00770 27FF      CLR	R31
    00771 7FE0      ANDI	R30,0xF0
    00772 70F0      ANDI	R31,0
    00773 016F      MOVW	R12,R30
    00774 2AC8      OR	R12,R24
    00775 2AD9      OR	R13,R25
    00776 01F7      MOVW	R30,R14
    00777 82C0      ST	Z,R12
(0890) 			break;
    00778 C0D2      RJMP	0x084B
(0891) 
(0892) 		case FS_FAT16 :
(0893) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    00779 E088      LDI	R24,0x8
    0077A E090      LDI	R25,0
    0077B 850F      LDD	R16,Y+15
    0077C 8918      LDD	R17,Y+16
    0077D 8929      LDD	R18,Y+17
    0077E 893A      LDD	R19,Y+18
    0077F 938A      ST	-Y,R24
    00780 940E 433F CALL	lsr32
    00782 85ED      LDD	R30,Y+13
    00783 85FE      LDD	R31,Y+14
    00784 8C26      LDD	R2,Z+30
    00785 8C37      LDD	R3,Z+31
    00786 A040      LDD	R4,Z+32
    00787 A051      LDD	R5,Z+33
    00788 0E20      ADD	R2,R16
    00789 1E31      ADC	R3,R17
    0078A 1E42      ADC	R4,R18
    0078B 1E53      ADC	R5,R19
    0078C 8248      ST	Y,R4
    0078D 8259      STD	Y+1,R5
    0078E 0191      MOVW	R18,R2
    0078F 018F      MOVW	R16,R30
    00790 DBEC      RCALL	ff.c:move_window
    00791 2EC0      MOV	R12,R16
    00792 82CA      STD	Y+2,R12
(0894) 			if (res != FR_OK) break;
    00793 2C0C      MOV	R0,R12
    00794 2300      TST	R16
    00795 F009      BEQ	0x0797
    00796 C0B4      RJMP	0x084B
(0895) 			p = &fs->win[clst * 2 % SS(fs)];
    00797 EF4F      LDI	R20,0xFF
    00798 E051      LDI	R21,1
    00799 E060      LDI	R22,0
    0079A E070      LDI	R23,0
    0079B 842F      LDD	R2,Y+15
    0079C 8838      LDD	R3,Y+16
    0079D 8849      LDD	R4,Y+17
    0079E 885A      LDD	R5,Y+18
    0079F 0C22      LSL	R2
    007A0 1C33      ROL	R3
    007A1 1C44      ROL	R4
    007A2 1C55      ROL	R5
    007A3 2224      AND	R2,R20
    007A4 2235      AND	R3,R21
    007A5 2246      AND	R4,R22
    007A6 2257      AND	R5,R23
    007A7 0171      MOVW	R14,R2
    007A8 858D      LDD	R24,Y+13
    007A9 859E      LDD	R25,Y+14
    007AA 968E      ADIW	R24,0x2E
    007AB 0EE8      ADD	R14,R24
    007AC 1EF9      ADC	R15,R25
(0896) 			ST_WORD(p, (WORD)val);
    007AD 882B      LDD	R2,Y+19
    007AE 883C      LDD	R3,Y+20
    007AF 01F7      MOVW	R30,R14
    007B0 8220      ST	Z,R2
    007B1 2C23      MOV	R2,R3
    007B2 2433      CLR	R3
    007B3 8221      STD	Z+1,R2
(0897) 			break;
    007B4 C096      RJMP	0x084B
(0898) 
(0899) 		case FS_FAT32 :
(0900) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    007B5 E087      LDI	R24,7
    007B6 E090      LDI	R25,0
    007B7 850F      LDD	R16,Y+15
    007B8 8918      LDD	R17,Y+16
    007B9 8929      LDD	R18,Y+17
    007BA 893A      LDD	R19,Y+18
    007BB 938A      ST	-Y,R24
    007BC 940E 433F CALL	lsr32
    007BE 85ED      LDD	R30,Y+13
    007BF 85FE      LDD	R31,Y+14
    007C0 8C26      LDD	R2,Z+30
    007C1 8C37      LDD	R3,Z+31
    007C2 A040      LDD	R4,Z+32
    007C3 A051      LDD	R5,Z+33
    007C4 0E20      ADD	R2,R16
    007C5 1E31      ADC	R3,R17
    007C6 1E42      ADC	R4,R18
    007C7 1E53      ADC	R5,R19
    007C8 8248      ST	Y,R4
    007C9 8259      STD	Y+1,R5
    007CA 0191      MOVW	R18,R2
    007CB 018F      MOVW	R16,R30
    007CC DBB0      RCALL	ff.c:move_window
    007CD 2EC0      MOV	R12,R16
    007CE 82CA      STD	Y+2,R12
(0901) 			if (res != FR_OK) break;
    007CF 2C0C      MOV	R0,R12
    007D0 2300      TST	R16
    007D1 F009      BEQ	0x07D3
    007D2 C078      RJMP	0x084B
(0902) 			p = &fs->win[clst * 4 % SS(fs)];
    007D3 E082      LDI	R24,2
    007D4 E090      LDI	R25,0
    007D5 850F      LDD	R16,Y+15
    007D6 8918      LDD	R17,Y+16
    007D7 8929      LDD	R18,Y+17
    007D8 893A      LDD	R19,Y+18
    007D9 938A      ST	-Y,R24
    007DA 940E 4326 CALL	lsl32
    007DC 0118      MOVW	R2,R16
    007DD 0129      MOVW	R4,R18
    007DE EF4F      LDI	R20,0xFF
    007DF E051      LDI	R21,1
    007E0 E060      LDI	R22,0
    007E1 E070      LDI	R23,0
    007E2 2224      AND	R2,R20
    007E3 2235      AND	R3,R21
    007E4 2246      AND	R4,R22
    007E5 2257      AND	R5,R23
    007E6 0171      MOVW	R14,R2
    007E7 858D      LDD	R24,Y+13
    007E8 859E      LDD	R25,Y+14
    007E9 968E      ADIW	R24,0x2E
    007EA 0EE8      ADD	R14,R24
    007EB 1EF9      ADC	R15,R25
(0903) 			val |= LD_DWORD(p) & 0xF0000000;
    007EC E188      LDI	R24,0x18
    007ED E090      LDI	R25,0
    007EE 01F7      MOVW	R30,R14
    007EF 8103      LDD	R16,Z+3
    007F0 2711      CLR	R17
    007F1 2722      CLR	R18
    007F2 2733      CLR	R19
    007F3 938A      ST	-Y,R24
    007F4 940E 4326 CALL	lsl32
    007F6 0118      MOVW	R2,R16
    007F7 0129      MOVW	R4,R18
    007F8 01F7      MOVW	R30,R14
    007F9 8062      LDD	R6,Z+2
    007FA 2477      CLR	R7
    007FB 2488      CLR	R8
    007FC 2499      CLR	R9
    007FD 0143      MOVW	R8,R6
    007FE 2466      CLR	R6
    007FF 2477      CLR	R7
    00800 2826      OR	R2,R6
    00801 2837      OR	R3,R7
    00802 2848      OR	R4,R8
    00803 2859      OR	R5,R9
    00804 8061      LDD	R6,Z+1
    00805 2477      CLR	R7
    00806 2C76      MOV	R7,R6
    00807 2466      CLR	R6
    00808 2488      CLR	R8
    00809 2499      CLR	R9
    0080A 2826      OR	R2,R6
    0080B 2837      OR	R3,R7
    0080C 2848      OR	R4,R8
    0080D 2859      OR	R5,R9
    0080E 8060      LD	R6,Z
    0080F 2477      CLR	R7
    00810 2488      CLR	R8
    00811 2499      CLR	R9
    00812 2826      OR	R2,R6
    00813 2837      OR	R3,R7
    00814 2848      OR	R4,R8
    00815 2859      OR	R5,R9
    00816 E040      LDI	R20,0
    00817 E050      LDI	R21,0
    00818 E060      LDI	R22,0
    00819 EF70      LDI	R23,0xF0
    0081A 2224      AND	R2,R20
    0081B 2235      AND	R3,R21
    0081C 2246      AND	R4,R22
    0081D 2257      AND	R5,R23
    0081E 886B      LDD	R6,Y+19
    0081F 887C      LDD	R7,Y+20
    00820 888D      LDD	R8,Y+21
    00821 889E      LDD	R9,Y+22
    00822 2862      OR	R6,R2
    00823 2873      OR	R7,R3
    00824 2884      OR	R8,R4
    00825 2895      OR	R9,R5
    00826 8A6B      STD	Y+19,R6
    00827 8A7C      STD	Y+20,R7
    00828 8A8D      STD	Y+21,R8
    00829 8A9E      STD	Y+22,R9
(0904) 			ST_DWORD(p, val);
    0082A 882B      LDD	R2,Y+19
    0082B 883C      LDD	R3,Y+20
    0082C 884D      LDD	R4,Y+21
    0082D 885E      LDD	R5,Y+22
    0082E 8220      ST	Z,R2
    0082F 2C23      MOV	R2,R3
    00830 2433      CLR	R3
    00831 9631      ADIW	R30,1
    00832 8220      ST	Z,R2
    00833 882B      LDD	R2,Y+19
    00834 883C      LDD	R3,Y+20
    00835 884D      LDD	R4,Y+21
    00836 885E      LDD	R5,Y+22
    00837 0112      MOVW	R2,R4
    00838 2444      CLR	R4
    00839 2455      CLR	R5
    0083A 01F7      MOVW	R30,R14
    0083B 9632      ADIW	R30,2
    0083C 8220      ST	Z,R2
    0083D E188      LDI	R24,0x18
    0083E E090      LDI	R25,0
    0083F 890B      LDD	R16,Y+19
    00840 891C      LDD	R17,Y+20
    00841 892D      LDD	R18,Y+21
    00842 893E      LDD	R19,Y+22
    00843 938A      ST	-Y,R24
    00844 940E 433F CALL	lsr32
    00846 01F7      MOVW	R30,R14
    00847 8303      STD	Z+3,R16
(0905) 			break;
    00848 C002      RJMP	0x084B
(0906) 
(0907) 		default :
(0908) 			res = FR_INT_ERR;
    00849 E082      LDI	R24,2
    0084A 838A      STD	Y+2,R24
(0909) 		}
(0910) 		fs->wflag = 1;
    0084B E081      LDI	R24,1
    0084C 85ED      LDD	R30,Y+13
    0084D 85FE      LDD	R31,Y+14
    0084E 8384      STD	Z+4,R24
(0911) 	}
(0912) 
(0913) 	return res;
    0084F 810A      LDD	R16,Y+2
    00850 9623      ADIW	R28,3
    00851 940E 4299 CALL	pop_xgsetF0FC
    00853 9624      ADIW	R28,4
    00854 9508      RET
ff.c:remove_chain:
  res                  --> R10
  nxt                  --> Y,+6
  clst                 --> Y,+18
  fs                   --> R12
    00855 933A      ST	-Y,R19
    00856 932A      ST	-Y,R18
    00857 940E 42DF CALL	push_xgsetF03C
    00859 0168      MOVW	R12,R16
    0085A 972A      SBIW	R28,0xA
(0914) }
(0915) #endif /* !_FS_READONLY */
(0916) 
(0917) 
(0918) 
(0919) 
(0920) /*-----------------------------------------------------------------------*/
(0921) /* FAT handling - Remove a cluster chain                                 */
(0922) /*-----------------------------------------------------------------------*/
(0923) #if !_FS_READONLY
(0924) static
(0925) FRESULT remove_chain (
(0926) 	FATFS *fs,			/* File system object */
(0927) 	DWORD clst			/* Cluster# to remove a chain from */
(0928) )
(0929) {
(0930) 	FRESULT res;
(0931) 	DWORD nxt;
(0932) #if _USE_ERASE
(0933) 	DWORD scl = clst, ecl = clst, resion[2];
(0934) #endif
(0935) 
(0936) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    0085B E042      LDI	R20,2
    0085C E050      LDI	R21,0
    0085D E060      LDI	R22,0
    0085E E070      LDI	R23,0
    0085F 882A      LDD	R2,Y+18
    00860 883B      LDD	R3,Y+19
    00861 884C      LDD	R4,Y+20
    00862 885D      LDD	R5,Y+21
    00863 1624      CP	R2,R20
    00864 0635      CPC	R3,R21
    00865 0646      CPC	R4,R22
    00866 0657      CPC	R5,R23
    00867 F078      BCS	0x0877
    00868 01F6      MOVW	R30,R12
    00869 9676      ADIW	R30,0x16
    0086A 8020      LD	R2,Z
    0086B 8031      LDD	R3,Z+1
    0086C 8042      LDD	R4,Z+2
    0086D 8053      LDD	R5,Z+3
    0086E 886A      LDD	R6,Y+18
    0086F 887B      LDD	R7,Y+19
    00870 888C      LDD	R8,Y+20
    00871 889D      LDD	R9,Y+21
    00872 1462      CP	R6,R2
    00873 0473      CPC	R7,R3
    00874 0484      CPC	R8,R4
    00875 0495      CPC	R9,R5
    00876 F018      BCS	0x087A
(0937) 		res = FR_INT_ERR;
    00877 E082      LDI	R24,2
    00878 2EA8      MOV	R10,R24
(0938) 
(0939) 	} else {
    00879 C088      RJMP	0x0902
(0940) 		res = FR_OK;
    0087A 24AA      CLR	R10
    0087B C076      RJMP	0x08F2
(0941) 		while (clst < fs->n_fatent) {			/* Not a last link? */
(0942) 			nxt = get_fat(fs, clst);			/* Get cluster status */
    0087C 882A      LDD	R2,Y+18
    0087D 883B      LDD	R3,Y+19
    0087E 884C      LDD	R4,Y+20
    0087F 885D      LDD	R5,Y+21
    00880 8248      ST	Y,R4
    00881 8259      STD	Y+1,R5
    00882 0191      MOVW	R18,R2
    00883 0186      MOVW	R16,R12
    00884 DCC1      RCALL	_get_fat
    00885 830E      STD	Y+6,R16
    00886 831F      STD	Y+7,R17
    00887 8728      STD	Y+8,R18
    00888 8739      STD	Y+9,R19
(0943) 			if (nxt == 0) break;				/* Empty cluster? */
    00889 802E      LDD	R2,Y+6
    0088A 803F      LDD	R3,Y+7
    0088B 8448      LDD	R4,Y+8
    0088C 8459      LDD	R5,Y+9
    0088D 9488      BCLR	0
    0088E 2022      TST	R2
    0088F 0432      CPC	R3,R2
    00890 0442      CPC	R4,R2
    00891 0452      CPC	R5,R2
    00892 F409      BNE	0x0894
    00893 C06E      RJMP	0x0902
(0944) 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    00894 E041      LDI	R20,1
    00895 E050      LDI	R21,0
    00896 E060      LDI	R22,0
    00897 E070      LDI	R23,0
    00898 802E      LDD	R2,Y+6
    00899 803F      LDD	R3,Y+7
    0089A 8448      LDD	R4,Y+8
    0089B 8459      LDD	R5,Y+9
    0089C 1624      CP	R2,R20
    0089D 0635      CPC	R3,R21
    0089E 0646      CPC	R4,R22
    0089F 0657      CPC	R5,R23
    008A0 F419      BNE	0x08A4
    008A1 E082      LDI	R24,2
    008A2 2EA8      MOV	R10,R24
    008A3 C05E      RJMP	0x0902
(0945) 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    008A4 EF4F      LDI	R20,0xFF
    008A5 EF5F      LDI	R21,0xFF
    008A6 EF6F      LDI	R22,0xFF
    008A7 EF7F      LDI	R23,0xFF
    008A8 802E      LDD	R2,Y+6
    008A9 803F      LDD	R3,Y+7
    008AA 8448      LDD	R4,Y+8
    008AB 8459      LDD	R5,Y+9
    008AC 1624      CP	R2,R20
    008AD 0635      CPC	R3,R21
    008AE 0646      CPC	R4,R22
    008AF 0657      CPC	R5,R23
    008B0 F419      BNE	0x08B4
    008B1 24AA      CLR	R10
    008B2 94A3      INC	R10
    008B3 C04E      RJMP	0x0902
(0946) 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    008B4 E080      LDI	R24,0
    008B5 838A      STD	Y+2,R24
    008B6 838B      STD	Y+3,R24
    008B7 838C      STD	Y+4,R24
    008B8 838D      STD	Y+5,R24
    008B9 882A      LDD	R2,Y+18
    008BA 883B      LDD	R3,Y+19
    008BB 884C      LDD	R4,Y+20
    008BC 885D      LDD	R5,Y+21
    008BD 8248      ST	Y,R4
    008BE 8259      STD	Y+1,R5
    008BF 0191      MOVW	R18,R2
    008C0 0186      MOVW	R16,R12
    008C1 DDD4      RCALL	_put_fat
    008C2 2EA0      MOV	R10,R16
(0947) 			if (res != FR_OK) break;
    008C3 2300      TST	R16
    008C4 F009      BEQ	0x08C6
    008C5 C03C      RJMP	0x0902
(0948) 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    008C6 EF4F      LDI	R20,0xFF
    008C7 EF5F      LDI	R21,0xFF
    008C8 EF6F      LDI	R22,0xFF
    008C9 EF7F      LDI	R23,0xFF
    008CA 01F6      MOVW	R30,R12
    008CB 8426      LDD	R2,Z+14
    008CC 8437      LDD	R3,Z+15
    008CD 8840      LDD	R4,Z+16
    008CE 8851      LDD	R5,Z+17
    008CF 1624      CP	R2,R20
    008D0 0635      CPC	R3,R21
    008D1 0646      CPC	R4,R22
    008D2 0657      CPC	R5,R23
    008D3 F0B1      BEQ	0x08EA
(0949) 				fs->free_clust++;
    008D4 01CF      MOVW	R24,R30
    008D5 960E      ADIW	R24,0xE
    008D6 E041      LDI	R20,1
    008D7 E050      LDI	R21,0
    008D8 E060      LDI	R22,0
    008D9 E070      LDI	R23,0
    008DA 01FC      MOVW	R30,R24
    008DB 8020      LD	R2,Z
    008DC 8031      LDD	R3,Z+1
    008DD 8042      LDD	R4,Z+2
    008DE 8053      LDD	R5,Z+3
    008DF 0E24      ADD	R2,R20
    008E0 1E35      ADC	R3,R21
    008E1 1E46      ADC	R4,R22
    008E2 1E57      ADC	R5,R23
    008E3 8220      ST	Z,R2
    008E4 8231      STD	Z+1,R3
    008E5 8242      STD	Z+2,R4
    008E6 8253      STD	Z+3,R5
(0950) 				fs->fsi_flag = 1;
    008E7 E081      LDI	R24,1
    008E8 01F6      MOVW	R30,R12
    008E9 8385      STD	Z+5,R24
(0951) 			}
(0952) #if _USE_ERASE
(0953) 			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
(0954) 				ecl = nxt;
(0955) 			} else {				/* End of contiguous clusters */ 
(0956) 				resion[0] = clust2sect(fs, scl);					/* Start sector */
(0957) 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
(0958) 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
(0959) 				scl = ecl = nxt;
(0960) 			}
(0961) #endif
(0962) 			clst = nxt;	/* Next cluster */
    008EA 802E      LDD	R2,Y+6
    008EB 803F      LDD	R3,Y+7
    008EC 8448      LDD	R4,Y+8
    008ED 8459      LDD	R5,Y+9
    008EE 8A2A      STD	Y+18,R2
    008EF 8A3B      STD	Y+19,R3
    008F0 8A4C      STD	Y+20,R4
    008F1 8A5D      STD	Y+21,R5
    008F2 01F6      MOVW	R30,R12
    008F3 9676      ADIW	R30,0x16
    008F4 8020      LD	R2,Z
    008F5 8031      LDD	R3,Z+1
    008F6 8042      LDD	R4,Z+2
    008F7 8053      LDD	R5,Z+3
    008F8 886A      LDD	R6,Y+18
    008F9 887B      LDD	R7,Y+19
    008FA 888C      LDD	R8,Y+20
    008FB 889D      LDD	R9,Y+21
    008FC 1462      CP	R6,R2
    008FD 0473      CPC	R7,R3
    008FE 0484      CPC	R8,R4
    008FF 0495      CPC	R9,R5
    00900 F408      BCC	0x0902
    00901 CF7A      RJMP	0x087C
(0963) 		}
(0964) 	}
(0965) 
(0966) 	return res;
    00902 2D0A      MOV	R16,R10
    00903 962A      ADIW	R28,0xA
    00904 940E 42E8 CALL	pop_xgsetF03C
    00906 9622      ADIW	R28,2
    00907 9508      RET
ff.c:create_chain:
  res                  --> R10
  scl                  --> Y,+14
  cs                   --> Y,+10
  ncl                  --> Y,+6
  clst                 --> Y,+32
  fs                   --> R12
    00908 933A      ST	-Y,R19
    00909 932A      ST	-Y,R18
    0090A 940E 42A4 CALL	push_xgsetF0FC
    0090C 0168      MOVW	R12,R16
    0090D 9766      SBIW	R28,0x16
(0967) }
(0968) #endif
(0969) 
(0970) 
(0971) 
(0972) 
(0973) /*-----------------------------------------------------------------------*/
(0974) /* FAT handling - Stretch or Create a cluster chain                      */
(0975) /*-----------------------------------------------------------------------*/
(0976) #if !_FS_READONLY
(0977) static
(0978) DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
(0979) 	FATFS *fs,			/* File system object */
(0980) 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
(0981) )
(0982) {
(0983) 	DWORD cs, ncl, scl;
(0984) 	FRESULT res;
(0985) 
(0986) 
(0987) 	if (clst == 0) {		/* Create a new chain */
    0090E A028      LDD	R2,Y+32
    0090F A039      LDD	R3,Y+33
    00910 A04A      LDD	R4,Y+34
    00911 A05B      LDD	R5,Y+35
    00912 9488      BCLR	0
    00913 2022      TST	R2
    00914 0432      CPC	R3,R2
    00915 0442      CPC	R4,R2
    00916 0452      CPC	R5,R2
    00917 F559      BNE	0x0943
(0988) 		scl = fs->last_clust;			/* Get suggested start point */
    00918 01F6      MOVW	R30,R12
    00919 963A      ADIW	R30,0xA
    0091A 8020      LD	R2,Z
    0091B 8031      LDD	R3,Z+1
    0091C 8042      LDD	R4,Z+2
    0091D 8053      LDD	R5,Z+3
    0091E 862E      STD	Y+14,R2
    0091F 863F      STD	Y+15,R3
    00920 8A48      STD	Y+16,R4
    00921 8A59      STD	Y+17,R5
(0989) 		if (!scl || scl >= fs->n_fatent) scl = 1;
    00922 842E      LDD	R2,Y+14
    00923 843F      LDD	R3,Y+15
    00924 8848      LDD	R4,Y+16
    00925 8859      LDD	R5,Y+17
    00926 9488      BCLR	0
    00927 2022      TST	R2
    00928 0432      CPC	R3,R2
    00929 0442      CPC	R4,R2
    0092A 0452      CPC	R5,R2
    0092B F081      BEQ	0x093C
    0092C 01F6      MOVW	R30,R12
    0092D 9676      ADIW	R30,0x16
    0092E 8020      LD	R2,Z
    0092F 8031      LDD	R3,Z+1
    00930 8042      LDD	R4,Z+2
    00931 8053      LDD	R5,Z+3
    00932 846E      LDD	R6,Y+14
    00933 847F      LDD	R7,Y+15
    00934 8888      LDD	R8,Y+16
    00935 8899      LDD	R9,Y+17
    00936 1462      CP	R6,R2
    00937 0473      CPC	R7,R3
    00938 0484      CPC	R8,R4
    00939 0495      CPC	R9,R5
    0093A F408      BCC	0x093C
    0093B C040      RJMP	0x097C
    0093C E081      LDI	R24,1
    0093D 878E      STD	Y+14,R24
    0093E E080      LDI	R24,0
    0093F 878F      STD	Y+15,R24
    00940 8B88      STD	Y+16,R24
    00941 8B89      STD	Y+17,R24
(0990) 	}
    00942 C039      RJMP	0x097C
(0991) 	else {					/* Stretch the current chain */
(0992) 		cs = get_fat(fs, clst);			/* Check the cluster status */
    00943 A028      LDD	R2,Y+32
    00944 A039      LDD	R3,Y+33
    00945 A04A      LDD	R4,Y+34
    00946 A05B      LDD	R5,Y+35
    00947 8248      ST	Y,R4
    00948 8259      STD	Y+1,R5
    00949 0191      MOVW	R18,R2
    0094A 0186      MOVW	R16,R12
    0094B DBFA      RCALL	_get_fat
    0094C 870A      STD	Y+10,R16
    0094D 871B      STD	Y+11,R17
    0094E 872C      STD	Y+12,R18
    0094F 873D      STD	Y+13,R19
(0993) 		if (cs < 2) return 1;			/* It is an invalid cluster */
    00950 E042      LDI	R20,2
    00951 E050      LDI	R21,0
    00952 E060      LDI	R22,0
    00953 E070      LDI	R23,0
    00954 842A      LDD	R2,Y+10
    00955 843B      LDD	R3,Y+11
    00956 844C      LDD	R4,Y+12
    00957 845D      LDD	R5,Y+13
    00958 1624      CP	R2,R20
    00959 0635      CPC	R3,R21
    0095A 0646      CPC	R4,R22
    0095B 0657      CPC	R5,R23
    0095C F428      BCC	0x0962
    0095D E001      LDI	R16,1
    0095E E010      LDI	R17,0
    0095F E020      LDI	R18,0
    00960 E030      LDI	R19,0
    00961 C119      RJMP	0x0A7B
(0994) 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    00962 01F6      MOVW	R30,R12
    00963 9676      ADIW	R30,0x16
    00964 8020      LD	R2,Z
    00965 8031      LDD	R3,Z+1
    00966 8042      LDD	R4,Z+2
    00967 8053      LDD	R5,Z+3
    00968 846A      LDD	R6,Y+10
    00969 847B      LDD	R7,Y+11
    0096A 848C      LDD	R8,Y+12
    0096B 849D      LDD	R9,Y+13
    0096C 1462      CP	R6,R2
    0096D 0473      CPC	R7,R3
    0096E 0484      CPC	R8,R4
    0096F 0495      CPC	R9,R5
    00970 F418      BCC	0x0974
    00971 0183      MOVW	R16,R6
    00972 0194      MOVW	R18,R8
    00973 C107      RJMP	0x0A7B
(0995) 		scl = clst;
    00974 A028      LDD	R2,Y+32
    00975 A039      LDD	R3,Y+33
    00976 A04A      LDD	R4,Y+34
    00977 A05B      LDD	R5,Y+35
    00978 862E      STD	Y+14,R2
    00979 863F      STD	Y+15,R3
    0097A 8A48      STD	Y+16,R4
    0097B 8A59      STD	Y+17,R5
(0996) 	}
(0997) 
(0998) 	ncl = scl;				/* Start cluster */
    0097C 842E      LDD	R2,Y+14
    0097D 843F      LDD	R3,Y+15
    0097E 8848      LDD	R4,Y+16
    0097F 8859      LDD	R5,Y+17
    00980 822E      STD	Y+6,R2
    00981 823F      STD	Y+7,R3
    00982 8648      STD	Y+8,R4
    00983 8659      STD	Y+9,R5
(0999) 	for (;;) {
(1000) 		ncl++;							/* Next cluster */
    00984 E041      LDI	R20,1
    00985 E050      LDI	R21,0
    00986 E060      LDI	R22,0
    00987 E070      LDI	R23,0
    00988 802E      LDD	R2,Y+6
    00989 803F      LDD	R3,Y+7
    0098A 8448      LDD	R4,Y+8
    0098B 8459      LDD	R5,Y+9
    0098C 0E24      ADD	R2,R20
    0098D 1E35      ADC	R3,R21
    0098E 1E46      ADC	R4,R22
    0098F 1E57      ADC	R5,R23
    00990 822E      STD	Y+6,R2
    00991 823F      STD	Y+7,R3
    00992 8648      STD	Y+8,R4
    00993 8659      STD	Y+9,R5
(1001) 		if (ncl >= fs->n_fatent) {		/* Wrap around */
    00994 01F6      MOVW	R30,R12
    00995 9676      ADIW	R30,0x16
    00996 8020      LD	R2,Z
    00997 8031      LDD	R3,Z+1
    00998 8042      LDD	R4,Z+2
    00999 8053      LDD	R5,Z+3
    0099A 806E      LDD	R6,Y+6
    0099B 807F      LDD	R7,Y+7
    0099C 8488      LDD	R8,Y+8
    0099D 8499      LDD	R9,Y+9
    0099E 1462      CP	R6,R2
    0099F 0473      CPC	R7,R3
    009A0 0484      CPC	R8,R4
    009A1 0495      CPC	R9,R5
    009A2 F0C0      BCS	0x09BB
(1002) 			ncl = 2;
    009A3 E082      LDI	R24,2
    009A4 838E      STD	Y+6,R24
    009A5 E080      LDI	R24,0
    009A6 838F      STD	Y+7,R24
    009A7 8788      STD	Y+8,R24
    009A8 8789      STD	Y+9,R24
(1003) 			if (ncl > scl) return 0;	/* No free cluster */
    009A9 842E      LDD	R2,Y+14
    009AA 843F      LDD	R3,Y+15
    009AB 8848      LDD	R4,Y+16
    009AC 8859      LDD	R5,Y+17
    009AD 806E      LDD	R6,Y+6
    009AE 807F      LDD	R7,Y+7
    009AF 8488      LDD	R8,Y+8
    009B0 8499      LDD	R9,Y+9
    009B1 1426      CP	R2,R6
    009B2 0437      CPC	R3,R7
    009B3 0448      CPC	R4,R8
    009B4 0459      CPC	R5,R9
    009B5 F428      BCC	0x09BB
    009B6 E000      LDI	R16,0
    009B7 E010      LDI	R17,0
    009B8 E020      LDI	R18,0
    009B9 E030      LDI	R19,0
    009BA C0C0      RJMP	0x0A7B
(1004) 		}
(1005) 		cs = get_fat(fs, ncl);			/* Get the cluster status */
    009BB 802E      LDD	R2,Y+6
    009BC 803F      LDD	R3,Y+7
    009BD 8448      LDD	R4,Y+8
    009BE 8459      LDD	R5,Y+9
    009BF 8248      ST	Y,R4
    009C0 8259      STD	Y+1,R5
    009C1 0191      MOVW	R18,R2
    009C2 0186      MOVW	R16,R12
    009C3 DB82      RCALL	_get_fat
    009C4 870A      STD	Y+10,R16
    009C5 871B      STD	Y+11,R17
    009C6 872C      STD	Y+12,R18
    009C7 873D      STD	Y+13,R19
(1006) 		if (cs == 0) break;				/* Found a free cluster */
    009C8 842A      LDD	R2,Y+10
    009C9 843B      LDD	R3,Y+11
    009CA 844C      LDD	R4,Y+12
    009CB 845D      LDD	R5,Y+13
    009CC 9488      BCLR	0
    009CD 2022      TST	R2
    009CE 0432      CPC	R3,R2
    009CF 0442      CPC	R4,R2
    009D0 0452      CPC	R5,R2
    009D1 F409      BNE	0x09D3
    009D2 C02E      RJMP	0x0A01
(1007) 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    009D3 EF4F      LDI	R20,0xFF
    009D4 EF5F      LDI	R21,0xFF
    009D5 EF6F      LDI	R22,0xFF
    009D6 EF7F      LDI	R23,0xFF
    009D7 842A      LDD	R2,Y+10
    009D8 843B      LDD	R3,Y+11
    009D9 844C      LDD	R4,Y+12
    009DA 845D      LDD	R5,Y+13
    009DB 1624      CP	R2,R20
    009DC 0635      CPC	R3,R21
    009DD 0646      CPC	R4,R22
    009DE 0657      CPC	R5,R23
    009DF F049      BEQ	0x09E9
    009E0 E041      LDI	R20,1
    009E1 E050      LDI	R21,0
    009E2 E060      LDI	R22,0
    009E3 E070      LDI	R23,0
    009E4 1624      CP	R2,R20
    009E5 0635      CPC	R3,R21
    009E6 0646      CPC	R4,R22
    009E7 0657      CPC	R5,R23
    009E8 F429      BNE	0x09EE
(1008) 			return cs;
    009E9 850A      LDD	R16,Y+10
    009EA 851B      LDD	R17,Y+11
    009EB 852C      LDD	R18,Y+12
    009EC 853D      LDD	R19,Y+13
    009ED C08D      RJMP	0x0A7B
(1009) 		if (ncl == scl) return 0;		/* No free cluster */
    009EE 842E      LDD	R2,Y+14
    009EF 843F      LDD	R3,Y+15
    009F0 8848      LDD	R4,Y+16
    009F1 8859      LDD	R5,Y+17
    009F2 806E      LDD	R6,Y+6
    009F3 807F      LDD	R7,Y+7
    009F4 8488      LDD	R8,Y+8
    009F5 8499      LDD	R9,Y+9
    009F6 1462      CP	R6,R2
    009F7 0473      CPC	R7,R3
    009F8 0484      CPC	R8,R4
    009F9 0495      CPC	R9,R5
    009FA F009      BEQ	0x09FC
    009FB CF88      RJMP	0x0984
    009FC E000      LDI	R16,0
    009FD E010      LDI	R17,0
    009FE E020      LDI	R18,0
    009FF E030      LDI	R19,0
    00A00 C07A      RJMP	0x0A7B
(1010) 	}
(1011) 
(1012) 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    00A01 EF8F      LDI	R24,0xFF
    00A02 838A      STD	Y+2,R24
    00A03 838B      STD	Y+3,R24
    00A04 838C      STD	Y+4,R24
    00A05 E08F      LDI	R24,0xF
    00A06 838D      STD	Y+5,R24
    00A07 802E      LDD	R2,Y+6
    00A08 803F      LDD	R3,Y+7
    00A09 8448      LDD	R4,Y+8
    00A0A 8459      LDD	R5,Y+9
    00A0B 8248      ST	Y,R4
    00A0C 8259      STD	Y+1,R5
    00A0D 0191      MOVW	R18,R2
    00A0E 0186      MOVW	R16,R12
    00A0F DC86      RCALL	_put_fat
    00A10 2EA0      MOV	R10,R16
(1013) 	if (res == FR_OK && clst != 0) {
    00A11 2300      TST	R16
    00A12 F4E1      BNE	0x0A2F
    00A13 A028      LDD	R2,Y+32
    00A14 A039      LDD	R3,Y+33
    00A15 A04A      LDD	R4,Y+34
    00A16 A05B      LDD	R5,Y+35
    00A17 9488      BCLR	0
    00A18 2022      TST	R2
    00A19 0432      CPC	R3,R2
    00A1A 0442      CPC	R4,R2
    00A1B 0452      CPC	R5,R2
    00A1C F091      BEQ	0x0A2F
(1014) 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    00A1D 802E      LDD	R2,Y+6
    00A1E 803F      LDD	R3,Y+7
    00A1F 8448      LDD	R4,Y+8
    00A20 8459      LDD	R5,Y+9
    00A21 822A      STD	Y+2,R2
    00A22 823B      STD	Y+3,R3
    00A23 824C      STD	Y+4,R4
    00A24 825D      STD	Y+5,R5
    00A25 A028      LDD	R2,Y+32
    00A26 A039      LDD	R3,Y+33
    00A27 A04A      LDD	R4,Y+34
    00A28 A05B      LDD	R5,Y+35
    00A29 8248      ST	Y,R4
    00A2A 8259      STD	Y+1,R5
    00A2B 0191      MOVW	R18,R2
    00A2C 0186      MOVW	R16,R12
    00A2D DC68      RCALL	_put_fat
    00A2E 2EA0      MOV	R10,R16
(1015) 	}
(1016) 	if (res == FR_OK) {
    00A2F 20AA      TST	R10
    00A30 F009      BEQ	0x0A32
    00A31 C02E      RJMP	0x0A60
(1017) 		fs->last_clust = ncl;			/* Update FSINFO */
    00A32 802E      LDD	R2,Y+6
    00A33 803F      LDD	R3,Y+7
    00A34 8448      LDD	R4,Y+8
    00A35 8459      LDD	R5,Y+9
    00A36 01F6      MOVW	R30,R12
    00A37 8622      STD	Z+10,R2
    00A38 8633      STD	Z+11,R3
    00A39 8644      STD	Z+12,R4
    00A3A 8655      STD	Z+13,R5
(1018) 		if (fs->free_clust != 0xFFFFFFFF) {
    00A3B EF4F      LDI	R20,0xFF
    00A3C EF5F      LDI	R21,0xFF
    00A3D EF6F      LDI	R22,0xFF
    00A3E EF7F      LDI	R23,0xFF
    00A3F 8426      LDD	R2,Z+14
    00A40 8437      LDD	R3,Z+15
    00A41 8840      LDD	R4,Z+16
    00A42 8851      LDD	R5,Z+17
    00A43 1624      CP	R2,R20
    00A44 0635      CPC	R3,R21
    00A45 0646      CPC	R4,R22
    00A46 0657      CPC	R5,R23
    00A47 F179      BEQ	0x0A77
(1019) 			fs->free_clust--;
    00A48 01CF      MOVW	R24,R30
    00A49 960E      ADIW	R24,0xE
    00A4A 017C      MOVW	R14,R24
    00A4B E041      LDI	R20,1
    00A4C E050      LDI	R21,0
    00A4D E060      LDI	R22,0
    00A4E E070      LDI	R23,0
    00A4F 01FC      MOVW	R30,R24
    00A50 8020      LD	R2,Z
    00A51 8031      LDD	R3,Z+1
    00A52 8042      LDD	R4,Z+2
    00A53 8053      LDD	R5,Z+3
    00A54 1A24      SUB	R2,R20
    00A55 0A35      SBC	R3,R21
    00A56 0A46      SBC	R4,R22
    00A57 0A57      SBC	R5,R23
    00A58 8220      ST	Z,R2
    00A59 8231      STD	Z+1,R3
    00A5A 8242      STD	Z+2,R4
    00A5B 8253      STD	Z+3,R5
(1020) 			fs->fsi_flag = 1;
    00A5C E081      LDI	R24,1
    00A5D 01F6      MOVW	R30,R12
    00A5E 8385      STD	Z+5,R24
(1021) 		}
(1022) 	} else {
    00A5F C017      RJMP	0x0A77
(1023) 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    00A60 2D8A      MOV	R24,R10
    00A61 3081      CPI	R24,1
    00A62 F431      BNE	0x0A69
    00A63 EF8F      LDI	R24,0xFF
    00A64 8B8A      STD	Y+18,R24
    00A65 8B8B      STD	Y+19,R24
    00A66 8B8C      STD	Y+20,R24
    00A67 8B8D      STD	Y+21,R24
    00A68 C006      RJMP	0x0A6F
    00A69 E081      LDI	R24,1
    00A6A 8B8A      STD	Y+18,R24
    00A6B E080      LDI	R24,0
    00A6C 8B8B      STD	Y+19,R24
    00A6D 8B8C      STD	Y+20,R24
    00A6E 8B8D      STD	Y+21,R24
    00A6F 882A      LDD	R2,Y+18
    00A70 883B      LDD	R3,Y+19
    00A71 884C      LDD	R4,Y+20
    00A72 885D      LDD	R5,Y+21
    00A73 822E      STD	Y+6,R2
    00A74 823F      STD	Y+7,R3
    00A75 8648      STD	Y+8,R4
    00A76 8659      STD	Y+9,R5
(1024) 	}
(1025) 
(1026) 	return ncl;		/* Return new cluster number or error code */
    00A77 810E      LDD	R16,Y+6
    00A78 811F      LDD	R17,Y+7
    00A79 8528      LDD	R18,Y+8
    00A7A 8539      LDD	R19,Y+9
    00A7B 9666      ADIW	R28,0x16
    00A7C 940E 4299 CALL	pop_xgsetF0FC
    00A7E 9622      ADIW	R28,2
    00A7F 9508      RET
ff.c:clmt_clust:
  tbl                  --> R10
  cl                   --> Y,+4
  ncl                  --> Y,+0
  ofs                  --> Y,+12
  fp                   --> R12
    00A80 933A      ST	-Y,R19
    00A81 932A      ST	-Y,R18
    00A82 940E 42AA CALL	push_xgset003C
    00A84 0168      MOVW	R12,R16
    00A85 9728      SBIW	R28,0x8
(1027) }
(1028) #endif /* !_FS_READONLY */
(1029) 
(1030) 
(1031) 
(1032) /*-----------------------------------------------------------------------*/
(1033) /* FAT handling - Convert offset into cluster with link map table        */
(1034) /*-----------------------------------------------------------------------*/
(1035) 
(1036) #if _USE_FASTSEEK
(1037) static
(1038) DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
(1039) 	FIL* fp,		/* Pointer to the file object */
(1040) 	DWORD ofs		/* File offset to be converted to cluster# */
(1041) )
(1042) {
(1043) 	DWORD cl, ncl, *tbl;
(1044) 
(1045) 
(1046) 	tbl = fp->cltbl + 1;	/* Top of CLMT */
    00A86 01F6      MOVW	R30,R12
    00A87 96B0      ADIW	R30,0x20
    00A88 8180      LD	R24,Z
    00A89 8191      LDD	R25,Z+1
    00A8A 9604      ADIW	R24,4
    00A8B 015C      MOVW	R10,R24
(1047) 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
    00A8C E089      LDI	R24,0x9
    00A8D E090      LDI	R25,0
    00A8E 850C      LDD	R16,Y+12
    00A8F 851D      LDD	R17,Y+13
    00A90 852E      LDD	R18,Y+14
    00A91 853F      LDD	R19,Y+15
    00A92 938A      ST	-Y,R24
    00A93 940E 433F CALL	lsr32
    00A95 01F6      MOVW	R30,R12
    00A96 93AF      PUSH	R26
    00A97 93BF      PUSH	R27
    00A98 81A0      LD	R26,Z
    00A99 81B1      LDD	R27,Z+1
    00A9A 01FD      MOVW	R30,R26
    00A9B 91BF      POP	R27
    00A9C 91AF      POP	R26
    00A9D 9632      ADIW	R30,2
    00A9E 8020      LD	R2,Z
    00A9F 2433      CLR	R3
    00AA0 2444      CLR	R4
    00AA1 2455      CLR	R5
    00AA2 925A      ST	-Y,R5
    00AA3 924A      ST	-Y,R4
    00AA4 923A      ST	-Y,R3
    00AA5 922A      ST	-Y,R2
    00AA6 940E 41AA CALL	div32u
    00AA8 830C      STD	Y+4,R16
    00AA9 831D      STD	Y+5,R17
    00AAA 832E      STD	Y+6,R18
    00AAB 833F      STD	Y+7,R19
(1048) 	for (;;) {
(1049) 		ncl = *tbl++;			/* Number of cluters in the fragment */
    00AAC 01F5      MOVW	R30,R10
    00AAD 9021      LD	R2,Z+
    00AAE 9031      LD	R3,Z+
    00AAF 9041      LD	R4,Z+
    00AB0 9051      LD	R5,Z+
    00AB1 015F      MOVW	R10,R30
    00AB2 8228      ST	Y,R2
    00AB3 8239      STD	Y+1,R3
    00AB4 824A      STD	Y+2,R4
    00AB5 825B      STD	Y+3,R5
(1050) 		if (!ncl) return 0;		/* End of table? (error) */
    00AB6 8028      LD	R2,Y
    00AB7 8039      LDD	R3,Y+1
    00AB8 804A      LDD	R4,Y+2
    00AB9 805B      LDD	R5,Y+3
    00ABA 9488      BCLR	0
    00ABB 2022      TST	R2
    00ABC 0432      CPC	R3,R2
    00ABD 0442      CPC	R4,R2
    00ABE 0452      CPC	R5,R2
    00ABF F429      BNE	0x0AC5
    00AC0 E000      LDI	R16,0
    00AC1 E010      LDI	R17,0
    00AC2 E020      LDI	R18,0
    00AC3 E030      LDI	R19,0
    00AC4 C02F      RJMP	0x0AF4
(1051) 		if (cl < ncl) break;	/* In this fragment? */
    00AC5 8028      LD	R2,Y
    00AC6 8039      LDD	R3,Y+1
    00AC7 804A      LDD	R4,Y+2
    00AC8 805B      LDD	R5,Y+3
    00AC9 806C      LDD	R6,Y+4
    00ACA 807D      LDD	R7,Y+5
    00ACB 808E      LDD	R8,Y+6
    00ACC 809F      LDD	R9,Y+7
    00ACD 1462      CP	R6,R2
    00ACE 0473      CPC	R7,R3
    00ACF 0484      CPC	R8,R4
    00AD0 0495      CPC	R9,R5
    00AD1 F408      BCC	0x0AD3
    00AD2 C014      RJMP	0x0AE7
(1052) 		cl -= ncl; tbl++;		/* Next fragment */
    00AD3 8028      LD	R2,Y
    00AD4 8039      LDD	R3,Y+1
    00AD5 804A      LDD	R4,Y+2
    00AD6 805B      LDD	R5,Y+3
    00AD7 806C      LDD	R6,Y+4
    00AD8 807D      LDD	R7,Y+5
    00AD9 808E      LDD	R8,Y+6
    00ADA 809F      LDD	R9,Y+7
    00ADB 1862      SUB	R6,R2
    00ADC 0873      SBC	R7,R3
    00ADD 0884      SBC	R8,R4
    00ADE 0895      SBC	R9,R5
    00ADF 826C      STD	Y+4,R6
    00AE0 827D      STD	Y+5,R7
    00AE1 828E      STD	Y+6,R8
    00AE2 829F      STD	Y+7,R9
    00AE3 01C5      MOVW	R24,R10
    00AE4 9604      ADIW	R24,4
    00AE5 015C      MOVW	R10,R24
    00AE6 CFC5      RJMP	0x0AAC
(1053) 	}
(1054) 	return cl + *tbl;	/* Return the cluster number */
    00AE7 01F5      MOVW	R30,R10
    00AE8 8020      LD	R2,Z
    00AE9 8031      LDD	R3,Z+1
    00AEA 8042      LDD	R4,Z+2
    00AEB 8053      LDD	R5,Z+3
    00AEC 810C      LDD	R16,Y+4
    00AED 811D      LDD	R17,Y+5
    00AEE 812E      LDD	R18,Y+6
    00AEF 813F      LDD	R19,Y+7
    00AF0 0D02      ADD	R16,R2
    00AF1 1D13      ADC	R17,R3
    00AF2 1D24      ADC	R18,R4
    00AF3 1D35      ADC	R19,R5
    00AF4 9628      ADIW	R28,0x8
    00AF5 940E 4284 CALL	pop_xgset003C
    00AF7 9622      ADIW	R28,2
    00AF8 9508      RET
ff.c:dir_sdi:
  ic                   --> R14
  clst                 --> Y,+2
  idx                  --> R12
  dj                   --> R10
    00AF9 940E 42A4 CALL	push_xgsetF0FC
    00AFB 0169      MOVW	R12,R18
    00AFC 0158      MOVW	R10,R16
    00AFD 9726      SBIW	R28,6
(1055) }
(1056) #endif	/* _USE_FASTSEEK */
(1057) 
(1058) 
(1059) 
(1060) /*-----------------------------------------------------------------------*/
(1061) /* Directory handling - Set directory index                              */
(1062) /*-----------------------------------------------------------------------*/
(1063) 
(1064) static
(1065) FRESULT dir_sdi (
(1066) 	DIR *dj,		/* Pointer to directory object */
(1067) 	WORD idx		/* Directory index number */
(1068) )
(1069) {
(1070) 	DWORD clst;
(1071) 	WORD ic;
(1072) 
(1073) 
(1074) 	dj->index = idx;
    00AFE 01F5      MOVW	R30,R10
    00AFF 82D5      STD	Z+5,R13
    00B00 82C4      STD	Z+4,R12
(1075) 	clst = dj->sclust;
    00B01 9636      ADIW	R30,6
    00B02 8020      LD	R2,Z
    00B03 8031      LDD	R3,Z+1
    00B04 8042      LDD	R4,Z+2
    00B05 8053      LDD	R5,Z+3
    00B06 822A      STD	Y+2,R2
    00B07 823B      STD	Y+3,R3
    00B08 824C      STD	Y+4,R4
    00B09 825D      STD	Y+5,R5
(1076) 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    00B0A E041      LDI	R20,1
    00B0B E050      LDI	R21,0
    00B0C E060      LDI	R22,0
    00B0D E070      LDI	R23,0
    00B0E 802A      LDD	R2,Y+2
    00B0F 803B      LDD	R3,Y+3
    00B10 804C      LDD	R4,Y+4
    00B11 805D      LDD	R5,Y+5
    00B12 1624      CP	R2,R20
    00B13 0635      CPC	R3,R21
    00B14 0646      CPC	R4,R22
    00B15 0657      CPC	R5,R23
    00B16 F089      BEQ	0x0B28
    00B17 01F5      MOVW	R30,R10
    00B18 81A0      LD	R26,Z
    00B19 81B1      LDD	R27,Z+1
    00B1A 9656      ADIW	R26,0x16
    00B1B 902D      LD	R2,X+
    00B1C 903D      LD	R3,X+
    00B1D 904D      LD	R4,X+
    00B1E 905C      LD	R5,X
    00B1F 806A      LDD	R6,Y+2
    00B20 807B      LDD	R7,Y+3
    00B21 808C      LDD	R8,Y+4
    00B22 809D      LDD	R9,Y+5
    00B23 1462      CP	R6,R2
    00B24 0473      CPC	R7,R3
    00B25 0484      CPC	R8,R4
    00B26 0495      CPC	R9,R5
    00B27 F010      BCS	0x0B2A
(1077) 		return FR_INT_ERR;
    00B28 E002      LDI	R16,2
    00B29 C0D6      RJMP	0x0C00
(1078) 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    00B2A 802A      LDD	R2,Y+2
    00B2B 803B      LDD	R3,Y+3
    00B2C 804C      LDD	R4,Y+4
    00B2D 805D      LDD	R5,Y+5
    00B2E 9488      BCLR	0
    00B2F 2022      TST	R2
    00B30 0432      CPC	R3,R2
    00B31 0442      CPC	R4,R2
    00B32 0452      CPC	R5,R2
    00B33 F479      BNE	0x0B43
    00B34 01F5      MOVW	R30,R10
    00B35 81A0      LD	R26,Z
    00B36 81B1      LDD	R27,Z+1
    00B37 918C      LD	R24,X
    00B38 3083      CPI	R24,3
    00B39 F449      BNE	0x0B43
(1079) 		clst = dj->fs->dirbase;
    00B3A 9692      ADIW	R26,0x22
    00B3B 902D      LD	R2,X+
    00B3C 903D      LD	R3,X+
    00B3D 904D      LD	R4,X+
    00B3E 905C      LD	R5,X
    00B3F 822A      STD	Y+2,R2
    00B40 823B      STD	Y+3,R3
    00B41 824C      STD	Y+4,R4
    00B42 825D      STD	Y+5,R5
(1080) 
(1081) 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    00B43 802A      LDD	R2,Y+2
    00B44 803B      LDD	R3,Y+3
    00B45 804C      LDD	R4,Y+4
    00B46 805D      LDD	R5,Y+5
    00B47 9488      BCLR	0
    00B48 2022      TST	R2
    00B49 0432      CPC	R3,R2
    00B4A 0442      CPC	R4,R2
    00B4B 0452      CPC	R5,R2
    00B4C F009      BEQ	0x0B4E
    00B4D C02B      RJMP	0x0B79
(1082) 		dj->clust = clst;
    00B4E 01F5      MOVW	R30,R10
    00B4F 8622      STD	Z+10,R2
    00B50 8633      STD	Z+11,R3
    00B51 8644      STD	Z+12,R4
    00B52 8655      STD	Z+13,R5
(1083) 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    00B53 81A0      LD	R26,Z
    00B54 81B1      LDD	R27,Z+1
    00B55 9618      ADIW	R26,0x8
    00B56 902D      LD	R2,X+
    00B57 903C      LD	R3,X
    00B58 14C2      CP	R12,R2
    00B59 04D3      CPC	R13,R3
    00B5A F010      BCS	0x0B5D
(1084) 			return FR_INT_ERR;
    00B5B E002      LDI	R16,2
    00B5C C0A3      RJMP	0x0C00
(1085) 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B5D 0116      MOVW	R2,R12
    00B5E 9436      LSR	R3
    00B5F 9427      ROR	R2
    00B60 9436      LSR	R3
    00B61 9427      ROR	R2
    00B62 9436      LSR	R3
    00B63 9427      ROR	R2
    00B64 9436      LSR	R3
    00B65 9427      ROR	R2
    00B66 2444      CLR	R4
    00B67 2455      CLR	R5
    00B68 01F5      MOVW	R30,R10
    00B69 81A0      LD	R26,Z
    00B6A 81B1      LDD	R27,Z+1
    00B6B 9692      ADIW	R26,0x22
    00B6C 906D      LD	R6,X+
    00B6D 907D      LD	R7,X+
    00B6E 908D      LD	R8,X+
    00B6F 909C      LD	R9,X
    00B70 0C62      ADD	R6,R2
    00B71 1C73      ADC	R7,R3
    00B72 1C84      ADC	R8,R4
    00B73 1C95      ADC	R9,R5
    00B74 8666      STD	Z+14,R6
    00B75 8677      STD	Z+15,R7
    00B76 8A80      STD	Z+16,R8
    00B77 8A91      STD	Z+17,R9
(1086) 	}
    00B78 C076      RJMP	0x0BEF
(1087) 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
(1088) 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    00B79 01F5      MOVW	R30,R10
    00B7A 93AF      PUSH	R26
    00B7B 93BF      PUSH	R27
    00B7C 81A0      LD	R26,Z
    00B7D 81B1      LDD	R27,Z+1
    00B7E 01FD      MOVW	R30,R26
    00B7F 91BF      POP	R27
    00B80 91AF      POP	R26
    00B81 8022      LDD	R2,Z+2
    00B82 E180      LDI	R24,0x10
    00B83 9D82      MUL	R24,R2
    00B84 0170      MOVW	R14,R0
    00B85 C040      RJMP	0x0BC6
(1089) 		while (idx >= ic) {	/* Follow cluster chain */
(1090) 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    00B86 802A      LDD	R2,Y+2
    00B87 803B      LDD	R3,Y+3
    00B88 804C      LDD	R4,Y+4
    00B89 805D      LDD	R5,Y+5
    00B8A 8248      ST	Y,R4
    00B8B 8259      STD	Y+1,R5
    00B8C 0191      MOVW	R18,R2
    00B8D 01F5      MOVW	R30,R10
    00B8E 8100      LD	R16,Z
    00B8F 8111      LDD	R17,Z+1
    00B90 D9B5      RCALL	_get_fat
    00B91 830A      STD	Y+2,R16
    00B92 831B      STD	Y+3,R17
    00B93 832C      STD	Y+4,R18
    00B94 833D      STD	Y+5,R19
(1091) 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    00B95 EF4F      LDI	R20,0xFF
    00B96 EF5F      LDI	R21,0xFF
    00B97 EF6F      LDI	R22,0xFF
    00B98 EF7F      LDI	R23,0xFF
    00B99 802A      LDD	R2,Y+2
    00B9A 803B      LDD	R3,Y+3
    00B9B 804C      LDD	R4,Y+4
    00B9C 805D      LDD	R5,Y+5
    00B9D 1624      CP	R2,R20
    00B9E 0635      CPC	R3,R21
    00B9F 0646      CPC	R4,R22
    00BA0 0657      CPC	R5,R23
    00BA1 F411      BNE	0x0BA4
    00BA2 E001      LDI	R16,1
    00BA3 C05C      RJMP	0x0C00
(1092) 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    00BA4 E042      LDI	R20,2
    00BA5 E050      LDI	R21,0
    00BA6 E060      LDI	R22,0
    00BA7 E070      LDI	R23,0
    00BA8 802A      LDD	R2,Y+2
    00BA9 803B      LDD	R3,Y+3
    00BAA 804C      LDD	R4,Y+4
    00BAB 805D      LDD	R5,Y+5
    00BAC 1624      CP	R2,R20
    00BAD 0635      CPC	R3,R21
    00BAE 0646      CPC	R4,R22
    00BAF 0657      CPC	R5,R23
    00BB0 F088      BCS	0x0BC2
    00BB1 01F5      MOVW	R30,R10
    00BB2 81A0      LD	R26,Z
    00BB3 81B1      LDD	R27,Z+1
    00BB4 9656      ADIW	R26,0x16
    00BB5 902D      LD	R2,X+
    00BB6 903D      LD	R3,X+
    00BB7 904D      LD	R4,X+
    00BB8 905C      LD	R5,X
    00BB9 806A      LDD	R6,Y+2
    00BBA 807B      LDD	R7,Y+3
    00BBB 808C      LDD	R8,Y+4
    00BBC 809D      LDD	R9,Y+5
    00BBD 1462      CP	R6,R2
    00BBE 0473      CPC	R7,R3
    00BBF 0484      CPC	R8,R4
    00BC0 0495      CPC	R9,R5
    00BC1 F010      BCS	0x0BC4
(1093) 				return FR_INT_ERR;
    00BC2 E002      LDI	R16,2
    00BC3 C03C      RJMP	0x0C00
(1094) 			idx -= ic;
    00BC4 18CE      SUB	R12,R14
    00BC5 08DF      SBC	R13,R15
    00BC6 14CE      CP	R12,R14
    00BC7 04DF      CPC	R13,R15
    00BC8 F008      BCS	0x0BCA
    00BC9 CFBC      RJMP	0x0B86
(1095) 		}
(1096) 		dj->clust = clst;
    00BCA 802A      LDD	R2,Y+2
    00BCB 803B      LDD	R3,Y+3
    00BCC 804C      LDD	R4,Y+4
    00BCD 805D      LDD	R5,Y+5
    00BCE 01F5      MOVW	R30,R10
    00BCF 8622      STD	Z+10,R2
    00BD0 8633      STD	Z+11,R3
    00BD1 8644      STD	Z+12,R4
    00BD2 8655      STD	Z+13,R5
(1097) 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00BD3 8248      ST	Y,R4
    00BD4 8259      STD	Y+1,R5
    00BD5 0191      MOVW	R18,R2
    00BD6 8100      LD	R16,Z
    00BD7 8111      LDD	R17,Z+1
    00BD8 D91B      RCALL	_clust2sect
    00BD9 0116      MOVW	R2,R12
    00BDA 9436      LSR	R3
    00BDB 9427      ROR	R2
    00BDC 9436      LSR	R3
    00BDD 9427      ROR	R2
    00BDE 9436      LSR	R3
    00BDF 9427      ROR	R2
    00BE0 9436      LSR	R3
    00BE1 9427      ROR	R2
    00BE2 2444      CLR	R4
    00BE3 2455      CLR	R5
    00BE4 0138      MOVW	R6,R16
    00BE5 0149      MOVW	R8,R18
    00BE6 0C62      ADD	R6,R2
    00BE7 1C73      ADC	R7,R3
    00BE8 1C84      ADC	R8,R4
    00BE9 1C95      ADC	R9,R5
    00BEA 01F5      MOVW	R30,R10
    00BEB 8666      STD	Z+14,R6
    00BEC 8677      STD	Z+15,R7
    00BED 8A80      STD	Z+16,R8
    00BEE 8A91      STD	Z+17,R9
(1098) 	}
(1099) 
(1100) 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    00BEF 0196      MOVW	R18,R12
    00BF0 702F      ANDI	R18,0xF
    00BF1 7030      ANDI	R19,0
    00BF2 E200      LDI	R16,0x20
    00BF3 E010      LDI	R17,0
    00BF4 940E 4240 CALL	empy16s
    00BF6 0118      MOVW	R2,R16
    00BF7 01F5      MOVW	R30,R10
    00BF8 8180      LD	R24,Z
    00BF9 8191      LDD	R25,Z+1
    00BFA 968E      ADIW	R24,0x2E
    00BFB 0E28      ADD	R2,R24
    00BFC 1E39      ADC	R3,R25
    00BFD 8A33      STD	Z+19,R3
    00BFE 8A22      STD	Z+18,R2
(1101) 
(1102) 	return FR_OK;	/* Seek succeeded */
    00BFF 2700      CLR	R16
    00C00 9626      ADIW	R28,6
    00C01 940C 4299 JMP	pop_xgsetF0FC
ff.c:dir_next:
  c                    --> R10
  clst                 --> Y,+2
  i                    --> R12
  stretch              --> R10
  dj                   --> Y,+16
    00C03 940E 415F CALL	push_arg4
    00C05 940E 42A4 CALL	push_xgsetF0FC
    00C07 0159      MOVW	R10,R18
    00C08 9726      SBIW	R28,6
(1103) }
(1104) 
(1105) 
(1106) 
(1107) 
(1108) /*-----------------------------------------------------------------------*/
(1109) /* Directory handling - Move directory index next                        */
(1110) /*-----------------------------------------------------------------------*/
(1111) 
(1112) static
(1113) FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
(1114) 	DIR *dj,		/* Pointer to directory object */
(1115) 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
(1116) )
(1117) {
(1118) 	DWORD clst;
(1119) 	WORD i;
(1120) 
(1121) 
(1122) 	stretch = stretch;		/* To suppress warning on read-only cfg. */
(1123) 	i = dj->index + 1;
    00C09 89E8      LDD	R30,Y+16
    00C0A 89F9      LDD	R31,Y+17
    00C0B 8184      LDD	R24,Z+4
    00C0C 8195      LDD	R25,Z+5
    00C0D 9601      ADIW	R24,1
    00C0E 016C      MOVW	R12,R24
(1124) 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    00C0F 3080      CPI	R24,0
    00C10 0789      CPC	R24,R25
    00C11 F059      BEQ	0x0C1D
    00C12 963E      ADIW	R30,0xE
    00C13 8020      LD	R2,Z
    00C14 8031      LDD	R3,Z+1
    00C15 8042      LDD	R4,Z+2
    00C16 8053      LDD	R5,Z+3
    00C17 9488      BCLR	0
    00C18 2022      TST	R2
    00C19 0432      CPC	R3,R2
    00C1A 0442      CPC	R4,R2
    00C1B 0452      CPC	R5,R2
    00C1C F411      BNE	0x0C1F
(1125) 		return FR_NO_FILE;
    00C1D E004      LDI	R16,4
    00C1E C18D      RJMP	0x0DAC
(1126) 
(1127) 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    00C1F 01C6      MOVW	R24,R12
    00C20 708F      ANDI	R24,0xF
    00C21 7090      ANDI	R25,0
    00C22 3080      CPI	R24,0
    00C23 0789      CPC	R24,R25
    00C24 F009      BEQ	0x0C26
    00C25 C170      RJMP	0x0D96
(1128) 		dj->sect++;					/* Next sector */
    00C26 8988      LDD	R24,Y+16
    00C27 8999      LDD	R25,Y+17
    00C28 960E      ADIW	R24,0xE
    00C29 E041      LDI	R20,1
    00C2A E050      LDI	R21,0
    00C2B E060      LDI	R22,0
    00C2C E070      LDI	R23,0
    00C2D 01FC      MOVW	R30,R24
    00C2E 8020      LD	R2,Z
    00C2F 8031      LDD	R3,Z+1
    00C30 8042      LDD	R4,Z+2
    00C31 8053      LDD	R5,Z+3
    00C32 0E24      ADD	R2,R20
    00C33 1E35      ADC	R3,R21
    00C34 1E46      ADC	R4,R22
    00C35 1E57      ADC	R5,R23
    00C36 8220      ST	Z,R2
    00C37 8231      STD	Z+1,R3
    00C38 8242      STD	Z+2,R4
    00C39 8253      STD	Z+3,R5
(1129) 
(1130) 		if (dj->clust == 0) {	/* Static table */
    00C3A 89E8      LDD	R30,Y+16
    00C3B 89F9      LDD	R31,Y+17
    00C3C 963A      ADIW	R30,0xA
    00C3D 8020      LD	R2,Z
    00C3E 8031      LDD	R3,Z+1
    00C3F 8042      LDD	R4,Z+2
    00C40 8053      LDD	R5,Z+3
    00C41 9488      BCLR	0
    00C42 2022      TST	R2
    00C43 0432      CPC	R3,R2
    00C44 0442      CPC	R4,R2
    00C45 0452      CPC	R5,R2
    00C46 F469      BNE	0x0C54
(1131) 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    00C47 89E8      LDD	R30,Y+16
    00C48 89F9      LDD	R31,Y+17
    00C49 81A0      LD	R26,Z
    00C4A 81B1      LDD	R27,Z+1
    00C4B 9618      ADIW	R26,0x8
    00C4C 902D      LD	R2,X+
    00C4D 903C      LD	R3,X
    00C4E 14C2      CP	R12,R2
    00C4F 04D3      CPC	R13,R3
    00C50 F408      BCC	0x0C52
    00C51 C144      RJMP	0x0D96
(1132) 				return FR_NO_FILE;
    00C52 E004      LDI	R16,4
    00C53 C158      RJMP	0x0DAC
(1133) 		}
(1134) 		else {					/* Dynamic table */
(1135) 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    00C54 89E8      LDD	R30,Y+16
    00C55 89F9      LDD	R31,Y+17
    00C56 93AF      PUSH	R26
    00C57 93BF      PUSH	R27
    00C58 81A0      LD	R26,Z
    00C59 81B1      LDD	R27,Z+1
    00C5A 01FD      MOVW	R30,R26
    00C5B 91BF      POP	R27
    00C5C 91AF      POP	R26
    00C5D 8182      LDD	R24,Z+2
    00C5E 2799      CLR	R25
    00C5F 9701      SBIW	R24,1
    00C60 0116      MOVW	R2,R12
    00C61 9436      LSR	R3
    00C62 9427      ROR	R2
    00C63 9436      LSR	R3
    00C64 9427      ROR	R2
    00C65 9436      LSR	R3
    00C66 9427      ROR	R2
    00C67 9436      LSR	R3
    00C68 9427      ROR	R2
    00C69 2228      AND	R2,R24
    00C6A 2239      AND	R3,R25
    00C6B 2022      TST	R2
    00C6C F009      BEQ	0x0C6E
    00C6D C128      RJMP	0x0D96
    00C6E 2033      TST	R3
    00C6F F009      BEQ	0x0C71
    00C70 C125      RJMP	0x0D96
(1136) 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    00C71 89E8      LDD	R30,Y+16
    00C72 89F9      LDD	R31,Y+17
    00C73 8422      LDD	R2,Z+10
    00C74 8433      LDD	R3,Z+11
    00C75 8444      LDD	R4,Z+12
    00C76 8455      LDD	R5,Z+13
    00C77 8248      ST	Y,R4
    00C78 8259      STD	Y+1,R5
    00C79 0191      MOVW	R18,R2
    00C7A 8100      LD	R16,Z
    00C7B 8111      LDD	R17,Z+1
    00C7C D8C9      RCALL	_get_fat
    00C7D 830A      STD	Y+2,R16
    00C7E 831B      STD	Y+3,R17
    00C7F 832C      STD	Y+4,R18
    00C80 833D      STD	Y+5,R19
(1137) 				if (clst <= 1) return FR_INT_ERR;
    00C81 E041      LDI	R20,1
    00C82 E050      LDI	R21,0
    00C83 E060      LDI	R22,0
    00C84 E070      LDI	R23,0
    00C85 802A      LDD	R2,Y+2
    00C86 803B      LDD	R3,Y+3
    00C87 804C      LDD	R4,Y+4
    00C88 805D      LDD	R5,Y+5
    00C89 1542      CP	R20,R2
    00C8A 0553      CPC	R21,R3
    00C8B 0564      CPC	R22,R4
    00C8C 0575      CPC	R23,R5
    00C8D F010      BCS	0x0C90
    00C8E E002      LDI	R16,2
    00C8F C11C      RJMP	0x0DAC
(1138) 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C90 EF4F      LDI	R20,0xFF
    00C91 EF5F      LDI	R21,0xFF
    00C92 EF6F      LDI	R22,0xFF
    00C93 EF7F      LDI	R23,0xFF
    00C94 802A      LDD	R2,Y+2
    00C95 803B      LDD	R3,Y+3
    00C96 804C      LDD	R4,Y+4
    00C97 805D      LDD	R5,Y+5
    00C98 1624      CP	R2,R20
    00C99 0635      CPC	R3,R21
    00C9A 0646      CPC	R4,R22
    00C9B 0657      CPC	R5,R23
    00C9C F411      BNE	0x0C9F
    00C9D E001      LDI	R16,1
    00C9E C10D      RJMP	0x0DAC
(1139) 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    00C9F 89E8      LDD	R30,Y+16
    00CA0 89F9      LDD	R31,Y+17
    00CA1 81A0      LD	R26,Z
    00CA2 81B1      LDD	R27,Z+1
    00CA3 9656      ADIW	R26,0x16
    00CA4 902D      LD	R2,X+
    00CA5 903D      LD	R3,X+
    00CA6 904D      LD	R4,X+
    00CA7 905C      LD	R5,X
    00CA8 806A      LDD	R6,Y+2
    00CA9 807B      LDD	R7,Y+3
    00CAA 808C      LDD	R8,Y+4
    00CAB 809D      LDD	R9,Y+5
    00CAC 1462      CP	R6,R2
    00CAD 0473      CPC	R7,R3
    00CAE 0484      CPC	R8,R4
    00CAF 0495      CPC	R9,R5
    00CB0 F408      BCC	0x0CB2
    00CB1 C0CD      RJMP	0x0D7F
(1140) #if !_FS_READONLY
(1141) 					BYTE c;
(1142) 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    00CB2 20AA      TST	R10
    00CB3 F421      BNE	0x0CB8
    00CB4 20BB      TST	R11
    00CB5 F411      BNE	0x0CB8
    00CB6 E004      LDI	R16,4
    00CB7 C0F4      RJMP	0x0DAC
(1143) 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    00CB8 89E8      LDD	R30,Y+16
    00CB9 89F9      LDD	R31,Y+17
    00CBA 8422      LDD	R2,Z+10
    00CBB 8433      LDD	R3,Z+11
    00CBC 8444      LDD	R4,Z+12
    00CBD 8455      LDD	R5,Z+13
    00CBE 8248      ST	Y,R4
    00CBF 8259      STD	Y+1,R5
    00CC0 0191      MOVW	R18,R2
    00CC1 8100      LD	R16,Z
    00CC2 8111      LDD	R17,Z+1
    00CC3 DC44      RCALL	ff.c:create_chain
    00CC4 830A      STD	Y+2,R16
    00CC5 831B      STD	Y+3,R17
    00CC6 832C      STD	Y+4,R18
    00CC7 833D      STD	Y+5,R19
(1144) 					if (clst == 0) return FR_DENIED;			/* No free cluster */
    00CC8 802A      LDD	R2,Y+2
    00CC9 803B      LDD	R3,Y+3
    00CCA 804C      LDD	R4,Y+4
    00CCB 805D      LDD	R5,Y+5
    00CCC 9488      BCLR	0
    00CCD 2022      TST	R2
    00CCE 0432      CPC	R3,R2
    00CCF 0442      CPC	R4,R2
    00CD0 0452      CPC	R5,R2
    00CD1 F411      BNE	0x0CD4
    00CD2 E007      LDI	R16,7
    00CD3 C0D8      RJMP	0x0DAC
(1145) 					if (clst == 1) return FR_INT_ERR;
    00CD4 E041      LDI	R20,1
    00CD5 E050      LDI	R21,0
    00CD6 E060      LDI	R22,0
    00CD7 E070      LDI	R23,0
    00CD8 802A      LDD	R2,Y+2
    00CD9 803B      LDD	R3,Y+3
    00CDA 804C      LDD	R4,Y+4
    00CDB 805D      LDD	R5,Y+5
    00CDC 1624      CP	R2,R20
    00CDD 0635      CPC	R3,R21
    00CDE 0646      CPC	R4,R22
    00CDF 0657      CPC	R5,R23
    00CE0 F411      BNE	0x0CE3
    00CE1 E002      LDI	R16,2
    00CE2 C0C9      RJMP	0x0DAC
(1146) 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00CE3 EF4F      LDI	R20,0xFF
    00CE4 EF5F      LDI	R21,0xFF
    00CE5 EF6F      LDI	R22,0xFF
    00CE6 EF7F      LDI	R23,0xFF
    00CE7 802A      LDD	R2,Y+2
    00CE8 803B      LDD	R3,Y+3
    00CE9 804C      LDD	R4,Y+4
    00CEA 805D      LDD	R5,Y+5
    00CEB 1624      CP	R2,R20
    00CEC 0635      CPC	R3,R21
    00CED 0646      CPC	R4,R22
    00CEE 0657      CPC	R5,R23
    00CEF F411      BNE	0x0CF2
    00CF0 E001      LDI	R16,1
    00CF1 C0BA      RJMP	0x0DAC
(1147) 					/* Clean-up stretched table */
(1148) 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    00CF2 E040      LDI	R20,0
    00CF3 E050      LDI	R21,0
    00CF4 E060      LDI	R22,0
    00CF5 E070      LDI	R23,0
    00CF6 8368      ST	Y,R22
    00CF7 8379      STD	Y+1,R23
    00CF8 019A      MOVW	R18,R20
    00CF9 89E8      LDD	R30,Y+16
    00CFA 89F9      LDD	R31,Y+17
    00CFB 8100      LD	R16,Z
    00CFC 8111      LDD	R17,Z+1
    00CFD 940E 037D CALL	ff.c:move_window
    00CFF 2300      TST	R16
    00D00 F011      BEQ	0x0D03
    00D01 E001      LDI	R16,1
    00D02 C0A9      RJMP	0x0DAC
(1149) 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    00D03 E080      LDI	R24,0
    00D04 E092      LDI	R25,2
    00D05 8399      STD	Y+1,R25
    00D06 8388      ST	Y,R24
    00D07 2722      CLR	R18
    00D08 2733      CLR	R19
    00D09 89E8      LDD	R30,Y+16
    00D0A 89F9      LDD	R31,Y+17
    00D0B 8100      LD	R16,Z
    00D0C 8111      LDD	R17,Z+1
    00D0D 5D02      SUBI	R16,0xD2
    00D0E 4F1F      SBCI	R17,0xFF
    00D0F 940E 033A CALL	ff.c:mem_set
(1150) 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    00D11 802A      LDD	R2,Y+2
    00D12 803B      LDD	R3,Y+3
    00D13 804C      LDD	R4,Y+4
    00D14 805D      LDD	R5,Y+5
    00D15 8248      ST	Y,R4
    00D16 8259      STD	Y+1,R5
    00D17 0191      MOVW	R18,R2
    00D18 89E8      LDD	R30,Y+16
    00D19 89F9      LDD	R31,Y+17
    00D1A 80A0      LD	R10,Z
    00D1B 80B1      LDD	R11,Z+1
    00D1C 0185      MOVW	R16,R10
    00D1D 940E 04F4 CALL	_clust2sect
    00D1F 01F5      MOVW	R30,R10
    00D20 A702      STD	Z+42,R16
    00D21 A713      STD	Z+43,R17
    00D22 A724      STD	Z+44,R18
    00D23 A735      STD	Z+45,R19
(1151) 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    00D24 24AA      CLR	R10
    00D25 C035      RJMP	0x0D5B
(1152) 						dj->fs->wflag = 1;
    00D26 E081      LDI	R24,1
    00D27 89E8      LDD	R30,Y+16
    00D28 89F9      LDD	R31,Y+17
    00D29 93AF      PUSH	R26
    00D2A 93BF      PUSH	R27
    00D2B 81A0      LD	R26,Z
    00D2C 81B1      LDD	R27,Z+1
    00D2D 01FD      MOVW	R30,R26
    00D2E 91BF      POP	R27
    00D2F 91AF      POP	R26
    00D30 8384      STD	Z+4,R24
(1153) 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    00D31 E040      LDI	R20,0
    00D32 E050      LDI	R21,0
    00D33 E060      LDI	R22,0
    00D34 E070      LDI	R23,0
    00D35 8368      ST	Y,R22
    00D36 8379      STD	Y+1,R23
    00D37 019A      MOVW	R18,R20
    00D38 89E8      LDD	R30,Y+16
    00D39 89F9      LDD	R31,Y+17
    00D3A 8100      LD	R16,Z
    00D3B 8111      LDD	R17,Z+1
    00D3C 940E 037D CALL	ff.c:move_window
    00D3E 2EE0      MOV	R14,R16
    00D3F 2300      TST	R16
    00D40 F011      BEQ	0x0D43
    00D41 E001      LDI	R16,1
    00D42 C069      RJMP	0x0DAC
(1154) 						dj->fs->winsect++;
    00D43 89E8      LDD	R30,Y+16
    00D44 89F9      LDD	R31,Y+17
    00D45 8180      LD	R24,Z
    00D46 8191      LDD	R25,Z+1
    00D47 968A      ADIW	R24,0x2A
    00D48 017C      MOVW	R14,R24
    00D49 E041      LDI	R20,1
    00D4A E050      LDI	R21,0
    00D4B E060      LDI	R22,0
    00D4C E070      LDI	R23,0
    00D4D 01FC      MOVW	R30,R24
    00D4E 8020      LD	R2,Z
    00D4F 8031      LDD	R3,Z+1
    00D50 8042      LDD	R4,Z+2
    00D51 8053      LDD	R5,Z+3
    00D52 0E24      ADD	R2,R20
    00D53 1E35      ADC	R3,R21
    00D54 1E46      ADC	R4,R22
    00D55 1E57      ADC	R5,R23
    00D56 8220      ST	Z,R2
    00D57 8231      STD	Z+1,R3
    00D58 8242      STD	Z+2,R4
    00D59 8253      STD	Z+3,R5
    00D5A 94A3      INC	R10
    00D5B 89E8      LDD	R30,Y+16
    00D5C 89F9      LDD	R31,Y+17
    00D5D 93AF      PUSH	R26
    00D5E 93BF      PUSH	R27
    00D5F 81A0      LD	R26,Z
    00D60 81B1      LDD	R27,Z+1
    00D61 01FD      MOVW	R30,R26
    00D62 91BF      POP	R27
    00D63 91AF      POP	R26
    00D64 8022      LDD	R2,Z+2
    00D65 14A2      CP	R10,R2
    00D66 F408      BCC	0x0D68
    00D67 CFBE      RJMP	0x0D26
(1155) 					}
(1156) 					dj->fs->winsect -= c;						/* Rewind window address */
    00D68 89E8      LDD	R30,Y+16
    00D69 89F9      LDD	R31,Y+17
    00D6A 8180      LD	R24,Z
    00D6B 8191      LDD	R25,Z+1
    00D6C 968A      ADIW	R24,0x2A
    00D6D 017C      MOVW	R14,R24
    00D6E 2C2A      MOV	R2,R10
    00D6F 2433      CLR	R3
    00D70 2444      CLR	R4
    00D71 2455      CLR	R5
    00D72 01FC      MOVW	R30,R24
    00D73 8060      LD	R6,Z
    00D74 8071      LDD	R7,Z+1
    00D75 8082      LDD	R8,Z+2
    00D76 8093      LDD	R9,Z+3
    00D77 1862      SUB	R6,R2
    00D78 0873      SBC	R7,R3
    00D79 0884      SBC	R8,R4
    00D7A 0895      SBC	R9,R5
    00D7B 8260      ST	Z,R6
    00D7C 8271      STD	Z+1,R7
    00D7D 8282      STD	Z+2,R8
    00D7E 8293      STD	Z+3,R9
(1157) #else
(1158) 					return FR_NO_FILE;			/* Report EOT */
(1159) #endif
(1160) 				}
(1161) 				dj->clust = clst;				/* Initialize data for new cluster */
    00D7F 802A      LDD	R2,Y+2
    00D80 803B      LDD	R3,Y+3
    00D81 804C      LDD	R4,Y+4
    00D82 805D      LDD	R5,Y+5
    00D83 89E8      LDD	R30,Y+16
    00D84 89F9      LDD	R31,Y+17
    00D85 8622      STD	Z+10,R2
    00D86 8633      STD	Z+11,R3
    00D87 8644      STD	Z+12,R4
    00D88 8655      STD	Z+13,R5
(1162) 				dj->sect = clust2sect(dj->fs, clst);
    00D89 8248      ST	Y,R4
    00D8A 8259      STD	Y+1,R5
    00D8B 0191      MOVW	R18,R2
    00D8C 8100      LD	R16,Z
    00D8D 8111      LDD	R17,Z+1
    00D8E 940E 04F4 CALL	_clust2sect
    00D90 89E8      LDD	R30,Y+16
    00D91 89F9      LDD	R31,Y+17
    00D92 8706      STD	Z+14,R16
    00D93 8717      STD	Z+15,R17
    00D94 8B20      STD	Z+16,R18
    00D95 8B31      STD	Z+17,R19
(1163) 			}
(1164) 		}
(1165) 	}
(1166) 
(1167) 	dj->index = i;
    00D96 89E8      LDD	R30,Y+16
    00D97 89F9      LDD	R31,Y+17
    00D98 82D5      STD	Z+5,R13
    00D99 82C4      STD	Z+4,R12
(1168) 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    00D9A 0196      MOVW	R18,R12
    00D9B 702F      ANDI	R18,0xF
    00D9C 7030      ANDI	R19,0
    00D9D E200      LDI	R16,0x20
    00D9E E010      LDI	R17,0
    00D9F 940E 4240 CALL	empy16s
    00DA1 0118      MOVW	R2,R16
    00DA2 89E8      LDD	R30,Y+16
    00DA3 89F9      LDD	R31,Y+17
    00DA4 8180      LD	R24,Z
    00DA5 8191      LDD	R25,Z+1
    00DA6 968E      ADIW	R24,0x2E
    00DA7 0E28      ADD	R2,R24
    00DA8 1E39      ADC	R3,R25
    00DA9 8A33      STD	Z+19,R3
    00DAA 8A22      STD	Z+18,R2
(1169) 
(1170) 	return FR_OK;
    00DAB 2700      CLR	R16
    00DAC 9626      ADIW	R28,6
    00DAD 940E 4299 CALL	pop_xgsetF0FC
    00DAF 9624      ADIW	R28,4
    00DB0 9508      RET
ff.c:dir_find:
  c                    --> R12
  dir                  --> R10
  res                  --> R20
  dj                   --> R22
    00DB1 940E 42DF CALL	push_xgsetF03C
    00DB3 01B8      MOVW	R22,R16
    00DB4 9722      SBIW	R28,2
(1171) }
(1172) 
(1173) 
(1174) 
(1175) 
(1176) /*-----------------------------------------------------------------------*/
(1177) /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
(1178) /*-----------------------------------------------------------------------*/
(1179) #if _USE_LFN
(1180) static
(1181) const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
(1182) 
(1183) 
(1184) static
(1185) int cmp_lfn (			/* 1:Matched, 0:Not matched */
(1186) 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
(1187) 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
(1188) )
(1189) {
(1190) 	UINT i, s;
(1191) 	WCHAR wc, uc;
(1192) 
(1193) 
(1194) 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
(1195) 	s = 0; wc = 1;
(1196) 	do {
(1197) 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
(1198) 		if (wc) {	/* Last char has not been processed */
(1199) 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
(1200) 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
(1201) 				return 0;				/* Not matched */
(1202) 		} else {
(1203) 			if (uc != 0xFFFF) return 0;	/* Check filler */
(1204) 		}
(1205) 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
(1206) 
(1207) 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
(1208) 		return 0;
(1209) 
(1210) 	return 1;						/* The part of LFN matched */
(1211) }
(1212) 
(1213) 
(1214) 
(1215) static
(1216) int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
(1217) 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
(1218) 	BYTE *dir			/* Pointer to the directory entry */
(1219) )
(1220) {
(1221) 	UINT i, s;
(1222) 	WCHAR wc, uc;
(1223) 
(1224) 
(1225) 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
(1226) 
(1227) 	s = 0; wc = 1;
(1228) 	do {
(1229) 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
(1230) 		if (wc) {	/* Last char has not been processed */
(1231) 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
(1232) 			lfnbuf[i++] = wc = uc;			/* Store it */
(1233) 		} else {
(1234) 			if (uc != 0xFFFF) return 0;		/* Check filler */
(1235) 		}
(1236) 	} while (++s < 13);						/* Read all character in the entry */
(1237) 
(1238) 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
(1239) 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
(1240) 		lfnbuf[i] = 0;
(1241) 	}
(1242) 
(1243) 	return 1;
(1244) }
(1245) 
(1246) 
(1247) #if !_FS_READONLY
(1248) static
(1249) void fit_lfn (
(1250) 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
(1251) 	BYTE *dir,				/* Pointer to the directory entry */
(1252) 	BYTE ord,				/* LFN order (1-20) */
(1253) 	BYTE sum				/* SFN sum */
(1254) )
(1255) {
(1256) 	UINT i, s;
(1257) 	WCHAR wc;
(1258) 
(1259) 
(1260) 	dir[LDIR_Chksum] = sum;			/* Set check sum */
(1261) 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
(1262) 	dir[LDIR_Type] = 0;
(1263) 	ST_WORD(dir+LDIR_FstClusLO, 0);
(1264) 
(1265) 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
(1266) 	s = wc = 0;
(1267) 	do {
(1268) 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
(1269) 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
(1270) 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
(1271) 	} while (++s < 13);
(1272) 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
(1273) 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
(1274) }
(1275) 
(1276) #endif
(1277) #endif
(1278) 
(1279) 
(1280) 
(1281) /*-----------------------------------------------------------------------*/
(1282) /* Create numbered name                                                  */
(1283) /*-----------------------------------------------------------------------*/
(1284) #if _USE_LFN
(1285) void gen_numname (
(1286) 	BYTE *dst,			/* Pointer to generated SFN */
(1287) 	const BYTE *src,	/* Pointer to source SFN to be modified */
(1288) 	const WCHAR *lfn,	/* Pointer to LFN */
(1289) 	WORD seq			/* Sequence number */
(1290) )
(1291) {
(1292) 	BYTE ns[8], c;
(1293) 	UINT i, j;
(1294) 
(1295) 
(1296) 	mem_cpy(dst, src, 11);
(1297) 
(1298) 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
(1299) 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
(1300) 	}
(1301) 
(1302) 	/* itoa (hexdecimal) */
(1303) 	i = 7;
(1304) 	do {
(1305) 		c = (seq % 16) + '0';
(1306) 		if (c > '9') c += 7;
(1307) 		ns[i--] = c;
(1308) 		seq /= 16;
(1309) 	} while (seq);
(1310) 	ns[i] = '~';
(1311) 
(1312) 	/* Append the number */
(1313) 	for (j = 0; j < i && dst[j] != ' '; j++) {
(1314) 		if (IsDBCS1(dst[j])) {
(1315) 			if (j == i - 1) break;
(1316) 			j++;
(1317) 		}
(1318) 	}
(1319) 	do {
(1320) 		dst[j++] = (i < 8) ? ns[i++] : ' ';
(1321) 	} while (j < 8);
(1322) }
(1323) #endif
(1324) 
(1325) 
(1326) 
(1327) 
(1328) /*-----------------------------------------------------------------------*/
(1329) /* Calculate sum of an SFN                                               */
(1330) /*-----------------------------------------------------------------------*/
(1331) #if _USE_LFN
(1332) static
(1333) BYTE sum_sfn (
(1334) 	const BYTE *dir		/* Ptr to directory entry */
(1335) )
(1336) {
(1337) 	BYTE sum = 0;
(1338) 	UINT n = 11;
(1339) 
(1340) 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
(1341) 	return sum;
(1342) }
(1343) #endif
(1344) 
(1345) 
(1346) 
(1347) 
(1348) /*-----------------------------------------------------------------------*/
(1349) /* Directory handling - Find an object in the directory                  */
(1350) /*-----------------------------------------------------------------------*/
(1351) 
(1352) static
(1353) FRESULT dir_find (
(1354) 	DIR *dj			/* Pointer to the directory object linked to the file name */
(1355) )
(1356) {
(1357) 	FRESULT res;
(1358) 	BYTE c, *dir;
(1359) #if _USE_LFN
(1360) 	BYTE a, ord, sum;
(1361) #endif
(1362) 
(1363) 	res = dir_sdi(dj, 0);			/* Rewind directory object */
    00DB5 2722      CLR	R18
    00DB6 2733      CLR	R19
    00DB7 018B      MOVW	R16,R22
    00DB8 DD40      RCALL	ff.c:dir_sdi
    00DB9 2F40      MOV	R20,R16
(1364) 	if (res != FR_OK) return res;
    00DBA 2300      TST	R16
    00DBB F009      BEQ	0x0DBD
    00DBC C036      RJMP	0x0DF3
(1365) 
(1366) #if _USE_LFN
(1367) 	ord = sum = 0xFF;
(1368) #endif
(1369) 	do {
(1370) 		res = move_window(dj->fs, dj->sect);
    00DBD 01FB      MOVW	R30,R22
    00DBE 8426      LDD	R2,Z+14
    00DBF 8437      LDD	R3,Z+15
    00DC0 8840      LDD	R4,Z+16
    00DC1 8851      LDD	R5,Z+17
    00DC2 8248      ST	Y,R4
    00DC3 8259      STD	Y+1,R5
    00DC4 0191      MOVW	R18,R2
    00DC5 8100      LD	R16,Z
    00DC6 8111      LDD	R17,Z+1
    00DC7 940E 037D CALL	ff.c:move_window
    00DC9 2F40      MOV	R20,R16
(1371) 		if (res != FR_OK) break;
    00DCA 2300      TST	R16
    00DCB F009      BEQ	0x0DCD
    00DCC C025      RJMP	0x0DF2
(1372) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00DCD 01FB      MOVW	R30,R22
    00DCE 88A2      LDD	R10,Z+18
    00DCF 88B3      LDD	R11,Z+19
(1373) 		c = dir[DIR_Name];
    00DD0 01F5      MOVW	R30,R10
    00DD1 80C0      LD	R12,Z
(1374) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00DD2 20CC      TST	R12
    00DD3 F411      BNE	0x0DD6
    00DD4 E044      LDI	R20,4
    00DD5 C01C      RJMP	0x0DF2
(1375) #if _USE_LFN	/* LFN configuration */
(1376) 		a = dir[DIR_Attr] & AM_MASK;
(1377) 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1378) 			ord = 0xFF;
(1379) 		} else {
(1380) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1381) 				if (dj->lfn) {
(1382) 					if (c & LLE) {		/* Is it start of LFN sequence? */
(1383) 						sum = dir[LDIR_Chksum];
(1384) 						c &= ~LLE; ord = c;	/* LFN start order */
(1385) 						dj->lfn_idx = dj->index;
(1386) 					}
(1387) 					/* Check validity of the LFN entry and compare it with given name */
(1388) 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1389) 				}
(1390) 			} else {					/* An SFN entry is found */
(1391) 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
(1392) 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
(1393) 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
(1394) 			}
(1395) 		}
(1396) #else		/* Non LFN configuration */
(1397) 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    00DD6 01F5      MOVW	R30,R10
    00DD7 8423      LDD	R2,Z+11
    00DD8 FC23      SBRC	R2,3
    00DD9 C00F      RJMP	0x0DE9
    00DDA E08B      LDI	R24,0xB
    00DDB E090      LDI	R25,0
    00DDC 8399      STD	Y+1,R25
    00DDD 8388      ST	Y,R24
    00DDE 01FB      MOVW	R30,R22
    00DDF 8924      LDD	R18,Z+20
    00DE0 8935      LDD	R19,Z+21
    00DE1 0185      MOVW	R16,R10
    00DE2 940E 034C CALL	ff.c:mem_cmp
    00DE4 0158      MOVW	R10,R16
    00DE5 3000      CPI	R16,0
    00DE6 0701      CPC	R16,R17
    00DE7 F409      BNE	0x0DE9
(1398) 			break;
    00DE8 C009      RJMP	0x0DF2
(1399) #endif
(1400) 		res = dir_next(dj, 0);		/* Next entry */
    00DE9 2722      CLR	R18
    00DEA 2733      CLR	R19
    00DEB 018B      MOVW	R16,R22
    00DEC DE16      RCALL	ff.c:dir_next
    00DED 2EA0      MOV	R10,R16
    00DEE 2D4A      MOV	R20,R10
(1401) 	} while (res == FR_OK);
    00DEF 2344      TST	R20
    00DF0 F409      BNE	0x0DF2
    00DF1 CFCB      RJMP	0x0DBD
(1402) 
(1403) 	return res;
    00DF2 2F04      MOV	R16,R20
    00DF3 9622      ADIW	R28,2
    00DF4 940C 42E8 JMP	pop_xgsetF03C
ff.c:dir_read:
  dir                  --> R10
  c                    --> R12
  res                  --> R20
  dj                   --> R22
    00DF6 940E 42DF CALL	push_xgsetF03C
    00DF8 01B8      MOVW	R22,R16
    00DF9 9722      SBIW	R28,2
(1404) }
(1405) 
(1406) 
(1407) 
(1408) 
(1409) /*-----------------------------------------------------------------------*/
(1410) /* Read an object from the directory                                     */
(1411) /*-----------------------------------------------------------------------*/
(1412) #if _FS_MINIMIZE <= 1
(1413) static
(1414) FRESULT dir_read (
(1415) 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
(1416) )
(1417) {
(1418) 	FRESULT res;
(1419) 	BYTE c, *dir;
(1420) #if _USE_LFN
(1421) 	BYTE a, ord = 0xFF, sum = 0xFF;
(1422) #endif
(1423) 
(1424) 	res = FR_NO_FILE;
    00DFA E044      LDI	R20,4
    00DFB C02B      RJMP	0x0E27
(1425) 	while (dj->sect) {
(1426) 		res = move_window(dj->fs, dj->sect);
    00DFC 01FB      MOVW	R30,R22
    00DFD 8426      LDD	R2,Z+14
    00DFE 8437      LDD	R3,Z+15
    00DFF 8840      LDD	R4,Z+16
    00E00 8851      LDD	R5,Z+17
    00E01 8248      ST	Y,R4
    00E02 8259      STD	Y+1,R5
    00E03 0191      MOVW	R18,R2
    00E04 8100      LD	R16,Z
    00E05 8111      LDD	R17,Z+1
    00E06 940E 037D CALL	ff.c:move_window
    00E08 2F40      MOV	R20,R16
(1427) 		if (res != FR_OK) break;
    00E09 2300      TST	R16
    00E0A F009      BEQ	0x0E0C
    00E0B C028      RJMP	0x0E34
(1428) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00E0C 01FB      MOVW	R30,R22
    00E0D 88A2      LDD	R10,Z+18
    00E0E 88B3      LDD	R11,Z+19
(1429) 		c = dir[DIR_Name];
    00E0F 01F5      MOVW	R30,R10
    00E10 80C0      LD	R12,Z
(1430) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00E11 20CC      TST	R12
    00E12 F411      BNE	0x0E15
    00E13 E044      LDI	R20,4
    00E14 C01F      RJMP	0x0E34
(1431) #if _USE_LFN	/* LFN configuration */
(1432) 		a = dir[DIR_Attr] & AM_MASK;
(1433) 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1434) 			ord = 0xFF;
(1435) 		} else {
(1436) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1437) 				if (c & LLE) {			/* Is it start of LFN sequence? */
(1438) 					sum = dir[LDIR_Chksum];
(1439) 					c &= ~LLE; ord = c;
(1440) 					dj->lfn_idx = dj->index;
(1441) 				}
(1442) 				/* Check LFN validity and capture it */
(1443) 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1444) 			} else {					/* An SFN entry is found */
(1445) 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
(1446) 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
(1447) 				break;
(1448) 			}
(1449) 		}
(1450) #else		/* Non LFN configuration */
(1451) 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    00E15 2D8C      MOV	R24,R12
    00E16 3E85      CPI	R24,0xE5
    00E17 F039      BEQ	0x0E1F
    00E18 328E      CPI	R24,0x2E
    00E19 F029      BEQ	0x0E1F
    00E1A 01F5      MOVW	R30,R10
    00E1B 8423      LDD	R2,Z+11
    00E1C FC23      SBRC	R2,3
    00E1D C001      RJMP	0x0E1F
(1452) 			break;
    00E1E C015      RJMP	0x0E34
(1453) #endif
(1454) 		res = dir_next(dj, 0);				/* Next entry */
    00E1F 2722      CLR	R18
    00E20 2733      CLR	R19
    00E21 018B      MOVW	R16,R22
    00E22 DDE0      RCALL	ff.c:dir_next
    00E23 2F40      MOV	R20,R16
(1455) 		if (res != FR_OK) break;
    00E24 2300      TST	R16
    00E25 F009      BEQ	0x0E27
    00E26 C00D      RJMP	0x0E34
    00E27 01FB      MOVW	R30,R22
    00E28 963E      ADIW	R30,0xE
    00E29 8020      LD	R2,Z
    00E2A 8031      LDD	R3,Z+1
    00E2B 8042      LDD	R4,Z+2
    00E2C 8053      LDD	R5,Z+3
    00E2D 9488      BCLR	0
    00E2E 2022      TST	R2
    00E2F 0432      CPC	R3,R2
    00E30 0442      CPC	R4,R2
    00E31 0452      CPC	R5,R2
    00E32 F009      BEQ	0x0E34
    00E33 CFC8      RJMP	0x0DFC
(1456) 	}
(1457) 
(1458) 	if (res != FR_OK) dj->sect = 0;
    00E34 2344      TST	R20
    00E35 F039      BEQ	0x0E3D
    00E36 01FB      MOVW	R30,R22
    00E37 963E      ADIW	R30,0xE
    00E38 E080      LDI	R24,0
    00E39 8380      ST	Z,R24
    00E3A 8381      STD	Z+1,R24
    00E3B 8382      STD	Z+2,R24
    00E3C 8383      STD	Z+3,R24
(1459) 
(1460) 	return res;
    00E3D 2F04      MOV	R16,R20
    00E3E 9622      ADIW	R28,2
    00E3F 940C 42E8 JMP	pop_xgsetF03C
ff.c:dir_register:
  dir                  --> R12
  c                    --> R22
  res                  --> R10
  dj                   --> R20
    00E41 940E 42DF CALL	push_xgsetF03C
    00E43 01A8      MOVW	R20,R16
    00E44 9722      SBIW	R28,2
(1461) }
(1462) #endif
(1463) 
(1464) 
(1465) 
(1466) /*-----------------------------------------------------------------------*/
(1467) /* Register an object to the directory                                   */
(1468) /*-----------------------------------------------------------------------*/
(1469) #if !_FS_READONLY
(1470) static
(1471) FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
(1472) 	DIR *dj				/* Target directory with object name to be created */
(1473) )
(1474) {
(1475) 	FRESULT res;
(1476) 	BYTE c, *dir;
(1477) #if _USE_LFN	/* LFN configuration */
(1478) 	WORD n, ne, is;
(1479) 	BYTE sn[12], *fn, sum;
(1480) 	WCHAR *lfn;
(1481) 
(1482) 
(1483) 	fn = dj->fn; lfn = dj->lfn;
(1484) 	mem_cpy(sn, fn, 12);
(1485) 
(1486) 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
(1487) 		return FR_INVALID_NAME;
(1488) 
(1489) 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
(1490) 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
(1491) 		for (n = 1; n < 100; n++) {
(1492) 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
(1493) 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
(1494) 			if (res != FR_OK) break;
(1495) 		}
(1496) 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
(1497) 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
(1498) 		fn[NS] = sn[NS]; dj->lfn = lfn;
(1499) 	}
(1500) 
(1501) 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
(1502) 		for (ne = 0; lfn[ne]; ne++) ;
(1503) 		ne = (ne + 25) / 13;
(1504) 	} else {						/* Otherwise reserve only an SFN entry. */
(1505) 		ne = 1;
(1506) 	}
(1507) 
(1508) 	/* Reserve contiguous entries */
(1509) 	res = dir_sdi(dj, 0);
(1510) 	if (res != FR_OK) return res;
(1511) 	n = is = 0;
(1512) 	do {
(1513) 		res = move_window(dj->fs, dj->sect);
(1514) 		if (res != FR_OK) break;
(1515) 		c = *dj->dir;				/* Check the entry status */
(1516) 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
(1517) 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
(1518) 			if (++n == ne) break;	/* A contiguous entry that required count is found */
(1519) 		} else {
(1520) 			n = 0;					/* Not a blank entry. Restart to search */
(1521) 		}
(1522) 		res = dir_next(dj, 1);		/* Next entry with table stretch */
(1523) 	} while (res == FR_OK);
(1524) 
(1525) 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
(1526) 		res = dir_sdi(dj, is);
(1527) 		if (res == FR_OK) {
(1528) 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
(1529) 			ne--;
(1530) 			do {					/* Store LFN entries in bottom first */
(1531) 				res = move_window(dj->fs, dj->sect);
(1532) 				if (res != FR_OK) break;
(1533) 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
(1534) 				dj->fs->wflag = 1;
(1535) 				res = dir_next(dj, 0);	/* Next entry */
(1536) 			} while (res == FR_OK && --ne);
(1537) 		}
(1538) 	}
(1539) 
(1540) #else	/* Non LFN configuration */
(1541) 	res = dir_sdi(dj, 0);
    00E45 2722      CLR	R18
    00E46 2733      CLR	R19
    00E47 018A      MOVW	R16,R20
    00E48 DCB0      RCALL	ff.c:dir_sdi
    00E49 2EA0      MOV	R10,R16
(1542) 	if (res == FR_OK) {
    00E4A 2300      TST	R16
    00E4B F509      BNE	0x0E6D
(1543) 		do {	/* Find a blank entry for the SFN */
(1544) 			res = move_window(dj->fs, dj->sect);
    00E4C 01FA      MOVW	R30,R20
    00E4D 8426      LDD	R2,Z+14
    00E4E 8437      LDD	R3,Z+15
    00E4F 8840      LDD	R4,Z+16
    00E50 8851      LDD	R5,Z+17
    00E51 8248      ST	Y,R4
    00E52 8259      STD	Y+1,R5
    00E53 0191      MOVW	R18,R2
    00E54 8100      LD	R16,Z
    00E55 8111      LDD	R17,Z+1
    00E56 940E 037D CALL	ff.c:move_window
    00E58 2EA0      MOV	R10,R16
(1545) 			if (res != FR_OK) break;
    00E59 2300      TST	R16
    00E5A F009      BEQ	0x0E5C
    00E5B C011      RJMP	0x0E6D
(1546) 			c = *dj->dir;
    00E5C 01FA      MOVW	R30,R20
    00E5D 89A2      LDD	R26,Z+18
    00E5E 89B3      LDD	R27,Z+19
    00E5F 916C      LD	R22,X
(1547) 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    00E60 3E65      CPI	R22,0xE5
    00E61 F011      BEQ	0x0E64
    00E62 2366      TST	R22
    00E63 F409      BNE	0x0E65
    00E64 C008      RJMP	0x0E6D
(1548) 			res = dir_next(dj, 1);			/* Next entry with table stretch */
    00E65 E021      LDI	R18,1
    00E66 E030      LDI	R19,0
    00E67 018A      MOVW	R16,R20
    00E68 DD9A      RCALL	ff.c:dir_next
    00E69 2EC0      MOV	R12,R16
    00E6A 2CAC      MOV	R10,R12
(1549) 		} while (res == FR_OK);
    00E6B 20AA      TST	R10
    00E6C F2F9      BEQ	0x0E4C
(1550) 	}
(1551) #endif
(1552) 
(1553) 	if (res == FR_OK) {		/* Initialize the SFN entry */
    00E6D 20AA      TST	R10
    00E6E F009      BEQ	0x0E70
    00E6F C030      RJMP	0x0EA0
(1554) 		res = move_window(dj->fs, dj->sect);
    00E70 01FA      MOVW	R30,R20
    00E71 8426      LDD	R2,Z+14
    00E72 8437      LDD	R3,Z+15
    00E73 8840      LDD	R4,Z+16
    00E74 8851      LDD	R5,Z+17
    00E75 8248      ST	Y,R4
    00E76 8259      STD	Y+1,R5
    00E77 0191      MOVW	R18,R2
    00E78 8100      LD	R16,Z
    00E79 8111      LDD	R17,Z+1
    00E7A 940E 037D CALL	ff.c:move_window
    00E7C 2EC0      MOV	R12,R16
    00E7D 2CAC      MOV	R10,R12
(1555) 		if (res == FR_OK) {
    00E7E 2300      TST	R16
    00E7F F501      BNE	0x0EA0
(1556) 			dir = dj->dir;
    00E80 01FA      MOVW	R30,R20
    00E81 88C2      LDD	R12,Z+18
    00E82 88D3      LDD	R13,Z+19
(1557) 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    00E83 E280      LDI	R24,0x20
    00E84 E090      LDI	R25,0
    00E85 8399      STD	Y+1,R25
    00E86 8388      ST	Y,R24
    00E87 2722      CLR	R18
    00E88 2733      CLR	R19
    00E89 0186      MOVW	R16,R12
    00E8A 940E 033A CALL	ff.c:mem_set
(1558) 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    00E8C E08B      LDI	R24,0xB
    00E8D E090      LDI	R25,0
    00E8E 8399      STD	Y+1,R25
    00E8F 8388      ST	Y,R24
    00E90 01FA      MOVW	R30,R20
    00E91 8924      LDD	R18,Z+20
    00E92 8935      LDD	R19,Z+21
    00E93 0186      MOVW	R16,R12
    00E94 940E 0324 CALL	ff.c:mem_cpy
(1559) #if _USE_LFN
(1560) 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
(1561) #endif
(1562) 			dj->fs->wflag = 1;
    00E96 E081      LDI	R24,1
    00E97 01FA      MOVW	R30,R20
    00E98 93AF      PUSH	R26
    00E99 93BF      PUSH	R27
    00E9A 81A0      LD	R26,Z
    00E9B 81B1      LDD	R27,Z+1
    00E9C 01FD      MOVW	R30,R26
    00E9D 91BF      POP	R27
    00E9E 91AF      POP	R26
    00E9F 8384      STD	Z+4,R24
(1563) 		}
(1564) 	}
(1565) 
(1566) 	return res;
    00EA0 2D0A      MOV	R16,R10
    00EA1 9622      ADIW	R28,2
    00EA2 940C 42E8 JMP	pop_xgsetF03C
ff.c:create_name:
  si                   --> R22
  b                    --> Y,+8
  sfn                  --> Y,+6
  ni                   --> R12
  d                    --> R10
  i                    --> Y,+4
  p                    --> Y,+2
  c                    --> R20
  path                 --> Y,+19
  dj                   --> R20
    00EA4 933A      ST	-Y,R19
    00EA5 932A      ST	-Y,R18
    00EA6 940E 42A4 CALL	push_xgsetF0FC
    00EA8 01A8      MOVW	R20,R16
    00EA9 9729      SBIW	R28,0x9
(1567) }
(1568) #endif /* !_FS_READONLY */
(1569) 
(1570) 
(1571) 
(1572) 
(1573) /*-----------------------------------------------------------------------*/
(1574) /* Remove an object from the directory                                   */
(1575) /*-----------------------------------------------------------------------*/
(1576) #if !_FS_READONLY && !_FS_MINIMIZE
(1577) static
(1578) FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
(1579) 	DIR *dj				/* Directory object pointing the entry to be removed */
(1580) )
(1581) {
(1582) 	FRESULT res;
(1583) #if _USE_LFN	/* LFN configuration */
(1584) 	WORD i;
(1585) 
(1586) 	i = dj->index;	/* SFN index */
(1587) 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
(1588) 	if (res == FR_OK) {
(1589) 		do {
(1590) 			res = move_window(dj->fs, dj->sect);
(1591) 			if (res != FR_OK) break;
(1592) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1593) 			dj->fs->wflag = 1;
(1594) 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
(1595) 			res = dir_next(dj, 0);		/* Next entry */
(1596) 		} while (res == FR_OK);
(1597) 		if (res == FR_NO_FILE) res = FR_INT_ERR;
(1598) 	}
(1599) 
(1600) #else			/* Non LFN configuration */
(1601) 	res = dir_sdi(dj, dj->index);
(1602) 	if (res == FR_OK) {
(1603) 		res = move_window(dj->fs, dj->sect);
(1604) 		if (res == FR_OK) {
(1605) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1606) 			dj->fs->wflag = 1;
(1607) 		}
(1608) 	}
(1609) #endif
(1610) 
(1611) 	return res;
(1612) }
(1613) #endif /* !_FS_READONLY */
(1614) 
(1615) 
(1616) 
(1617) 
(1618) /*-----------------------------------------------------------------------*/
(1619) /* Pick a segment and create the object name in directory form           */
(1620) /*-----------------------------------------------------------------------*/
(1621) 
(1622) static
(1623) FRESULT create_name (
(1624) 	DIR *dj,			/* Pointer to the directory object */
(1625) 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
(1626) )
(1627) {
(1628) #ifdef _EXCVT
(1629) 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
(1630) #endif
(1631) 
(1632) #if _USE_LFN	/* LFN configuration */
(1633) 	BYTE b, cf;
(1634) 	WCHAR w, *lfn;
(1635) 	UINT i, ni, si, di;
(1636) 	const TCHAR *p;
(1637) 
(1638) 	/* Create LFN in Unicode */
(1639) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
(1640) 	lfn = dj->lfn;
(1641) 	si = di = 0;
(1642) 	for (;;) {
(1643) 		w = p[si++];					/* Get a character */
(1644) 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
(1645) 		if (di >= _MAX_LFN)				/* Reject too long name */
(1646) 			return FR_INVALID_NAME;
(1647) #if !_LFN_UNICODE
(1648) 		w &= 0xFF;
(1649) 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
(1650) 			b = (BYTE)p[si++];			/* Get 2nd byte */
(1651) 			if (!IsDBCS2(b))
(1652) 				return FR_INVALID_NAME;	/* Reject invalid sequence */
(1653) 			w = (w << 8) + b;			/* Create a DBC */
(1654) 		}
(1655) 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
(1656) 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
(1657) #endif
(1658) 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
(1659) 			return FR_INVALID_NAME;
(1660) 		lfn[di++] = w;					/* Store the Unicode char */
(1661) 	}
(1662) 	*path = &p[si];						/* Return pointer to the next segment */
(1663) 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
(1664) #if _FS_RPATH
(1665) 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
(1666) 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
(1667) 		lfn[di] = 0;
(1668) 		for (i = 0; i < 11; i++)
(1669) 			dj->fn[i] = (i < di) ? '.' : ' ';
(1670) 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
(1671) 		return FR_OK;
(1672) 	}
(1673) #endif
(1674) 	while (di) {						/* Strip trailing spaces and dots */
(1675) 		w = lfn[di-1];
(1676) 		if (w != ' ' && w != '.') break;
(1677) 		di--;
(1678) 	}
(1679) 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
(1680) 
(1681) 	lfn[di] = 0;						/* LFN is created */
(1682) 
(1683) 	/* Create SFN in directory form */
(1684) 	mem_set(dj->fn, ' ', 11);
(1685) 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
(1686) 	if (si) cf |= NS_LOSS | NS_LFN;
(1687) 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
(1688) 
(1689) 	b = i = 0; ni = 8;
(1690) 	for (;;) {
(1691) 		w = lfn[si++];					/* Get an LFN char */
(1692) 		if (!w) break;					/* Break on end of the LFN */
(1693) 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
(1694) 			cf |= NS_LOSS | NS_LFN; continue;
(1695) 		}
(1696) 
(1697) 		if (i >= ni || si == di) {		/* Extension or end of SFN */
(1698) 			if (ni == 11) {				/* Long extension */
(1699) 				cf |= NS_LOSS | NS_LFN; break;
(1700) 			}
(1701) 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
(1702) 			if (si > di) break;			/* No extension */
(1703) 			si = di; i = 8; ni = 11;	/* Enter extension section */
(1704) 			b <<= 2; continue;
(1705) 		}
(1706) 
(1707) 		if (w >= 0x80) {				/* Non ASCII char */
(1708) #ifdef _EXCVT
(1709) 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
(1710) 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
(1711) #else
(1712) 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
(1713) #endif
(1714) 			cf |= NS_LFN;				/* Force create LFN entry */
(1715) 		}
(1716) 
(1717) 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
(1718) 			if (i >= ni - 1) {
(1719) 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
(1720) 			}
(1721) 			dj->fn[i++] = (BYTE)(w >> 8);
(1722) 		} else {						/* Single byte char */
(1723) 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
(1724) 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
(1725) 			} else {
(1726) 				if (IsUpper(w)) {		/* ASCII large capital */
(1727) 					b |= 2;
(1728) 				} else {
(1729) 					if (IsLower(w)) {	/* ASCII small capital */
(1730) 						b |= 1; w -= 0x20;
(1731) 					}
(1732) 				}
(1733) 			}
(1734) 		}
(1735) 		dj->fn[i++] = (BYTE)w;
(1736) 	}
(1737) 
(1738) 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
(1739) 
(1740) 	if (ni == 8) b <<= 2;
(1741) 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
(1742) 		cf |= NS_LFN;
(1743) 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
(1744) 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
(1745) 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
(1746) 	}
(1747) 
(1748) 	dj->fn[NS] = cf;	/* SFN is created */
(1749) 
(1750) 	return FR_OK;
(1751) 
(1752) 
(1753) #else	/* Non-LFN configuration */
(1754) 	BYTE b, c, d, *sfn;
(1755) 	UINT ni, si, i;
(1756) 	const char *p;
(1757) 
(1758) 	/* Create file name in directory form */
(1759) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    00EAA 89EB      LDD	R30,Y+19
    00EAB 89FC      LDD	R31,Y+20
    00EAC 8020      LD	R2,Z
    00EAD 8031      LDD	R3,Z+1
    00EAE 823B      STD	Y+3,R3
    00EAF 822A      STD	Y+2,R2
    00EB0 C005      RJMP	0x0EB6
    00EB1 818A      LDD	R24,Y+2
    00EB2 819B      LDD	R25,Y+3
    00EB3 9601      ADIW	R24,1
    00EB4 839B      STD	Y+3,R25
    00EB5 838A      STD	Y+2,R24
    00EB6 81EA      LDD	R30,Y+2
    00EB7 81FB      LDD	R31,Y+3
    00EB8 8020      LD	R2,Z
    00EB9 2433      CLR	R3
    00EBA 2D82      MOV	R24,R2
    00EBB 328F      CPI	R24,0x2F
    00EBC F3A1      BEQ	0x0EB1
    00EBD 358C      CPI	R24,0x5C
    00EBE F391      BEQ	0x0EB1
(1760) 	sfn = dj->fn;
    00EBF 01FA      MOVW	R30,R20
    00EC0 8824      LDD	R2,Z+20
    00EC1 8835      LDD	R3,Z+21
    00EC2 823F      STD	Y+7,R3
    00EC3 822E      STD	Y+6,R2
(1761) 	mem_set(sfn, ' ', 11);
    00EC4 E08B      LDI	R24,0xB
    00EC5 E090      LDI	R25,0
    00EC6 8399      STD	Y+1,R25
    00EC7 8388      ST	Y,R24
    00EC8 E220      LDI	R18,0x20
    00EC9 E030      LDI	R19,0
    00ECA 0181      MOVW	R16,R2
    00ECB 940E 033A CALL	ff.c:mem_set
(1762) 	si = i = b = 0; ni = 8;
    00ECD 2400      CLR	R0
    00ECE 8608      STD	Y+8,R0
    00ECF 2422      CLR	R2
    00ED0 2433      CLR	R3
    00ED1 823D      STD	Y+5,R3
    00ED2 822C      STD	Y+4,R2
    00ED3 01B1      MOVW	R22,R2
    00ED4 E088      LDI	R24,0x8
    00ED5 E090      LDI	R25,0
    00ED6 016C      MOVW	R12,R24
(1763) #if _FS_RPATH
(1764) 	if (p[si] == '.') { /* Is this a dot entry? */
(1765) 		for (;;) {
(1766) 			c = (BYTE)p[si++];
(1767) 			if (c != '.' || si >= 3) break;
(1768) 			sfn[i++] = c;
(1769) 		}
(1770) 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
(1771) 		*path = &p[si];									/* Return pointer to the next segment */
(1772) 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
(1773) 		return FR_OK;
(1774) 	}
(1775) #endif
(1776) 	for (;;) {
(1777) 		c = (BYTE)p[si++];
    00ED7 01AB      MOVW	R20,R22
    00ED8 5F6F      SUBI	R22,0xFF
    00ED9 4F7F      SBCI	R23,0xFF
    00EDA 01FA      MOVW	R30,R20
    00EDB 800A      LDD	R0,Y+2
    00EDC 801B      LDD	R1,Y+3
    00EDD 0DE0      ADD	R30,R0
    00EDE 1DF1      ADC	R31,R1
    00EDF 8140      LD	R20,Z
(1778) 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    00EE0 E280      LDI	R24,0x20
    00EE1 1784      CP	R24,R20
    00EE2 F420      BCC	0x0EE7
    00EE3 324F      CPI	R20,0x2F
    00EE4 F011      BEQ	0x0EE7
    00EE5 354C      CPI	R20,0x5C
    00EE6 F409      BNE	0x0EE8
    00EE7 C087      RJMP	0x0F6F
(1779) 		if (c == '.' || i >= ni) {
    00EE8 324E      CPI	R20,0x2E
    00EE9 F029      BEQ	0x0EEF
    00EEA 800C      LDD	R0,Y+4
    00EEB 801D      LDD	R1,Y+5
    00EEC 140C      CP	R0,R12
    00EED 041D      CPC	R1,R13
    00EEE F0A0      BCS	0x0F03
(1780) 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    00EEF 01C6      MOVW	R24,R12
    00EF0 3088      CPI	R24,0x8
    00EF1 E0E0      LDI	R30,0
    00EF2 079E      CPC	R25,R30
    00EF3 F411      BNE	0x0EF6
    00EF4 324E      CPI	R20,0x2E
    00EF5 F011      BEQ	0x0EF8
    00EF6 E006      LDI	R16,6
    00EF7 C0AF      RJMP	0x0FA7
(1781) 			i = 8; ni = 11;
    00EF8 E088      LDI	R24,0x8
    00EF9 E090      LDI	R25,0
    00EFA 839D      STD	Y+5,R25
    00EFB 838C      STD	Y+4,R24
    00EFC E08B      LDI	R24,0xB
    00EFD 016C      MOVW	R12,R24
(1782) 			b <<= 2; continue;
    00EFE 8408      LDD	R0,Y+8
    00EFF 0C00      LSL	R0
    00F00 0C00      LSL	R0
    00F01 8608      STD	Y+8,R0
    00F02 CFD4      RJMP	0x0ED7
(1783) 		}
(1784) 		if (c >= 0x80) {				/* Extended char? */
    00F03 3840      CPI	R20,0x80
    00F04 F018      BCS	0x0F08
(1785) 			b |= 3;						/* Eliminate NT flag */
    00F05 8588      LDD	R24,Y+8
    00F06 6083      ORI	R24,3
    00F07 8788      STD	Y+8,R24
(1786) #ifdef _EXCVT
(1787) 			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
(1788) #else
(1789) #if !_DF1S	/* ASCII only cfg */
(1790) 			return FR_INVALID_NAME;
(1791) #endif
(1792) #endif
(1793) 		}
(1794) 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    00F08 3841      CPI	R20,0x81
    00F09 F408      BCC	0x0F0B
    00F0A C039      RJMP	0x0F44
    00F0B EF8E      LDI	R24,0xFE
    00F0C 1784      CP	R24,R20
    00F0D F408      BCC	0x0F0F
    00F0E C035      RJMP	0x0F44
(1795) 			d = (BYTE)p[si++];			/* Get 2nd byte */
    00F0F 015B      MOVW	R10,R22
    00F10 5F6F      SUBI	R22,0xFF
    00F11 4F7F      SBCI	R23,0xFF
    00F12 01F5      MOVW	R30,R10
    00F13 800A      LDD	R0,Y+2
    00F14 801B      LDD	R1,Y+3
    00F15 0DE0      ADD	R30,R0
    00F16 1DF1      ADC	R31,R1
    00F17 80A0      LD	R10,Z
(1796) 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    00F18 2D8A      MOV	R24,R10
    00F19 3480      CPI	R24,0x40
    00F1A F018      BCS	0x0F1E
    00F1B E78E      LDI	R24,0x7E
    00F1C 158A      CP	R24,R10
    00F1D F430      BCC	0x0F24
    00F1E 2D8A      MOV	R24,R10
    00F1F 3880      CPI	R24,0x80
    00F20 F050      BCS	0x0F2B
    00F21 EF8E      LDI	R24,0xFE
    00F22 158A      CP	R24,R10
    00F23 F038      BCS	0x0F2B
    00F24 01C6      MOVW	R24,R12
    00F25 9701      SBIW	R24,1
    00F26 800C      LDD	R0,Y+4
    00F27 801D      LDD	R1,Y+5
    00F28 1608      CP	R0,R24
    00F29 0619      CPC	R1,R25
    00F2A F010      BCS	0x0F2D
(1797) 				return FR_INVALID_NAME;
    00F2B E006      LDI	R16,6
    00F2C C07A      RJMP	0x0FA7
(1798) 			sfn[i++] = c;
    00F2D 80EC      LDD	R14,Y+4
    00F2E 80FD      LDD	R15,Y+5
    00F2F 01C7      MOVW	R24,R14
    00F30 9601      ADIW	R24,1
    00F31 839D      STD	Y+5,R25
    00F32 838C      STD	Y+4,R24
    00F33 01F7      MOVW	R30,R14
    00F34 800E      LDD	R0,Y+6
    00F35 801F      LDD	R1,Y+7
    00F36 0DE0      ADD	R30,R0
    00F37 1DF1      ADC	R31,R1
    00F38 8340      ST	Z,R20
(1799) 			sfn[i++] = d;
    00F39 017C      MOVW	R14,R24
    00F3A 9601      ADIW	R24,1
    00F3B 839D      STD	Y+5,R25
    00F3C 838C      STD	Y+4,R24
    00F3D 01F7      MOVW	R30,R14
    00F3E 800E      LDD	R0,Y+6
    00F3F 801F      LDD	R1,Y+7
    00F40 0DE0      ADD	R30,R0
    00F41 1DF1      ADC	R31,R1
    00F42 82A0      ST	Z,R10
(1800) 		} else {						/* Single byte code */
    00F43 CF93      RJMP	0x0ED7
(1801) 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    00F44 2F24      MOV	R18,R20
    00F45 2733      CLR	R19
    00F46 E000      LDI	R16,0
    00F47 E011      LDI	R17,1
    00F48 940E 036D CALL	ff.c:chk_chr
    00F4A 0158      MOVW	R10,R16
    00F4B 3000      CPI	R16,0
    00F4C 0701      CPC	R16,R17
    00F4D F011      BEQ	0x0F50
(1802) 				return FR_INVALID_NAME;
    00F4E E006      LDI	R16,6
    00F4F C057      RJMP	0x0FA7
(1803) 			if (IsUpper(c)) {			/* ASCII large capital? */
    00F50 3441      CPI	R20,0x41
    00F51 F038      BCS	0x0F59
    00F52 E58A      LDI	R24,0x5A
    00F53 1784      CP	R24,R20
    00F54 F020      BCS	0x0F59
(1804) 				b |= 2;
    00F55 8588      LDD	R24,Y+8
    00F56 6082      ORI	R24,2
    00F57 8788      STD	Y+8,R24
(1805) 			} else {
    00F58 C009      RJMP	0x0F62
(1806) 				if (IsLower(c)) {		/* ASCII small capital? */
    00F59 3641      CPI	R20,0x61
    00F5A F038      BCS	0x0F62
    00F5B E78A      LDI	R24,0x7A
    00F5C 1784      CP	R24,R20
    00F5D F020      BCS	0x0F62
(1807) 					b |= 1; c -= 0x20;
    00F5E 8588      LDD	R24,Y+8
    00F5F 6081      ORI	R24,1
    00F60 8788      STD	Y+8,R24
    00F61 5240      SUBI	R20,0x20
(1808) 				}
(1809) 			}
(1810) 			sfn[i++] = c;
    00F62 80AC      LDD	R10,Y+4
    00F63 80BD      LDD	R11,Y+5
    00F64 01C5      MOVW	R24,R10
    00F65 9601      ADIW	R24,1
    00F66 839D      STD	Y+5,R25
    00F67 838C      STD	Y+4,R24
    00F68 01F5      MOVW	R30,R10
    00F69 800E      LDD	R0,Y+6
    00F6A 801F      LDD	R1,Y+7
    00F6B 0DE0      ADD	R30,R0
    00F6C 1DF1      ADC	R31,R1
    00F6D 8340      ST	Z,R20
    00F6E CF68      RJMP	0x0ED7
(1811) 		}
(1812) 	}
(1813) 	*path = &p[si];						/* Return pointer to the next segment */
    00F6F 011B      MOVW	R2,R22
    00F70 800A      LDD	R0,Y+2
    00F71 801B      LDD	R1,Y+3
    00F72 0C20      ADD	R2,R0
    00F73 1C31      ADC	R3,R1
    00F74 89EB      LDD	R30,Y+19
    00F75 89FC      LDD	R31,Y+20
    00F76 8231      STD	Z+1,R3
    00F77 8220      ST	Z,R2
(1814) 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    00F78 E280      LDI	R24,0x20
    00F79 1784      CP	R24,R20
    00F7A F018      BCS	0x0F7E
    00F7B E064      LDI	R22,4
    00F7C E070      LDI	R23,0
    00F7D C002      RJMP	0x0F80
    00F7E 2766      CLR	R22
    00F7F 2777      CLR	R23
    00F80 2F46      MOV	R20,R22
(1815) 
(1816) 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    00F81 800C      LDD	R0,Y+4
    00F82 801D      LDD	R1,Y+5
    00F83 2000      TST	R0
    00F84 F421      BNE	0x0F89
    00F85 2011      TST	R1
    00F86 F411      BNE	0x0F89
    00F87 E006      LDI	R16,6
    00F88 C01E      RJMP	0x0FA7
(1817) 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    00F89 81EE      LDD	R30,Y+6
    00F8A 81FF      LDD	R31,Y+7
    00F8B 8180      LD	R24,Z
    00F8C 3E85      CPI	R24,0xE5
    00F8D F411      BNE	0x0F90
    00F8E E085      LDI	R24,5
    00F8F 8380      ST	Z,R24
(1818) 
(1819) 	if (ni == 8) b <<= 2;
    00F90 01C6      MOVW	R24,R12
    00F91 3088      CPI	R24,0x8
    00F92 E0E0      LDI	R30,0
    00F93 079E      CPC	R25,R30
    00F94 F421      BNE	0x0F99
    00F95 8408      LDD	R0,Y+8
    00F96 0C00      LSL	R0
    00F97 0C00      LSL	R0
    00F98 8608      STD	Y+8,R0
(1820) 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    00F99 8588      LDD	R24,Y+8
    00F9A 7083      ANDI	R24,3
    00F9B 3081      CPI	R24,1
    00F9C F409      BNE	0x0F9E
    00F9D 6140      ORI	R20,0x10
(1821) 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    00F9E 8588      LDD	R24,Y+8
    00F9F 708C      ANDI	R24,0xC
    00FA0 3084      CPI	R24,4
    00FA1 F409      BNE	0x0FA3
    00FA2 6048      ORI	R20,0x8
(1822) 
(1823) 	sfn[NS] = c;		/* Store NT flag, File name is created */
    00FA3 81EE      LDD	R30,Y+6
    00FA4 81FF      LDD	R31,Y+7
    00FA5 8743      STD	Z+11,R20
(1824) 
(1825) 	return FR_OK;
    00FA6 2700      CLR	R16
    00FA7 9629      ADIW	R28,0x9
    00FA8 940E 4299 CALL	pop_xgsetF0FC
    00FAA 9622      ADIW	R28,2
    00FAB 9508      RET
ff.c:get_fileinfo:
  nt                   --> R12
  p                    --> R20
  dir                  --> R10
  i                    --> R12
  c                    --> R14
  fno                  --> R22
  dj                   --> R10
    00FAC 940E 42A4 CALL	push_xgsetF0FC
    00FAE 01B9      MOVW	R22,R18
    00FAF 0158      MOVW	R10,R16
(1826) #endif
(1827) }
(1828) 
(1829) 
(1830) 
(1831) 
(1832) /*-----------------------------------------------------------------------*/
(1833) /* Get file information from directory entry                             */
(1834) /*-----------------------------------------------------------------------*/
(1835) #if _FS_MINIMIZE <= 1
(1836) static
(1837) void get_fileinfo (		/* No return code */
(1838) 	DIR *dj,			/* Pointer to the directory object */
(1839) 	FILINFO *fno	 	/* Pointer to the file information to be filled */
(1840) )
(1841) {
(1842) 	UINT i;
(1843) 	BYTE nt, *dir;
(1844) 	TCHAR *p, c;
(1845) 
(1846) 
(1847) 	p = fno->fname;
    00FB0 01AB      MOVW	R20,R22
    00FB1 5F47      SUBI	R20,0xF7
    00FB2 4F5F      SBCI	R21,0xFF
(1848) 	if (dj->sect) {
    00FB3 01F5      MOVW	R30,R10
    00FB4 963E      ADIW	R30,0xE
    00FB5 8020      LD	R2,Z
    00FB6 8031      LDD	R3,Z+1
    00FB7 8042      LDD	R4,Z+2
    00FB8 8053      LDD	R5,Z+3
    00FB9 9488      BCLR	0
    00FBA 2022      TST	R2
    00FBB 0432      CPC	R3,R2
    00FBC 0442      CPC	R4,R2
    00FBD 0452      CPC	R5,R2
    00FBE F409      BNE	0x0FC0
    00FBF C08A      RJMP	0x104A
(1849) 		dir = dj->dir;
    00FC0 01F5      MOVW	R30,R10
    00FC1 88A2      LDD	R10,Z+18
    00FC2 88B3      LDD	R11,Z+19
(1850) 		nt = dir[DIR_NTres];		/* NT flag */
(1851) 		for (i = 0; i < 8; i++) {	/* Copy name body */
    00FC3 24CC      CLR	R12
    00FC4 24DD      CLR	R13
    00FC5 C014      RJMP	0x0FDA
(1852) 			c = dir[i];
    00FC6 01F6      MOVW	R30,R12
    00FC7 0DEA      ADD	R30,R10
    00FC8 1DFB      ADC	R31,R11
    00FC9 80E0      LD	R14,Z
(1853) 			if (c == ' ') break;
    00FCA 2D8E      MOV	R24,R14
    00FCB 3280      CPI	R24,0x20
    00FCC F409      BNE	0x0FCE
    00FCD C011      RJMP	0x0FDF
(1854) 			if (c == NDDE) c = (TCHAR)DDE;
    00FCE 2D8E      MOV	R24,R14
    00FCF 3085      CPI	R24,5
    00FD0 F411      BNE	0x0FD3
    00FD1 EE85      LDI	R24,0xE5
    00FD2 2EE8      MOV	R14,R24
(1855) 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
    00FD3 C000      RJMP	0x0FD4
(1856) #if _LFN_UNICODE
(1857) 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
(1858) 				c = (c << 8) | dir[++i];
(1859) 			c = ff_convert(c, 1);
(1860) 			if (!c) c = '?';
(1861) #endif
(1862) 			*p++ = c;
    00FD4 01FA      MOVW	R30,R20
    00FD5 92E1      ST	Z+,R14
    00FD6 01AF      MOVW	R20,R30
    00FD7 01C6      MOVW	R24,R12
    00FD8 9601      ADIW	R24,1
    00FD9 016C      MOVW	R12,R24
    00FDA 01C6      MOVW	R24,R12
    00FDB 3088      CPI	R24,0x8
    00FDC E0E0      LDI	R30,0
    00FDD 079E      CPC	R25,R30
    00FDE F338      BCS	0x0FC6
(1863) 		}
(1864) 		if (dir[8] != ' ') {		/* Copy name extension */
    00FDF 01F5      MOVW	R30,R10
    00FE0 8580      LDD	R24,Z+8
    00FE1 3280      CPI	R24,0x20
    00FE2 F0E1      BEQ	0x0FFF
(1865) 			*p++ = '.';
    00FE3 E28E      LDI	R24,0x2E
    00FE4 01FA      MOVW	R30,R20
    00FE5 9381      ST	Z+,R24
    00FE6 01AF      MOVW	R20,R30
(1866) 			for (i = 8; i < 11; i++) {
    00FE7 E088      LDI	R24,0x8
    00FE8 E090      LDI	R25,0
    00FE9 016C      MOVW	R12,R24
    00FEA C00F      RJMP	0x0FFA
(1867) 				c = dir[i];
    00FEB 01F6      MOVW	R30,R12
    00FEC 0DEA      ADD	R30,R10
    00FED 1DFB      ADC	R31,R11
    00FEE 80E0      LD	R14,Z
(1868) 				if (c == ' ') break;
    00FEF 2D8E      MOV	R24,R14
    00FF0 3280      CPI	R24,0x20
    00FF1 F409      BNE	0x0FF3
    00FF2 C00C      RJMP	0x0FFF
(1869) 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
    00FF3 C000      RJMP	0x0FF4
(1870) #if _LFN_UNICODE
(1871) 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
(1872) 					c = (c << 8) | dir[++i];
(1873) 				c = ff_convert(c, 1);
(1874) 				if (!c) c = '?';
(1875) #endif
(1876) 				*p++ = c;
    00FF4 01FA      MOVW	R30,R20
    00FF5 92E1      ST	Z+,R14
    00FF6 01AF      MOVW	R20,R30
    00FF7 01C6      MOVW	R24,R12
    00FF8 9601      ADIW	R24,1
    00FF9 016C      MOVW	R12,R24
    00FFA 01C6      MOVW	R24,R12
    00FFB 308B      CPI	R24,0xB
    00FFC E0E0      LDI	R30,0
    00FFD 079E      CPC	R25,R30
    00FFE F360      BCS	0x0FEB
(1877) 			}
(1878) 		}
(1879) 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    00FFF 01F5      MOVW	R30,R10
    01000 8423      LDD	R2,Z+11
    01001 01FB      MOVW	R30,R22
    01002 8620      STD	Z+8,R2
(1880) 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    01003 E188      LDI	R24,0x18
    01004 E090      LDI	R25,0
    01005 01F5      MOVW	R30,R10
    01006 8D07      LDD	R16,Z+31
    01007 2711      CLR	R17
    01008 2722      CLR	R18
    01009 2733      CLR	R19
    0100A 938A      ST	-Y,R24
    0100B 940E 4326 CALL	lsl32
    0100D 0118      MOVW	R2,R16
    0100E 0129      MOVW	R4,R18
    0100F 01F5      MOVW	R30,R10
    01010 8C66      LDD	R6,Z+30
    01011 2477      CLR	R7
    01012 2488      CLR	R8
    01013 2499      CLR	R9
    01014 0143      MOVW	R8,R6
    01015 2466      CLR	R6
    01016 2477      CLR	R7
    01017 2826      OR	R2,R6
    01018 2837      OR	R3,R7
    01019 2848      OR	R4,R8
    0101A 2859      OR	R5,R9
    0101B 8C65      LDD	R6,Z+29
    0101C 2477      CLR	R7
    0101D 2C76      MOV	R7,R6
    0101E 2466      CLR	R6
    0101F 2488      CLR	R8
    01020 2499      CLR	R9
    01021 2826      OR	R2,R6
    01022 2837      OR	R3,R7
    01023 2848      OR	R4,R8
    01024 2859      OR	R5,R9
    01025 8C64      LDD	R6,Z+28
    01026 2477      CLR	R7
    01027 2488      CLR	R8
    01028 2499      CLR	R9
    01029 2826      OR	R2,R6
    0102A 2837      OR	R3,R7
    0102B 2848      OR	R4,R8
    0102C 2859      OR	R5,R9
    0102D 01FB      MOVW	R30,R22
    0102E 8220      ST	Z,R2
    0102F 8231      STD	Z+1,R3
    01030 8242      STD	Z+2,R4
    01031 8253      STD	Z+3,R5
(1881) 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    01032 01F5      MOVW	R30,R10
    01033 8C20      LDD	R2,Z+24
    01034 2433      CLR	R3
    01035 8C41      LDD	R4,Z+25
    01036 2455      CLR	R5
    01037 2C54      MOV	R5,R4
    01038 2444      CLR	R4
    01039 2842      OR	R4,R2
    0103A 2853      OR	R5,R3
    0103B 01FB      MOVW	R30,R22
    0103C 8255      STD	Z+5,R5
    0103D 8244      STD	Z+4,R4
(1882) 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    0103E 01F5      MOVW	R30,R10
    0103F 8826      LDD	R2,Z+22
    01040 2433      CLR	R3
    01041 8847      LDD	R4,Z+23
    01042 2455      CLR	R5
    01043 2C54      MOV	R5,R4
    01044 2444      CLR	R4
    01045 2842      OR	R4,R2
    01046 2853      OR	R5,R3
    01047 01FB      MOVW	R30,R22
    01048 8257      STD	Z+7,R5
    01049 8246      STD	Z+6,R4
(1883) 	}
(1884) 	*p = 0;		/* Terminate SFN str by a \0 */
    0104A 2422      CLR	R2
    0104B 01FA      MOVW	R30,R20
    0104C 8220      ST	Z,R2
    0104D 940C 4299 JMP	pop_xgsetF0FC
ff.c:follow_path:
  ns                   --> R10
  res                  --> R20
  dir                  --> R10
  path                 --> Y,+6
  dj                   --> R22
    0104F 933A      ST	-Y,R19
    01050 932A      ST	-Y,R18
    01051 940E 42C3 CALL	push_xgsetF00C
    01053 01B8      MOVW	R22,R16
(1885) 
(1886) #if _USE_LFN
(1887) 	if (fno->lfname && fno->lfsize) {
(1888) 		TCHAR *tp = fno->lfname;
(1889) 		WCHAR w, *lfn;
(1890) 
(1891) 		i = 0;
(1892) 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
(1893) 			lfn = dj->lfn;
(1894) 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
(1895) #if !_LFN_UNICODE
(1896) 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
(1897) 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
(1898) 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
(1899) 					tp[i++] = (TCHAR)(w >> 8);
(1900) #endif
(1901) 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
(1902) 				tp[i++] = (TCHAR)w;
(1903) 			}
(1904) 		}
(1905) 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
(1906) 	}
(1907) #endif
(1908) }
(1909) #endif /* _FS_MINIMIZE <= 1 */
(1910) 
(1911) 
(1912) 
(1913) 
(1914) /*-----------------------------------------------------------------------*/
(1915) /* Follow a file path                                                    */
(1916) /*-----------------------------------------------------------------------*/
(1917) 
(1918) static
(1919) FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
(1920) 	DIR *dj,			/* Directory object to return last directory and found object */
(1921) 	const TCHAR *path	/* Full-path string to find a file or directory */
(1922) )
(1923) {
(1924) 	FRESULT res;
(1925) 	BYTE *dir, ns;
(1926) 
(1927) 
(1928) #if _FS_RPATH
(1929) 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
(1930) 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
(1931) 	} else {							/* No heading separator */
(1932) 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
(1933) 	}
(1934) #else
(1935) 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    01054 81EE      LDD	R30,Y+6
    01055 81FF      LDD	R31,Y+7
    01056 8020      LD	R2,Z
    01057 2433      CLR	R3
    01058 2D82      MOV	R24,R2
    01059 328F      CPI	R24,0x2F
    0105A F011      BEQ	0x105D
    0105B 358C      CPI	R24,0x5C
    0105C F429      BNE	0x1062
(1936) 		path++;
    0105D 818E      LDD	R24,Y+6
    0105E 819F      LDD	R25,Y+7
    0105F 9601      ADIW	R24,1
    01060 839F      STD	Y+7,R25
    01061 838E      STD	Y+6,R24
(1937) 	dj->sclust = 0;						/* Start from the root dir */
    01062 01FB      MOVW	R30,R22
    01063 9636      ADIW	R30,6
    01064 E080      LDI	R24,0
    01065 8380      ST	Z,R24
    01066 8381      STD	Z+1,R24
    01067 8382      STD	Z+2,R24
    01068 8383      STD	Z+3,R24
(1938) #endif
(1939) 
(1940) 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    01069 81EE      LDD	R30,Y+6
    0106A 81FF      LDD	R31,Y+7
    0106B 8180      LD	R24,Z
    0106C 2799      CLR	R25
    0106D 3280      CPI	R24,0x20
    0106E E0E0      LDI	R30,0
    0106F 079E      CPC	R25,R30
    01070 F458      BCC	0x107C
(1941) 		res = dir_sdi(dj, 0);
    01071 2722      CLR	R18
    01072 2733      CLR	R19
    01073 018B      MOVW	R16,R22
    01074 DA84      RCALL	ff.c:dir_sdi
    01075 2F40      MOV	R20,R16
(1942) 		dj->dir = 0;
    01076 2422      CLR	R2
    01077 2433      CLR	R3
    01078 01FB      MOVW	R30,R22
    01079 8A33      STD	Z+19,R3
    0107A 8A22      STD	Z+18,R2
(1943) 
(1944) 	} else {							/* Follow path */
    0107B C052      RJMP	0x10CE
(1945) 		for (;;) {
(1946) 			res = create_name(dj, &path);	/* Get a segment */
    0107C 019E      MOVW	R18,R28
    0107D 5F2A      SUBI	R18,0xFA
    0107E 4F3F      SBCI	R19,0xFF
    0107F 018B      MOVW	R16,R22
    01080 DE23      RCALL	ff.c:create_name
    01081 2EA0      MOV	R10,R16
    01082 2D4A      MOV	R20,R10
(1947) 			if (res != FR_OK) break;
    01083 2300      TST	R16
    01084 F009      BEQ	0x1086
    01085 C048      RJMP	0x10CE
(1948) 			res = dir_find(dj);				/* Find it */
    01086 018B      MOVW	R16,R22
    01087 DD29      RCALL	ff.c:dir_find
    01088 2EA0      MOV	R10,R16
    01089 2D4A      MOV	R20,R10
(1949) 			ns = *(dj->fn+NS);
    0108A 01FB      MOVW	R30,R22
    0108B 93AF      PUSH	R26
    0108C 93BF      PUSH	R27
    0108D 89A4      LDD	R26,Z+20
    0108E 89B5      LDD	R27,Z+21
    0108F 01FD      MOVW	R30,R26
    01090 91BF      POP	R27
    01091 91AF      POP	R26
    01092 84A3      LDD	R10,Z+11
(1950) 			if (res != FR_OK) {				/* Failed to find the object */
    01093 2300      TST	R16
    01094 F049      BEQ	0x109E
(1951) 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    01095 3004      CPI	R16,4
    01096 F009      BEQ	0x1098
    01097 C036      RJMP	0x10CE
(1952) 				/* Object not found */
(1953) 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    01098 C001      RJMP	0x109A
(1954) 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
(1955) 					res = FR_OK;
(1956) 					if (!(ns & NS_LAST)) continue;
    01099 CFE2      RJMP	0x107C
(1957) 				} else {							/* Could not find the object */
(1958) 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    0109A FCA2      SBRC	R10,2
    0109B C032      RJMP	0x10CE
    0109C E045      LDI	R20,5
(1959) 				}
(1960) 				break;
    0109D C030      RJMP	0x10CE
(1961) 			}
(1962) 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    0109E FEA2      SBRS	R10,2
    0109F C001      RJMP	0x10A1
    010A0 C02D      RJMP	0x10CE
(1963) 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    010A1 01FB      MOVW	R30,R22
    010A2 88A2      LDD	R10,Z+18
    010A3 88B3      LDD	R11,Z+19
(1964) 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    010A4 01F5      MOVW	R30,R10
    010A5 8423      LDD	R2,Z+11
    010A6 FC24      SBRC	R2,4
    010A7 C002      RJMP	0x10AA
(1965) 				res = FR_NO_PATH; break;
    010A8 E045      LDI	R20,5
    010A9 C024      RJMP	0x10CE
(1966) 			}
(1967) 			dj->sclust = LD_CLUST(dir);
    010AA 01F5      MOVW	R30,R10
    010AB 8C22      LDD	R2,Z+26
    010AC 2433      CLR	R3
    010AD 8C43      LDD	R4,Z+27
    010AE 2455      CLR	R5
    010AF 2C54      MOV	R5,R4
    010B0 2444      CLR	R4
    010B1 2842      OR	R4,R2
    010B2 2853      OR	R5,R3
    010B3 0112      MOVW	R2,R4
    010B4 2444      CLR	R4
    010B5 2455      CLR	R5
    010B6 8864      LDD	R6,Z+20
    010B7 2477      CLR	R7
    010B8 8885      LDD	R8,Z+21
    010B9 2499      CLR	R9
    010BA 2C98      MOV	R9,R8
    010BB 2488      CLR	R8
    010BC 2886      OR	R8,R6
    010BD 2897      OR	R9,R7
    010BE 0134      MOVW	R6,R8
    010BF 2488      CLR	R8
    010C0 2499      CLR	R9
    010C1 0143      MOVW	R8,R6
    010C2 2466      CLR	R6
    010C3 2477      CLR	R7
    010C4 2862      OR	R6,R2
    010C5 2873      OR	R7,R3
    010C6 2884      OR	R8,R4
    010C7 2895      OR	R9,R5
    010C8 01FB      MOVW	R30,R22
    010C9 8266      STD	Z+6,R6
    010CA 8277      STD	Z+7,R7
    010CB 8680      STD	Z+8,R8
    010CC 8691      STD	Z+9,R9
    010CD CFAE      RJMP	0x107C
(1968) 		}
(1969) 	}
(1970) 
(1971) 	return res;
    010CE 2F04      MOV	R16,R20
    010CF 940E 42CA CALL	pop_xgsetF00C
    010D1 9622      ADIW	R28,2
    010D2 9508      RET
ff.c:check_fs:
  sect                 --> Y,+11
  fs                   --> R10
    010D3 933A      ST	-Y,R19
    010D4 932A      ST	-Y,R18
    010D5 940E 42C3 CALL	push_xgsetF00C
    010D7 0158      MOVW	R10,R16
    010D8 9725      SBIW	R28,5
(1972) }
(1973) 
(1974) 
(1975) 
(1976) 
(1977) /*-----------------------------------------------------------------------*/
(1978) /* Load a sector and check if it is an FAT Volume Boot Record            */
(1979) /*-----------------------------------------------------------------------*/
(1980) 
(1981) static
(1982) BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
(1983) 	FATFS *fs,	/* File system object */
(1984) 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
(1985) )
(1986) {
(1987) 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    010D9 E081      LDI	R24,1
    010DA 838C      STD	Y+4,R24
    010DB 842B      LDD	R2,Y+11
    010DC 843C      LDD	R3,Y+12
    010DD 844D      LDD	R4,Y+13
    010DE 845E      LDD	R5,Y+14
    010DF 8228      ST	Y,R2
    010E0 8239      STD	Y+1,R3
    010E1 824A      STD	Y+2,R4
    010E2 825B      STD	Y+3,R5
    010E3 0195      MOVW	R18,R10
    010E4 5D22      SUBI	R18,0xD2
    010E5 4F3F      SBCI	R19,0xFF
    010E6 01F5      MOVW	R30,R10
    010E7 8101      LDD	R16,Z+1
    010E8 940E 02E2 CALL	_disk_read
    010EA 2300      TST	R16
    010EB F011      BEQ	0x10EE
(1988) 		return 3;
    010EC E003      LDI	R16,3
    010ED C0A8      RJMP	0x1196
(1989) 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    010EE 01F5      MOVW	R30,R10
    010EF 5DE4      SUBI	R30,0xD4
    010F0 4FFD      SBCI	R31,0xFD
    010F1 8020      LD	R2,Z
    010F2 52EC      SUBI	R30,0x2C
    010F3 40F2      SBCI	R31,2
    010F4 2433      CLR	R3
    010F5 5DE3      SUBI	R30,0xD3
    010F6 4FFD      SBCI	R31,0xFD
    010F7 8180      LD	R24,Z
    010F8 2799      CLR	R25
    010F9 2F98      MOV	R25,R24
    010FA 2788      CLR	R24
    010FB 2982      OR	R24,R2
    010FC 2993      OR	R25,R3
    010FD 3585      CPI	R24,0x55
    010FE EAEA      LDI	R30,0xAA
    010FF 079E      CPC	R25,R30
    01100 F011      BEQ	0x1103
(1990) 		return 2;
    01101 E002      LDI	R16,2
    01102 C093      RJMP	0x1196
(1991) 
(1992) 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    01103 E188      LDI	R24,0x18
    01104 E090      LDI	R25,0
    01105 01F5      MOVW	R30,R10
    01106 59E9      SUBI	R30,0x99
    01107 4FFF      SBCI	R31,0xFF
    01108 8100      LD	R16,Z
    01109 2711      CLR	R17
    0110A 2722      CLR	R18
    0110B 2733      CLR	R19
    0110C 938A      ST	-Y,R24
    0110D 940E 4326 CALL	lsl32
    0110F 0118      MOVW	R2,R16
    01110 0129      MOVW	R4,R18
    01111 01F5      MOVW	R30,R10
    01112 59EA      SUBI	R30,0x9A
    01113 4FFF      SBCI	R31,0xFF
    01114 8060      LD	R6,Z
    01115 56E6      SUBI	R30,0x66
    01116 40F0      SBCI	R31,0
    01117 2477      CLR	R7
    01118 2488      CLR	R8
    01119 2499      CLR	R9
    0111A 0143      MOVW	R8,R6
    0111B 2466      CLR	R6
    0111C 2477      CLR	R7
    0111D 2826      OR	R2,R6
    0111E 2837      OR	R3,R7
    0111F 2848      OR	R4,R8
    01120 2859      OR	R5,R9
    01121 59EB      SUBI	R30,0x9B
    01122 4FFF      SBCI	R31,0xFF
    01123 8060      LD	R6,Z
    01124 56E5      SUBI	R30,0x65
    01125 40F0      SBCI	R31,0
    01126 2477      CLR	R7
    01127 2C76      MOV	R7,R6
    01128 2466      CLR	R6
    01129 2488      CLR	R8
    0112A 2499      CLR	R9
    0112B 2826      OR	R2,R6
    0112C 2837      OR	R3,R7
    0112D 2848      OR	R4,R8
    0112E 2859      OR	R5,R9
    0112F 59EC      SUBI	R30,0x9C
    01130 4FFF      SBCI	R31,0xFF
    01131 8060      LD	R6,Z
    01132 2477      CLR	R7
    01133 2488      CLR	R8
    01134 2499      CLR	R9
    01135 2826      OR	R2,R6
    01136 2837      OR	R3,R7
    01137 2848      OR	R4,R8
    01138 2859      OR	R5,R9
    01139 EF4F      LDI	R20,0xFF
    0113A EF5F      LDI	R21,0xFF
    0113B EF6F      LDI	R22,0xFF
    0113C E070      LDI	R23,0
    0113D 2224      AND	R2,R20
    0113E 2235      AND	R3,R21
    0113F 2246      AND	R4,R22
    01140 2257      AND	R5,R23
    01141 E446      LDI	R20,0x46
    01142 E451      LDI	R21,0x41
    01143 E564      LDI	R22,0x54
    01144 E070      LDI	R23,0
    01145 1624      CP	R2,R20
    01146 0635      CPC	R3,R21
    01147 0646      CPC	R4,R22
    01148 0657      CPC	R5,R23
    01149 F411      BNE	0x114C
(1993) 		return 0;
    0114A 2700      CLR	R16
    0114B C04A      RJMP	0x1196
(1994) 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    0114C E188      LDI	R24,0x18
    0114D E090      LDI	R25,0
    0114E 01F5      MOVW	R30,R10
    0114F 57ED      SUBI	R30,0x7D
    01150 4FFF      SBCI	R31,0xFF
    01151 8100      LD	R16,Z
    01152 2711      CLR	R17
    01153 2722      CLR	R18
    01154 2733      CLR	R19
    01155 938A      ST	-Y,R24
    01156 940E 4326 CALL	lsl32
    01158 0118      MOVW	R2,R16
    01159 0129      MOVW	R4,R18
    0115A 01F5      MOVW	R30,R10
    0115B 57EE      SUBI	R30,0x7E
    0115C 4FFF      SBCI	R31,0xFF
    0115D 8060      LD	R6,Z
    0115E 58E2      SUBI	R30,0x82
    0115F 40F0      SBCI	R31,0
    01160 2477      CLR	R7
    01161 2488      CLR	R8
    01162 2499      CLR	R9
    01163 0143      MOVW	R8,R6
    01164 2466      CLR	R6
    01165 2477      CLR	R7
    01166 2826      OR	R2,R6
    01167 2837      OR	R3,R7
    01168 2848      OR	R4,R8
    01169 2859      OR	R5,R9
    0116A 57EF      SUBI	R30,0x7F
    0116B 4FFF      SBCI	R31,0xFF
    0116C 8060      LD	R6,Z
    0116D 58E1      SUBI	R30,0x81
    0116E 40F0      SBCI	R31,0
    0116F 2477      CLR	R7
    01170 2C76      MOV	R7,R6
    01171 2466      CLR	R6
    01172 2488      CLR	R8
    01173 2499      CLR	R9
    01174 2826      OR	R2,R6
    01175 2837      OR	R3,R7
    01176 2848      OR	R4,R8
    01177 2859      OR	R5,R9
    01178 58E0      SUBI	R30,0x80
    01179 4FFF      SBCI	R31,0xFF
    0117A 8060      LD	R6,Z
    0117B 2477      CLR	R7
    0117C 2488      CLR	R8
    0117D 2499      CLR	R9
    0117E 2826      OR	R2,R6
    0117F 2837      OR	R3,R7
    01180 2848      OR	R4,R8
    01181 2859      OR	R5,R9
    01182 EF4F      LDI	R20,0xFF
    01183 EF5F      LDI	R21,0xFF
    01184 EF6F      LDI	R22,0xFF
    01185 E070      LDI	R23,0
    01186 2224      AND	R2,R20
    01187 2235      AND	R3,R21
    01188 2246      AND	R4,R22
    01189 2257      AND	R5,R23
    0118A E446      LDI	R20,0x46
    0118B E451      LDI	R21,0x41
    0118C E564      LDI	R22,0x54
    0118D E070      LDI	R23,0
    0118E 1624      CP	R2,R20
    0118F 0635      CPC	R3,R21
    01190 0646      CPC	R4,R22
    01191 0657      CPC	R5,R23
    01192 F411      BNE	0x1195
(1995) 		return 0;
    01193 2700      CLR	R16
    01194 C001      RJMP	0x1196
(1996) 
(1997) 	return 1;
    01195 E001      LDI	R16,1
    01196 9625      ADIW	R28,5
    01197 940E 42CA CALL	pop_xgsetF00C
    01199 9622      ADIW	R28,2
    0119A 9508      RET
ff.c:chk_mounted:
  pi                   --> R10
  szbfat               --> Y,+25
  tbl                  --> R10
  p                    --> R10
  nrsv                 --> R14
  sysect               --> Y,+21
  bsect                --> Y,+17
  stat                 --> R10
  tsect                --> Y,+13
  nclst                --> Y,+9
  vol                  --> R14
  fasize               --> Y,+5
  b                    --> R14
  fmt                  --> R12
  fs                   --> Y,+37
  chk_wp               --> Y,+51
  rfs                  --> Y,+49
  path                 --> R12
    0119B 933A      ST	-Y,R19
    0119C 932A      ST	-Y,R18
    0119D 940E 42A4 CALL	push_xgsetF0FC
    0119F 0168      MOVW	R12,R16
    011A0 97A7      SBIW	R28,0x27
(1998) }
(1999) 
(2000) 
(2001) 
(2002) 
(2003) /*-----------------------------------------------------------------------*/
(2004) /* Check if the file system object is valid or not                       */
(2005) /*-----------------------------------------------------------------------*/
(2006) 
(2007) static
(2008) FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
(2009) 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
(2010) 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
(2011) 	BYTE chk_wp			/* !=0: Check media write protection for write access */
(2012) )
(2013) {
(2014) 	BYTE fmt, b, pi, *tbl;
(2015) 	UINT vol;
(2016) 	DSTATUS stat;
(2017) 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
(2018) 	WORD nrsv;
(2019) 	const TCHAR *p = *path;
    011A1 01F6      MOVW	R30,R12
    011A2 80A0      LD	R10,Z
    011A3 80B1      LDD	R11,Z+1
(2020) 	FATFS *fs;
(2021) 
(2022) 	/* Get logical drive number from the path name */
(2023) 	vol = p[0] - '0';					/* Is there a drive number? */
    011A4 01F5      MOVW	R30,R10
    011A5 8180      LD	R24,Z
    011A6 2799      CLR	R25
    011A7 97C0      SBIW	R24,0x30
    011A8 017C      MOVW	R14,R24
(2024) 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    011A9 E089      LDI	R24,0x9
    011AA E090      LDI	R25,0
    011AB 158E      CP	R24,R14
    011AC 059F      CPC	R25,R15
    011AD F050      BCS	0x11B8
    011AE 8181      LDD	R24,Z+1
    011AF 338A      CPI	R24,0x3A
    011B0 F439      BNE	0x11B8
(2025) 		p += 2; *path = p;				/* Return pointer to the path name */
    011B1 01CF      MOVW	R24,R30
    011B2 9602      ADIW	R24,2
    011B3 015C      MOVW	R10,R24
    011B4 01F6      MOVW	R30,R12
    011B5 82B1      STD	Z+1,R11
    011B6 82A0      ST	Z,R10
(2026) 	} else {							/* No drive number is given */
    011B7 C002      RJMP	0x11BA
(2027) #if _FS_RPATH
(2028) 		vol = CurrVol;					/* Use current drive */
(2029) #else
(2030) 		vol = 0;						/* Use drive 0 */
    011B8 24EE      CLR	R14
    011B9 24FF      CLR	R15
(2031) #endif
(2032) 	}
(2033) 
(2034) 	/* Check if the file system object is valid or not */
(2035) 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    011BA 01C7      MOVW	R24,R14
    011BB 3081      CPI	R24,1
    011BC E0E0      LDI	R30,0
    011BD 079E      CPC	R25,R30
    011BE F010      BCS	0x11C1
(2036) 		return FR_INVALID_DRIVE;
    011BF E00B      LDI	R16,0xB
    011C0 C4CF      RJMP	0x1690
(2037) 	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    011C1 E787      LDI	R24,0x77
    011C2 E095      LDI	R25,5
    011C3 01F7      MOVW	R30,R14
    011C4 0FEE      LSL	R30
    011C5 1FFF      ROL	R31
    011C6 0FE8      ADD	R30,R24
    011C7 1FF9      ADC	R31,R25
    011C8 8020      LD	R2,Z
    011C9 8031      LDD	R3,Z+1
    011CA A23E      STD	Y+38,R3
    011CB A22D      STD	Y+37,R2
    011CC A9E9      LDD	R30,Y+49
    011CD A9FA      LDD	R31,Y+50
    011CE 8231      STD	Z+1,R3
    011CF 8220      ST	Z,R2
(2038) 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    011D0 0101      MOVW	R0,R2
    011D1 2022      TST	R2
    011D2 F421      BNE	0x11D7
    011D3 2033      TST	R3
    011D4 F411      BNE	0x11D7
    011D5 E00C      LDI	R16,0xC
    011D6 C4B9      RJMP	0x1690
(2039) 
(2040) 	ENTER_FF(fs);						/* Lock file system */
(2041) 
(2042) 	if (fs->fs_type) {					/* If the logical drive has been mounted */
    011D7 A1ED      LDD	R30,Y+37
    011D8 A1FE      LDD	R31,Y+38
    011D9 8020      LD	R2,Z
    011DA 2022      TST	R2
    011DB F079      BEQ	0x11EB
(2043) 		stat = disk_status(fs->drv);
    011DC 8101      LDD	R16,Z+1
    011DD 940E 02DC CALL	_disk_status
    011DF 2EA0      MOV	R10,R16
(2044) 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    011E0 FD00      SBRC	R16,0
    011E1 C009      RJMP	0x11EB
(2045) 			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    011E2 A80B      LDD	R0,Y+51
    011E3 2000      TST	R0
    011E4 F021      BEQ	0x11E9
    011E5 FF02      SBRS	R16,2
    011E6 C002      RJMP	0x11E9
(2046) 				return FR_WRITE_PROTECTED;
    011E7 E00A      LDI	R16,0xA
    011E8 C4A7      RJMP	0x1690
(2047) 			return FR_OK;				/* The file system object is valid */
    011E9 2700      CLR	R16
    011EA C4A5      RJMP	0x1690
(2048) 		}
(2049) 	}
(2050) 
(2051) 	/* The file system object is not valid. */
(2052) 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
(2053) 
(2054) 	fs->fs_type = 0;					/* Clear the file system object */
    011EB 2422      CLR	R2
    011EC A1ED      LDD	R30,Y+37
    011ED A1FE      LDD	R31,Y+38
    011EE 8220      ST	Z,R2
(2055) 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    011EF 82E1      STD	Z+1,R14
(2056) 	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    011F0 8101      LDD	R16,Z+1
    011F1 940E 02C6 CALL	_disk_initialize
    011F3 2EE0      MOV	R14,R16
    011F4 2CAE      MOV	R10,R14
(2057) 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    011F5 FF00      SBRS	R16,0
    011F6 C002      RJMP	0x11F9
(2058) 		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    011F7 E003      LDI	R16,3
    011F8 C497      RJMP	0x1690
(2059) 	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    011F9 A80B      LDD	R0,Y+51
    011FA 2000      TST	R0
    011FB F021      BEQ	0x1200
    011FC FEA2      SBRS	R10,2
    011FD C002      RJMP	0x1200
(2060) 		return FR_WRITE_PROTECTED;
    011FE E00A      LDI	R16,0xA
    011FF C490      RJMP	0x1690
(2061) #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
(2062) 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
(2063) 		return FR_DISK_ERR;
(2064) #endif
(2065) 	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
(2066) 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    01200 E080      LDI	R24,0
    01201 8B89      STD	Y+17,R24
    01202 8B8A      STD	Y+18,R24
    01203 8B8B      STD	Y+19,R24
    01204 8B8C      STD	Y+20,R24
    01205 E040      LDI	R20,0
    01206 E050      LDI	R21,0
    01207 E060      LDI	R22,0
    01208 E070      LDI	R23,0
    01209 8368      ST	Y,R22
    0120A 8379      STD	Y+1,R23
    0120B 019A      MOVW	R18,R20
    0120C A10D      LDD	R16,Y+37
    0120D A11E      LDD	R17,Y+38
    0120E DEC4      RCALL	ff.c:check_fs
    0120F 2EA0      MOV	R10,R16
    01210 2CCA      MOV	R12,R10
(2067) 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
    01211 C000      RJMP	0x1212
(2068) 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    01212 2D8C      MOV	R24,R12
    01213 3081      CPI	R24,1
    01214 F009      BEQ	0x1216
    01215 C04C      RJMP	0x1262
(2069) 		/* Check the partition listed in the partition table */
(2070) 		pi = LD2PT(vol);
    01216 24AA      CLR	R10
(2071) 		if (pi) pi--;
    01217 F009      BEQ	0x1219
    01218 94AA      DEC	R10
(2072) 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
    01219 E100      LDI	R16,0x10
    0121A 2D1A      MOV	R17,R10
    0121B 0301      MULSU	R16,R17
    0121C 0150      MOVW	R10,R0
    0121D A18D      LDD	R24,Y+37
    0121E A19E      LDD	R25,Y+38
    0121F 5184      SUBI	R24,0x14
    01220 4F9E      SBCI	R25,0xFE
    01221 0EA8      ADD	R10,R24
    01222 1EB9      ADC	R11,R25
(2073) 		if (tbl[4]) {						/* Is the partition existing? */
    01223 01F5      MOVW	R30,R10
    01224 8024      LDD	R2,Z+4
    01225 2022      TST	R2
    01226 F409      BNE	0x1228
    01227 C03A      RJMP	0x1262
(2074) 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    01228 E188      LDI	R24,0x18
    01229 E090      LDI	R25,0
    0122A 8503      LDD	R16,Z+11
    0122B 2711      CLR	R17
    0122C 2722      CLR	R18
    0122D 2733      CLR	R19
    0122E 938A      ST	-Y,R24
    0122F 940E 4326 CALL	lsl32
    01231 0118      MOVW	R2,R16
    01232 0129      MOVW	R4,R18
    01233 01F5      MOVW	R30,R10
    01234 8462      LDD	R6,Z+10
    01235 2477      CLR	R7
    01236 2488      CLR	R8
    01237 2499      CLR	R9
    01238 0143      MOVW	R8,R6
    01239 2466      CLR	R6
    0123A 2477      CLR	R7
    0123B 2826      OR	R2,R6
    0123C 2837      OR	R3,R7
    0123D 2848      OR	R4,R8
    0123E 2859      OR	R5,R9
    0123F 8461      LDD	R6,Z+9
    01240 2477      CLR	R7
    01241 2C76      MOV	R7,R6
    01242 2466      CLR	R6
    01243 2488      CLR	R8
    01244 2499      CLR	R9
    01245 2826      OR	R2,R6
    01246 2837      OR	R3,R7
    01247 2848      OR	R4,R8
    01248 2859      OR	R5,R9
    01249 9638      ADIW	R30,0x8
    0124A 8060      LD	R6,Z
    0124B 2477      CLR	R7
    0124C 2488      CLR	R8
    0124D 2499      CLR	R9
    0124E 2826      OR	R2,R6
    0124F 2837      OR	R3,R7
    01250 2848      OR	R4,R8
    01251 2859      OR	R5,R9
    01252 8A29      STD	Y+17,R2
    01253 8A3A      STD	Y+18,R3
    01254 8A4B      STD	Y+19,R4
    01255 8A5C      STD	Y+20,R5
(2075) 			fmt = check_fs(fs, bsect);		/* Check the partition */
    01256 8829      LDD	R2,Y+17
    01257 883A      LDD	R3,Y+18
    01258 884B      LDD	R4,Y+19
    01259 885C      LDD	R5,Y+20
    0125A 8248      ST	Y,R4
    0125B 8259      STD	Y+1,R5
    0125C 0191      MOVW	R18,R2
    0125D A10D      LDD	R16,Y+37
    0125E A11E      LDD	R17,Y+38
    0125F DE73      RCALL	ff.c:check_fs
    01260 2EA0      MOV	R10,R16
    01261 2CCA      MOV	R12,R10
(2076) 		}
(2077) 	}
(2078) 	if (fmt == 3) return FR_DISK_ERR;
    01262 2D8C      MOV	R24,R12
    01263 3083      CPI	R24,3
    01264 F411      BNE	0x1267
    01265 E001      LDI	R16,1
    01266 C429      RJMP	0x1690
(2079) 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    01267 20CC      TST	R12
    01268 F011      BEQ	0x126B
    01269 E00D      LDI	R16,0xD
    0126A C425      RJMP	0x1690
(2080) 
(2081) 	/* An FAT volume is found. Following code initializes the file system object */
(2082) 
(2083) 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    0126B A1ED      LDD	R30,Y+37
    0126C A1FE      LDD	R31,Y+38
    0126D AC21      LDD	R2,Z+57
    0126E 2433      CLR	R3
    0126F AD82      LDD	R24,Z+58
    01270 2799      CLR	R25
    01271 2F98      MOV	R25,R24
    01272 2788      CLR	R24
    01273 2982      OR	R24,R2
    01274 2993      OR	R25,R3
    01275 3080      CPI	R24,0
    01276 E0E2      LDI	R30,2
    01277 079E      CPC	R25,R30
    01278 F011      BEQ	0x127B
(2084) 		return FR_NO_FILESYSTEM;
    01279 E00D      LDI	R16,0xD
    0127A C415      RJMP	0x1690
(2085) 
(2086) 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    0127B A1ED      LDD	R30,Y+37
    0127C A1FE      LDD	R31,Y+38
    0127D 5BEC      SUBI	R30,0xBC
    0127E 4FFF      SBCI	R31,0xFF
    0127F 8020      LD	R2,Z
    01280 54E4      SUBI	R30,0x44
    01281 40F0      SBCI	R31,0
    01282 2433      CLR	R3
    01283 5BEB      SUBI	R30,0xBB
    01284 4FFF      SBCI	R31,0xFF
    01285 8040      LD	R4,Z
    01286 2455      CLR	R5
    01287 2C54      MOV	R5,R4
    01288 2444      CLR	R4
    01289 2842      OR	R4,R2
    0128A 2853      OR	R5,R3
    0128B 0112      MOVW	R2,R4
    0128C 2444      CLR	R4
    0128D 2455      CLR	R5
    0128E 822D      STD	Y+5,R2
    0128F 823E      STD	Y+6,R3
    01290 824F      STD	Y+7,R4
    01291 8658      STD	Y+8,R5
(2087) 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    01292 802D      LDD	R2,Y+5
    01293 803E      LDD	R3,Y+6
    01294 804F      LDD	R4,Y+7
    01295 8458      LDD	R5,Y+8
    01296 9488      BCLR	0
    01297 2022      TST	R2
    01298 0432      CPC	R3,R2
    01299 0442      CPC	R4,R2
    0129A 0452      CPC	R5,R2
    0129B F009      BEQ	0x129D
    0129C C03C      RJMP	0x12D9
    0129D E188      LDI	R24,0x18
    0129E E090      LDI	R25,0
    0129F A1ED      LDD	R30,Y+37
    012A0 A1FE      LDD	R31,Y+38
    012A1 5AEB      SUBI	R30,0xAB
    012A2 4FFF      SBCI	R31,0xFF
    012A3 8100      LD	R16,Z
    012A4 2711      CLR	R17
    012A5 2722      CLR	R18
    012A6 2733      CLR	R19
    012A7 938A      ST	-Y,R24
    012A8 940E 4326 CALL	lsl32
    012AA 0118      MOVW	R2,R16
    012AB 0129      MOVW	R4,R18
    012AC A1ED      LDD	R30,Y+37
    012AD A1FE      LDD	R31,Y+38
    012AE 5AEC      SUBI	R30,0xAC
    012AF 4FFF      SBCI	R31,0xFF
    012B0 8060      LD	R6,Z
    012B1 55E4      SUBI	R30,0x54
    012B2 40F0      SBCI	R31,0
    012B3 2477      CLR	R7
    012B4 2488      CLR	R8
    012B5 2499      CLR	R9
    012B6 0143      MOVW	R8,R6
    012B7 2466      CLR	R6
    012B8 2477      CLR	R7
    012B9 2826      OR	R2,R6
    012BA 2837      OR	R3,R7
    012BB 2848      OR	R4,R8
    012BC 2859      OR	R5,R9
    012BD 5AED      SUBI	R30,0xAD
    012BE 4FFF      SBCI	R31,0xFF
    012BF 8060      LD	R6,Z
    012C0 55E3      SUBI	R30,0x53
    012C1 40F0      SBCI	R31,0
    012C2 2477      CLR	R7
    012C3 2C76      MOV	R7,R6
    012C4 2466      CLR	R6
    012C5 2488      CLR	R8
    012C6 2499      CLR	R9
    012C7 2826      OR	R2,R6
    012C8 2837      OR	R3,R7
    012C9 2848      OR	R4,R8
    012CA 2859      OR	R5,R9
    012CB 5AEE      SUBI	R30,0xAE
    012CC 4FFF      SBCI	R31,0xFF
    012CD 8060      LD	R6,Z
    012CE 2477      CLR	R7
    012CF 2488      CLR	R8
    012D0 2499      CLR	R9
    012D1 2826      OR	R2,R6
    012D2 2837      OR	R3,R7
    012D3 2848      OR	R4,R8
    012D4 2859      OR	R5,R9
    012D5 822D      STD	Y+5,R2
    012D6 823E      STD	Y+6,R3
    012D7 824F      STD	Y+7,R4
    012D8 8658      STD	Y+8,R5
(2088) 	fs->fsize = fasize;
    012D9 802D      LDD	R2,Y+5
    012DA 803E      LDD	R3,Y+6
    012DB 804F      LDD	R4,Y+7
    012DC 8458      LDD	R5,Y+8
    012DD A1ED      LDD	R30,Y+37
    012DE A1FE      LDD	R31,Y+38
    012DF 8E22      STD	Z+26,R2
    012E0 8E33      STD	Z+27,R3
    012E1 8E44      STD	Z+28,R4
    012E2 8E55      STD	Z+29,R5
(2089) 
(2090) 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    012E3 ACA6      LDD	R10,Z+62
    012E4 2CEA      MOV	R14,R10
    012E5 82A3      STD	Z+3,R10
(2091) 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    012E6 2D8E      MOV	R24,R14
    012E7 3081      CPI	R24,1
    012E8 F021      BEQ	0x12ED
    012E9 3082      CPI	R24,2
    012EA F011      BEQ	0x12ED
    012EB E00D      LDI	R16,0xD
    012EC C3A3      RJMP	0x1690
(2092) 	fasize *= b;										/* Number of sectors for FAT area */
    012ED 2C2E      MOV	R2,R14
    012EE 2433      CLR	R3
    012EF 2444      CLR	R4
    012F0 2455      CLR	R5
    012F1 810D      LDD	R16,Y+5
    012F2 811E      LDD	R17,Y+6
    012F3 812F      LDD	R18,Y+7
    012F4 8538      LDD	R19,Y+8
    012F5 925A      ST	-Y,R5
    012F6 924A      ST	-Y,R4
    012F7 923A      ST	-Y,R3
    012F8 922A      ST	-Y,R2
    012F9 940E 4250 CALL	empy32u|empy32s
    012FB 830D      STD	Y+5,R16
    012FC 831E      STD	Y+6,R17
    012FD 832F      STD	Y+7,R18
    012FE 8738      STD	Y+8,R19
(2093) 
(2094) 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    012FF A1ED      LDD	R30,Y+37
    01300 A1FE      LDD	R31,Y+38
    01301 ACA3      LDD	R10,Z+59
    01302 2CEA      MOV	R14,R10
    01303 82A2      STD	Z+2,R10
(2095) 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    01304 20AA      TST	R10
    01305 F029      BEQ	0x130B
    01306 2D8E      MOV	R24,R14
    01307 5081      SUBI	R24,1
    01308 2C2E      MOV	R2,R14
    01309 2228      AND	R2,R24
    0130A F011      BEQ	0x130D
    0130B E00D      LDI	R16,0xD
    0130C C383      RJMP	0x1690
(2096) 
(2097) 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    0130D A1ED      LDD	R30,Y+37
    0130E A1FE      LDD	R31,Y+38
    0130F AC27      LDD	R2,Z+63
    01310 2433      CLR	R3
    01311 5CE0      SUBI	R30,0xC0
    01312 4FFF      SBCI	R31,0xFF
    01313 8040      LD	R4,Z
    01314 54E0      SUBI	R30,0x40
    01315 40F0      SBCI	R31,0
    01316 2455      CLR	R5
    01317 2C54      MOV	R5,R4
    01318 2444      CLR	R4
    01319 2842      OR	R4,R2
    0131A 2853      OR	R5,R3
    0131B 8651      STD	Z+9,R5
    0131C 8640      STD	Z+8,R4
(2098) 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    0131D 8580      LDD	R24,Z+8
    0131E 8591      LDD	R25,Z+9
    0131F 708F      ANDI	R24,0xF
    01320 7090      ANDI	R25,0
    01321 3080      CPI	R24,0
    01322 0789      CPC	R24,R25
    01323 F011      BEQ	0x1326
    01324 E00D      LDI	R16,0xD
    01325 C36A      RJMP	0x1690
(2099) 
(2100) 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    01326 A1ED      LDD	R30,Y+37
    01327 A1FE      LDD	R31,Y+38
    01328 5BEF      SUBI	R30,0xBF
    01329 4FFF      SBCI	R31,0xFF
    0132A 8020      LD	R2,Z
    0132B 54E1      SUBI	R30,0x41
    0132C 40F0      SBCI	R31,0
    0132D 2433      CLR	R3
    0132E 5BEE      SUBI	R30,0xBE
    0132F 4FFF      SBCI	R31,0xFF
    01330 8040      LD	R4,Z
    01331 2455      CLR	R5
    01332 2C54      MOV	R5,R4
    01333 2444      CLR	R4
    01334 2842      OR	R4,R2
    01335 2853      OR	R5,R3
    01336 0112      MOVW	R2,R4
    01337 2444      CLR	R4
    01338 2455      CLR	R5
    01339 862D      STD	Y+13,R2
    0133A 863E      STD	Y+14,R3
    0133B 864F      STD	Y+15,R4
    0133C 8A58      STD	Y+16,R5
(2101) 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    0133D 842D      LDD	R2,Y+13
    0133E 843E      LDD	R3,Y+14
    0133F 844F      LDD	R4,Y+15
    01340 8858      LDD	R5,Y+16
    01341 9488      BCLR	0
    01342 2022      TST	R2
    01343 0432      CPC	R3,R2
    01344 0442      CPC	R4,R2
    01345 0452      CPC	R5,R2
    01346 F009      BEQ	0x1348
    01347 C03C      RJMP	0x1384
    01348 E188      LDI	R24,0x18
    01349 E090      LDI	R25,0
    0134A A1ED      LDD	R30,Y+37
    0134B A1FE      LDD	R31,Y+38
    0134C 5AEF      SUBI	R30,0xAF
    0134D 4FFF      SBCI	R31,0xFF
    0134E 8100      LD	R16,Z
    0134F 2711      CLR	R17
    01350 2722      CLR	R18
    01351 2733      CLR	R19
    01352 938A      ST	-Y,R24
    01353 940E 4326 CALL	lsl32
    01355 0118      MOVW	R2,R16
    01356 0129      MOVW	R4,R18
    01357 A1ED      LDD	R30,Y+37
    01358 A1FE      LDD	R31,Y+38
    01359 5BE0      SUBI	R30,0xB0
    0135A 4FFF      SBCI	R31,0xFF
    0135B 8060      LD	R6,Z
    0135C 55E0      SUBI	R30,0x50
    0135D 40F0      SBCI	R31,0
    0135E 2477      CLR	R7
    0135F 2488      CLR	R8
    01360 2499      CLR	R9
    01361 0143      MOVW	R8,R6
    01362 2466      CLR	R6
    01363 2477      CLR	R7
    01364 2826      OR	R2,R6
    01365 2837      OR	R3,R7
    01366 2848      OR	R4,R8
    01367 2859      OR	R5,R9
    01368 5BE1      SUBI	R30,0xB1
    01369 4FFF      SBCI	R31,0xFF
    0136A 8060      LD	R6,Z
    0136B 54EF      SUBI	R30,0x4F
    0136C 40F0      SBCI	R31,0
    0136D 2477      CLR	R7
    0136E 2C76      MOV	R7,R6
    0136F 2466      CLR	R6
    01370 2488      CLR	R8
    01371 2499      CLR	R9
    01372 2826      OR	R2,R6
    01373 2837      OR	R3,R7
    01374 2848      OR	R4,R8
    01375 2859      OR	R5,R9
    01376 5BE2      SUBI	R30,0xB2
    01377 4FFF      SBCI	R31,0xFF
    01378 8060      LD	R6,Z
    01379 2477      CLR	R7
    0137A 2488      CLR	R8
    0137B 2499      CLR	R9
    0137C 2826      OR	R2,R6
    0137D 2837      OR	R3,R7
    0137E 2848      OR	R4,R8
    0137F 2859      OR	R5,R9
    01380 862D      STD	Y+13,R2
    01381 863E      STD	Y+14,R3
    01382 864F      STD	Y+15,R4
    01383 8A58      STD	Y+16,R5
(2102) 
(2103) 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    01384 A1ED      LDD	R30,Y+37
    01385 A1FE      LDD	R31,Y+38
    01386 AC24      LDD	R2,Z+60
    01387 2433      CLR	R3
    01388 ACE5      LDD	R14,Z+61
    01389 24FF      CLR	R15
    0138A 2CFE      MOV	R15,R14
    0138B 24EE      CLR	R14
    0138C 28E2      OR	R14,R2
    0138D 28F3      OR	R15,R3
(2104) 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    0138E 20EE      TST	R14
    0138F F421      BNE	0x1394
    01390 20FF      TST	R15
    01391 F411      BNE	0x1394
    01392 E00D      LDI	R16,0xD
    01393 C2FC      RJMP	0x1690
(2105) 
(2106) 	/* Determine the FAT sub type */
(2107) 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    01394 802D      LDD	R2,Y+5
    01395 803E      LDD	R3,Y+6
    01396 804F      LDD	R4,Y+7
    01397 8458      LDD	R5,Y+8
    01398 0137      MOVW	R6,R14
    01399 2488      CLR	R8
    0139A 2499      CLR	R9
    0139B 0C62      ADD	R6,R2
    0139C 1C73      ADC	R7,R3
    0139D 1C84      ADC	R8,R4
    0139E 1C95      ADC	R9,R5
    0139F A1ED      LDD	R30,Y+37
    013A0 A1FE      LDD	R31,Y+38
    013A1 9638      ADIW	R30,0x8
    013A2 8020      LD	R2,Z
    013A3 8031      LDD	R3,Z+1
    013A4 9436      LSR	R3
    013A5 9427      ROR	R2
    013A6 9436      LSR	R3
    013A7 9427      ROR	R2
    013A8 9436      LSR	R3
    013A9 9427      ROR	R2
    013AA 9436      LSR	R3
    013AB 9427      ROR	R2
    013AC 2444      CLR	R4
    013AD 2455      CLR	R5
    013AE 0C62      ADD	R6,R2
    013AF 1C73      ADC	R7,R3
    013B0 1C84      ADC	R8,R4
    013B1 1C95      ADC	R9,R5
    013B2 8A6D      STD	Y+21,R6
    013B3 8A7E      STD	Y+22,R7
    013B4 8A8F      STD	Y+23,R8
    013B5 8E98      STD	Y+24,R9
(2108) 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    013B6 882D      LDD	R2,Y+21
    013B7 883E      LDD	R3,Y+22
    013B8 884F      LDD	R4,Y+23
    013B9 8C58      LDD	R5,Y+24
    013BA 846D      LDD	R6,Y+13
    013BB 847E      LDD	R7,Y+14
    013BC 848F      LDD	R8,Y+15
    013BD 8898      LDD	R9,Y+16
    013BE 1462      CP	R6,R2
    013BF 0473      CPC	R7,R3
    013C0 0484      CPC	R8,R4
    013C1 0495      CPC	R9,R5
    013C2 F410      BCC	0x13C5
    013C3 E00D      LDI	R16,0xD
    013C4 C2CB      RJMP	0x1690
(2109) 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    013C5 882D      LDD	R2,Y+21
    013C6 883E      LDD	R3,Y+22
    013C7 884F      LDD	R4,Y+23
    013C8 8C58      LDD	R5,Y+24
    013C9 850D      LDD	R16,Y+13
    013CA 851E      LDD	R17,Y+14
    013CB 852F      LDD	R18,Y+15
    013CC 8938      LDD	R19,Y+16
    013CD 1902      SUB	R16,R2
    013CE 0913      SBC	R17,R3
    013CF 0924      SBC	R18,R4
    013D0 0935      SBC	R19,R5
    013D1 A1ED      LDD	R30,Y+37
    013D2 A1FE      LDD	R31,Y+38
    013D3 9632      ADIW	R30,2
    013D4 8020      LD	R2,Z
    013D5 2433      CLR	R3
    013D6 2444      CLR	R4
    013D7 2455      CLR	R5
    013D8 925A      ST	-Y,R5
    013D9 924A      ST	-Y,R4
    013DA 923A      ST	-Y,R3
    013DB 922A      ST	-Y,R2
    013DC 940E 41AA CALL	div32u
    013DE 8709      STD	Y+9,R16
    013DF 871A      STD	Y+10,R17
    013E0 872B      STD	Y+11,R18
    013E1 873C      STD	Y+12,R19
(2110) 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    013E2 8429      LDD	R2,Y+9
    013E3 843A      LDD	R3,Y+10
    013E4 844B      LDD	R4,Y+11
    013E5 845C      LDD	R5,Y+12
    013E6 9488      BCLR	0
    013E7 2022      TST	R2
    013E8 0432      CPC	R3,R2
    013E9 0442      CPC	R4,R2
    013EA 0452      CPC	R5,R2
    013EB F411      BNE	0x13EE
    013EC E00D      LDI	R16,0xD
    013ED C2A2      RJMP	0x1690
(2111) 	fmt = FS_FAT12;
    013EE 24CC      CLR	R12
    013EF 94C3      INC	R12
(2112) 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    013F0 EF46      LDI	R20,0xF6
    013F1 E05F      LDI	R21,0xF
    013F2 E060      LDI	R22,0
    013F3 E070      LDI	R23,0
    013F4 8429      LDD	R2,Y+9
    013F5 843A      LDD	R3,Y+10
    013F6 844B      LDD	R4,Y+11
    013F7 845C      LDD	R5,Y+12
    013F8 1624      CP	R2,R20
    013F9 0635      CPC	R3,R21
    013FA 0646      CPC	R4,R22
    013FB 0657      CPC	R5,R23
    013FC F010      BCS	0x13FF
    013FD E082      LDI	R24,2
    013FE 2EC8      MOV	R12,R24
(2113) 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    013FF EF46      LDI	R20,0xF6
    01400 EF5F      LDI	R21,0xFF
    01401 E060      LDI	R22,0
    01402 E070      LDI	R23,0
    01403 8429      LDD	R2,Y+9
    01404 843A      LDD	R3,Y+10
    01405 844B      LDD	R4,Y+11
    01406 845C      LDD	R5,Y+12
    01407 1624      CP	R2,R20
    01408 0635      CPC	R3,R21
    01409 0646      CPC	R4,R22
    0140A 0657      CPC	R5,R23
    0140B F010      BCS	0x140E
    0140C E083      LDI	R24,3
    0140D 2EC8      MOV	R12,R24
(2114) 
(2115) 	/* Boundaries and Limits */
(2116) 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    0140E E042      LDI	R20,2
    0140F E050      LDI	R21,0
    01410 E060      LDI	R22,0
    01411 E070      LDI	R23,0
    01412 8429      LDD	R2,Y+9
    01413 843A      LDD	R3,Y+10
    01414 844B      LDD	R4,Y+11
    01415 845C      LDD	R5,Y+12
    01416 0E24      ADD	R2,R20
    01417 1E35      ADC	R3,R21
    01418 1E46      ADC	R4,R22
    01419 1E57      ADC	R5,R23
    0141A A1ED      LDD	R30,Y+37
    0141B A1FE      LDD	R31,Y+38
    0141C 9676      ADIW	R30,0x16
    0141D 8220      ST	Z,R2
    0141E 8231      STD	Z+1,R3
    0141F 8242      STD	Z+2,R4
    01420 8253      STD	Z+3,R5
(2117) 	fs->database = bsect + sysect;						/* Data start sector */
    01421 882D      LDD	R2,Y+21
    01422 883E      LDD	R3,Y+22
    01423 884F      LDD	R4,Y+23
    01424 8C58      LDD	R5,Y+24
    01425 8869      LDD	R6,Y+17
    01426 887A      LDD	R7,Y+18
    01427 888B      LDD	R8,Y+19
    01428 889C      LDD	R9,Y+20
    01429 0C62      ADD	R6,R2
    0142A 1C73      ADC	R7,R3
    0142B 1C84      ADC	R8,R4
    0142C 1C95      ADC	R9,R5
    0142D A1ED      LDD	R30,Y+37
    0142E A1FE      LDD	R31,Y+38
    0142F 96B6      ADIW	R30,0x26
    01430 8260      ST	Z,R6
    01431 8271      STD	Z+1,R7
    01432 8282      STD	Z+2,R8
    01433 8293      STD	Z+3,R9
(2118) 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    01434 0117      MOVW	R2,R14
    01435 2444      CLR	R4
    01436 2455      CLR	R5
    01437 8869      LDD	R6,Y+17
    01438 887A      LDD	R7,Y+18
    01439 888B      LDD	R8,Y+19
    0143A 889C      LDD	R9,Y+20
    0143B 0C62      ADD	R6,R2
    0143C 1C73      ADC	R7,R3
    0143D 1C84      ADC	R8,R4
    0143E 1C95      ADC	R9,R5
    0143F A1ED      LDD	R30,Y+37
    01440 A1FE      LDD	R31,Y+38
    01441 8E66      STD	Z+30,R6
    01442 8E77      STD	Z+31,R7
    01443 A280      STD	Z+32,R8
    01444 A291      STD	Z+33,R9
(2119) 	if (fmt == FS_FAT32) {
    01445 2D8C      MOV	R24,R12
    01446 3083      CPI	R24,3
    01447 F009      BEQ	0x1449
    01448 C055      RJMP	0x149E
(2120) 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    01449 8420      LDD	R2,Z+8
    0144A 8431      LDD	R3,Z+9
    0144B 2022      TST	R2
    0144C F411      BNE	0x144F
    0144D 2033      TST	R3
    0144E F011      BEQ	0x1451
    0144F E00D      LDI	R16,0xD
    01450 C23F      RJMP	0x1690
(2121) 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    01451 E188      LDI	R24,0x18
    01452 E090      LDI	R25,0
    01453 A1ED      LDD	R30,Y+37
    01454 A1FE      LDD	R31,Y+38
    01455 5AE3      SUBI	R30,0xA3
    01456 4FFF      SBCI	R31,0xFF
    01457 8100      LD	R16,Z
    01458 2711      CLR	R17
    01459 2722      CLR	R18
    0145A 2733      CLR	R19
    0145B 938A      ST	-Y,R24
    0145C 940E 4326 CALL	lsl32
    0145E 0118      MOVW	R2,R16
    0145F 0129      MOVW	R4,R18
    01460 A1ED      LDD	R30,Y+37
    01461 A1FE      LDD	R31,Y+38
    01462 5AE4      SUBI	R30,0xA4
    01463 4FFF      SBCI	R31,0xFF
    01464 8060      LD	R6,Z
    01465 55EC      SUBI	R30,0x5C
    01466 40F0      SBCI	R31,0
    01467 2477      CLR	R7
    01468 2488      CLR	R8
    01469 2499      CLR	R9
    0146A 0143      MOVW	R8,R6
    0146B 2466      CLR	R6
    0146C 2477      CLR	R7
    0146D 2826      OR	R2,R6
    0146E 2837      OR	R3,R7
    0146F 2848      OR	R4,R8
    01470 2859      OR	R5,R9
    01471 5AE5      SUBI	R30,0xA5
    01472 4FFF      SBCI	R31,0xFF
    01473 8060      LD	R6,Z
    01474 55EB      SUBI	R30,0x5B
    01475 40F0      SBCI	R31,0
    01476 2477      CLR	R7
    01477 2C76      MOV	R7,R6
    01478 2466      CLR	R6
    01479 2488      CLR	R8
    0147A 2499      CLR	R9
    0147B 2826      OR	R2,R6
    0147C 2837      OR	R3,R7
    0147D 2848      OR	R4,R8
    0147E 2859      OR	R5,R9
    0147F 5AE6      SUBI	R30,0xA6
    01480 4FFF      SBCI	R31,0xFF
    01481 8060      LD	R6,Z
    01482 55EA      SUBI	R30,0x5A
    01483 40F0      SBCI	R31,0
    01484 2477      CLR	R7
    01485 2488      CLR	R8
    01486 2499      CLR	R9
    01487 2826      OR	R2,R6
    01488 2837      OR	R3,R7
    01489 2848      OR	R4,R8
    0148A 2859      OR	R5,R9
    0148B A222      STD	Z+34,R2
    0148C A233      STD	Z+35,R3
    0148D A244      STD	Z+36,R4
    0148E A255      STD	Z+37,R5
(2122) 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    0148F E082      LDI	R24,2
    01490 E090      LDI	R25,0
    01491 9676      ADIW	R30,0x16
    01492 8100      LD	R16,Z
    01493 8111      LDD	R17,Z+1
    01494 8122      LDD	R18,Z+2
    01495 8133      LDD	R19,Z+3
    01496 938A      ST	-Y,R24
    01497 940E 4326 CALL	lsl32
    01499 8F09      STD	Y+25,R16
    0149A 8F1A      STD	Y+26,R17
    0149B 8F2B      STD	Y+27,R18
    0149C 8F3C      STD	Y+28,R19
(2123) 	} else {
    0149D C06A      RJMP	0x1508
(2124) 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    0149E A1ED      LDD	R30,Y+37
    0149F A1FE      LDD	R31,Y+38
    014A0 8420      LDD	R2,Z+8
    014A1 8431      LDD	R3,Z+9
    014A2 2022      TST	R2
    014A3 F421      BNE	0x14A8
    014A4 2033      TST	R3
    014A5 F411      BNE	0x14A8
    014A6 E00D      LDI	R16,0xD
    014A7 C1E8      RJMP	0x1690
(2125) 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    014A8 802D      LDD	R2,Y+5
    014A9 803E      LDD	R3,Y+6
    014AA 804F      LDD	R4,Y+7
    014AB 8458      LDD	R5,Y+8
    014AC A1ED      LDD	R30,Y+37
    014AD A1FE      LDD	R31,Y+38
    014AE 8C66      LDD	R6,Z+30
    014AF 8C77      LDD	R7,Z+31
    014B0 A080      LDD	R8,Z+32
    014B1 A091      LDD	R9,Z+33
    014B2 0C62      ADD	R6,R2
    014B3 1C73      ADC	R7,R3
    014B4 1C84      ADC	R8,R4
    014B5 1C95      ADC	R9,R5
    014B6 A262      STD	Z+34,R6
    014B7 A273      STD	Z+35,R7
    014B8 A284      STD	Z+36,R8
    014B9 A295      STD	Z+37,R9
(2126) 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    014BA 2D8C      MOV	R24,R12
    014BB 3082      CPI	R24,2
    014BC F471      BNE	0x14CB
    014BD 9676      ADIW	R30,0x16
    014BE 8020      LD	R2,Z
    014BF 8031      LDD	R3,Z+1
    014C0 8042      LDD	R4,Z+2
    014C1 8053      LDD	R5,Z+3
    014C2 0C22      LSL	R2
    014C3 1C33      ROL	R3
    014C4 1C44      ROL	R4
    014C5 1C55      ROL	R5
    014C6 8E2D      STD	Y+29,R2
    014C7 8E3E      STD	Y+30,R3
    014C8 8E4F      STD	Y+31,R4
    014C9 A258      STD	Y+32,R5
    014CA C035      RJMP	0x1500
    014CB A1ED      LDD	R30,Y+37
    014CC A1FE      LDD	R31,Y+38
    014CD 9676      ADIW	R30,0x16
    014CE 8020      LD	R2,Z
    014CF 8031      LDD	R3,Z+1
    014D0 8042      LDD	R4,Z+2
    014D1 8053      LDD	R5,Z+3
    014D2 A229      STD	Y+33,R2
    014D3 A23A      STD	Y+34,R3
    014D4 A24B      STD	Y+35,R4
    014D5 A25C      STD	Y+36,R5
    014D6 E041      LDI	R20,1
    014D7 E050      LDI	R21,0
    014D8 E060      LDI	R22,0
    014D9 E070      LDI	R23,0
    014DA A029      LDD	R2,Y+33
    014DB A03A      LDD	R3,Y+34
    014DC A04B      LDD	R4,Y+35
    014DD A05C      LDD	R5,Y+36
    014DE 2224      AND	R2,R20
    014DF 2235      AND	R3,R21
    014E0 2246      AND	R4,R22
    014E1 2257      AND	R5,R23
    014E2 A069      LDD	R6,Y+33
    014E3 A07A      LDD	R7,Y+34
    014E4 A08B      LDD	R8,Y+35
    014E5 A09C      LDD	R9,Y+36
    014E6 E043      LDI	R20,3
    014E7 E050      LDI	R21,0
    014E8 E060      LDI	R22,0
    014E9 E070      LDI	R23,0
    014EA 929A      ST	-Y,R9
    014EB 928A      ST	-Y,R8
    014EC 927A      ST	-Y,R7
    014ED 926A      ST	-Y,R6
    014EE 018A      MOVW	R16,R20
    014EF 019B      MOVW	R18,R22
    014F0 940E 4250 CALL	empy32u|empy32s
    014F2 0138      MOVW	R6,R16
    014F3 0149      MOVW	R8,R18
    014F4 9496      LSR	R9
    014F5 9487      ROR	R8
    014F6 9477      ROR	R7
    014F7 9467      ROR	R6
    014F8 0C62      ADD	R6,R2
    014F9 1C73      ADC	R7,R3
    014FA 1C84      ADC	R8,R4
    014FB 1C95      ADC	R9,R5
    014FC 8E6D      STD	Y+29,R6
    014FD 8E7E      STD	Y+30,R7
    014FE 8E8F      STD	Y+31,R8
    014FF A298      STD	Y+32,R9
    01500 8C2D      LDD	R2,Y+29
    01501 8C3E      LDD	R3,Y+30
    01502 8C4F      LDD	R4,Y+31
    01503 A058      LDD	R5,Y+32
    01504 8E29      STD	Y+25,R2
    01505 8E3A      STD	Y+26,R3
    01506 8E4B      STD	Y+27,R4
    01507 8E5C      STD	Y+28,R5
(2127) 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
(2128) 	}
(2129) 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    01508 EF4F      LDI	R20,0xFF
    01509 E051      LDI	R21,1
    0150A E060      LDI	R22,0
    0150B E070      LDI	R23,0
    0150C 8D09      LDD	R16,Y+25
    0150D 8D1A      LDD	R17,Y+26
    0150E 8D2B      LDD	R18,Y+27
    0150F 8D3C      LDD	R19,Y+28
    01510 0F04      ADD	R16,R20
    01511 1F15      ADC	R17,R21
    01512 1F26      ADC	R18,R22
    01513 1F37      ADC	R19,R23
    01514 E089      LDI	R24,0x9
    01515 E090      LDI	R25,0
    01516 938A      ST	-Y,R24
    01517 940E 433F CALL	lsr32
    01519 A1ED      LDD	R30,Y+37
    0151A A1FE      LDD	R31,Y+38
    0151B 8C22      LDD	R2,Z+26
    0151C 8C33      LDD	R3,Z+27
    0151D 8C44      LDD	R4,Z+28
    0151E 8C55      LDD	R5,Z+29
    0151F 1620      CP	R2,R16
    01520 0631      CPC	R3,R17
    01521 0642      CPC	R4,R18
    01522 0653      CPC	R5,R19
    01523 F410      BCC	0x1526
(2130) 		return FR_NO_FILESYSTEM;
    01524 E00D      LDI	R16,0xD
    01525 C16A      RJMP	0x1690
(2131) 
(2132) #if !_FS_READONLY
(2133) 	/* Initialize cluster allocation information */
(2134) 	fs->free_clust = 0xFFFFFFFF;
    01526 A1ED      LDD	R30,Y+37
    01527 A1FE      LDD	R31,Y+38
    01528 963E      ADIW	R30,0xE
    01529 EF8F      LDI	R24,0xFF
    0152A 8380      ST	Z,R24
    0152B 8381      STD	Z+1,R24
    0152C 8382      STD	Z+2,R24
    0152D 8383      STD	Z+3,R24
(2135) 	fs->last_clust = 0;
    0152E A1ED      LDD	R30,Y+37
    0152F A1FE      LDD	R31,Y+38
    01530 963A      ADIW	R30,0xA
    01531 E080      LDI	R24,0
    01532 8380      ST	Z,R24
    01533 8381      STD	Z+1,R24
    01534 8382      STD	Z+2,R24
    01535 8383      STD	Z+3,R24
(2136) 
(2137) 	/* Get fsinfo if available */
(2138) 	if (fmt == FS_FAT32) {
    01536 2D8C      MOV	R24,R12
    01537 3083      CPI	R24,3
    01538 F009      BEQ	0x153A
    01539 C13C      RJMP	0x1676
(2139) 	 	fs->fsi_flag = 0;
    0153A 2422      CLR	R2
    0153B A1ED      LDD	R30,Y+37
    0153C A1FE      LDD	R31,Y+38
    0153D 8225      STD	Z+5,R2
(2140) 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    0153E 5AE2      SUBI	R30,0xA2
    0153F 4FFF      SBCI	R31,0xFF
    01540 8020      LD	R2,Z
    01541 55EE      SUBI	R30,0x5E
    01542 40F0      SBCI	R31,0
    01543 2433      CLR	R3
    01544 5AE1      SUBI	R30,0xA1
    01545 4FFF      SBCI	R31,0xFF
    01546 8040      LD	R4,Z
    01547 2455      CLR	R5
    01548 2C54      MOV	R5,R4
    01549 2444      CLR	R4
    0154A 2842      OR	R4,R2
    0154B 2853      OR	R5,R3
    0154C 0112      MOVW	R2,R4
    0154D 2444      CLR	R4
    0154E 2455      CLR	R5
    0154F 8869      LDD	R6,Y+17
    01550 887A      LDD	R7,Y+18
    01551 888B      LDD	R8,Y+19
    01552 889C      LDD	R9,Y+20
    01553 0C62      ADD	R6,R2
    01554 1C73      ADC	R7,R3
    01555 1C84      ADC	R8,R4
    01556 1C95      ADC	R9,R5
    01557 A1ED      LDD	R30,Y+37
    01558 A1FE      LDD	R31,Y+38
    01559 8A62      STD	Z+18,R6
    0155A 8A73      STD	Z+19,R7
    0155B 8A84      STD	Z+20,R8
    0155C 8A95      STD	Z+21,R9
(2141) 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    0155D E081      LDI	R24,1
    0155E 838C      STD	Y+4,R24
    0155F 8822      LDD	R2,Z+18
    01560 8833      LDD	R3,Z+19
    01561 8844      LDD	R4,Z+20
    01562 8855      LDD	R5,Z+21
    01563 8228      ST	Y,R2
    01564 8239      STD	Y+1,R3
    01565 824A      STD	Y+2,R4
    01566 825B      STD	Y+3,R5
    01567 019F      MOVW	R18,R30
    01568 5D22      SUBI	R18,0xD2
    01569 4F3F      SBCI	R19,0xFF
    0156A 8101      LDD	R16,Z+1
    0156B 940E 02E2 CALL	_disk_read
    0156D 2EE0      MOV	R14,R16
    0156E 2300      TST	R16
    0156F F009      BEQ	0x1571
    01570 C105      RJMP	0x1676
    01571 A1ED      LDD	R30,Y+37
    01572 A1FE      LDD	R31,Y+38
    01573 5DE4      SUBI	R30,0xD4
    01574 4FFD      SBCI	R31,0xFD
    01575 8020      LD	R2,Z
    01576 52EC      SUBI	R30,0x2C
    01577 40F2      SBCI	R31,2
    01578 2433      CLR	R3
    01579 5DE3      SUBI	R30,0xD3
    0157A 4FFD      SBCI	R31,0xFD
    0157B 8180      LD	R24,Z
    0157C 52ED      SUBI	R30,0x2D
    0157D 40F2      SBCI	R31,2
    0157E 2799      CLR	R25
    0157F 2F98      MOV	R25,R24
    01580 2788      CLR	R24
    01581 2982      OR	R24,R2
    01582 2993      OR	R25,R3
    01583 3585      CPI	R24,0x55
    01584 EAAA      LDI	R26,0xAA
    01585 079A      CPC	R25,R26
    01586 F009      BEQ	0x1588
    01587 C0EE      RJMP	0x1676
    01588 E188      LDI	R24,0x18
    01589 E090      LDI	R25,0
    0158A A901      LDD	R16,Z+49
    0158B 2711      CLR	R17
    0158C 2722      CLR	R18
    0158D 2733      CLR	R19
    0158E 938A      ST	-Y,R24
    0158F 940E 4326 CALL	lsl32
    01591 0118      MOVW	R2,R16
    01592 0129      MOVW	R4,R18
    01593 A1ED      LDD	R30,Y+37
    01594 A1FE      LDD	R31,Y+38
    01595 A860      LDD	R6,Z+48
    01596 2477      CLR	R7
    01597 2488      CLR	R8
    01598 2499      CLR	R9
    01599 0143      MOVW	R8,R6
    0159A 2466      CLR	R6
    0159B 2477      CLR	R7
    0159C 2826      OR	R2,R6
    0159D 2837      OR	R3,R7
    0159E 2848      OR	R4,R8
    0159F 2859      OR	R5,R9
    015A0 A467      LDD	R6,Z+47
    015A1 2477      CLR	R7
    015A2 2C76      MOV	R7,R6
    015A3 2466      CLR	R6
    015A4 2488      CLR	R8
    015A5 2499      CLR	R9
    015A6 2826      OR	R2,R6
    015A7 2837      OR	R3,R7
    015A8 2848      OR	R4,R8
    015A9 2859      OR	R5,R9
    015AA A466      LDD	R6,Z+46
    015AB 2477      CLR	R7
    015AC 2488      CLR	R8
    015AD 2499      CLR	R9
    015AE 2826      OR	R2,R6
    015AF 2837      OR	R3,R7
    015B0 2848      OR	R4,R8
    015B1 2859      OR	R5,R9
    015B2 E542      LDI	R20,0x52
    015B3 E552      LDI	R21,0x52
    015B4 E661      LDI	R22,0x61
    015B5 E471      LDI	R23,0x41
    015B6 1624      CP	R2,R20
    015B7 0635      CPC	R3,R21
    015B8 0646      CPC	R4,R22
    015B9 0657      CPC	R5,R23
    015BA F009      BEQ	0x15BC
    015BB C0BA      RJMP	0x1676
    015BC E188      LDI	R24,0x18
    015BD E090      LDI	R25,0
    015BE 5EEB      SUBI	R30,0xEB
    015BF 4FFD      SBCI	R31,0xFD
    015C0 8100      LD	R16,Z
    015C1 2711      CLR	R17
    015C2 2722      CLR	R18
    015C3 2733      CLR	R19
    015C4 938A      ST	-Y,R24
    015C5 940E 4326 CALL	lsl32
    015C7 0118      MOVW	R2,R16
    015C8 0129      MOVW	R4,R18
    015C9 A1ED      LDD	R30,Y+37
    015CA A1FE      LDD	R31,Y+38
    015CB 5EEC      SUBI	R30,0xEC
    015CC 4FFD      SBCI	R31,0xFD
    015CD 8060      LD	R6,Z
    015CE 51E4      SUBI	R30,0x14
    015CF 40F2      SBCI	R31,2
    015D0 2477      CLR	R7
    015D1 2488      CLR	R8
    015D2 2499      CLR	R9
    015D3 0143      MOVW	R8,R6
    015D4 2466      CLR	R6
    015D5 2477      CLR	R7
    015D6 2826      OR	R2,R6
    015D7 2837      OR	R3,R7
    015D8 2848      OR	R4,R8
    015D9 2859      OR	R5,R9
    015DA 5EED      SUBI	R30,0xED
    015DB 4FFD      SBCI	R31,0xFD
    015DC 8060      LD	R6,Z
    015DD 51E3      SUBI	R30,0x13
    015DE 40F2      SBCI	R31,2
    015DF 2477      CLR	R7
    015E0 2C76      MOV	R7,R6
    015E1 2466      CLR	R6
    015E2 2488      CLR	R8
    015E3 2499      CLR	R9
    015E4 2826      OR	R2,R6
    015E5 2837      OR	R3,R7
    015E6 2848      OR	R4,R8
    015E7 2859      OR	R5,R9
    015E8 5EEE      SUBI	R30,0xEE
    015E9 4FFD      SBCI	R31,0xFD
    015EA 8060      LD	R6,Z
    015EB 51E2      SUBI	R30,0x12
    015EC 40F2      SBCI	R31,2
    015ED 2477      CLR	R7
    015EE 2488      CLR	R8
    015EF 2499      CLR	R9
    015F0 2826      OR	R2,R6
    015F1 2837      OR	R3,R7
    015F2 2848      OR	R4,R8
    015F3 2859      OR	R5,R9
    015F4 E742      LDI	R20,0x72
    015F5 E752      LDI	R21,0x72
    015F6 E461      LDI	R22,0x41
    015F7 E671      LDI	R23,0x61
    015F8 1624      CP	R2,R20
    015F9 0635      CPC	R3,R21
    015FA 0646      CPC	R4,R22
    015FB 0657      CPC	R5,R23
    015FC F009      BEQ	0x15FE
    015FD C078      RJMP	0x1676
(2142) 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
(2143) 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
(2144) 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
(2145) 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    015FE E188      LDI	R24,0x18
    015FF E090      LDI	R25,0
    01600 5EE3      SUBI	R30,0xE3
    01601 4FFD      SBCI	R31,0xFD
    01602 8100      LD	R16,Z
    01603 2711      CLR	R17
    01604 2722      CLR	R18
    01605 2733      CLR	R19
    01606 938A      ST	-Y,R24
    01607 940E 4326 CALL	lsl32
    01609 0118      MOVW	R2,R16
    0160A 0129      MOVW	R4,R18
    0160B A1ED      LDD	R30,Y+37
    0160C A1FE      LDD	R31,Y+38
    0160D 5EE4      SUBI	R30,0xE4
    0160E 4FFD      SBCI	R31,0xFD
    0160F 8060      LD	R6,Z
    01610 51EC      SUBI	R30,0x1C
    01611 40F2      SBCI	R31,2
    01612 2477      CLR	R7
    01613 2488      CLR	R8
    01614 2499      CLR	R9
    01615 0143      MOVW	R8,R6
    01616 2466      CLR	R6
    01617 2477      CLR	R7
    01618 2826      OR	R2,R6
    01619 2837      OR	R3,R7
    0161A 2848      OR	R4,R8
    0161B 2859      OR	R5,R9
    0161C 5EE5      SUBI	R30,0xE5
    0161D 4FFD      SBCI	R31,0xFD
    0161E 8060      LD	R6,Z
    0161F 51EB      SUBI	R30,0x1B
    01620 40F2      SBCI	R31,2
    01621 2477      CLR	R7
    01622 2C76      MOV	R7,R6
    01623 2466      CLR	R6
    01624 2488      CLR	R8
    01625 2499      CLR	R9
    01626 2826      OR	R2,R6
    01627 2837      OR	R3,R7
    01628 2848      OR	R4,R8
    01629 2859      OR	R5,R9
    0162A 5EE6      SUBI	R30,0xE6
    0162B 4FFD      SBCI	R31,0xFD
    0162C 8060      LD	R6,Z
    0162D 51EA      SUBI	R30,0x1A
    0162E 40F2      SBCI	R31,2
    0162F 2477      CLR	R7
    01630 2488      CLR	R8
    01631 2499      CLR	R9
    01632 2826      OR	R2,R6
    01633 2837      OR	R3,R7
    01634 2848      OR	R4,R8
    01635 2859      OR	R5,R9
    01636 8622      STD	Z+10,R2
    01637 8633      STD	Z+11,R3
    01638 8644      STD	Z+12,R4
    01639 8655      STD	Z+13,R5
(2146) 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    0163A E188      LDI	R24,0x18
    0163B E090      LDI	R25,0
    0163C 5EE7      SUBI	R30,0xE7
    0163D 4FFD      SBCI	R31,0xFD
    0163E 8100      LD	R16,Z
    0163F 2711      CLR	R17
    01640 2722      CLR	R18
    01641 2733      CLR	R19
    01642 938A      ST	-Y,R24
    01643 940E 4326 CALL	lsl32
    01645 0118      MOVW	R2,R16
    01646 0129      MOVW	R4,R18
    01647 A1ED      LDD	R30,Y+37
    01648 A1FE      LDD	R31,Y+38
    01649 5EE8      SUBI	R30,0xE8
    0164A 4FFD      SBCI	R31,0xFD
    0164B 8060      LD	R6,Z
    0164C 51E8      SUBI	R30,0x18
    0164D 40F2      SBCI	R31,2
    0164E 2477      CLR	R7
    0164F 2488      CLR	R8
    01650 2499      CLR	R9
    01651 0143      MOVW	R8,R6
    01652 2466      CLR	R6
    01653 2477      CLR	R7
    01654 2826      OR	R2,R6
    01655 2837      OR	R3,R7
    01656 2848      OR	R4,R8
    01657 2859      OR	R5,R9
    01658 5EE9      SUBI	R30,0xE9
    01659 4FFD      SBCI	R31,0xFD
    0165A 8060      LD	R6,Z
    0165B 51E7      SUBI	R30,0x17
    0165C 40F2      SBCI	R31,2
    0165D 2477      CLR	R7
    0165E 2C76      MOV	R7,R6
    0165F 2466      CLR	R6
    01660 2488      CLR	R8
    01661 2499      CLR	R9
    01662 2826      OR	R2,R6
    01663 2837      OR	R3,R7
    01664 2848      OR	R4,R8
    01665 2859      OR	R5,R9
    01666 5EEA      SUBI	R30,0xEA
    01667 4FFD      SBCI	R31,0xFD
    01668 8060      LD	R6,Z
    01669 51E6      SUBI	R30,0x16
    0166A 40F2      SBCI	R31,2
    0166B 2477      CLR	R7
    0166C 2488      CLR	R8
    0166D 2499      CLR	R9
    0166E 2826      OR	R2,R6
    0166F 2837      OR	R3,R7
    01670 2848      OR	R4,R8
    01671 2859      OR	R5,R9
    01672 8626      STD	Z+14,R2
    01673 8637      STD	Z+15,R3
    01674 8A40      STD	Z+16,R4
    01675 8A51      STD	Z+17,R5
(2147) 		}
(2148) 	}
(2149) #endif
(2150) 	fs->fs_type = fmt;		/* FAT sub-type */
    01676 A1ED      LDD	R30,Y+37
    01677 A1FE      LDD	R31,Y+38
    01678 82C0      ST	Z,R12
(2151) 	fs->id = ++Fsid;		/* File system mount ID */
    01679 9180 0575 LDS	R24,ff.c:Fsid
    0167B 9190 0576 LDS	R25,ff.c:Fsid+1
    0167D 9601      ADIW	R24,1
    0167E 016C      MOVW	R12,R24
    0167F 92D0 0576 STS	ff.c:Fsid+1,R13
    01681 92C0 0575 STS	ff.c:Fsid,R12
    01683 82D7      STD	Z+7,R13
    01684 82C6      STD	Z+6,R12
(2152) 	fs->winsect = 0;		/* Invalidate sector cache */
    01685 96BA      ADIW	R30,0x2A
    01686 E080      LDI	R24,0
    01687 8380      ST	Z,R24
    01688 8381      STD	Z+1,R24
    01689 8382      STD	Z+2,R24
    0168A 8383      STD	Z+3,R24
(2153) 	fs->wflag = 0;
    0168B 2422      CLR	R2
    0168C A1ED      LDD	R30,Y+37
    0168D A1FE      LDD	R31,Y+38
    0168E 8224      STD	Z+4,R2
(2154) #if _FS_RPATH
(2155) 	fs->cdir = 0;			/* Current directory (root dir) */
(2156) #endif
(2157) #if _FS_SHARE				/* Clear file lock semaphores */
(2158) 	clear_lock(fs);
(2159) #endif
(2160) 
(2161) 	return FR_OK;
    0168F 2700      CLR	R16
    01690 96A7      ADIW	R28,0x27
    01691 940E 4299 CALL	pop_xgsetF0FC
    01693 9622      ADIW	R28,2
    01694 9508      RET
ff.c:validate:
  id                   --> R10
  fs                   --> R20
    01695 940E 42AF CALL	push_xgset300C
    01697 0159      MOVW	R10,R18
    01698 01A8      MOVW	R20,R16
(2162) }
(2163) 
(2164) 
(2165) 
(2166) 
(2167) /*-----------------------------------------------------------------------*/
(2168) /* Check if the file/dir object is valid or not                          */
(2169) /*-----------------------------------------------------------------------*/
(2170) 
(2171) static
(2172) FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
(2173) 	FATFS *fs,		/* Pointer to the file system object */
(2174) 	WORD id			/* Member id of the target object to be checked */
(2175) )
(2176) {
(2177) 	if (!fs || !fs->fs_type || fs->id != id)
    01699 3040      CPI	R20,0
    0169A 0745      CPC	R20,R21
    0169B F049      BEQ	0x16A5
    0169C 01FA      MOVW	R30,R20
    0169D 8020      LD	R2,Z
    0169E 2022      TST	R2
    0169F F029      BEQ	0x16A5
    016A0 8026      LDD	R2,Z+6
    016A1 8037      LDD	R3,Z+7
    016A2 142A      CP	R2,R10
    016A3 043B      CPC	R3,R11
    016A4 F011      BEQ	0x16A7
(2178) 		return FR_INVALID_OBJECT;
    016A5 E009      LDI	R16,0x9
    016A6 C009      RJMP	0x16B0
(2179) 
(2180) 	ENTER_FF(fs);		/* Lock file system */
(2181) 
(2182) 	if (disk_status(fs->drv) & STA_NOINIT)
    016A7 01FA      MOVW	R30,R20
    016A8 8101      LDD	R16,Z+1
    016A9 940E 02DC CALL	_disk_status
    016AB FF00      SBRS	R16,0
    016AC C002      RJMP	0x16AF
(2183) 		return FR_NOT_READY;
    016AD E003      LDI	R16,3
    016AE C001      RJMP	0x16B0
(2184) 
(2185) 	return FR_OK;
    016AF 2700      CLR	R16
    016B0 940C 42B4 JMP	pop_xgset300C
_f_mount:
  rfs                  --> R10
  fs                   --> R18
  vol                  --> R16
    016B2 92AA      ST	-Y,R10
    016B3 92BA      ST	-Y,R11
(2186) }
(2187) 
(2188) 
(2189) 
(2190) 
(2191) /*--------------------------------------------------------------------------
(2192) 
(2193)    Public Functions
(2194) 
(2195) --------------------------------------------------------------------------*/
(2196) 
(2197) 
(2198) 
(2199) /*-----------------------------------------------------------------------*/
(2200) /* Mount/Unmount a Logical Drive                                         */
(2201) /*-----------------------------------------------------------------------*/
(2202) 
(2203) FRESULT f_mount (
(2204) 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
(2205) 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
(2206) )
(2207) {
(2208) 	FATFS *rfs;
(2209) 
(2210) 
(2211) 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    016B4 3001      CPI	R16,1
    016B5 F010      BCS	0x16B8
(2212) 		return FR_INVALID_DRIVE;
    016B6 E00B      LDI	R16,0xB
    016B7 C022      RJMP	0x16DA
(2213) 	rfs = FatFs[vol];			/* Get current fs object */
    016B8 E787      LDI	R24,0x77
    016B9 E095      LDI	R25,5
    016BA 2FE0      MOV	R30,R16
    016BB 27FF      CLR	R31
    016BC 0FEE      LSL	R30
    016BD 1FFF      ROL	R31
    016BE 0FE8      ADD	R30,R24
    016BF 1FF9      ADC	R31,R25
    016C0 80A0      LD	R10,Z
    016C1 80B1      LDD	R11,Z+1
(2214) 
(2215) 	if (rfs) {
    016C2 20AA      TST	R10
    016C3 F411      BNE	0x16C6
    016C4 20BB      TST	R11
    016C5 F019      BEQ	0x16C9
(2216) #if _FS_SHARE
(2217) 		clear_lock(rfs);
(2218) #endif
(2219) #if _FS_REENTRANT				/* Discard sync object of the current volume */
(2220) 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
(2221) #endif
(2222) 		rfs->fs_type = 0;		/* Clear old fs object */
    016C6 2422      CLR	R2
    016C7 01F5      MOVW	R30,R10
    016C8 8220      ST	Z,R2
(2223) 	}
(2224) 
(2225) 	if (fs) {
    016C9 3020      CPI	R18,0
    016CA 0723      CPC	R18,R19
    016CB F019      BEQ	0x16CF
(2226) 		fs->fs_type = 0;		/* Clear new fs object */
    016CC 2422      CLR	R2
    016CD 01F9      MOVW	R30,R18
    016CE 8220      ST	Z,R2
(2227) #if _FS_REENTRANT				/* Create sync object for the new volume */
(2228) 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
(2229) #endif
(2230) 	}
(2231) 	FatFs[vol] = fs;			/* Register new fs object */
    016CF E787      LDI	R24,0x77
    016D0 E095      LDI	R25,5
    016D1 2FE0      MOV	R30,R16
    016D2 27FF      CLR	R31
    016D3 0FEE      LSL	R30
    016D4 1FFF      ROL	R31
    016D5 0FE8      ADD	R30,R24
    016D6 1FF9      ADC	R31,R25
    016D7 8331      STD	Z+1,R19
    016D8 8320      ST	Z,R18
(2232) 
(2233) 	return FR_OK;
    016D9 2700      CLR	R16
    016DA 90B9      LD	R11,Y+
    016DB 90A9      LD	R10,Y+
    016DC 9508      RET
_f_open:
  cl                   --> Y,+40
  dw                   --> Y,+36
  sfn                  --> Y,+24
  dj                   --> Y,+2
  res                  --> R10
  dir                  --> R14
  mode                 --> Y,+58
  path                 --> Y,+56
  fp                   --> Y,+54
    016DD 940E 415F CALL	push_arg4
    016DF 940E 42A4 CALL	push_xgsetF0FC
    016E1 97AC      SBIW	R28,0x2C
(2234) }
(2235) 
(2236) 
(2237) 
(2238) 
(2239) /*-----------------------------------------------------------------------*/
(2240) /* Open or Create a File                                                 */
(2241) /*-----------------------------------------------------------------------*/
(2242) 
(2243) FRESULT f_open (
(2244) 	FIL *fp,			/* Pointer to the blank file object */
(2245) 	const TCHAR *path,	/* Pointer to the file name */
(2246) 	BYTE mode			/* Access mode and file open mode flags */
(2247) )
(2248) {
(2249) 	FRESULT res;
(2250) 	DIR dj;
(2251) 	BYTE *dir;
(2252) 	DEF_NAMEBUF;
(2253) 
(2254) 
(2255) 	fp->fs = 0;			/* Clear file object */
    016E2 2422      CLR	R2
    016E3 2433      CLR	R3
    016E4 A9EE      LDD	R30,Y+54
    016E5 A9FF      LDD	R31,Y+55
    016E6 8231      STD	Z+1,R3
    016E7 8220      ST	Z,R2
(2256) 
(2257) #if !_FS_READONLY
(2258) 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    016E8 AD8A      LDD	R24,Y+58
    016E9 718F      ANDI	R24,0x1F
    016EA AF8A      STD	Y+58,R24
(2259) 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    016EB 2799      CLR	R25
    016EC 7F8E      ANDI	R24,0xFE
    016ED 8388      ST	Y,R24
    016EE 019E      MOVW	R18,R28
    016EF 5F2E      SUBI	R18,0xFE
    016F0 4F3F      SBCI	R19,0xFF
    016F1 018E      MOVW	R16,R28
    016F2 5C08      SUBI	R16,0xC8
    016F3 4F1F      SBCI	R17,0xFF
    016F4 DAA6      RCALL	ff.c:chk_mounted
    016F5 2EA0      MOV	R10,R16
(2260) #else
(2261) 	mode &= FA_READ;
(2262) 	res = chk_mounted(&path, &dj.fs, 0);
(2263) #endif
(2264) 	INIT_BUF(dj);
    016F6 01CE      MOVW	R24,R28
    016F7 9648      ADIW	R24,0x18
    016F8 8B9F      STD	Y+23,R25
    016F9 8B8E      STD	Y+22,R24
(2265) 	if (res == FR_OK)
    016FA 2300      TST	R16
    016FB F439      BNE	0x1703
(2266) 		res = follow_path(&dj, path);	/* Follow the file path */
    016FC AD28      LDD	R18,Y+56
    016FD AD39      LDD	R19,Y+57
    016FE 018E      MOVW	R16,R28
    016FF 5F0E      SUBI	R16,0xFE
    01700 4F1F      SBCI	R17,0xFF
    01701 D94D      RCALL	ff.c:follow_path
    01702 2EA0      MOV	R10,R16
(2267) 	dir = dj.dir;
    01703 88EC      LDD	R14,Y+20
    01704 88FD      LDD	R15,Y+21
(2268) 
(2269) #if !_FS_READONLY	/* R/W configuration */
(2270) 	if (res == FR_OK) {
    01705 20AA      TST	R10
    01706 F431      BNE	0x170D
(2271) 		if (!dir)	/* Current dir itself */
    01707 20EE      TST	R14
    01708 F421      BNE	0x170D
    01709 20FF      TST	R15
    0170A F411      BNE	0x170D
(2272) 			res = FR_INVALID_NAME;
    0170B E086      LDI	R24,6
    0170C 2EA8      MOV	R10,R24
(2273) #if _FS_SHARE
(2274) 		else
(2275) 			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2276) #endif
(2277) 	}
(2278) 	/* Create or Open a file */
(2279) 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    0170D AD8A      LDD	R24,Y+58
    0170E 718C      ANDI	R24,0x1C
    0170F F409      BNE	0x1711
    01710 C0C0      RJMP	0x17D1
(2280) 		DWORD dw, cl;
(2281) 
(2282) 		if (res != FR_OK) {					/* No file, create new */
    01711 20AA      TST	R10
    01712 F081      BEQ	0x1723
(2283) 			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    01713 2D8A      MOV	R24,R10
    01714 3084      CPI	R24,4
    01715 F439      BNE	0x171D
(2284) #if _FS_SHARE
(2285) 				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
(2286) #else
(2287) 				res = dir_register(&dj);
    01716 018E      MOVW	R16,R28
    01717 5F0E      SUBI	R16,0xFE
    01718 4F1F      SBCI	R17,0xFF
    01719 940E 0E41 CALL	ff.c:dir_register
    0171B 2EC0      MOV	R12,R16
    0171C 2CAC      MOV	R10,R12
(2288) #endif
(2289) 			mode |= FA_CREATE_ALWAYS;		/* File is created */
    0171D AD8A      LDD	R24,Y+58
    0171E 6088      ORI	R24,0x8
    0171F AF8A      STD	Y+58,R24
(2290) 			dir = dj.dir;					/* New entry */
    01720 88EC      LDD	R14,Y+20
    01721 88FD      LDD	R15,Y+21
(2291) 		}
    01722 C00C      RJMP	0x172F
(2292) 		else {								/* Any object is already existing */
(2293) 			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    01723 01F7      MOVW	R30,R14
    01724 8583      LDD	R24,Z+11
    01725 7181      ANDI	R24,0x11
    01726 F019      BEQ	0x172A
(2294) 				res = FR_DENIED;
    01727 E087      LDI	R24,7
    01728 2EA8      MOV	R10,R24
(2295) 			} else {
    01729 C005      RJMP	0x172F
(2296) 				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    0172A AC0A      LDD	R0,Y+58
    0172B FE02      SBRS	R0,2
    0172C C002      RJMP	0x172F
(2297) 					res = FR_EXIST;
    0172D E088      LDI	R24,0x8
    0172E 2EA8      MOV	R10,R24
(2298) 			}
(2299) 		}
(2300) 		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    0172F 20AA      TST	R10
    01730 F009      BEQ	0x1732
    01731 C0B1      RJMP	0x17E3
    01732 AC0A      LDD	R0,Y+58
    01733 FE03      SBRS	R0,3
    01734 C0AE      RJMP	0x17E3
(2301) 			dw = get_fattime();					/* Created time */
    01735 940E 031F CALL	_get_fattime
    01737 A30C      STD	Y+36,R16
    01738 A31D      STD	Y+37,R17
    01739 A32E      STD	Y+38,R18
    0173A A33F      STD	Y+39,R19
(2302) 			ST_DWORD(dir+DIR_CrtTime, dw);
    0173B A02C      LDD	R2,Y+36
    0173C A03D      LDD	R3,Y+37
    0173D A04E      LDD	R4,Y+38
    0173E A05F      LDD	R5,Y+39
    0173F 01F7      MOVW	R30,R14
    01740 8626      STD	Z+14,R2
    01741 2C23      MOV	R2,R3
    01742 2433      CLR	R3
    01743 963F      ADIW	R30,0xF
    01744 8220      ST	Z,R2
    01745 A02C      LDD	R2,Y+36
    01746 A03D      LDD	R3,Y+37
    01747 A04E      LDD	R4,Y+38
    01748 A05F      LDD	R5,Y+39
    01749 0112      MOVW	R2,R4
    0174A 2444      CLR	R4
    0174B 2455      CLR	R5
    0174C 01F7      MOVW	R30,R14
    0174D 9670      ADIW	R30,0x10
    0174E 8220      ST	Z,R2
    0174F E188      LDI	R24,0x18
    01750 E090      LDI	R25,0
    01751 A10C      LDD	R16,Y+36
    01752 A11D      LDD	R17,Y+37
    01753 A12E      LDD	R18,Y+38
    01754 A13F      LDD	R19,Y+39
    01755 938A      ST	-Y,R24
    01756 940E 433F CALL	lsr32
    01758 01F7      MOVW	R30,R14
    01759 8B01      STD	Z+17,R16
(2303) 			dir[DIR_Attr] = 0;					/* Reset attribute */
    0175A 2422      CLR	R2
    0175B 8623      STD	Z+11,R2
(2304) 			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    0175C 8E24      STD	Z+28,R2
    0175D 8E25      STD	Z+29,R2
    0175E 8E26      STD	Z+30,R2
    0175F 8E27      STD	Z+31,R2
(2305) 			cl = LD_CLUST(dir);					/* Get start cluster */
    01760 8C22      LDD	R2,Z+26
    01761 2433      CLR	R3
    01762 8C43      LDD	R4,Z+27
    01763 2455      CLR	R5
    01764 2C54      MOV	R5,R4
    01765 2444      CLR	R4
    01766 2842      OR	R4,R2
    01767 2853      OR	R5,R3
    01768 0112      MOVW	R2,R4
    01769 2444      CLR	R4
    0176A 2455      CLR	R5
    0176B 8864      LDD	R6,Z+20
    0176C 2477      CLR	R7
    0176D 9675      ADIW	R30,0x15
    0176E 8080      LD	R8,Z
    0176F 2499      CLR	R9
    01770 2C98      MOV	R9,R8
    01771 2488      CLR	R8
    01772 2886      OR	R8,R6
    01773 2897      OR	R9,R7
    01774 0134      MOVW	R6,R8
    01775 2488      CLR	R8
    01776 2499      CLR	R9
    01777 0143      MOVW	R8,R6
    01778 2466      CLR	R6
    01779 2477      CLR	R7
    0177A 2862      OR	R6,R2
    0177B 2873      OR	R7,R3
    0177C 2884      OR	R8,R4
    0177D 2895      OR	R9,R5
    0177E A668      STD	Y+40,R6
    0177F A679      STD	Y+41,R7
    01780 A68A      STD	Y+42,R8
    01781 A69B      STD	Y+43,R9
(2306) 			ST_CLUST(dir, 0);					/* cluster = 0 */
    01782 2422      CLR	R2
    01783 01F7      MOVW	R30,R14
    01784 8E22      STD	Z+26,R2
    01785 8E23      STD	Z+27,R2
    01786 8A24      STD	Z+20,R2
    01787 8A25      STD	Z+21,R2
(2307) 			dj.fs->wflag = 1;
    01788 E081      LDI	R24,1
    01789 81EA      LDD	R30,Y+2
    0178A 81FB      LDD	R31,Y+3
    0178B 9634      ADIW	R30,4
    0178C 8380      ST	Z,R24
(2308) 			if (cl) {							/* Remove the cluster chain if exist */
    0178D A428      LDD	R2,Y+40
    0178E A439      LDD	R3,Y+41
    0178F A44A      LDD	R4,Y+42
    01790 A45B      LDD	R5,Y+43
    01791 9488      BCLR	0
    01792 2022      TST	R2
    01793 0432      CPC	R3,R2
    01794 0442      CPC	R4,R2
    01795 0452      CPC	R5,R2
    01796 F409      BNE	0x1798
    01797 C04B      RJMP	0x17E3
(2309) 				dw = dj.fs->winsect;
    01798 81EA      LDD	R30,Y+2
    01799 81FB      LDD	R31,Y+3
    0179A A422      LDD	R2,Z+42
    0179B A433      LDD	R3,Z+43
    0179C A444      LDD	R4,Z+44
    0179D A455      LDD	R5,Z+45
    0179E A22C      STD	Y+36,R2
    0179F A23D      STD	Y+37,R3
    017A0 A24E      STD	Y+38,R4
    017A1 A25F      STD	Y+39,R5
(2310) 				res = remove_chain(dj.fs, cl);
    017A2 A428      LDD	R2,Y+40
    017A3 A439      LDD	R3,Y+41
    017A4 A44A      LDD	R4,Y+42
    017A5 A45B      LDD	R5,Y+43
    017A6 8248      ST	Y,R4
    017A7 8259      STD	Y+1,R5
    017A8 0191      MOVW	R18,R2
    017A9 810A      LDD	R16,Y+2
    017AA 811B      LDD	R17,Y+3
    017AB 940E 0855 CALL	ff.c:remove_chain
    017AD 2EC0      MOV	R12,R16
    017AE 2CAC      MOV	R10,R12
(2311) 				if (res == FR_OK) {
    017AF 2300      TST	R16
    017B0 F591      BNE	0x17E3
(2312) 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    017B1 E041      LDI	R20,1
    017B2 E050      LDI	R21,0
    017B3 E060      LDI	R22,0
    017B4 E070      LDI	R23,0
    017B5 A428      LDD	R2,Y+40
    017B6 A439      LDD	R3,Y+41
    017B7 A44A      LDD	R4,Y+42
    017B8 A45B      LDD	R5,Y+43
    017B9 1A24      SUB	R2,R20
    017BA 0A35      SBC	R3,R21
    017BB 0A46      SBC	R4,R22
    017BC 0A57      SBC	R5,R23
    017BD 81EA      LDD	R30,Y+2
    017BE 81FB      LDD	R31,Y+3
    017BF 8622      STD	Z+10,R2
    017C0 8633      STD	Z+11,R3
    017C1 8644      STD	Z+12,R4
    017C2 8655      STD	Z+13,R5
(2313) 					res = move_window(dj.fs, dw);
    017C3 A02C      LDD	R2,Y+36
    017C4 A03D      LDD	R3,Y+37
    017C5 A04E      LDD	R4,Y+38
    017C6 A05F      LDD	R5,Y+39
    017C7 8248      ST	Y,R4
    017C8 8259      STD	Y+1,R5
    017C9 0191      MOVW	R18,R2
    017CA 810A      LDD	R16,Y+2
    017CB 811B      LDD	R17,Y+3
    017CC 940E 037D CALL	ff.c:move_window
    017CE 2EC0      MOV	R12,R16
    017CF 2CAC      MOV	R10,R12
(2314) 				}
(2315) 			}
(2316) 		}
(2317) 	}
    017D0 C012      RJMP	0x17E3
(2318) 	else {	/* Open an existing file */
(2319) 		if (res == FR_OK) {						/* Follow succeeded */
    017D1 20AA      TST	R10
    017D2 F481      BNE	0x17E3
(2320) 			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    017D3 01F7      MOVW	R30,R14
    017D4 8423      LDD	R2,Z+11
    017D5 FE24      SBRS	R2,4
    017D6 C003      RJMP	0x17DA
(2321) 				res = FR_NO_FILE;
    017D7 E084      LDI	R24,4
    017D8 2EA8      MOV	R10,R24
(2322) 			} else {
    017D9 C009      RJMP	0x17E3
(2323) 				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    017DA AC0A      LDD	R0,Y+58
    017DB FE01      SBRS	R0,1
    017DC C006      RJMP	0x17E3
    017DD 01F7      MOVW	R30,R14
    017DE 8423      LDD	R2,Z+11
    017DF FE20      SBRS	R2,0
    017E0 C002      RJMP	0x17E3
(2324) 					res = FR_DENIED;
    017E1 E087      LDI	R24,7
    017E2 2EA8      MOV	R10,R24
(2325) 			}
(2326) 		}
(2327) 	}
(2328) 	if (res == FR_OK) {
    017E3 20AA      TST	R10
    017E4 F4A1      BNE	0x17F9
(2329) 		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    017E5 AC0A      LDD	R0,Y+58
    017E6 FE03      SBRS	R0,3
    017E7 C003      RJMP	0x17EB
(2330) 			mode |= FA__WRITTEN;
    017E8 2D80      MOV	R24,R0
    017E9 6280      ORI	R24,0x20
    017EA AF8A      STD	Y+58,R24
(2331) 		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    017EB 81EA      LDD	R30,Y+2
    017EC 81FB      LDD	R31,Y+3
    017ED A422      LDD	R2,Z+42
    017EE A433      LDD	R3,Z+43
    017EF A444      LDD	R4,Z+44
    017F0 A455      LDD	R5,Z+45
    017F1 A9EE      LDD	R30,Y+54
    017F2 A9FF      LDD	R31,Y+55
    017F3 8E22      STD	Z+26,R2
    017F4 8E33      STD	Z+27,R3
    017F5 8E44      STD	Z+28,R4
    017F6 8E55      STD	Z+29,R5
(2332) 		fp->dir_ptr = dir;
    017F7 8EF7      STD	Z+31,R15
    017F8 8EE6      STD	Z+30,R14
(2333) #if _FS_SHARE
(2334) 		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2335) 		if (!fp->lockid) res = FR_INT_ERR;
(2336) #endif
(2337) 	}
(2338) 
(2339) #else				/* R/O configuration */
(2340) 	if (res == FR_OK) {					/* Follow succeeded */
(2341) 		if (!dir) {						/* Current dir itself */
(2342) 			res = FR_INVALID_NAME;
(2343) 		} else {
(2344) 			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
(2345) 				res = FR_NO_FILE;
(2346) 		}
(2347) 	}
(2348) #endif
(2349) 	FREE_BUF();
(2350) 
(2351) 	if (res == FR_OK) {
    017F9 20AA      TST	R10
    017FA F009      BEQ	0x17FC
    017FB C077      RJMP	0x1873
(2352) 		fp->flag = mode;					/* File access mode */
    017FC A9EE      LDD	R30,Y+54
    017FD A9FF      LDD	R31,Y+55
    017FE AC0A      LDD	R0,Y+58
    017FF 8204      STD	Z+4,R0
(2353) 		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    01800 01F7      MOVW	R30,R14
    01801 8C22      LDD	R2,Z+26
    01802 2433      CLR	R3
    01803 8C43      LDD	R4,Z+27
    01804 2455      CLR	R5
    01805 2C54      MOV	R5,R4
    01806 2444      CLR	R4
    01807 2842      OR	R4,R2
    01808 2853      OR	R5,R3
    01809 0112      MOVW	R2,R4
    0180A 2444      CLR	R4
    0180B 2455      CLR	R5
    0180C 8864      LDD	R6,Z+20
    0180D 2477      CLR	R7
    0180E 8885      LDD	R8,Z+21
    0180F 2499      CLR	R9
    01810 2C98      MOV	R9,R8
    01811 2488      CLR	R8
    01812 2886      OR	R8,R6
    01813 2897      OR	R9,R7
    01814 0134      MOVW	R6,R8
    01815 2488      CLR	R8
    01816 2499      CLR	R9
    01817 0143      MOVW	R8,R6
    01818 2466      CLR	R6
    01819 2477      CLR	R7
    0181A 2862      OR	R6,R2
    0181B 2873      OR	R7,R3
    0181C 2884      OR	R8,R4
    0181D 2895      OR	R9,R5
    0181E A9EE      LDD	R30,Y+54
    0181F A9FF      LDD	R31,Y+55
    01820 8666      STD	Z+14,R6
    01821 8677      STD	Z+15,R7
    01822 8A80      STD	Z+16,R8
    01823 8A91      STD	Z+17,R9
(2354) 		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    01824 E188      LDI	R24,0x18
    01825 E090      LDI	R25,0
    01826 01F7      MOVW	R30,R14
    01827 8D07      LDD	R16,Z+31
    01828 2711      CLR	R17
    01829 2722      CLR	R18
    0182A 2733      CLR	R19
    0182B 938A      ST	-Y,R24
    0182C 940E 4326 CALL	lsl32
    0182E 0118      MOVW	R2,R16
    0182F 0129      MOVW	R4,R18
    01830 01F7      MOVW	R30,R14
    01831 8C66      LDD	R6,Z+30
    01832 2477      CLR	R7
    01833 2488      CLR	R8
    01834 2499      CLR	R9
    01835 0143      MOVW	R8,R6
    01836 2466      CLR	R6
    01837 2477      CLR	R7
    01838 2826      OR	R2,R6
    01839 2837      OR	R3,R7
    0183A 2848      OR	R4,R8
    0183B 2859      OR	R5,R9
    0183C 8C65      LDD	R6,Z+29
    0183D 2477      CLR	R7
    0183E 2C76      MOV	R7,R6
    0183F 2466      CLR	R6
    01840 2488      CLR	R8
    01841 2499      CLR	R9
    01842 2826      OR	R2,R6
    01843 2837      OR	R3,R7
    01844 2848      OR	R4,R8
    01845 2859      OR	R5,R9
    01846 8C64      LDD	R6,Z+28
    01847 2477      CLR	R7
    01848 2488      CLR	R8
    01849 2499      CLR	R9
    0184A 2826      OR	R2,R6
    0184B 2837      OR	R3,R7
    0184C 2848      OR	R4,R8
    0184D 2859      OR	R5,R9
    0184E A9EE      LDD	R30,Y+54
    0184F A9FF      LDD	R31,Y+55
    01850 8622      STD	Z+10,R2
    01851 8633      STD	Z+11,R3
    01852 8644      STD	Z+12,R4
    01853 8655      STD	Z+13,R5
(2355) 		fp->fptr = 0;						/* File pointer */
    01854 9636      ADIW	R30,6
    01855 E080      LDI	R24,0
    01856 8380      ST	Z,R24
    01857 8381      STD	Z+1,R24
    01858 8382      STD	Z+2,R24
    01859 8383      STD	Z+3,R24
(2356) 		fp->dsect = 0;
    0185A A9EE      LDD	R30,Y+54
    0185B A9FF      LDD	R31,Y+55
    0185C 9676      ADIW	R30,0x16
    0185D E080      LDI	R24,0
    0185E 8380      ST	Z,R24
    0185F 8381      STD	Z+1,R24
    01860 8382      STD	Z+2,R24
    01861 8383      STD	Z+3,R24
(2357) #if _USE_FASTSEEK
(2358) 		fp->cltbl = 0;						/* Normal seek mode */
    01862 2422      CLR	R2
    01863 2433      CLR	R3
    01864 A9EE      LDD	R30,Y+54
    01865 A9FF      LDD	R31,Y+55
    01866 A231      STD	Z+33,R3
    01867 A220      STD	Z+32,R2
(2359) #endif
(2360) 		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    01868 802A      LDD	R2,Y+2
    01869 803B      LDD	R3,Y+3
    0186A 8231      STD	Z+1,R3
    0186B 8220      ST	Z,R2
    0186C 01F1      MOVW	R30,R2
    0186D 8026      LDD	R2,Z+6
    0186E 8037      LDD	R3,Z+7
    0186F A9EE      LDD	R30,Y+54
    01870 A9FF      LDD	R31,Y+55
    01871 8233      STD	Z+3,R3
    01872 8222      STD	Z+2,R2
(2361) 	}
(2362) 
(2363) 	LEAVE_FF(dj.fs, res);
    01873 2D0A      MOV	R16,R10
    01874 96AC      ADIW	R28,0x2C
    01875 940E 4299 CALL	pop_xgsetF0FC
    01877 9624      ADIW	R28,4
    01878 9508      RET
_f_read:
  remain               --> Y,+13
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  rbuff                --> R14
  sect                 --> Y,+5
  rcnt                 --> R12
  br                   --> Y,+33
  btr                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01879 940E 415F CALL	push_arg4
    0187B 940E 42A4 CALL	push_xgsetF0FC
    0187D 0159      MOVW	R10,R18
    0187E 9761      SBIW	R28,0x11
(2364) }
(2365) 
(2366) 
(2367) 
(2368) 
(2369) /*-----------------------------------------------------------------------*/
(2370) /* Read File                                                             */
(2371) /*-----------------------------------------------------------------------*/
(2372) 
(2373) FRESULT f_read (
(2374) 	FIL *fp, 		/* Pointer to the file object */
(2375) 	void *buff,		/* Pointer to data buffer */
(2376) 	UINT btr,		/* Number of bytes to read */
(2377) 	UINT *br		/* Pointer to number of bytes read */
(2378) )
(2379) {
(2380) 	FRESULT res;
(2381) 	DWORD clst, sect, remain;
(2382) 	UINT rcnt, cc;
(2383) 	BYTE csect, *rbuff = buff;
    0187F 0175      MOVW	R14,R10
(2384) 
(2385) 	memset(buff,0,512);
    01880 E080      LDI	R24,0
    01881 E092      LDI	R25,2
    01882 8399      STD	Y+1,R25
    01883 8388      ST	Y,R24
    01884 2722      CLR	R18
    01885 2733      CLR	R19
    01886 0185      MOVW	R16,R10
    01887 940E 413B CALL	_memset
(2386) 
(2387) 	*br = 0;	/* Initialize byte counter */
    01889 2422      CLR	R2
    0188A 2433      CLR	R3
    0188B A1E9      LDD	R30,Y+33
    0188C A1FA      LDD	R31,Y+34
    0188D 8231      STD	Z+1,R3
    0188E 8220      ST	Z,R2
(2388) 
(2389) 	res = validate(fp->fs, fp->id);				/* Check validity */
    0188F 8DEB      LDD	R30,Y+27
    01890 8DFC      LDD	R31,Y+28
    01891 8122      LDD	R18,Z+2
    01892 8133      LDD	R19,Z+3
    01893 8100      LD	R16,Z
    01894 8111      LDD	R17,Z+1
    01895 DDFF      RCALL	ff.c:validate
    01896 2EA0      MOV	R10,R16
(2390) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01897 2300      TST	R16
    01898 F009      BEQ	0x189A
    01899 C245      RJMP	0x1ADF
(2391) 	if (fp->flag & FA__ERROR)					/* Aborted file? */
    0189A 8DEB      LDD	R30,Y+27
    0189B 8DFC      LDD	R31,Y+28
    0189C 8024      LDD	R2,Z+4
    0189D FE27      SBRS	R2,7
    0189E C002      RJMP	0x18A1
(2392) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    0189F E002      LDI	R16,2
    018A0 C23E      RJMP	0x1ADF
(2393) 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    018A1 8DEB      LDD	R30,Y+27
    018A2 8DFC      LDD	R31,Y+28
    018A3 8024      LDD	R2,Z+4
    018A4 FC20      SBRC	R2,0
    018A5 C002      RJMP	0x18A8
(2394) 		LEAVE_FF(fp->fs, FR_DENIED);
    018A6 E007      LDI	R16,7
    018A7 C237      RJMP	0x1ADF
(2395) 	remain = fp->fsize - fp->fptr;
    018A8 8DEB      LDD	R30,Y+27
    018A9 8DFC      LDD	R31,Y+28
    018AA 8026      LDD	R2,Z+6
    018AB 8037      LDD	R3,Z+7
    018AC 8440      LDD	R4,Z+8
    018AD 8451      LDD	R5,Z+9
    018AE 963A      ADIW	R30,0xA
    018AF 8060      LD	R6,Z
    018B0 8071      LDD	R7,Z+1
    018B1 8082      LDD	R8,Z+2
    018B2 8093      LDD	R9,Z+3
    018B3 1862      SUB	R6,R2
    018B4 0873      SBC	R7,R3
    018B5 0884      SBC	R8,R4
    018B6 0895      SBC	R9,R5
    018B7 866D      STD	Y+13,R6
    018B8 867E      STD	Y+14,R7
    018B9 868F      STD	Y+15,R8
    018BA 8A98      STD	Y+16,R9
(2396) 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    018BB 842D      LDD	R2,Y+13
    018BC 843E      LDD	R3,Y+14
    018BD 844F      LDD	R4,Y+15
    018BE 8858      LDD	R5,Y+16
    018BF 8C6F      LDD	R6,Y+31
    018C0 A078      LDD	R7,Y+32
    018C1 2488      CLR	R8
    018C2 2499      CLR	R9
    018C3 1426      CP	R2,R6
    018C4 0437      CPC	R3,R7
    018C5 0448      CPC	R4,R8
    018C6 0459      CPC	R5,R9
    018C7 F008      BCS	0x18C9
    018C8 C20D      RJMP	0x1AD6
    018C9 A238      STD	Y+32,R3
    018CA 8E2F      STD	Y+31,R2
(2397) 
(2398) 	for ( ;  btr;								/* Repeat until all data read */
    018CB C20A      RJMP	0x1AD6
(2399) 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
(2400) 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    018CC EF4F      LDI	R20,0xFF
    018CD E051      LDI	R21,1
    018CE E060      LDI	R22,0
    018CF E070      LDI	R23,0
    018D0 8DEB      LDD	R30,Y+27
    018D1 8DFC      LDD	R31,Y+28
    018D2 9636      ADIW	R30,6
    018D3 8020      LD	R2,Z
    018D4 8031      LDD	R3,Z+1
    018D5 8042      LDD	R4,Z+2
    018D6 8053      LDD	R5,Z+3
    018D7 2224      AND	R2,R20
    018D8 2235      AND	R3,R21
    018D9 2246      AND	R4,R22
    018DA 2257      AND	R5,R23
    018DB 9488      BCLR	0
    018DC 2022      TST	R2
    018DD 0432      CPC	R3,R2
    018DE 0442      CPC	R4,R2
    018DF 0452      CPC	R5,R2
    018E0 F009      BEQ	0x18E2
    018E1 C180      RJMP	0x1A62
(2401) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    018E2 E089      LDI	R24,0x9
    018E3 E090      LDI	R25,0
    018E4 8DEB      LDD	R30,Y+27
    018E5 8DFC      LDD	R31,Y+28
    018E6 8106      LDD	R16,Z+6
    018E7 8117      LDD	R17,Z+7
    018E8 8520      LDD	R18,Z+8
    018E9 8531      LDD	R19,Z+9
    018EA 938A      ST	-Y,R24
    018EB 940E 433F CALL	lsr32
    018ED 0118      MOVW	R2,R16
    018EE 0129      MOVW	R4,R18
    018EF 8DEB      LDD	R30,Y+27
    018F0 8DFC      LDD	R31,Y+28
    018F1 93AF      PUSH	R26
    018F2 93BF      PUSH	R27
    018F3 81A0      LD	R26,Z
    018F4 81B1      LDD	R27,Z+1
    018F5 01FD      MOVW	R30,R26
    018F6 91BF      POP	R27
    018F7 91AF      POP	R26
    018F8 8182      LDD	R24,Z+2
    018F9 2799      CLR	R25
    018FA 9701      SBIW	R24,1
    018FB 013C      MOVW	R6,R24
    018FC 2488      CLR	R8
    018FD FC77      SBRC	R7,7
    018FE 9480      COM	R8
    018FF 2499      CLR	R9
    01900 FC87      SBRC	R8,7
    01901 9490      COM	R9
    01902 2026      AND	R2,R6
    01903 2037      AND	R3,R7
    01904 2048      AND	R4,R8
    01905 2059      AND	R5,R9
    01906 2CC2      MOV	R12,R2
(2402) 			if (!csect) {						/* On the cluster boundary? */
    01907 2022      TST	R2
    01908 F009      BEQ	0x190A
    01909 C078      RJMP	0x1982
(2403) 				if (fp->fptr == 0) {			/* On the top of the file? */
    0190A 8DEB      LDD	R30,Y+27
    0190B 8DFC      LDD	R31,Y+28
    0190C 9636      ADIW	R30,6
    0190D 8020      LD	R2,Z
    0190E 8031      LDD	R3,Z+1
    0190F 8042      LDD	R4,Z+2
    01910 8053      LDD	R5,Z+3
    01911 9488      BCLR	0
    01912 2022      TST	R2
    01913 0432      CPC	R3,R2
    01914 0442      CPC	R4,R2
    01915 0452      CPC	R5,R2
    01916 F461      BNE	0x1923
(2404) 					clst = fp->sclust;			/* Follow from the origin */
    01917 8DEB      LDD	R30,Y+27
    01918 8DFC      LDD	R31,Y+28
    01919 963E      ADIW	R30,0xE
    0191A 8020      LD	R2,Z
    0191B 8031      LDD	R3,Z+1
    0191C 8042      LDD	R4,Z+2
    0191D 8053      LDD	R5,Z+3
    0191E 8629      STD	Y+9,R2
    0191F 863A      STD	Y+10,R3
    01920 864B      STD	Y+11,R4
    01921 865C      STD	Y+12,R5
(2405) 				} else {						/* Middle or end of the file */
    01922 C028      RJMP	0x194B
(2406) #if _USE_FASTSEEK
(2407) 					if (fp->cltbl)
    01923 8DEB      LDD	R30,Y+27
    01924 8DFC      LDD	R31,Y+28
    01925 A020      LDD	R2,Z+32
    01926 A031      LDD	R3,Z+33
    01927 2022      TST	R2
    01928 F411      BNE	0x192B
    01929 2033      TST	R3
    0192A F079      BEQ	0x193A
(2408) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    0192B 8026      LDD	R2,Z+6
    0192C 8037      LDD	R3,Z+7
    0192D 8440      LDD	R4,Z+8
    0192E 8451      LDD	R5,Z+9
    0192F 8248      ST	Y,R4
    01930 8259      STD	Y+1,R5
    01931 0191      MOVW	R18,R2
    01932 018F      MOVW	R16,R30
    01933 940E 0A80 CALL	ff.c:clmt_clust
    01935 8709      STD	Y+9,R16
    01936 871A      STD	Y+10,R17
    01937 872B      STD	Y+11,R18
    01938 873C      STD	Y+12,R19
    01939 C011      RJMP	0x194B
(2409) 					else
(2410) #endif
(2411) 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    0193A 8DEB      LDD	R30,Y+27
    0193B 8DFC      LDD	R31,Y+28
    0193C 8822      LDD	R2,Z+18
    0193D 8833      LDD	R3,Z+19
    0193E 8844      LDD	R4,Z+20
    0193F 8855      LDD	R5,Z+21
    01940 8248      ST	Y,R4
    01941 8259      STD	Y+1,R5
    01942 0191      MOVW	R18,R2
    01943 8100      LD	R16,Z
    01944 8111      LDD	R17,Z+1
    01945 940E 0546 CALL	_get_fat
    01947 8709      STD	Y+9,R16
    01948 871A      STD	Y+10,R17
    01949 872B      STD	Y+11,R18
    0194A 873C      STD	Y+12,R19
(2412) 				}
(2413) 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    0194B E042      LDI	R20,2
    0194C E050      LDI	R21,0
    0194D E060      LDI	R22,0
    0194E E070      LDI	R23,0
    0194F 8429      LDD	R2,Y+9
    01950 843A      LDD	R3,Y+10
    01951 844B      LDD	R4,Y+11
    01952 845C      LDD	R5,Y+12
    01953 1624      CP	R2,R20
    01954 0635      CPC	R3,R21
    01955 0646      CPC	R4,R22
    01956 0657      CPC	R5,R23
    01957 F448      BCC	0x1961
    01958 8D8B      LDD	R24,Y+27
    01959 8D9C      LDD	R25,Y+28
    0195A 9604      ADIW	R24,4
    0195B 01FC      MOVW	R30,R24
    0195C 8180      LD	R24,Z
    0195D 6880      ORI	R24,0x80
    0195E 8380      ST	Z,R24
    0195F E002      LDI	R16,2
    01960 C17E      RJMP	0x1ADF
(2414) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01961 EF4F      LDI	R20,0xFF
    01962 EF5F      LDI	R21,0xFF
    01963 EF6F      LDI	R22,0xFF
    01964 EF7F      LDI	R23,0xFF
    01965 8429      LDD	R2,Y+9
    01966 843A      LDD	R3,Y+10
    01967 844B      LDD	R4,Y+11
    01968 845C      LDD	R5,Y+12
    01969 1624      CP	R2,R20
    0196A 0635      CPC	R3,R21
    0196B 0646      CPC	R4,R22
    0196C 0657      CPC	R5,R23
    0196D F451      BNE	0x1978
    0196E 8D8B      LDD	R24,Y+27
    0196F 8D9C      LDD	R25,Y+28
    01970 9604      ADIW	R24,4
    01971 015C      MOVW	R10,R24
    01972 01FC      MOVW	R30,R24
    01973 8180      LD	R24,Z
    01974 6880      ORI	R24,0x80
    01975 8380      ST	Z,R24
    01976 E001      LDI	R16,1
    01977 C167      RJMP	0x1ADF
(2415) 				fp->clust = clst;				/* Update current cluster */
    01978 8429      LDD	R2,Y+9
    01979 843A      LDD	R3,Y+10
    0197A 844B      LDD	R4,Y+11
    0197B 845C      LDD	R5,Y+12
    0197C 8DEB      LDD	R30,Y+27
    0197D 8DFC      LDD	R31,Y+28
    0197E 8A22      STD	Z+18,R2
    0197F 8A33      STD	Z+19,R3
    01980 8A44      STD	Z+20,R4
    01981 8A55      STD	Z+21,R5
(2416) 			}
(2417) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01982 8DEB      LDD	R30,Y+27
    01983 8DFC      LDD	R31,Y+28
    01984 8822      LDD	R2,Z+18
    01985 8833      LDD	R3,Z+19
    01986 8844      LDD	R4,Z+20
    01987 8855      LDD	R5,Z+21
    01988 8248      ST	Y,R4
    01989 8259      STD	Y+1,R5
    0198A 0191      MOVW	R18,R2
    0198B 8100      LD	R16,Z
    0198C 8111      LDD	R17,Z+1
    0198D 940E 04F4 CALL	_clust2sect
    0198F 830D      STD	Y+5,R16
    01990 831E      STD	Y+6,R17
    01991 832F      STD	Y+7,R18
    01992 8738      STD	Y+8,R19
(2418) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01993 802D      LDD	R2,Y+5
    01994 803E      LDD	R3,Y+6
    01995 804F      LDD	R4,Y+7
    01996 8458      LDD	R5,Y+8
    01997 9488      BCLR	0
    01998 2022      TST	R2
    01999 0432      CPC	R3,R2
    0199A 0442      CPC	R4,R2
    0199B 0452      CPC	R5,R2
    0199C F451      BNE	0x19A7
    0199D 8D8B      LDD	R24,Y+27
    0199E 8D9C      LDD	R25,Y+28
    0199F 9604      ADIW	R24,4
    019A0 015C      MOVW	R10,R24
    019A1 01FC      MOVW	R30,R24
    019A2 8180      LD	R24,Z
    019A3 6880      ORI	R24,0x80
    019A4 8380      ST	Z,R24
    019A5 E002      LDI	R16,2
    019A6 C138      RJMP	0x1ADF
(2419) 			sect += csect;
    019A7 2C2C      MOV	R2,R12
    019A8 2433      CLR	R3
    019A9 2444      CLR	R4
    019AA 2455      CLR	R5
    019AB 806D      LDD	R6,Y+5
    019AC 807E      LDD	R7,Y+6
    019AD 808F      LDD	R8,Y+7
    019AE 8498      LDD	R9,Y+8
    019AF 0C62      ADD	R6,R2
    019B0 1C73      ADC	R7,R3
    019B1 1C84      ADC	R8,R4
    019B2 1C95      ADC	R9,R5
    019B3 826D      STD	Y+5,R6
    019B4 827E      STD	Y+6,R7
    019B5 828F      STD	Y+7,R8
    019B6 8698      STD	Y+8,R9
(2420) 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    019B7 E029      LDI	R18,0x9
    019B8 E030      LDI	R19,0
    019B9 8D0F      LDD	R16,Y+31
    019BA A118      LDD	R17,Y+32
    019BB 940E 4338 CALL	lsr16
    019BD 0158      MOVW	R10,R16
(2421) 			if (cc) {							/* Read maximum contiguous sectors directly */
    019BE 3000      CPI	R16,0
    019BF 0701      CPC	R16,R17
    019C0 F409      BNE	0x19C2
    019C1 C096      RJMP	0x1A58
(2422) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    019C2 2C2C      MOV	R2,R12
    019C3 2433      CLR	R3
    019C4 0E20      ADD	R2,R16
    019C5 1E31      ADC	R3,R17
    019C6 8DEB      LDD	R30,Y+27
    019C7 8DFC      LDD	R31,Y+28
    019C8 93AF      PUSH	R26
    019C9 93BF      PUSH	R27
    019CA 81A0      LD	R26,Z
    019CB 81B1      LDD	R27,Z+1
    019CC 01FD      MOVW	R30,R26
    019CD 91BF      POP	R27
    019CE 91AF      POP	R26
    019CF 8042      LDD	R4,Z+2
    019D0 2455      CLR	R5
    019D1 1442      CP	R4,R2
    019D2 0453      CPC	R5,R3
    019D3 F478      BCC	0x19E3
(2423) 					cc = fp->fs->csize - csect;
    019D4 2C2C      MOV	R2,R12
    019D5 2433      CLR	R3
    019D6 8DEB      LDD	R30,Y+27
    019D7 8DFC      LDD	R31,Y+28
    019D8 93AF      PUSH	R26
    019D9 93BF      PUSH	R27
    019DA 81A0      LD	R26,Z
    019DB 81B1      LDD	R27,Z+1
    019DC 01FD      MOVW	R30,R26
    019DD 91BF      POP	R27
    019DE 91AF      POP	R26
    019DF 80A2      LDD	R10,Z+2
    019E0 24BB      CLR	R11
    019E1 18A2      SUB	R10,R2
    019E2 08B3      SBC	R11,R3
(2424) 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    019E3 82AC      STD	Y+4,R10
    019E4 802D      LDD	R2,Y+5
    019E5 803E      LDD	R3,Y+6
    019E6 804F      LDD	R4,Y+7
    019E7 8458      LDD	R5,Y+8
    019E8 8228      ST	Y,R2
    019E9 8239      STD	Y+1,R3
    019EA 824A      STD	Y+2,R4
    019EB 825B      STD	Y+3,R5
    019EC 0197      MOVW	R18,R14
    019ED 8DEB      LDD	R30,Y+27
    019EE 8DFC      LDD	R31,Y+28
    019EF 93AF      PUSH	R26
    019F0 93BF      PUSH	R27
    019F1 81A0      LD	R26,Z
    019F2 81B1      LDD	R27,Z+1
    019F3 01FD      MOVW	R30,R26
    019F4 91BF      POP	R27
    019F5 91AF      POP	R26
    019F6 8101      LDD	R16,Z+1
    019F7 940E 02E2 CALL	_disk_read
    019F9 2EC0      MOV	R12,R16
    019FA 2300      TST	R16
    019FB F051      BEQ	0x1A06
(2425) 					ABORT(fp->fs, FR_DISK_ERR);
    019FC 8D8B      LDD	R24,Y+27
    019FD 8D9C      LDD	R25,Y+28
    019FE 9604      ADIW	R24,4
    019FF 016C      MOVW	R12,R24
    01A00 01FC      MOVW	R30,R24
    01A01 8180      LD	R24,Z
    01A02 6880      ORI	R24,0x80
    01A03 8380      ST	Z,R24
    01A04 E001      LDI	R16,1
    01A05 C0D9      RJMP	0x1ADF
(2426) #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
(2427) #if _FS_TINY
(2428) 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    01A06 8DEB      LDD	R30,Y+27
    01A07 8DFC      LDD	R31,Y+28
    01A08 80C0      LD	R12,Z
    01A09 80D1      LDD	R13,Z+1
    01A0A 01F6      MOVW	R30,R12
    01A0B 9634      ADIW	R30,4
    01A0C 8020      LD	R2,Z
    01A0D 2022      TST	R2
    01A0E F409      BNE	0x1A10
    01A0F C041      RJMP	0x1A51
    01A10 802D      LDD	R2,Y+5
    01A11 803E      LDD	R3,Y+6
    01A12 804F      LDD	R4,Y+7
    01A13 8458      LDD	R5,Y+8
    01A14 01F6      MOVW	R30,R12
    01A15 A462      LDD	R6,Z+42
    01A16 A473      LDD	R7,Z+43
    01A17 A484      LDD	R8,Z+44
    01A18 A495      LDD	R9,Z+45
    01A19 1862      SUB	R6,R2
    01A1A 0873      SBC	R7,R3
    01A1B 0884      SBC	R8,R4
    01A1C 0895      SBC	R9,R5
    01A1D 0115      MOVW	R2,R10
    01A1E 2444      CLR	R4
    01A1F 2455      CLR	R5
    01A20 1462      CP	R6,R2
    01A21 0473      CPC	R7,R3
    01A22 0484      CPC	R8,R4
    01A23 0495      CPC	R9,R5
    01A24 F560      BCC	0x1A51
(2429) 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
    01A25 E080      LDI	R24,0
    01A26 E092      LDI	R25,2
    01A27 8399      STD	Y+1,R25
    01A28 8388      ST	Y,R24
    01A29 8DEB      LDD	R30,Y+27
    01A2A 8DFC      LDD	R31,Y+28
    01A2B 80C0      LD	R12,Z
    01A2C 80D1      LDD	R13,Z+1
    01A2D 0196      MOVW	R18,R12
    01A2E 5D22      SUBI	R18,0xD2
    01A2F 4F3F      SBCI	R19,0xFF
    01A30 802D      LDD	R2,Y+5
    01A31 803E      LDD	R3,Y+6
    01A32 804F      LDD	R4,Y+7
    01A33 8458      LDD	R5,Y+8
    01A34 01F6      MOVW	R30,R12
    01A35 A462      LDD	R6,Z+42
    01A36 A473      LDD	R7,Z+43
    01A37 A484      LDD	R8,Z+44
    01A38 A495      LDD	R9,Z+45
    01A39 1862      SUB	R6,R2
    01A3A 0873      SBC	R7,R3
    01A3B 0884      SBC	R8,R4
    01A3C 0895      SBC	R9,R5
    01A3D E040      LDI	R20,0
    01A3E E052      LDI	R21,2
    01A3F E060      LDI	R22,0
    01A40 E070      LDI	R23,0
    01A41 932F      PUSH	R18
    01A42 933F      PUSH	R19
    01A43 929A      ST	-Y,R9
    01A44 928A      ST	-Y,R8
    01A45 927A      ST	-Y,R7
    01A46 926A      ST	-Y,R6
    01A47 018A      MOVW	R16,R20
    01A48 019B      MOVW	R18,R22
    01A49 940E 4250 CALL	empy32u|empy32s
    01A4B 913F      POP	R19
    01A4C 912F      POP	R18
    01A4D 0D0E      ADD	R16,R14
    01A4E 1D1F      ADC	R17,R15
    01A4F 940E 0324 CALL	ff.c:mem_cpy
(2430) #else
(2431) 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
(2432) 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
(2433) #endif
(2434) #endif
(2435) 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    01A51 E000      LDI	R16,0
    01A52 E012      LDI	R17,2
    01A53 0195      MOVW	R18,R10
    01A54 940E 4240 CALL	empy16s
    01A56 0168      MOVW	R12,R16
(2436) 				continue;
    01A57 C05A      RJMP	0x1AB2
(2437) 			}
(2438) #if !_FS_TINY
(2439) 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
(2440) #if !_FS_READONLY
(2441) 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2442) 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2443) 						ABORT(fp->fs, FR_DISK_ERR);
(2444) 					fp->flag &= ~FA__DIRTY;
(2445) 				}
(2446) #endif
(2447) 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
(2448) 					ABORT(fp->fs, FR_DISK_ERR);
(2449) 			}
(2450) #endif
(2451) 			fp->dsect = sect;
    01A58 802D      LDD	R2,Y+5
    01A59 803E      LDD	R3,Y+6
    01A5A 804F      LDD	R4,Y+7
    01A5B 8458      LDD	R5,Y+8
    01A5C 8DEB      LDD	R30,Y+27
    01A5D 8DFC      LDD	R31,Y+28
    01A5E 8A26      STD	Z+22,R2
    01A5F 8A37      STD	Z+23,R3
    01A60 8E40      STD	Z+24,R4
    01A61 8E51      STD	Z+25,R5
(2452) 		}
(2453) 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    01A62 EF4F      LDI	R20,0xFF
    01A63 E051      LDI	R21,1
    01A64 E060      LDI	R22,0
    01A65 E070      LDI	R23,0
    01A66 8DEB      LDD	R30,Y+27
    01A67 8DFC      LDD	R31,Y+28
    01A68 8026      LDD	R2,Z+6
    01A69 8037      LDD	R3,Z+7
    01A6A 8440      LDD	R4,Z+8
    01A6B 8451      LDD	R5,Z+9
    01A6C 2224      AND	R2,R20
    01A6D 2235      AND	R3,R21
    01A6E 2246      AND	R4,R22
    01A6F 2257      AND	R5,R23
    01A70 E040      LDI	R20,0
    01A71 E052      LDI	R21,2
    01A72 E060      LDI	R22,0
    01A73 E070      LDI	R23,0
    01A74 1942      SUB	R20,R2
    01A75 0953      SBC	R21,R3
    01A76 0964      SBC	R22,R4
    01A77 0975      SBC	R23,R5
    01A78 016A      MOVW	R12,R20
(2454) 		if (rcnt > btr) rcnt = btr;
    01A79 8C0F      LDD	R0,Y+31
    01A7A A018      LDD	R1,Y+32
    01A7B 1604      CP	R0,R20
    01A7C 0615      CPC	R1,R21
    01A7D F408      BCC	0x1A7F
    01A7E 0160      MOVW	R12,R0
(2455) #if _FS_TINY
(2456) 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    01A7F 8DEB      LDD	R30,Y+27
    01A80 8DFC      LDD	R31,Y+28
    01A81 8826      LDD	R2,Z+22
    01A82 8837      LDD	R3,Z+23
    01A83 8C40      LDD	R4,Z+24
    01A84 8C51      LDD	R5,Z+25
    01A85 8248      ST	Y,R4
    01A86 8259      STD	Y+1,R5
    01A87 0191      MOVW	R18,R2
    01A88 8100      LD	R16,Z
    01A89 8111      LDD	R17,Z+1
    01A8A 940E 037D CALL	ff.c:move_window
    01A8C 2EA0      MOV	R10,R16
    01A8D 2300      TST	R16
    01A8E F051      BEQ	0x1A99
(2457) 			ABORT(fp->fs, FR_DISK_ERR);
    01A8F 8D8B      LDD	R24,Y+27
    01A90 8D9C      LDD	R25,Y+28
    01A91 9604      ADIW	R24,4
    01A92 015C      MOVW	R10,R24
    01A93 01FC      MOVW	R30,R24
    01A94 8180      LD	R24,Z
    01A95 6880      ORI	R24,0x80
    01A96 8380      ST	Z,R24
    01A97 E001      LDI	R16,1
    01A98 C046      RJMP	0x1ADF
(2458) 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    01A99 82D9      STD	Y+1,R13
    01A9A 82C8      ST	Y,R12
    01A9B EF4F      LDI	R20,0xFF
    01A9C E051      LDI	R21,1
    01A9D E060      LDI	R22,0
    01A9E E070      LDI	R23,0
    01A9F 8DEB      LDD	R30,Y+27
    01AA0 8DFC      LDD	R31,Y+28
    01AA1 8026      LDD	R2,Z+6
    01AA2 8037      LDD	R3,Z+7
    01AA3 8440      LDD	R4,Z+8
    01AA4 8451      LDD	R5,Z+9
    01AA5 2224      AND	R2,R20
    01AA6 2235      AND	R3,R21
    01AA7 2246      AND	R4,R22
    01AA8 2257      AND	R5,R23
    01AA9 0191      MOVW	R18,R2
    01AAA 8180      LD	R24,Z
    01AAB 8191      LDD	R25,Z+1
    01AAC 968E      ADIW	R24,0x2E
    01AAD 0F28      ADD	R18,R24
    01AAE 1F39      ADC	R19,R25
    01AAF 0187      MOVW	R16,R14
    01AB0 940E 0324 CALL	ff.c:mem_cpy
    01AB2 0CEC      ADD	R14,R12
    01AB3 1CFD      ADC	R15,R13
    01AB4 8D8B      LDD	R24,Y+27
    01AB5 8D9C      LDD	R25,Y+28
    01AB6 9606      ADIW	R24,6
    01AB7 015C      MOVW	R10,R24
    01AB8 0116      MOVW	R2,R12
    01AB9 2444      CLR	R4
    01ABA 2455      CLR	R5
    01ABB 01FC      MOVW	R30,R24
    01ABC 8060      LD	R6,Z
    01ABD 8071      LDD	R7,Z+1
    01ABE 8082      LDD	R8,Z+2
    01ABF 8093      LDD	R9,Z+3
    01AC0 0C62      ADD	R6,R2
    01AC1 1C73      ADC	R7,R3
    01AC2 1C84      ADC	R8,R4
    01AC3 1C95      ADC	R9,R5
    01AC4 8260      ST	Z,R6
    01AC5 8271      STD	Z+1,R7
    01AC6 8282      STD	Z+2,R8
    01AC7 8293      STD	Z+3,R9
    01AC8 A1E9      LDD	R30,Y+33
    01AC9 A1FA      LDD	R31,Y+34
    01ACA 8020      LD	R2,Z
    01ACB 8031      LDD	R3,Z+1
    01ACC 0C2C      ADD	R2,R12
    01ACD 1C3D      ADC	R3,R13
    01ACE 8231      STD	Z+1,R3
    01ACF 8220      ST	Z,R2
    01AD0 8C0F      LDD	R0,Y+31
    01AD1 A018      LDD	R1,Y+32
    01AD2 180C      SUB	R0,R12
    01AD3 081D      SBC	R1,R13
    01AD4 A218      STD	Y+32,R1
    01AD5 8E0F      STD	Y+31,R0
    01AD6 8C0F      LDD	R0,Y+31
    01AD7 A018      LDD	R1,Y+32
    01AD8 2000      TST	R0
    01AD9 F009      BEQ	0x1ADB
    01ADA CDF1      RJMP	0x18CC
    01ADB 2011      TST	R1
    01ADC F009      BEQ	0x1ADE
    01ADD CDEE      RJMP	0x18CC
(2459) #else
(2460) 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
(2461) #endif
(2462) 	}
(2463) 
(2464) 	LEAVE_FF(fp->fs, FR_OK);
    01ADE 2700      CLR	R16
    01ADF 9661      ADIW	R28,0x11
    01AE0 940E 4299 CALL	pop_xgsetF0FC
    01AE2 9624      ADIW	R28,4
    01AE3 9508      RET
_f_write:
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  wbuff                --> R14
  sect                 --> Y,+5
  wcnt                 --> R12
  bw                   --> Y,+33
  btw                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01AE4 940E 415F CALL	push_arg4
    01AE6 940E 42A4 CALL	push_xgsetF0FC
    01AE8 0159      MOVW	R10,R18
    01AE9 9761      SBIW	R28,0x11
(2465) }
(2466) 
(2467) 
(2468) 
(2469) 
(2470) #if !_FS_READONLY
(2471) /*-----------------------------------------------------------------------*/
(2472) /* Write File                                                            */
(2473) /*-----------------------------------------------------------------------*/
(2474) 
(2475) FRESULT f_write (
(2476) 	FIL *fp,			/* Pointer to the file object */
(2477) 	const void *buff,	/* Pointer to the data to be written */
(2478) 	UINT btw,			/* Number of bytes to write */
(2479) 	UINT *bw			/* Pointer to number of bytes written */
(2480) )
(2481) {
(2482) 	FRESULT res;
(2483) 	DWORD clst, sect;
(2484) 	UINT wcnt, cc;
(2485) 	const BYTE *wbuff = buff;
    01AEA 0175      MOVW	R14,R10
(2486) 	BYTE csect;
(2487) 
(2488) 
(2489) 	*bw = 0;	/* Initialize byte counter */
    01AEB 2422      CLR	R2
    01AEC 2433      CLR	R3
    01AED A1E9      LDD	R30,Y+33
    01AEE A1FA      LDD	R31,Y+34
    01AEF 8231      STD	Z+1,R3
    01AF0 8220      ST	Z,R2
(2490) 
(2491) 	res = validate(fp->fs, fp->id);			/* Check validity */
    01AF1 8DEB      LDD	R30,Y+27
    01AF2 8DFC      LDD	R31,Y+28
    01AF3 8122      LDD	R18,Z+2
    01AF4 8133      LDD	R19,Z+3
    01AF5 8100      LD	R16,Z
    01AF6 8111      LDD	R17,Z+1
    01AF7 DB9D      RCALL	ff.c:validate
    01AF8 2EA0      MOV	R10,R16
(2492) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01AF9 2300      TST	R16
    01AFA F009      BEQ	0x1AFC
    01AFB C2FC      RJMP	0x1DF8
(2493) 	if (fp->flag & FA__ERROR)				/* Aborted file? */
    01AFC 8DEB      LDD	R30,Y+27
    01AFD 8DFC      LDD	R31,Y+28
    01AFE 8024      LDD	R2,Z+4
    01AFF FE27      SBRS	R2,7
    01B00 C002      RJMP	0x1B03
(2494) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01B01 E002      LDI	R16,2
    01B02 C2F5      RJMP	0x1DF8
(2495) 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    01B03 8DEB      LDD	R30,Y+27
    01B04 8DFC      LDD	R31,Y+28
    01B05 8024      LDD	R2,Z+4
    01B06 FC21      SBRC	R2,1
    01B07 C002      RJMP	0x1B0A
(2496) 		LEAVE_FF(fp->fs, FR_DENIED);
    01B08 E007      LDI	R16,7
    01B09 C2EE      RJMP	0x1DF8
(2497) 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    01B0A 8DEB      LDD	R30,Y+27
    01B0B 8DFC      LDD	R31,Y+28
    01B0C 963A      ADIW	R30,0xA
    01B0D 8020      LD	R2,Z
    01B0E 8031      LDD	R3,Z+1
    01B0F 8042      LDD	R4,Z+2
    01B10 8053      LDD	R5,Z+3
    01B11 862D      STD	Y+13,R2
    01B12 863E      STD	Y+14,R3
    01B13 864F      STD	Y+15,R4
    01B14 8A58      STD	Y+16,R5
    01B15 8C2F      LDD	R2,Y+31
    01B16 A038      LDD	R3,Y+32
    01B17 2444      CLR	R4
    01B18 2455      CLR	R5
    01B19 846D      LDD	R6,Y+13
    01B1A 847E      LDD	R7,Y+14
    01B1B 848F      LDD	R8,Y+15
    01B1C 8898      LDD	R9,Y+16
    01B1D 0C62      ADD	R6,R2
    01B1E 1C73      ADC	R7,R3
    01B1F 1C84      ADC	R8,R4
    01B20 1C95      ADC	R9,R5
    01B21 842D      LDD	R2,Y+13
    01B22 843E      LDD	R3,Y+14
    01B23 844F      LDD	R4,Y+15
    01B24 8858      LDD	R5,Y+16
    01B25 1462      CP	R6,R2
    01B26 0473      CPC	R7,R3
    01B27 0484      CPC	R8,R4
    01B28 0495      CPC	R9,R5
    01B29 F008      BCS	0x1B2B
    01B2A C2A5      RJMP	0x1DD0
    01B2B 2400      CLR	R0
    01B2C 2411      CLR	R1
    01B2D A218      STD	Y+32,R1
    01B2E 8E0F      STD	Y+31,R0
(2498) 
(2499) 	for ( ;  btw;							/* Repeat until all data written */
    01B2F C2A0      RJMP	0x1DD0
(2500) 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
(2501) 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    01B30 EF4F      LDI	R20,0xFF
    01B31 E051      LDI	R21,1
    01B32 E060      LDI	R22,0
    01B33 E070      LDI	R23,0
    01B34 8DEB      LDD	R30,Y+27
    01B35 8DFC      LDD	R31,Y+28
    01B36 9636      ADIW	R30,6
    01B37 8020      LD	R2,Z
    01B38 8031      LDD	R3,Z+1
    01B39 8042      LDD	R4,Z+2
    01B3A 8053      LDD	R5,Z+3
    01B3B 2224      AND	R2,R20
    01B3C 2235      AND	R3,R21
    01B3D 2246      AND	R4,R22
    01B3E 2257      AND	R5,R23
    01B3F 9488      BCLR	0
    01B40 2022      TST	R2
    01B41 0432      CPC	R3,R2
    01B42 0442      CPC	R4,R2
    01B43 0452      CPC	R5,R2
    01B44 F009      BEQ	0x1B46
    01B45 C20B      RJMP	0x1D51
(2502) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01B46 E089      LDI	R24,0x9
    01B47 E090      LDI	R25,0
    01B48 8DEB      LDD	R30,Y+27
    01B49 8DFC      LDD	R31,Y+28
    01B4A 8106      LDD	R16,Z+6
    01B4B 8117      LDD	R17,Z+7
    01B4C 8520      LDD	R18,Z+8
    01B4D 8531      LDD	R19,Z+9
    01B4E 938A      ST	-Y,R24
    01B4F 940E 433F CALL	lsr32
    01B51 0118      MOVW	R2,R16
    01B52 0129      MOVW	R4,R18
    01B53 8DEB      LDD	R30,Y+27
    01B54 8DFC      LDD	R31,Y+28
    01B55 93AF      PUSH	R26
    01B56 93BF      PUSH	R27
    01B57 81A0      LD	R26,Z
    01B58 81B1      LDD	R27,Z+1
    01B59 01FD      MOVW	R30,R26
    01B5A 91BF      POP	R27
    01B5B 91AF      POP	R26
    01B5C 8182      LDD	R24,Z+2
    01B5D 2799      CLR	R25
    01B5E 9701      SBIW	R24,1
    01B5F 013C      MOVW	R6,R24
    01B60 2488      CLR	R8
    01B61 FC77      SBRC	R7,7
    01B62 9480      COM	R8
    01B63 2499      CLR	R9
    01B64 FC87      SBRC	R8,7
    01B65 9490      COM	R9
    01B66 2026      AND	R2,R6
    01B67 2037      AND	R3,R7
    01B68 2048      AND	R4,R8
    01B69 2059      AND	R5,R9
    01B6A 2CC2      MOV	R12,R2
(2503) 			if (!csect) {					/* On the cluster boundary? */
    01B6B 2022      TST	R2
    01B6C F009      BEQ	0x1B6E
    01B6D C0A5      RJMP	0x1C13
(2504) 				if (fp->fptr == 0) {		/* On the top of the file? */
    01B6E 8DEB      LDD	R30,Y+27
    01B6F 8DFC      LDD	R31,Y+28
    01B70 9636      ADIW	R30,6
    01B71 8020      LD	R2,Z
    01B72 8031      LDD	R3,Z+1
    01B73 8042      LDD	R4,Z+2
    01B74 8053      LDD	R5,Z+3
    01B75 9488      BCLR	0
    01B76 2022      TST	R2
    01B77 0432      CPC	R3,R2
    01B78 0442      CPC	R4,R2
    01B79 0452      CPC	R5,R2
    01B7A F571      BNE	0x1BA9
(2505) 					clst = fp->sclust;		/* Follow from the origin */
    01B7B 8DEB      LDD	R30,Y+27
    01B7C 8DFC      LDD	R31,Y+28
    01B7D 963E      ADIW	R30,0xE
    01B7E 8020      LD	R2,Z
    01B7F 8031      LDD	R3,Z+1
    01B80 8042      LDD	R4,Z+2
    01B81 8053      LDD	R5,Z+3
    01B82 8629      STD	Y+9,R2
    01B83 863A      STD	Y+10,R3
    01B84 864B      STD	Y+11,R4
    01B85 865C      STD	Y+12,R5
(2506) 					if (clst == 0)			/* When no cluster is allocated, */
    01B86 8429      LDD	R2,Y+9
    01B87 843A      LDD	R3,Y+10
    01B88 844B      LDD	R4,Y+11
    01B89 845C      LDD	R5,Y+12
    01B8A 9488      BCLR	0
    01B8B 2022      TST	R2
    01B8C 0432      CPC	R3,R2
    01B8D 0442      CPC	R4,R2
    01B8E 0452      CPC	R5,R2
    01B8F F009      BEQ	0x1B91
    01B90 C040      RJMP	0x1BD1
(2507) 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    01B91 E040      LDI	R20,0
    01B92 E050      LDI	R21,0
    01B93 E060      LDI	R22,0
    01B94 E070      LDI	R23,0
    01B95 8368      ST	Y,R22
    01B96 8379      STD	Y+1,R23
    01B97 019A      MOVW	R18,R20
    01B98 8DEB      LDD	R30,Y+27
    01B99 8DFC      LDD	R31,Y+28
    01B9A 8100      LD	R16,Z
    01B9B 8111      LDD	R17,Z+1
    01B9C 940E 0908 CALL	ff.c:create_chain
    01B9E 8709      STD	Y+9,R16
    01B9F 871A      STD	Y+10,R17
    01BA0 872B      STD	Y+11,R18
    01BA1 873C      STD	Y+12,R19
    01BA2 8DEB      LDD	R30,Y+27
    01BA3 8DFC      LDD	R31,Y+28
    01BA4 8706      STD	Z+14,R16
    01BA5 8717      STD	Z+15,R17
    01BA6 8B20      STD	Z+16,R18
    01BA7 8B31      STD	Z+17,R19
(2508) 				} else {					/* Middle or end of the file */
    01BA8 C028      RJMP	0x1BD1
(2509) #if _USE_FASTSEEK
(2510) 					if (fp->cltbl)
    01BA9 8DEB      LDD	R30,Y+27
    01BAA 8DFC      LDD	R31,Y+28
    01BAB A020      LDD	R2,Z+32
    01BAC A031      LDD	R3,Z+33
    01BAD 2022      TST	R2
    01BAE F411      BNE	0x1BB1
    01BAF 2033      TST	R3
    01BB0 F079      BEQ	0x1BC0
(2511) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    01BB1 8026      LDD	R2,Z+6
    01BB2 8037      LDD	R3,Z+7
    01BB3 8440      LDD	R4,Z+8
    01BB4 8451      LDD	R5,Z+9
    01BB5 8248      ST	Y,R4
    01BB6 8259      STD	Y+1,R5
    01BB7 0191      MOVW	R18,R2
    01BB8 018F      MOVW	R16,R30
    01BB9 940E 0A80 CALL	ff.c:clmt_clust
    01BBB 8709      STD	Y+9,R16
    01BBC 871A      STD	Y+10,R17
    01BBD 872B      STD	Y+11,R18
    01BBE 873C      STD	Y+12,R19
    01BBF C011      RJMP	0x1BD1
(2512) 					else
(2513) #endif
(2514) 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    01BC0 8DEB      LDD	R30,Y+27
    01BC1 8DFC      LDD	R31,Y+28
    01BC2 8822      LDD	R2,Z+18
    01BC3 8833      LDD	R3,Z+19
    01BC4 8844      LDD	R4,Z+20
    01BC5 8855      LDD	R5,Z+21
    01BC6 8248      ST	Y,R4
    01BC7 8259      STD	Y+1,R5
    01BC8 0191      MOVW	R18,R2
    01BC9 8100      LD	R16,Z
    01BCA 8111      LDD	R17,Z+1
    01BCB 940E 0908 CALL	ff.c:create_chain
    01BCD 8709      STD	Y+9,R16
    01BCE 871A      STD	Y+10,R17
    01BCF 872B      STD	Y+11,R18
    01BD0 873C      STD	Y+12,R19
(2515) 				}
(2516) 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    01BD1 8429      LDD	R2,Y+9
    01BD2 843A      LDD	R3,Y+10
    01BD3 844B      LDD	R4,Y+11
    01BD4 845C      LDD	R5,Y+12
    01BD5 9488      BCLR	0
    01BD6 2022      TST	R2
    01BD7 0432      CPC	R3,R2
    01BD8 0442      CPC	R4,R2
    01BD9 0452      CPC	R5,R2
    01BDA F409      BNE	0x1BDC
    01BDB C1FC      RJMP	0x1DD8
(2517) 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    01BDC E041      LDI	R20,1
    01BDD E050      LDI	R21,0
    01BDE E060      LDI	R22,0
    01BDF E070      LDI	R23,0
    01BE0 8429      LDD	R2,Y+9
    01BE1 843A      LDD	R3,Y+10
    01BE2 844B      LDD	R4,Y+11
    01BE3 845C      LDD	R5,Y+12
    01BE4 1624      CP	R2,R20
    01BE5 0635      CPC	R3,R21
    01BE6 0646      CPC	R4,R22
    01BE7 0657      CPC	R5,R23
    01BE8 F449      BNE	0x1BF2
    01BE9 8D8B      LDD	R24,Y+27
    01BEA 8D9C      LDD	R25,Y+28
    01BEB 9604      ADIW	R24,4
    01BEC 01FC      MOVW	R30,R24
    01BED 8180      LD	R24,Z
    01BEE 6880      ORI	R24,0x80
    01BEF 8380      ST	Z,R24
    01BF0 E002      LDI	R16,2
    01BF1 C206      RJMP	0x1DF8
(2518) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01BF2 EF4F      LDI	R20,0xFF
    01BF3 EF5F      LDI	R21,0xFF
    01BF4 EF6F      LDI	R22,0xFF
    01BF5 EF7F      LDI	R23,0xFF
    01BF6 8429      LDD	R2,Y+9
    01BF7 843A      LDD	R3,Y+10
    01BF8 844B      LDD	R4,Y+11
    01BF9 845C      LDD	R5,Y+12
    01BFA 1624      CP	R2,R20
    01BFB 0635      CPC	R3,R21
    01BFC 0646      CPC	R4,R22
    01BFD 0657      CPC	R5,R23
    01BFE F451      BNE	0x1C09
    01BFF 8D8B      LDD	R24,Y+27
    01C00 8D9C      LDD	R25,Y+28
    01C01 9604      ADIW	R24,4
    01C02 015C      MOVW	R10,R24
    01C03 01FC      MOVW	R30,R24
    01C04 8180      LD	R24,Z
    01C05 6880      ORI	R24,0x80
    01C06 8380      ST	Z,R24
    01C07 E001      LDI	R16,1
    01C08 C1EF      RJMP	0x1DF8
(2519) 				fp->clust = clst;			/* Update current cluster */
    01C09 8429      LDD	R2,Y+9
    01C0A 843A      LDD	R3,Y+10
    01C0B 844B      LDD	R4,Y+11
    01C0C 845C      LDD	R5,Y+12
    01C0D 8DEB      LDD	R30,Y+27
    01C0E 8DFC      LDD	R31,Y+28
    01C0F 8A22      STD	Z+18,R2
    01C10 8A33      STD	Z+19,R3
    01C11 8A44      STD	Z+20,R4
    01C12 8A55      STD	Z+21,R5
(2520) 			}
(2521) #if _FS_TINY
(2522) 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
    01C13 8DEB      LDD	R30,Y+27
    01C14 8DFC      LDD	R31,Y+28
    01C15 80A0      LD	R10,Z
    01C16 80B1      LDD	R11,Z+1
    01C17 8826      LDD	R2,Z+22
    01C18 8837      LDD	R3,Z+23
    01C19 8C40      LDD	R4,Z+24
    01C1A 8C51      LDD	R5,Z+25
    01C1B 01F5      MOVW	R30,R10
    01C1C A462      LDD	R6,Z+42
    01C1D A473      LDD	R7,Z+43
    01C1E A484      LDD	R8,Z+44
    01C1F A495      LDD	R9,Z+45
    01C20 1462      CP	R6,R2
    01C21 0473      CPC	R7,R3
    01C22 0484      CPC	R8,R4
    01C23 0495      CPC	R9,R5
    01C24 F4B9      BNE	0x1C3C
    01C25 E040      LDI	R20,0
    01C26 E050      LDI	R21,0
    01C27 E060      LDI	R22,0
    01C28 E070      LDI	R23,0
    01C29 8368      ST	Y,R22
    01C2A 8379      STD	Y+1,R23
    01C2B 019A      MOVW	R18,R20
    01C2C 018F      MOVW	R16,R30
    01C2D 940E 037D CALL	ff.c:move_window
    01C2F 2EA0      MOV	R10,R16
    01C30 2300      TST	R16
    01C31 F051      BEQ	0x1C3C
(2523) 				ABORT(fp->fs, FR_DISK_ERR);
    01C32 8D8B      LDD	R24,Y+27
    01C33 8D9C      LDD	R25,Y+28
    01C34 9604      ADIW	R24,4
    01C35 015C      MOVW	R10,R24
    01C36 01FC      MOVW	R30,R24
    01C37 8180      LD	R24,Z
    01C38 6880      ORI	R24,0x80
    01C39 8380      ST	Z,R24
    01C3A E001      LDI	R16,1
    01C3B C1BC      RJMP	0x1DF8
(2524) #else
(2525) 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
(2526) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2527) 					ABORT(fp->fs, FR_DISK_ERR);
(2528) 				fp->flag &= ~FA__DIRTY;
(2529) 			}
(2530) #endif
(2531) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01C3C 8DEB      LDD	R30,Y+27
    01C3D 8DFC      LDD	R31,Y+28
    01C3E 8822      LDD	R2,Z+18
    01C3F 8833      LDD	R3,Z+19
    01C40 8844      LDD	R4,Z+20
    01C41 8855      LDD	R5,Z+21
    01C42 8248      ST	Y,R4
    01C43 8259      STD	Y+1,R5
    01C44 0191      MOVW	R18,R2
    01C45 8100      LD	R16,Z
    01C46 8111      LDD	R17,Z+1
    01C47 940E 04F4 CALL	_clust2sect
    01C49 830D      STD	Y+5,R16
    01C4A 831E      STD	Y+6,R17
    01C4B 832F      STD	Y+7,R18
    01C4C 8738      STD	Y+8,R19
(2532) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01C4D 802D      LDD	R2,Y+5
    01C4E 803E      LDD	R3,Y+6
    01C4F 804F      LDD	R4,Y+7
    01C50 8458      LDD	R5,Y+8
    01C51 9488      BCLR	0
    01C52 2022      TST	R2
    01C53 0432      CPC	R3,R2
    01C54 0442      CPC	R4,R2
    01C55 0452      CPC	R5,R2
    01C56 F451      BNE	0x1C61
    01C57 8D8B      LDD	R24,Y+27
    01C58 8D9C      LDD	R25,Y+28
    01C59 9604      ADIW	R24,4
    01C5A 015C      MOVW	R10,R24
    01C5B 01FC      MOVW	R30,R24
    01C5C 8180      LD	R24,Z
    01C5D 6880      ORI	R24,0x80
    01C5E 8380      ST	Z,R24
    01C5F E002      LDI	R16,2
    01C60 C197      RJMP	0x1DF8
(2533) 			sect += csect;
    01C61 2C2C      MOV	R2,R12
    01C62 2433      CLR	R3
    01C63 2444      CLR	R4
    01C64 2455      CLR	R5
    01C65 806D      LDD	R6,Y+5
    01C66 807E      LDD	R7,Y+6
    01C67 808F      LDD	R8,Y+7
    01C68 8498      LDD	R9,Y+8
    01C69 0C62      ADD	R6,R2
    01C6A 1C73      ADC	R7,R3
    01C6B 1C84      ADC	R8,R4
    01C6C 1C95      ADC	R9,R5
    01C6D 826D      STD	Y+5,R6
    01C6E 827E      STD	Y+6,R7
    01C6F 828F      STD	Y+7,R8
    01C70 8698      STD	Y+8,R9
(2534) 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    01C71 E029      LDI	R18,0x9
    01C72 E030      LDI	R19,0
    01C73 8D0F      LDD	R16,Y+31
    01C74 A118      LDD	R17,Y+32
    01C75 940E 4338 CALL	lsr16
    01C77 0158      MOVW	R10,R16
(2535) 			if (cc) {						/* Write maximum contiguous sectors directly */
    01C78 3000      CPI	R16,0
    01C79 0701      CPC	R16,R17
    01C7A F409      BNE	0x1C7C
    01C7B C097      RJMP	0x1D13
(2536) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01C7C 2C2C      MOV	R2,R12
    01C7D 2433      CLR	R3
    01C7E 0E20      ADD	R2,R16
    01C7F 1E31      ADC	R3,R17
    01C80 8DEB      LDD	R30,Y+27
    01C81 8DFC      LDD	R31,Y+28
    01C82 93AF      PUSH	R26
    01C83 93BF      PUSH	R27
    01C84 81A0      LD	R26,Z
    01C85 81B1      LDD	R27,Z+1
    01C86 01FD      MOVW	R30,R26
    01C87 91BF      POP	R27
    01C88 91AF      POP	R26
    01C89 8042      LDD	R4,Z+2
    01C8A 2455      CLR	R5
    01C8B 1442      CP	R4,R2
    01C8C 0453      CPC	R5,R3
    01C8D F478      BCC	0x1C9D
(2537) 					cc = fp->fs->csize - csect;
    01C8E 2C2C      MOV	R2,R12
    01C8F 2433      CLR	R3
    01C90 8DEB      LDD	R30,Y+27
    01C91 8DFC      LDD	R31,Y+28
    01C92 93AF      PUSH	R26
    01C93 93BF      PUSH	R27
    01C94 81A0      LD	R26,Z
    01C95 81B1      LDD	R27,Z+1
    01C96 01FD      MOVW	R30,R26
    01C97 91BF      POP	R27
    01C98 91AF      POP	R26
    01C99 80A2      LDD	R10,Z+2
    01C9A 24BB      CLR	R11
    01C9B 18A2      SUB	R10,R2
    01C9C 08B3      SBC	R11,R3
(2538) 				if (disk_write(fp->fs->drv,(char*)wbuff, sect, (BYTE)cc) != RES_OK)
    01C9D 82AC      STD	Y+4,R10
    01C9E 802D      LDD	R2,Y+5
    01C9F 803E      LDD	R3,Y+6
    01CA0 804F      LDD	R4,Y+7
    01CA1 8458      LDD	R5,Y+8
    01CA2 8228      ST	Y,R2
    01CA3 8239      STD	Y+1,R3
    01CA4 824A      STD	Y+2,R4
    01CA5 825B      STD	Y+3,R5
    01CA6 0197      MOVW	R18,R14
    01CA7 8DEB      LDD	R30,Y+27
    01CA8 8DFC      LDD	R31,Y+28
    01CA9 93AF      PUSH	R26
    01CAA 93BF      PUSH	R27
    01CAB 81A0      LD	R26,Z
    01CAC 81B1      LDD	R27,Z+1
    01CAD 01FD      MOVW	R30,R26
    01CAE 91BF      POP	R27
    01CAF 91AF      POP	R26
    01CB0 8101      LDD	R16,Z+1
    01CB1 940E 0302 CALL	_disk_write
    01CB3 2EC0      MOV	R12,R16
    01CB4 2300      TST	R16
    01CB5 F051      BEQ	0x1CC0
(2539) 					ABORT(fp->fs, FR_DISK_ERR);
    01CB6 8D8B      LDD	R24,Y+27
    01CB7 8D9C      LDD	R25,Y+28
    01CB8 9604      ADIW	R24,4
    01CB9 016C      MOVW	R12,R24
    01CBA 01FC      MOVW	R30,R24
    01CBB 8180      LD	R24,Z
    01CBC 6880      ORI	R24,0x80
    01CBD 8380      ST	Z,R24
    01CBE E001      LDI	R16,1
    01CBF C138      RJMP	0x1DF8
(2540) #if _FS_TINY
(2541) 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
    01CC0 802D      LDD	R2,Y+5
    01CC1 803E      LDD	R3,Y+6
    01CC2 804F      LDD	R4,Y+7
    01CC3 8458      LDD	R5,Y+8
    01CC4 8DEB      LDD	R30,Y+27
    01CC5 8DFC      LDD	R31,Y+28
    01CC6 81A0      LD	R26,Z
    01CC7 81B1      LDD	R27,Z+1
    01CC8 969A      ADIW	R26,0x2A
    01CC9 906D      LD	R6,X+
    01CCA 907D      LD	R7,X+
    01CCB 908D      LD	R8,X+
    01CCC 909C      LD	R9,X
    01CCD 1862      SUB	R6,R2
    01CCE 0873      SBC	R7,R3
    01CCF 0884      SBC	R8,R4
    01CD0 0895      SBC	R9,R5
    01CD1 0115      MOVW	R2,R10
    01CD2 2444      CLR	R4
    01CD3 2455      CLR	R5
    01CD4 1462      CP	R6,R2
    01CD5 0473      CPC	R7,R3
    01CD6 0484      CPC	R8,R4
    01CD7 0495      CPC	R9,R5
    01CD8 F008      BCS	0x1CDA
    01CD9 C032      RJMP	0x1D0C
(2542) 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
    01CDA E080      LDI	R24,0
    01CDB E092      LDI	R25,2
    01CDC 8399      STD	Y+1,R25
    01CDD 8388      ST	Y,R24
    01CDE 80C0      LD	R12,Z
    01CDF 80D1      LDD	R13,Z+1
    01CE0 802D      LDD	R2,Y+5
    01CE1 803E      LDD	R3,Y+6
    01CE2 804F      LDD	R4,Y+7
    01CE3 8458      LDD	R5,Y+8
    01CE4 01F6      MOVW	R30,R12
    01CE5 A462      LDD	R6,Z+42
    01CE6 A473      LDD	R7,Z+43
    01CE7 A484      LDD	R8,Z+44
    01CE8 A495      LDD	R9,Z+45
    01CE9 1862      SUB	R6,R2
    01CEA 0873      SBC	R7,R3
    01CEB 0884      SBC	R8,R4
    01CEC 0895      SBC	R9,R5
    01CED E040      LDI	R20,0
    01CEE E052      LDI	R21,2
    01CEF E060      LDI	R22,0
    01CF0 E070      LDI	R23,0
    01CF1 929A      ST	-Y,R9
    01CF2 928A      ST	-Y,R8
    01CF3 927A      ST	-Y,R7
    01CF4 926A      ST	-Y,R6
    01CF5 018A      MOVW	R16,R20
    01CF6 019B      MOVW	R18,R22
    01CF7 940E 4250 CALL	empy32u|empy32s
    01CF9 0198      MOVW	R18,R16
    01CFA 0D2E      ADD	R18,R14
    01CFB 1D3F      ADC	R19,R15
    01CFC 0186      MOVW	R16,R12
    01CFD 5D02      SUBI	R16,0xD2
    01CFE 4F1F      SBCI	R17,0xFF
    01CFF 940E 0324 CALL	ff.c:mem_cpy
(2543) 					fp->fs->wflag = 0;
    01D01 2422      CLR	R2
    01D02 8DEB      LDD	R30,Y+27
    01D03 8DFC      LDD	R31,Y+28
    01D04 93AF      PUSH	R26
    01D05 93BF      PUSH	R27
    01D06 81A0      LD	R26,Z
    01D07 81B1      LDD	R27,Z+1
    01D08 01FD      MOVW	R30,R26
    01D09 91BF      POP	R27
    01D0A 91AF      POP	R26
    01D0B 8224      STD	Z+4,R2
(2544) 				}
(2545) #else
(2546) 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
(2547) 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
(2548) 					fp->flag &= ~FA__DIRTY;
(2549) 				}
(2550) #endif
(2551) 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    01D0C E000      LDI	R16,0
    01D0D E012      LDI	R17,2
    01D0E 0195      MOVW	R18,R10
    01D0F 940E 4240 CALL	empy16s
    01D11 0168      MOVW	R12,R16
(2552) 				continue;
    01D12 C099      RJMP	0x1DAC
(2553) 			}
(2554) #if _FS_TINY
(2555) 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
    01D13 8DEB      LDD	R30,Y+27
    01D14 8DFC      LDD	R31,Y+28
    01D15 8422      LDD	R2,Z+10
    01D16 8433      LDD	R3,Z+11
    01D17 8444      LDD	R4,Z+12
    01D18 8455      LDD	R5,Z+13
    01D19 8066      LDD	R6,Z+6
    01D1A 8077      LDD	R7,Z+7
    01D1B 8480      LDD	R8,Z+8
    01D1C 8491      LDD	R9,Z+9
    01D1D 1462      CP	R6,R2
    01D1E 0473      CPC	R7,R3
    01D1F 0484      CPC	R8,R4
    01D20 0495      CPC	R9,R5
    01D21 F128      BCS	0x1D47
(2556) 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    01D22 E040      LDI	R20,0
    01D23 E050      LDI	R21,0
    01D24 E060      LDI	R22,0
    01D25 E070      LDI	R23,0
    01D26 8368      ST	Y,R22
    01D27 8379      STD	Y+1,R23
    01D28 019A      MOVW	R18,R20
    01D29 8100      LD	R16,Z
    01D2A 8111      LDD	R17,Z+1
    01D2B 940E 037D CALL	ff.c:move_window
    01D2D 2EA0      MOV	R10,R16
    01D2E 2300      TST	R16
    01D2F F051      BEQ	0x1D3A
    01D30 8D8B      LDD	R24,Y+27
    01D31 8D9C      LDD	R25,Y+28
    01D32 9604      ADIW	R24,4
    01D33 015C      MOVW	R10,R24
    01D34 01FC      MOVW	R30,R24
    01D35 8180      LD	R24,Z
    01D36 6880      ORI	R24,0x80
    01D37 8380      ST	Z,R24
    01D38 E001      LDI	R16,1
    01D39 C0BE      RJMP	0x1DF8
(2557) 				fp->fs->winsect = sect;
    01D3A 802D      LDD	R2,Y+5
    01D3B 803E      LDD	R3,Y+6
    01D3C 804F      LDD	R4,Y+7
    01D3D 8458      LDD	R5,Y+8
    01D3E 8DEB      LDD	R30,Y+27
    01D3F 8DFC      LDD	R31,Y+28
    01D40 81A0      LD	R26,Z
    01D41 81B1      LDD	R27,Z+1
    01D42 969A      ADIW	R26,0x2A
    01D43 922D      ST	X+,R2
    01D44 923D      ST	X+,R3
    01D45 924D      ST	X+,R4
    01D46 925C      ST	X,R5
(2558) 			}
(2559) #else
(2560) 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
(2561) 				if (fp->fptr < fp->fsize &&
(2562) 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
(2563) 						ABORT(fp->fs, FR_DISK_ERR);
(2564) 			}
(2565) #endif
(2566) 			fp->dsect = sect;
    01D47 802D      LDD	R2,Y+5
    01D48 803E      LDD	R3,Y+6
    01D49 804F      LDD	R4,Y+7
    01D4A 8458      LDD	R5,Y+8
    01D4B 8DEB      LDD	R30,Y+27
    01D4C 8DFC      LDD	R31,Y+28
    01D4D 8A26      STD	Z+22,R2
    01D4E 8A37      STD	Z+23,R3
    01D4F 8E40      STD	Z+24,R4
    01D50 8E51      STD	Z+25,R5
(2567) 		}
(2568) 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    01D51 EF4F      LDI	R20,0xFF
    01D52 E051      LDI	R21,1
    01D53 E060      LDI	R22,0
    01D54 E070      LDI	R23,0
    01D55 8DEB      LDD	R30,Y+27
    01D56 8DFC      LDD	R31,Y+28
    01D57 8026      LDD	R2,Z+6
    01D58 8037      LDD	R3,Z+7
    01D59 8440      LDD	R4,Z+8
    01D5A 8451      LDD	R5,Z+9
    01D5B 2224      AND	R2,R20
    01D5C 2235      AND	R3,R21
    01D5D 2246      AND	R4,R22
    01D5E 2257      AND	R5,R23
    01D5F E040      LDI	R20,0
    01D60 E052      LDI	R21,2
    01D61 E060      LDI	R22,0
    01D62 E070      LDI	R23,0
    01D63 1942      SUB	R20,R2
    01D64 0953      SBC	R21,R3
    01D65 0964      SBC	R22,R4
    01D66 0975      SBC	R23,R5
    01D67 016A      MOVW	R12,R20
(2569) 		if (wcnt > btw) wcnt = btw;
    01D68 8C0F      LDD	R0,Y+31
    01D69 A018      LDD	R1,Y+32
    01D6A 1604      CP	R0,R20
    01D6B 0615      CPC	R1,R21
    01D6C F408      BCC	0x1D6E
    01D6D 0160      MOVW	R12,R0
(2570) #if _FS_TINY
(2571) 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
    01D6E 8DEB      LDD	R30,Y+27
    01D6F 8DFC      LDD	R31,Y+28
    01D70 8826      LDD	R2,Z+22
    01D71 8837      LDD	R3,Z+23
    01D72 8C40      LDD	R4,Z+24
    01D73 8C51      LDD	R5,Z+25
    01D74 8248      ST	Y,R4
    01D75 8259      STD	Y+1,R5
    01D76 0191      MOVW	R18,R2
    01D77 8100      LD	R16,Z
    01D78 8111      LDD	R17,Z+1
    01D79 940E 037D CALL	ff.c:move_window
    01D7B 2EA0      MOV	R10,R16
    01D7C 2300      TST	R16
    01D7D F051      BEQ	0x1D88
(2572) 			ABORT(fp->fs, FR_DISK_ERR);
    01D7E 8D8B      LDD	R24,Y+27
    01D7F 8D9C      LDD	R25,Y+28
    01D80 9604      ADIW	R24,4
    01D81 015C      MOVW	R10,R24
    01D82 01FC      MOVW	R30,R24
    01D83 8180      LD	R24,Z
    01D84 6880      ORI	R24,0x80
    01D85 8380      ST	Z,R24
    01D86 E001      LDI	R16,1
    01D87 C070      RJMP	0x1DF8
(2573) 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    01D88 82D9      STD	Y+1,R13
    01D89 82C8      ST	Y,R12
    01D8A 0197      MOVW	R18,R14
    01D8B EF4F      LDI	R20,0xFF
    01D8C E051      LDI	R21,1
    01D8D E060      LDI	R22,0
    01D8E E070      LDI	R23,0
    01D8F 8DEB      LDD	R30,Y+27
    01D90 8DFC      LDD	R31,Y+28
    01D91 8026      LDD	R2,Z+6
    01D92 8037      LDD	R3,Z+7
    01D93 8440      LDD	R4,Z+8
    01D94 8451      LDD	R5,Z+9
    01D95 2224      AND	R2,R20
    01D96 2235      AND	R3,R21
    01D97 2246      AND	R4,R22
    01D98 2257      AND	R5,R23
    01D99 0181      MOVW	R16,R2
    01D9A 8180      LD	R24,Z
    01D9B 8191      LDD	R25,Z+1
    01D9C 968E      ADIW	R24,0x2E
    01D9D 0F08      ADD	R16,R24
    01D9E 1F19      ADC	R17,R25
    01D9F 940E 0324 CALL	ff.c:mem_cpy
(2574) 		fp->fs->wflag = 1;
    01DA1 E081      LDI	R24,1
    01DA2 8DEB      LDD	R30,Y+27
    01DA3 8DFC      LDD	R31,Y+28
    01DA4 93AF      PUSH	R26
    01DA5 93BF      PUSH	R27
    01DA6 81A0      LD	R26,Z
    01DA7 81B1      LDD	R27,Z+1
    01DA8 01FD      MOVW	R30,R26
    01DA9 91BF      POP	R27
    01DAA 91AF      POP	R26
    01DAB 8384      STD	Z+4,R24
    01DAC 0CEC      ADD	R14,R12
    01DAD 1CFD      ADC	R15,R13
    01DAE 8D8B      LDD	R24,Y+27
    01DAF 8D9C      LDD	R25,Y+28
    01DB0 9606      ADIW	R24,6
    01DB1 015C      MOVW	R10,R24
    01DB2 0116      MOVW	R2,R12
    01DB3 2444      CLR	R4
    01DB4 2455      CLR	R5
    01DB5 01FC      MOVW	R30,R24
    01DB6 8060      LD	R6,Z
    01DB7 8071      LDD	R7,Z+1
    01DB8 8082      LDD	R8,Z+2
    01DB9 8093      LDD	R9,Z+3
    01DBA 0C62      ADD	R6,R2
    01DBB 1C73      ADC	R7,R3
    01DBC 1C84      ADC	R8,R4
    01DBD 1C95      ADC	R9,R5
    01DBE 8260      ST	Z,R6
    01DBF 8271      STD	Z+1,R7
    01DC0 8282      STD	Z+2,R8
    01DC1 8293      STD	Z+3,R9
    01DC2 A1E9      LDD	R30,Y+33
    01DC3 A1FA      LDD	R31,Y+34
    01DC4 8020      LD	R2,Z
    01DC5 8031      LDD	R3,Z+1
    01DC6 0C2C      ADD	R2,R12
    01DC7 1C3D      ADC	R3,R13
    01DC8 8231      STD	Z+1,R3
    01DC9 8220      ST	Z,R2
    01DCA 8C0F      LDD	R0,Y+31
    01DCB A018      LDD	R1,Y+32
    01DCC 180C      SUB	R0,R12
    01DCD 081D      SBC	R1,R13
    01DCE A218      STD	Y+32,R1
    01DCF 8E0F      STD	Y+31,R0
    01DD0 8C0F      LDD	R0,Y+31
    01DD1 A018      LDD	R1,Y+32
    01DD2 2000      TST	R0
    01DD3 F009      BEQ	0x1DD5
    01DD4 CD5B      RJMP	0x1B30
    01DD5 2011      TST	R1
    01DD6 F009      BEQ	0x1DD8
    01DD7 CD58      RJMP	0x1B30
(2575) #else
(2576) 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
(2577) 		fp->flag |= FA__DIRTY;
(2578) #endif
(2579) 	}
(2580) 
(2581) 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    01DD8 8DEB      LDD	R30,Y+27
    01DD9 8DFC      LDD	R31,Y+28
    01DDA 8422      LDD	R2,Z+10
    01DDB 8433      LDD	R3,Z+11
    01DDC 8444      LDD	R4,Z+12
    01DDD 8455      LDD	R5,Z+13
    01DDE 8066      LDD	R6,Z+6
    01DDF 8077      LDD	R7,Z+7
    01DE0 8480      LDD	R8,Z+8
    01DE1 8491      LDD	R9,Z+9
    01DE2 1426      CP	R2,R6
    01DE3 0437      CPC	R3,R7
    01DE4 0448      CPC	R4,R8
    01DE5 0459      CPC	R5,R9
    01DE6 F440      BCC	0x1DEF
    01DE7 8026      LDD	R2,Z+6
    01DE8 8037      LDD	R3,Z+7
    01DE9 8440      LDD	R4,Z+8
    01DEA 8451      LDD	R5,Z+9
    01DEB 8622      STD	Z+10,R2
    01DEC 8633      STD	Z+11,R3
    01DED 8644      STD	Z+12,R4
    01DEE 8655      STD	Z+13,R5
(2582) 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    01DEF 8D8B      LDD	R24,Y+27
    01DF0 8D9C      LDD	R25,Y+28
    01DF1 9604      ADIW	R24,4
    01DF2 015C      MOVW	R10,R24
    01DF3 01FC      MOVW	R30,R24
    01DF4 8180      LD	R24,Z
    01DF5 6280      ORI	R24,0x20
    01DF6 8380      ST	Z,R24
(2583) 
(2584) 	LEAVE_FF(fp->fs, FR_OK);
    01DF7 2700      CLR	R16
    01DF8 9661      ADIW	R28,0x11
    01DF9 940E 4299 CALL	pop_xgsetF0FC
    01DFB 9624      ADIW	R28,4
    01DFC 9508      RET
_f_sync:
  tim                  --> Y,+2
  dir                  --> R22
  res                  --> R10
  fp                   --> R20
    01DFD 940E 42DF CALL	push_xgsetF03C
    01DFF 01A8      MOVW	R20,R16
    01E00 9726      SBIW	R28,6
(2585) }
(2586) 
(2587) 
(2588) 
(2589) 
(2590) /*-----------------------------------------------------------------------*/
(2591) /* Synchronize the File Object                                           */
(2592) /*-----------------------------------------------------------------------*/
(2593) 
(2594) FRESULT f_sync (
(2595) 	FIL *fp		/* Pointer to the file object */
(2596) )
(2597) {
(2598) 	FRESULT res;
(2599) 	DWORD tim;
(2600) 	BYTE *dir;
(2601) 
(2602) 
(2603) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01E01 01FA      MOVW	R30,R20
    01E02 8122      LDD	R18,Z+2
    01E03 8133      LDD	R19,Z+3
    01E04 8100      LD	R16,Z
    01E05 8111      LDD	R17,Z+1
    01E06 D88E      RCALL	ff.c:validate
    01E07 2EA0      MOV	R10,R16
(2604) 	if (res == FR_OK) {
    01E08 2300      TST	R16
    01E09 F009      BEQ	0x1E0B
    01E0A C09F      RJMP	0x1EAA
(2605) 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    01E0B 01FA      MOVW	R30,R20
    01E0C 8024      LDD	R2,Z+4
    01E0D FE25      SBRS	R2,5
    01E0E C09B      RJMP	0x1EAA
(2606) #if !_FS_TINY	/* Write-back dirty buffer */
(2607) 			if (fp->flag & FA__DIRTY) {
(2608) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2609) 					LEAVE_FF(fp->fs, FR_DISK_ERR);
(2610) 				fp->flag &= ~FA__DIRTY;
(2611) 			}
(2612) #endif
(2613) 			/* Update the directory entry */
(2614) 			res = move_window(fp->fs, fp->dir_sect);
    01E0F 8C22      LDD	R2,Z+26
    01E10 8C33      LDD	R3,Z+27
    01E11 8C44      LDD	R4,Z+28
    01E12 8C55      LDD	R5,Z+29
    01E13 8248      ST	Y,R4
    01E14 8259      STD	Y+1,R5
    01E15 0191      MOVW	R18,R2
    01E16 8100      LD	R16,Z
    01E17 8111      LDD	R17,Z+1
    01E18 940E 037D CALL	ff.c:move_window
    01E1A 2EA0      MOV	R10,R16
(2615) 			if (res == FR_OK) {
    01E1B 2300      TST	R16
    01E1C F009      BEQ	0x1E1E
    01E1D C08C      RJMP	0x1EAA
(2616) 				dir = fp->dir_ptr;
    01E1E 01FA      MOVW	R30,R20
    01E1F 8D66      LDD	R22,Z+30
    01E20 8D77      LDD	R23,Z+31
(2617) 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    01E21 01CB      MOVW	R24,R22
    01E22 960B      ADIW	R24,0xB
    01E23 01FC      MOVW	R30,R24
    01E24 8180      LD	R24,Z
    01E25 6280      ORI	R24,0x20
    01E26 8380      ST	Z,R24
(2618) 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    01E27 01FA      MOVW	R30,R20
    01E28 8422      LDD	R2,Z+10
    01E29 8433      LDD	R3,Z+11
    01E2A 8444      LDD	R4,Z+12
    01E2B 8455      LDD	R5,Z+13
    01E2C 01FB      MOVW	R30,R22
    01E2D 8E24      STD	Z+28,R2
    01E2E 01FA      MOVW	R30,R20
    01E2F 8422      LDD	R2,Z+10
    01E30 8433      LDD	R3,Z+11
    01E31 2C23      MOV	R2,R3
    01E32 2433      CLR	R3
    01E33 01FB      MOVW	R30,R22
    01E34 8E25      STD	Z+29,R2
    01E35 01FA      MOVW	R30,R20
    01E36 8422      LDD	R2,Z+10
    01E37 8433      LDD	R3,Z+11
    01E38 8444      LDD	R4,Z+12
    01E39 8455      LDD	R5,Z+13
    01E3A 0112      MOVW	R2,R4
    01E3B 2444      CLR	R4
    01E3C 2455      CLR	R5
    01E3D 01FB      MOVW	R30,R22
    01E3E 8E26      STD	Z+30,R2
    01E3F E188      LDI	R24,0x18
    01E40 E090      LDI	R25,0
    01E41 01FA      MOVW	R30,R20
    01E42 8502      LDD	R16,Z+10
    01E43 8513      LDD	R17,Z+11
    01E44 8524      LDD	R18,Z+12
    01E45 8535      LDD	R19,Z+13
    01E46 938A      ST	-Y,R24
    01E47 940E 433F CALL	lsr32
    01E49 01FB      MOVW	R30,R22
    01E4A 8F07      STD	Z+31,R16
(2619) 				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    01E4B 01FA      MOVW	R30,R20
    01E4C 8426      LDD	R2,Z+14
    01E4D 8437      LDD	R3,Z+15
    01E4E 8840      LDD	R4,Z+16
    01E4F 8851      LDD	R5,Z+17
    01E50 01FB      MOVW	R30,R22
    01E51 8E22      STD	Z+26,R2
    01E52 01FA      MOVW	R30,R20
    01E53 8426      LDD	R2,Z+14
    01E54 8437      LDD	R3,Z+15
    01E55 2C23      MOV	R2,R3
    01E56 2433      CLR	R3
    01E57 01FB      MOVW	R30,R22
    01E58 8E23      STD	Z+27,R2
    01E59 01FA      MOVW	R30,R20
    01E5A 8426      LDD	R2,Z+14
    01E5B 8437      LDD	R3,Z+15
    01E5C 8840      LDD	R4,Z+16
    01E5D 8851      LDD	R5,Z+17
    01E5E 0112      MOVW	R2,R4
    01E5F 2444      CLR	R4
    01E60 2455      CLR	R5
    01E61 01FB      MOVW	R30,R22
    01E62 8A24      STD	Z+20,R2
    01E63 01FA      MOVW	R30,R20
    01E64 8426      LDD	R2,Z+14
    01E65 8437      LDD	R3,Z+15
    01E66 8840      LDD	R4,Z+16
    01E67 8851      LDD	R5,Z+17
    01E68 0112      MOVW	R2,R4
    01E69 2C23      MOV	R2,R3
    01E6A 2433      CLR	R3
    01E6B 01FB      MOVW	R30,R22
    01E6C 8A25      STD	Z+21,R2
(2620) 				tim = get_fattime();						/* Update updated time */
    01E6D 940E 031F CALL	_get_fattime
    01E6F 830A      STD	Y+2,R16
    01E70 831B      STD	Y+3,R17
    01E71 832C      STD	Y+4,R18
    01E72 833D      STD	Y+5,R19
(2621) 				ST_DWORD(dir+DIR_WrtTime, tim);
    01E73 802A      LDD	R2,Y+2
    01E74 803B      LDD	R3,Y+3
    01E75 804C      LDD	R4,Y+4
    01E76 805D      LDD	R5,Y+5
    01E77 01FB      MOVW	R30,R22
    01E78 8A26      STD	Z+22,R2
    01E79 2C23      MOV	R2,R3
    01E7A 2433      CLR	R3
    01E7B 9677      ADIW	R30,0x17
    01E7C 8220      ST	Z,R2
    01E7D 802A      LDD	R2,Y+2
    01E7E 803B      LDD	R3,Y+3
    01E7F 804C      LDD	R4,Y+4
    01E80 805D      LDD	R5,Y+5
    01E81 0112      MOVW	R2,R4
    01E82 2444      CLR	R4
    01E83 2455      CLR	R5
    01E84 01FB      MOVW	R30,R22
    01E85 9678      ADIW	R30,0x18
    01E86 8220      ST	Z,R2
    01E87 E188      LDI	R24,0x18
    01E88 E090      LDI	R25,0
    01E89 810A      LDD	R16,Y+2
    01E8A 811B      LDD	R17,Y+3
    01E8B 812C      LDD	R18,Y+4
    01E8C 813D      LDD	R19,Y+5
    01E8D 938A      ST	-Y,R24
    01E8E 940E 433F CALL	lsr32
    01E90 01FB      MOVW	R30,R22
    01E91 8F01      STD	Z+25,R16
(2622) 				fp->flag &= ~FA__WRITTEN;
    01E92 01BA      MOVW	R22,R20
    01E93 5F6C      SUBI	R22,0xFC
    01E94 4F7F      SBCI	R23,0xFF
    01E95 01FB      MOVW	R30,R22
    01E96 8180      LD	R24,Z
    01E97 7D8F      ANDI	R24,0xDF
    01E98 8380      ST	Z,R24
(2623) 				fp->fs->wflag = 1;
    01E99 E081      LDI	R24,1
    01E9A 01FA      MOVW	R30,R20
    01E9B 93AF      PUSH	R26
    01E9C 93BF      PUSH	R27
    01E9D 81A0      LD	R26,Z
    01E9E 81B1      LDD	R27,Z+1
    01E9F 01FD      MOVW	R30,R26
    01EA0 91BF      POP	R27
    01EA1 91AF      POP	R26
    01EA2 8384      STD	Z+4,R24
(2624) 				res = sync(fp->fs);
    01EA3 01FA      MOVW	R30,R20
    01EA4 8100      LD	R16,Z
    01EA5 8111      LDD	R17,Z+1
    01EA6 940E 041F CALL	ff.c:sync
    01EA8 2EC0      MOV	R12,R16
    01EA9 2CAC      MOV	R10,R12
(2625) 			}
(2626) 		}
(2627) 	}
(2628) 
(2629) 	LEAVE_FF(fp->fs, res);
    01EAA 2D0A      MOV	R16,R10
    01EAB 9626      ADIW	R28,6
    01EAC 940C 42E8 JMP	pop_xgsetF03C
_f_close:
  res                  --> R10
  fp                   --> R12
    01EAE 940E 42AA CALL	push_xgset003C
    01EB0 0168      MOVW	R12,R16
(2630) }
(2631) 
(2632) #endif /* !_FS_READONLY */
(2633) 
(2634) 
(2635) 
(2636) 
(2637) /*-----------------------------------------------------------------------*/
(2638) /* Close File                                                            */
(2639) /*-----------------------------------------------------------------------*/
(2640) 
(2641) FRESULT f_close (
(2642) 	FIL *fp		/* Pointer to the file object to be closed */
(2643) )
(2644) {
(2645) 	FRESULT res;
(2646) 
(2647) #if _FS_READONLY
(2648) 	FATFS *fs = fp->fs;
(2649) 	res = validate(fs, fp->id);
(2650) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
(2651) 	LEAVE_FF(fs, res);
(2652) 
(2653) #else
(2654) 	res = f_sync(fp);		/* Flush cached data */
    01EB1 0186      MOVW	R16,R12
    01EB2 DF4A      RCALL	_f_sync
    01EB3 2EA0      MOV	R10,R16
(2655) #if _FS_SHARE
(2656) 	if (res == FR_OK) {		/* Decrement open counter */
(2657) #if _FS_REENTRANT
(2658) 		res = validate(fp->fs, fp->id);
(2659) 		if (res == FR_OK) {
(2660) 			res = dec_lock(fp->lockid);	
(2661) 			unlock_fs(fp->fs, FR_OK);
(2662) 		}
(2663) #else
(2664) 		res = dec_lock(fp->lockid);
(2665) #endif
(2666) 	}
(2667) #endif
(2668) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    01EB4 2300      TST	R16
    01EB5 F429      BNE	0x1EBB
    01EB6 2422      CLR	R2
    01EB7 2433      CLR	R3
    01EB8 01F6      MOVW	R30,R12
    01EB9 8231      STD	Z+1,R3
    01EBA 8220      ST	Z,R2
(2669) 	return res;
    01EBB 2D0A      MOV	R16,R10
    01EBC 940C 4284 JMP	pop_xgset003C
_f_lseek:
  ifptr                --> Y,+14
  nsect                --> Y,+10
  bcs                  --> Y,+6
  clst                 --> Y,+2
  dsc                  --> Y,+26
  tlen                 --> Y,+22
  tbl                  --> R14
  tcl                  --> Y,+18
  ulen                 --> Y,+14
  ncl                  --> Y,+10
  pcl                  --> Y,+6
  cl                   --> Y,+2
  res                  --> R10
  ofs                  --> Y,+42
  fp                   --> Y,+40
    01EBE 940E 415F CALL	push_arg4
    01EC0 940E 42A4 CALL	push_xgsetF0FC
    01EC2 976E      SBIW	R28,0x1E
(2670) #endif
(2671) }
(2672) 
(2673) 
(2674) 
(2675) 
(2676) /*-----------------------------------------------------------------------*/
(2677) /* Current Drive/Directory Handlings                                     */
(2678) /*-----------------------------------------------------------------------*/
(2679) 
(2680) #if _FS_RPATH >= 1
(2681) 
(2682) FRESULT f_chdrive (
(2683) 	BYTE drv		/* Drive number */
(2684) )
(2685) {
(2686) 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
(2687) 
(2688) 	CurrVol = drv;
(2689) 
(2690) 	return FR_OK;
(2691) }
(2692) 
(2693) 
(2694) 
(2695) FRESULT f_chdir (
(2696) 	const TCHAR *path	/* Pointer to the directory path */
(2697) )
(2698) {
(2699) 	FRESULT res;
(2700) 	DIR dj;
(2701) 	DEF_NAMEBUF;
(2702) 
(2703) 
(2704) 	res = chk_mounted(&path, &dj.fs, 0);
(2705) 	if (res == FR_OK) {
(2706) 		INIT_BUF(dj);
(2707) 		res = follow_path(&dj, path);		/* Follow the path */
(2708) 		FREE_BUF();
(2709) 		if (res == FR_OK) {					/* Follow completed */
(2710) 			if (!dj.dir) {
(2711) 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
(2712) 			} else {
(2713) 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
(2714) 					dj.fs->cdir = LD_CLUST(dj.dir);
(2715) 				else
(2716) 					res = FR_NO_PATH;		/* Reached but a file */
(2717) 			}
(2718) 		}
(2719) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
(2720) 	}
(2721) 
(2722) 	LEAVE_FF(dj.fs, res);
(2723) }
(2724) 
(2725) 
(2726) #if _FS_RPATH >= 2
(2727) FRESULT f_getcwd (
(2728) 	TCHAR *path,	/* Pointer to the directory path */
(2729) 	UINT sz_path	/* Size of path */
(2730) )
(2731) {
(2732) 	FRESULT res;
(2733) 	DIR dj;
(2734) 	UINT i, n;
(2735) 	DWORD ccl;
(2736) 	TCHAR *tp;
(2737) 	FILINFO fno;
(2738) 	DEF_NAMEBUF;
(2739) 
(2740) 
(2741) 	*path = 0;
(2742) 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
(2743) 	if (res == FR_OK) {
(2744) 		INIT_BUF(dj);
(2745) 		i = sz_path;		/* Bottom of buffer (dir stack base) */
(2746) 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
(2747) 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
(2748) 			res = dir_sdi(&dj, 1);			/* Get parent dir */
(2749) 			if (res != FR_OK) break;
(2750) 			res = dir_read(&dj);
(2751) 			if (res != FR_OK) break;
(2752) 			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
(2753) 			res = dir_sdi(&dj, 0);
(2754) 			if (res != FR_OK) break;
(2755) 			do {							/* Find the entry links to the child dir */
(2756) 				res = dir_read(&dj);
(2757) 				if (res != FR_OK) break;
(2758) 				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
(2759) 				res = dir_next(&dj, 0);	
(2760) 			} while (res == FR_OK);
(2761) 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
(2762) 			if (res != FR_OK) break;
(2763) #if _USE_LFN
(2764) 			fno.lfname = path;
(2765) 			fno.lfsize = i;
(2766) #endif
(2767) 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
(2768) 			tp = fno.fname;
(2769) 			if (_USE_LFN && *path) tp = path;
(2770) 			for (n = 0; tp[n]; n++) ;
(2771) 			if (i < n + 3) {
(2772) 				res = FR_NOT_ENOUGH_CORE; break;
(2773) 			}
(2774) 			while (n) path[--i] = tp[--n];
(2775) 			path[--i] = '/';
(2776) 		}
(2777) 		tp = path;
(2778) 		if (res == FR_OK) {
(2779) 			*tp++ = '0' + CurrVol;			/* Put drive number */
(2780) 			*tp++ = ':';
(2781) 			if (i == sz_path) {				/* Root-dir */
(2782) 				*tp++ = '/';
(2783) 			} else {						/* Sub-dir */
(2784) 				do		/* Add stacked path str */
(2785) 					*tp++ = path[i++];
(2786) 				while (i < sz_path);
(2787) 			}
(2788) 		}
(2789) 		*tp = 0;
(2790) 		FREE_BUF();
(2791) 	}
(2792) 
(2793) 	LEAVE_FF(dj.fs, res);
(2794) }
(2795) #endif /* _FS_RPATH >= 2 */
(2796) #endif /* _FS_RPATH >= 1 */
(2797) 
(2798) 
(2799) 
(2800) #if _FS_MINIMIZE <= 2
(2801) /*-----------------------------------------------------------------------*/
(2802) /* Seek File R/W Pointer                                                 */
(2803) /*-----------------------------------------------------------------------*/
(2804) 
(2805) FRESULT f_lseek (
(2806) 	FIL *fp,		/* Pointer to the file object */
(2807) 	DWORD ofs		/* File pointer from top of file */
(2808) )
(2809) {
(2810) 	FRESULT res;
(2811) 
(2812) 
(2813) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01EC3 A5E8      LDD	R30,Y+40
    01EC4 A5F9      LDD	R31,Y+41
    01EC5 8122      LDD	R18,Z+2
    01EC6 8133      LDD	R19,Z+3
    01EC7 8100      LD	R16,Z
    01EC8 8111      LDD	R17,Z+1
    01EC9 940E 1695 CALL	ff.c:validate
    01ECB 2EA0      MOV	R10,R16
(2814) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01ECC 2300      TST	R16
    01ECD F009      BEQ	0x1ECF
    01ECE C4A7      RJMP	0x2376
(2815) 	if (fp->flag & FA__ERROR)			/* Check abort flag */
    01ECF A5E8      LDD	R30,Y+40
    01ED0 A5F9      LDD	R31,Y+41
    01ED1 8024      LDD	R2,Z+4
    01ED2 FE27      SBRS	R2,7
    01ED3 C002      RJMP	0x1ED6
(2816) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01ED4 E002      LDI	R16,2
    01ED5 C4A0      RJMP	0x2376
(2817) 
(2818) #if _USE_FASTSEEK
(2819) 	if (fp->cltbl) {	/* Fast seek */
    01ED6 A5E8      LDD	R30,Y+40
    01ED7 A5F9      LDD	R31,Y+41
    01ED8 96B0      ADIW	R30,0x20
    01ED9 8020      LD	R2,Z
    01EDA 8031      LDD	R3,Z+1
    01EDB 2022      TST	R2
    01EDC F419      BNE	0x1EE0
    01EDD 2033      TST	R3
    01EDE F409      BNE	0x1EE0
    01EDF C1E3      RJMP	0x20C3
(2820) 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
(2821) 
(2822) 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
    01EE0 EF4F      LDI	R20,0xFF
    01EE1 EF5F      LDI	R21,0xFF
    01EE2 EF6F      LDI	R22,0xFF
    01EE3 EF7F      LDI	R23,0xFF
    01EE4 A42A      LDD	R2,Y+42
    01EE5 A43B      LDD	R3,Y+43
    01EE6 A44C      LDD	R4,Y+44
    01EE7 A45D      LDD	R5,Y+45
    01EE8 1624      CP	R2,R20
    01EE9 0635      CPC	R3,R21
    01EEA 0646      CPC	R4,R22
    01EEB 0657      CPC	R5,R23
    01EEC F009      BEQ	0x1EEE
    01EED C109      RJMP	0x1FF7
(2823) 			tbl = fp->cltbl;
    01EEE A5E8      LDD	R30,Y+40
    01EEF A5F9      LDD	R31,Y+41
    01EF0 A0E0      LDD	R14,Z+32
    01EF1 A0F1      LDD	R15,Z+33
(2824) 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
    01EF2 01F7      MOVW	R30,R14
    01EF3 9021      LD	R2,Z+
    01EF4 9031      LD	R3,Z+
    01EF5 9041      LD	R4,Z+
    01EF6 9051      LD	R5,Z+
    01EF7 017F      MOVW	R14,R30
    01EF8 8A2E      STD	Y+22,R2
    01EF9 8A3F      STD	Y+23,R3
    01EFA 8E48      STD	Y+24,R4
    01EFB 8E59      STD	Y+25,R5
    01EFC E082      LDI	R24,2
    01EFD 878E      STD	Y+14,R24
    01EFE E080      LDI	R24,0
    01EFF 878F      STD	Y+15,R24
    01F00 8B88      STD	Y+16,R24
    01F01 8B89      STD	Y+17,R24
(2825) 			cl = fp->sclust;			/* Top of the chain */
    01F02 A5E8      LDD	R30,Y+40
    01F03 A5F9      LDD	R31,Y+41
    01F04 963E      ADIW	R30,0xE
    01F05 8020      LD	R2,Z
    01F06 8031      LDD	R3,Z+1
    01F07 8042      LDD	R4,Z+2
    01F08 8053      LDD	R5,Z+3
    01F09 822A      STD	Y+2,R2
    01F0A 823B      STD	Y+3,R3
    01F0B 824C      STD	Y+4,R4
    01F0C 825D      STD	Y+5,R5
(2826) 			if (cl) {
    01F0D 802A      LDD	R2,Y+2
    01F0E 803B      LDD	R3,Y+3
    01F0F 804C      LDD	R4,Y+4
    01F10 805D      LDD	R5,Y+5
    01F11 9488      BCLR	0
    01F12 2022      TST	R2
    01F13 0432      CPC	R3,R2
    01F14 0442      CPC	R4,R2
    01F15 0452      CPC	R5,R2
    01F16 F409      BNE	0x1F18
    01F17 C0BB      RJMP	0x1FD3
(2827) 				do {
(2828) 					/* Get a fragment */
(2829) 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
    01F18 802A      LDD	R2,Y+2
    01F19 803B      LDD	R3,Y+3
    01F1A 804C      LDD	R4,Y+4
    01F1B 805D      LDD	R5,Y+5
    01F1C 8A2A      STD	Y+18,R2
    01F1D 8A3B      STD	Y+19,R3
    01F1E 8A4C      STD	Y+20,R4
    01F1F 8A5D      STD	Y+21,R5
    01F20 E080      LDI	R24,0
    01F21 878A      STD	Y+10,R24
    01F22 878B      STD	Y+11,R24
    01F23 878C      STD	Y+12,R24
    01F24 878D      STD	Y+13,R24
    01F25 E042      LDI	R20,2
    01F26 E050      LDI	R21,0
    01F27 E060      LDI	R22,0
    01F28 E070      LDI	R23,0
    01F29 842E      LDD	R2,Y+14
    01F2A 843F      LDD	R3,Y+15
    01F2B 8848      LDD	R4,Y+16
    01F2C 8859      LDD	R5,Y+17
    01F2D 0E24      ADD	R2,R20
    01F2E 1E35      ADC	R3,R21
    01F2F 1E46      ADC	R4,R22
    01F30 1E57      ADC	R5,R23
    01F31 862E      STD	Y+14,R2
    01F32 863F      STD	Y+15,R3
    01F33 8A48      STD	Y+16,R4
    01F34 8A59      STD	Y+17,R5
(2830) 					do {
(2831) 						pcl = cl; ncl++;
    01F35 802A      LDD	R2,Y+2
    01F36 803B      LDD	R3,Y+3
    01F37 804C      LDD	R4,Y+4
    01F38 805D      LDD	R5,Y+5
    01F39 822E      STD	Y+6,R2
    01F3A 823F      STD	Y+7,R3
    01F3B 8648      STD	Y+8,R4
    01F3C 8659      STD	Y+9,R5
    01F3D E041      LDI	R20,1
    01F3E E050      LDI	R21,0
    01F3F E060      LDI	R22,0
    01F40 E070      LDI	R23,0
    01F41 842A      LDD	R2,Y+10
    01F42 843B      LDD	R3,Y+11
    01F43 844C      LDD	R4,Y+12
    01F44 845D      LDD	R5,Y+13
    01F45 0E24      ADD	R2,R20
    01F46 1E35      ADC	R3,R21
    01F47 1E46      ADC	R4,R22
    01F48 1E57      ADC	R5,R23
    01F49 862A      STD	Y+10,R2
    01F4A 863B      STD	Y+11,R3
    01F4B 864C      STD	Y+12,R4
    01F4C 865D      STD	Y+13,R5
(2832) 						cl = get_fat(fp->fs, cl);
    01F4D 802A      LDD	R2,Y+2
    01F4E 803B      LDD	R3,Y+3
    01F4F 804C      LDD	R4,Y+4
    01F50 805D      LDD	R5,Y+5
    01F51 8248      ST	Y,R4
    01F52 8259      STD	Y+1,R5
    01F53 0191      MOVW	R18,R2
    01F54 A5E8      LDD	R30,Y+40
    01F55 A5F9      LDD	R31,Y+41
    01F56 8100      LD	R16,Z
    01F57 8111      LDD	R17,Z+1
    01F58 940E 0546 CALL	_get_fat
    01F5A 830A      STD	Y+2,R16
    01F5B 831B      STD	Y+3,R17
    01F5C 832C      STD	Y+4,R18
    01F5D 833D      STD	Y+5,R19
(2833) 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
    01F5E E041      LDI	R20,1
    01F5F E050      LDI	R21,0
    01F60 E060      LDI	R22,0
    01F61 E070      LDI	R23,0
    01F62 802A      LDD	R2,Y+2
    01F63 803B      LDD	R3,Y+3
    01F64 804C      LDD	R4,Y+4
    01F65 805D      LDD	R5,Y+5
    01F66 1542      CP	R20,R2
    01F67 0553      CPC	R21,R3
    01F68 0564      CPC	R22,R4
    01F69 0575      CPC	R23,R5
    01F6A F048      BCS	0x1F74
    01F6B A588      LDD	R24,Y+40
    01F6C A599      LDD	R25,Y+41
    01F6D 9604      ADIW	R24,4
    01F6E 01FC      MOVW	R30,R24
    01F6F 8180      LD	R24,Z
    01F70 6880      ORI	R24,0x80
    01F71 8380      ST	Z,R24
    01F72 E002      LDI	R16,2
    01F73 C402      RJMP	0x2376
(2834) 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01F74 EF4F      LDI	R20,0xFF
    01F75 EF5F      LDI	R21,0xFF
    01F76 EF6F      LDI	R22,0xFF
    01F77 EF7F      LDI	R23,0xFF
    01F78 802A      LDD	R2,Y+2
    01F79 803B      LDD	R3,Y+3
    01F7A 804C      LDD	R4,Y+4
    01F7B 805D      LDD	R5,Y+5
    01F7C 1624      CP	R2,R20
    01F7D 0635      CPC	R3,R21
    01F7E 0646      CPC	R4,R22
    01F7F 0657      CPC	R5,R23
    01F80 F451      BNE	0x1F8B
    01F81 A588      LDD	R24,Y+40
    01F82 A599      LDD	R25,Y+41
    01F83 9604      ADIW	R24,4
    01F84 016C      MOVW	R12,R24
    01F85 01FC      MOVW	R30,R24
    01F86 8180      LD	R24,Z
    01F87 6880      ORI	R24,0x80
    01F88 8380      ST	Z,R24
    01F89 E001      LDI	R16,1
    01F8A C3EB      RJMP	0x2376
(2835) 					} while (cl == pcl + 1);
    01F8B E041      LDI	R20,1
    01F8C E050      LDI	R21,0
    01F8D E060      LDI	R22,0
    01F8E E070      LDI	R23,0
    01F8F 802E      LDD	R2,Y+6
    01F90 803F      LDD	R3,Y+7
    01F91 8448      LDD	R4,Y+8
    01F92 8459      LDD	R5,Y+9
    01F93 0E24      ADD	R2,R20
    01F94 1E35      ADC	R3,R21
    01F95 1E46      ADC	R4,R22
    01F96 1E57      ADC	R5,R23
    01F97 806A      LDD	R6,Y+2
    01F98 807B      LDD	R7,Y+3
    01F99 808C      LDD	R8,Y+4
    01F9A 809D      LDD	R9,Y+5
    01F9B 1462      CP	R6,R2
    01F9C 0473      CPC	R7,R3
    01F9D 0484      CPC	R8,R4
    01F9E 0495      CPC	R9,R5
    01F9F F409      BNE	0x1FA1
    01FA0 CF94      RJMP	0x1F35
(2836) 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
    01FA1 882E      LDD	R2,Y+22
    01FA2 883F      LDD	R3,Y+23
    01FA3 8C48      LDD	R4,Y+24
    01FA4 8C59      LDD	R5,Y+25
    01FA5 846E      LDD	R6,Y+14
    01FA6 847F      LDD	R7,Y+15
    01FA7 8888      LDD	R8,Y+16
    01FA8 8899      LDD	R9,Y+17
    01FA9 1426      CP	R2,R6
    01FAA 0437      CPC	R3,R7
    01FAB 0448      CPC	R4,R8
    01FAC 0459      CPC	R5,R9
    01FAD F090      BCS	0x1FC0
(2837) 						*tbl++ = ncl; *tbl++ = tcl;
    01FAE 842A      LDD	R2,Y+10
    01FAF 843B      LDD	R3,Y+11
    01FB0 844C      LDD	R4,Y+12
    01FB1 845D      LDD	R5,Y+13
    01FB2 01F7      MOVW	R30,R14
    01FB3 9221      ST	Z+,R2
    01FB4 9231      ST	Z+,R3
    01FB5 9241      ST	Z+,R4
    01FB6 9251      ST	Z+,R5
    01FB7 882A      LDD	R2,Y+18
    01FB8 883B      LDD	R3,Y+19
    01FB9 884C      LDD	R4,Y+20
    01FBA 885D      LDD	R5,Y+21
    01FBB 9221      ST	Z+,R2
    01FBC 9231      ST	Z+,R3
    01FBD 9241      ST	Z+,R4
    01FBE 9251      ST	Z+,R5
    01FBF 017F      MOVW	R14,R30
(2838) 					}
(2839) 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
    01FC0 A5E8      LDD	R30,Y+40
    01FC1 A5F9      LDD	R31,Y+41
    01FC2 81A0      LD	R26,Z
    01FC3 81B1      LDD	R27,Z+1
    01FC4 9656      ADIW	R26,0x16
    01FC5 902D      LD	R2,X+
    01FC6 903D      LD	R3,X+
    01FC7 904D      LD	R4,X+
    01FC8 905C      LD	R5,X
    01FC9 806A      LDD	R6,Y+2
    01FCA 807B      LDD	R7,Y+3
    01FCB 808C      LDD	R8,Y+4
    01FCC 809D      LDD	R9,Y+5
    01FCD 1462      CP	R6,R2
    01FCE 0473      CPC	R7,R3
    01FCF 0484      CPC	R8,R4
    01FD0 0495      CPC	R9,R5
    01FD1 F408      BCC	0x1FD3
    01FD2 CF45      RJMP	0x1F18
(2840) 			}
(2841) 			*fp->cltbl = ulen;	/* Number of items used */
    01FD3 842E      LDD	R2,Y+14
    01FD4 843F      LDD	R3,Y+15
    01FD5 8848      LDD	R4,Y+16
    01FD6 8859      LDD	R5,Y+17
    01FD7 A5E8      LDD	R30,Y+40
    01FD8 A5F9      LDD	R31,Y+41
    01FD9 96B0      ADIW	R30,0x20
    01FDA 81A0      LD	R26,Z
    01FDB 81B1      LDD	R27,Z+1
    01FDC 922D      ST	X+,R2
    01FDD 923D      ST	X+,R3
    01FDE 924D      ST	X+,R4
    01FDF 925C      ST	X,R5
(2842) 			if (ulen <= tlen)
    01FE0 882E      LDD	R2,Y+22
    01FE1 883F      LDD	R3,Y+23
    01FE2 8C48      LDD	R4,Y+24
    01FE3 8C59      LDD	R5,Y+25
    01FE4 846E      LDD	R6,Y+14
    01FE5 847F      LDD	R7,Y+15
    01FE6 8888      LDD	R8,Y+16
    01FE7 8899      LDD	R9,Y+17
    01FE8 1426      CP	R2,R6
    01FE9 0437      CPC	R3,R7
    01FEA 0448      CPC	R4,R8
    01FEB 0459      CPC	R5,R9
    01FEC F038      BCS	0x1FF4
(2843) 				*tbl = 0;		/* Terminate table */
    01FED 01F7      MOVW	R30,R14
    01FEE E080      LDI	R24,0
    01FEF 8380      ST	Z,R24
    01FF0 8381      STD	Z+1,R24
    01FF1 8382      STD	Z+2,R24
    01FF2 8383      STD	Z+3,R24
    01FF3 C381      RJMP	0x2375
(2844) 			else
(2845) 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
    01FF4 E181      LDI	R24,0x11
    01FF5 2EA8      MOV	R10,R24
(2846) 
(2847) 		} else {						/* Fast seek */
    01FF6 C37E      RJMP	0x2375
(2848) 			if (ofs > fp->fsize)		/* Clip offset at the file size */
    01FF7 A5E8      LDD	R30,Y+40
    01FF8 A5F9      LDD	R31,Y+41
    01FF9 963A      ADIW	R30,0xA
    01FFA 8020      LD	R2,Z
    01FFB 8031      LDD	R3,Z+1
    01FFC 8042      LDD	R4,Z+2
    01FFD 8053      LDD	R5,Z+3
    01FFE A46A      LDD	R6,Y+42
    01FFF A47B      LDD	R7,Y+43
    02000 A48C      LDD	R8,Y+44
    02001 A49D      LDD	R9,Y+45
    02002 1426      CP	R2,R6
    02003 0437      CPC	R3,R7
    02004 0448      CPC	R4,R8
    02005 0459      CPC	R5,R9
    02006 F458      BCC	0x2012
(2849) 				ofs = fp->fsize;
    02007 A5E8      LDD	R30,Y+40
    02008 A5F9      LDD	R31,Y+41
    02009 963A      ADIW	R30,0xA
    0200A 8020      LD	R2,Z
    0200B 8031      LDD	R3,Z+1
    0200C 8042      LDD	R4,Z+2
    0200D 8053      LDD	R5,Z+3
    0200E A62A      STD	Y+42,R2
    0200F A63B      STD	Y+43,R3
    02010 A64C      STD	Y+44,R4
    02011 A65D      STD	Y+45,R5
(2850) 			fp->fptr = ofs;				/* Set file pointer */
    02012 A42A      LDD	R2,Y+42
    02013 A43B      LDD	R3,Y+43
    02014 A44C      LDD	R4,Y+44
    02015 A45D      LDD	R5,Y+45
    02016 A5E8      LDD	R30,Y+40
    02017 A5F9      LDD	R31,Y+41
    02018 9636      ADIW	R30,6
    02019 8220      ST	Z,R2
    0201A 8231      STD	Z+1,R3
    0201B 8242      STD	Z+2,R4
    0201C 8253      STD	Z+3,R5
(2851) 			if (ofs) {
    0201D 9488      BCLR	0
    0201E 2022      TST	R2
    0201F 0432      CPC	R3,R2
    02020 0442      CPC	R4,R2
    02021 0452      CPC	R5,R2
    02022 F409      BNE	0x2024
    02023 C351      RJMP	0x2375
(2852) 				fp->clust = clmt_clust(fp, ofs - 1);
    02024 E041      LDI	R20,1
    02025 E050      LDI	R21,0
    02026 E060      LDI	R22,0
    02027 E070      LDI	R23,0
    02028 1A24      SUB	R2,R20
    02029 0A35      SBC	R3,R21
    0202A 0A46      SBC	R4,R22
    0202B 0A57      SBC	R5,R23
    0202C 8248      ST	Y,R4
    0202D 8259      STD	Y+1,R5
    0202E 0191      MOVW	R18,R2
    0202F A508      LDD	R16,Y+40
    02030 A519      LDD	R17,Y+41
    02031 940E 0A80 CALL	ff.c:clmt_clust
    02033 A5E8      LDD	R30,Y+40
    02034 A5F9      LDD	R31,Y+41
    02035 8B02      STD	Z+18,R16
    02036 8B13      STD	Z+19,R17
    02037 8B24      STD	Z+20,R18
    02038 8B35      STD	Z+21,R19
(2853) 				dsc = clust2sect(fp->fs, fp->clust);
    02039 8822      LDD	R2,Z+18
    0203A 8833      LDD	R3,Z+19
    0203B 8844      LDD	R4,Z+20
    0203C 8855      LDD	R5,Z+21
    0203D 8248      ST	Y,R4
    0203E 8259      STD	Y+1,R5
    0203F 0191      MOVW	R18,R2
    02040 8100      LD	R16,Z
    02041 8111      LDD	R17,Z+1
    02042 940E 04F4 CALL	_clust2sect
    02044 8F0A      STD	Y+26,R16
    02045 8F1B      STD	Y+27,R17
    02046 8F2C      STD	Y+28,R18
    02047 8F3D      STD	Y+29,R19
(2854) 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
    02048 8C2A      LDD	R2,Y+26
    02049 8C3B      LDD	R3,Y+27
    0204A 8C4C      LDD	R4,Y+28
    0204B 8C5D      LDD	R5,Y+29
    0204C 9488      BCLR	0
    0204D 2022      TST	R2
    0204E 0432      CPC	R3,R2
    0204F 0442      CPC	R4,R2
    02050 0452      CPC	R5,R2
    02051 F451      BNE	0x205C
    02052 A588      LDD	R24,Y+40
    02053 A599      LDD	R25,Y+41
    02054 9604      ADIW	R24,4
    02055 017C      MOVW	R14,R24
    02056 01FC      MOVW	R30,R24
    02057 8180      LD	R24,Z
    02058 6880      ORI	R24,0x80
    02059 8380      ST	Z,R24
    0205A E002      LDI	R16,2
    0205B C31A      RJMP	0x2376
(2855) 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
    0205C E041      LDI	R20,1
    0205D E050      LDI	R21,0
    0205E E060      LDI	R22,0
    0205F E070      LDI	R23,0
    02060 A50A      LDD	R16,Y+42
    02061 A51B      LDD	R17,Y+43
    02062 A52C      LDD	R18,Y+44
    02063 A53D      LDD	R19,Y+45
    02064 1B04      SUB	R16,R20
    02065 0B15      SBC	R17,R21
    02066 0B26      SBC	R18,R22
    02067 0B37      SBC	R19,R23
    02068 E089      LDI	R24,0x9
    02069 E090      LDI	R25,0
    0206A 938A      ST	-Y,R24
    0206B 940E 433F CALL	lsr32
    0206D 0118      MOVW	R2,R16
    0206E 0129      MOVW	R4,R18
    0206F A5E8      LDD	R30,Y+40
    02070 A5F9      LDD	R31,Y+41
    02071 93AF      PUSH	R26
    02072 93BF      PUSH	R27
    02073 81A0      LD	R26,Z
    02074 81B1      LDD	R27,Z+1
    02075 01FD      MOVW	R30,R26
    02076 91BF      POP	R27
    02077 91AF      POP	R26
    02078 9632      ADIW	R30,2
    02079 8180      LD	R24,Z
    0207A 2799      CLR	R25
    0207B 9701      SBIW	R24,1
    0207C 013C      MOVW	R6,R24
    0207D 2488      CLR	R8
    0207E FC77      SBRC	R7,7
    0207F 9480      COM	R8
    02080 2499      CLR	R9
    02081 FC87      SBRC	R8,7
    02082 9490      COM	R9
    02083 2026      AND	R2,R6
    02084 2037      AND	R3,R7
    02085 2048      AND	R4,R8
    02086 2059      AND	R5,R9
    02087 8C6A      LDD	R6,Y+26
    02088 8C7B      LDD	R7,Y+27
    02089 8C8C      LDD	R8,Y+28
    0208A 8C9D      LDD	R9,Y+29
    0208B 0C62      ADD	R6,R2
    0208C 1C73      ADC	R7,R3
    0208D 1C84      ADC	R8,R4
    0208E 1C95      ADC	R9,R5
    0208F 8E6A      STD	Y+26,R6
    02090 8E7B      STD	Y+27,R7
    02091 8E8C      STD	Y+28,R8
    02092 8E9D      STD	Y+29,R9
(2856) 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
    02093 EF4F      LDI	R20,0xFF
    02094 E051      LDI	R21,1
    02095 E060      LDI	R22,0
    02096 E070      LDI	R23,0
    02097 A5E8      LDD	R30,Y+40
    02098 A5F9      LDD	R31,Y+41
    02099 9636      ADIW	R30,6
    0209A 8020      LD	R2,Z
    0209B 8031      LDD	R3,Z+1
    0209C 8042      LDD	R4,Z+2
    0209D 8053      LDD	R5,Z+3
    0209E 2224      AND	R2,R20
    0209F 2235      AND	R3,R21
    020A0 2246      AND	R4,R22
    020A1 2257      AND	R5,R23
    020A2 9488      BCLR	0
    020A3 2022      TST	R2
    020A4 0432      CPC	R3,R2
    020A5 0442      CPC	R4,R2
    020A6 0452      CPC	R5,R2
    020A7 F409      BNE	0x20A9
    020A8 C2CC      RJMP	0x2375
    020A9 A5E8      LDD	R30,Y+40
    020AA A5F9      LDD	R31,Y+41
    020AB 9676      ADIW	R30,0x16
    020AC 8020      LD	R2,Z
    020AD 8031      LDD	R3,Z+1
    020AE 8042      LDD	R4,Z+2
    020AF 8053      LDD	R5,Z+3
    020B0 8C6A      LDD	R6,Y+26
    020B1 8C7B      LDD	R7,Y+27
    020B2 8C8C      LDD	R8,Y+28
    020B3 8C9D      LDD	R9,Y+29
    020B4 1462      CP	R6,R2
    020B5 0473      CPC	R7,R3
    020B6 0484      CPC	R8,R4
    020B7 0495      CPC	R9,R5
    020B8 F409      BNE	0x20BA
    020B9 C2BB      RJMP	0x2375
(2857) #if !_FS_TINY
(2858) #if !_FS_READONLY
(2859) 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2860) 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2861) 							ABORT(fp->fs, FR_DISK_ERR);
(2862) 						fp->flag &= ~FA__DIRTY;
(2863) 					}
(2864) #endif
(2865) 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
(2866) 						ABORT(fp->fs, FR_DISK_ERR);
(2867) #endif
(2868) 					fp->dsect = dsc;
    020BA 0113      MOVW	R2,R6
    020BB 0124      MOVW	R4,R8
    020BC A5E8      LDD	R30,Y+40
    020BD A5F9      LDD	R31,Y+41
    020BE 8A26      STD	Z+22,R2
    020BF 8A37      STD	Z+23,R3
    020C0 8E40      STD	Z+24,R4
    020C1 8E51      STD	Z+25,R5
(2869) 				}
(2870) 			}
(2871) 		}
(2872) 	} else
    020C2 C2B2      RJMP	0x2375
(2873) #endif
(2874) 
(2875) 	/* Normal Seek */
(2876) 	{
(2877) 		DWORD clst, bcs, nsect, ifptr;
(2878) 
(2879) 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    020C3 A5E8      LDD	R30,Y+40
    020C4 A5F9      LDD	R31,Y+41
    020C5 963A      ADIW	R30,0xA
    020C6 8020      LD	R2,Z
    020C7 8031      LDD	R3,Z+1
    020C8 8042      LDD	R4,Z+2
    020C9 8053      LDD	R5,Z+3
    020CA A46A      LDD	R6,Y+42
    020CB A47B      LDD	R7,Y+43
    020CC A48C      LDD	R8,Y+44
    020CD A49D      LDD	R9,Y+45
    020CE 1426      CP	R2,R6
    020CF 0437      CPC	R3,R7
    020D0 0448      CPC	R4,R8
    020D1 0459      CPC	R5,R9
    020D2 F470      BCC	0x20E1
    020D3 A5E8      LDD	R30,Y+40
    020D4 A5F9      LDD	R31,Y+41
    020D5 8024      LDD	R2,Z+4
    020D6 FC21      SBRC	R2,1
    020D7 C009      RJMP	0x20E1
(2880) #if !_FS_READONLY
(2881) 			 && !(fp->flag & FA_WRITE)
(2882) #endif
(2883) 			) ofs = fp->fsize;
    020D8 963A      ADIW	R30,0xA
    020D9 8020      LD	R2,Z
    020DA 8031      LDD	R3,Z+1
    020DB 8042      LDD	R4,Z+2
    020DC 8053      LDD	R5,Z+3
    020DD A62A      STD	Y+42,R2
    020DE A63B      STD	Y+43,R3
    020DF A64C      STD	Y+44,R4
    020E0 A65D      STD	Y+45,R5
(2884) 
(2885) 		ifptr = fp->fptr;
    020E1 A5E8      LDD	R30,Y+40
    020E2 A5F9      LDD	R31,Y+41
    020E3 9636      ADIW	R30,6
    020E4 8020      LD	R2,Z
    020E5 8031      LDD	R3,Z+1
    020E6 8042      LDD	R4,Z+2
    020E7 8053      LDD	R5,Z+3
    020E8 862E      STD	Y+14,R2
    020E9 863F      STD	Y+15,R3
    020EA 8A48      STD	Y+16,R4
    020EB 8A59      STD	Y+17,R5
(2886) 		fp->fptr = nsect = 0;
    020EC E080      LDI	R24,0
    020ED 878A      STD	Y+10,R24
    020EE 878B      STD	Y+11,R24
    020EF 878C      STD	Y+12,R24
    020F0 878D      STD	Y+13,R24
    020F1 A5E8      LDD	R30,Y+40
    020F2 A5F9      LDD	R31,Y+41
    020F3 9636      ADIW	R30,6
    020F4 E080      LDI	R24,0
    020F5 8380      ST	Z,R24
    020F6 8381      STD	Z+1,R24
    020F7 8382      STD	Z+2,R24
    020F8 8383      STD	Z+3,R24
(2887) 		if (ofs) {
    020F9 A42A      LDD	R2,Y+42
    020FA A43B      LDD	R3,Y+43
    020FB A44C      LDD	R4,Y+44
    020FC A45D      LDD	R5,Y+45
    020FD 9488      BCLR	0
    020FE 2022      TST	R2
    020FF 0432      CPC	R3,R2
    02100 0442      CPC	R4,R2
    02101 0452      CPC	R5,R2
    02102 F409      BNE	0x2104
    02103 C226      RJMP	0x232A
(2888) 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    02104 A5E8      LDD	R30,Y+40
    02105 A5F9      LDD	R31,Y+41
    02106 93AF      PUSH	R26
    02107 93BF      PUSH	R27
    02108 81A0      LD	R26,Z
    02109 81B1      LDD	R27,Z+1
    0210A 01FD      MOVW	R30,R26
    0210B 91BF      POP	R27
    0210C 91AF      POP	R26
    0210D 9632      ADIW	R30,2
    0210E 8020      LD	R2,Z
    0210F 2433      CLR	R3
    02110 2444      CLR	R4
    02111 2455      CLR	R5
    02112 E040      LDI	R20,0
    02113 E052      LDI	R21,2
    02114 E060      LDI	R22,0
    02115 E070      LDI	R23,0
    02116 925A      ST	-Y,R5
    02117 924A      ST	-Y,R4
    02118 923A      ST	-Y,R3
    02119 922A      ST	-Y,R2
    0211A 018A      MOVW	R16,R20
    0211B 019B      MOVW	R18,R22
    0211C 940E 4250 CALL	empy32u|empy32s
    0211E 830E      STD	Y+6,R16
    0211F 831F      STD	Y+7,R17
    02120 8728      STD	Y+8,R18
    02121 8739      STD	Y+9,R19
(2889) 			if (ifptr > 0 &&
    02122 842E      LDD	R2,Y+14
    02123 843F      LDD	R3,Y+15
    02124 8848      LDD	R4,Y+16
    02125 8859      LDD	R5,Y+17
    02126 9488      BCLR	0
    02127 2022      TST	R2
    02128 0432      CPC	R3,R2
    02129 0442      CPC	R4,R2
    0212A 0452      CPC	R5,R2
    0212B F409      BNE	0x212D
    0212C C075      RJMP	0x21A2
    0212D E041      LDI	R20,1
    0212E E050      LDI	R21,0
    0212F E060      LDI	R22,0
    02130 E070      LDI	R23,0
    02131 0181      MOVW	R16,R2
    02132 0192      MOVW	R18,R4
    02133 1B04      SUB	R16,R20
    02134 0B15      SBC	R17,R21
    02135 0B26      SBC	R18,R22
    02136 0B37      SBC	R19,R23
    02137 802E      LDD	R2,Y+6
    02138 803F      LDD	R3,Y+7
    02139 8448      LDD	R4,Y+8
    0213A 8459      LDD	R5,Y+9
    0213B 925A      ST	-Y,R5
    0213C 924A      ST	-Y,R4
    0213D 923A      ST	-Y,R3
    0213E 922A      ST	-Y,R2
    0213F 940E 41AA CALL	div32u
    02141 0118      MOVW	R2,R16
    02142 0129      MOVW	R4,R18
    02143 E041      LDI	R20,1
    02144 E050      LDI	R21,0
    02145 E060      LDI	R22,0
    02146 E070      LDI	R23,0
    02147 A50A      LDD	R16,Y+42
    02148 A51B      LDD	R17,Y+43
    02149 A52C      LDD	R18,Y+44
    0214A A53D      LDD	R19,Y+45
    0214B 1B04      SUB	R16,R20
    0214C 0B15      SBC	R17,R21
    0214D 0B26      SBC	R18,R22
    0214E 0B37      SBC	R19,R23
    0214F 806E      LDD	R6,Y+6
    02150 807F      LDD	R7,Y+7
    02151 8488      LDD	R8,Y+8
    02152 8499      LDD	R9,Y+9
    02153 929A      ST	-Y,R9
    02154 928A      ST	-Y,R8
    02155 927A      ST	-Y,R7
    02156 926A      ST	-Y,R6
    02157 940E 41AA CALL	div32u
    02159 1502      CP	R16,R2
    0215A 0513      CPC	R17,R3
    0215B 0524      CPC	R18,R4
    0215C 0535      CPC	R19,R5
    0215D F408      BCC	0x215F
    0215E C043      RJMP	0x21A2
(2890) 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
(2891) 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    0215F E041      LDI	R20,1
    02160 E050      LDI	R21,0
    02161 E060      LDI	R22,0
    02162 E070      LDI	R23,0
    02163 802E      LDD	R2,Y+6
    02164 803F      LDD	R3,Y+7
    02165 8448      LDD	R4,Y+8
    02166 8459      LDD	R5,Y+9
    02167 1A24      SUB	R2,R20
    02168 0A35      SBC	R3,R21
    02169 0A46      SBC	R4,R22
    0216A 0A57      SBC	R5,R23
    0216B 9420      COM	R2
    0216C 9430      COM	R3
    0216D 9440      COM	R4
    0216E 9450      COM	R5
    0216F E041      LDI	R20,1
    02170 E050      LDI	R21,0
    02171 E060      LDI	R22,0
    02172 E070      LDI	R23,0
    02173 846E      LDD	R6,Y+14
    02174 847F      LDD	R7,Y+15
    02175 8888      LDD	R8,Y+16
    02176 8899      LDD	R9,Y+17
    02177 1A64      SUB	R6,R20
    02178 0A75      SBC	R7,R21
    02179 0A86      SBC	R8,R22
    0217A 0A97      SBC	R9,R23
    0217B 2062      AND	R6,R2
    0217C 2073      AND	R7,R3
    0217D 2084      AND	R8,R4
    0217E 2095      AND	R9,R5
    0217F A5E8      LDD	R30,Y+40
    02180 A5F9      LDD	R31,Y+41
    02181 8266      STD	Z+6,R6
    02182 8277      STD	Z+7,R7
    02183 8680      STD	Z+8,R8
    02184 8691      STD	Z+9,R9
(2892) 				ofs -= fp->fptr;
    02185 9636      ADIW	R30,6
    02186 8020      LD	R2,Z
    02187 8031      LDD	R3,Z+1
    02188 8042      LDD	R4,Z+2
    02189 8053      LDD	R5,Z+3
    0218A A46A      LDD	R6,Y+42
    0218B A47B      LDD	R7,Y+43
    0218C A48C      LDD	R8,Y+44
    0218D A49D      LDD	R9,Y+45
    0218E 1862      SUB	R6,R2
    0218F 0873      SBC	R7,R3
    02190 0884      SBC	R8,R4
    02191 0895      SBC	R9,R5
    02192 A66A      STD	Y+42,R6
    02193 A67B      STD	Y+43,R7
    02194 A68C      STD	Y+44,R8
    02195 A69D      STD	Y+45,R9
(2893) 				clst = fp->clust;
    02196 A5E8      LDD	R30,Y+40
    02197 A5F9      LDD	R31,Y+41
    02198 9672      ADIW	R30,0x12
    02199 8020      LD	R2,Z
    0219A 8031      LDD	R3,Z+1
    0219B 8042      LDD	R4,Z+2
    0219C 8053      LDD	R5,Z+3
    0219D 822A      STD	Y+2,R2
    0219E 823B      STD	Y+3,R3
    0219F 824C      STD	Y+4,R4
    021A0 825D      STD	Y+5,R5
(2894) 			} else {									/* When seek to back cluster, */
    021A1 C069      RJMP	0x220B
(2895) 				clst = fp->sclust;						/* start from the first cluster */
    021A2 A5E8      LDD	R30,Y+40
    021A3 A5F9      LDD	R31,Y+41
    021A4 963E      ADIW	R30,0xE
    021A5 8020      LD	R2,Z
    021A6 8031      LDD	R3,Z+1
    021A7 8042      LDD	R4,Z+2
    021A8 8053      LDD	R5,Z+3
    021A9 822A      STD	Y+2,R2
    021AA 823B      STD	Y+3,R3
    021AB 824C      STD	Y+4,R4
    021AC 825D      STD	Y+5,R5
(2896) #if !_FS_READONLY
(2897) 				if (clst == 0) {						/* If no cluster chain, create a new chain */
    021AD 802A      LDD	R2,Y+2
    021AE 803B      LDD	R3,Y+3
    021AF 804C      LDD	R4,Y+4
    021B0 805D      LDD	R5,Y+5
    021B1 9488      BCLR	0
    021B2 2022      TST	R2
    021B3 0432      CPC	R3,R2
    021B4 0442      CPC	R4,R2
    021B5 0452      CPC	R5,R2
    021B6 F009      BEQ	0x21B8
    021B7 C049      RJMP	0x2201
(2898) 					clst = create_chain(fp->fs, 0);
    021B8 E040      LDI	R20,0
    021B9 E050      LDI	R21,0
    021BA E060      LDI	R22,0
    021BB E070      LDI	R23,0
    021BC 8368      ST	Y,R22
    021BD 8379      STD	Y+1,R23
    021BE 019A      MOVW	R18,R20
    021BF A5E8      LDD	R30,Y+40
    021C0 A5F9      LDD	R31,Y+41
    021C1 8100      LD	R16,Z
    021C2 8111      LDD	R17,Z+1
    021C3 940E 0908 CALL	ff.c:create_chain
    021C5 830A      STD	Y+2,R16
    021C6 831B      STD	Y+3,R17
    021C7 832C      STD	Y+4,R18
    021C8 833D      STD	Y+5,R19
(2899) 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    021C9 E041      LDI	R20,1
    021CA E050      LDI	R21,0
    021CB E060      LDI	R22,0
    021CC E070      LDI	R23,0
    021CD 802A      LDD	R2,Y+2
    021CE 803B      LDD	R3,Y+3
    021CF 804C      LDD	R4,Y+4
    021D0 805D      LDD	R5,Y+5
    021D1 1624      CP	R2,R20
    021D2 0635      CPC	R3,R21
    021D3 0646      CPC	R4,R22
    021D4 0657      CPC	R5,R23
    021D5 F451      BNE	0x21E0
    021D6 A588      LDD	R24,Y+40
    021D7 A599      LDD	R25,Y+41
    021D8 9604      ADIW	R24,4
    021D9 017C      MOVW	R14,R24
    021DA 01FC      MOVW	R30,R24
    021DB 8180      LD	R24,Z
    021DC 6880      ORI	R24,0x80
    021DD 8380      ST	Z,R24
    021DE E002      LDI	R16,2
    021DF C196      RJMP	0x2376
(2900) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    021E0 EF4F      LDI	R20,0xFF
    021E1 EF5F      LDI	R21,0xFF
    021E2 EF6F      LDI	R22,0xFF
    021E3 EF7F      LDI	R23,0xFF
    021E4 802A      LDD	R2,Y+2
    021E5 803B      LDD	R3,Y+3
    021E6 804C      LDD	R4,Y+4
    021E7 805D      LDD	R5,Y+5
    021E8 1624      CP	R2,R20
    021E9 0635      CPC	R3,R21
    021EA 0646      CPC	R4,R22
    021EB 0657      CPC	R5,R23
    021EC F451      BNE	0x21F7
    021ED A588      LDD	R24,Y+40
    021EE A599      LDD	R25,Y+41
    021EF 9604      ADIW	R24,4
    021F0 017C      MOVW	R14,R24
    021F1 01FC      MOVW	R30,R24
    021F2 8180      LD	R24,Z
    021F3 6880      ORI	R24,0x80
    021F4 8380      ST	Z,R24
    021F5 E001      LDI	R16,1
    021F6 C17F      RJMP	0x2376
(2901) 					fp->sclust = clst;
    021F7 802A      LDD	R2,Y+2
    021F8 803B      LDD	R3,Y+3
    021F9 804C      LDD	R4,Y+4
    021FA 805D      LDD	R5,Y+5
    021FB A5E8      LDD	R30,Y+40
    021FC A5F9      LDD	R31,Y+41
    021FD 8626      STD	Z+14,R2
    021FE 8637      STD	Z+15,R3
    021FF 8A40      STD	Z+16,R4
    02200 8A51      STD	Z+17,R5
(2902) 				}
(2903) #endif
(2904) 				fp->clust = clst;
    02201 802A      LDD	R2,Y+2
    02202 803B      LDD	R3,Y+3
    02203 804C      LDD	R4,Y+4
    02204 805D      LDD	R5,Y+5
    02205 A5E8      LDD	R30,Y+40
    02206 A5F9      LDD	R31,Y+41
    02207 8A22      STD	Z+18,R2
    02208 8A33      STD	Z+19,R3
    02209 8A44      STD	Z+20,R4
    0220A 8A55      STD	Z+21,R5
(2905) 			}
(2906) 			if (clst != 0) {
    0220B 802A      LDD	R2,Y+2
    0220C 803B      LDD	R3,Y+3
    0220D 804C      LDD	R4,Y+4
    0220E 805D      LDD	R5,Y+5
    0220F 9488      BCLR	0
    02210 2022      TST	R2
    02211 0432      CPC	R3,R2
    02212 0442      CPC	R4,R2
    02213 0452      CPC	R5,R2
    02214 F409      BNE	0x2216
    02215 C114      RJMP	0x232A
    02216 C0A7      RJMP	0x22BE
(2907) 				while (ofs > bcs) {						/* Cluster following loop */
(2908) #if !_FS_READONLY
(2909) 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    02217 A5E8      LDD	R30,Y+40
    02218 A5F9      LDD	R31,Y+41
    02219 9634      ADIW	R30,4
    0221A 8020      LD	R2,Z
    0221B FE21      SBRS	R2,1
    0221C C024      RJMP	0x2241
(2910) 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    0221D 802A      LDD	R2,Y+2
    0221E 803B      LDD	R3,Y+3
    0221F 804C      LDD	R4,Y+4
    02220 805D      LDD	R5,Y+5
    02221 8248      ST	Y,R4
    02222 8259      STD	Y+1,R5
    02223 0191      MOVW	R18,R2
    02224 A5E8      LDD	R30,Y+40
    02225 A5F9      LDD	R31,Y+41
    02226 8100      LD	R16,Z
    02227 8111      LDD	R17,Z+1
    02228 940E 0908 CALL	ff.c:create_chain
    0222A 830A      STD	Y+2,R16
    0222B 831B      STD	Y+3,R17
    0222C 832C      STD	Y+4,R18
    0222D 833D      STD	Y+5,R19
(2911) 						if (clst == 0) {				/* When disk gets full, clip file size */
    0222E 802A      LDD	R2,Y+2
    0222F 803B      LDD	R3,Y+3
    02230 804C      LDD	R4,Y+4
    02231 805D      LDD	R5,Y+5
    02232 9488      BCLR	0
    02233 2022      TST	R2
    02234 0432      CPC	R3,R2
    02235 0442      CPC	R4,R2
    02236 0452      CPC	R5,R2
    02237 F4D1      BNE	0x2252
(2912) 							ofs = bcs; break;
    02238 802E      LDD	R2,Y+6
    02239 803F      LDD	R3,Y+7
    0223A 8448      LDD	R4,Y+8
    0223B 8459      LDD	R5,Y+9
    0223C A62A      STD	Y+42,R2
    0223D A63B      STD	Y+43,R3
    0223E A64C      STD	Y+44,R4
    0223F A65D      STD	Y+45,R5
    02240 C08B      RJMP	0x22CC
(2913) 						}
(2914) 					} else
(2915) #endif
(2916) 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    02241 802A      LDD	R2,Y+2
    02242 803B      LDD	R3,Y+3
    02243 804C      LDD	R4,Y+4
    02244 805D      LDD	R5,Y+5
    02245 8248      ST	Y,R4
    02246 8259      STD	Y+1,R5
    02247 0191      MOVW	R18,R2
    02248 A5E8      LDD	R30,Y+40
    02249 A5F9      LDD	R31,Y+41
    0224A 8100      LD	R16,Z
    0224B 8111      LDD	R17,Z+1
    0224C 940E 0546 CALL	_get_fat
    0224E 830A      STD	Y+2,R16
    0224F 831B      STD	Y+3,R17
    02250 832C      STD	Y+4,R18
    02251 833D      STD	Y+5,R19
(2917) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    02252 EF4F      LDI	R20,0xFF
    02253 EF5F      LDI	R21,0xFF
    02254 EF6F      LDI	R22,0xFF
    02255 EF7F      LDI	R23,0xFF
    02256 802A      LDD	R2,Y+2
    02257 803B      LDD	R3,Y+3
    02258 804C      LDD	R4,Y+4
    02259 805D      LDD	R5,Y+5
    0225A 1624      CP	R2,R20
    0225B 0635      CPC	R3,R21
    0225C 0646      CPC	R4,R22
    0225D 0657      CPC	R5,R23
    0225E F451      BNE	0x2269
    0225F A588      LDD	R24,Y+40
    02260 A599      LDD	R25,Y+41
    02261 9604      ADIW	R24,4
    02262 017C      MOVW	R14,R24
    02263 01FC      MOVW	R30,R24
    02264 8180      LD	R24,Z
    02265 6880      ORI	R24,0x80
    02266 8380      ST	Z,R24
    02267 E001      LDI	R16,1
    02268 C10D      RJMP	0x2376
(2918) 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    02269 E041      LDI	R20,1
    0226A E050      LDI	R21,0
    0226B E060      LDI	R22,0
    0226C E070      LDI	R23,0
    0226D 802A      LDD	R2,Y+2
    0226E 803B      LDD	R3,Y+3
    0226F 804C      LDD	R4,Y+4
    02270 805D      LDD	R5,Y+5
    02271 1542      CP	R20,R2
    02272 0553      CPC	R21,R3
    02273 0564      CPC	R22,R4
    02274 0575      CPC	R23,R5
    02275 F490      BCC	0x2288
    02276 A5E8      LDD	R30,Y+40
    02277 A5F9      LDD	R31,Y+41
    02278 81A0      LD	R26,Z
    02279 81B1      LDD	R27,Z+1
    0227A 9656      ADIW	R26,0x16
    0227B 902D      LD	R2,X+
    0227C 903D      LD	R3,X+
    0227D 904D      LD	R4,X+
    0227E 905C      LD	R5,X
    0227F 806A      LDD	R6,Y+2
    02280 807B      LDD	R7,Y+3
    02281 808C      LDD	R8,Y+4
    02282 809D      LDD	R9,Y+5
    02283 1462      CP	R6,R2
    02284 0473      CPC	R7,R3
    02285 0484      CPC	R8,R4
    02286 0495      CPC	R9,R5
    02287 F050      BCS	0x2292
    02288 A588      LDD	R24,Y+40
    02289 A599      LDD	R25,Y+41
    0228A 9604      ADIW	R24,4
    0228B 017C      MOVW	R14,R24
    0228C 01FC      MOVW	R30,R24
    0228D 8180      LD	R24,Z
    0228E 6880      ORI	R24,0x80
    0228F 8380      ST	Z,R24
    02290 E002      LDI	R16,2
    02291 C0E4      RJMP	0x2376
(2919) 					fp->clust = clst;
    02292 802A      LDD	R2,Y+2
    02293 803B      LDD	R3,Y+3
    02294 804C      LDD	R4,Y+4
    02295 805D      LDD	R5,Y+5
    02296 A5E8      LDD	R30,Y+40
    02297 A5F9      LDD	R31,Y+41
    02298 9672      ADIW	R30,0x12
    02299 8220      ST	Z,R2
    0229A 8231      STD	Z+1,R3
    0229B 8242      STD	Z+2,R4
    0229C 8253      STD	Z+3,R5
(2920) 					fp->fptr += bcs;
    0229D A588      LDD	R24,Y+40
    0229E A599      LDD	R25,Y+41
    0229F 9606      ADIW	R24,6
    022A0 017C      MOVW	R14,R24
    022A1 802E      LDD	R2,Y+6
    022A2 803F      LDD	R3,Y+7
    022A3 8448      LDD	R4,Y+8
    022A4 8459      LDD	R5,Y+9
    022A5 01FC      MOVW	R30,R24
    022A6 8060      LD	R6,Z
    022A7 8071      LDD	R7,Z+1
    022A8 8082      LDD	R8,Z+2
    022A9 8093      LDD	R9,Z+3
    022AA 0C62      ADD	R6,R2
    022AB 1C73      ADC	R7,R3
    022AC 1C84      ADC	R8,R4
    022AD 1C95      ADC	R9,R5
    022AE 8260      ST	Z,R6
    022AF 8271      STD	Z+1,R7
    022B0 8282      STD	Z+2,R8
    022B1 8293      STD	Z+3,R9
(2921) 					ofs -= bcs;
    022B2 A46A      LDD	R6,Y+42
    022B3 A47B      LDD	R7,Y+43
    022B4 A48C      LDD	R8,Y+44
    022B5 A49D      LDD	R9,Y+45
    022B6 1862      SUB	R6,R2
    022B7 0873      SBC	R7,R3
    022B8 0884      SBC	R8,R4
    022B9 0895      SBC	R9,R5
    022BA A66A      STD	Y+42,R6
    022BB A67B      STD	Y+43,R7
    022BC A68C      STD	Y+44,R8
    022BD A69D      STD	Y+45,R9
    022BE 802E      LDD	R2,Y+6
    022BF 803F      LDD	R3,Y+7
    022C0 8448      LDD	R4,Y+8
    022C1 8459      LDD	R5,Y+9
    022C2 A46A      LDD	R6,Y+42
    022C3 A47B      LDD	R7,Y+43
    022C4 A48C      LDD	R8,Y+44
    022C5 A49D      LDD	R9,Y+45
    022C6 1426      CP	R2,R6
    022C7 0437      CPC	R3,R7
    022C8 0448      CPC	R4,R8
    022C9 0459      CPC	R5,R9
    022CA F408      BCC	0x22CC
    022CB CF4B      RJMP	0x2217
(2922) 				}
(2923) 				fp->fptr += ofs;
    022CC A588      LDD	R24,Y+40
    022CD A599      LDD	R25,Y+41
    022CE 9606      ADIW	R24,6
    022CF 017C      MOVW	R14,R24
    022D0 A42A      LDD	R2,Y+42
    022D1 A43B      LDD	R3,Y+43
    022D2 A44C      LDD	R4,Y+44
    022D3 A45D      LDD	R5,Y+45
    022D4 01FC      MOVW	R30,R24
    022D5 8060      LD	R6,Z
    022D6 8071      LDD	R7,Z+1
    022D7 8082      LDD	R8,Z+2
    022D8 8093      LDD	R9,Z+3
    022D9 0C62      ADD	R6,R2
    022DA 1C73      ADC	R7,R3
    022DB 1C84      ADC	R8,R4
    022DC 1C95      ADC	R9,R5
    022DD 8260      ST	Z,R6
    022DE 8271      STD	Z+1,R7
    022DF 8282      STD	Z+2,R8
    022E0 8293      STD	Z+3,R9
(2924) 				if (ofs % SS(fp->fs)) {
    022E1 EF4F      LDI	R20,0xFF
    022E2 E051      LDI	R21,1
    022E3 E060      LDI	R22,0
    022E4 E070      LDI	R23,0
    022E5 2224      AND	R2,R20
    022E6 2235      AND	R3,R21
    022E7 2246      AND	R4,R22
    022E8 2257      AND	R5,R23
    022E9 9488      BCLR	0
    022EA 2022      TST	R2
    022EB 0432      CPC	R3,R2
    022EC 0442      CPC	R4,R2
    022ED 0452      CPC	R5,R2
    022EE F409      BNE	0x22F0
    022EF C03A      RJMP	0x232A
(2925) 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    022F0 802A      LDD	R2,Y+2
    022F1 803B      LDD	R3,Y+3
    022F2 804C      LDD	R4,Y+4
    022F3 805D      LDD	R5,Y+5
    022F4 8248      ST	Y,R4
    022F5 8259      STD	Y+1,R5
    022F6 0191      MOVW	R18,R2
    022F7 A5E8      LDD	R30,Y+40
    022F8 A5F9      LDD	R31,Y+41
    022F9 8100      LD	R16,Z
    022FA 8111      LDD	R17,Z+1
    022FB 940E 04F4 CALL	_clust2sect
    022FD 870A      STD	Y+10,R16
    022FE 871B      STD	Y+11,R17
    022FF 872C      STD	Y+12,R18
    02300 873D      STD	Y+13,R19
(2926) 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    02301 842A      LDD	R2,Y+10
    02302 843B      LDD	R3,Y+11
    02303 844C      LDD	R4,Y+12
    02304 845D      LDD	R5,Y+13
    02305 9488      BCLR	0
    02306 2022      TST	R2
    02307 0432      CPC	R3,R2
    02308 0442      CPC	R4,R2
    02309 0452      CPC	R5,R2
    0230A F451      BNE	0x2315
    0230B A588      LDD	R24,Y+40
    0230C A599      LDD	R25,Y+41
    0230D 9604      ADIW	R24,4
    0230E 017C      MOVW	R14,R24
    0230F 01FC      MOVW	R30,R24
    02310 8180      LD	R24,Z
    02311 6880      ORI	R24,0x80
    02312 8380      ST	Z,R24
    02313 E002      LDI	R16,2
    02314 C061      RJMP	0x2376
(2927) 					nsect += ofs / SS(fp->fs);
    02315 E089      LDI	R24,0x9
    02316 E090      LDI	R25,0
    02317 A50A      LDD	R16,Y+42
    02318 A51B      LDD	R17,Y+43
    02319 A52C      LDD	R18,Y+44
    0231A A53D      LDD	R19,Y+45
    0231B 938A      ST	-Y,R24
    0231C 940E 433F CALL	lsr32
    0231E 842A      LDD	R2,Y+10
    0231F 843B      LDD	R3,Y+11
    02320 844C      LDD	R4,Y+12
    02321 845D      LDD	R5,Y+13
    02322 0E20      ADD	R2,R16
    02323 1E31      ADC	R3,R17
    02324 1E42      ADC	R4,R18
    02325 1E53      ADC	R5,R19
    02326 862A      STD	Y+10,R2
    02327 863B      STD	Y+11,R3
    02328 864C      STD	Y+12,R4
    02329 865D      STD	Y+13,R5
(2928) 				}
(2929) 			}
(2930) 		}
(2931) 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    0232A EF4F      LDI	R20,0xFF
    0232B E051      LDI	R21,1
    0232C E060      LDI	R22,0
    0232D E070      LDI	R23,0
    0232E A5E8      LDD	R30,Y+40
    0232F A5F9      LDD	R31,Y+41
    02330 9636      ADIW	R30,6
    02331 8020      LD	R2,Z
    02332 8031      LDD	R3,Z+1
    02333 8042      LDD	R4,Z+2
    02334 8053      LDD	R5,Z+3
    02335 2224      AND	R2,R20
    02336 2235      AND	R3,R21
    02337 2246      AND	R4,R22
    02338 2257      AND	R5,R23
    02339 9488      BCLR	0
    0233A 2022      TST	R2
    0233B 0432      CPC	R3,R2
    0233C 0442      CPC	R4,R2
    0233D 0452      CPC	R5,R2
    0233E F0C1      BEQ	0x2357
    0233F A5E8      LDD	R30,Y+40
    02340 A5F9      LDD	R31,Y+41
    02341 9676      ADIW	R30,0x16
    02342 8020      LD	R2,Z
    02343 8031      LDD	R3,Z+1
    02344 8042      LDD	R4,Z+2
    02345 8053      LDD	R5,Z+3
    02346 846A      LDD	R6,Y+10
    02347 847B      LDD	R7,Y+11
    02348 848C      LDD	R8,Y+12
    02349 849D      LDD	R9,Y+13
    0234A 1462      CP	R6,R2
    0234B 0473      CPC	R7,R3
    0234C 0484      CPC	R8,R4
    0234D 0495      CPC	R9,R5
    0234E F041      BEQ	0x2357
(2932) #if !_FS_TINY
(2933) #if !_FS_READONLY
(2934) 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
(2935) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2936) 					ABORT(fp->fs, FR_DISK_ERR);
(2937) 				fp->flag &= ~FA__DIRTY;
(2938) 			}
(2939) #endif
(2940) 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
(2941) 				ABORT(fp->fs, FR_DISK_ERR);
(2942) #endif
(2943) 			fp->dsect = nsect;
    0234F 0113      MOVW	R2,R6
    02350 0124      MOVW	R4,R8
    02351 A5E8      LDD	R30,Y+40
    02352 A5F9      LDD	R31,Y+41
    02353 8A26      STD	Z+22,R2
    02354 8A37      STD	Z+23,R3
    02355 8E40      STD	Z+24,R4
    02356 8E51      STD	Z+25,R5
(2944) 		}
(2945) #if !_FS_READONLY
(2946) 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    02357 A5E8      LDD	R30,Y+40
    02358 A5F9      LDD	R31,Y+41
    02359 8422      LDD	R2,Z+10
    0235A 8433      LDD	R3,Z+11
    0235B 8444      LDD	R4,Z+12
    0235C 8455      LDD	R5,Z+13
    0235D 8066      LDD	R6,Z+6
    0235E 8077      LDD	R7,Z+7
    0235F 8480      LDD	R8,Z+8
    02360 8491      LDD	R9,Z+9
    02361 1426      CP	R2,R6
    02362 0437      CPC	R3,R7
    02363 0448      CPC	R4,R8
    02364 0459      CPC	R5,R9
    02365 F478      BCC	0x2375
(2947) 			fp->fsize = fp->fptr;
    02366 8026      LDD	R2,Z+6
    02367 8037      LDD	R3,Z+7
    02368 8440      LDD	R4,Z+8
    02369 8451      LDD	R5,Z+9
    0236A 8622      STD	Z+10,R2
    0236B 8633      STD	Z+11,R3
    0236C 8644      STD	Z+12,R4
    0236D 8655      STD	Z+13,R5
(2948) 			fp->flag |= FA__WRITTEN;
    0236E 01CF      MOVW	R24,R30
    0236F 9604      ADIW	R24,4
    02370 016C      MOVW	R12,R24
    02371 01FC      MOVW	R30,R24
    02372 8180      LD	R24,Z
    02373 6280      ORI	R24,0x20
    02374 8380      ST	Z,R24
(2949) 		}
(2950) #endif
(2951) 	}
(2952) 
(2953) 	LEAVE_FF(fp->fs, res);
    02375 2D0A      MOV	R16,R10
    02376 966E      ADIW	R28,0x1E
    02377 940E 4299 CALL	pop_xgsetF0FC
    02379 9624      ADIW	R28,4
    0237A 9508      RET
_f_opendir:
  sfn                  --> Y,+1
  res                  --> R20
  path                 --> Y,+19
  dj                   --> R22
    0237B 933A      ST	-Y,R19
    0237C 932A      ST	-Y,R18
    0237D 940E 42C3 CALL	push_xgsetF00C
    0237F 01B8      MOVW	R22,R16
    02380 972D      SBIW	R28,0xD
(2954) }
(2955) 
(2956) 
(2957) 
(2958) #if _FS_MINIMIZE <= 1
(2959) /*-----------------------------------------------------------------------*/
(2960) /* Create a Directroy Object                                             */
(2961) /*-----------------------------------------------------------------------*/
(2962) 
(2963) FRESULT f_opendir (
(2964) 	DIR *dj,			/* Pointer to directory object to create */
(2965) 	const TCHAR *path	/* Pointer to the directory path */
(2966) )
(2967) {
(2968) 	FRESULT res;
(2969) 	DEF_NAMEBUF;
(2970) 
(2971) 
(2972) 	res = chk_mounted(&path, &dj->fs, 0);
    02381 2422      CLR	R2
    02382 8228      ST	Y,R2
    02383 019B      MOVW	R18,R22
    02384 018E      MOVW	R16,R28
    02385 5E0D      SUBI	R16,0xED
    02386 4F1F      SBCI	R17,0xFF
    02387 940E 119B CALL	ff.c:chk_mounted
    02389 2F40      MOV	R20,R16
(2973) 	if (res == FR_OK) {
    0238A 2300      TST	R16
    0238B F009      BEQ	0x238D
    0238C C05C      RJMP	0x23E9
(2974) 		INIT_BUF(*dj);
    0238D 01CE      MOVW	R24,R28
    0238E 9601      ADIW	R24,1
    0238F 01FB      MOVW	R30,R22
    02390 8B95      STD	Z+21,R25
    02391 8B84      STD	Z+20,R24
(2975) 		res = follow_path(dj, path);			/* Follow the path to the directory */
    02392 892B      LDD	R18,Y+19
    02393 893C      LDD	R19,Y+20
    02394 018F      MOVW	R16,R30
    02395 940E 104F CALL	ff.c:follow_path
    02397 2F40      MOV	R20,R16
(2976) 		FREE_BUF();
(2977) 		if (res == FR_OK) {						/* Follow completed */
    02398 2300      TST	R16
    02399 F009      BEQ	0x239B
    0239A C04B      RJMP	0x23E6
(2978) 			if (dj->dir) {						/* It is not the root dir */
    0239B 01FB      MOVW	R30,R22
    0239C 8822      LDD	R2,Z+18
    0239D 8833      LDD	R3,Z+19
    0239E 2022      TST	R2
    0239F F419      BNE	0x23A3
    023A0 2033      TST	R3
    023A1 F409      BNE	0x23A3
    023A2 C032      RJMP	0x23D5
(2979) 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    023A3 93AF      PUSH	R26
    023A4 93BF      PUSH	R27
    023A5 89A2      LDD	R26,Z+18
    023A6 89B3      LDD	R27,Z+19
    023A7 01FD      MOVW	R30,R26
    023A8 91BF      POP	R27
    023A9 91AF      POP	R26
    023AA 8423      LDD	R2,Z+11
    023AB FE24      SBRS	R2,4
    023AC C027      RJMP	0x23D4
(2980) 					dj->sclust = LD_CLUST(dj->dir);
    023AD 01FB      MOVW	R30,R22
    023AE 88A2      LDD	R10,Z+18
    023AF 88B3      LDD	R11,Z+19
    023B0 01F5      MOVW	R30,R10
    023B1 8C22      LDD	R2,Z+26
    023B2 2433      CLR	R3
    023B3 8C43      LDD	R4,Z+27
    023B4 2455      CLR	R5
    023B5 2C54      MOV	R5,R4
    023B6 2444      CLR	R4
    023B7 2842      OR	R4,R2
    023B8 2853      OR	R5,R3
    023B9 0112      MOVW	R2,R4
    023BA 2444      CLR	R4
    023BB 2455      CLR	R5
    023BC 8864      LDD	R6,Z+20
    023BD 2477      CLR	R7
    023BE 8885      LDD	R8,Z+21
    023BF 2499      CLR	R9
    023C0 2C98      MOV	R9,R8
    023C1 2488      CLR	R8
    023C2 2886      OR	R8,R6
    023C3 2897      OR	R9,R7
    023C4 0134      MOVW	R6,R8
    023C5 2488      CLR	R8
    023C6 2499      CLR	R9
    023C7 0143      MOVW	R8,R6
    023C8 2466      CLR	R6
    023C9 2477      CLR	R7
    023CA 2862      OR	R6,R2
    023CB 2873      OR	R7,R3
    023CC 2884      OR	R8,R4
    023CD 2895      OR	R9,R5
    023CE 01FB      MOVW	R30,R22
    023CF 8266      STD	Z+6,R6
    023D0 8277      STD	Z+7,R7
    023D1 8680      STD	Z+8,R8
    023D2 8691      STD	Z+9,R9
(2981) 				} else {						/* The object is not a directory */
    023D3 C001      RJMP	0x23D5
(2982) 					res = FR_NO_PATH;
    023D4 E045      LDI	R20,5
(2983) 				}
(2984) 			}
(2985) 			if (res == FR_OK) {
    023D5 2344      TST	R20
    023D6 F479      BNE	0x23E6
(2986) 				dj->id = dj->fs->id;
    023D7 01FB      MOVW	R30,R22
    023D8 81A0      LD	R26,Z
    023D9 81B1      LDD	R27,Z+1
    023DA 9616      ADIW	R26,6
    023DB 902D      LD	R2,X+
    023DC 903C      LD	R3,X
    023DD 8233      STD	Z+3,R3
    023DE 8222      STD	Z+2,R2
(2987) 				res = dir_sdi(dj, 0);			/* Rewind dir */
    023DF 2722      CLR	R18
    023E0 2733      CLR	R19
    023E1 018F      MOVW	R16,R30
    023E2 940E 0AF9 CALL	ff.c:dir_sdi
    023E4 2EA0      MOV	R10,R16
    023E5 2D4A      MOV	R20,R10
(2988) 			}
(2989) 		}
(2990) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
    023E6 3044      CPI	R20,4
    023E7 F409      BNE	0x23E9
    023E8 E045      LDI	R20,5
(2991) 	}
(2992) 
(2993) 	LEAVE_FF(dj->fs, res);
    023E9 2F04      MOV	R16,R20
    023EA 962D      ADIW	R28,0xD
    023EB 940E 42CA CALL	pop_xgsetF00C
    023ED 9622      ADIW	R28,2
    023EE 9508      RET
_f_readdir:
  sfn                  --> Y,+0
  res                  --> R20
  fno                  --> R10
  dj                   --> R22
    023EF 940E 42DF CALL	push_xgsetF03C
    023F1 0159      MOVW	R10,R18
    023F2 01B8      MOVW	R22,R16
    023F3 972C      SBIW	R28,0xC
(2994) }
(2995) 
(2996) 
(2997) 
(2998) 
(2999) /*-----------------------------------------------------------------------*/
(3000) /* Read Directory Entry in Sequense                                      */
(3001) /*-----------------------------------------------------------------------*/
(3002) 
(3003) FRESULT f_readdir (
(3004) 	DIR *dj,			/* Pointer to the open directory object */
(3005) 	FILINFO *fno		/* Pointer to file information to return */
(3006) )
(3007) {
(3008) 	FRESULT res;
(3009) 	DEF_NAMEBUF;
(3010) 
(3011) 
(3012) 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    023F4 01FB      MOVW	R30,R22
    023F5 8122      LDD	R18,Z+2
    023F6 8133      LDD	R19,Z+3
    023F7 8100      LD	R16,Z
    023F8 8111      LDD	R17,Z+1
    023F9 940E 1695 CALL	ff.c:validate
    023FB 2F40      MOV	R20,R16
(3013) 	if (res == FR_OK) {
    023FC 2300      TST	R16
    023FD F009      BEQ	0x23FF
    023FE C035      RJMP	0x2434
(3014) 		if (!fno) {
    023FF 20AA      TST	R10
    02400 F449      BNE	0x240A
    02401 20BB      TST	R11
    02402 F439      BNE	0x240A
(3015) 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    02403 2722      CLR	R18
    02404 2733      CLR	R19
    02405 018B      MOVW	R16,R22
    02406 940E 0AF9 CALL	ff.c:dir_sdi
    02408 2F40      MOV	R20,R16
(3016) 		} else {
    02409 C02A      RJMP	0x2434
(3017) 			INIT_BUF(*dj);
    0240A 01CE      MOVW	R24,R28
    0240B 01FB      MOVW	R30,R22
    0240C 8B95      STD	Z+21,R25
    0240D 8B84      STD	Z+20,R24
(3018) 			res = dir_read(dj);				/* Read an directory item */
    0240E 018F      MOVW	R16,R30
    0240F 940E 0DF6 CALL	ff.c:dir_read
    02411 2EC0      MOV	R12,R16
    02412 2D4C      MOV	R20,R12
(3019) 			if (res == FR_NO_FILE) {		/* Reached end of dir */
    02413 3004      CPI	R16,4
    02414 F441      BNE	0x241D
(3020) 				dj->sect = 0;
    02415 01FB      MOVW	R30,R22
    02416 963E      ADIW	R30,0xE
    02417 E080      LDI	R24,0
    02418 8380      ST	Z,R24
    02419 8381      STD	Z+1,R24
    0241A 8382      STD	Z+2,R24
    0241B 8383      STD	Z+3,R24
(3021) 				res = FR_OK;
    0241C 2744      CLR	R20
(3022) 			}
(3023) 			if (res == FR_OK) {				/* A valid entry is found */
    0241D 2344      TST	R20
    0241E F4A9      BNE	0x2434
(3024) 				get_fileinfo(dj, fno);		/* Get the object information */
    0241F 0195      MOVW	R18,R10
    02420 018B      MOVW	R16,R22
    02421 940E 0FAC CALL	ff.c:get_fileinfo
(3025) 				res = dir_next(dj, 0);		/* Increment index for next */
    02423 2722      CLR	R18
    02424 2733      CLR	R19
    02425 018B      MOVW	R16,R22
    02426 940E 0C03 CALL	ff.c:dir_next
    02428 2EA0      MOV	R10,R16
    02429 2D4A      MOV	R20,R10
(3026) 				if (res == FR_NO_FILE) {
    0242A 3004      CPI	R16,4
    0242B F441      BNE	0x2434
(3027) 					dj->sect = 0;
    0242C 01FB      MOVW	R30,R22
    0242D 963E      ADIW	R30,0xE
    0242E E080      LDI	R24,0
    0242F 8380      ST	Z,R24
    02430 8381      STD	Z+1,R24
    02431 8382      STD	Z+2,R24
    02432 8383      STD	Z+3,R24
(3028) 					res = FR_OK;
    02433 2744      CLR	R20
(3029) 				}
(3030) 			}
(3031) 			FREE_BUF();
(3032) 		}
(3033) 	}
(3034) 
(3035) 	LEAVE_FF(dj->fs, res);
    02434 2F04      MOV	R16,R20
    02435 962C      ADIW	R28,0xC
    02436 940C 42E8 JMP	pop_xgsetF03C
FILE: D:\LQD\software\software_src\delay.c
(0001) /*******************************
(0002)  function ：延时函数
(0003) Clock F  :7.3728M 
(0004) Software : ICCAVR7.14C
(0005) ********************************/
(0006) /*---------------------------------------------------------------------------------
(0007)      延时程序计算方法
(0008)      计数个数j = 延时时间/6*晶振频率 - 1
(0009) ---------------------------------------------------------------------------------*/
(0010) void delayus(unsigned int tttt)   // 1.2us 延时子函数   
(0011) { 
(0012)    do
(0013)    {
(0014)        tttt--;
_delayus:
  tttt                 --> R16
    02438 5001      SUBI	R16,1
    02439 4010      SBCI	R17,0
(0015)    }
(0016)    while(tttt>1);
    0243A E081      LDI	R24,1
    0243B E090      LDI	R25,0
    0243C 1780      CP	R24,R16
    0243D 0791      CPC	R25,R17
    0243E F3C8      BCS	0x2438
    0243F 9508      RET
_delayms:
  j                    --> R20
  i                    --> R16
    02440 934A      ST	-Y,R20
    02441 935A      ST	-Y,R21
(0017) }
(0018) void delayms(unsigned int i)                 //1ms延时
(0019)    {
    02442 C00A      RJMP	0x244D
(0020)     while(i--)
(0021)     {                          
(0022) 	    unsigned int j;                
(0023)         for(j=1;j<=1227;j++)   
    02443 E041      LDI	R20,1
    02444 E050      LDI	R21,0
    02445 C002      RJMP	0x2448
    02446 5F4F      SUBI	R20,0xFF
    02447 4F5F      SBCI	R21,0xFF
    02448 EC8B      LDI	R24,0xCB
    02449 E094      LDI	R25,4
    0244A 1784      CP	R24,R20
    0244B 0795      CPC	R25,R21
    0244C F7C8      BCC	0x2446
    0244D 0118      MOVW	R2,R16
    0244E 5001      SUBI	R16,1
    0244F 4010      SBCI	R17,0
    02450 2022      TST	R2
    02451 F789      BNE	0x2443
    02452 2033      TST	R3
    02453 F779      BNE	0x2443
    02454 9159      LD	R21,Y+
    02455 9149      LD	R20,Y+
    02456 9508      RET
FILE: D:\LQD\software\software_src\main.c
(0001) #include "config.h"
(0002) #define  N_per_Second  (2.72*60)
(0003) const char tab[]="\t\0";
(0004) const char enter[]="\n\0";
(0005) char buffer[512];
(0006) char TempChar[80]; //存放临时字串
(0007) struct DATA Result;
(0008) struct tm t;
(0009) unsigned long now =0; 
(0010) void debug(UINT8 *str,UINT8 val);
(0011) void WriteSDFile(void);
(0012) struct CONFIG config;
(0013) void initDevices(void){
(0014)      CLI();
_initDevices:
    02457 94F8      BCLR	7
(0015) 	 DDRA=0XFF;
    02458 EF8F      LDI	R24,0xFF
    02459 BB8A      OUT	0x1A,R24
(0016) 	 PORTA=0XFF;
    0245A BB8B      OUT	0x1B,R24
(0017) 	 DDRB=0XFF;
    0245B BB87      OUT	0x17,R24
(0018) 	 PORTB=0XFF; 	 
    0245C BB88      OUT	0x18,R24
(0019) 	 DDRC=0XFF;
    0245D BB84      OUT	0x14,R24
(0020) 	 PORTC=0XFF;
    0245E BB85      OUT	0x15,R24
(0021) 	 DDRG=0XFF;
    0245F 9380 0064 STS	0x64,R24
(0022) 	 PORTG=0XFF;	 
    02461 9380 0065 STS	0x65,R24
(0023) 	 SPI_IO_Init(); 
    02463 940E 3AC0 CALL	_SPI_IO_Init
(0024) 	 SD_Init();
    02465 940E 2C3A CALL	_SD_Init
(0025) 	 uart1_init();
    02467 940E 38EA CALL	_uart1_init
(0026) 	 LCD_INT();delayms(50);LCD_INT();
    02469 940E 3ADE CALL	_LCD_INT
    0246B E302      LDI	R16,0x32
    0246C E010      LDI	R17,0
    0246D 940E 2440 CALL	_delayms
    0246F 940E 3ADE CALL	_LCD_INT
(0027) 	 LCD_SW(1);
    02471 E001      LDI	R16,1
    02472 940E 3AD4 CALL	_LCD_SW
(0028) 	 config.THRESHOLD_delta_sec=5; //一次检测用时
    02474 E085      LDI	R24,5
    02475 9380 083F STS	config+4,R24
    02477 E080      LDI	R24,0
    02478 9380 0840 STS	config+5,R24
    0247A 9380 0841 STS	config+6,R24
    0247C 9380 0842 STS	config+7,R24
(0029) 	 config.autocheck=1;        //自动检测开关
    0247E E081      LDI	R24,1
    0247F 9380 084B STS	config+16,R24
(0030) 	 config.checkDeltaTime=3;  //自动检测模式 时间间隔
    02481 E083      LDI	R24,3
    02482 E090      LDI	R25,0
    02483 9390 084D STS	config+18,R25
    02485 9380 084C STS	config+17,R24
(0031) 	 config.readMode = 0;      //读数据模式
    02487 2422      CLR	R2
    02488 9220 084E STS	config+19,R2
(0032) 	 SEI();
    0248A 9478      BSET	7
    0248B 9508      RET
(0033) }
(0034) void timer1_init(void)
(0035) {
(0036)  TCCR1B = 0x00; //stop
_timer1_init:
    0248C 2422      CLR	R2
    0248D BC2E      OUT	0x2E,R2
(0037)  TCNT1H = 0x00 /*INVALID SETTING*/; //setup
    0248E BC2D      OUT	0x2D,R2
(0038)  TCNT1L = 0x00 /*INVALID SETTING*/;
    0248F BC2C      OUT	0x2C,R2
(0039)  TCCR1A = 0x00;
    02490 BC2F      OUT	0x2F,R2
(0040)  TCCR1B = 0x46; //start Timer
    02491 E486      LDI	R24,0x46
    02492 BD8E      OUT	0x2E,R24
    02493 9508      RET
_main:
  keycode              --> Y,+1
  i                    --> R10
  filename             --> Y,+513
  buf512               --> Y,+0
  tmp                  --> R10
    02494 97EF      SBIW	R28,0x3F
    02495 97EF      SBIW	R28,0x3F
    02496 97EF      SBIW	R28,0x3F
    02497 97EF      SBIW	R28,0x3F
    02498 97EF      SBIW	R28,0x3F
    02499 97EF      SBIW	R28,0x3F
    0249A 97EF      SBIW	R28,0x3F
    0249B 97EF      SBIW	R28,0x3F
    0249C 9767      SBIW	R28,0x17
(0041) }
(0042) ////////////////////////////////////////////////////////////////
(0043) void main(void){
(0044) 	 UINT8 tmp,keycode;
(0045) 	 UINT8 buf512[513];
(0046) 	 char filename[]="201301.xls\0\0\0";
    0249D E189      LDI	R24,0x19
    0249E E091      LDI	R25,1
    0249F 01FE      MOVW	R30,R28
    024A0 5FEF      SUBI	R30,0xFF
    024A1 4FFD      SBCI	R31,0xFD
    024A2 E00E      LDI	R16,0xE
    024A3 E010      LDI	R17,0
    024A4 93FA      ST	-Y,R31
    024A5 93EA      ST	-Y,R30
    024A6 939A      ST	-Y,R25
    024A7 938A      ST	-Y,R24
    024A8 940E 434B CALL	asgnblk
(0047) 	 int i=0;
    024AA 24AA      CLR	R10
    024AB 24BB      CLR	R11
(0048) 	 initDevices();
    024AC DFAA      RCALL	_initDevices
(0049) 	 dateRefresh(1);
    024AD E001      LDI	R16,1
    024AE 940E 379B CALL	_dateRefresh
(0050) 	 WriteFileHead();
    024B0 D0FD      RCALL	_WriteFileHead
(0051)      Result.Index=findIndex(get_name(filename),buf512);
    024B1 018E      MOVW	R16,R28
    024B2 5F0F      SUBI	R16,0xFF
    024B3 4F1D      SBCI	R17,0xFD
    024B4 D668      RCALL	_get_name
    024B5 019E      MOVW	R18,R28
    024B6 D287      RCALL	_findIndex
    024B7 0118      MOVW	R2,R16
    024B8 2444      CLR	R4
    024B9 2455      CLR	R5
    024BA 9230 05D6 STS	Result+11,R3
    024BC 9220 05D5 STS	Result+10,R2
    024BE 9250 05D8 STS	Result+13,R5
    024C0 9240 05D7 STS	Result+12,R4
(0052) 	 #ifdef _DBG_RD_
(0053) 	 	 while(1){
(0054) 		     GUI_readback(buf512);
(0055) 	     }
(0056) 	 #endif
(0057) 	 //selfTest();
(0058) 	 GUI_welcome();
    024C2 940E 377E CALL	_GUI_welcome
    024C4 C025      RJMP	0x24EA
(0059) 	 while(1){
(0060) 	    tmp=GUI_mainmeu();
    024C5 940E 2E13 CALL	_GUI_mainmeu
    024C7 2EA0      MOV	R10,R16
(0061) 		switch(tmp){
    024C8 2D4A      MOV	R20,R10
    024C9 2755      CLR	R21
    024CA 3043      CPI	R20,3
    024CB E0E0      LDI	R30,0
    024CC 075E      CPC	R21,R30
    024CD F069      BEQ	0x24DB
    024CE 3044      CPI	R20,4
    024CF E0E0      LDI	R30,0
    024D0 075E      CPC	R21,R30
    024D1 F061      BEQ	0x24DE
    024D2 3045      CPI	R20,5
    024D3 E0E0      LDI	R30,0
    024D4 075E      CPC	R21,R30
    024D5 F059      BEQ	0x24E1
    024D6 3047      CPI	R20,7
    024D7 E0E0      LDI	R30,0
    024D8 075E      CPC	R21,R30
    024D9 F059      BEQ	0x24E5
    024DA C00B      RJMP	0x24E6
(0062) 		    case 3 : GUI_check(); break; 
    024DB 940E 2F02 CALL	_GUI_check
    024DD C008      RJMP	0x24E6
(0063) 			case 4 : GUI_set_time(); break ;
    024DE 940E 33AF CALL	_GUI_set_time
    024E0 C005      RJMP	0x24E6
(0064) 			case 5 : GUI_readback(buf512); break;
    024E1 018E      MOVW	R16,R28
    024E2 940E 35ED CALL	_GUI_readback
    024E4 C001      RJMP	0x24E6
(0065) 			//case 6 : GUI_send_date();
(0066) 			case 7 : selfTest(); break ;
    024E5 D00F      RCALL	_selfTest
(0067) 			default : break;
(0068) 	   }
(0069) 	   delayms(100);
    024E6 E604      LDI	R16,0x64
    024E7 E010      LDI	R17,0
    024E8 940E 2440 CALL	_delayms
    024EA CFDA      RJMP	0x24C5
    024EB 96EF      ADIW	R28,0x3F
    024EC 96EF      ADIW	R28,0x3F
    024ED 96EF      ADIW	R28,0x3F
    024EE 96EF      ADIW	R28,0x3F
    024EF 96EF      ADIW	R28,0x3F
    024F0 96EF      ADIW	R28,0x3F
    024F1 96EF      ADIW	R28,0x3F
    024F2 96EF      ADIW	R28,0x3F
    024F3 9667      ADIW	R28,0x17
    024F4 9508      RET
_selfTest:
  str2                 --> Y,+12
  str1                 --> Y,+6
  tmp                  --> Y,+2
    024F5 9762      SBIW	R28,0x12
(0070) 	 }
(0071) 
(0072) }
(0073) void selfTest(void){
(0074) 	float tmp=0;                                                                
    024F6 EB04      LDI	R16,0xB4
    024F7 E010      LDI	R17,0
    024F8 940E 422C CALL	elpm32
    024FA 830A      STD	Y+2,R16
    024FB 831B      STD	Y+3,R17
    024FC 832C      STD	Y+4,R18
    024FD 833D      STD	Y+5,R19
(0075) 	char str1[6],str2[6];
(0076) 	
(0077) 	 //自检程序
(0078) 	lp("自检程序");delayms(500);
    024FE E50C      LDI	R16,0x5C
    024FF E012      LDI	R17,2
    02500 940E 3E0D CALL	_lp
    02502 EF04      LDI	R16,0xF4
    02503 E011      LDI	R17,1
    02504 940E 2440 CALL	_delayms
(0079) 	lp("外部温度 ");
    02506 E502      LDI	R16,0x52
    02507 E012      LDI	R17,2
    02508 940E 3E0D CALL	_lp
(0080) 	tmp=read_T_NUM(0);
    0250A 2700      CLR	R16
    0250B 940E 403B CALL	_read_T_NUM
    0250D 830A      STD	Y+2,R16
    0250E 831B      STD	Y+3,R17
    0250F 832C      STD	Y+4,R18
    02510 833D      STD	Y+5,R19
(0081) 	ftochr(tmp,str1);
    02511 01CE      MOVW	R24,R28
    02512 9606      ADIW	R24,6
    02513 8399      STD	Y+1,R25
    02514 8388      ST	Y,R24
    02515 810A      LDD	R16,Y+2
    02516 811B      LDD	R17,Y+3
    02517 812C      LDD	R18,Y+4
    02518 813D      LDD	R19,Y+5
    02519 D504      RCALL	_ftochr
(0082) 	str1[6]=0;
    0251A 2422      CLR	R2
    0251B 862C      STD	Y+12,R2
(0083) 	lp(str1);
    0251C 018E      MOVW	R16,R28
    0251D 5F0A      SUBI	R16,0xFA
    0251E 4F1F      SBCI	R17,0xFF
    0251F 940E 3E0D CALL	_lp
(0084) 	delayms(500);
    02521 EF04      LDI	R16,0xF4
    02522 E011      LDI	R17,1
    02523 940E 2440 CALL	_delayms
(0085) 	lp("内部温度");
    02525 E409      LDI	R16,0x49
    02526 E012      LDI	R17,2
    02527 940E 3E0D CALL	_lp
(0086) 	tmp=read_T_NUM(1);
    02529 E001      LDI	R16,1
    0252A 940E 403B CALL	_read_T_NUM
    0252C 830A      STD	Y+2,R16
    0252D 831B      STD	Y+3,R17
    0252E 832C      STD	Y+4,R18
    0252F 833D      STD	Y+5,R19
(0087) 	ftochr(tmp,str2);
    02530 01CE      MOVW	R24,R28
    02531 960C      ADIW	R24,0xC
    02532 8399      STD	Y+1,R25
    02533 8388      ST	Y,R24
    02534 810A      LDD	R16,Y+2
    02535 811B      LDD	R17,Y+3
    02536 812C      LDD	R18,Y+4
    02537 813D      LDD	R19,Y+5
    02538 D4E5      RCALL	_ftochr
(0088) 	str2[6]=0;
    02539 2422      CLR	R2
    0253A 8A2A      STD	Y+18,R2
(0089) 	lp(str2);
    0253B 018E      MOVW	R16,R28
    0253C 5F04      SUBI	R16,0xF4
    0253D 4F1F      SBCI	R17,0xFF
    0253E 940E 3E0D CALL	_lp
(0090) 	delayms(500);
    02540 EF04      LDI	R16,0xF4
    02541 E011      LDI	R17,1
    02542 940E 2440 CALL	_delayms
(0091) 	lp("风速脉冲：");delayms(500);
    02544 E30E      LDI	R16,0x3E
    02545 E012      LDI	R17,2
    02546 940E 3E0D CALL	_lp
    02548 EF04      LDI	R16,0xF4
    02549 E011      LDI	R17,1
    0254A 940E 2440 CALL	_delayms
(0092) 	lp("蜂鸣器"); beep(2,2);delayms(500);
    0254C E307      LDI	R16,0x37
    0254D E012      LDI	R17,2
    0254E 940E 3E0D CALL	_lp
    02550 E022      LDI	R18,2
    02551 E002      LDI	R16,2
    02552 940E 3E83 CALL	_beep
    02554 EF04      LDI	R16,0xF4
    02555 E011      LDI	R17,1
    02556 940E 2440 CALL	_delayms
(0093) 	lp("power 指示灯");
    02558 E20A      LDI	R16,0x2A
    02559 E012      LDI	R17,2
    0255A 940E 3E0D CALL	_lp
(0094) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    0255C 9AA7      SBI	0x14,7
    0255D 98AF      CBI	0x15,7
    0255E E604      LDI	R16,0x64
    0255F E010      LDI	R17,0
    02560 940E 2440 CALL	_delayms
    02562 9AA7      SBI	0x14,7
    02563 9AAF      SBI	0x15,7
    02564 E604      LDI	R16,0x64
    02565 E010      LDI	R17,0
    02566 940E 2440 CALL	_delayms
(0095) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02568 9AA7      SBI	0x14,7
    02569 98AF      CBI	0x15,7
    0256A E604      LDI	R16,0x64
    0256B E010      LDI	R17,0
    0256C 940E 2440 CALL	_delayms
    0256E 9AA7      SBI	0x14,7
    0256F 9AAF      SBI	0x15,7
    02570 E604      LDI	R16,0x64
    02571 E010      LDI	R17,0
    02572 940E 2440 CALL	_delayms
(0096) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02574 9AA7      SBI	0x14,7
    02575 98AF      CBI	0x15,7
    02576 E604      LDI	R16,0x64
    02577 E010      LDI	R17,0
    02578 940E 2440 CALL	_delayms
    0257A 9AA7      SBI	0x14,7
    0257B 9AAF      SBI	0x15,7
    0257C E604      LDI	R16,0x64
    0257D E010      LDI	R17,0
    0257E 940E 2440 CALL	_delayms
(0097) 	delayms(500);
    02580 EF04      LDI	R16,0xF4
    02581 E011      LDI	R17,1
    02582 940E 2440 CALL	_delayms
(0098) 	lp("加热开关");
    02584 E201      LDI	R16,0x21
    02585 E012      LDI	R17,2
    02586 940E 3E0D CALL	_lp
(0099) 	RELAY_ON();delayms(100);  
    02588 9AAD      SBI	0x15,5
    02589 E604      LDI	R16,0x64
    0258A E010      LDI	R17,0
    0258B 940E 2440 CALL	_delayms
(0100) 	RELAY_OFF();delayms(100);
    0258D 98AD      CBI	0x15,5
    0258E E604      LDI	R16,0x64
    0258F E010      LDI	R17,0
    02590 940E 2440 CALL	_delayms
(0101) 	RELAY_ON();delayms(100);
    02592 9AAD      SBI	0x15,5
    02593 E604      LDI	R16,0x64
    02594 E010      LDI	R17,0
    02595 940E 2440 CALL	_delayms
(0102) 	RELAY_OFF();delayms(100);
    02597 98AD      CBI	0x15,5
    02598 E604      LDI	R16,0x64
    02599 E010      LDI	R17,0
    0259A 940E 2440 CALL	_delayms
(0103) 	lp("  ");delayms(500);
    0259C E10E      LDI	R16,0x1E
    0259D E012      LDI	R17,2
    0259E 940E 3E0D CALL	_lp
    025A0 EF04      LDI	R16,0xF4
    025A1 E011      LDI	R17,1
    025A2 940E 2440 CALL	_delayms
(0104) 	lp("完成自检");delayms(500);
    025A4 E105      LDI	R16,0x15
    025A5 E012      LDI	R17,2
    025A6 940E 3E0D CALL	_lp
    025A8 EF04      LDI	R16,0xF4
    025A9 E011      LDI	R17,1
    025AA 940E 2440 CALL	_delayms
    025AC 9662      ADIW	R28,0x12
    025AD 9508      RET
_WriteFileHead:
  fs                   --> Y,+177
  bw                   --> Y,+175
  fnamep               --> Y,+161
  itam                 --> Y,+38
  file                 --> Y,+4
  res                  --> R10
    025AE 940E 42AA CALL	push_xgset003C
    025B0 97EF      SBIW	R28,0x3F
    025B1 97EF      SBIW	R28,0x3F
    025B2 97EF      SBIW	R28,0x3F
    025B3 97EF      SBIW	R28,0x3F
    025B4 97EF      SBIW	R28,0x3F
    025B5 97EF      SBIW	R28,0x3F
    025B6 97EF      SBIW	R28,0x3F
    025B7 97EF      SBIW	R28,0x3F
    025B8 97EF      SBIW	R28,0x3F
    025B9 97EF      SBIW	R28,0x3F
    025BA 97EF      SBIW	R28,0x3F
    025BB 97AA      SBIW	R28,0x2A
(0105) 	  
(0106) }
(0107) 
(0108) void WriteFileHead(void)   
(0109) {
(0110)  	 unsigned int bw;
(0111) 	 FRESULT res;
(0112) 	 FATFS fs;
(0113) 	 FIL file;
(0114) 	 char fnamep[]="201201.xls\0\0\0"; 
    025BC E287      LDI	R24,0x27
    025BD E091      LDI	R25,1
    025BE 01FE      MOVW	R30,R28
    025BF 55EF      SUBI	R30,0x5F
    025C0 4FFF      SBCI	R31,0xFF
    025C1 E00E      LDI	R16,0xE
    025C2 E010      LDI	R17,0
    025C3 93FA      ST	-Y,R31
    025C4 93EA      ST	-Y,R30
    025C5 939A      ST	-Y,R25
    025C6 938A      ST	-Y,R24
    025C7 940E 434B CALL	asgnblk
(0115) 	 UINT8 itam[]="DEV000001\t\t\t\t\t\t\t\t\t\t\r\n序号\t日期\t时分\t温度\t风速\t风冷指数\t等价制冷温度\t相当温度\t冻伤危害性\t安静作业\t中等强度作业\t高强度作业\n\0";
    025C9 E385      LDI	R24,0x35
    025CA E091      LDI	R25,1
    025CB 01FE      MOVW	R30,R28
    025CC 96B6      ADIW	R30,0x26
    025CD E70B      LDI	R16,0x7B
    025CE E010      LDI	R17,0
    025CF 93FA      ST	-Y,R31
    025D0 93EA      ST	-Y,R30
    025D1 939A      ST	-Y,R25
    025D2 938A      ST	-Y,R24
    025D3 940E 434B CALL	asgnblk
(0116) 	 res=disk_initialize(0);
    025D5 2700      CLR	R16
    025D6 940E 02C6 CALL	_disk_initialize
    025D8 2EA0      MOV	R10,R16
(0117) 	 #ifdef _DEBUG
(0118) 	 debug("dinit",res);
    025D9 2D2A      MOV	R18,R10
    025DA E00F      LDI	R16,0xF
    025DB E012      LDI	R17,2
    025DC D61B      RCALL	_debug
(0119) 	 #endif
(0120) 	 res = f_mount(0, &fs);
    025DD 019E      MOVW	R18,R28
    025DE 542F      SUBI	R18,0x4F
    025DF 4F3F      SBCI	R19,0xFF
    025E0 2700      CLR	R16
    025E1 940E 16B2 CALL	_f_mount
    025E3 2EA0      MOV	R10,R16
(0121) 	 #ifdef _DEBUG
(0122)  	 debug("dmnt",res);
    025E4 2D2A      MOV	R18,R10
    025E5 E00A      LDI	R16,0xA
    025E6 E012      LDI	R17,2
    025E7 D610      RCALL	_debug
(0123) 	 #endif
(0124) 	 //get_name(fnamep)
(0125) 	 res = f_open(&file, get_name(fnamep) , FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    025E8 018E      MOVW	R16,R28
    025E9 550F      SUBI	R16,0x5F
    025EA 4F1F      SBCI	R17,0xFF
    025EB D531      RCALL	_get_name
    025EC 0168      MOVW	R12,R16
    025ED E182      LDI	R24,0x12
    025EE 8388      ST	Y,R24
    025EF 0196      MOVW	R18,R12
    025F0 018E      MOVW	R16,R28
    025F1 5F0C      SUBI	R16,0xFC
    025F2 4F1F      SBCI	R17,0xFF
    025F3 940E 16DD CALL	_f_open
    025F5 2EC0      MOV	R12,R16
    025F6 2CAC      MOV	R10,R12
(0126) 	 #ifdef _DEBUG
(0127) 	 debug("fopen",res);
    025F7 2D2A      MOV	R18,R10
    025F8 E004      LDI	R16,4
    025F9 E012      LDI	R17,2
    025FA D5FD      RCALL	_debug
(0128) 	 #endif
(0129) 	 res = f_write(&file,itam,sizeof(itam),&bw);   //bw 已写入字节数
    025FB 01CE      MOVW	R24,R28
    025FC 5581      SUBI	R24,0x51
    025FD 4F9F      SBCI	R25,0xFF
    025FE 839B      STD	Y+3,R25
    025FF 838A      STD	Y+2,R24
    02600 E78B      LDI	R24,0x7B
    02601 E090      LDI	R25,0
    02602 8399      STD	Y+1,R25
    02603 8388      ST	Y,R24
    02604 019E      MOVW	R18,R28
    02605 5D2A      SUBI	R18,0xDA
    02606 4F3F      SBCI	R19,0xFF
    02607 018E      MOVW	R16,R28
    02608 5F0C      SUBI	R16,0xFC
    02609 4F1F      SBCI	R17,0xFF
    0260A 940E 1AE4 CALL	_f_write
    0260C 2EC0      MOV	R12,R16
    0260D 2CAC      MOV	R10,R12
(0130) 	 #ifdef _DEBUG
(0131) 	 debug("fwrite",res);
    0260E 2D2A      MOV	R18,R10
    0260F EF0D      LDI	R16,0xFD
    02610 E011      LDI	R17,1
    02611 D5E6      RCALL	_debug
(0132) 	 #endif
(0133) 	 f_close(&file);
    02612 018E      MOVW	R16,R28
    02613 5F0C      SUBI	R16,0xFC
    02614 4F1F      SBCI	R17,0xFF
    02615 940E 1EAE CALL	_f_close
(0134) 	 f_mount(0, NULL);
    02617 2722      CLR	R18
    02618 2733      CLR	R19
    02619 2700      CLR	R16
    0261A 940E 16B2 CALL	_f_mount
    0261C 96EF      ADIW	R28,0x3F
    0261D 96EF      ADIW	R28,0x3F
    0261E 96EF      ADIW	R28,0x3F
    0261F 96EF      ADIW	R28,0x3F
    02620 96EF      ADIW	R28,0x3F
    02621 96EF      ADIW	R28,0x3F
    02622 96EF      ADIW	R28,0x3F
    02623 96EF      ADIW	R28,0x3F
    02624 96EF      ADIW	R28,0x3F
    02625 96EF      ADIW	R28,0x3F
    02626 96EF      ADIW	R28,0x3F
    02627 96AA      ADIW	R28,0x2A
    02628 940C 4284 JMP	pop_xgset003C
_WriteSDFile:
  fnamep               --> Y,+602
  fs                   --> Y,+44
  bw                   --> Y,+42
  lenth                --> Y,+38
  res                  --> R10
  file                 --> Y,+4
    0262A 92AA      ST	-Y,R10
    0262B 92CA      ST	-Y,R12
    0262C 97EF      SBIW	R28,0x3F
    0262D 97EF      SBIW	R28,0x3F
    0262E 97EF      SBIW	R28,0x3F
    0262F 97EF      SBIW	R28,0x3F
    02630 97EF      SBIW	R28,0x3F
    02631 97EF      SBIW	R28,0x3F
    02632 97EF      SBIW	R28,0x3F
    02633 97EF      SBIW	R28,0x3F
    02634 97EF      SBIW	R28,0x3F
    02635 97E0      SBIW	R28,0x30
(0135) } /////////////////////////////////////////////////
(0136) //       写入文件函数 
(0137) //(创建)打开文件 
(0138) // data 指向欲写入的的字符串 64byt 
(0139) //////////////////////////////////////////////// 
(0140) void WriteSDFile(void)   
(0141) {
(0142)     unsigned int bw;
(0143) 	FRESULT res;
(0144) 	FATFS fs;
(0145)     FIL file;
(0146) 	char fnamep[13];
(0147) 	long lenth=0;
    02636 E080      LDI	R24,0
    02637 A38E      STD	Y+38,R24
    02638 A38F      STD	Y+39,R24
    02639 A788      STD	Y+40,R24
    0263A A789      STD	Y+41,R24
(0148) 	disk_initialize(0);
    0263B 2700      CLR	R16
    0263C 940E 02C6 CALL	_disk_initialize
(0149) 	res = f_mount(0, &fs);
    0263E 019E      MOVW	R18,R28
    0263F 5D24      SUBI	R18,0xD4
    02640 4F3F      SBCI	R19,0xFF
    02641 2700      CLR	R16
    02642 940E 16B2 CALL	_f_mount
(0150) 	res = f_open(&file,get_name(fnamep), FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    02644 018E      MOVW	R16,R28
    02645 5A06      SUBI	R16,0xA6
    02646 4F1D      SBCI	R17,0xFD
    02647 D4D5      RCALL	_get_name
    02648 E182      LDI	R24,0x12
    02649 8388      ST	Y,R24
    0264A 0198      MOVW	R18,R16
    0264B 018E      MOVW	R16,R28
    0264C 5F0C      SUBI	R16,0xFC
    0264D 4F1F      SBCI	R17,0xFF
    0264E 940E 16DD CALL	_f_open
(0151) 	lenth=file.fsize;   
    02650 842E      LDD	R2,Y+14
    02651 843F      LDD	R3,Y+15
    02652 8848      LDD	R4,Y+16
    02653 8859      LDD	R5,Y+17
    02654 A22E      STD	Y+38,R2
    02655 A23F      STD	Y+39,R3
    02656 A648      STD	Y+40,R4
    02657 A659      STD	Y+41,R5
(0152) 	res = f_lseek (&file,lenth);	 
    02658 A02E      LDD	R2,Y+38
    02659 A03F      LDD	R3,Y+39
    0265A A448      LDD	R4,Y+40
    0265B A459      LDD	R5,Y+41
    0265C 8248      ST	Y,R4
    0265D 8259      STD	Y+1,R5
    0265E 0191      MOVW	R18,R2
    0265F 018E      MOVW	R16,R28
    02660 5F0C      SUBI	R16,0xFC
    02661 4F1F      SBCI	R17,0xFF
    02662 940E 1EBE CALL	_f_lseek
(0153) 	res = f_write(&file,TempChar,SINGLE_ITEM_SIZE,&bw);   //bw 已写入字节数
    02664 01CE      MOVW	R24,R28
    02665 968A      ADIW	R24,0x2A
    02666 839B      STD	Y+3,R25
    02667 838A      STD	Y+2,R24
    02668 E480      LDI	R24,0x40
    02669 E090      LDI	R25,0
    0266A 8399      STD	Y+1,R25
    0266B 8388      ST	Y,R24
    0266C E72B      LDI	R18,0x7B
    0266D E035      LDI	R19,5
    0266E 018E      MOVW	R16,R28
    0266F 5F0C      SUBI	R16,0xFC
    02670 4F1F      SBCI	R17,0xFF
    02671 940E 1AE4 CALL	_f_write
    02673 2EC0      MOV	R12,R16
    02674 2CAC      MOV	R10,R12
(0154) 	f_close(&file);
    02675 018E      MOVW	R16,R28
    02676 5F0C      SUBI	R16,0xFC
    02677 4F1F      SBCI	R17,0xFF
    02678 940E 1EAE CALL	_f_close
(0155) 	f_mount(0, NULL);
    0267A 2722      CLR	R18
    0267B 2733      CLR	R19
    0267C 2700      CLR	R16
    0267D 940E 16B2 CALL	_f_mount
    0267F 96EF      ADIW	R28,0x3F
    02680 96EF      ADIW	R28,0x3F
    02681 96EF      ADIW	R28,0x3F
    02682 96EF      ADIW	R28,0x3F
    02683 96EF      ADIW	R28,0x3F
    02684 96EF      ADIW	R28,0x3F
    02685 96EF      ADIW	R28,0x3F
    02686 96EF      ADIW	R28,0x3F
    02687 96EF      ADIW	R28,0x3F
    02688 96E0      ADIW	R28,0x30
    02689 90C9      LD	R12,Y+
    0268A 90A9      LD	R10,Y+
    0268B 9508      RET
_ReadSDFile:
  fs                   --> Y,+40
  bw                   --> Y,+38
  max                  --> R12
  file                 --> Y,+4
  res                  --> R20
  mode                 --> R22
  data                 --> R10
  index                --> R14
  fnamep               --> R12
    0268C 940E 42A4 CALL	push_xgsetF0FC
    0268E 0179      MOVW	R14,R18
    0268F 0168      MOVW	R12,R16
    02690 97EF      SBIW	R28,0x3F
    02691 97EF      SBIW	R28,0x3F
    02692 97EF      SBIW	R28,0x3F
    02693 97EF      SBIW	R28,0x3F
    02694 97EF      SBIW	R28,0x3F
    02695 97EF      SBIW	R28,0x3F
    02696 97EF      SBIW	R28,0x3F
    02697 97EF      SBIW	R28,0x3F
    02698 97EF      SBIW	R28,0x3F
    02699 976F      SBIW	R28,0x1F
    0269A 01FE      MOVW	R30,R28
    0269B 5AE0      SUBI	R30,0xA0
    0269C 4FFD      SBCI	R31,0xFD
    0269D 80A0      LD	R10,Z
    0269E 80B1      LDD	R11,Z+1
    0269F 01FE      MOVW	R30,R28
    026A0 59EE      SUBI	R30,0x9E
    026A1 4FFD      SBCI	R31,0xFD
    026A2 8160      LD	R22,Z
(0156) }
(0157) /////////////////////////////////////////////////
(0158) //       读取文件函数
(0159) //以64byte为一块 读取
(0160) //index数据偏移量   data读出后存放地
(0161) //////////////////////////////////////////////// 
(0162) char ReadSDFile(char *fnamep,int index, char *data, char mode)
(0163) {
(0164)  	unsigned int bw;
(0165) 	char res;
(0166) 	FATFS fs;
(0167)     FIL file;
(0168) 	static int indexoffset;
(0169) 	unsigned int max;
(0170) 	disk_initialize(0);
    026A3 2700      CLR	R16
    026A4 940E 02C6 CALL	_disk_initialize
(0171)     res = f_mount(0, &fs);
    026A6 019E      MOVW	R18,R28
    026A7 5D28      SUBI	R18,0xD8
    026A8 4F3F      SBCI	R19,0xFF
    026A9 2700      CLR	R16
    026AA 940E 16B2 CALL	_f_mount
(0172)     res = f_open(&file,fnamep,FA_READ);  
    026AC E081      LDI	R24,1
    026AD 8388      ST	Y,R24
    026AE 0196      MOVW	R18,R12
    026AF 018E      MOVW	R16,R28
    026B0 5F0C      SUBI	R16,0xFC
    026B1 4F1F      SBCI	R17,0xFF
    026B2 940E 16DD CALL	_f_open
    026B4 2F40      MOV	R20,R16
(0173)     if(res==FR_NO_FILE) {
    026B5 3004      CPI	R16,4
    026B6 F419      BNE	0x26BA
(0174) 	data=NULL;
    026B7 24AA      CLR	R10
    026B8 24BB      CLR	R11
(0175)     #if _debug >= 1 
(0176)     debug_out("now file",255);
(0177) 	debug_out(filename,res);
(0178) 	debug_out("file is no exist....",255);
(0179)     #endif 
(0180)     return res;
    026B9 C078      RJMP	0x2732
(0181)     }   
(0182)     max = (file.fsize-128)/SINGLE_ITEM_SIZE;
    026BA E880      LDI	R24,0x80
    026BB E090      LDI	R25,0
    026BC E0A0      LDI	R26,0
    026BD E0B0      LDI	R27,0
    026BE 850E      LDD	R16,Y+14
    026BF 851F      LDD	R17,Y+15
    026C0 8928      LDD	R18,Y+16
    026C1 8939      LDD	R19,Y+17
    026C2 1B08      SUB	R16,R24
    026C3 0B19      SBC	R17,R25
    026C4 0B2A      SBC	R18,R26
    026C5 0B3B      SBC	R19,R27
    026C6 E086      LDI	R24,6
    026C7 E090      LDI	R25,0
    026C8 938A      ST	-Y,R24
    026C9 940E 433F CALL	lsr32
    026CB 0168      MOVW	R12,R16
(0183) 	if(mode == 0){ //绝对位置模式
    026CC 2366      TST	R22
    026CD F429      BNE	0x26D3
(0184) 		indexoffset = index;
    026CE 92F0 057A STS	main.c:indexoffset+1,R15
    026D0 92E0 0579 STS	main.c:indexoffset,R14
(0185) 	}
    026D2 C00C      RJMP	0x26DF
(0186) 	else if(mode == 1){ //位置偏移模式
    026D3 3061      CPI	R22,1
    026D4 F451      BNE	0x26DF
(0187) 		indexoffset+=index;
    026D5 9020 0579 LDS	R2,main.c:indexoffset
    026D7 9030 057A LDS	R3,main.c:indexoffset+1
    026D9 0C2E      ADD	R2,R14
    026DA 1C3F      ADC	R3,R15
    026DB 9230 057A STS	main.c:indexoffset+1,R3
    026DD 9220 0579 STS	main.c:indexoffset,R2
(0188) 	}
(0189) 	if(indexoffset >max){
    026DF 9020 0579 LDS	R2,main.c:indexoffset
    026E1 9030 057A LDS	R3,main.c:indexoffset+1
    026E3 14C2      CP	R12,R2
    026E4 04D3      CPC	R13,R3
    026E5 F428      BCC	0x26EB
(0190) 	    indexoffset = max;
    026E6 92D0 057A STS	main.c:indexoffset+1,R13
    026E8 92C0 0579 STS	main.c:indexoffset,R12
(0191) 	}
    026EA C00F      RJMP	0x26FA
(0192) 	else if(indexoffset <=0){
    026EB 2422      CLR	R2
    026EC 2433      CLR	R3
    026ED 9040 0579 LDS	R4,main.c:indexoffset
    026EF 9050 057A LDS	R5,main.c:indexoffset+1
    026F1 1424      CP	R2,R4
    026F2 0435      CPC	R3,R5
    026F3 F034      BLT	0x26FA
(0193) 		indexoffset = 1;
    026F4 E081      LDI	R24,1
    026F5 E090      LDI	R25,0
    026F6 9390 057A STS	main.c:indexoffset+1,R25
    026F8 9380 0579 STS	main.c:indexoffset,R24
(0194) 	}
(0195) 	res = f_lseek (&file,(indexoffset-1)*SINGLE_ITEM_SIZE+128);	 //前两个字节数据为文件头空间 所以从第三块读/写起
    026FA 9120 0579 LDS	R18,main.c:indexoffset
    026FC 9130 057A LDS	R19,main.c:indexoffset+1
    026FE E400      LDI	R16,0x40
    026FF E010      LDI	R17,0
    02700 940E 4240 CALL	empy16s
    02702 01C8      MOVW	R24,R16
    02703 5480      SUBI	R24,0x40
    02704 4090      SBCI	R25,0
    02705 5880      SUBI	R24,0x80
    02706 4F9F      SBCI	R25,0xFF
    02707 011C      MOVW	R2,R24
    02708 2444      CLR	R4
    02709 FC37      SBRC	R3,7
    0270A 9440      COM	R4
    0270B 2455      CLR	R5
    0270C FC47      SBRC	R4,7
    0270D 9450      COM	R5
    0270E 8248      ST	Y,R4
    0270F 8259      STD	Y+1,R5
    02710 0191      MOVW	R18,R2
    02711 018E      MOVW	R16,R28
    02712 5F0C      SUBI	R16,0xFC
    02713 4F1F      SBCI	R17,0xFF
    02714 940E 1EBE CALL	_f_lseek
    02716 2EC0      MOV	R12,R16
(0196)     res = f_read(&file,data,SINGLE_ITEM_SIZE,&bw);
    02717 01CE      MOVW	R24,R28
    02718 9686      ADIW	R24,0x26
    02719 839B      STD	Y+3,R25
    0271A 838A      STD	Y+2,R24
    0271B E480      LDI	R24,0x40
    0271C E090      LDI	R25,0
    0271D 8399      STD	Y+1,R25
    0271E 8388      ST	Y,R24
    0271F 0195      MOVW	R18,R10
    02720 018E      MOVW	R16,R28
    02721 5F0C      SUBI	R16,0xFC
    02722 4F1F      SBCI	R17,0xFF
    02723 940E 1879 CALL	_f_read
    02725 2EA0      MOV	R10,R16
    02726 2D4A      MOV	R20,R10
(0197)     f_close(&file);
    02727 018E      MOVW	R16,R28
    02728 5F0C      SUBI	R16,0xFC
    02729 4F1F      SBCI	R17,0xFF
    0272A 940E 1EAE CALL	_f_close
(0198) 	f_mount(0, NULL);
    0272C 2722      CLR	R18
    0272D 2733      CLR	R19
    0272E 2700      CLR	R16
    0272F 940E 16B2 CALL	_f_mount
(0199) 	return res;
    02731 2F04      MOV	R16,R20
    02732 96EF      ADIW	R28,0x3F
    02733 96EF      ADIW	R28,0x3F
    02734 96EF      ADIW	R28,0x3F
    02735 96EF      ADIW	R28,0x3F
    02736 96EF      ADIW	R28,0x3F
    02737 96EF      ADIW	R28,0x3F
    02738 96EF      ADIW	R28,0x3F
    02739 96EF      ADIW	R28,0x3F
    0273A 96EF      ADIW	R28,0x3F
    0273B 966F      ADIW	R28,0x1F
    0273C 940C 4299 JMP	pop_xgsetF0FC
_findIndex:
  fs                   --> Y,+48
  bw                   --> Y,+46
  fnamep               --> R14
  readsize             --> R10
  res                  --> R12
  file                 --> Y,+12
  lenth                --> Y,+8
  index                --> Y,+4
  is_first_end         --> Y,+606
  tmp                  --> R10
  buf                  --> Y,+617
  filename             --> R10
    0273E 933A      ST	-Y,R19
    0273F 932A      ST	-Y,R18
    02740 940E 42A4 CALL	push_xgsetF0FC
    02742 0158      MOVW	R10,R16
    02743 97EF      SBIW	R28,0x3F
    02744 97EF      SBIW	R28,0x3F
    02745 97EF      SBIW	R28,0x3F
    02746 97EF      SBIW	R28,0x3F
    02747 97EF      SBIW	R28,0x3F
    02748 97EF      SBIW	R28,0x3F
    02749 97EF      SBIW	R28,0x3F
    0274A 97EF      SBIW	R28,0x3F
    0274B 97EF      SBIW	R28,0x3F
    0274C 97A8      SBIW	R28,0x28
(0200) } 
(0201) //////////////////////////////////
(0202) //   find index
(0203) // 检查当前文件尺寸，根据倒数第二个
(0204) //'\n'及其后面的index确定当前index值
(0205) //////////////////////////////////
(0206) unsigned int findIndex(char *filename,char *buf){
(0207)     unsigned int bw,tmp;
(0208) 	long index =0;
    0274D E080      LDI	R24,0
    0274E 838C      STD	Y+4,R24
    0274F 838D      STD	Y+5,R24
    02750 838E      STD	Y+6,R24
    02751 838F      STD	Y+7,R24
(0209) 	unsigned char is_first_end=0;
    02752 2400      CLR	R0
    02753 01DE      MOVW	R26,R28
    02754 5AA2      SUBI	R26,0xA2
    02755 4FBD      SBCI	R27,0xFD
    02756 920C      ST	X,R0
(0210) 	char *fnamep=filename;
    02757 0175      MOVW	R14,R10
(0211) 	FRESULT res;
(0212) 	FATFS fs;
(0213) 	FIL file;
(0214) 	long lenth=0;
    02758 E080      LDI	R24,0
    02759 8788      STD	Y+8,R24
    0275A 8789      STD	Y+9,R24
    0275B 878A      STD	Y+10,R24
    0275C 878B      STD	Y+11,R24
(0215) 	int readsize=0;
    0275D 24AA      CLR	R10
    0275E 24BB      CLR	R11
(0216) 	//PrintString_n(fnamep);
(0217) 	res = f_mount(0, &fs);
    0275F 019E      MOVW	R18,R28
    02760 5D20      SUBI	R18,0xD0
    02761 4F3F      SBCI	R19,0xFF
    02762 2700      CLR	R16
    02763 940E 16B2 CALL	_f_mount
(0218) 	res = f_open(&file,fnamep, FA_OPEN_ALWAYS | FA_READ );  //创建一个新的文件
    02765 E181      LDI	R24,0x11
    02766 8388      ST	Y,R24
    02767 0197      MOVW	R18,R14
    02768 018E      MOVW	R16,R28
    02769 5F04      SUBI	R16,0xF4
    0276A 4F1F      SBCI	R17,0xFF
    0276B 940E 16DD CALL	_f_open
    0276D 2EC0      MOV	R12,R16
(0219) 	if(res !=  FR_OK){ //openerror
    0276E 2300      TST	R16
    0276F F011      BEQ	0x2772
(0220) 	    return res;}
    02770 2711      CLR	R17
    02771 C11E      RJMP	0x2890
(0221) 	lenth=file.fsize;   //文件尾部为 file.size 
    02772 882E      LDD	R2,Y+22
    02773 883F      LDD	R3,Y+23
    02774 8C48      LDD	R4,Y+24
    02775 8C59      LDD	R5,Y+25
    02776 8628      STD	Y+8,R2
    02777 8639      STD	Y+9,R3
    02778 864A      STD	Y+10,R4
    02779 865B      STD	Y+11,R5
(0222) 	//debug("size=",0xff);
(0223) 	//PrintLong(lenth);
(0224) 	if(lenth > 512) {
    0277A E040      LDI	R20,0
    0277B E052      LDI	R21,2
    0277C E060      LDI	R22,0
    0277D E070      LDI	R23,0
    0277E 8428      LDD	R2,Y+8
    0277F 8439      LDD	R3,Y+9
    02780 844A      LDD	R4,Y+10
    02781 845B      LDD	R5,Y+11
    02782 1542      CP	R20,R2
    02783 0553      CPC	R21,R3
    02784 0564      CPC	R22,R4
    02785 0575      CPC	R23,R5
    02786 F464      BGE	0x2793
(0225) 	    readsize=512;
    02787 E080      LDI	R24,0
    02788 E092      LDI	R25,2
    02789 015C      MOVW	R10,R24
(0226) 		lenth=file.fsize;
    0278A 882E      LDD	R2,Y+22
    0278B 883F      LDD	R3,Y+23
    0278C 8C48      LDD	R4,Y+24
    0278D 8C59      LDD	R5,Y+25
    0278E 8628      STD	Y+8,R2
    0278F 8639      STD	Y+9,R3
    02790 864A      STD	Y+10,R4
    02791 865B      STD	Y+11,R5
(0227) 	}
    02792 C007      RJMP	0x279A
(0228) 	else {
(0229) 	    readsize =file.fsize;
    02793 88AE      LDD	R10,Y+22
    02794 88BF      LDD	R11,Y+23
(0230) 		lenth=0;
    02795 E080      LDI	R24,0
    02796 8788      STD	Y+8,R24
    02797 8789      STD	Y+9,R24
    02798 878A      STD	Y+10,R24
    02799 878B      STD	Y+11,R24
(0231) 	}
(0232) 	res = f_lseek (&file,file.fsize-readsize);
    0279A 0115      MOVW	R2,R10
    0279B 2444      CLR	R4
    0279C FC37      SBRC	R3,7
    0279D 9440      COM	R4
    0279E 2455      CLR	R5
    0279F FC47      SBRC	R4,7
    027A0 9450      COM	R5
    027A1 886E      LDD	R6,Y+22
    027A2 887F      LDD	R7,Y+23
    027A3 8C88      LDD	R8,Y+24
    027A4 8C99      LDD	R9,Y+25
    027A5 1862      SUB	R6,R2
    027A6 0873      SBC	R7,R3
    027A7 0884      SBC	R8,R4
    027A8 0895      SBC	R9,R5
    027A9 8288      ST	Y,R8
    027AA 8299      STD	Y+1,R9
    027AB 0193      MOVW	R18,R6
    027AC 018E      MOVW	R16,R28
    027AD 5F04      SUBI	R16,0xF4
    027AE 4F1F      SBCI	R17,0xFF
    027AF 940E 1EBE CALL	_f_lseek
(0233) 	//debug("readSIZE=",0x00);
(0234) 	//PrintLong((file.fsize-readsize));
(0235) 	res = f_read(&file,buf,readsize,&bw);
    027B1 01CE      MOVW	R24,R28
    027B2 968E      ADIW	R24,0x2E
    027B3 839B      STD	Y+3,R25
    027B4 838A      STD	Y+2,R24
    027B5 82B9      STD	Y+1,R11
    027B6 82A8      ST	Y,R10
    027B7 01FE      MOVW	R30,R28
    027B8 59E7      SUBI	R30,0x97
    027B9 4FFD      SBCI	R31,0xFD
    027BA 8120      LD	R18,Z
    027BB 8131      LDD	R19,Z+1
    027BC 018E      MOVW	R16,R28
    027BD 5F04      SUBI	R16,0xF4
    027BE 4F1F      SBCI	R17,0xFF
    027BF 940E 1879 CALL	_f_read
    027C1 2EE0      MOV	R14,R16
    027C2 2CCE      MOV	R12,R14
(0236) 	f_close(&file);
    027C3 018E      MOVW	R16,R28
    027C4 5F04      SUBI	R16,0xF4
    027C5 4F1F      SBCI	R17,0xFF
    027C6 940E 1EAE CALL	_f_close
(0237) 	//debug("readRES=",res);
(0238) 	//debug("readbw=",0X00);
(0239) 	//PrintLong(bw);
(0240) 	//PrintString_n(buf);
(0241) 	for(tmp=readsize;tmp>0;tmp--){
    027C8 C04E      RJMP	0x2817
(0242) 		//debug("buf index",buf[tmp]);
(0243) 		//PrintLong(tmp);
(0244) 		if(buf[tmp] == '\n') Usart_Transmit('@');						  
    027C9 01F5      MOVW	R30,R10
    027CA 01DE      MOVW	R26,R28
    027CB 59A7      SUBI	R26,0x97
    027CC 4FBD      SBCI	R27,0xFD
    027CD 900D      LD	R0,X+
    027CE 901C      LD	R1,X
    027CF 0DE0      ADD	R30,R0
    027D0 1DF1      ADC	R31,R1
    027D1 8180      LD	R24,Z
    027D2 308A      CPI	R24,0xA
    027D3 F419      BNE	0x27D7
    027D4 E400      LDI	R16,0x40
    027D5 940E 3904 CALL	_Usart_Transmit
(0245) 		if(buf[tmp] == '\n' && is_first_end== 0){
    027D7 01F5      MOVW	R30,R10
    027D8 01DE      MOVW	R26,R28
    027D9 59A7      SUBI	R26,0x97
    027DA 4FBD      SBCI	R27,0xFD
    027DB 900D      LD	R0,X+
    027DC 901C      LD	R1,X
    027DD 0DE0      ADD	R30,R0
    027DE 1DF1      ADC	R31,R1
    027DF 8180      LD	R24,Z
    027E0 308A      CPI	R24,0xA
    027E1 F469      BNE	0x27EF
    027E2 01FE      MOVW	R30,R28
    027E3 5AE2      SUBI	R30,0xA2
    027E4 4FFD      SBCI	R31,0xFD
    027E5 8000      LD	R0,Z
    027E6 2000      TST	R0
    027E7 F439      BNE	0x27EF
(0246) 		    is_first_end=1; 	
    027E8 2400      CLR	R0
    027E9 9403      INC	R0
    027EA 01FE      MOVW	R30,R28
    027EB 5AE2      SUBI	R30,0xA2
    027EC 4FFD      SBCI	R31,0xFD
    027ED 8200      ST	Z,R0
(0247) 			//debug("first=",0xf0);					      
(0248) 		}
    027EE C025      RJMP	0x2814
(0249) 		else if(buf[tmp] == '\n' && is_first_end== 1){
    027EF 01F5      MOVW	R30,R10
    027F0 01DE      MOVW	R26,R28
    027F1 59A7      SUBI	R26,0x97
    027F2 4FBD      SBCI	R27,0xFD
    027F3 900D      LD	R0,X+
    027F4 901C      LD	R1,X
    027F5 0DE0      ADD	R30,R0
    027F6 1DF1      ADC	R31,R1
    027F7 8180      LD	R24,Z
    027F8 308A      CPI	R24,0xA
    027F9 F4D1      BNE	0x2814
    027FA 01DE      MOVW	R26,R28
    027FB 5AA2      SUBI	R26,0xA2
    027FC 4FBD      SBCI	R27,0xFD
    027FD 918C      LD	R24,X
    027FE 3081      CPI	R24,1
    027FF F4A1      BNE	0x2814
(0250) 		    lenth -= (512-tmp);
    02800 E080      LDI	R24,0
    02801 E092      LDI	R25,2
    02802 011C      MOVW	R2,R24
    02803 182A      SUB	R2,R10
    02804 083B      SBC	R3,R11
    02805 2444      CLR	R4
    02806 2455      CLR	R5
    02807 8468      LDD	R6,Y+8
    02808 8479      LDD	R7,Y+9
    02809 848A      LDD	R8,Y+10
    0280A 849B      LDD	R9,Y+11
    0280B 1862      SUB	R6,R2
    0280C 0873      SBC	R7,R3
    0280D 0884      SBC	R8,R4
    0280E 0895      SBC	R9,R5
    0280F 8668      STD	Y+8,R6
    02810 8679      STD	Y+9,R7
    02811 868A      STD	Y+10,R8
    02812 869B      STD	Y+11,R9
(0251) 			break;
    02813 C009      RJMP	0x281D
    02814 01C5      MOVW	R24,R10
    02815 9701      SBIW	R24,1
    02816 015C      MOVW	R10,R24
    02817 20AA      TST	R10
    02818 F009      BEQ	0x281A
    02819 CFAF      RJMP	0x27C9
    0281A 20BB      TST	R11
    0281B F009      BEQ	0x281D
    0281C CFAC      RJMP	0x27C9
(0252) 		} 						
(0253) 	}
(0254) 	//debug("start=",0X00); PrintLong(lenth);
(0255) 	if(lenth < 118 ){ 
    0281D E746      LDI	R20,0x76
    0281E E050      LDI	R21,0
    0281F E060      LDI	R22,0
    02820 E070      LDI	R23,0
    02821 8428      LDD	R2,Y+8
    02822 8439      LDD	R3,Y+9
    02823 844A      LDD	R4,Y+10
    02824 845B      LDD	R5,Y+11
    02825 1624      CP	R2,R20
    02826 0635      CPC	R3,R21
    02827 0646      CPC	R4,R22
    02828 0657      CPC	R5,R23
    02829 F434      BGE	0x2830
(0256)  		return 1;
    0282A E001      LDI	R16,1
    0282B E010      LDI	R17,0
    0282C C063      RJMP	0x2890
(0257) 	}
(0258) 	else {
(0259) 		 //debug(">128 ",0X00);
(0260) 		 while(buf[tmp] <= '0' || buf[tmp] >= '9') tmp++;
    0282D 01C5      MOVW	R24,R10
    0282E 9601      ADIW	R24,1
    0282F 015C      MOVW	R10,R24
    02830 01F5      MOVW	R30,R10
    02831 01DE      MOVW	R26,R28
    02832 59A7      SUBI	R26,0x97
    02833 4FBD      SBCI	R27,0xFD
    02834 900D      LD	R0,X+
    02835 901C      LD	R1,X
    02836 0DE0      ADD	R30,R0
    02837 1DF1      ADC	R31,R1
    02838 80E0      LD	R14,Z
    02839 24FF      CLR	R15
    0283A E380      LDI	R24,0x30
    0283B 158E      CP	R24,R14
    0283C F780      BCC	0x282D
    0283D 2D8E      MOV	R24,R14
    0283E 3389      CPI	R24,0x39
    0283F F768      BCC	0x282D
    02840 C02F      RJMP	0x2870
(0261) 		 //debug("nozero ",bw); PrintLong(tmp);
(0262) 		 while(buf[tmp] != 't' && buf[tmp] >= '0' && buf[tmp] <= '9'){
(0263) 		     index=index*10+(buf[tmp]-'0');
    02841 01F5      MOVW	R30,R10
    02842 01DE      MOVW	R26,R28
    02843 59A7      SUBI	R26,0x97
    02844 4FBD      SBCI	R27,0xFD
    02845 900D      LD	R0,X+
    02846 901C      LD	R1,X
    02847 0DE0      ADD	R30,R0
    02848 1DF1      ADC	R31,R1
    02849 8180      LD	R24,Z
    0284A 2799      CLR	R25
    0284B 97C0      SBIW	R24,0x30
    0284C 011C      MOVW	R2,R24
    0284D 2444      CLR	R4
    0284E FC37      SBRC	R3,7
    0284F 9440      COM	R4
    02850 2455      CLR	R5
    02851 FC47      SBRC	R4,7
    02852 9450      COM	R5
    02853 806C      LDD	R6,Y+4
    02854 807D      LDD	R7,Y+5
    02855 808E      LDD	R8,Y+6
    02856 809F      LDD	R9,Y+7
    02857 E04A      LDI	R20,0xA
    02858 E050      LDI	R21,0
    02859 E060      LDI	R22,0
    0285A E070      LDI	R23,0
    0285B 929A      ST	-Y,R9
    0285C 928A      ST	-Y,R8
    0285D 927A      ST	-Y,R7
    0285E 926A      ST	-Y,R6
    0285F 018A      MOVW	R16,R20
    02860 019B      MOVW	R18,R22
    02861 940E 4250 CALL	empy32u|empy32s
    02863 0138      MOVW	R6,R16
    02864 0149      MOVW	R8,R18
    02865 0C62      ADD	R6,R2
    02866 1C73      ADC	R7,R3
    02867 1C84      ADC	R8,R4
    02868 1C95      ADC	R9,R5
    02869 826C      STD	Y+4,R6
    0286A 827D      STD	Y+5,R7
    0286B 828E      STD	Y+6,R8
    0286C 829F      STD	Y+7,R9
(0264) 		 	 //Usart_Transmit(buf[tmp]);	
(0265) 		 	 tmp++;
    0286D 01C5      MOVW	R24,R10
    0286E 9601      ADIW	R24,1
    0286F 015C      MOVW	R10,R24
    02870 01F5      MOVW	R30,R10
    02871 01DE      MOVW	R26,R28
    02872 59A7      SUBI	R26,0x97
    02873 4FBD      SBCI	R27,0xFD
    02874 900D      LD	R0,X+
    02875 901C      LD	R1,X
    02876 0DE0      ADD	R30,R0
    02877 1DF1      ADC	R31,R1
    02878 80E0      LD	R14,Z
    02879 24FF      CLR	R15
    0287A 2D8E      MOV	R24,R14
    0287B 3784      CPI	R24,0x74
    0287C F031      BEQ	0x2883
    0287D 3380      CPI	R24,0x30
    0287E F020      BCS	0x2883
    0287F E389      LDI	R24,0x39
    02880 158E      CP	R24,R14
    02881 F008      BCS	0x2883
    02882 CFBE      RJMP	0x2841
(0266) 		 }
(0267) 	}
(0268) 	//debug("index=",0X00);
(0269) 	//PrintLong(index+1);
(0270) 	return index+1;
    02883 E041      LDI	R20,1
    02884 E050      LDI	R21,0
    02885 E060      LDI	R22,0
    02886 E070      LDI	R23,0
    02887 802C      LDD	R2,Y+4
    02888 803D      LDD	R3,Y+5
    02889 804E      LDD	R4,Y+6
    0288A 805F      LDD	R5,Y+7
    0288B 0E24      ADD	R2,R20
    0288C 1E35      ADC	R3,R21
    0288D 1E46      ADC	R4,R22
    0288E 1E57      ADC	R5,R23
    0288F 0181      MOVW	R16,R2
    02890 96EF      ADIW	R28,0x3F
    02891 96EF      ADIW	R28,0x3F
    02892 96EF      ADIW	R28,0x3F
    02893 96EF      ADIW	R28,0x3F
    02894 96EF      ADIW	R28,0x3F
    02895 96EF      ADIW	R28,0x3F
    02896 96EF      ADIW	R28,0x3F
    02897 96EF      ADIW	R28,0x3F
    02898 96EF      ADIW	R28,0x3F
    02899 96A8      ADIW	R28,0x28
    0289A 940E 4299 CALL	pop_xgsetF0FC
    0289C 9622      ADIW	R28,2
    0289D 9508      RET
_scan_files:
  i                    --> R14
  dir                  --> Y,+22
  fn                   --> R14
  res                  --> R10
  fno                  --> Y,+0
  path                 --> R12
    0289E 940E 42A8 CALL	push_xgset00FC
    028A0 0168      MOVW	R12,R16
    028A1 97AC      SBIW	R28,0x2C
(0271) }
(0272) ////////////////////////////////////////////////
(0273) //			文件查找函数
(0274) //
(0275) ////////////////////////////////////////////////
(0276) char scan_files (char* path)
(0277) {
(0278)     FRESULT res;
(0279)     FILINFO fno;
(0280)     DIR dir;
(0281)     int i;
(0282)     char *fn;
(0283) #if _USE_LFN   //长文件名支持
(0284)     static char lfn[_MAX_LFN * (_DF1S ? 2 : 1) + 1];
(0285)     fno.lfname = lfn;
(0286)     fno.lfsize = sizeof(lfn);
(0287) #endif
(0288)     res = f_opendir(&dir, path); //打开文件夹
    028A2 0196      MOVW	R18,R12
    028A3 018E      MOVW	R16,R28
    028A4 5E0A      SUBI	R16,0xEA
    028A5 4F1F      SBCI	R17,0xFF
    028A6 940E 237B CALL	_f_opendir
    028A8 2EA0      MOV	R10,R16
(0289)     if (res == FR_OK) {PrintString_n("opendir ok");
    028A9 2300      TST	R16
    028AA F009      BEQ	0x28AC
    028AB C035      RJMP	0x28E1
    028AC EF02      LDI	R16,0xF2
    028AD E011      LDI	R17,1
    028AE 940E 3945 CALL	_PrintString_n
(0290)         i = strlen(path);
    028B0 0186      MOVW	R16,R12
    028B1 940E 4153 CALL	_strlen
(0291)         for (;;) {
(0292)             res = f_readdir(&dir, &fno);
    028B3 019E      MOVW	R18,R28
    028B4 018E      MOVW	R16,R28
    028B5 5E0A      SUBI	R16,0xEA
    028B6 4F1F      SBCI	R17,0xFF
    028B7 940E 23EF CALL	_f_readdir
    028B9 2EE0      MOV	R14,R16
    028BA 2CAE      MOV	R10,R14
(0293) 			debug("read addr",res);debug(fno.fname,255);
    028BB 2D2A      MOV	R18,R10
    028BC EE08      LDI	R16,0xE8
    028BD E011      LDI	R17,1
    028BE D339      RCALL	_debug
    028BF EF2F      LDI	R18,0xFF
    028C0 018E      MOVW	R16,R28
    028C1 5F07      SUBI	R16,0xF7
    028C2 4F1F      SBCI	R17,0xFF
    028C3 D334      RCALL	_debug
(0294)             if (res != FR_OK || fno.fname[0] == 0){ debug("break",255);break; }
    028C4 20EE      TST	R14
    028C5 F419      BNE	0x28C9
    028C6 8429      LDD	R2,Y+9
    028C7 2022      TST	R2
    028C8 F429      BNE	0x28CE
    028C9 EF2F      LDI	R18,0xFF
    028CA EE02      LDI	R16,0xE2
    028CB E011      LDI	R17,1
    028CC D32B      RCALL	_debug
    028CD C013      RJMP	0x28E1
(0295) #if _USE_LFN
(0296)             fn = *fno.lfname ? fno.lfname : fno.fname;
(0297) #else
(0298)             fn = fno.fname;
    028CE 01CE      MOVW	R24,R28
    028CF 9609      ADIW	R24,0x9
    028D0 017C      MOVW	R14,R24
(0299) #endif
(0300) 	  		PrintString_n("aaa");
    028D1 ED0E      LDI	R16,0xDE
    028D2 E011      LDI	R17,1
    028D3 940E 3945 CALL	_PrintString_n
(0301)             if (*fn == '.') continue;
    028D5 01F7      MOVW	R30,R14
    028D6 8180      LD	R24,Z
    028D7 328E      CPI	R24,0x2E
    028D8 F409      BNE	0x28DA
    028D9 CFD9      RJMP	0x28B3
(0302)            /* if (fno.fattrib & AM_DIR) {
(0303)                 sprintf(&path[i], "/%s", fn);PrintString_n(fn);
(0304)                 res = scan_files(path);
(0305)                 if (res != FR_OK) break;
(0306)                 path[i] = 0;
(0307)             } else {
(0308)                 PrintString_n(path);
(0309) 				PrintString_n(fn);
(0310)             }
(0311) 			*/
(0312) 			PrintString_n(path);
    028DA 0186      MOVW	R16,R12
    028DB 940E 3945 CALL	_PrintString_n
(0313) 			PrintString_n(fn);
    028DD 0187      MOVW	R16,R14
    028DE 940E 3945 CALL	_PrintString_n
    028E0 CFD2      RJMP	0x28B3
(0314)         }
(0315)     }
(0316) 
(0317)     return res;
    028E1 2D0A      MOV	R16,R10
    028E2 96AC      ADIW	R28,0x2C
    028E3 940C 4289 JMP	pop_xgset00FC
_check:
  WScounter            --> R10
  tmp                  --> R12
    028E5 940E 42AA CALL	push_xgset003C
    028E7 9722      SBIW	R28,2
(0318) }
(0319) void check( void )
(0320) {
(0321)  unsigned char tmp;
(0322)  unsigned int WScounter;
(0323)  //检测风速
(0324)  //读计数器1 此步需严格按手册进行。
(0325)  tmp=SREG;
    028E8 B6CF      IN	R12,0x3F
(0326)  CLI();
    028E9 94F8      BCLR	7
(0327)  WScounter=TCNT1H*256+TCNT1L;
    028EA B52D      IN	R18,0x2D
    028EB 2733      CLR	R19
    028EC E000      LDI	R16,0
    028ED E011      LDI	R17,1
    028EE 940E 4240 CALL	empy16s
    028F0 0158      MOVW	R10,R16
    028F1 B42C      IN	R2,0x2C
    028F2 2433      CLR	R3
    028F3 0CA2      ADD	R10,R2
    028F4 1CB3      ADC	R11,R3
(0328)  SREG=tmp;
    028F5 BECF      OUT	0x3F,R12
(0329)  SEI();
    028F6 9478      BSET	7
(0330)  //计算风速
(0331)  Result.WindSpeed=WScounter/N_per_Second;
    028F7 0185      MOVW	R16,R10
    028F8 940E 43FE CALL	uint2fp
    028FA 0118      MOVW	R2,R16
    028FB 0129      MOVW	R4,R18
    028FC EB00      LDI	R16,0xB0
    028FD E010      LDI	R17,0
    028FE 940E 422C CALL	elpm32
    02900 933A      ST	-Y,R19
    02901 932A      ST	-Y,R18
    02902 931A      ST	-Y,R17
    02903 930A      ST	-Y,R16
    02904 0181      MOVW	R16,R2
    02905 0192      MOVW	R18,R4
    02906 940E 442B CALL	fpdiv2
    02908 9310 05FF STS	Result+52,R17
    0290A 9300 05FE STS	Result+51,R16
    0290C 9330 0601 STS	Result+54,R19
    0290E 9320 0600 STS	Result+53,R18
(0332)  //温度
(0333)  Result.Temperature=read_T_NUM(1); //读两次 避免出错
    02910 E001      LDI	R16,1
    02911 940E 403B CALL	_read_T_NUM
    02913 9310 05F5 STS	Result+42,R17
    02915 9300 05F4 STS	Result+41,R16
    02917 9330 05F7 STS	Result+44,R19
    02919 9320 05F6 STS	Result+43,R18
(0334)  Result.Temperature=read_T_NUM(1);
    0291B E001      LDI	R16,1
    0291C 940E 403B CALL	_read_T_NUM
    0291E 9310 05F5 STS	Result+42,R17
    02920 9300 05F4 STS	Result+41,R16
    02922 9330 05F7 STS	Result+44,R19
    02924 9320 05F6 STS	Result+43,R18
(0335)  //WCI风冷指数
(0336)   Result.WCI = 4.18 *(10*SquareRootFloat(Result.WindSpeed) + 10.45 -  Result.WindSpeed  ) *( 33 - Result.Temperature );
    02926 9120 0600 LDS	R18,Result+53
    02928 9130 0601 LDS	R19,Result+54
    0292A 9100 05FE LDS	R16,Result+51
    0292C 9110 05FF LDS	R17,Result+52
    0292E D22D      RCALL	_SquareRootFloat
    0292F 0118      MOVW	R2,R16
    02930 0129      MOVW	R4,R18
    02931 EA0C      LDI	R16,0xAC
    02932 E010      LDI	R17,0
    02933 940E 422C CALL	elpm32
    02935 0138      MOVW	R6,R16
    02936 0149      MOVW	R8,R18
    02937 EA08      LDI	R16,0xA8
    02938 E010      LDI	R17,0
    02939 940E 422C CALL	elpm32
    0293B 925A      ST	-Y,R5
    0293C 924A      ST	-Y,R4
    0293D 923A      ST	-Y,R3
    0293E 922A      ST	-Y,R2
    0293F 940E 45A5 CALL	fpmule2
    02941 0118      MOVW	R2,R16
    02942 0129      MOVW	R4,R18
    02943 EA04      LDI	R16,0xA4
    02944 E010      LDI	R17,0
    02945 940E 422C CALL	elpm32
    02947 933A      ST	-Y,R19
    02948 932A      ST	-Y,R18
    02949 931A      ST	-Y,R17
    0294A 930A      ST	-Y,R16
    0294B 0181      MOVW	R16,R2
    0294C 0192      MOVW	R18,R4
    0294D 940E 43CD CALL	fpadd2
    0294F EF8E      LDI	R24,0xFE
    02950 E095      LDI	R25,5
    02951 939A      ST	-Y,R25
    02952 938A      ST	-Y,R24
    02953 940E 43E3 CALL	fpsub1x
    02955 0183      MOVW	R16,R6
    02956 0194      MOVW	R18,R8
    02957 940E 45A5 CALL	fpmule2
    02959 0118      MOVW	R2,R16
    0295A 0129      MOVW	R4,R18
    0295B EA00      LDI	R16,0xA0
    0295C E010      LDI	R17,0
    0295D 940E 422C CALL	elpm32
    0295F EF84      LDI	R24,0xF4
    02960 E095      LDI	R25,5
    02961 939A      ST	-Y,R25
    02962 938A      ST	-Y,R24
    02963 940E 43E3 CALL	fpsub1x
    02965 0181      MOVW	R16,R2
    02966 0192      MOVW	R18,R4
    02967 940E 45A5 CALL	fpmule2
    02969 9310 0608 STS	Result+61,R17
    0296B 9300 0607 STS	Result+60,R16
    0296D 9330 060A STS	Result+63,R19
    0296F 9320 0609 STS	Result+62,R18
(0337)  //ECT等价制冷温度
(0338)  Result.ECT = 33 - 0.01085 * Result.WCI;
    02971 E90C      LDI	R16,0x9C
    02972 E010      LDI	R17,0
    02973 940E 422C CALL	elpm32
    02975 0118      MOVW	R2,R16
    02976 0129      MOVW	R4,R18
    02977 E908      LDI	R16,0x98
    02978 E010      LDI	R17,0
    02979 940E 422C CALL	elpm32
    0297B E087      LDI	R24,7
    0297C E096      LDI	R25,6
    0297D 939A      ST	-Y,R25
    0297E 938A      ST	-Y,R24
    0297F 940E 45B0 CALL	fpmule1x
    02981 0181      MOVW	R16,R2
    02982 0192      MOVW	R18,R4
    02983 940E 43D8 CALL	fpsub2
    02985 9310 0612 STS	Result+71,R17
    02987 9300 0611 STS	Result+70,R16
    02989 9330 0614 STS	Result+73,R19
    0298B 9320 0613 STS	Result+72,R18
(0339)  //TEQ 相当温度
(0340)  Result.Teq = Result.Temperature +( (Result.Temperature -36)/10 ) * Result.WindSpeed ;
    0298D 9040 05F6 LDS	R4,Result+43
    0298F 9050 05F7 LDS	R5,Result+44
    02991 9020 05F4 LDS	R2,Result+41
    02993 9030 05F5 LDS	R3,Result+42
    02995 0131      MOVW	R6,R2
    02996 0142      MOVW	R8,R4
    02997 E904      LDI	R16,0x94
    02998 E010      LDI	R17,0
    02999 940E 422C CALL	elpm32
    0299B 933A      ST	-Y,R19
    0299C 932A      ST	-Y,R18
    0299D 931A      ST	-Y,R17
    0299E 930A      ST	-Y,R16
    0299F 0183      MOVW	R16,R6
    029A0 0194      MOVW	R18,R8
    029A1 940E 43D8 CALL	fpsub2
    029A3 0138      MOVW	R6,R16
    029A4 0149      MOVW	R8,R18
    029A5 EA08      LDI	R16,0xA8
    029A6 E010      LDI	R17,0
    029A7 940E 422C CALL	elpm32
    029A9 933A      ST	-Y,R19
    029AA 932A      ST	-Y,R18
    029AB 931A      ST	-Y,R17
    029AC 930A      ST	-Y,R16
    029AD 0183      MOVW	R16,R6
    029AE 0194      MOVW	R18,R8
    029AF 940E 442B CALL	fpdiv2
    029B1 EF8E      LDI	R24,0xFE
    029B2 E095      LDI	R25,5
    029B3 939A      ST	-Y,R25
    029B4 938A      ST	-Y,R24
    029B5 940E 45B0 CALL	fpmule1x
    029B7 0181      MOVW	R16,R2
    029B8 0192      MOVW	R18,R4
    029B9 940E 43CD CALL	fpadd2
    029BB 9310 061C STS	Result+81,R17
    029BD 9300 061B STS	Result+80,R16
    029BF 9330 061E STS	Result+83,R19
    029C1 9320 061D STS	Result+82,R18
(0341) //将数据转换成字符串
(0342)  
(0343) ftochr(Result.WindSpeed,Result.WSChar);
    029C3 E082      LDI	R24,2
    029C4 E096      LDI	R25,6
    029C5 8399      STD	Y+1,R25
    029C6 8388      ST	Y,R24
    029C7 9120 0600 LDS	R18,Result+53
    029C9 9130 0601 LDS	R19,Result+54
    029CB 9100 05FE LDS	R16,Result+51
    029CD 9110 05FF LDS	R17,Result+52
    029CF D04E      RCALL	_ftochr
(0344) ftochr(Result.Temperature,Result.TempChar);//PrintString_n(Result.TempChar);
    029D0 EF88      LDI	R24,0xF8
    029D1 E095      LDI	R25,5
    029D2 8399      STD	Y+1,R25
    029D3 8388      ST	Y,R24
    029D4 9120 05F6 LDS	R18,Result+43
    029D6 9130 05F7 LDS	R19,Result+44
    029D8 9100 05F4 LDS	R16,Result+41
    029DA 9110 05F5 LDS	R17,Result+42
    029DC D041      RCALL	_ftochr
(0345) ftochr(Result.WCI,Result.WCIChar);
    029DD E08B      LDI	R24,0xB
    029DE E096      LDI	R25,6
    029DF 8399      STD	Y+1,R25
    029E0 8388      ST	Y,R24
    029E1 9120 0609 LDS	R18,Result+62
    029E3 9130 060A LDS	R19,Result+63
    029E5 9100 0607 LDS	R16,Result+60
    029E7 9110 0608 LDS	R17,Result+61
    029E9 D034      RCALL	_ftochr
(0346) ftochr(Result.ECT,Result.ECTChar);
    029EA E185      LDI	R24,0x15
    029EB E096      LDI	R25,6
    029EC 8399      STD	Y+1,R25
    029ED 8388      ST	Y,R24
    029EE 9120 0613 LDS	R18,Result+72
    029F0 9130 0614 LDS	R19,Result+73
    029F2 9100 0611 LDS	R16,Result+70
    029F4 9110 0612 LDS	R17,Result+71
    029F6 D027      RCALL	_ftochr
(0347) ftochr(Result.Teq,Result.TeqChar);
    029F7 E18F      LDI	R24,0x1F
    029F8 E096      LDI	R25,6
    029F9 8399      STD	Y+1,R25
    029FA 8388      ST	Y,R24
    029FB 9120 061D LDS	R18,Result+82
    029FD 9130 061E LDS	R19,Result+83
    029FF 9100 061B LDS	R16,Result+80
    02A01 9110 061C LDS	R17,Result+81
    02A03 D01A      RCALL	_ftochr
(0348) itoa(Result.IndexChar,Result.Index,10);
    02A04 E08A      LDI	R24,0xA
    02A05 E090      LDI	R25,0
    02A06 8399      STD	Y+1,R25
    02A07 8388      ST	Y,R24
    02A08 9120 05D5 LDS	R18,Result+10
    02A0A 9130 05D6 LDS	R19,Result+11
    02A0C ED09      LDI	R16,0xD9
    02A0D E015      LDI	R17,5
    02A0E 940E 45D6 CALL	_itoa
(0349) Result.TempChar[6]='\0';
    02A10 2422      CLR	R2
    02A11 9220 05FE STS	Result+51,R2
(0350) Result.WSChar[5]='\0';
    02A13 9220 0607 STS	Result+60,R2
(0351) Result.WCIChar[6]='\0';
    02A15 9220 0611 STS	Result+70,R2
(0352) Result.ECTChar[6]='\0';
    02A17 9220 061B STS	Result+80,R2
(0353) Result.TeqChar[6]='\0';
    02A19 9220 0625 STS	Result+90,R2
(0354)  return ;
    02A1B 9622      ADIW	R28,2
    02A1C 940C 4284 JMP	pop_xgset003C
_ftochr:
  status               --> Y,+2
  j                    --> R12
  lenth                --> R20
  res                  --> R12
  i                    --> R10
  dest                 --> R14
  a                    --> Y,+12
    02A1E 940E 415F CALL	push_arg4
    02A20 940E 42A6 CALL	push_xgset30FC
    02A22 9724      SBIW	R28,4
    02A23 88E8      LDD	R14,Y+16
    02A24 88F9      LDD	R15,Y+17
(0355) }
(0356) ////////////////////////////////////////////
(0357) //				字符串转换函数
(0358) //   浮点 到  字符串
(0359) ////////////////////////////////////////////
(0360) void ftochr(float a,char * dest){//float
(0361) char i=0,j=0,lenth;
(0362) int status;
(0363) char *res;
(0364)  res=ftoa(a,&status);  //float to ascii
    02A25 01CE      MOVW	R24,R28
    02A26 9602      ADIW	R24,2
    02A27 8399      STD	Y+1,R25
    02A28 8388      ST	Y,R24
    02A29 850C      LDD	R16,Y+12
    02A2A 851D      LDD	R17,Y+13
    02A2B 852E      LDD	R18,Y+14
    02A2C 853F      LDD	R19,Y+15
    02A2D 940E 46F9 CALL	_ftoa
    02A2F 0168      MOVW	R12,R16
(0365) lenth=strlen(res);
    02A30 940E 4153 CALL	_strlen
    02A32 2F40      MOV	R20,R16
(0366) 
(0367) for(i=0;i <lenth;i++) 
    02A33 24AA      CLR	R10
    02A34 C023      RJMP	0x2A58
(0368)        {
(0369) 	   	dest[i]=res[i];
    02A35 2DEA      MOV	R30,R10
    02A36 27FF      CLR	R31
    02A37 0DEC      ADD	R30,R12
    02A38 1DFD      ADC	R31,R13
    02A39 8020      LD	R2,Z
    02A3A 2DEA      MOV	R30,R10
    02A3B 27FF      CLR	R31
    02A3C 0DEE      ADD	R30,R14
    02A3D 1DFF      ADC	R31,R15
    02A3E 8220      ST	Z,R2
(0370) 
(0371) 		if( res[i]=='.'  ) 
    02A3F 2DEA      MOV	R30,R10
    02A40 27FF      CLR	R31
    02A41 0DEC      ADD	R30,R12
    02A42 1DFD      ADC	R31,R13
    02A43 8180      LD	R24,Z
    02A44 328E      CPI	R24,0x2E
    02A45 F489      BNE	0x2A57
(0372) 			{
(0373) 				dest[i+1]=res[i+1];
    02A46 2DEA      MOV	R30,R10
    02A47 27FF      CLR	R31
    02A48 0DEC      ADD	R30,R12
    02A49 1DFD      ADC	R31,R13
    02A4A 8021      LDD	R2,Z+1
    02A4B 2DEA      MOV	R30,R10
    02A4C 27FF      CLR	R31
    02A4D 0DEE      ADD	R30,R14
    02A4E 1DFF      ADC	R31,R15
    02A4F 8221      STD	Z+1,R2
(0374) 					dest[i+2]='\0';
    02A50 2DEA      MOV	R30,R10
    02A51 27FF      CLR	R31
    02A52 0DEE      ADD	R30,R14
    02A53 1DFF      ADC	R31,R15
    02A54 2422      CLR	R2
    02A55 8222      STD	Z+2,R2
(0375) 						return ;    
    02A56 C003      RJMP	0x2A5A
    02A57 94A3      INC	R10
    02A58 16A4      CP	R10,R20
    02A59 F2D8      BCS	0x2A35
    02A5A 9624      ADIW	R28,4
    02A5B 940E 4290 CALL	pop_xgset30FC
    02A5D 9624      ADIW	R28,4
    02A5E 9508      RET
_itochr:
  dest                 --> R10
  a                    --> R12
    02A5F 940E 42AA CALL	push_xgset003C
    02A61 0159      MOVW	R10,R18
    02A62 0168      MOVW	R12,R16
    02A63 9722      SBIW	R28,2
(0376) 		    }
(0377)  
(0378)  		}
(0379) }
(0380) //////////////////////////////////////////////////////
(0381) //              整型数据变字符串
(0382) //    a  到  dest
(0383) ///////////////////////////////////////////////////////
(0384) void itochr(int a,char * dest){ //int to ascii
(0385) 	 itoa(dest,a,10); 
    02A64 E08A      LDI	R24,0xA
    02A65 E090      LDI	R25,0
    02A66 8399      STD	Y+1,R25
    02A67 8388      ST	Y,R24
    02A68 0196      MOVW	R18,R12
    02A69 0185      MOVW	R16,R10
    02A6A 940E 45D6 CALL	_itoa
    02A6C 9622      ADIW	R28,2
    02A6D 940C 4284 JMP	pop_xgset003C
_StructToChar:
  otherbyte            --> Y,+16
  ary                  --> Y,+0
  i                    --> R10
    02A6F 92AA      ST	-Y,R10
    02A70 9768      SBIW	R28,0x18
(0386) }
(0387) //////////////////////////////////////////////////////
(0388) //                  结构体 变字符串
(0389) // 将目前存于结构体的数据转换到Temp_Char中。
(0390) ///////////////////////////////////////////////////////
(0391) void  StructToChar(void)
(0392) { 
(0393)   unsigned char i;
(0394)   char otherbyte[]="0\t0\t0\t0";
    02A71 EB80      LDI	R24,0xB0
    02A72 E091      LDI	R25,1
    02A73 01FE      MOVW	R30,R28
    02A74 9670      ADIW	R30,0x10
    02A75 E008      LDI	R16,0x8
    02A76 E010      LDI	R17,0
    02A77 93FA      ST	-Y,R31
    02A78 93EA      ST	-Y,R30
    02A79 939A      ST	-Y,R25
    02A7A 938A      ST	-Y,R24
    02A7B 940E 434B CALL	asgnblk
(0395)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    02A7D EB88      LDI	R24,0xB8
    02A7E E091      LDI	R25,1
    02A7F 01FE      MOVW	R30,R28
    02A80 E100      LDI	R16,0x10
    02A81 E010      LDI	R17,0
    02A82 93FA      ST	-Y,R31
    02A83 93EA      ST	-Y,R30
    02A84 939A      ST	-Y,R25
    02A85 938A      ST	-Y,R24
    02A86 940E 434B CALL	asgnblk
(0396)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0397) 				Result.TeqChar
(0398) 			   };  //指向数组首地址的指针
(0399)   //strcat(Temp_Char,Result.Name);
(0400)   for(i=0;i<=80;i++) TempChar[i]='\0';  //清空数组
    02A88 24AA      CLR	R10
    02A89 C009      RJMP	0x2A93
    02A8A E78B      LDI	R24,0x7B
    02A8B E095      LDI	R25,5
    02A8C 2DEA      MOV	R30,R10
    02A8D 27FF      CLR	R31
    02A8E 0FE8      ADD	R30,R24
    02A8F 1FF9      ADC	R31,R25
    02A90 2422      CLR	R2
    02A91 8220      ST	Z,R2
    02A92 94A3      INC	R10
    02A93 E580      LDI	R24,0x50
    02A94 158A      CP	R24,R10
    02A95 F7A0      BCC	0x2A8A
(0401)     for(i=0;i<=7;i++){
    02A96 24AA      CLR	R10
    02A97 C014      RJMP	0x2AAC
(0402) 		strcat(TempChar,ary[i]);  // 按顺序复制字符串
    02A98 01CE      MOVW	R24,R28
    02A99 2DEA      MOV	R30,R10
    02A9A 27FF      CLR	R31
    02A9B 0FEE      LSL	R30
    02A9C 1FFF      ROL	R31
    02A9D 0FE8      ADD	R30,R24
    02A9E 1FF9      ADC	R31,R25
    02A9F 8120      LD	R18,Z
    02AA0 8131      LDD	R19,Z+1
    02AA1 E70B      LDI	R16,0x7B
    02AA2 E015      LDI	R17,5
    02AA3 940E 4146 CALL	_strcat
(0403) 		strcat(TempChar,tab);     // 字串结尾加上制表符
    02AA5 E02F      LDI	R18,0xF
    02AA6 E031      LDI	R19,1
    02AA7 E70B      LDI	R16,0x7B
    02AA8 E015      LDI	R17,5
    02AA9 940E 4146 CALL	_strcat
    02AAB 94A3      INC	R10
    02AAC E087      LDI	R24,7
    02AAD 158A      CP	R24,R10
    02AAE F748      BCC	0x2A98
(0404)     }
(0405) 				 
(0406) 				 otherbyte[0]=otherbyte[0]+Result.WeiHai;
    02AAF 9020 0625 LDS	R2,Result+90
    02AB1 8838      LDD	R3,Y+16
    02AB2 0C32      ADD	R3,R2
    02AB3 8A38      STD	Y+16,R3
(0407) 				 otherbyte[2]=otherbyte[0]+Result.LowLabor;
    02AB4 9020 0626 LDS	R2,Result+91
    02AB6 0C32      ADD	R3,R2
    02AB7 8A3A      STD	Y+18,R3
(0408) 				 otherbyte[4]=otherbyte[0]+Result.MidLabor;
    02AB8 9020 0627 LDS	R2,Result+92
    02ABA 8838      LDD	R3,Y+16
    02ABB 0C32      ADD	R3,R2
    02ABC 8A3C      STD	Y+20,R3
(0409) 				 otherbyte[6]=otherbyte[0]+Result.HighLabor;
    02ABD 9020 0628 LDS	R2,Result+93
    02ABF 8838      LDD	R3,Y+16
    02AC0 0C32      ADD	R3,R2
    02AC1 8A3E      STD	Y+22,R3
(0410)  
(0411)   strcat(TempChar,otherbyte);  
    02AC2 019E      MOVW	R18,R28
    02AC3 5F20      SUBI	R18,0xF0
    02AC4 4F3F      SBCI	R19,0xFF
    02AC5 E70B      LDI	R16,0x7B
    02AC6 E015      LDI	R17,5
    02AC7 940E 4146 CALL	_strcat
(0412)   strcat(TempChar,enter);  
    02AC9 E122      LDI	R18,0x12
    02ACA E031      LDI	R19,1
    02ACB E70B      LDI	R16,0x7B
    02ACC E015      LDI	R17,5
    02ACD 940E 4146 CALL	_strcat
(0413)   strcat(TempChar,"\0");
    02ACF ED2C      LDI	R18,0xDC
    02AD0 E031      LDI	R19,1
    02AD1 E70B      LDI	R16,0x7B
    02AD2 E015      LDI	R17,5
    02AD3 940E 4146 CALL	_strcat
    02AD5 9668      ADIW	R28,0x18
    02AD6 90A9      LD	R10,Y+
    02AD7 9508      RET
_CharToStruct:
  ary                  --> Y,+0
  j                    --> R12
  p                    --> R10
  q                    --> R20
  buf                  --> R14
    02AD8 940E 42A6 CALL	push_xgset30FC
    02ADA 0178      MOVW	R14,R16
    02ADB 9760      SBIW	R28,0x10
(0414) }
(0415) 
(0416) //////////////////////////////////////////////////////
(0417) //               字符串  变  结构体
(0418) // 
(0419) ///////////////////////////////////////////////////////
(0420) void CharToStruct(char *buf)
(0421) {
(0422)   unsigned char j=0;
    02ADC 24CC      CLR	R12
(0423)   unsigned char *p,*q;
(0424)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    02ADD EC88      LDI	R24,0xC8
    02ADE E091      LDI	R25,1
    02ADF 01FE      MOVW	R30,R28
    02AE0 E100      LDI	R16,0x10
    02AE1 E010      LDI	R17,0
    02AE2 93FA      ST	-Y,R31
    02AE3 93EA      ST	-Y,R30
    02AE4 939A      ST	-Y,R25
    02AE5 938A      ST	-Y,R24
    02AE6 940E 434B CALL	asgnblk
(0425)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0426) 				Result.TeqChar
(0427) 			   };  //指向数组首地址的指针
(0428)     p=ary[j];
    02AE8 01CE      MOVW	R24,R28
    02AE9 2DEC      MOV	R30,R12
    02AEA 27FF      CLR	R31
    02AEB 0FEE      LSL	R30
    02AEC 1FFF      ROL	R31
    02AED 0FE8      ADD	R30,R24
    02AEE 1FF9      ADC	R31,R25
    02AEF 80A0      LD	R10,Z
    02AF0 80B1      LDD	R11,Z+1
(0429) 	q=buf;
    02AF1 01A7      MOVW	R20,R14
    02AF2 C026      RJMP	0x2B19
(0430) 	
(0431) 	while(1){
(0432)     if(*q =='\n') {*p='\0'; return;} ;
    02AF3 01FA      MOVW	R30,R20
    02AF4 8180      LD	R24,Z
    02AF5 308A      CPI	R24,0xA
    02AF6 F421      BNE	0x2AFB
    02AF7 2422      CLR	R2
    02AF8 01F5      MOVW	R30,R10
    02AF9 8220      ST	Z,R2
    02AFA C01F      RJMP	0x2B1A
(0433) 	if(*q =='\t') {
    02AFB 01FA      MOVW	R30,R20
    02AFC 8180      LD	R24,Z
    02AFD 3089      CPI	R24,0x9
    02AFE F4A1      BNE	0x2B13
(0434) 		*p='\0';
    02AFF 2422      CLR	R2
    02B00 01F5      MOVW	R30,R10
    02B01 8220      ST	Z,R2
(0435) 		q++;
    02B02 5F4F      SUBI	R20,0xFF
    02B03 4F5F      SBCI	R21,0xFF
(0436) 	    if(j>7) break ;
    02B04 E087      LDI	R24,7
    02B05 158C      CP	R24,R12
    02B06 F408      BCC	0x2B08
    02B07 C012      RJMP	0x2B1A
(0437) 		j++;
    02B08 94C3      INC	R12
(0438) 		p=ary[j];
    02B09 01CE      MOVW	R24,R28
    02B0A 2DEC      MOV	R30,R12
    02B0B 27FF      CLR	R31
    02B0C 0FEE      LSL	R30
    02B0D 1FFF      ROL	R31
    02B0E 0FE8      ADD	R30,R24
    02B0F 1FF9      ADC	R31,R25
    02B10 80A0      LD	R10,Z
    02B11 80B1      LDD	R11,Z+1
(0439) 		continue ;
    02B12 C006      RJMP	0x2B19
(0440) 	}
(0441) 	//Usart_Transmit('-');
(0442) 	//Usart_Transmit(*q);
(0443) 	//Usart_Transmit(']');
(0444) 	//PrintChar(*q);
(0445) 	//Usart_Transmit('+');
(0446)     *p++=*q++;
    02B13 01FA      MOVW	R30,R20
    02B14 01D5      MOVW	R26,R10
    02B15 9001      LD	R0,Z+
    02B16 01AF      MOVW	R20,R30
    02B17 920D      ST	X+,R0
    02B18 015D      MOVW	R10,R26
    02B19 CFD9      RJMP	0x2AF3
    02B1A 9660      ADIW	R28,0x10
    02B1B 940C 4290 JMP	pop_xgset30FC
_get_name:
  i                    --> R20
  filenamep            --> R16
    02B1D 940E 42B9 CALL	push_xgsetF000
(0447) 	}
(0448) 	/* for debug
(0449) 	PrintString_n(Result.IndexChar);
(0450) 	PrintString_n(Result.Date);
(0451) 	PrintString_n(Result.Time);
(0452) 	PrintString_n(Result.TempChar);
(0453) 	PrintString_n(Result.WSChar);
(0454) 	PrintString_n(Result.WCIChar);
(0455) 	PrintString_n(Result.ECTChar);
(0456) 	PrintString_n(Result.TeqChar);
(0457) 	Result.WeiHai=*(q+1)-0x30;
(0458) 	Result.LowLabor=*(q+3)-0x30;
(0459) 	Result.MidLabor=*(q+5)-0x30;
(0460) 	Result.HighLabor=*(q+7)-0x30;
(0461) 	*/
(0462) 	return ;
(0463) }
(0464)  
(0465)  ////////////////////////////////////////////
(0466) //				根据当前日期获取文件名
(0467) //   
(0468) ////////////////////////////////////////////
(0469) char *get_name( char filenamep[] ){     
(0470) 	  unsigned char i=0;
(0471)  	  for(i=0;i<6;i++) {
    02B1F 2744      CLR	R20
    02B20 C00D      RJMP	0x2B2E
(0472) 	  				    *(filenamep+i)=Result.Date[i];
    02B21 EE81      LDI	R24,0xE1
    02B22 E095      LDI	R25,5
    02B23 2FE4      MOV	R30,R20
    02B24 27FF      CLR	R31
    02B25 0FE8      ADD	R30,R24
    02B26 1FF9      ADC	R31,R25
    02B27 8020      LD	R2,Z
    02B28 2FE4      MOV	R30,R20
    02B29 27FF      CLR	R31
    02B2A 0FE0      ADD	R30,R16
    02B2B 1FF1      ADC	R31,R17
    02B2C 8220      ST	Z,R2
    02B2D 9543      INC	R20
    02B2E 3046      CPI	R20,6
    02B2F F388      BCS	0x2B21
(0473) 	  				   } 
(0474) 	 	*(filenamep+(i++))='.';
    02B30 2E24      MOV	R2,R20
    02B31 2433      CLR	R3
    02B32 5F4F      SUBI	R20,0xFF
    02B33 2DE2      MOV	R30,R2
    02B34 27FF      CLR	R31
    02B35 0FE0      ADD	R30,R16
    02B36 1FF1      ADC	R31,R17
    02B37 E28E      LDI	R24,0x2E
    02B38 8380      ST	Z,R24
(0475) 		*(filenamep+(i++))='x';
    02B39 2E24      MOV	R2,R20
    02B3A 2433      CLR	R3
    02B3B 5F4F      SUBI	R20,0xFF
    02B3C 2DE2      MOV	R30,R2
    02B3D 27FF      CLR	R31
    02B3E 0FE0      ADD	R30,R16
    02B3F 1FF1      ADC	R31,R17
    02B40 E788      LDI	R24,0x78
    02B41 8380      ST	Z,R24
(0476) 		*(filenamep+(i++))='l';
    02B42 2F64      MOV	R22,R20
    02B43 2777      CLR	R23
    02B44 5F4F      SUBI	R20,0xFF
    02B45 2FE6      MOV	R30,R22
    02B46 27FF      CLR	R31
    02B47 0FE0      ADD	R30,R16
    02B48 1FF1      ADC	R31,R17
    02B49 E68C      LDI	R24,0x6C
    02B4A 8380      ST	Z,R24
(0477) 		*(filenamep+(i++))='s';
    02B4B 2F64      MOV	R22,R20
    02B4C 2777      CLR	R23
    02B4D 5F4F      SUBI	R20,0xFF
    02B4E 2FE6      MOV	R30,R22
    02B4F 27FF      CLR	R31
    02B50 0FE0      ADD	R30,R16
    02B51 1FF1      ADC	R31,R17
    02B52 E783      LDI	R24,0x73
    02B53 8380      ST	Z,R24
(0478) 		*(filenamep+(i))='\0';
    02B54 2FE4      MOV	R30,R20
    02B55 27FF      CLR	R31
    02B56 0FE0      ADD	R30,R16
    02B57 1FF1      ADC	R31,R17
    02B58 2422      CLR	R2
    02B59 8220      ST	Z,R2
(0479) 					   
(0480)       return filenamep;
    02B5A 940C 42BE JMP	pop_xgsetF000
_SquareRootFloat:
  f                    --> Y,+12
  x                    --> Y,+8
  i                    --> Y,+4
  y                    --> Y,+0
  number               --> Y,+20
    02B5C 940E 415F CALL	push_arg4
    02B5E 940E 42B9 CALL	push_xgsetF000
    02B60 9760      SBIW	R28,0x10
(0481) } 
(0482) float SquareRootFloat(float number)
(0483) {
(0484)     long i;
(0485)     float x, y;
(0486)     const float f = 1.5F;
    02B61 E900      LDI	R16,0x90
    02B62 E010      LDI	R17,0
    02B63 940E 422C CALL	elpm32
    02B65 870C      STD	Y+12,R16
    02B66 871D      STD	Y+13,R17
    02B67 872E      STD	Y+14,R18
    02B68 873F      STD	Y+15,R19
(0487)     x = number * 0.5F;
    02B69 E80C      LDI	R16,0x8C
    02B6A E010      LDI	R17,0
    02B6B 940E 422C CALL	elpm32
    02B6D 01CE      MOVW	R24,R28
    02B6E 9644      ADIW	R24,0x14
    02B6F 939A      ST	-Y,R25
    02B70 938A      ST	-Y,R24
    02B71 940E 459B CALL	fpmule1
    02B73 8708      STD	Y+8,R16
    02B74 8719      STD	Y+9,R17
    02B75 872A      STD	Y+10,R18
    02B76 873B      STD	Y+11,R19
(0488)     y  = number;
    02B77 882C      LDD	R2,Y+20
    02B78 883D      LDD	R3,Y+21
    02B79 884E      LDD	R4,Y+22
    02B7A 885F      LDD	R5,Y+23
    02B7B 8228      ST	Y,R2
    02B7C 8239      STD	Y+1,R3
    02B7D 824A      STD	Y+2,R4
    02B7E 825B      STD	Y+3,R5
(0489)     i  = * ( long * ) &y;
    02B7F 01FE      MOVW	R30,R28
    02B80 8020      LD	R2,Z
    02B81 8031      LDD	R3,Z+1
    02B82 8042      LDD	R4,Z+2
    02B83 8053      LDD	R5,Z+3
    02B84 822C      STD	Y+4,R2
    02B85 823D      STD	Y+5,R3
    02B86 824E      STD	Y+6,R4
    02B87 825F      STD	Y+7,R5
(0490)     i  = 0x5f3759df - ( i >> 1 );  //卡马克
    02B88 802C      LDD	R2,Y+4
    02B89 803D      LDD	R3,Y+5
    02B8A 804E      LDD	R4,Y+6
    02B8B 805F      LDD	R5,Y+7
    02B8C 9455      ASR	R5
    02B8D 9447      ROR	R4
    02B8E 9437      ROR	R3
    02B8F 9427      ROR	R2
    02B90 ED4F      LDI	R20,0xDF
    02B91 E559      LDI	R21,0x59
    02B92 E367      LDI	R22,0x37
    02B93 E57F      LDI	R23,0x5F
    02B94 1942      SUB	R20,R2
    02B95 0953      SBC	R21,R3
    02B96 0964      SBC	R22,R4
    02B97 0975      SBC	R23,R5
    02B98 834C      STD	Y+4,R20
    02B99 835D      STD	Y+5,R21
    02B9A 836E      STD	Y+6,R22
    02B9B 837F      STD	Y+7,R23
(0491)   //i  = 0x5f375a86 - ( i >> 1 );  //Lomont
(0492)     y  = * ( float * ) &i;
    02B9C 01FE      MOVW	R30,R28
    02B9D 9634      ADIW	R30,4
    02B9E 8020      LD	R2,Z
    02B9F 8031      LDD	R3,Z+1
    02BA0 8042      LDD	R4,Z+2
    02BA1 8053      LDD	R5,Z+3
    02BA2 8228      ST	Y,R2
    02BA3 8239      STD	Y+1,R3
    02BA4 824A      STD	Y+2,R4
    02BA5 825B      STD	Y+3,R5
(0493)     y  = y * ( f - ( x * y * y ) );
    02BA6 8028      LD	R2,Y
    02BA7 8039      LDD	R3,Y+1
    02BA8 804A      LDD	R4,Y+2
    02BA9 805B      LDD	R5,Y+3
    02BAA 846C      LDD	R6,Y+12
    02BAB 847D      LDD	R7,Y+13
    02BAC 848E      LDD	R8,Y+14
    02BAD 849F      LDD	R9,Y+15
    02BAE 8508      LDD	R16,Y+8
    02BAF 8519      LDD	R17,Y+9
    02BB0 852A      LDD	R18,Y+10
    02BB1 853B      LDD	R19,Y+11
    02BB2 01CE      MOVW	R24,R28
    02BB3 939A      ST	-Y,R25
    02BB4 938A      ST	-Y,R24
    02BB5 940E 459B CALL	fpmule1
    02BB7 01CE      MOVW	R24,R28
    02BB8 939A      ST	-Y,R25
    02BB9 938A      ST	-Y,R24
    02BBA 940E 45B0 CALL	fpmule1x
    02BBC 0183      MOVW	R16,R6
    02BBD 0194      MOVW	R18,R8
    02BBE 940E 43F0 CALL	fpsub2x
    02BC0 0181      MOVW	R16,R2
    02BC1 0192      MOVW	R18,R4
    02BC2 940E 45A5 CALL	fpmule2
    02BC4 8308      ST	Y,R16
    02BC5 8319      STD	Y+1,R17
    02BC6 832A      STD	Y+2,R18
    02BC7 833B      STD	Y+3,R19
(0494)     y  = y * ( f - ( x * y * y ) );
    02BC8 8028      LD	R2,Y
    02BC9 8039      LDD	R3,Y+1
    02BCA 804A      LDD	R4,Y+2
    02BCB 805B      LDD	R5,Y+3
    02BCC 846C      LDD	R6,Y+12
    02BCD 847D      LDD	R7,Y+13
    02BCE 848E      LDD	R8,Y+14
    02BCF 849F      LDD	R9,Y+15
    02BD0 8508      LDD	R16,Y+8
    02BD1 8519      LDD	R17,Y+9
    02BD2 852A      LDD	R18,Y+10
    02BD3 853B      LDD	R19,Y+11
    02BD4 01CE      MOVW	R24,R28
    02BD5 939A      ST	-Y,R25
    02BD6 938A      ST	-Y,R24
    02BD7 940E 459B CALL	fpmule1
    02BD9 01CE      MOVW	R24,R28
    02BDA 939A      ST	-Y,R25
    02BDB 938A      ST	-Y,R24
    02BDC 940E 45B0 CALL	fpmule1x
    02BDE 0183      MOVW	R16,R6
    02BDF 0194      MOVW	R18,R8
    02BE0 940E 43F0 CALL	fpsub2x
    02BE2 0181      MOVW	R16,R2
    02BE3 0192      MOVW	R18,R4
    02BE4 940E 45A5 CALL	fpmule2
    02BE6 8308      ST	Y,R16
    02BE7 8319      STD	Y+1,R17
    02BE8 832A      STD	Y+2,R18
    02BE9 833B      STD	Y+3,R19
(0495)     return number * y;
    02BEA 890C      LDD	R16,Y+20
    02BEB 891D      LDD	R17,Y+21
    02BEC 892E      LDD	R18,Y+22
    02BED 893F      LDD	R19,Y+23
    02BEE 01CE      MOVW	R24,R28
    02BEF 939A      ST	-Y,R25
    02BF0 938A      ST	-Y,R24
    02BF1 940E 459B CALL	fpmule1
    02BF3 9660      ADIW	R28,0x10
    02BF4 940E 42BE CALL	pop_xgsetF000
    02BF6 9624      ADIW	R28,4
    02BF7 9508      RET
_debug:
  str2                 --> Y,+0
  val                  --> Y,+6
  str                  --> Y,+4
    02BF8 940E 415F CALL	push_arg4
    02BFA 9724      SBIW	R28,4
(0496) } 
(0497) //
(0498) //###############################################################//
(0499) //debug
(0500) void debug(UINT8 *str,UINT8 val)
(0501) {
(0502)  UINT8 str2[4]={0,0,0,0};
    02BFB ED88      LDI	R24,0xD8
    02BFC E091      LDI	R25,1
    02BFD 01FE      MOVW	R30,R28
    02BFE E004      LDI	R16,4
    02BFF E010      LDI	R17,0
    02C00 93FA      ST	-Y,R31
    02C01 93EA      ST	-Y,R30
    02C02 939A      ST	-Y,R25
    02C03 938A      ST	-Y,R24
    02C04 940E 434B CALL	asgnblk
(0503)  str=str;
(0504)  val=val;
    02C06 9628      ADIW	R28,0x8
    02C07 9508      RET
_SD_Write_cmd:
  k                    --> R22
  temp                 --> R20
  p                    --> R20
    02C08 940E 42B9 CALL	push_xgsetF000
    02C0A 01A8      MOVW	R20,R16
FILE: D:\LQD\software\software_src\sd.c
(0001) //*****************************************************************************//
(0002) //*								数码相框
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SD卡控制
(0006) //*修改者：  桃子
(0007) //*****************************************************************************//
(0008) #include "sd.h"
(0009) 
(0010) //****************************************************************
(0011) //*隶属模块：SD卡控制
(0012) //*函数功能：写6字节数据
(0013) //****************************************************************
(0014) UINT8 SD_Write_cmd(UINT8 *p)
(0015) {	
(0016) 	UINT16 temp,k=0;
    02C0B 2766      CLR	R22
    02C0C 2777      CLR	R23
(0017) 	SD_CS_DIS();//禁止SPI
    02C0D 9AC0      SBI	0x18,0
(0018) 	SPI_Read();//空读一字节
    02C0E 940E 3ACE CALL	_SPI_Read
(0019) 	SD_CS_EN();//使能SPI
    02C10 98C0      CBI	0x18,0
(0020) 
(0021) 	SPI_Write(p[0]);
    02C11 01FA      MOVW	R30,R20
    02C12 8100      LD	R16,Z
    02C13 940E 3ACA CALL	_SPI_Write
(0022) 	SPI_Write(p[1]);
    02C15 01FA      MOVW	R30,R20
    02C16 8101      LDD	R16,Z+1
    02C17 940E 3ACA CALL	_SPI_Write
(0023) 	SPI_Write(p[2]);
    02C19 01FA      MOVW	R30,R20
    02C1A 8102      LDD	R16,Z+2
    02C1B 940E 3ACA CALL	_SPI_Write
(0024) 	SPI_Write(p[3]);
    02C1D 01FA      MOVW	R30,R20
    02C1E 8103      LDD	R16,Z+3
    02C1F 940E 3ACA CALL	_SPI_Write
(0025) 	SPI_Write(p[4]);
    02C21 01FA      MOVW	R30,R20
    02C22 8104      LDD	R16,Z+4
    02C23 940E 3ACA CALL	_SPI_Write
(0026) 	SPI_Write(p[5]);
    02C25 01FA      MOVW	R30,R20
    02C26 8105      LDD	R16,Z+5
    02C27 940E 3ACA CALL	_SPI_Write
(0027) 
(0028) 	do 
(0029)  	{  
(0030)   		temp = SPI_Read();//一直读，直到读到的不是0xff或超时
    02C29 940E 3ACE CALL	_SPI_Read
    02C2B 2F40      MOV	R20,R16
    02C2C 2755      CLR	R21
(0031)  		k++;
    02C2D 5F6F      SUBI	R22,0xFF
    02C2E 4F7F      SBCI	R23,0xFF
(0032)  	}while((temp==0xff)&&(k<TRY_TIME)); 
    02C2F 3F4F      CPI	R20,0xFF
    02C30 E0E0      LDI	R30,0
    02C31 075E      CPC	R21,R30
    02C32 F421      BNE	0x2C37
    02C33 3164      CPI	R22,0x14
    02C34 E0E0      LDI	R30,0
    02C35 077E      CPC	R23,R30
    02C36 F390      BCS	0x2C29
(0033) 
(0034) 	return temp;
    02C37 2F04      MOV	R16,R20
    02C38 940C 42BE JMP	pop_xgsetF000
_SD_Init:
  pcmd                 --> Y,+0
  temp                 --> R22
  time                 --> R20
    02C3A 940E 42C3 CALL	push_xgsetF00C
    02C3C 9726      SBIW	R28,6
(0035) }
(0036) //****************************************************************
(0037) //*隶属模块：SD卡控制
(0038) //*函数功能：初始化
(0039) //****************************************************************
(0040) UINT8 SD_Init(void)	
(0041) {  
(0042) 	UINT8 time=0,temp=0;
    02C3D 2744      CLR	R20
    02C3E 2766      CLR	R22
(0043) 	UINT8 pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; //命令0的字节序列
    02C3F E685      LDI	R24,0x65
    02C40 E092      LDI	R25,2
    02C41 01FE      MOVW	R30,R28
    02C42 E006      LDI	R16,6
    02C43 E010      LDI	R17,0
    02C44 93FA      ST	-Y,R31
    02C45 93EA      ST	-Y,R30
    02C46 939A      ST	-Y,R25
    02C47 938A      ST	-Y,R24
    02C48 940E 434B CALL	asgnblk
(0044) 	if(SD_DET()==0) return 0x02; //no disk
    02C4A B181      IN	R24,0x01
    02C4B 9586      LSR	R24
    02C4C 9586      LSR	R24
    02C4D 9586      LSR	R24
    02C4E 9586      LSR	R24
    02C4F 9586      LSR	R24
    02C50 7081      ANDI	R24,1
    02C51 F421      BNE	0x2C56
    02C52 E081      LDI	R24,1
    02C53 E090      LDI	R25,0
    02C54 015C      MOVW	R10,R24
    02C55 C002      RJMP	0x2C58
    02C56 24AA      CLR	R10
    02C57 24BB      CLR	R11
    02C58 20AA      TST	R10
    02C59 F421      BNE	0x2C5E
    02C5A 20BB      TST	R11
    02C5B F411      BNE	0x2C5E
    02C5C E002      LDI	R16,2
    02C5D C039      RJMP	0x2C97
(0045) 	SD_PORT |= (1<<SD_CS);
    02C5E 9AC0      SBI	0x18,0
(0046) 	SD_DDR |= (1<<SD_CS);
    02C5F 9AB8      SBI	0x17,0
(0047) 
(0048) 	SPI_IO_Init();
    02C60 940E 3AC0 CALL	_SPI_IO_Init
(0049) 	SPI_Low();
    02C62 E582      LDI	R24,0x52
    02C63 B98D      OUT	0x0D,R24
    02C64 B18E      IN	R24,0x0E
    02C65 7F8F      ANDI	R24,0xFF
    02C66 B98E      OUT	0x0E,R24
(0050) 
(0051) 	SD_CS_DIS();  //关闭片选 
    02C67 9AC0      SBI	0x18,0
(0052) 	for(time=0;time<10;time++) //初始时，首先要发送最少74个时钟信号，这是必须的！！！
    02C68 2744      CLR	R20
    02C69 C003      RJMP	0x2C6D
(0053) 	{
(0054)   		SPI_Read(); 
    02C6A 940E 3ACE CALL	_SPI_Read
    02C6C 9543      INC	R20
    02C6D 304A      CPI	R20,0xA
    02C6E F3D8      BCS	0x2C6A
(0055) 	}
(0056) 	SD_CS_EN(); //打开片选
    02C6F 98C0      CBI	0x18,0
(0057) 	time = 0;
    02C70 2744      CLR	R20
(0058) 	do
(0059) 	{ 
(0060) 		temp=SD_Write_cmd(pcmd);//写入CMD0
    02C71 018E      MOVW	R16,R28
    02C72 DF95      RCALL	_SD_Write_cmd
    02C73 2F60      MOV	R22,R16
(0061) 	 	time++;
    02C74 9543      INC	R20
(0062) 	 	if(time==TRY_TIME) 
    02C75 3144      CPI	R20,0x14
    02C76 F419      BNE	0x2C7A
(0063) 	 	{ 
(0064) 	  		SD_CS_DIS(); //关闭片选
    02C77 9AC0      SBI	0x18,0
(0065) 	  		return(INIT_CMD0_ERROR);//CMD0写入失败
    02C78 E001      LDI	R16,1
    02C79 C01D      RJMP	0x2C97
(0066) 	 	}
(0067) 	 }while(temp!=0x01);
    02C7A 3061      CPI	R22,1
    02C7B F7A9      BNE	0x2C71
(0068) 
(0069) 	SD_CS_DIS(); //关闭片选
    02C7C 9AC0      SBI	0x18,0
(0070) 	SPI_Read(); //按照SD卡的操作时序在这里补8个时钟 
    02C7D 940E 3ACE CALL	_SPI_Read
(0071) 	SD_CS_EN(); //打开片选
    02C7F 98C0      CBI	0x18,0
(0072) 
(0073) 	pcmd[0]=0x41,pcmd[5]=0xff;
    02C80 E481      LDI	R24,0x41
    02C81 8388      ST	Y,R24
    02C82 EF8F      LDI	R24,0xFF
    02C83 838D      STD	Y+5,R24
(0074) 	time = 0;
    02C84 2744      CLR	R20
(0075) 	do
(0076) 	{ 
(0077) 		temp=SD_Write_cmd(pcmd);
    02C85 018E      MOVW	R16,R28
    02C86 DF81      RCALL	_SD_Write_cmd
    02C87 2F60      MOV	R22,R16
(0078) 		time++;
    02C88 9543      INC	R20
(0079) 		if(time==TRY_TIME) 
    02C89 3144      CPI	R20,0x14
    02C8A F419      BNE	0x2C8E
(0080) 		{ 
(0081) 		 	SD_CS_DIS(); //关闭片选
    02C8B 9AC0      SBI	0x18,0
(0082) 			 return(INIT_CMD1_ERROR);//CMD1写入失败
    02C8C E002      LDI	R16,2
    02C8D C009      RJMP	0x2C97
(0083) 		 }
(0084) 	 }while(temp!=0);
    02C8E 2366      TST	R22
    02C8F F7A9      BNE	0x2C85
(0085)   
(0086) 	 SPI_High();  
    02C90 E580      LDI	R24,0x50
    02C91 B98D      OUT	0x0D,R24
    02C92 9A70      SBI	0x0E,0
(0087) 	 SD_CS_DIS();  //关闭片选 
    02C93 9AC0      SBI	0x18,0
(0088) 	 SPI_Read(); //按照SD卡的操作时序在这里补8个时钟
    02C94 940E 3ACE CALL	_SPI_Read
(0089) 	 return SD_TURE; //返回0,说明初始化操作成功
    02C96 2700      CLR	R16
    02C97 9626      ADIW	R28,6
    02C98 940C 42CA JMP	pop_xgsetF00C
_SD_Write_Sector:
  pcmd                 --> Y,+0
  time                 --> R12
  temp                 --> R20
  i                    --> R22
  buffer               --> R10
  addr                 --> Y,+14
    02C9A 940E 415F CALL	push_arg4
    02C9C 940E 42DF CALL	push_xgsetF03C
    02C9E 9726      SBIW	R28,6
    02C9F 88AA      LDD	R10,Y+18
    02CA0 88BB      LDD	R11,Y+19
(0090) } 
(0091) //****************************************************************
(0092) //*隶属模块：SD卡控制
(0093) //*函数功能：写512字节数据（一扇区字节）
(0094) //****************************************************************
(0095) UINT16 SD_Write_Sector(UINT32 addr,UINT8 *buffer)
(0096) {  
(0097) 	UINT8 temp=0,time=0;
    02CA1 2744      CLR	R20
    02CA2 24CC      CLR	R12
(0098) 	UINT16 i=0;
    02CA3 2766      CLR	R22
    02CA4 2777      CLR	R23
(0099) 	UINT8 pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //向SD卡中单个块（512字节，一个扇区）写入数据，用CMD24
    02CA5 E68B      LDI	R24,0x6B
    02CA6 E092      LDI	R25,2
    02CA7 01FE      MOVW	R30,R28
    02CA8 E006      LDI	R16,6
    02CA9 E010      LDI	R17,0
    02CAA 93FA      ST	-Y,R31
    02CAB 93EA      ST	-Y,R30
    02CAC 939A      ST	-Y,R25
    02CAD 938A      ST	-Y,R24
    02CAE 940E 434B CALL	asgnblk
(0100) 
(0101) 	 addr<<=9; //将块地址（扇区地址）转为字节地址 ［这里就限制了SD卡的最大容量为4G］
    02CB0 E089      LDI	R24,0x9
    02CB1 E090      LDI	R25,0
    02CB2 850E      LDD	R16,Y+14
    02CB3 851F      LDD	R17,Y+15
    02CB4 8928      LDD	R18,Y+16
    02CB5 8939      LDD	R19,Y+17
    02CB6 938A      ST	-Y,R24
    02CB7 940E 4326 CALL	lsl32
    02CB9 870E      STD	Y+14,R16
    02CBA 871F      STD	Y+15,R17
    02CBB 8B28      STD	Y+16,R18
    02CBC 8B39      STD	Y+17,R19
(0102) 
(0103) 	 pcmd[1]=(addr>>24); //将字节地址写入到CMD24字节序列中
    02CBD E188      LDI	R24,0x18
    02CBE E090      LDI	R25,0
    02CBF 850E      LDD	R16,Y+14
    02CC0 851F      LDD	R17,Y+15
    02CC1 8928      LDD	R18,Y+16
    02CC2 8939      LDD	R19,Y+17
    02CC3 938A      ST	-Y,R24
    02CC4 940E 433F CALL	lsr32
    02CC6 8309      STD	Y+1,R16
(0104) 	 pcmd[2]=(addr>>16);
    02CC7 842E      LDD	R2,Y+14
    02CC8 843F      LDD	R3,Y+15
    02CC9 8848      LDD	R4,Y+16
    02CCA 8859      LDD	R5,Y+17
    02CCB 0112      MOVW	R2,R4
    02CCC 2444      CLR	R4
    02CCD 2455      CLR	R5
    02CCE 822A      STD	Y+2,R2
(0105) 	 pcmd[3]=(addr>>8);
    02CCF E088      LDI	R24,0x8
    02CD0 E090      LDI	R25,0
    02CD1 850E      LDD	R16,Y+14
    02CD2 851F      LDD	R17,Y+15
    02CD3 8928      LDD	R18,Y+16
    02CD4 8939      LDD	R19,Y+17
    02CD5 938A      ST	-Y,R24
    02CD6 940E 433F CALL	lsr32
    02CD8 830B      STD	Y+3,R16
(0106) 	// pcmd[4]=offset;	
(0107) 	 SD_CS_EN();//打开SD卡片选
    02CD9 98C0      CBI	0x18,0
(0108) 
(0109) 	 do
(0110) 	 {  
(0111) 		temp=SD_Write_cmd(pcmd);
    02CDA 018E      MOVW	R16,R28
    02CDB DF2C      RCALL	_SD_Write_cmd
    02CDC 2F40      MOV	R20,R16
(0112)   		time++;
    02CDD 94C3      INC	R12
(0113)   		if(time==TRY_TIME) 
    02CDE 2D8C      MOV	R24,R12
    02CDF 3184      CPI	R24,0x14
    02CE0 F419      BNE	0x2CE4
(0114)   		{ 
(0115)    			SD_CS_DIS(); //关闭片选
    02CE1 9AC0      SBI	0x18,0
(0116)    			return(temp); //命令写入失败
    02CE2 2711      CLR	R17
    02CE3 C037      RJMP	0x2D1B
(0117)   		}
(0118) 	}while(temp!=0); 
    02CE4 2344      TST	R20
    02CE5 F7A1      BNE	0x2CDA
(0119) 
(0120) 	for(i=0;i<100;i++) //这里要插入若干时钟信号
    02CE6 2766      CLR	R22
    02CE7 2777      CLR	R23
    02CE8 C004      RJMP	0x2CED
(0121)   		SPI_Read();
    02CE9 940E 3ACE CALL	_SPI_Read
    02CEB 5F6F      SUBI	R22,0xFF
    02CEC 4F7F      SBCI	R23,0xFF
    02CED 3664      CPI	R22,0x64
    02CEE E0E0      LDI	R30,0
    02CEF 077E      CPC	R23,R30
    02CF0 F3C0      BCS	0x2CE9
(0122) 	
(0123) 	SPI_Write(0xfe);//写入开始字节 0xfe，后面就是要写入的512个字节的数据	
    02CF1 EF0E      LDI	R16,0xFE
    02CF2 940E 3ACA CALL	_SPI_Write
(0124) 	
(0125) 	for(i=0;i<512;i++) //将缓冲区中要写入的512个字节写入SD卡
    02CF4 2766      CLR	R22
    02CF5 2777      CLR	R23
    02CF6 C007      RJMP	0x2CFE
(0126) 		SPI_Write(*buffer++);
    02CF7 01F5      MOVW	R30,R10
    02CF8 9101      LD	R16,Z+
    02CF9 015F      MOVW	R10,R30
    02CFA 940E 3ACA CALL	_SPI_Write
    02CFC 5F6F      SUBI	R22,0xFF
    02CFD 4F7F      SBCI	R23,0xFF
    02CFE 3060      CPI	R22,0
    02CFF E0E2      LDI	R30,2
    02D00 077E      CPC	R23,R30
    02D01 F3A8      BCS	0x2CF7
(0127)   
(0128) 	SPI_Read(); 
    02D02 940E 3ACE CALL	_SPI_Read
(0129) 	SPI_Read(); //两个字节的CRC校验码，不用关心
    02D04 940E 3ACE CALL	_SPI_Read
(0130)    
(0131)     
(0132) 	temp=SPI_Read();   //读取返回值
    02D06 940E 3ACE CALL	_SPI_Read
    02D08 2F40      MOV	R20,R16
(0133) 	if((temp&0x1F)!=0x05) //如果返回值是 XXX00101说明数据已经被SD卡接受了
    02D09 2F84      MOV	R24,R20
    02D0A 718F      ANDI	R24,0x1F
    02D0B 3085      CPI	R24,5
    02D0C F021      BEQ	0x2D11
(0134) 	{
(0135)  		SD_CS_DIS();
    02D0D 9AC0      SBI	0x18,0
(0136)  		return(WRITE_BLOCK_ERROR); //写块数据失败
    02D0E E003      LDI	R16,3
    02D0F E010      LDI	R17,0
    02D10 C00A      RJMP	0x2D1B
(0137) 	}
(0138)  
(0139) 	while(SPI_Read()!=0xff);//等到SD卡不忙（数据被接受以后，SD卡要将这些数据写入到自身的FLASH中，需要一个时间）
    02D11 940E 3ACE CALL	_SPI_Read
    02D13 2F40      MOV	R20,R16
    02D14 3F0F      CPI	R16,0xFF
    02D15 F7D9      BNE	0x2D11
(0140) 						    //忙时，读回来的值为0x00,不忙时，为0xff
(0141) 
(0142) 	SD_CS_DIS(); //关闭片选
    02D16 9AC0      SBI	0x18,0
(0143) 
(0144) 	SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02D17 940E 3ACE CALL	_SPI_Read
(0145) 	return SD_TURE;		 //返回0,说明写扇区操作成功
    02D19 2700      CLR	R16
    02D1A 2711      CLR	R17
    02D1B 9626      ADIW	R28,6
    02D1C 940E 42E8 CALL	pop_xgsetF03C
    02D1E 9624      ADIW	R28,4
    02D1F 9508      RET
_SD_Read_Sector:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  buffer               --> R10
  addr                 --> Y,+14
    02D20 940E 415F CALL	push_arg4
    02D22 940E 42DF CALL	push_xgsetF03C
    02D24 9726      SBIW	R28,6
    02D25 88AA      LDD	R10,Y+18
    02D26 88BB      LDD	R11,Y+19
(0146) } 
(0147) //****************************************************************
(0148) //*隶属模块：SD卡控制
(0149) //*函数功能：读512字节数据（一扇区字节）
(0150) //****************************************************************
(0151) UINT16 SD_Read_Sector(UINT32 addr,UINT8 *buffer)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0152) {
(0153) 
(0154) 	 UINT16 j=0;
    02D27 2744      CLR	R20
    02D28 2755      CLR	R21
(0155) 	 UINT8 time=0,temp=0;
    02D29 2766      CLR	R22
    02D2A 24CC      CLR	R12
(0156) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02D2B E781      LDI	R24,0x71
    02D2C E092      LDI	R25,2
    02D2D 01FE      MOVW	R30,R28
    02D2E E006      LDI	R16,6
    02D2F E010      LDI	R17,0
    02D30 93FA      ST	-Y,R31
    02D31 93EA      ST	-Y,R30
    02D32 939A      ST	-Y,R25
    02D33 938A      ST	-Y,R24
    02D34 940E 434B CALL	asgnblk
(0157) 
(0158) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02D36 E089      LDI	R24,0x9
    02D37 E090      LDI	R25,0
    02D38 850E      LDD	R16,Y+14
    02D39 851F      LDD	R17,Y+15
    02D3A 8928      LDD	R18,Y+16
    02D3B 8939      LDD	R19,Y+17
    02D3C 938A      ST	-Y,R24
    02D3D 940E 4326 CALL	lsl32
    02D3F 870E      STD	Y+14,R16
    02D40 871F      STD	Y+15,R17
    02D41 8B28      STD	Y+16,R18
    02D42 8B39      STD	Y+17,R19
(0159) 
(0160) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02D43 E188      LDI	R24,0x18
    02D44 E090      LDI	R25,0
    02D45 850E      LDD	R16,Y+14
    02D46 851F      LDD	R17,Y+15
    02D47 8928      LDD	R18,Y+16
    02D48 8939      LDD	R19,Y+17
    02D49 938A      ST	-Y,R24
    02D4A 940E 433F CALL	lsr32
    02D4C 8309      STD	Y+1,R16
(0161) 	 pcmd[2] = (addr>>16);
    02D4D 842E      LDD	R2,Y+14
    02D4E 843F      LDD	R3,Y+15
    02D4F 8848      LDD	R4,Y+16
    02D50 8859      LDD	R5,Y+17
    02D51 0112      MOVW	R2,R4
    02D52 2444      CLR	R4
    02D53 2455      CLR	R5
    02D54 822A      STD	Y+2,R2
(0162) 	 pcmd[3] =(addr>>8);
    02D55 E088      LDI	R24,0x8
    02D56 E090      LDI	R25,0
    02D57 850E      LDD	R16,Y+14
    02D58 851F      LDD	R17,Y+15
    02D59 8928      LDD	R18,Y+16
    02D5A 8939      LDD	R19,Y+17
    02D5B 938A      ST	-Y,R24
    02D5C 940E 433F CALL	lsr32
    02D5E 830B      STD	Y+3,R16
(0163) 	// pcmd[4] = offset;
(0164) 
(0165) 	 SD_CS_EN();//打开片选 
    02D5F 98C0      CBI	0x18,0
(0166) 
(0167) 	 do
(0168) 	 {  
(0169) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02D60 018E      MOVW	R16,R28
    02D61 DEA6      RCALL	_SD_Write_cmd
    02D62 2EC0      MOV	R12,R16
(0170) 		  time++;
    02D63 9563      INC	R22
(0171) 		  if(time==TRY_TIME) 
    02D64 3164      CPI	R22,0x14
    02D65 F421      BNE	0x2D6A
(0172) 		  {
(0173) 		   SD_CS_DIS();
    02D66 9AC0      SBI	0x18,0
(0174) 		   return(READ_BLOCK_ERROR); //读块失败
    02D67 E004      LDI	R16,4
    02D68 E010      LDI	R17,0
    02D69 C01F      RJMP	0x2D89
(0175) 		  }
(0176) 	 }while(temp!=0); 
    02D6A 20CC      TST	R12
    02D6B F7A1      BNE	0x2D60
(0177)    			
(0178) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02D6C 940E 3ACE CALL	_SPI_Read
    02D6E 3F0E      CPI	R16,0xFE
    02D6F F7E1      BNE	0x2D6C
(0179)  		   	   	
(0180) 	 for(j=0;j<512;j++)	 //将数据写入到数据缓冲区中
    02D70 2744      CLR	R20
    02D71 2755      CLR	R21
    02D72 C009      RJMP	0x2D7C
(0181) 	 {	
(0182) 	    buffer[j]=SPI_Read();
    02D73 940E 3ACE CALL	_SPI_Read
    02D75 2EC0      MOV	R12,R16
    02D76 01FA      MOVW	R30,R20
    02D77 0DEA      ADD	R30,R10
    02D78 1DFB      ADC	R31,R11
    02D79 82C0      ST	Z,R12
    02D7A 5F4F      SUBI	R20,0xFF
    02D7B 4F5F      SBCI	R21,0xFF
    02D7C 3040      CPI	R20,0
    02D7D E0E2      LDI	R30,2
    02D7E 075E      CPC	R21,R30
    02D7F F398      BCS	0x2D73
(0183) 	 }
(0184) 
(0185) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02D80 940E 3ACE CALL	_SPI_Read
(0186) 	 SPI_Read();
    02D82 940E 3ACE CALL	_SPI_Read
(0187) 
(0188) 	 SD_CS_DIS();  //SD卡关闭片选 
    02D84 9AC0      SBI	0x18,0
(0189) 
(0190) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02D85 940E 3ACE CALL	_SPI_Read
(0191) 
(0192) 	 return SD_TURE;
    02D87 2700      CLR	R16
    02D88 2711      CLR	R17
    02D89 9626      ADIW	R28,6
    02D8A 940E 42E8 CALL	pop_xgsetF03C
    02D8C 9624      ADIW	R28,4
    02D8D 9508      RET
_SD_Read_Sector_ndata:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  len                  --> R14
  offset               --> R10
  buffer               --> Y,+20
  addr                 --> Y,+16
    02D8E 940E 415F CALL	push_arg4
    02D90 940E 42A4 CALL	push_xgsetF0FC
    02D92 9726      SBIW	R28,6
    02D93 88AE      LDD	R10,Y+22
    02D94 88BF      LDD	R11,Y+23
    02D95 8CE8      LDD	R14,Y+24
    02D96 8CF9      LDD	R15,Y+25
(0193) }
(0194) //****************************************************************
(0195) //*隶属模块：SD卡控制
(0196) //*函数功能：写多扇区数据（多扇区字节）
(0197) //****************************************************************
(0198) UINT16 SD_Read_Sector_ndata(UINT32 addr,UINT8 *buffer,UINT16 offset,UINT16 len)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0199) {
(0200) 
(0201) 	 UINT16 j=0;
    02D97 2744      CLR	R20
    02D98 2755      CLR	R21
(0202) 	 UINT8 time=0,temp=0;
    02D99 2766      CLR	R22
    02D9A 24CC      CLR	R12
(0203) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02D9B E787      LDI	R24,0x77
    02D9C E092      LDI	R25,2
    02D9D 01FE      MOVW	R30,R28
    02D9E E006      LDI	R16,6
    02D9F E010      LDI	R17,0
    02DA0 93FA      ST	-Y,R31
    02DA1 93EA      ST	-Y,R30
    02DA2 939A      ST	-Y,R25
    02DA3 938A      ST	-Y,R24
    02DA4 940E 434B CALL	asgnblk
(0204) 
(0205) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02DA6 E089      LDI	R24,0x9
    02DA7 E090      LDI	R25,0
    02DA8 8908      LDD	R16,Y+16
    02DA9 8919      LDD	R17,Y+17
    02DAA 892A      LDD	R18,Y+18
    02DAB 893B      LDD	R19,Y+19
    02DAC 938A      ST	-Y,R24
    02DAD 940E 4326 CALL	lsl32
    02DAF 8B08      STD	Y+16,R16
    02DB0 8B19      STD	Y+17,R17
    02DB1 8B2A      STD	Y+18,R18
    02DB2 8B3B      STD	Y+19,R19
(0206) 
(0207) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02DB3 E188      LDI	R24,0x18
    02DB4 E090      LDI	R25,0
    02DB5 8908      LDD	R16,Y+16
    02DB6 8919      LDD	R17,Y+17
    02DB7 892A      LDD	R18,Y+18
    02DB8 893B      LDD	R19,Y+19
    02DB9 938A      ST	-Y,R24
    02DBA 940E 433F CALL	lsr32
    02DBC 8309      STD	Y+1,R16
(0208) 	 pcmd[2] = (addr>>16);
    02DBD 8828      LDD	R2,Y+16
    02DBE 8839      LDD	R3,Y+17
    02DBF 884A      LDD	R4,Y+18
    02DC0 885B      LDD	R5,Y+19
    02DC1 0112      MOVW	R2,R4
    02DC2 2444      CLR	R4
    02DC3 2455      CLR	R5
    02DC4 822A      STD	Y+2,R2
(0209) 	 pcmd[3] =(addr>>8);
    02DC5 E088      LDI	R24,0x8
    02DC6 E090      LDI	R25,0
    02DC7 8908      LDD	R16,Y+16
    02DC8 8919      LDD	R17,Y+17
    02DC9 892A      LDD	R18,Y+18
    02DCA 893B      LDD	R19,Y+19
    02DCB 938A      ST	-Y,R24
    02DCC 940E 433F CALL	lsr32
    02DCE 830B      STD	Y+3,R16
(0210) 	// pcmd[4] = offset;
(0211) 
(0212) 	 SD_CS_EN();//打开片选 
    02DCF 98C0      CBI	0x18,0
(0213) 
(0214) 	 do
(0215) 	 {  
(0216) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02DD0 018E      MOVW	R16,R28
    02DD1 DE36      RCALL	_SD_Write_cmd
    02DD2 2EC0      MOV	R12,R16
(0217) 		  time++;
    02DD3 9563      INC	R22
(0218) 		  if(time==TRY_TIME) 
    02DD4 3164      CPI	R22,0x14
    02DD5 F421      BNE	0x2DDA
(0219) 		  {
(0220) 		   SD_CS_DIS();
    02DD6 9AC0      SBI	0x18,0
(0221) 		   return(READ_BLOCK_ERROR); //读块失败
    02DD7 E004      LDI	R16,4
    02DD8 E010      LDI	R17,0
    02DD9 C034      RJMP	0x2E0E
(0222) 		  }
(0223) 	 }while(temp!=0); 
    02DDA 20CC      TST	R12
    02DDB F7A1      BNE	0x2DD0
(0224)    			
(0225) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02DDC 940E 3ACE CALL	_SPI_Read
    02DDE 3F0E      CPI	R16,0xFE
    02DDF F7E1      BNE	0x2DDC
(0226)  		   	   	
(0227) 	 for(j=0;j<offset;j++)	 //将数据写入到数据缓冲区中
    02DE0 2744      CLR	R20
    02DE1 2755      CLR	R21
    02DE2 C004      RJMP	0x2DE7
(0228) 	    SPI_Read();
    02DE3 940E 3ACE CALL	_SPI_Read
    02DE5 5F4F      SUBI	R20,0xFF
    02DE6 4F5F      SBCI	R21,0xFF
    02DE7 154A      CP	R20,R10
    02DE8 055B      CPC	R21,R11
    02DE9 F3C8      BCS	0x2DE3
(0229) 	 for(;j<offset+len;j++)	 
    02DEA C00B      RJMP	0x2DF6
(0230) 		buffer[j]=SPI_Read();
    02DEB 940E 3ACE CALL	_SPI_Read
    02DED 2F60      MOV	R22,R16
    02DEE 01FA      MOVW	R30,R20
    02DEF 880C      LDD	R0,Y+20
    02DF0 881D      LDD	R1,Y+21
    02DF1 0DE0      ADD	R30,R0
    02DF2 1DF1      ADC	R31,R1
    02DF3 8360      ST	Z,R22
    02DF4 5F4F      SUBI	R20,0xFF
    02DF5 4F5F      SBCI	R21,0xFF
    02DF6 0115      MOVW	R2,R10
    02DF7 0C2E      ADD	R2,R14
    02DF8 1C3F      ADC	R3,R15
    02DF9 1542      CP	R20,R2
    02DFA 0553      CPC	R21,R3
    02DFB F378      BCS	0x2DEB
(0231) 	 for(;j<512;j++)	 
    02DFC C004      RJMP	0x2E01
(0232) 		SPI_Read();
    02DFD 940E 3ACE CALL	_SPI_Read
    02DFF 5F4F      SUBI	R20,0xFF
    02E00 4F5F      SBCI	R21,0xFF
    02E01 3040      CPI	R20,0
    02E02 E0E2      LDI	R30,2
    02E03 075E      CPC	R21,R30
    02E04 F3C0      BCS	0x2DFD
(0233) 
(0234) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02E05 940E 3ACE CALL	_SPI_Read
(0235) 	 SPI_Read();
    02E07 940E 3ACE CALL	_SPI_Read
(0236) 
(0237) 	 SD_CS_DIS();  //SD卡关闭片选 
    02E09 9AC0      SBI	0x18,0
(0238) 
(0239) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02E0A 940E 3ACE CALL	_SPI_Read
(0240) 
(0241) 	 return SD_TURE;
    02E0C 2700      CLR	R16
    02E0D 2711      CLR	R17
    02E0E 9626      ADIW	R28,6
    02E0F 940E 4299 CALL	pop_xgsetF0FC
    02E11 9624      ADIW	R28,4
    02E12 9508      RET
_GUI_mainmeu:
  key                  --> R22
  select               --> R20
    02E13 940E 42C3 CALL	push_xgsetF00C
    02E15 9723      SBIW	R28,3
FILE: D:\LQD\software\software_src\gui.c
(0001) #include "config.h"
(0002) const char labelH[]="高强度作业：\0";
(0003) const char labelM[]="中等强度作业：\0";
(0004) const char labelL[]="低强度作业：\0";
(0005) const char H01[]="加强劳动监督；\0";
(0006) const char H02[]="增加饮水;\0" ;
(0007) const char H03[]="保持干燥禁裸露。\0";
(0008) #define M01 H01
(0009) #define M02 H03
(0010) const char M03[]="戴面罩。\0";
(0011) const char M04[]="禁油彩。\0";
(0012) #define L01 M03
(0013) #define L02 M04
(0014) const char L03[]="缩短作业时间。";
(0015) //-----//
(0016) #define H11 M04
(0017) #define H12 H03
(0018) const char H13[]="休息注意保暖。\0";
(0019) #define M11 H01
(0020) const char M12[]="减少非必须作业；\0";
(0021) const char M13[]="劳动时间<30min。\0";
(0022) const char L11[]="取消非必须的作业\0";
(0023) const char L12[]="劳动时间<15min；\0";
(0024) #define L13 H03
(0025) //-----//
(0026) #define H21 L11
(0027) #define H22 L12
(0028) #define H23 H03
(0029) const char M21[]="取消户外作业。"; 
(0030) #define L21 M21
(0031) 
(0032) //#define LEDON   PORTC&=~(1<<7)					   
(0033) //#define LEDOFF  PINC|=(1<<7)
(0034) char GUI_date[17]="09月19日18:00:00\0";
(0035) 
(0036) // 主菜单
(0037) unsigned char GUI_mainmeu( void ){
(0038)  	unsigned char key=0; //init= nokey
    02E16 2766      CLR	R22
(0039) 	unsigned char select=3;
    02E17 E043      LDI	R20,3
(0040) 	LCD_CLR();
    02E18 940E 3BAE CALL	_LCD_CLR
(0041) 	
(0042)  	Set_White(1,1,8,1);
    02E1A E081      LDI	R24,1
    02E1B 838A      STD	Y+2,R24
    02E1C E088      LDI	R24,0x8
    02E1D 8388      ST	Y,R24
    02E1E E021      LDI	R18,1
    02E1F E001      LDI	R16,1
    02E20 940E 3C38 CALL	_Set_White
(0043) 	Set_White(1,2,8,1);
    02E22 E081      LDI	R24,1
    02E23 838A      STD	Y+2,R24
    02E24 E088      LDI	R24,0x8
    02E25 8388      ST	Y,R24
    02E26 E022      LDI	R18,2
    02E27 E001      LDI	R16,1
    02E28 940E 3C38 CALL	_Set_White
(0044) 	Set_White(1,3,8,1);
    02E2A E081      LDI	R24,1
    02E2B 838A      STD	Y+2,R24
    02E2C E088      LDI	R24,0x8
    02E2D 8388      ST	Y,R24
    02E2E E023      LDI	R18,3
    02E2F E001      LDI	R16,1
    02E30 940E 3C38 CALL	_Set_White
(0045) 	Set_White(1,4,8,1);
    02E32 E081      LDI	R24,1
    02E33 838A      STD	Y+2,R24
    02E34 E088      LDI	R24,0x8
    02E35 8388      ST	Y,R24
    02E36 E024      LDI	R18,4
    02E37 E001      LDI	R16,1
    02E38 940E 3C38 CALL	_Set_White
(0046) 	dateRefresh(1); //更新系统时间
    02E3A E001      LDI	R16,1
    02E3B 940E 379B CALL	_dateRefresh
(0047) 	LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02E3D D543      RCALL	_GUI_get_date
    02E3E 8319      STD	Y+1,R17
    02E3F 8308      ST	Y,R16
    02E40 E021      LDI	R18,1
    02E41 E001      LDI	R16,1
    02E42 940E 3B08 CALL	_LCD_const_disp
(0048) 	LCD_const_disp(2,1,"  检测  时钟调整");
    02E44 E480      LDI	R24,0x40
    02E45 E095      LDI	R25,5
    02E46 8399      STD	Y+1,R25
    02E47 8388      ST	Y,R24
    02E48 E021      LDI	R18,1
    02E49 E002      LDI	R16,2
    02E4A 940E 3B08 CALL	_LCD_const_disp
(0049) 	LCD_const_disp(3,1,"  查询  数据传输");
    02E4C E28F      LDI	R24,0x2F
    02E4D E095      LDI	R25,5
    02E4E 8399      STD	Y+1,R25
    02E4F 8388      ST	Y,R24
    02E50 E021      LDI	R18,1
    02E51 E003      LDI	R16,3
    02E52 940E 3B08 CALL	_LCD_const_disp
(0050) 	LCD_const_disp(4,1,"  初始化");
    02E54 E286      LDI	R24,0x26
    02E55 E095      LDI	R25,5
    02E56 8399      STD	Y+1,R25
    02E57 8388      ST	Y,R24
    02E58 E021      LDI	R18,1
    02E59 E004      LDI	R16,4
    02E5A 940E 3B08 CALL	_LCD_const_disp
(0051) 	Set_White(1,1,8,1);
    02E5C E081      LDI	R24,1
    02E5D 838A      STD	Y+2,R24
    02E5E E088      LDI	R24,0x8
    02E5F 8388      ST	Y,R24
    02E60 E021      LDI	R18,1
    02E61 E001      LDI	R16,1
    02E62 940E 3C38 CALL	_Set_White
(0052) 	Set_White(1,2,8,1);
    02E64 E081      LDI	R24,1
    02E65 838A      STD	Y+2,R24
    02E66 E088      LDI	R24,0x8
    02E67 8388      ST	Y,R24
    02E68 E022      LDI	R18,2
    02E69 E001      LDI	R16,1
    02E6A 940E 3C38 CALL	_Set_White
(0053) 	Set_White(1,3,8,1);
    02E6C E081      LDI	R24,1
    02E6D 838A      STD	Y+2,R24
    02E6E E088      LDI	R24,0x8
    02E6F 8388      ST	Y,R24
    02E70 E023      LDI	R18,3
    02E71 E001      LDI	R16,1
    02E72 940E 3C38 CALL	_Set_White
(0054) 	Set_White(1,4,8,1);
    02E74 E081      LDI	R24,1
    02E75 838A      STD	Y+2,R24
    02E76 E088      LDI	R24,0x8
    02E77 8388      ST	Y,R24
    02E78 E024      LDI	R18,4
    02E79 E001      LDI	R16,1
    02E7A 940E 3C38 CALL	_Set_White
(0055) 	set_white_n(select,0);
    02E7C 2722      CLR	R18
    02E7D 2F04      MOV	R16,R20
    02E7E 940E 3CCA CALL	_set_white_n
    02E80 C07D      RJMP	0x2EFE
(0056) 	while(1)
(0057) 	{
(0058) 	 	key=kbscan();
    02E81 940E 40F2 CALL	_kbscan
    02E83 2F60      MOV	R22,R16
(0059) 		dateRefresh(1); //更新系统时间
    02E84 E001      LDI	R16,1
    02E85 940E 379B CALL	_dateRefresh
(0060) 		LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02E87 D4F9      RCALL	_GUI_get_date
    02E88 0158      MOVW	R10,R16
    02E89 82B9      STD	Y+1,R11
    02E8A 82A8      ST	Y,R10
    02E8B E021      LDI	R18,1
    02E8C E001      LDI	R16,1
    02E8D 940E 3B08 CALL	_LCD_const_disp
(0061) 		if((select>3) && ( key==up ) ){
    02E8F E083      LDI	R24,3
    02E90 1784      CP	R24,R20
    02E91 F4F8      BCC	0x2EB1
    02E92 316E      CPI	R22,0x1E
    02E93 F4E9      BNE	0x2EB1
(0062) 		 Set_White(1,2,8,1);
    02E94 E081      LDI	R24,1
    02E95 838A      STD	Y+2,R24
    02E96 E088      LDI	R24,0x8
    02E97 8388      ST	Y,R24
    02E98 E022      LDI	R18,2
    02E99 E001      LDI	R16,1
    02E9A 940E 3C38 CALL	_Set_White
(0063) 		 Set_White(1,3,8,1);
    02E9C E081      LDI	R24,1
    02E9D 838A      STD	Y+2,R24
    02E9E E088      LDI	R24,0x8
    02E9F 8388      ST	Y,R24
    02EA0 E023      LDI	R18,3
    02EA1 E001      LDI	R16,1
    02EA2 940E 3C38 CALL	_Set_White
(0064) 		 Set_White(1,4,8,1);
    02EA4 E081      LDI	R24,1
    02EA5 838A      STD	Y+2,R24
    02EA6 E088      LDI	R24,0x8
    02EA7 8388      ST	Y,R24
    02EA8 E024      LDI	R18,4
    02EA9 E001      LDI	R16,1
    02EAA 940E 3C38 CALL	_Set_White
(0065) 		 select--;
    02EAC 954A      DEC	R20
(0066) 		 set_white_n(select,0);
    02EAD 2722      CLR	R18
    02EAE 2F04      MOV	R16,R20
    02EAF 940E 3CCA CALL	_set_white_n
(0067) 		}
(0068) 		if((select<7) && ( key==down ) ){
    02EB1 3047      CPI	R20,7
    02EB2 F538      BCC	0x2EDA
    02EB3 316D      CPI	R22,0x1D
    02EB4 F529      BNE	0x2EDA
(0069) 		 Set_White(1,1,8,1);
    02EB5 E081      LDI	R24,1
    02EB6 838A      STD	Y+2,R24
    02EB7 E088      LDI	R24,0x8
    02EB8 8388      ST	Y,R24
    02EB9 E021      LDI	R18,1
    02EBA E001      LDI	R16,1
    02EBB 940E 3C38 CALL	_Set_White
(0070) 		 Set_White(1,2,8,1);
    02EBD E081      LDI	R24,1
    02EBE 838A      STD	Y+2,R24
    02EBF E088      LDI	R24,0x8
    02EC0 8388      ST	Y,R24
    02EC1 E022      LDI	R18,2
    02EC2 E001      LDI	R16,1
    02EC3 940E 3C38 CALL	_Set_White
(0071) 		 Set_White(1,3,8,1);
    02EC5 E081      LDI	R24,1
    02EC6 838A      STD	Y+2,R24
    02EC7 E088      LDI	R24,0x8
    02EC8 8388      ST	Y,R24
    02EC9 E023      LDI	R18,3
    02ECA E001      LDI	R16,1
    02ECB 940E 3C38 CALL	_Set_White
(0072) 		 Set_White(1,4,8,1);
    02ECD E081      LDI	R24,1
    02ECE 838A      STD	Y+2,R24
    02ECF E088      LDI	R24,0x8
    02ED0 8388      ST	Y,R24
    02ED1 E024      LDI	R18,4
    02ED2 E001      LDI	R16,1
    02ED3 940E 3C38 CALL	_Set_White
(0073) 		 select++;
    02ED5 9543      INC	R20
(0074) 		 set_white_n(select,0);
    02ED6 2722      CLR	R18
    02ED7 2F04      MOV	R16,R20
    02ED8 940E 3CCA CALL	_set_white_n
(0075) 		}
(0076) 		if(key == left ){
    02EDA 316B      CPI	R22,0x1B
    02EDB F511      BNE	0x2EFE
(0077) 		 Set_White(1,1,8,1);
    02EDC E081      LDI	R24,1
    02EDD 838A      STD	Y+2,R24
    02EDE E088      LDI	R24,0x8
    02EDF 8388      ST	Y,R24
    02EE0 E021      LDI	R18,1
    02EE1 E001      LDI	R16,1
    02EE2 940E 3C38 CALL	_Set_White
(0078) 		 Set_White(1,2,8,1);
    02EE4 E081      LDI	R24,1
    02EE5 838A      STD	Y+2,R24
    02EE6 E088      LDI	R24,0x8
    02EE7 8388      ST	Y,R24
    02EE8 E022      LDI	R18,2
    02EE9 E001      LDI	R16,1
    02EEA 940E 3C38 CALL	_Set_White
(0079) 		 Set_White(1,3,8,1);
    02EEC E081      LDI	R24,1
    02EED 838A      STD	Y+2,R24
    02EEE E088      LDI	R24,0x8
    02EEF 8388      ST	Y,R24
    02EF0 E023      LDI	R18,3
    02EF1 E001      LDI	R16,1
    02EF2 940E 3C38 CALL	_Set_White
(0080) 		 Set_White(1,4,8,1);
    02EF4 E081      LDI	R24,1
    02EF5 838A      STD	Y+2,R24
    02EF6 E088      LDI	R24,0x8
    02EF7 8388      ST	Y,R24
    02EF8 E024      LDI	R18,4
    02EF9 E001      LDI	R16,1
    02EFA 940E 3C38 CALL	_Set_White
(0081) 		 //beep(3,select);
(0082) 		 return select;
    02EFC 2F04      MOV	R16,R20
    02EFD C001      RJMP	0x2EFF
    02EFE CF82      RJMP	0x2E81
    02EFF 9623      ADIW	R28,3
    02F00 940C 42CA JMP	pop_xgsetF00C
_GUI_check:
  windcounter          --> R10
  next_step_time       --> Y,+3
  selectCheckMode      --> R14
  is_on                --> Y,+8
  page                 --> Y,+7
  key                  --> R12
    02F02 940E 42A4 CALL	push_xgsetF0FC
    02F04 9729      SBIW	R28,0x9
(0083) 		}
(0084)     }
(0085) 	return 0xff; //error
(0086) 	
(0087) }
(0088) 
(0089) //”检测 “菜单
(0090) void GUI_check(void){
(0091)     char key;
(0092) 	char page=0,is_on=0;
    02F05 2400      CLR	R0
    02F06 820F      STD	Y+7,R0
    02F07 8608      STD	Y+8,R0
(0093) 	char windcounter=0;
    02F08 24AA      CLR	R10
(0094) 	unsigned long next_step_time=0;
    02F09 E080      LDI	R24,0
    02F0A 838B      STD	Y+3,R24
    02F0B 838C      STD	Y+4,R24
    02F0C 838D      STD	Y+5,R24
    02F0D 838E      STD	Y+6,R24
(0095) 	char selectCheckMode=config.autocheck; //自动检测开关
    02F0E 90E0 084B LDS	R14,config+16
(0096) RE_IN:
(0097) 	key=0;
    02F10 24CC      CLR	R12
(0098) 	page=0;
    02F11 2400      CLR	R0
    02F12 820F      STD	Y+7,R0
(0099) 	is_on=0;
    02F13 8608      STD	Y+8,R0
(0100) 	windcounter=0;
    02F14 24AA      CLR	R10
(0101) 	next_step_time=0;
    02F15 E080      LDI	R24,0
    02F16 838B      STD	Y+3,R24
    02F17 838C      STD	Y+4,R24
    02F18 838D      STD	Y+5,R24
    02F19 838E      STD	Y+6,R24
(0102) 	
(0103) 	dateRefresh(1);
    02F1A E001      LDI	R16,1
    02F1B 940E 379B CALL	_dateRefresh
(0104) 	LCD_CLR();
    02F1D 940E 3BAE CALL	_LCD_CLR
(0105) 	LCD_const_disp(1,1,"菜单/ 检测");
    02F1F E18B      LDI	R24,0x1B
    02F20 E095      LDI	R25,5
    02F21 8399      STD	Y+1,R25
    02F22 8388      ST	Y,R24
    02F23 E021      LDI	R18,1
    02F24 E001      LDI	R16,1
    02F25 940E 3B08 CALL	_LCD_const_disp
(0106) 	LCD_const_disp(2,3,"自动");		 
    02F27 E186      LDI	R24,0x16
    02F28 E095      LDI	R25,5
    02F29 8399      STD	Y+1,R25
    02F2A 8388      ST	Y,R24
    02F2B E023      LDI	R18,3
    02F2C E002      LDI	R16,2
    02F2D 940E 3B08 CALL	_LCD_const_disp
(0107) 	LCD_const_disp(3,3,"手动");
    02F2F E181      LDI	R24,0x11
    02F30 E095      LDI	R25,5
    02F31 8399      STD	Y+1,R25
    02F32 8388      ST	Y,R24
    02F33 E023      LDI	R18,3
    02F34 E003      LDI	R16,3
    02F35 940E 3B08 CALL	_LCD_const_disp
(0108) 	if(selectCheckMode==1) {
    02F37 2D8E      MOV	R24,R14
    02F38 3081      CPI	R24,1
    02F39 F489      BNE	0x2F4B
(0109) 	    Set_White(1,2,8,0);
    02F3A 2422      CLR	R2
    02F3B 822A      STD	Y+2,R2
    02F3C E088      LDI	R24,0x8
    02F3D 8388      ST	Y,R24
    02F3E E022      LDI	R18,2
    02F3F E001      LDI	R16,1
    02F40 940E 3C38 CALL	_Set_White
(0110) 		Set_White(1,3,8,1);
    02F42 E081      LDI	R24,1
    02F43 838A      STD	Y+2,R24
    02F44 E088      LDI	R24,0x8
    02F45 8388      ST	Y,R24
    02F46 E023      LDI	R18,3
    02F47 E001      LDI	R16,1
    02F48 940E 3C38 CALL	_Set_White
(0111) 	}
    02F4A C05B      RJMP	0x2FA6
(0112) 	else {
(0113) 		 Set_White(1,2,8,1);
    02F4B E081      LDI	R24,1
    02F4C 838A      STD	Y+2,R24
    02F4D E088      LDI	R24,0x8
    02F4E 8388      ST	Y,R24
    02F4F E022      LDI	R18,2
    02F50 E001      LDI	R16,1
    02F51 940E 3C38 CALL	_Set_White
(0114) 		 Set_White(1,3,8,0);
    02F53 2422      CLR	R2
    02F54 822A      STD	Y+2,R2
    02F55 E088      LDI	R24,0x8
    02F56 8388      ST	Y,R24
    02F57 E023      LDI	R18,3
    02F58 E001      LDI	R16,1
    02F59 940E 3C38 CALL	_Set_White
(0115) 	}
    02F5B C04A      RJMP	0x2FA6
(0116) 	
(0117) //<<菜单/检测/手（自）动>>
(0118) 	while(1){
(0119) 	 	key=kbscan();
    02F5C 940E 40F2 CALL	_kbscan
    02F5E 2EC0      MOV	R12,R16
(0120) 		//上键短按 选择
(0121) 		if(key==up || key ==down){
    02F5F 2D8C      MOV	R24,R12
    02F60 310E      CPI	R16,0x1E
    02F61 F011      BEQ	0x2F64
    02F62 310D      CPI	R16,0x1D
    02F63 F539      BNE	0x2F8B
(0122) 		    if(selectCheckMode >0){
    02F64 E080      LDI	R24,0
    02F65 158E      CP	R24,R14
    02F66 F490      BCC	0x2F79
(0123) 			    selectCheckMode=0;
    02F67 24EE      CLR	R14
(0124) 				Set_White(1,2,8,1);
    02F68 E081      LDI	R24,1
    02F69 838A      STD	Y+2,R24
    02F6A E088      LDI	R24,0x8
    02F6B 8388      ST	Y,R24
    02F6C E022      LDI	R18,2
    02F6D E001      LDI	R16,1
    02F6E 940E 3C38 CALL	_Set_White
(0125) 	 			Set_White(1,3,8,0);
    02F70 2422      CLR	R2
    02F71 822A      STD	Y+2,R2
    02F72 E088      LDI	R24,0x8
    02F73 8388      ST	Y,R24
    02F74 E023      LDI	R18,3
    02F75 E001      LDI	R16,1
    02F76 940E 3C38 CALL	_Set_White
(0126) 			}
    02F78 C012      RJMP	0x2F8B
(0127) 			else {
(0128) 			    selectCheckMode=1;
    02F79 24EE      CLR	R14
    02F7A 94E3      INC	R14
(0129) 				Set_White(1,2,8,0);
    02F7B 2422      CLR	R2
    02F7C 822A      STD	Y+2,R2
    02F7D E088      LDI	R24,0x8
    02F7E 8388      ST	Y,R24
    02F7F E022      LDI	R18,2
    02F80 E001      LDI	R16,1
    02F81 940E 3C38 CALL	_Set_White
(0130) 	 			Set_White(1,3,8,1);
    02F83 E081      LDI	R24,1
    02F84 838A      STD	Y+2,R24
    02F85 E088      LDI	R24,0x8
    02F86 8388      ST	Y,R24
    02F87 E023      LDI	R18,3
    02F88 E001      LDI	R16,1
    02F89 940E 3C38 CALL	_Set_White
(0131) 			}
(0132) 			
(0133) 		}
(0134) 		//左键短按  进入
(0135) 		if(key == left) {
    02F8B 2D8C      MOV	R24,R12
    02F8C 318B      CPI	R24,0x1B
    02F8D F499      BNE	0x2FA1
(0136) 			config.autocheck=selectCheckMode; 
    02F8E 92E0 084B STS	config+16,R14
(0137) 			Set_White(1,2,8,1);
    02F90 E081      LDI	R24,1
    02F91 838A      STD	Y+2,R24
    02F92 E088      LDI	R24,0x8
    02F93 8388      ST	Y,R24
    02F94 E022      LDI	R18,2
    02F95 E001      LDI	R16,1
    02F96 940E 3C38 CALL	_Set_White
(0138) 	 		Set_White(1,3,8,1); 
    02F98 E081      LDI	R24,1
    02F99 838A      STD	Y+2,R24
    02F9A E088      LDI	R24,0x8
    02F9B 8388      ST	Y,R24
    02F9C E023      LDI	R18,3
    02F9D E001      LDI	R16,1
    02F9E 940E 3C38 CALL	_Set_White
(0139) 			break ;		
    02FA0 C006      RJMP	0x2FA7
(0140) 		}
(0141) 		//右键短按  返回
(0142) 		if(key == right) {
    02FA1 2D8C      MOV	R24,R12
    02FA2 3187      CPI	R24,0x17
    02FA3 F409      BNE	0x2FA5
(0143) 			return ;		
    02FA4 C1CD      RJMP	0x3172
(0144) 		}
(0145) 		key=0;
    02FA5 24CC      CLR	R12
    02FA6 CFB5      RJMP	0x2F5C
(0146) 	} //end of while
(0147)     //自动开启检测
(0148) 	dateRefresh(0);
    02FA7 2700      CLR	R16
    02FA8 D7F2      RCALL	_dateRefresh
(0149) 	is_on =1 ;
    02FA9 2400      CLR	R0
    02FAA 9403      INC	R0
    02FAB 8608      STD	Y+8,R0
(0150) 	config.time1=config.now+config.THRESHOLD_delta_sec;
    02FAC 9040 0841 LDS	R4,config+6
    02FAE 9050 0842 LDS	R5,config+7
    02FB0 9020 083F LDS	R2,config+4
    02FB2 9030 0840 LDS	R3,config+5
    02FB4 9080 0849 LDS	R8,config+14
    02FB6 9090 084A LDS	R9,config+15
    02FB8 9060 0847 LDS	R6,config+12
    02FBA 9070 0848 LDS	R7,config+13
    02FBC 0C62      ADD	R6,R2
    02FBD 1C73      ADC	R7,R3
    02FBE 1C84      ADC	R8,R4
    02FBF 1C95      ADC	R9,R5
    02FC0 9270 0844 STS	config+9,R7
    02FC2 9260 0843 STS	config+8,R6
    02FC4 9290 0846 STS	config+11,R9
    02FC6 9280 0845 STS	config+10,R8
(0151) 	Result.TempChar[0]=0; //清除上次结果
    02FC8 2422      CLR	R2
    02FC9 9220 05F8 STS	Result+45,R2
(0152) 	Result.WSChar[0]=0;
    02FCB 9220 0602 STS	Result+55,R2
    02FCD C1A3      RJMP	0x3171
(0153) 	while(1){
(0154) 		key=kbscan();
    02FCE 940E 40F2 CALL	_kbscan
    02FD0 2EC0      MOV	R12,R16
(0155) 		if(key != 0) beep(0,1);
    02FD1 2300      TST	R16
    02FD2 F021      BEQ	0x2FD7
    02FD3 E021      LDI	R18,1
    02FD4 2700      CLR	R16
    02FD5 940E 3E83 CALL	_beep
(0156) 		if(key==right){	//右键 退出
    02FD7 2D8C      MOV	R24,R12
    02FD8 3187      CPI	R24,0x17
    02FD9 F569      BNE	0x3007
(0157) 		    is_on=0;
    02FDA 2400      CLR	R0
    02FDB 8608      STD	Y+8,R0
(0158) 			LCD_CLR();
    02FDC 940E 3BAE CALL	_LCD_CLR
(0159) 		 	LCD_Init();	  
    02FDE 940E 3B7C CALL	_LCD_Init
(0160) 	 	 	LCD_const_disp(4,5,"退出    "); 
    02FE0 E088      LDI	R24,0x8
    02FE1 E095      LDI	R25,5
    02FE2 8399      STD	Y+1,R25
    02FE3 8388      ST	Y,R24
    02FE4 E025      LDI	R18,5
    02FE5 E004      LDI	R16,4
    02FE6 940E 3B08 CALL	_LCD_const_disp
(0161) 		 	delayms(200);
    02FE8 EC08      LDI	R16,0xC8
    02FE9 E010      LDI	R17,0
    02FEA 940E 2440 CALL	_delayms
(0162) 		 	LCD_const_disp(4,7,".."); 
    02FEC E085      LDI	R24,5
    02FED E095      LDI	R25,5
    02FEE 8399      STD	Y+1,R25
    02FEF 8388      ST	Y,R24
    02FF0 E027      LDI	R18,7
    02FF1 E004      LDI	R16,4
    02FF2 940E 3B08 CALL	_LCD_const_disp
(0163) 		 	delayms(200);
    02FF4 EC08      LDI	R16,0xC8
    02FF5 E010      LDI	R17,0
    02FF6 940E 2440 CALL	_delayms
(0164) 		 	LCD_const_disp(4,8,".."); 	
    02FF8 E085      LDI	R24,5
    02FF9 E095      LDI	R25,5
    02FFA 8399      STD	Y+1,R25
    02FFB 8388      ST	Y,R24
    02FFC E028      LDI	R18,0x8
    02FFD E004      LDI	R16,4
    02FFE 940E 3B08 CALL	_LCD_const_disp
(0165) 		 	delayms(500);
    03000 EF04      LDI	R16,0xF4
    03001 E011      LDI	R17,1
    03002 940E 2440 CALL	_delayms
(0166) 		 	LCD_CLR();
    03004 940E 3BAE CALL	_LCD_CLR
(0167) 		 	goto RE_IN;
    03006 CF09      RJMP	0x2F10
(0168) 		}
(0169) 		if(is_on==1){ 
    03007 8588      LDD	R24,Y+8
    03008 3081      CPI	R24,1
    03009 F009      BEQ	0x300B
    0300A C08B      RJMP	0x3096
(0170) 			dateRefresh(1); 
    0300B E001      LDI	R16,1
    0300C D78E      RCALL	_dateRefresh
(0171) 		    _GUI_datashow(page); //更新时间
    0300D 810F      LDD	R16,Y+7
    0300E D166      RCALL	__GUI_datashow
(0172) 		    if(config.now < config.time1) {
    0300F 9040 0845 LDS	R4,config+10
    03011 9050 0846 LDS	R5,config+11
    03013 9020 0843 LDS	R2,config+8
    03015 9030 0844 LDS	R3,config+9
    03017 9080 0849 LDS	R8,config+14
    03019 9090 084A LDS	R9,config+15
    0301B 9060 0847 LDS	R6,config+12
    0301D 9070 0848 LDS	R7,config+13
    0301F 1462      CP	R6,R2
    03020 0473      CPC	R7,R3
    03021 0484      CPC	R8,R4
    03022 0495      CPC	R9,R5
    03023 F598      BCC	0x3057
(0173) 				//时间更新 开启风速检测 等待检测 不支持翻页
(0174) 				if(windcounter==0){
    03024 20AA      TST	R10
    03025 F421      BNE	0x302A
(0175) 				    windcounter=1; //清零开启风速计数器
    03026 24AA      CLR	R10
    03027 94A3      INC	R10
(0176) 					timer1_init(); //开启风速传感器技术
    03028 940E 248C CALL	_timer1_init
(0177) 				}
(0178) 				if(page == 0 ){
    0302A 800F      LDD	R0,Y+7
    0302B 2000      TST	R0
    0302C F009      BEQ	0x302E
    0302D C13F      RJMP	0x316D
(0179) 				
(0180) 				    LCD_const_disp(4,1,"正在检测");
    0302E EF8C      LDI	R24,0xFC
    0302F E094      LDI	R25,4
    03030 8399      STD	Y+1,R25
    03031 8388      ST	Y,R24
    03032 E021      LDI	R18,1
    03033 E004      LDI	R16,4
    03034 940E 3B08 CALL	_LCD_const_disp
(0181) 					LCD_print4num(4,5,config.time1-config.now);
    03036 9020 0847 LDS	R2,config+12
    03038 9030 0848 LDS	R3,config+13
    0303A 9040 0843 LDS	R4,config+8
    0303C 9050 0844 LDS	R5,config+9
    0303E 1842      SUB	R4,R2
    0303F 0853      SBC	R5,R3
    03040 8259      STD	Y+1,R5
    03041 8248      ST	Y,R4
    03042 E025      LDI	R18,5
    03043 E004      LDI	R16,4
    03044 940E 3DCA CALL	_LCD_print4num
(0182) 					LCD_const_disp(2,6,"      ");
    03046 EF85      LDI	R24,0xF5
    03047 E094      LDI	R25,4
    03048 8399      STD	Y+1,R25
    03049 8388      ST	Y,R24
    0304A E026      LDI	R18,6
    0304B E002      LDI	R16,2
    0304C 940E 3B08 CALL	_LCD_const_disp
(0183) 					LCD_const_disp(3,6,"      ");
    0304E EF85      LDI	R24,0xF5
    0304F E094      LDI	R25,4
    03050 8399      STD	Y+1,R25
    03051 8388      ST	Y,R24
    03052 E026      LDI	R18,6
    03053 E003      LDI	R16,3
    03054 940E 3B08 CALL	_LCD_const_disp
(0184) 				}
(0185) 			} 
    03056 C116      RJMP	0x316D
(0186) 			else {
(0187) 			   //检测完成 获得数据 转换数据 存储数据 切换到非检测状态
(0188) 			    windcounter =0 ; //关闭风速传感器计数器
    03057 24AA      CLR	R10
(0189) 				check();
    03058 940E 28E5 CALL	_check
(0190) 				StructToChar(); //转成字符串
    0305A 940E 2A6F CALL	_StructToChar
(0191) 				WriteFileHead();//重写文件头
    0305C 940E 25AE CALL	_WriteFileHead
(0192) 				WriteSDFile();  //写入sd卡
    0305E 940E 262A CALL	_WriteSDFile
(0193) 				//zigbee_send(); //发送
(0194) 				Result.Index++; //索引自增一
    03060 E041      LDI	R20,1
    03061 E050      LDI	R21,0
    03062 E060      LDI	R22,0
    03063 E070      LDI	R23,0
    03064 9040 05D7 LDS	R4,Result+12
    03066 9050 05D8 LDS	R5,Result+13
    03068 9020 05D5 LDS	R2,Result+10
    0306A 9030 05D6 LDS	R3,Result+11
    0306C 0E24      ADD	R2,R20
    0306D 1E35      ADC	R3,R21
    0306E 1E46      ADC	R4,R22
    0306F 1E57      ADC	R5,R23
    03070 9230 05D6 STS	Result+11,R3
    03072 9220 05D5 STS	Result+10,R2
    03074 9250 05D8 STS	Result+13,R5
    03076 9240 05D7 STS	Result+12,R4
(0195) 				is_on=0; //切换到非检测状态
    03078 2400      CLR	R0
    03079 8608      STD	Y+8,R0
(0196) 				next_step_time=config.now+config.checkDeltaTime;//自动翻页时间更新
    0307A 9020 084C LDS	R2,config+17
    0307C 9030 084D LDS	R3,config+18
    0307E 2444      CLR	R4
    0307F FC37      SBRC	R3,7
    03080 9440      COM	R4
    03081 2455      CLR	R5
    03082 FC47      SBRC	R4,7
    03083 9450      COM	R5
    03084 9080 0849 LDS	R8,config+14
    03086 9090 084A LDS	R9,config+15
    03088 9060 0847 LDS	R6,config+12
    0308A 9070 0848 LDS	R7,config+13
    0308C 0C62      ADD	R6,R2
    0308D 1C73      ADC	R7,R3
    0308E 1C84      ADC	R8,R4
    0308F 1C95      ADC	R9,R5
    03090 826B      STD	Y+3,R6
    03091 827C      STD	Y+4,R7
    03092 828D      STD	Y+5,R8
    03093 829E      STD	Y+6,R9
(0197) 				page=0;
    03094 820F      STD	Y+7,R0
(0198) 		   }
(0199) 		}
    03095 C0D7      RJMP	0x316D
(0200) 		else { //is_on == 0 非检测状态 手动翻页/自动翻页
(0201) 		    dateRefresh(0);//不更新时间
    03096 2700      CLR	R16
    03097 D703      RCALL	_dateRefresh
(0202) 			_GUI_datashow(page); 
    03098 810F      LDD	R16,Y+7
    03099 D0DB      RCALL	__GUI_datashow
(0203) 			if(page == 0 ){
    0309A 800F      LDD	R0,Y+7
    0309B 2000      TST	R0
    0309C F4E9      BNE	0x30BA
(0204) 				
(0205) 				    LCD_const_disp(4,1,"完成检测        ");
    0309D EE84      LDI	R24,0xE4
    0309E E094      LDI	R25,4
    0309F 8399      STD	Y+1,R25
    030A0 8388      ST	Y,R24
    030A1 E021      LDI	R18,1
    030A2 E004      LDI	R16,4
    030A3 940E 3B08 CALL	_LCD_const_disp
(0206) 					if(config.autocheck == 1){
    030A5 9180 084B LDS	R24,config+16
    030A7 3081      CPI	R24,1
    030A8 F449      BNE	0x30B2
(0207) 					    LCD_const_disp(4,7,"自动");
    030A9 E186      LDI	R24,0x16
    030AA E095      LDI	R25,5
    030AB 8399      STD	Y+1,R25
    030AC 8388      ST	Y,R24
    030AD E027      LDI	R18,7
    030AE E004      LDI	R16,4
    030AF 940E 3B08 CALL	_LCD_const_disp
(0208) 					}
    030B1 C008      RJMP	0x30BA
(0209) 					else {
(0210) 					    LCD_const_disp(4,7,"手动");
    030B2 E181      LDI	R24,0x11
    030B3 E095      LDI	R25,5
    030B4 8399      STD	Y+1,R25
    030B5 8388      ST	Y,R24
    030B6 E027      LDI	R18,7
    030B7 E004      LDI	R16,4
    030B8 940E 3B08 CALL	_LCD_const_disp
(0211) 					}
(0212) 					
(0213) 				}
(0214) 						//手动翻页 
(0215) 			if(key==up){ //上键 : 页面减 
    030BA 2D8C      MOV	R24,R12
    030BB 318E      CPI	R24,0x1E
    030BC F539      BNE	0x30E4
(0216) 		        if(page>0) page--;
    030BD E080      LDI	R24,0
    030BE 800F      LDD	R0,Y+7
    030BF 1580      CP	R24,R0
    030C0 F418      BCC	0x30C4
    030C1 940A      DEC	R0
    030C2 820F      STD	Y+7,R0
    030C3 C01C      RJMP	0x30E0
(0217) 				else{
(0218) 				page =5;
    030C4 E085      LDI	R24,5
    030C5 838F      STD	Y+7,R24
(0219) 				next_step_time = config.now + config.checkDeltaTime;
    030C6 9020 084C LDS	R2,config+17
    030C8 9030 084D LDS	R3,config+18
    030CA 2444      CLR	R4
    030CB FC37      SBRC	R3,7
    030CC 9440      COM	R4
    030CD 2455      CLR	R5
    030CE FC47      SBRC	R4,7
    030CF 9450      COM	R5
    030D0 9080 0849 LDS	R8,config+14
    030D2 9090 084A LDS	R9,config+15
    030D4 9060 0847 LDS	R6,config+12
    030D6 9070 0848 LDS	R7,config+13
    030D8 0C62      ADD	R6,R2
    030D9 1C73      ADC	R7,R3
    030DA 1C84      ADC	R8,R4
    030DB 1C95      ADC	R9,R5
    030DC 826B      STD	Y+3,R6
    030DD 827C      STD	Y+4,R7
    030DE 828D      STD	Y+5,R8
    030DF 829E      STD	Y+6,R9
(0220) 				}
(0221) 		    	LCD_CLR();
    030E0 940E 3BAE CALL	_LCD_CLR
(0222) 		    	LCD_Init();
    030E2 940E 3B7C CALL	_LCD_Init
(0223) 			}
(0224) 			if(key==down){//下键 ： 页面加
    030E4 2D8C      MOV	R24,R12
    030E5 318D      CPI	R24,0x1D
    030E6 F509      BNE	0x3108
(0225) 		        page++;
    030E7 800F      LDD	R0,Y+7
    030E8 9403      INC	R0
    030E9 820F      STD	Y+7,R0
(0226) 				next_step_time = config.now + config.checkDeltaTime;
    030EA 9020 084C LDS	R2,config+17
    030EC 9030 084D LDS	R3,config+18
    030EE 2444      CLR	R4
    030EF FC37      SBRC	R3,7
    030F0 9440      COM	R4
    030F1 2455      CLR	R5
    030F2 FC47      SBRC	R4,7
    030F3 9450      COM	R5
    030F4 9080 0849 LDS	R8,config+14
    030F6 9090 084A LDS	R9,config+15
    030F8 9060 0847 LDS	R6,config+12
    030FA 9070 0848 LDS	R7,config+13
    030FC 0C62      ADD	R6,R2
    030FD 1C73      ADC	R7,R3
    030FE 1C84      ADC	R8,R4
    030FF 1C95      ADC	R9,R5
    03100 826B      STD	Y+3,R6
    03101 827C      STD	Y+4,R7
    03102 828D      STD	Y+5,R8
    03103 829E      STD	Y+6,R9
(0227) 		  		LCD_CLR();
    03104 940E 3BAE CALL	_LCD_CLR
(0228) 		    	LCD_Init();
    03106 940E 3B7C CALL	_LCD_Init
(0229) 			} 	
(0230) 			//LCD_print2num(4,1,page);
(0231) 			//LCD_print4num(4,3,config.now);
(0232) 			//LCD_print4num(4,6,next_step_time);
(0233) 			if( config.autocheck == 1 ){  //如果开启自动翻页
    03108 9180 084B LDS	R24,config+16
    0310A 3081      CPI	R24,1
    0310B F009      BEQ	0x310D
    0310C C060      RJMP	0x316D
(0234) 			      if(config.now >= next_step_time || page >=6 )	{
    0310D 802B      LDD	R2,Y+3
    0310E 803C      LDD	R3,Y+4
    0310F 804D      LDD	R4,Y+5
    03110 805E      LDD	R5,Y+6
    03111 9080 0849 LDS	R8,config+14
    03113 9090 084A LDS	R9,config+15
    03115 9060 0847 LDS	R6,config+12
    03117 9070 0848 LDS	R7,config+13
    03119 1462      CP	R6,R2
    0311A 0473      CPC	R7,R3
    0311B 0484      CPC	R8,R4
    0311C 0495      CPC	R9,R5
    0311D F420      BCC	0x3122
    0311E 818F      LDD	R24,Y+7
    0311F 3086      CPI	R24,6
    03120 F408      BCC	0x3122
    03121 C04B      RJMP	0x316D
(0235) 				      next_step_time = config.now + config.checkDeltaTime;
    03122 9020 084C LDS	R2,config+17
    03124 9030 084D LDS	R3,config+18
    03126 2444      CLR	R4
    03127 FC37      SBRC	R3,7
    03128 9440      COM	R4
    03129 2455      CLR	R5
    0312A FC47      SBRC	R4,7
    0312B 9450      COM	R5
    0312C 9080 0849 LDS	R8,config+14
    0312E 9090 084A LDS	R9,config+15
    03130 9060 0847 LDS	R6,config+12
    03132 9070 0848 LDS	R7,config+13
    03134 0C62      ADD	R6,R2
    03135 1C73      ADC	R7,R3
    03136 1C84      ADC	R8,R4
    03137 1C95      ADC	R9,R5
    03138 826B      STD	Y+3,R6
    03139 827C      STD	Y+4,R7
    0313A 828D      STD	Y+5,R8
    0313B 829E      STD	Y+6,R9
(0236) 					  page++;
    0313C 800F      LDD	R0,Y+7
    0313D 9403      INC	R0
    0313E 820F      STD	Y+7,R0
(0237) 					  if( page>=6 ){
    0313F 2D80      MOV	R24,R0
    03140 3086      CPI	R24,6
    03141 F140      BCS	0x316A
(0238) 					      //自动翻到最后页，页面清零开启下次检测
(0239) 					      page = 0;
    03142 2400      CLR	R0
    03143 820F      STD	Y+7,R0
(0240) 						  dateRefresh(1); //刷新时间
    03144 E001      LDI	R16,1
    03145 D655      RCALL	_dateRefresh
(0241) 						  is_on =1 ; //开启检测
    03146 2400      CLR	R0
    03147 9403      INC	R0
    03148 8608      STD	Y+8,R0
(0242) 						  config.time1=config.now+config.THRESHOLD_delta_sec; //更新下次检测时间
    03149 9040 0841 LDS	R4,config+6
    0314B 9050 0842 LDS	R5,config+7
    0314D 9020 083F LDS	R2,config+4
    0314F 9030 0840 LDS	R3,config+5
    03151 9080 0849 LDS	R8,config+14
    03153 9090 084A LDS	R9,config+15
    03155 9060 0847 LDS	R6,config+12
    03157 9070 0848 LDS	R7,config+13
    03159 0C62      ADD	R6,R2
    0315A 1C73      ADC	R7,R3
    0315B 1C84      ADC	R8,R4
    0315C 1C95      ADC	R9,R5
    0315D 9270 0844 STS	config+9,R7
    0315F 9260 0843 STS	config+8,R6
    03161 9290 0846 STS	config+11,R9
    03163 9280 0845 STS	config+10,R8
(0243) 						  Result.TempChar[0]=0; //清除上次结果
    03165 2422      CLR	R2
    03166 9220 05F8 STS	Result+45,R2
(0244) 						  Result.WSChar[0]=0;
    03168 9220 0602 STS	Result+55,R2
(0245) 					  }
(0246) 				      LCD_CLR();      
    0316A 940E 3BAE CALL	_LCD_CLR
(0247) 					  key=0;
    0316C 24CC      CLR	R12
(0248) 				  }  
(0249) 			}
(0250) 
(0251) 			
(0252) 
(0253) 			 
(0254) 		} 
(0255) 	    delayms(10); 
    0316D E00A      LDI	R16,0xA
    0316E E010      LDI	R17,0
    0316F 940E 2440 CALL	_delayms
    03171 CE5C      RJMP	0x2FCE
    03172 9629      ADIW	R28,0x9
    03173 940C 4299 JMP	pop_xgsetF0FC
__GUI_datashow:
  page                 --> R20
    03175 940E 42C3 CALL	push_xgsetF00C
    03177 2F40      MOV	R20,R16
    03178 9722      SBIW	R28,2
(0256) 	}//end while
(0257) }//end function
(0258) void _GUI_datashow(char page){
(0259) 	if(page == 0){
    03179 2344      TST	R20
    0317A F539      BNE	0x31A2
(0260)  	//显示日期时间
(0261) 	    LCD_var_disp(1,1,GUI_get_date());
    0317B D205      RCALL	_GUI_get_date
    0317C 8319      STD	Y+1,R17
    0317D 8308      ST	Y,R16
    0317E E021      LDI	R18,1
    0317F E001      LDI	R16,1
    03180 940E 3B35 CALL	_LCD_var_disp
(0262) 	//显示温度
(0263) 	 	LCD_const_disp(2,1,"温度 (℃):      ");
    03182 ED83      LDI	R24,0xD3
    03183 E094      LDI	R25,4
    03184 8399      STD	Y+1,R25
    03185 8388      ST	Y,R24
    03186 E021      LDI	R18,1
    03187 E002      LDI	R16,2
    03188 940E 3B08 CALL	_LCD_const_disp
(0264) 	 	LCD_var_disp(2,6,Result.TempChar);
    0318A EF88      LDI	R24,0xF8
    0318B E095      LDI	R25,5
    0318C 8399      STD	Y+1,R25
    0318D 8388      ST	Y,R24
    0318E E026      LDI	R18,6
    0318F E002      LDI	R16,2
    03190 940E 3B35 CALL	_LCD_var_disp
(0265) 	//显示风速
(0266) 	    LCD_const_disp(3,1,"风速(m/s):      ");
    03192 EC82      LDI	R24,0xC2
    03193 E094      LDI	R25,4
    03194 8399      STD	Y+1,R25
    03195 8388      ST	Y,R24
    03196 E021      LDI	R18,1
    03197 E003      LDI	R16,3
    03198 940E 3B08 CALL	_LCD_const_disp
(0267) 	 	LCD_const_disp(3,6,Result.WSChar);
    0319A E082      LDI	R24,2
    0319B E096      LDI	R25,6
    0319C 8399      STD	Y+1,R25
    0319D 8388      ST	Y,R24
    0319E E026      LDI	R18,6
    0319F E003      LDI	R16,3
    031A0 940E 3B08 CALL	_LCD_const_disp
(0268) 
(0269) 	 } 
(0270) 	 if(page == 1){
    031A2 3041      CPI	R20,1
    031A3 F5B9      BNE	0x31DB
(0271) 	     LCD_var_disp(1,1,GUI_get_date());
    031A4 D1DC      RCALL	_GUI_get_date
    031A5 8319      STD	Y+1,R17
    031A6 8308      ST	Y,R16
    031A7 E021      LDI	R18,1
    031A8 E001      LDI	R16,1
    031A9 940E 3B35 CALL	_LCD_var_disp
(0272) 		 LCD_const_disp(2,1,"风冷指数: ");
    031AB EB87      LDI	R24,0xB7
    031AC E094      LDI	R25,4
    031AD 8399      STD	Y+1,R25
    031AE 8388      ST	Y,R24
    031AF E021      LDI	R18,1
    031B0 E002      LDI	R16,2
    031B1 940E 3B08 CALL	_LCD_const_disp
(0273) 		 LCD_var_disp(2,6,Result.WCIChar);						
    031B3 E08B      LDI	R24,0xB
    031B4 E096      LDI	R25,6
    031B5 8399      STD	Y+1,R25
    031B6 8388      ST	Y,R24
    031B7 E026      LDI	R18,6
    031B8 E002      LDI	R16,2
    031B9 940E 3B35 CALL	_LCD_var_disp
(0274) 		 LCD_const_disp(3,1,"等价温度: ");
    031BB EA8C      LDI	R24,0xAC
    031BC E094      LDI	R25,4
    031BD 8399      STD	Y+1,R25
    031BE 8388      ST	Y,R24
    031BF E021      LDI	R18,1
    031C0 E003      LDI	R16,3
    031C1 940E 3B08 CALL	_LCD_const_disp
(0275) 		 LCD_var_disp(3,6,Result.ECTChar);	 
    031C3 E185      LDI	R24,0x15
    031C4 E096      LDI	R25,6
    031C5 8399      STD	Y+1,R25
    031C6 8388      ST	Y,R24
    031C7 E026      LDI	R18,6
    031C8 E003      LDI	R16,3
    031C9 940E 3B35 CALL	_LCD_var_disp
(0276) 		 LCD_const_disp(4,1,"相当温度: ");
    031CB EA81      LDI	R24,0xA1
    031CC E094      LDI	R25,4
    031CD 8399      STD	Y+1,R25
    031CE 8388      ST	Y,R24
    031CF E021      LDI	R18,1
    031D0 E004      LDI	R16,4
    031D1 940E 3B08 CALL	_LCD_const_disp
(0277) 		 LCD_var_disp(4,6,Result.TeqChar);	
    031D3 E18F      LDI	R24,0x1F
    031D4 E096      LDI	R25,6
    031D5 8399      STD	Y+1,R25
    031D6 8388      ST	Y,R24
    031D7 E026      LDI	R18,6
    031D8 E004      LDI	R16,4
    031D9 940E 3B35 CALL	_LCD_var_disp
(0278) 	 }
(0279) 	 if(page == 2){
    031DB 3042      CPI	R20,2
    031DC F009      BEQ	0x31DE
    031DD C03F      RJMP	0x321D
(0280) 	     LCD_var_disp(1,1,GUI_get_date());
    031DE D1A2      RCALL	_GUI_get_date
    031DF 0158      MOVW	R10,R16
    031E0 82B9      STD	Y+1,R11
    031E1 82A8      ST	Y,R10
    031E2 E021      LDI	R18,1
    031E3 E001      LDI	R16,1
    031E4 940E 3B35 CALL	_LCD_var_disp
(0281) 		 LCD_const_disp(2,1,"冻伤危害性:");
    031E6 E985      LDI	R24,0x95
    031E7 E094      LDI	R25,4
    031E8 8399      STD	Y+1,R25
    031E9 8388      ST	Y,R24
    031EA E021      LDI	R18,1
    031EB E002      LDI	R16,2
    031EC 940E 3B08 CALL	_LCD_const_disp
(0282) 	 if(Result.WeiHai==0){LCD_const_disp(3,1,"  冻伤危害性小");			 }
    031EE 9020 0625 LDS	R2,Result+90
    031F0 2022      TST	R2
    031F1 F449      BNE	0x31FB
    031F2 E886      LDI	R24,0x86
    031F3 E094      LDI	R25,4
    031F4 8399      STD	Y+1,R25
    031F5 8388      ST	Y,R24
    031F6 E021      LDI	R18,1
    031F7 E003      LDI	R16,3
    031F8 940E 3B08 CALL	_LCD_const_disp
    031FA C022      RJMP	0x321D
(0283) 	 else if(Result.WeiHai==1){	LCD_const_disp(3,1,"  冻伤危害性较大");	 }
    031FB 9180 0625 LDS	R24,Result+90
    031FD 3081      CPI	R24,1
    031FE F449      BNE	0x3208
    031FF E785      LDI	R24,0x75
    03200 E094      LDI	R25,4
    03201 8399      STD	Y+1,R25
    03202 8388      ST	Y,R24
    03203 E021      LDI	R18,1
    03204 E003      LDI	R16,3
    03205 940E 3B08 CALL	_LCD_const_disp
    03207 C015      RJMP	0x321D
(0284) 	 else if(Result.WeiHai==2){	LCD_const_disp(3,1,"  冻伤危害性很大");	 }
    03208 9180 0625 LDS	R24,Result+90
    0320A 3082      CPI	R24,2
    0320B F449      BNE	0x3215
    0320C E684      LDI	R24,0x64
    0320D E094      LDI	R25,4
    0320E 8399      STD	Y+1,R25
    0320F 8388      ST	Y,R24
    03210 E021      LDI	R18,1
    03211 E003      LDI	R16,3
    03212 940E 3B08 CALL	_LCD_const_disp
    03214 C008      RJMP	0x321D
(0285) 	 else LCD_const_disp(3,1,"冻伤危害性小。");
    03215 E585      LDI	R24,0x55
    03216 E094      LDI	R25,4
    03217 8399      STD	Y+1,R25
    03218 8388      ST	Y,R24
    03219 E021      LDI	R18,1
    0321A E003      LDI	R16,3
    0321B 940E 3B08 CALL	_LCD_const_disp
(0286) 	 }	  
(0287) 	 if(page==3){
    0321D 3043      CPI	R20,3
    0321E F009      BEQ	0x3220
    0321F C061      RJMP	0x3281
(0288) 	     LCD_const_disp(1,1,labelH);		
    03220 E78D      LDI	R24,0x7D
    03221 E092      LDI	R25,2
    03222 8399      STD	Y+1,R25
    03223 8388      ST	Y,R24
    03224 E021      LDI	R18,1
    03225 E001      LDI	R16,1
    03226 940E 3B08 CALL	_LCD_const_disp
(0289) 	 	 switch( Result.WeiHai ){
    03228 9160 0625 LDS	R22,Result+90
    0322A 2777      CLR	R23
    0322B 3060      CPI	R22,0
    0322C 0767      CPC	R22,R23
    0322D F049      BEQ	0x3237
    0322E 3061      CPI	R22,1
    0322F E0E0      LDI	R30,0
    03230 077E      CPC	R23,R30
    03231 F0F1      BEQ	0x3250
    03232 3062      CPI	R22,2
    03233 E0E0      LDI	R30,0
    03234 077E      CPC	R23,R30
    03235 F199      BEQ	0x3269
    03236 C04A      RJMP	0x3281
(0290) 			case 0 :
(0291) 			LCD_const_disp(2,1,H01);
    03237 EA89      LDI	R24,0xA9
    03238 E092      LDI	R25,2
    03239 8399      STD	Y+1,R25
    0323A 8388      ST	Y,R24
    0323B E021      LDI	R18,1
    0323C E002      LDI	R16,2
    0323D 940E 3B08 CALL	_LCD_const_disp
(0292) 			LCD_const_disp(3,1,H02);
    0323F EB89      LDI	R24,0xB9
    03240 E092      LDI	R25,2
    03241 8399      STD	Y+1,R25
    03242 8388      ST	Y,R24
    03243 E021      LDI	R18,1
    03244 E003      LDI	R16,3
    03245 940E 3B08 CALL	_LCD_const_disp
(0293) 			LCD_const_disp(4,1,H03);
    03247 EC84      LDI	R24,0xC4
    03248 E092      LDI	R25,2
    03249 8399      STD	Y+1,R25
    0324A 8388      ST	Y,R24
    0324B E021      LDI	R18,1
    0324C E004      LDI	R16,4
    0324D 940E 3B08 CALL	_LCD_const_disp
(0294) 			break;
    0324F C031      RJMP	0x3281
(0295) 			case 1 : 
(0296) 			LCD_const_disp(2,1,H11);
    03250 EE80      LDI	R24,0xE0
    03251 E092      LDI	R25,2
    03252 8399      STD	Y+1,R25
    03253 8388      ST	Y,R24
    03254 E021      LDI	R18,1
    03255 E002      LDI	R16,2
    03256 940E 3B08 CALL	_LCD_const_disp
(0297) 			LCD_const_disp(3,1,H12);
    03258 EC84      LDI	R24,0xC4
    03259 E092      LDI	R25,2
    0325A 8399      STD	Y+1,R25
    0325B 8388      ST	Y,R24
    0325C E021      LDI	R18,1
    0325D E003      LDI	R16,3
    0325E 940E 3B08 CALL	_LCD_const_disp
(0298) 			LCD_const_disp(4,1,H13);
    03260 EF89      LDI	R24,0xF9
    03261 E092      LDI	R25,2
    03262 8399      STD	Y+1,R25
    03263 8388      ST	Y,R24
    03264 E021      LDI	R18,1
    03265 E004      LDI	R16,4
    03266 940E 3B08 CALL	_LCD_const_disp
(0299) 			break ;	
    03268 C018      RJMP	0x3281
(0300) 			case 2 :
(0301) 			LCD_const_disp(2,1,H21);
    03269 E28D      LDI	R24,0x2D
    0326A E093      LDI	R25,3
    0326B 8399      STD	Y+1,R25
    0326C 8388      ST	Y,R24
    0326D E021      LDI	R18,1
    0326E E002      LDI	R16,2
    0326F 940E 3B08 CALL	_LCD_const_disp
(0302) 			LCD_const_disp(3,1,H22);
    03271 E38F      LDI	R24,0x3F
    03272 E093      LDI	R25,3
    03273 8399      STD	Y+1,R25
    03274 8388      ST	Y,R24
    03275 E021      LDI	R18,1
    03276 E003      LDI	R16,3
    03277 940E 3B08 CALL	_LCD_const_disp
(0303) 			LCD_const_disp(4,1,H23);
    03279 EC84      LDI	R24,0xC4
    0327A E092      LDI	R25,2
    0327B 8399      STD	Y+1,R25
    0327C 8388      ST	Y,R24
    0327D E021      LDI	R18,1
    0327E E004      LDI	R16,4
    0327F 940E 3B08 CALL	_LCD_const_disp
(0304) 			break;
(0305) 			default : ;
(0306) 		}
(0307) 	 } 
(0308) 	 if(page==4){
    03281 3044      CPI	R20,4
    03282 F009      BEQ	0x3284
    03283 C086      RJMP	0x330A
(0309) 	 		LCD_const_disp(1,1,labelM);		
    03284 E88B      LDI	R24,0x8B
    03285 E092      LDI	R25,2
    03286 8399      STD	Y+1,R25
    03287 8388      ST	Y,R24
    03288 E021      LDI	R18,1
    03289 E001      LDI	R16,1
    0328A 940E 3B08 CALL	_LCD_const_disp
(0310) 	 		switch( Result.WeiHai ){
    0328C 9160 0625 LDS	R22,Result+90
    0328E 2777      CLR	R23
    0328F 3060      CPI	R22,0
    03290 0767      CPC	R22,R23
    03291 F059      BEQ	0x329D
    03292 3061      CPI	R22,1
    03293 E0E0      LDI	R30,0
    03294 077E      CPC	R23,R30
    03295 F409      BNE	0x3297
    03296 C052      RJMP	0x32E9
    03297 3062      CPI	R22,2
    03298 E0E0      LDI	R30,0
    03299 077E      CPC	R23,R30
    0329A F409      BNE	0x329C
    0329B C066      RJMP	0x3302
    0329C C06D      RJMP	0x330A
(0311) 	 			case 0 :
(0312) 				LCD_const_disp(2,1,M01);
    0329D EA89      LDI	R24,0xA9
    0329E E092      LDI	R25,2
    0329F 8399      STD	Y+1,R25
    032A0 8388      ST	Y,R24
    032A1 E021      LDI	R18,1
    032A2 E002      LDI	R16,2
    032A3 940E 3B08 CALL	_LCD_const_disp
(0313) 				LCD_const_disp(3,1,M02);
    032A5 EC84      LDI	R24,0xC4
    032A6 E092      LDI	R25,2
    032A7 8399      STD	Y+1,R25
    032A8 8388      ST	Y,R24
    032A9 E021      LDI	R18,1
    032AA E003      LDI	R16,3
    032AB 940E 3B08 CALL	_LCD_const_disp
(0314) 				if(Result.Temperature < 17.7){
    032AD 9040 05F6 LDS	R4,Result+43
    032AF 9050 05F7 LDS	R5,Result+44
    032B1 9020 05F4 LDS	R2,Result+41
    032B3 9030 05F5 LDS	R3,Result+42
    032B5 EC00      LDI	R16,0xC0
    032B6 E010      LDI	R17,0
    032B7 940E 422C CALL	elpm32
    032B9 933A      ST	-Y,R19
    032BA 932A      ST	-Y,R18
    032BB 931A      ST	-Y,R17
    032BC 930A      ST	-Y,R16
    032BD 0181      MOVW	R16,R2
    032BE 0192      MOVW	R18,R4
    032BF 940E 45CA CALL	fpcmp2
    032C1 F44C      BGE	0x32CB
(0315) 				    LCD_const_disp(4,1,"戴面罩；禁油彩。");
    032C2 E484      LDI	R24,0x44
    032C3 E094      LDI	R25,4
    032C4 8399      STD	Y+1,R25
    032C5 8388      ST	Y,R24
    032C6 E021      LDI	R18,1
    032C7 E004      LDI	R16,4
    032C8 940E 3B08 CALL	_LCD_const_disp
(0316) 				}
    032CA C03F      RJMP	0x330A
(0317) 				else if(Result.Temperature < 12){
    032CB 9040 05F6 LDS	R4,Result+43
    032CD 9050 05F7 LDS	R5,Result+44
    032CF 9020 05F4 LDS	R2,Result+41
    032D1 9030 05F5 LDS	R3,Result+42
    032D3 EB0C      LDI	R16,0xBC
    032D4 E010      LDI	R17,0
    032D5 940E 422C CALL	elpm32
    032D7 933A      ST	-Y,R19
    032D8 932A      ST	-Y,R18
    032D9 931A      ST	-Y,R17
    032DA 930A      ST	-Y,R16
    032DB 0181      MOVW	R16,R2
    032DC 0192      MOVW	R18,R4
    032DD 940E 45CA CALL	fpcmp2
    032DF F554      BGE	0x330A
(0318) 				    LCD_const_disp(4,1,"禁油彩。        \0");
    032E0 E382      LDI	R24,0x32
    032E1 E094      LDI	R25,4
    032E2 8399      STD	Y+1,R25
    032E3 8388      ST	Y,R24
    032E4 E021      LDI	R18,1
    032E5 E004      LDI	R16,4
    032E6 940E 3B08 CALL	_LCD_const_disp
(0319) 				}
(0320) 				break;
    032E8 C021      RJMP	0x330A
(0321) 				case 1 : 
(0322) 			    LCD_const_disp(2,1,M11);
    032E9 EA89      LDI	R24,0xA9
    032EA E092      LDI	R25,2
    032EB 8399      STD	Y+1,R25
    032EC 8388      ST	Y,R24
    032ED E021      LDI	R18,1
    032EE E002      LDI	R16,2
    032EF 940E 3B08 CALL	_LCD_const_disp
(0323) 				LCD_const_disp(3,1,M12);
    032F1 E089      LDI	R24,0x9
    032F2 E093      LDI	R25,3
    032F3 8399      STD	Y+1,R25
    032F4 8388      ST	Y,R24
    032F5 E021      LDI	R18,1
    032F6 E003      LDI	R16,3
    032F7 940E 3B08 CALL	_LCD_const_disp
(0324) 				LCD_const_disp(4,1,M13);
    032F9 E18B      LDI	R24,0x1B
    032FA E093      LDI	R25,3
    032FB 8399      STD	Y+1,R25
    032FC 8388      ST	Y,R24
    032FD E021      LDI	R18,1
    032FE E004      LDI	R16,4
    032FF 940E 3B08 CALL	_LCD_const_disp
(0325) 				break ;
    03301 C008      RJMP	0x330A
(0326) 				case 2 :
(0327) 				LCD_const_disp(2,1,M21);
    03302 E581      LDI	R24,0x51
    03303 E093      LDI	R25,3
    03304 8399      STD	Y+1,R25
    03305 8388      ST	Y,R24
    03306 E021      LDI	R18,1
    03307 E002      LDI	R16,2
    03308 940E 3B08 CALL	_LCD_const_disp
(0328) 				break ;
(0329) 				default :;
(0330) 	 		}
(0331) 	 }
(0332) 	 if(page==5){
    0330A 3045      CPI	R20,5
    0330B F009      BEQ	0x330D
    0330C C071      RJMP	0x337E
(0333) 	     LCD_const_disp(1,1,labelL);		
    0330D E98B      LDI	R24,0x9B
    0330E E092      LDI	R25,2
    0330F 8399      STD	Y+1,R25
    03310 8388      ST	Y,R24
    03311 E021      LDI	R18,1
    03312 E001      LDI	R16,1
    03313 940E 3B08 CALL	_LCD_const_disp
(0334) 	 	 switch( Result.WeiHai ){	
    03315 9140 0625 LDS	R20,Result+90
    03317 2755      CLR	R21
    03318 3040      CPI	R20,0
    03319 0745      CPC	R20,R21
    0331A F059      BEQ	0x3326
    0331B 3041      CPI	R20,1
    0331C E0E0      LDI	R30,0
    0331D 075E      CPC	R21,R30
    0331E F409      BNE	0x3320
    0331F C03D      RJMP	0x335D
    03320 3042      CPI	R20,2
    03321 E0E0      LDI	R30,0
    03322 075E      CPC	R21,R30
    03323 F409      BNE	0x3325
    03324 C051      RJMP	0x3376
    03325 C058      RJMP	0x337E
(0335) 		     case 0 :
(0336) 			 LCD_const_disp(2,1,L01);
    03326 ED86      LDI	R24,0xD6
    03327 E092      LDI	R25,2
    03328 8399      STD	Y+1,R25
    03329 8388      ST	Y,R24
    0332A E021      LDI	R18,1
    0332B E002      LDI	R16,2
    0332C 940E 3B08 CALL	_LCD_const_disp
(0337) 			 if(Result.Temperature < -12) {
    0332E 9040 05F6 LDS	R4,Result+43
    03330 9050 05F7 LDS	R5,Result+44
    03332 9020 05F4 LDS	R2,Result+41
    03334 9030 05F5 LDS	R3,Result+42
    03336 EB08      LDI	R16,0xB8
    03337 E010      LDI	R17,0
    03338 940E 422C CALL	elpm32
    0333A 933A      ST	-Y,R19
    0333B 932A      ST	-Y,R18
    0333C 931A      ST	-Y,R17
    0333D 930A      ST	-Y,R16
    0333E 0181      MOVW	R16,R2
    0333F 0192      MOVW	R18,R4
    03340 940E 45CA CALL	fpcmp2
    03342 F48C      BGE	0x3354
(0338) 			 LCD_const_disp(3,1,L02);
    03343 EE80      LDI	R24,0xE0
    03344 E092      LDI	R25,2
    03345 8399      STD	Y+1,R25
    03346 8388      ST	Y,R24
    03347 E021      LDI	R18,1
    03348 E003      LDI	R16,3
    03349 940E 3B08 CALL	_LCD_const_disp
(0339) 			 LCD_const_disp(4,1,L03);
    0334B EE8A      LDI	R24,0xEA
    0334C E092      LDI	R25,2
    0334D 8399      STD	Y+1,R25
    0334E 8388      ST	Y,R24
    0334F E021      LDI	R18,1
    03350 E004      LDI	R16,4
    03351 940E 3B08 CALL	_LCD_const_disp
(0340) 			 } 
    03353 C02A      RJMP	0x337E
(0341) 			 else {
(0342) 			 LCD_const_disp(3,1,L03);
    03354 EE8A      LDI	R24,0xEA
    03355 E092      LDI	R25,2
    03356 8399      STD	Y+1,R25
    03357 8388      ST	Y,R24
    03358 E021      LDI	R18,1
    03359 E003      LDI	R16,3
    0335A 940E 3B08 CALL	_LCD_const_disp
(0343) 			 }
(0344) 			 break;
    0335C C021      RJMP	0x337E
(0345) 			 case 1: 
(0346) 			 LCD_const_disp(2,1,L11);
    0335D E28D      LDI	R24,0x2D
    0335E E093      LDI	R25,3
    0335F 8399      STD	Y+1,R25
    03360 8388      ST	Y,R24
    03361 E021      LDI	R18,1
    03362 E002      LDI	R16,2
    03363 940E 3B08 CALL	_LCD_const_disp
(0347) 			 LCD_const_disp(3,1,L12);
    03365 E38F      LDI	R24,0x3F
    03366 E093      LDI	R25,3
    03367 8399      STD	Y+1,R25
    03368 8388      ST	Y,R24
    03369 E021      LDI	R18,1
    0336A E003      LDI	R16,3
    0336B 940E 3B08 CALL	_LCD_const_disp
(0348) 			 LCD_const_disp(3,1,L13);
    0336D EC84      LDI	R24,0xC4
    0336E E092      LDI	R25,2
    0336F 8399      STD	Y+1,R25
    03370 8388      ST	Y,R24
    03371 E021      LDI	R18,1
    03372 E003      LDI	R16,3
    03373 940E 3B08 CALL	_LCD_const_disp
(0349) 			 break ;
    03375 C008      RJMP	0x337E
(0350) 			 case 2 :
(0351) 			 LCD_const_disp(2,1,L21);
    03376 E581      LDI	R24,0x51
    03377 E093      LDI	R25,3
    03378 8399      STD	Y+1,R25
    03379 8388      ST	Y,R24
    0337A E021      LDI	R18,1
    0337B E002      LDI	R16,2
    0337C 940E 3B08 CALL	_LCD_const_disp
(0352) 			 break;
(0353) 			 default : ;
(0354) 		} //end switch
(0355) 	}  //end if
    0337E 9622      ADIW	R28,2
    0337F 940C 42CA JMP	pop_xgsetF00C
(0356) }
(0357) char * GUI_get_date(void) {  
(0358)   //格式:12月11日19:00:00
(0359)     GUI_date[0]=Result.Date[4]; 
_GUI_get_date:
    03381 9020 05E5 LDS	R2,Result+26
    03383 9220 0360 STS	GUI_date,R2
(0360)     GUI_date[1]=Result.Date[5];
    03385 9020 05E6 LDS	R2,Result+27
    03387 9220 0361 STS	GUI_date+1,R2
(0361)     GUI_date[4]=Result.Date[6];
    03389 9020 05E7 LDS	R2,Result+28
    0338B 9220 0364 STS	GUI_date+4,R2
(0362)     GUI_date[5]=Result.Date[7];
    0338D 9020 05E8 LDS	R2,Result+29
    0338F 9220 0365 STS	GUI_date+5,R2
(0363)     GUI_date[8]=Result.Time[0];
    03391 9020 05EA LDS	R2,Result+31
    03393 9220 0368 STS	GUI_date+8,R2
(0364)     GUI_date[9]=Result.Time[1];
    03395 9020 05EB LDS	R2,Result+32
    03397 9220 0369 STS	GUI_date+9,R2
(0365)     GUI_date[11]=Result.Time[4];
    03399 9020 05EE LDS	R2,Result+35
    0339B 9220 036B STS	GUI_date+11,R2
(0366)     GUI_date[12]=Result.Time[5];
    0339D 9020 05EF LDS	R2,Result+36
    0339F 9220 036C STS	GUI_date+12,R2
(0367)     GUI_date[14]=Result.Time[8];
    033A1 9020 05F2 LDS	R2,Result+39
    033A3 9220 036E STS	GUI_date+14,R2
(0368)     GUI_date[15]=Result.Time[9];
    033A5 9020 05F3 LDS	R2,Result+40
    033A7 9220 036F STS	GUI_date+15,R2
(0369)     GUI_date[16]='\0';
    033A9 2422      CLR	R2
    033AA 9220 0370 STS	GUI_date+16,R2
(0370)     return GUI_date;
    033AC E600      LDI	R16,0x60
    033AD E013      LDI	R17,3
    033AE 9508      RET
_GUI_set_time:
  GUI_down             --> Y,+5
  GUI_up               --> Y,+2
  pT                   --> R14
  ary                  --> R10
  p                    --> Y,+10
  i                    --> R12
  keyc                 --> R20
  pD                   --> Y,+8
    033AF 940E 42A4 CALL	push_xgsetF0FC
    033B1 972B      SBIW	R28,0xB
(0371) }
(0372) //设置时间 菜单 
(0373) void GUI_set_time(void){
(0374)     unsigned char p=2;
    033B2 E082      LDI	R24,2
    033B3 878A      STD	Y+10,R24
(0375) 	char GUI_up[]= "↑";
    033B4 E781      LDI	R24,0x71
    033B5 E093      LDI	R25,3
    033B6 01FE      MOVW	R30,R28
    033B7 9632      ADIW	R30,2
    033B8 E003      LDI	R16,3
    033B9 E010      LDI	R17,0
    033BA 93FA      ST	-Y,R31
    033BB 93EA      ST	-Y,R30
    033BC 939A      ST	-Y,R25
    033BD 938A      ST	-Y,R24
    033BE 940E 434B CALL	asgnblk
(0376) 	char GUI_down[]= "↓";
    033C0 E784      LDI	R24,0x74
    033C1 E093      LDI	R25,3
    033C2 01FE      MOVW	R30,R28
    033C3 9635      ADIW	R30,5
    033C4 E003      LDI	R16,3
    033C5 E010      LDI	R17,0
    033C6 93FA      ST	-Y,R31
    033C7 93EA      ST	-Y,R30
    033C8 939A      ST	-Y,R25
    033C9 938A      ST	-Y,R24
    033CA 940E 434B CALL	asgnblk
(0377) 	char *pD=NULL,*pT=NULL;
    033CC 2400      CLR	R0
    033CD 2411      CLR	R1
    033CE 8619      STD	Y+9,R1
    033CF 8608      STD	Y+8,R0
(0378) 	char *ary=GUI_up;
    033D0 01CE      MOVW	R24,R28
    033D1 9602      ADIW	R24,2
    033D2 015C      MOVW	R10,R24
(0379) 	unsigned char i=0,keyc=NO_KEY;
    033D3 24CC      CLR	R12
    033D4 2744      CLR	R20
(0380) 	LCD_CLR(); //清屏
    033D5 940E 3BAE CALL	_LCD_CLR
(0381) 	pD="2012年12月31日\0";
    033D7 E282      LDI	R24,0x22
    033D8 E094      LDI	R25,4
    033D9 8799      STD	Y+9,R25
    033DA 8788      STD	Y+8,R24
(0382) 	pT=Result.Time;
    033DB EE8A      LDI	R24,0xEA
    033DC E095      LDI	R25,5
    033DD 017C      MOVW	R14,R24
(0383) 	LCD_const_disp(1,1,"时间设置:       ");
    033DE E181      LDI	R24,0x11
    033DF E094      LDI	R25,4
    033E0 8399      STD	Y+1,R25
    033E1 8388      ST	Y,R24
    033E2 E021      LDI	R18,1
    033E3 E001      LDI	R16,1
    033E4 940E 3B08 CALL	_LCD_const_disp
(0384) 	LCD_const_disp(4,7,"保存");
    033E6 E08C      LDI	R24,0xC
    033E7 E094      LDI	R25,4
    033E8 8399      STD	Y+1,R25
    033E9 8388      ST	Y,R24
    033EA E027      LDI	R18,7
    033EB E004      LDI	R16,4
    033EC 940E 3B08 CALL	_LCD_const_disp
(0385) 	LCD_var_disp(3,p,ary);
    033EE 82B9      STD	Y+1,R11
    033EF 82A8      ST	Y,R10
    033F0 852A      LDD	R18,Y+10
    033F1 E003      LDI	R16,3
    033F2 940E 3B35 CALL	_LCD_var_disp
(0386) 	LCD_var_disp(2,1,pD);
    033F4 8408      LDD	R0,Y+8
    033F5 8419      LDD	R1,Y+9
    033F6 8219      STD	Y+1,R1
    033F7 8208      ST	Y,R0
    033F8 E021      LDI	R18,1
    033F9 E002      LDI	R16,2
    033FA 940E 3B35 CALL	_LCD_var_disp
(0387) 	LCD_var_disp(4,1,pT);
    033FC 82F9      STD	Y+1,R15
    033FD 82E8      ST	Y,R14
    033FE E021      LDI	R18,1
    033FF E004      LDI	R16,4
    03400 940E 3B35 CALL	_LCD_var_disp
(0388) 	delayms(250);
    03402 EF0A      LDI	R16,0xFA
    03403 E010      LDI	R17,0
    03404 940E 2440 CALL	_delayms
    03406 C1E2      RJMP	0x35E9
(0389) 	while(1){
(0390) 	    keyc=kbscan();
    03407 940E 40F2 CALL	_kbscan
    03409 2F40      MOV	R20,R16
(0391) 		pD[2]=Result.Date[2];
    0340A 9020 05E3 LDS	R2,Result+24
    0340C 85E8      LDD	R30,Y+8
    0340D 85F9      LDD	R31,Y+9
    0340E 8222      STD	Z+2,R2
(0392) 		pD[3]=Result.Date[3];
    0340F 9020 05E4 LDS	R2,Result+25
    03411 8223      STD	Z+3,R2
(0393) 		pD[6]=Result.Date[4];
    03412 9020 05E5 LDS	R2,Result+26
    03414 8226      STD	Z+6,R2
(0394) 		pD[7]=Result.Date[5];
    03415 9020 05E6 LDS	R2,Result+27
    03417 8227      STD	Z+7,R2
(0395) 		pD[10]=Result.Date[6];
    03418 9020 05E7 LDS	R2,Result+28
    0341A 8622      STD	Z+10,R2
(0396) 		pD[11]=Result.Date[7];  
    0341B 9020 05E8 LDS	R2,Result+29
    0341D 8623      STD	Z+11,R2
(0397) 
(0398) 		switch(i){
    0341E 2D6C      MOV	R22,R12
    0341F 2777      CLR	R23
    03420 3060      CPI	R22,0
    03421 0767      CPC	R22,R23
    03422 F0D1      BEQ	0x343D
    03423 3061      CPI	R22,1
    03424 E0E0      LDI	R30,0
    03425 077E      CPC	R23,R30
    03426 F409      BNE	0x3428
    03427 C04A      RJMP	0x3472
    03428 3062      CPI	R22,2
    03429 E0E0      LDI	R30,0
    0342A 077E      CPC	R23,R30
    0342B F409      BNE	0x342D
    0342C C07C      RJMP	0x34A9
    0342D 3063      CPI	R22,3
    0342E E0E0      LDI	R30,0
    0342F 077E      CPC	R23,R30
    03430 F409      BNE	0x3432
    03431 C0BE      RJMP	0x34F0
    03432 3064      CPI	R22,4
    03433 E0E0      LDI	R30,0
    03434 077E      CPC	R23,R30
    03435 F409      BNE	0x3437
    03436 C0F1      RJMP	0x3528
    03437 3065      CPI	R22,5
    03438 E0E0      LDI	R30,0
    03439 077E      CPC	R23,R30
    0343A F409      BNE	0x343C
    0343B C123      RJMP	0x355F
    0343C C15C      RJMP	0x3599
(0399)             case 0: p=2;ary=GUI_up;  //年
    0343D E082      LDI	R24,2
    0343E 878A      STD	Y+10,R24
    0343F 01CE      MOVW	R24,R28
    03440 9602      ADIW	R24,2
    03441 015C      MOVW	R10,R24
(0400) 		 	  	 if(keyc==up){
    03442 314E      CPI	R20,0x1E
    03443 F491      BNE	0x3456
(0401) 				     if(time_buf[1]<0x99){ 
    03444 9180 056E LDS	R24,time_buf+1
    03446 3989      CPI	R24,0x99
    03447 F008      BCS	0x3449
    03448 C150      RJMP	0x3599
(0402) 					     time_buf[1]++;
    03449 5F8F      SUBI	R24,0xFF
    0344A 9380 056E STS	time_buf+1,R24
(0403) 						 if((time_buf[1]&0x0f)==0x0a) 
    0344C 708F      ANDI	R24,0xF
    0344D 308A      CPI	R24,0xA
    0344E F009      BEQ	0x3450
    0344F C149      RJMP	0x3599
(0404) 						     time_buf[1]=time_buf[1]+6;
    03450 9180 056E LDS	R24,time_buf+1
    03452 5F8A      SUBI	R24,0xFA
    03453 9380 056E STS	time_buf+1,R24
(0405) 					 }
(0406) 												     
(0407) 				}				  
    03455 C143      RJMP	0x3599
(0408)  					        
(0409) 			    else if(keyc==down){ 
    03456 314D      CPI	R20,0x1D
    03457 F4A1      BNE	0x346C
(0410) 				    if(time_buf[1]>0x00){
    03458 E080      LDI	R24,0
    03459 9020 056E LDS	R2,time_buf+1
    0345B 1582      CP	R24,R2
    0345C F008      BCS	0x345E
    0345D C13B      RJMP	0x3599
(0411) 				        time_buf[1]--;
    0345E 2D82      MOV	R24,R2
    0345F 5081      SUBI	R24,1
    03460 9380 056E STS	time_buf+1,R24
(0412) 						if((time_buf[1]&0x0f)==0x0f) 
    03462 708F      ANDI	R24,0xF
    03463 308F      CPI	R24,0xF
    03464 F009      BEQ	0x3466
    03465 C133      RJMP	0x3599
(0413) 						    time_buf[1]=time_buf[1]-6;
    03466 9180 056E LDS	R24,time_buf+1
    03468 5086      SUBI	R24,6
    03469 9380 056E STS	time_buf+1,R24
(0414) 		 	  	 		 }
(0415) 												   
(0416) 					}			   		
    0346B C12D      RJMP	0x3599
(0417) 				else if(keyc==left) {i=1;}
    0346C 314B      CPI	R20,0x1B
    0346D F009      BEQ	0x346F
    0346E C12A      RJMP	0x3599
    0346F 24CC      CLR	R12
    03470 94C3      INC	R12
(0418) 				break;
    03471 C127      RJMP	0x3599
(0419) 		 case 1:p=4;ary=GUI_up;  //月
    03472 E084      LDI	R24,4
    03473 878A      STD	Y+10,R24
    03474 01CE      MOVW	R24,R28
    03475 9602      ADIW	R24,2
    03476 015C      MOVW	R10,R24
(0420) 		  	  	if(keyc==up){
    03477 314E      CPI	R20,0x1E
    03478 F499      BNE	0x348C
(0421) 				    if(time_buf[2]<0x12){  
    03479 9180 056F LDS	R24,time_buf+2
    0347B 3182      CPI	R24,0x12
    0347C F460      BCC	0x3489
(0422) 					    time_buf[2]++;	
    0347D 5F8F      SUBI	R24,0xFF
    0347E 9380 056F STS	time_buf+2,R24
(0423) 						if((time_buf[2]&0x0f)==0x0a) time_buf[2]+=6;
    03480 708F      ANDI	R24,0xF
    03481 308A      CPI	R24,0xA
    03482 F449      BNE	0x348C
    03483 9180 056F LDS	R24,time_buf+2
    03485 5F8A      SUBI	R24,0xFA
    03486 9380 056F STS	time_buf+2,R24
(0424) 					}
    03488 C003      RJMP	0x348C
(0425) 					else 
(0426) 					    time_buf[2]=0x01;
    03489 E081      LDI	R24,1
    0348A 9380 056F STS	time_buf+2,R24
(0427) 				}						 
(0428) 				if(keyc==down){ 
    0348C 314D      CPI	R20,0x1D
    0348D F4A9      BNE	0x34A3
(0429) 				    if(time_buf[2]>0x01){  
    0348E E081      LDI	R24,1
    0348F 9020 056F LDS	R2,time_buf+2
    03491 1582      CP	R24,R2
    03492 F468      BCC	0x34A0
(0430) 					    time_buf[2]--;	
    03493 2D82      MOV	R24,R2
    03494 5081      SUBI	R24,1
    03495 9380 056F STS	time_buf+2,R24
(0431) 						if((time_buf[2]&0x0f)==0x0f) 
    03497 708F      ANDI	R24,0xF
    03498 308F      CPI	R24,0xF
    03499 F449      BNE	0x34A3
(0432) 						    time_buf[2]-=6;
    0349A 9180 056F LDS	R24,time_buf+2
    0349C 5086      SUBI	R24,6
    0349D 9380 056F STS	time_buf+2,R24
(0433) 			  		}
    0349F C003      RJMP	0x34A3
(0434) 				    else 
(0435) 					    time_buf[2]=0x12;						
    034A0 E182      LDI	R24,0x12
    034A1 9380 056F STS	time_buf+2,R24
(0436) 				}						 							
(0437)  								
(0438) 				if(keyc==left){
    034A3 314B      CPI	R20,0x1B
    034A4 F009      BEQ	0x34A6
    034A5 C0F3      RJMP	0x3599
(0439) 				    i=2;   
    034A6 E082      LDI	R24,2
    034A7 2EC8      MOV	R12,R24
(0440) 				}  
(0441) 				break;
    034A8 C0F0      RJMP	0x3599
(0442) 	 	 case 2: p=6;ary=GUI_up;
    034A9 E086      LDI	R24,6
    034AA 878A      STD	Y+10,R24
    034AB 01CE      MOVW	R24,R28
    034AC 9602      ADIW	R24,2
    034AD 015C      MOVW	R10,R24
(0443) 		 	  	 if(keyc==up){ 
    034AE 314E      CPI	R20,0x1E
    034AF F519      BNE	0x34D3
(0444) 				     if(time_buf[3]<0x31){ 
    034B0 9180 0570 LDS	R24,time_buf+3
    034B2 3381      CPI	R24,0x31
    034B3 F5B0      BCC	0x34EA
(0445) 				         time_buf[3]++;
    034B4 5F8F      SUBI	R24,0xFF
    034B5 9380 0570 STS	time_buf+3,R24
(0446) 						 if ((time_buf[3]&0x0f)==0x0a) time_buf[3]=time_buf[3]+6;
    034B7 708F      ANDI	R24,0xF
    034B8 308A      CPI	R24,0xA
    034B9 F429      BNE	0x34BF
    034BA 9180 0570 LDS	R24,time_buf+3
    034BC 5F8A      SUBI	R24,0xFA
    034BD 9380 0570 STS	time_buf+3,R24
(0447) 						 if(  //2 4 6 9 11 月最大30天
(0448) 						  ( ((time_buf[2]==0x02) || (time_buf[2]==0x04)|| (time_buf[2]==0x06)||
    034BF 9180 056F LDS	R24,time_buf+2
    034C1 3082      CPI	R24,2
    034C2 F041      BEQ	0x34CB
    034C3 3084      CPI	R24,4
    034C4 F031      BEQ	0x34CB
    034C5 3086      CPI	R24,6
    034C6 F021      BEQ	0x34CB
    034C7 3089      CPI	R24,0x9
    034C8 F011      BEQ	0x34CB
    034C9 3181      CPI	R24,0x11
    034CA F4F9      BNE	0x34EA
    034CB 9180 0570 LDS	R24,time_buf+3
    034CD 3381      CPI	R24,0x31
    034CE F4D9      BNE	0x34EA
(0449) 						  (time_buf[2]==0x09)||(time_buf[2]==0x11))&&(time_buf[3]==0x31))){
(0450) 						      time_buf[3]=0x30;
    034CF E380      LDI	R24,0x30
    034D0 9380 0570 STS	time_buf+3,R24
(0451) 						}
(0452) 				     }
(0453)  									  
(0454)  				 }
    034D2 C017      RJMP	0x34EA
(0455) 			     else if(keyc==down){ 
    034D3 314D      CPI	R20,0x1D
    034D4 F4A9      BNE	0x34EA
(0456) 				      if(time_buf[3]>0x01){  
    034D5 E081      LDI	R24,1
    034D6 9020 0570 LDS	R2,time_buf+3
    034D8 1582      CP	R24,R2
    034D9 F468      BCC	0x34E7
(0457) 					     time_buf[3]--;
    034DA 2D82      MOV	R24,R2
    034DB 5081      SUBI	R24,1
    034DC 9380 0570 STS	time_buf+3,R24
(0458) 				 	  	 if((time_buf[3]&0x0f)==0x0f) time_buf[3]=time_buf[3]-6;
    034DE 708F      ANDI	R24,0xF
    034DF 308F      CPI	R24,0xF
    034E0 F449      BNE	0x34EA
    034E1 9180 0570 LDS	R24,time_buf+3
    034E3 5086      SUBI	R24,6
    034E4 9380 0570 STS	time_buf+3,R24
(0459) 		 	  	 	 }
    034E6 C003      RJMP	0x34EA
(0460) 					 else time_buf[3]=0x31;						
    034E7 E381      LDI	R24,0x31
    034E8 9380 0570 STS	time_buf+3,R24
(0461) 											   
(0462) 				}
(0463) 				if(keyc==left) {i=3;  }						 			   		
    034EA 314B      CPI	R20,0x1B
    034EB F009      BEQ	0x34ED
    034EC C0AC      RJMP	0x3599
    034ED E083      LDI	R24,3
    034EE 2EC8      MOV	R12,R24
(0464) 				break;
    034EF C0A9      RJMP	0x3599
(0465) 		case 3:p=1;ary=GUI_down;
    034F0 2400      CLR	R0
    034F1 9403      INC	R0
    034F2 860A      STD	Y+10,R0
    034F3 01CE      MOVW	R24,R28
    034F4 9605      ADIW	R24,5
    034F5 015C      MOVW	R10,R24
(0466)  	  	if(keyc==up){ if(time_buf[4]<0x23){  time_buf[4]++;	
    034F6 314E      CPI	R20,0x1E
    034F7 F499      BNE	0x350B
    034F8 9180 0571 LDS	R24,time_buf+4
    034FA 3283      CPI	R24,0x23
    034FB F460      BCC	0x3508
    034FC 5F8F      SUBI	R24,0xFF
    034FD 9380 0571 STS	time_buf+4,R24
(0467) 													if((time_buf[4]&0x0f)==0x0a) time_buf[4]+=6;
    034FF 708F      ANDI	R24,0xF
    03500 308A      CPI	R24,0xA
    03501 F449      BNE	0x350B
    03502 9180 0571 LDS	R24,time_buf+4
    03504 5F8A      SUBI	R24,0xFA
    03505 9380 0571 STS	time_buf+4,R24
(0468) 													 
(0469) 													
(0470) 												 }
    03507 C003      RJMP	0x350B
(0471) 							else time_buf[4]=0x00;
    03508 2422      CLR	R2
    03509 9220 0571 STS	time_buf+4,R2
(0472) 						  }						 
(0473) 				if(keyc==down){ if(time_buf[4]>0x00){  time_buf[4]--;	
    0350B 314D      CPI	R20,0x1D
    0350C F4A9      BNE	0x3522
    0350D E080      LDI	R24,0
    0350E 9020 0571 LDS	R2,time_buf+4
    03510 1582      CP	R24,R2
    03511 F468      BCC	0x351F
    03512 2D82      MOV	R24,R2
    03513 5081      SUBI	R24,1
    03514 9380 0571 STS	time_buf+4,R24
(0474) 													if((time_buf[4]&0x0f)==0x0f) time_buf[4]-=6;
    03516 708F      ANDI	R24,0xF
    03517 308F      CPI	R24,0xF
    03518 F449      BNE	0x3522
    03519 9180 0571 LDS	R24,time_buf+4
    0351B 5086      SUBI	R24,6
    0351C 9380 0571 STS	time_buf+4,R24
(0475) 													
(0476) 												 }
    0351E C003      RJMP	0x3522
(0477) 							 else time_buf[4]=0x23;						
    0351F E283      LDI	R24,0x23
    03520 9380 0571 STS	time_buf+4,R24
(0478) 						  }	
(0479) 		if(keyc==left) {i=4;    } 
    03522 314B      CPI	R20,0x1B
    03523 F009      BEQ	0x3525
    03524 C074      RJMP	0x3599
    03525 E084      LDI	R24,4
    03526 2EC8      MOV	R12,R24
(0480) 		break;						  					 			
    03527 C071      RJMP	0x3599
(0481)  case 4:p=3;ary=GUI_down;
    03528 E083      LDI	R24,3
    03529 878A      STD	Y+10,R24
    0352A 01CE      MOVW	R24,R28
    0352B 9605      ADIW	R24,5
    0352C 015C      MOVW	R10,R24
(0482)  	  	if(keyc==up){ if(time_buf[5]<0x59){  time_buf[5]++;	
    0352D 314E      CPI	R20,0x1E
    0352E F499      BNE	0x3542
    0352F 9180 0572 LDS	R24,time_buf+5
    03531 3589      CPI	R24,0x59
    03532 F460      BCC	0x353F
    03533 5F8F      SUBI	R24,0xFF
    03534 9380 0572 STS	time_buf+5,R24
(0483) 											 if((time_buf[5]&0x0f)==0x0a) time_buf[5]+=6;
    03536 708F      ANDI	R24,0xF
    03537 308A      CPI	R24,0xA
    03538 F449      BNE	0x3542
    03539 9180 0572 LDS	R24,time_buf+5
    0353B 5F8A      SUBI	R24,0xFA
    0353C 9380 0572 STS	time_buf+5,R24
(0484) 										  }
    0353E C003      RJMP	0x3542
(0485) 					  else time_buf[5]=0x00;
    0353F 2422      CLR	R2
    03540 9220 0572 STS	time_buf+5,R2
(0486) 					}						 
(0487) 		if(keyc==down){ if(time_buf[5]>0x00){  time_buf[5]--;	
    03542 314D      CPI	R20,0x1D
    03543 F4A9      BNE	0x3559
    03544 E080      LDI	R24,0
    03545 9020 0572 LDS	R2,time_buf+5
    03547 1582      CP	R24,R2
    03548 F468      BCC	0x3556
    03549 2D82      MOV	R24,R2
    0354A 5081      SUBI	R24,1
    0354B 9380 0572 STS	time_buf+5,R24
(0488) 												if((time_buf[5]&0x0f)==0x0f) time_buf[5]-=6;
    0354D 708F      ANDI	R24,0xF
    0354E 308F      CPI	R24,0xF
    0354F F449      BNE	0x3559
    03550 9180 0572 LDS	R24,time_buf+5
    03552 5086      SUBI	R24,6
    03553 9380 0572 STS	time_buf+5,R24
(0489) 											}
    03555 C003      RJMP	0x3559
(0490) 						else time_buf[5]=0x59;						
    03556 E589      LDI	R24,0x59
    03557 9380 0572 STS	time_buf+5,R24
(0491) 					  }
(0492) 		if(keyc==left ) {i=5;    } 		  						 								  			
    03559 314B      CPI	R20,0x1B
    0355A F009      BEQ	0x355C
    0355B C03D      RJMP	0x3599
    0355C E085      LDI	R24,5
    0355D 2EC8      MOV	R12,R24
(0493) 		break;			   
    0355E C03A      RJMP	0x3599
(0494)  case 5:p=5;ary=GUI_down;
    0355F E085      LDI	R24,5
    03560 878A      STD	Y+10,R24
    03561 01CE      MOVW	R24,R28
    03562 9605      ADIW	R24,5
    03563 015C      MOVW	R10,R24
(0495)  	  	if(keyc==up){ if(time_buf[6]<0x59){  time_buf[6]++;	
    03564 314E      CPI	R20,0x1E
    03565 F499      BNE	0x3579
    03566 9180 0573 LDS	R24,time_buf+6
    03568 3589      CPI	R24,0x59
    03569 F460      BCC	0x3576
    0356A 5F8F      SUBI	R24,0xFF
    0356B 9380 0573 STS	time_buf+6,R24
(0496) 											 if((time_buf[6]&0x0f)==0x0a) time_buf[6]+=6;
    0356D 708F      ANDI	R24,0xF
    0356E 308A      CPI	R24,0xA
    0356F F449      BNE	0x3579
    03570 9180 0573 LDS	R24,time_buf+6
    03572 5F8A      SUBI	R24,0xFA
    03573 9380 0573 STS	time_buf+6,R24
(0497) 										 }
    03575 C003      RJMP	0x3579
(0498) 					  else time_buf[6]=0x00;
    03576 2422      CLR	R2
    03577 9220 0573 STS	time_buf+6,R2
(0499) 					}						 
(0500) 		if(keyc==down){ if(time_buf[6]>0x00){  time_buf[6]--;	
    03579 314D      CPI	R20,0x1D
    0357A F4A9      BNE	0x3590
    0357B E080      LDI	R24,0
    0357C 9020 0573 LDS	R2,time_buf+6
    0357E 1582      CP	R24,R2
    0357F F468      BCC	0x358D
    03580 2D82      MOV	R24,R2
    03581 5081      SUBI	R24,1
    03582 9380 0573 STS	time_buf+6,R24
(0501) 						if((time_buf[6]&0x0f)==0x0f) time_buf[6]-=6;
    03584 708F      ANDI	R24,0xF
    03585 308F      CPI	R24,0xF
    03586 F449      BNE	0x3590
    03587 9180 0573 LDS	R24,time_buf+6
    03589 5086      SUBI	R24,6
    0358A 9380 0573 STS	time_buf+6,R24
(0502) 					  }
    0358C C003      RJMP	0x3590
(0503) 		else time_buf[6]=0x59;		}				
    0358D E589      LDI	R24,0x59
    0358E 9380 0573 STS	time_buf+6,R24
(0504) 		if(keyc==left) {i=6;p=1;ary=NULL;}  
    03590 314B      CPI	R20,0x1B
    03591 F439      BNE	0x3599
    03592 E086      LDI	R24,6
    03593 2EC8      MOV	R12,R24
    03594 2400      CLR	R0
    03595 9403      INC	R0
    03596 860A      STD	Y+10,R0
    03597 24AA      CLR	R10
    03598 24BB      CLR	R11
(0505) 		break;           
(0506) 							 
(0507) 		 }//endcase
(0508)  		 dateRefresh(88); //set clock mode
    03599 E508      LDI	R16,0x58
    0359A D200      RCALL	_dateRefresh
(0509) 		 
(0510) 		 LCD_const_disp(3,1,"                "); //清空箭头 
    0359B EF8B      LDI	R24,0xFB
    0359C E093      LDI	R25,3
    0359D 8399      STD	Y+1,R25
    0359E 8388      ST	Y,R24
    0359F E021      LDI	R18,1
    035A0 E003      LDI	R16,3
    035A1 940E 3B08 CALL	_LCD_const_disp
(0511)  		 LCD_var_disp(3,p,ary); //显示箭头 
    035A3 82B9      STD	Y+1,R11
    035A4 82A8      ST	Y,R10
    035A5 852A      LDD	R18,Y+10
    035A6 E003      LDI	R16,3
    035A7 940E 3B35 CALL	_LCD_var_disp
(0512)  		 LCD_var_disp(2,1,pD);  //显示日期
    035A9 8408      LDD	R0,Y+8
    035AA 8419      LDD	R1,Y+9
    035AB 8219      STD	Y+1,R1
    035AC 8208      ST	Y,R0
    035AD E021      LDI	R18,1
    035AE E002      LDI	R16,2
    035AF 940E 3B35 CALL	_LCD_var_disp
(0513)  		 LCD_var_disp(4,1,pT);  //显示时间
    035B1 82F9      STD	Y+1,R15
    035B2 82E8      ST	Y,R14
    035B3 E021      LDI	R18,1
    035B4 E004      LDI	R16,4
    035B5 940E 3B35 CALL	_LCD_var_disp
(0514)  if(keyc==right) {		  
    035B7 3147      CPI	R20,0x17
    035B8 F479      BNE	0x35C8
(0515)  		  LCD_const_disp(3,1,"        放弃修改"); 
    035B9 EE8A      LDI	R24,0xEA
    035BA E093      LDI	R25,3
    035BB 8399      STD	Y+1,R25
    035BC 8388      ST	Y,R24
    035BD E021      LDI	R18,1
    035BE E003      LDI	R16,3
    035BF 940E 3B08 CALL	_LCD_const_disp
(0516) 		  delayms(500);
    035C1 EF04      LDI	R16,0xF4
    035C2 E011      LDI	R17,1
    035C3 940E 2440 CALL	_delayms
(0517) 		  LCD_CLR(); //清屏
    035C5 940E 3BAE CALL	_LCD_CLR
(0518) 		  return ;} 
    035C7 C022      RJMP	0x35EA
(0519)  keyc=NO_KEY;
    035C8 2744      CLR	R20
(0520)  if(i==6){    //各值改变完成后 显示已保存 清屏 返回
    035C9 2D8C      MOV	R24,R12
    035CA 3086      CPI	R24,6
    035CB F4C9      BNE	0x35E5
(0521) 		  ds1302_write_time(); 
    035CC 940E 40A5 CALL	_ds1302_write_time
(0522)           LCD_const_disp(4,7,"    ");		  
    035CE EE85      LDI	R24,0xE5
    035CF E093      LDI	R25,3
    035D0 8399      STD	Y+1,R25
    035D1 8388      ST	Y,R24
    035D2 E027      LDI	R18,7
    035D3 E004      LDI	R16,4
    035D4 940E 3B08 CALL	_LCD_const_disp
(0523) 		  LCD_const_disp(3,1,"          已保存"); 
    035D6 ED84      LDI	R24,0xD4
    035D7 E093      LDI	R25,3
    035D8 8399      STD	Y+1,R25
    035D9 8388      ST	Y,R24
    035DA E021      LDI	R18,1
    035DB E003      LDI	R16,3
    035DC 940E 3B08 CALL	_LCD_const_disp
(0524) 		  delayms(300);
    035DE E20C      LDI	R16,0x2C
    035DF E011      LDI	R17,1
    035E0 940E 2440 CALL	_delayms
(0525) 		  LCD_CLR(); //清屏
    035E2 940E 3BAE CALL	_LCD_CLR
(0526) 		  return ;
    035E4 C005      RJMP	0x35EA
(0527) 		  }
(0528)  delayms(2);	  
    035E5 E002      LDI	R16,2
    035E6 E010      LDI	R17,0
    035E7 940E 2440 CALL	_delayms
    035E9 CE1D      RJMP	0x3407
    035EA 962B      ADIW	R28,0xB
    035EB 940C 4299 JMP	pop_xgsetF0FC
_GUI_readback:
  res                  --> R12
  file_buf             --> Y,+3
  page                 --> R20
  key                  --> R22
  buf                  --> R10
    035ED 940E 42A4 CALL	push_xgsetF0FC
    035EF 0158      MOVW	R10,R16
    035F0 9760      SBIW	R28,0x10
(0529) }//endwhile(1)
(0530) }
(0531) void GUI_readback(char *buf){
(0532)     char key=0;
    035F1 2766      CLR	R22
(0533) 	char page=0;
    035F2 2744      CLR	R20
(0534) 	char res=0;
    035F3 24CC      CLR	R12
(0535) 	char file_buf[]="201201.xls\0\0";
    035F4 E787      LDI	R24,0x77
    035F5 E093      LDI	R25,3
    035F6 01FE      MOVW	R30,R28
    035F7 9633      ADIW	R30,3
    035F8 E00D      LDI	R16,0xD
    035F9 E010      LDI	R17,0
    035FA 93FA      ST	-Y,R31
    035FB 93EA      ST	-Y,R30
    035FC 939A      ST	-Y,R25
    035FD 938A      ST	-Y,R24
    035FE 940E 434B CALL	asgnblk
(0536) 	LCD_CLR(); //清屏
    03600 940E 3BAE CALL	_LCD_CLR
(0537) 	//1 检测SD状态
(0538) 		//无SD卡 显示无卡 退出
(0539) 	if((SD_DET()==0)) {
    03602 B181      IN	R24,0x01
    03603 9586      LSR	R24
    03604 9586      LSR	R24
    03605 9586      LSR	R24
    03606 9586      LSR	R24
    03607 9586      LSR	R24
    03608 7081      ANDI	R24,1
    03609 F421      BNE	0x360E
    0360A E081      LDI	R24,1
    0360B E090      LDI	R25,0
    0360C 017C      MOVW	R14,R24
    0360D C002      RJMP	0x3610
    0360E 24EE      CLR	R14
    0360F 24FF      CLR	R15
    03610 20EE      TST	R14
    03611 F479      BNE	0x3621
    03612 20FF      TST	R15
    03613 F469      BNE	0x3621
(0540) 		LCD_const_disp(2,1,"未检测到SD卡..");
    03614 EC85      LDI	R24,0xC5
    03615 E093      LDI	R25,3
    03616 8399      STD	Y+1,R25
    03617 8388      ST	Y,R24
    03618 E021      LDI	R18,1
    03619 E002      LDI	R16,2
    0361A 940E 3B08 CALL	_LCD_const_disp
(0541) 			#ifdef _DBG_RD_
(0542) 		   PrintString_n("not find sd");
(0543) 		   #endif
(0544) 		delayms(500);
    0361C EF04      LDI	R16,0xF4
    0361D E011      LDI	R17,1
    0361E 940E 2440 CALL	_delayms
(0545) 		return ;
    03620 C15A      RJMP	0x377B
(0546) 	}
(0547) 	//2 显示当前月份
(0548) 	get_name(file_buf);
    03621 018E      MOVW	R16,R28
    03622 5F0D      SUBI	R16,0xFD
    03623 4F1F      SBCI	R17,0xFF
    03624 940E 2B1D CALL	_get_name
(0549) 	LCD_const_disp(1,1,"查找数据:");
    03626 EB8B      LDI	R24,0xBB
    03627 E093      LDI	R25,3
    03628 8399      STD	Y+1,R25
    03629 8388      ST	Y,R24
    0362A E021      LDI	R18,1
    0362B E001      LDI	R16,1
    0362C 940E 3B08 CALL	_LCD_const_disp
(0550) 	LCD_const_disp(2,2,file_buf);
    0362E 01CE      MOVW	R24,R28
    0362F 9603      ADIW	R24,3
    03630 8399      STD	Y+1,R25
    03631 8388      ST	Y,R24
    03632 E022      LDI	R18,2
    03633 E002      LDI	R16,2
    03634 940E 3B08 CALL	_LCD_const_disp
(0551) 	#ifdef _DBG_RD_
(0552) 		   PrintString_n(file_buf);
(0553) 	#endif
(0554) 	//3 查找文件是否存在
(0555) 		//存在-> 进入读取顺序的选择
(0556) 		//不存在 -> 询问查找上月
(0557) 	//4 选择 查询顺序
(0558) 		//计算总条数
(0559) 		//顺序 增量为1， 查询第一条 
(0560) 		//逆序 增量为-1，查询最后一条
(0561) 	//5 读取	
(0562) 	//6 显示
(0563) 	//7 上一条 下一条  退出
(0564) 		//设置条数 判断边界 进入5
(0565) 		//退出 返回主程序	
(0566) 	//!!res=checkFile(file_buf);
(0567) 	LCD_CLR(); //清屏
    03636 940E 3BAE CALL	_LCD_CLR
(0568) 	if(res == 0){ //找到并已经确认文件
    03638 20CC      TST	R12
    03639 F009      BEQ	0x363B
    0363A C140      RJMP	0x377B
(0569) 		   LCD_const_disp(1,1,"菜单/ 检测");
    0363B E18B      LDI	R24,0x1B
    0363C E095      LDI	R25,5
    0363D 8399      STD	Y+1,R25
    0363E 8388      ST	Y,R24
    0363F E021      LDI	R18,1
    03640 E001      LDI	R16,1
    03641 940E 3B08 CALL	_LCD_const_disp
(0570)    		   LCD_const_disp(2,3,"按顺序");
    03643 EB84      LDI	R24,0xB4
    03644 E093      LDI	R25,3
    03645 8399      STD	Y+1,R25
    03646 8388      ST	Y,R24
    03647 E023      LDI	R18,3
    03648 E002      LDI	R16,2
    03649 940E 3B08 CALL	_LCD_const_disp
(0571) 		   LCD_const_disp(3,3,"最后一次");		 
    0364B EA8B      LDI	R24,0xAB
    0364C E093      LDI	R25,3
    0364D 8399      STD	Y+1,R25
    0364E 8388      ST	Y,R24
    0364F E023      LDI	R18,3
    03650 E003      LDI	R16,3
    03651 940E 3B08 CALL	_LCD_const_disp
(0572) 	       if(config.readMode == READ_MODE_LAST){
    03653 9020 084E LDS	R2,config+19
    03655 2022      TST	R2
    03656 F4A1      BNE	0x366B
(0573) 		       config.readMode=READ_MODE_FIRST;
    03657 E081      LDI	R24,1
    03658 9380 084E STS	config+19,R24
(0574) 			   Set_White(1,2,8,0);
    0365A 2422      CLR	R2
    0365B 822A      STD	Y+2,R2
    0365C E088      LDI	R24,0x8
    0365D 8388      ST	Y,R24
    0365E E022      LDI	R18,2
    0365F E001      LDI	R16,1
    03660 940E 3C38 CALL	_Set_White
(0575)  			   Set_White(1,3,8,1);
    03662 E081      LDI	R24,1
    03663 838A      STD	Y+2,R24
    03664 E088      LDI	R24,0x8
    03665 8388      ST	Y,R24
    03666 E023      LDI	R18,3
    03667 E001      LDI	R16,1
    03668 940E 3C38 CALL	_Set_White
(0576) 		  }
    0366A C061      RJMP	0x36CC
(0577) 		  else {
(0578) 		       config.readMode=READ_MODE_LAST;
    0366B 2422      CLR	R2
    0366C 9220 084E STS	config+19,R2
(0579) 			   Set_White(1,2,8,1);
    0366E E081      LDI	R24,1
    0366F 838A      STD	Y+2,R24
    03670 E088      LDI	R24,0x8
    03671 8388      ST	Y,R24
    03672 E022      LDI	R18,2
    03673 E001      LDI	R16,1
    03674 940E 3C38 CALL	_Set_White
(0580)  			   Set_White(1,3,8,0);
    03676 2422      CLR	R2
    03677 822A      STD	Y+2,R2
    03678 E088      LDI	R24,0x8
    03679 8388      ST	Y,R24
    0367A E023      LDI	R18,3
    0367B E001      LDI	R16,1
    0367C 940E 3C38 CALL	_Set_White
(0581) 		 }
    0367E C04D      RJMP	0x36CC
(0582) 		   //<<菜单/检测/手（自）动>>
(0583) 		   while(1){
(0584)  		       key=kbscan();
    0367F 940E 40F2 CALL	_kbscan
    03681 2F60      MOV	R22,R16
(0585) 			   //上键短按 选择
(0586) 			   if(key==up || key ==down){
    03682 310E      CPI	R16,0x1E
    03683 F011      BEQ	0x3686
    03684 310D      CPI	R16,0x1D
    03685 F559      BNE	0x36B1
(0587) 	    	       if(config.readMode == READ_MODE_LAST){
    03686 9020 084E LDS	R2,config+19
    03688 2022      TST	R2
    03689 F4A1      BNE	0x369E
(0588) 		    	       config.readMode=READ_MODE_FIRST;
    0368A E081      LDI	R24,1
    0368B 9380 084E STS	config+19,R24
(0589) 					   Set_White(1,2,8,0);
    0368D 2422      CLR	R2
    0368E 822A      STD	Y+2,R2
    0368F E088      LDI	R24,0x8
    03690 8388      ST	Y,R24
    03691 E022      LDI	R18,2
    03692 E001      LDI	R16,1
    03693 940E 3C38 CALL	_Set_White
(0590)  					   Set_White(1,3,8,1);
    03695 E081      LDI	R24,1
    03696 838A      STD	Y+2,R24
    03697 E088      LDI	R24,0x8
    03698 8388      ST	Y,R24
    03699 E023      LDI	R18,3
    0369A E001      LDI	R16,1
    0369B 940E 3C38 CALL	_Set_White
(0591) 				   }
    0369D C013      RJMP	0x36B1
(0592) 				   else {
(0593) 		    	       config.readMode=READ_MODE_LAST;
    0369E 2422      CLR	R2
    0369F 9220 084E STS	config+19,R2
(0594) 					   Set_White(1,2,8,1);
    036A1 E081      LDI	R24,1
    036A2 838A      STD	Y+2,R24
    036A3 E088      LDI	R24,0x8
    036A4 8388      ST	Y,R24
    036A5 E022      LDI	R18,2
    036A6 E001      LDI	R16,1
    036A7 940E 3C38 CALL	_Set_White
(0595)  					   Set_White(1,3,8,0);
    036A9 2422      CLR	R2
    036AA 822A      STD	Y+2,R2
    036AB E088      LDI	R24,0x8
    036AC 8388      ST	Y,R24
    036AD E023      LDI	R18,3
    036AE E001      LDI	R16,1
    036AF 940E 3C38 CALL	_Set_White
(0596) 				   }
(0597) 				}      
(0598) 				//左键短按  进入
(0599) 				if(key == left) {
    036B1 316B      CPI	R22,0x1B
    036B2 F4A9      BNE	0x36C8
(0600) 				Set_White(1,2,8,1);
    036B3 E081      LDI	R24,1
    036B4 838A      STD	Y+2,R24
    036B5 E088      LDI	R24,0x8
    036B6 8388      ST	Y,R24
    036B7 E022      LDI	R18,2
    036B8 E001      LDI	R16,1
    036B9 940E 3C38 CALL	_Set_White
(0601)  				Set_White(1,3,8,1);
    036BB E081      LDI	R24,1
    036BC 838A      STD	Y+2,R24
    036BD E088      LDI	R24,0x8
    036BE 8388      ST	Y,R24
    036BF E023      LDI	R18,3
    036C0 E001      LDI	R16,1
    036C1 940E 3C38 CALL	_Set_White
(0602) 				delayms(100);
    036C3 E604      LDI	R16,0x64
    036C4 E010      LDI	R17,0
    036C5 940E 2440 CALL	_delayms
(0603) 				break ;		
    036C7 C005      RJMP	0x36CD
(0604) 				}
(0605) 				//右键短按  返回
(0606) 				if(key == right) {
    036C8 3167      CPI	R22,0x17
    036C9 F409      BNE	0x36CB
(0607) 				return ;		
    036CA C0B0      RJMP	0x377B
(0608) 				}
(0609) 				key=0;
    036CB 2766      CLR	R22
    036CC CFB2      RJMP	0x367F
(0610) 		    } //end of while
(0611) 			if(config.readMode==READ_MODE_LAST){
    036CD 9020 084E LDS	R2,config+19
    036CF 2022      TST	R2
    036D0 F461      BNE	0x36DD
(0612) 			    ReadSDFile(file_buf,65535,buf,0); //最后一条
    036D1 2422      CLR	R2
    036D2 822A      STD	Y+2,R2
    036D3 82B9      STD	Y+1,R11
    036D4 82A8      ST	Y,R10
    036D5 EF2F      LDI	R18,0xFF
    036D6 EF3F      LDI	R19,0xFF
    036D7 018E      MOVW	R16,R28
    036D8 5F0D      SUBI	R16,0xFD
    036D9 4F1F      SBCI	R17,0xFF
    036DA 940E 268C CALL	_ReadSDFile
(0613) 			}
    036DC C00B      RJMP	0x36E8
(0614) 			else {
(0615) 			    ReadSDFile(file_buf,1,buf,0); //读第一条
    036DD 2422      CLR	R2
    036DE 822A      STD	Y+2,R2
    036DF 82B9      STD	Y+1,R11
    036E0 82A8      ST	Y,R10
    036E1 E021      LDI	R18,1
    036E2 E030      LDI	R19,0
    036E3 018E      MOVW	R16,R28
    036E4 5F0D      SUBI	R16,0xFD
    036E5 4F1F      SBCI	R17,0xFF
    036E6 940E 268C CALL	_ReadSDFile
(0616) 			}
(0617) 			CharToStruct(buf);      //转换
    036E8 0185      MOVW	R16,R10
    036E9 940E 2AD8 CALL	_CharToStruct
    036EB C08E      RJMP	0x377A
(0618) 			while(1){
(0619) 			    key=kbscan();     //键盘扫描
    036EC 940E 40F2 CALL	_kbscan
    036EE 2F60      MOV	R22,R16
(0620) 				if(key != 0) beep(0,1);
    036EF 2300      TST	R16
    036F0 F021      BEQ	0x36F5
    036F1 E021      LDI	R18,1
    036F2 2700      CLR	R16
    036F3 940E 3E83 CALL	_beep
(0621) 				//dateRefresh(0);  //刷新
(0622) 				_GUI_datashow(page); //显示
    036F5 2F04      MOV	R16,R20
    036F6 DA7E      RCALL	__GUI_datashow
(0623) 				if( key==left ){ //按left键下一条
    036F7 316B      CPI	R22,0x1B
    036F8 F481      BNE	0x3709
(0624) 					next_item:  //下一条
(0625) 				    ReadSDFile(file_buf,1,buf,1); //偏移到下一条
    036F9 E081      LDI	R24,1
    036FA 838A      STD	Y+2,R24
    036FB 82B9      STD	Y+1,R11
    036FC 82A8      ST	Y,R10
    036FD E021      LDI	R18,1
    036FE E030      LDI	R19,0
    036FF 018E      MOVW	R16,R28
    03700 5F0D      SUBI	R16,0xFD
    03701 4F1F      SBCI	R17,0xFF
    03702 940E 268C CALL	_ReadSDFile
(0626) 					CharToStruct(buf);
    03704 0185      MOVW	R16,R10
    03705 940E 2AD8 CALL	_CharToStruct
(0627) 					page = 0;
    03707 2744      CLR	R20
(0628) 					key=0;
    03708 2766      CLR	R22
(0629) 				}
(0630) 				if( key==lleft ){ //长按按left键上一条
    03709 396B      CPI	R22,0x9B
    0370A F481      BNE	0x371B
(0631) 		    	    pre_item: //上一条
(0632) 					ReadSDFile(file_buf,-1,buf,1); //偏移到上一条
    0370B E081      LDI	R24,1
    0370C 838A      STD	Y+2,R24
    0370D 82B9      STD	Y+1,R11
    0370E 82A8      ST	Y,R10
    0370F EF2F      LDI	R18,0xFF
    03710 EF3F      LDI	R19,0xFF
    03711 018E      MOVW	R16,R28
    03712 5F0D      SUBI	R16,0xFD
    03713 4F1F      SBCI	R17,0xFF
    03714 940E 268C CALL	_ReadSDFile
(0633) 					CharToStruct(buf);
    03716 0185      MOVW	R16,R10
    03717 940E 2AD8 CALL	_CharToStruct
(0634) 					page = 0;
    03719 2744      CLR	R20
(0635) 					key=0;
    0371A 2766      CLR	R22
(0636) 				}
(0637) 				if(key==up){ //上键 : 页面减 
    0371B 316E      CPI	R22,0x1E
    0371C F441      BNE	0x3725
(0638) 	    		     if(page>0) page--;
    0371D E080      LDI	R24,0
    0371E 1784      CP	R24,R20
    0371F F758      BCC	0x370B
    03720 954A      DEC	R20
(0639) 	    			 else goto pre_item;
(0640) 					 LCD_CLR();
    03721 940E 3BAE CALL	_LCD_CLR
(0641) 	    			 LCD_Init();
    03723 940E 3B7C CALL	_LCD_Init
(0642)     			}
(0643) 				if(key==lup){ //长按上键 : -10 条 
    03725 396E      CPI	R22,0x9E
    03726 F4A1      BNE	0x373B
(0644) 	    		     ReadSDFile(file_buf,-10,buf,1); //偏移到下10条
    03727 E081      LDI	R24,1
    03728 838A      STD	Y+2,R24
    03729 82B9      STD	Y+1,R11
    0372A 82A8      ST	Y,R10
    0372B EF26      LDI	R18,0xF6
    0372C EF3F      LDI	R19,0xFF
    0372D 018E      MOVW	R16,R28
    0372E 5F0D      SUBI	R16,0xFD
    0372F 4F1F      SBCI	R17,0xFF
    03730 940E 268C CALL	_ReadSDFile
(0645) 					 CharToStruct(buf);
    03732 0185      MOVW	R16,R10
    03733 940E 2AD8 CALL	_CharToStruct
(0646) 					 page = 0;
    03735 2744      CLR	R20
(0647) 					 key=0;
    03736 2766      CLR	R22
(0648) 					 LCD_CLR();
    03737 940E 3BAE CALL	_LCD_CLR
(0649) 	    			 LCD_Init();
    03739 940E 3B7C CALL	_LCD_Init
(0650)     			}
(0651) 				if(key==down){ //下键 ： 页面加
    0373B 316D      CPI	R22,0x1D
    0373C F441      BNE	0x3745
(0652) 	    		    if(page<5) page++;
    0373D 3045      CPI	R20,5
    0373E F008      BCS	0x3740
    0373F CFB9      RJMP	0x36F9
    03740 9543      INC	R20
(0653) 	  				else goto next_item;
(0654) 	    			LCD_CLR();
    03741 940E 3BAE CALL	_LCD_CLR
(0655) 	    			LCD_Init();
    03743 940E 3B7C CALL	_LCD_Init
(0656) 				}
(0657) 				if(key==ldown){ //长按下键 ： 页面加10条
    03745 396D      CPI	R22,0x9D
    03746 F4A1      BNE	0x375B
(0658) 	    		    ReadSDFile(file_buf,10,buf,1); //偏移到下10条
    03747 E081      LDI	R24,1
    03748 838A      STD	Y+2,R24
    03749 82B9      STD	Y+1,R11
    0374A 82A8      ST	Y,R10
    0374B E02A      LDI	R18,0xA
    0374C E030      LDI	R19,0
    0374D 018E      MOVW	R16,R28
    0374E 5F0D      SUBI	R16,0xFD
    0374F 4F1F      SBCI	R17,0xFF
    03750 940E 268C CALL	_ReadSDFile
(0659) 					CharToStruct(buf);
    03752 0185      MOVW	R16,R10
    03753 940E 2AD8 CALL	_CharToStruct
(0660) 					page = 0;
    03755 2744      CLR	R20
(0661) 					key = 0;
    03756 2766      CLR	R22
(0662) 	    			LCD_CLR();
    03757 940E 3BAE CALL	_LCD_CLR
(0663) 	    			LCD_Init();
    03759 940E 3B7C CALL	_LCD_Init
(0664) 				}
(0665) 				if(key==right){	//右键 退出
    0375B 3167      CPI	R22,0x17
    0375C F439      BNE	0x3764
(0666) 	    		    beep(0,1); 
    0375D E021      LDI	R18,1
    0375E 2700      CLR	R16
    0375F 940E 3E83 CALL	_beep
(0667) 	 				LCD_CLR();
    03761 940E 3BAE CALL	_LCD_CLR
(0668) 	 				return ;
    03763 C017      RJMP	0x377B
(0669) 				}
(0670) 				if(page == 0 ){
    03764 2344      TST	R20
    03765 F481      BNE	0x3776
(0671) 				    LCD_const_disp(4,1,"ID:         ");
    03766 E98E      LDI	R24,0x9E
    03767 E093      LDI	R25,3
    03768 8399      STD	Y+1,R25
    03769 8388      ST	Y,R24
    0376A E021      LDI	R18,1
    0376B E004      LDI	R16,4
    0376C 940E 3B08 CALL	_LCD_const_disp
(0672) 					LCD_const_disp(4,3,Result.IndexChar);
    0376E ED89      LDI	R24,0xD9
    0376F E095      LDI	R25,5
    03770 8399      STD	Y+1,R25
    03771 8388      ST	Y,R24
    03772 E023      LDI	R18,3
    03773 E004      LDI	R16,4
    03774 940E 3B08 CALL	_LCD_const_disp
(0673) 				}
(0674)     			delayms(30); 
    03776 E10E      LDI	R16,0x1E
    03777 E010      LDI	R17,0
    03778 940E 2440 CALL	_delayms
    0377A CF71      RJMP	0x36EC
(0675) 		 }//end while
(0676) 		   
(0677) 	}
(0678) 	else { //未找到或未确认文件
(0679) 		 //逆序查找文件，直到月份小于 200001.xls
(0680) 		 //或是手工确认的方式
(0681) 	}
    0377B 9660      ADIW	R28,0x10
    0377C 940C 4299 JMP	pop_xgsetF0FC
_GUI_welcome:
    0377E 9722      SBIW	R28,2
(0682) 
(0683) }
(0684) void GUI_welcome(void){
(0685)     LCD_CLR(); //清屏
    0377F 940E 3BAE CALL	_LCD_CLR
(0686) 	LCD_const_disp(2,3,"欢迎使用");
    03781 E985      LDI	R24,0x95
    03782 E093      LDI	R25,3
    03783 8399      STD	Y+1,R25
    03784 8388      ST	Y,R24
    03785 E023      LDI	R18,3
    03786 E002      LDI	R16,2
    03787 940E 3B08 CALL	_LCD_const_disp
(0687) 	LCD_const_disp(3,1,"环境冷强度检测仪");
    03789 E884      LDI	R24,0x84
    0378A E093      LDI	R25,3
    0378B 8399      STD	Y+1,R25
    0378C 8388      ST	Y,R24
    0378D E021      LDI	R18,1
    0378E E003      LDI	R16,3
    0378F 940E 3B08 CALL	_LCD_const_disp
(0688) 	delayms(800);
    03791 E200      LDI	R16,0x20
    03792 E013      LDI	R17,3
    03793 940E 2440 CALL	_delayms
(0689) 	beep(0,1);
    03795 E021      LDI	R18,1
    03796 2700      CLR	R16
    03797 940E 3E83 CALL	_beep
    03799 9622      ADIW	R28,2
    0379A 9508      RET
_dateRefresh:
  readhardware         --> R20
    0379B 934A      ST	-Y,R20
    0379C 2F40      MOV	R20,R16
(0690) 	
(0691) }
(0692) 
(0693) ////////////////////////////////////
(0694) //  函数作用
(0695) //   将ds1302中缓存的时钟数据转换进结构体中
(0696) ////////////////////////////////////
(0697) void dateRefresh(unsigned char readhardware)
(0698) {	//readhardware = 0 not refresh, =1 refresh
(0699) 
(0700)  if( readhardware!=88 )	ds1302_read_time();
    0379D 3548      CPI	R20,0x58
    0379E F011      BEQ	0x37A1
    0379F 940E 40CA CALL	_ds1302_read_time
(0701) 	t.tm_sec=(((time_buf[6]&0x70)>>4)*10)+(time_buf[6]&0x0f);
    037A1 9110 0573 LDS	R17,time_buf+6
    037A3 7710      ANDI	R17,0x70
    037A4 9512      SWAP	R17
    037A5 701F      ANDI	R17,0xF
    037A6 E00A      LDI	R16,0xA
    037A7 0301      MULSU	R16,R17
    037A8 0110      MOVW	R2,R0
    037A9 9180 0573 LDS	R24,time_buf+6
    037AB 2799      CLR	R25
    037AC 708F      ANDI	R24,0xF
    037AD 7090      ANDI	R25,0
    037AE 0E28      ADD	R2,R24
    037AF 1E39      ADC	R3,R25
    037B0 9230 082A STS	t+1,R3
    037B2 9220 0829 STS	t,R2
(0702) 	t.tm_min=  (((time_buf[5]&0x70)>>4)*10)+(time_buf[5]&0x0f);
    037B4 9110 0572 LDS	R17,time_buf+5
    037B6 7710      ANDI	R17,0x70
    037B7 9512      SWAP	R17
    037B8 701F      ANDI	R17,0xF
    037B9 0301      MULSU	R16,R17
    037BA 0110      MOVW	R2,R0
    037BB 9180 0572 LDS	R24,time_buf+5
    037BD 2799      CLR	R25
    037BE 708F      ANDI	R24,0xF
    037BF 7090      ANDI	R25,0
    037C0 0E28      ADD	R2,R24
    037C1 1E39      ADC	R3,R25
    037C2 9230 082C STS	t+3,R3
    037C4 9220 082B STS	t+2,R2
(0703) 	t.tm_hour=  (((time_buf[4]&0x70)>>4)*10)+(time_buf[4]&0x0f);
    037C6 9110 0571 LDS	R17,time_buf+4
    037C8 7710      ANDI	R17,0x70
    037C9 9512      SWAP	R17
    037CA 701F      ANDI	R17,0xF
    037CB 0301      MULSU	R16,R17
    037CC 0110      MOVW	R2,R0
    037CD 9180 0571 LDS	R24,time_buf+4
    037CF 2799      CLR	R25
    037D0 708F      ANDI	R24,0xF
    037D1 7090      ANDI	R25,0
    037D2 0E28      ADD	R2,R24
    037D3 1E39      ADC	R3,R25
    037D4 9230 082E STS	t+5,R3
    037D6 9220 082D STS	t+4,R2
(0704) 	t.tm_mday=	(((time_buf[3]&0x70)>>4)*10)+(time_buf[3]&0x0f);
    037D8 9110 0570 LDS	R17,time_buf+3
    037DA 7710      ANDI	R17,0x70
    037DB 9512      SWAP	R17
    037DC 701F      ANDI	R17,0xF
    037DD 0301      MULSU	R16,R17
    037DE 0110      MOVW	R2,R0
    037DF 9180 0570 LDS	R24,time_buf+3
    037E1 2799      CLR	R25
    037E2 708F      ANDI	R24,0xF
    037E3 7090      ANDI	R25,0
    037E4 0E28      ADD	R2,R24
    037E5 1E39      ADC	R3,R25
    037E6 9230 0830 STS	t+7,R3
    037E8 9220 082F STS	t+6,R2
(0705) 	t.tm_mon= (((time_buf[2]&0x70)>>4)*10)+(time_buf[2]&0x0f);
    037EA 9110 056F LDS	R17,time_buf+2
    037EC 7710      ANDI	R17,0x70
    037ED 9512      SWAP	R17
    037EE 701F      ANDI	R17,0xF
    037EF 0301      MULSU	R16,R17
    037F0 0110      MOVW	R2,R0
    037F1 9180 056F LDS	R24,time_buf+2
    037F3 2799      CLR	R25
    037F4 708F      ANDI	R24,0xF
    037F5 7090      ANDI	R25,0
    037F6 0E28      ADD	R2,R24
    037F7 1E39      ADC	R3,R25
    037F8 9230 0832 STS	t+9,R3
    037FA 9220 0831 STS	t+8,R2
(0706) 	t.tm_wday=	(time_buf[7]&0x0f);
    037FC 9180 0574 LDS	R24,time_buf+7
    037FE 2799      CLR	R25
    037FF 708F      ANDI	R24,0xF
    03800 7090      ANDI	R25,0
    03801 9390 0836 STS	t+13,R25
    03803 9380 0835 STS	t+12,R24
(0707)     t.tm_year=	(((time_buf[1]&0x70)>>4)*10)+(time_buf[1]&0x0f);
    03805 9110 056E LDS	R17,time_buf+1
    03807 7710      ANDI	R17,0x70
    03808 9512      SWAP	R17
    03809 701F      ANDI	R17,0xF
    0380A 0301      MULSU	R16,R17
    0380B 0110      MOVW	R2,R0
    0380C 9180 056E LDS	R24,time_buf+1
    0380E 2799      CLR	R25
    0380F 708F      ANDI	R24,0xF
    03810 7090      ANDI	R25,0
    03811 0E28      ADD	R2,R24
    03812 1E39      ADC	R3,R25
    03813 9230 0834 STS	t+11,R3
    03815 9220 0833 STS	t+10,R2
(0708) 	if(readhardware != 0){
    03817 2344      TST	R20
    03818 F409      BNE	0x381A
    03819 C0A5      RJMP	0x38BF
(0709) 	Result.Date[0]='2';
    0381A E382      LDI	R24,0x32
    0381B 9380 05E1 STS	Result+22,R24
(0710) 	Result.Date[1]='0';
    0381D E380      LDI	R24,0x30
    0381E 9380 05E2 STS	Result+23,R24
(0711) 	Result.Date[2]=t.tm_year/10+'0';
    03820 E02A      LDI	R18,0xA
    03821 E030      LDI	R19,0
    03822 0181      MOVW	R16,R2
    03823 940E 4174 CALL	div16s
    03825 01C8      MOVW	R24,R16
    03826 96C0      ADIW	R24,0x30
    03827 9380 05E3 STS	Result+24,R24
(0712) 	Result.Date[3]=t.tm_year%10+'0';
    03829 E02A      LDI	R18,0xA
    0382A E030      LDI	R19,0
    0382B 9100 0833 LDS	R16,t+10
    0382D 9110 0834 LDS	R17,t+11
    0382F 940E 4170 CALL	mod16s
    03831 01C8      MOVW	R24,R16
    03832 96C0      ADIW	R24,0x30
    03833 9380 05E4 STS	Result+25,R24
(0713) 	Result.Date[4]=t.tm_mon/10+'0';
    03835 E02A      LDI	R18,0xA
    03836 E030      LDI	R19,0
    03837 9100 0831 LDS	R16,t+8
    03839 9110 0832 LDS	R17,t+9
    0383B 940E 4174 CALL	div16s
    0383D 01C8      MOVW	R24,R16
    0383E 96C0      ADIW	R24,0x30
    0383F 9380 05E5 STS	Result+26,R24
(0714) 	Result.Date[5]=t.tm_mon%10+'0';
    03841 E02A      LDI	R18,0xA
    03842 E030      LDI	R19,0
    03843 9100 0831 LDS	R16,t+8
    03845 9110 0832 LDS	R17,t+9
    03847 940E 4170 CALL	mod16s
    03849 01C8      MOVW	R24,R16
    0384A 96C0      ADIW	R24,0x30
    0384B 9380 05E6 STS	Result+27,R24
(0715) 	Result.Date[6]=t.tm_mday/10+'0';
    0384D E02A      LDI	R18,0xA
    0384E E030      LDI	R19,0
    0384F 9100 082F LDS	R16,t+6
    03851 9110 0830 LDS	R17,t+7
    03853 940E 4174 CALL	div16s
    03855 01C8      MOVW	R24,R16
    03856 96C0      ADIW	R24,0x30
    03857 9380 05E7 STS	Result+28,R24
(0716) 	Result.Date[7]=t.tm_mday%10+'0';
    03859 E02A      LDI	R18,0xA
    0385A E030      LDI	R19,0
    0385B 9100 082F LDS	R16,t+6
    0385D 9110 0830 LDS	R17,t+7
    0385F 940E 4170 CALL	mod16s
    03861 01C8      MOVW	R24,R16
    03862 96C0      ADIW	R24,0x30
    03863 9380 05E8 STS	Result+29,R24
(0717)     Result.Date[8]='\0';
    03865 2422      CLR	R2
    03866 9220 05E9 STS	Result+30,R2
(0718) 
(0719) 	Result.Time[0]=t.tm_hour/10+'0';
    03868 E02A      LDI	R18,0xA
    03869 E030      LDI	R19,0
    0386A 9100 082D LDS	R16,t+4
    0386C 9110 082E LDS	R17,t+5
    0386E 940E 4174 CALL	div16s
    03870 01C8      MOVW	R24,R16
    03871 96C0      ADIW	R24,0x30
    03872 9380 05EA STS	Result+31,R24
(0720) 	Result.Time[1]=t.tm_hour%10+'0';
    03874 E02A      LDI	R18,0xA
    03875 E030      LDI	R19,0
    03876 9100 082D LDS	R16,t+4
    03878 9110 082E LDS	R17,t+5
    0387A 940E 4170 CALL	mod16s
    0387C 01C8      MOVW	R24,R16
    0387D 96C0      ADIW	R24,0x30
    0387E 9380 05EB STS	Result+32,R24
(0721) 	Result.Time[2]=':';
    03880 E38A      LDI	R24,0x3A
    03881 9380 05EC STS	Result+33,R24
(0722) 	Result.Time[3]=' ';
    03883 E280      LDI	R24,0x20
    03884 9380 05ED STS	Result+34,R24
(0723) 	Result.Time[4]=t.tm_min/10+'0';
    03886 E02A      LDI	R18,0xA
    03887 E030      LDI	R19,0
    03888 9100 082B LDS	R16,t+2
    0388A 9110 082C LDS	R17,t+3
    0388C 940E 4174 CALL	div16s
    0388E 01C8      MOVW	R24,R16
    0388F 96C0      ADIW	R24,0x30
    03890 9380 05EE STS	Result+35,R24
(0724) 	Result.Time[5]=t.tm_min%10+'0';
    03892 E02A      LDI	R18,0xA
    03893 E030      LDI	R19,0
    03894 9100 082B LDS	R16,t+2
    03896 9110 082C LDS	R17,t+3
    03898 940E 4170 CALL	mod16s
    0389A 01C8      MOVW	R24,R16
    0389B 96C0      ADIW	R24,0x30
    0389C 9380 05EF STS	Result+36,R24
(0725) 	Result.Time[6]=':';
    0389E E38A      LDI	R24,0x3A
    0389F 9380 05F0 STS	Result+37,R24
(0726) 	Result.Time[7]=' ';
    038A1 E280      LDI	R24,0x20
    038A2 9380 05F1 STS	Result+38,R24
(0727) 	Result.Time[8]=t.tm_sec/10+'0';
    038A4 E02A      LDI	R18,0xA
    038A5 E030      LDI	R19,0
    038A6 9100 0829 LDS	R16,t
    038A8 9110 082A LDS	R17,t+1
    038AA 940E 4174 CALL	div16s
    038AC 01C8      MOVW	R24,R16
    038AD 96C0      ADIW	R24,0x30
    038AE 9380 05F2 STS	Result+39,R24
(0728) 	Result.Time[9]=t.tm_sec%10+'0';
    038B0 E02A      LDI	R18,0xA
    038B1 E030      LDI	R19,0
    038B2 9100 0829 LDS	R16,t
    038B4 9110 082A LDS	R17,t+1
    038B6 940E 4170 CALL	mod16s
    038B8 01C8      MOVW	R24,R16
    038B9 96C0      ADIW	R24,0x30
    038BA 9380 05F3 STS	Result+40,R24
(0729) 	Result.Time[10]='\0'; 
    038BC 2422      CLR	R2
    038BD 9220 05F4 STS	Result+41,R2
(0730) 	}
(0731)     config.now =t.tm_hour*3600 + t.tm_min*60 + t.tm_sec; //更新系统心跳
    038BF 9120 082B LDS	R18,t+2
    038C1 9130 082C LDS	R19,t+3
    038C3 E30C      LDI	R16,0x3C
    038C4 E010      LDI	R17,0
    038C5 940E 4240 CALL	empy16s
    038C7 0118      MOVW	R2,R16
    038C8 9120 082D LDS	R18,t+4
    038CA 9130 082E LDS	R19,t+5
    038CC E100      LDI	R16,0x10
    038CD E01E      LDI	R17,0xE
    038CE 940E 4240 CALL	empy16s
    038D0 0128      MOVW	R4,R16
    038D1 0C42      ADD	R4,R2
    038D2 1C53      ADC	R5,R3
    038D3 9020 0829 LDS	R2,t
    038D5 9030 082A LDS	R3,t+1
    038D7 0C42      ADD	R4,R2
    038D8 1C53      ADC	R5,R3
    038D9 0112      MOVW	R2,R4
    038DA 2444      CLR	R4
    038DB FC37      SBRC	R3,7
    038DC 9440      COM	R4
    038DD 2455      CLR	R5
    038DE FC47      SBRC	R4,7
    038DF 9450      COM	R5
    038E0 9230 0848 STS	config+13,R3
    038E2 9220 0847 STS	config+12,R2
    038E4 9250 084A STS	config+15,R5
    038E6 9240 0849 STS	config+14,R4
    038E8 9149      LD	R20,Y+
    038E9 9508      RET
FILE: D:\LQD\software\software_src\usart.c
(0001) #include "config.h"
(0002) 
(0003) 
(0004) #define fosc 7372800UL //晶振7.3728MHZ
(0005) #define baud 38400  //波特率
(0006) //串口通信初始化  MEGA128
(0007) //UART1 initialize
(0008) // desired baud rate:38400
(0009) // actual baud rate:38400 (0.0%)
(0010) // char size: 8 bit
(0011) // parity: Disabled
(0012) void uart1_init(void)
(0013) {
(0014)  	 UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    038EA 2422      CLR	R2
    038EB 9220 009A STS	0x9A,R2
(0015)      UCSR1A = 0x00;
    038ED 9220 009B STS	0x9B,R2
(0016)      UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//8bit+1bit stop
    038EF E086      LDI	R24,6
    038F0 9380 009D STS	0x9D,R24
(0017)      UBRR1L=(fosc/16/(baud+1))%256;
    038F2 E08B      LDI	R24,0xB
    038F3 9380 0099 STS	0x99,R24
(0018)      UBRR1H=(fosc/16/(baud+1))/256;
    038F5 9220 0098 STS	0x98,R2
(0019)      UCSR1B =(1<<RXEN1)|(1<<TXEN1);//RXCEN TXCEN
    038F7 E188      LDI	R24,0x18
    038F8 9380 009A STS	0x9A,R24
    038FA 9508      RET
_uart1_rx_isr:
  tmp                  --> R16
    038FB 930A      ST	-Y,R16
    038FC B70F      IN	R16,0x3F
    038FD 930A      ST	-Y,R16
(0020) }
(0021) 
(0022) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0023) void uart1_rx_isr(void){   
(0024) 	 char tmp;
(0025) 	 tmp=UDR1;
    038FE 9100 009C LDS	R16,0x9C
    03900 9109      LD	R16,Y+
    03901 BF0F      OUT	0x3F,R16
    03902 9109      LD	R16,Y+
    03903 9518      RETI
(0026) }
(0027) 
(0028) void Usart_Transmit(char c)
(0029) {
(0030)  	 while (!(UCSR1A&(1<<UDRE1)));//表明发送器一准备就绪
_Usart_Transmit:
  c                    --> R16
    03904 9020 009B LDS	R2,0x9B
    03906 FE25      SBRS	R2,5
    03907 CFFC      RJMP	_Usart_Transmit
(0031) 	 UDR1=c;
    03908 9300 009C STS	0x9C,R16
    0390A 9508      RET
_Puts:
  s                    --> R20
    0390B 934A      ST	-Y,R20
    0390C 935A      ST	-Y,R21
    0390D 01A8      MOVW	R20,R16
(0032) }
(0033) 
(0034) //串口输出字符串
(0035) void Puts( unsigned char *s)
(0036) { 
    0390E C00B      RJMP	0x391A
(0037) 	 while (*s) 
(0038)       { 
(0039) 	  //为数据间的隔断创造一个串口能显示的隔断字符 即'/t'  ->  ' '
(0040) 	  if(*s==0x09)  
    0390F 01FA      MOVW	R30,R20
    03910 8180      LD	R24,Z
    03911 3089      CPI	R24,0x9
    03912 F411      BNE	0x3915
(0041) 	  {   Usart_Transmit(' ');    }
    03913 E200      LDI	R16,0x20
    03914 DFEF      RCALL	_Usart_Transmit
(0042) 	 Usart_Transmit(*s);
    03915 01FA      MOVW	R30,R20
    03916 8100      LD	R16,Z
    03917 DFEC      RCALL	_Usart_Transmit
(0043) 	 s++;
    03918 5F4F      SUBI	R20,0xFF
    03919 4F5F      SBCI	R21,0xFF
    0391A 01FA      MOVW	R30,R20
    0391B 8020      LD	R2,Z
    0391C 2022      TST	R2
    0391D F789      BNE	0x390F
    0391E 9159      LD	R21,Y+
    0391F 9149      LD	R20,Y+
    03920 9508      RET
_Send_nByte:
  i                    --> R20
  len                  --> R10
  p                    --> R12
    03921 940E 42D1 CALL	push_xgset303C
    03923 2EA2      MOV	R10,R18
    03924 0168      MOVW	R12,R16
(0044) 	
(0045) 	
(0046)       }
(0047) }
(0048) 
(0049) 
(0050) 
(0051) void Send_nByte(unsigned char *p, unsigned char len)
(0052) { 
(0053)   int i = 0;
(0054)   for(i=0;i<len;i++)
    03925 2744      CLR	R20
    03926 2755      CLR	R21
    03927 C007      RJMP	0x392F
(0055)   {
(0056)    	Usart_Transmit(*(p+i));
    03928 01FA      MOVW	R30,R20
    03929 0DEC      ADD	R30,R12
    0392A 1DFD      ADC	R31,R13
    0392B 8100      LD	R16,Z
    0392C DFD7      RCALL	_Usart_Transmit
    0392D 5F4F      SUBI	R20,0xFF
    0392E 4F5F      SBCI	R21,0xFF
    0392F 2C2A      MOV	R2,R10
    03930 2433      CLR	R3
    03931 1542      CP	R20,R2
    03932 0553      CPC	R21,R3
    03933 F3A4      BLT	0x3928
    03934 940C 42D8 JMP	pop_xgset303C
_PrintString:
  str                  --> R10
    03936 92AA      ST	-Y,R10
    03937 92BA      ST	-Y,R11
    03938 0158      MOVW	R10,R16
(0057)   }
(0058) }
(0059) 
(0060) void  PrintString(const unsigned char *str)
(0061) {    
    03939 C004      RJMP	0x393E
(0062) 	while(*str!=0)	Usart_Transmit(*str++);
    0393A 01F5      MOVW	R30,R10
    0393B 9101      LD	R16,Z+
    0393C 015F      MOVW	R10,R30
    0393D DFC6      RCALL	_Usart_Transmit
    0393E 01F5      MOVW	R30,R10
    0393F 8020      LD	R2,Z
    03940 2022      TST	R2
    03941 F7C1      BNE	0x393A
    03942 90B9      LD	R11,Y+
    03943 90A9      LD	R10,Y+
    03944 9508      RET
_PrintString_n:
  str                  --> R10
    03945 92AA      ST	-Y,R10
    03946 92BA      ST	-Y,R11
    03947 0158      MOVW	R10,R16
(0063) }
(0064) void  PrintString_n(const unsigned char *str)
(0065) {   
(0066) 	Usart_Transmit('\r');
    03948 E00D      LDI	R16,0xD
    03949 DFBA      RCALL	_Usart_Transmit
(0067) 	Usart_Transmit('\n'); 
    0394A E00A      LDI	R16,0xA
    0394B DFB8      RCALL	_Usart_Transmit
    0394C C004      RJMP	0x3951
(0068) 	while(*str!=0)	Usart_Transmit(*str++);
    0394D 01F5      MOVW	R30,R10
    0394E 9101      LD	R16,Z+
    0394F 015F      MOVW	R10,R30
    03950 DFB3      RCALL	_Usart_Transmit
    03951 01F5      MOVW	R30,R10
    03952 8020      LD	R2,Z
    03953 2022      TST	R2
    03954 F7C1      BNE	0x394D
    03955 90B9      LD	R11,Y+
    03956 90A9      LD	R10,Y+
    03957 9508      RET
_PrintLong:
  i                    --> R20
  da                   --> Y,+0
  data                 --> Y,+9
    03958 940E 415F CALL	push_arg4
    0395A 934A      ST	-Y,R20
    0395B 9728      SBIW	R28,0x8
(0069) 
(0070) } 
(0071)  
(0072) void PrintLong(unsigned long data)
(0073) {
(0074)  
(0075) 	unsigned char da[8];
(0076) 	unsigned char i;
(0077) 	for(i=0;i<8;i++)	da[i]=0;
    0395C 2744      CLR	R20
    0395D C008      RJMP	0x3966
    0395E 01CE      MOVW	R24,R28
    0395F 2FE4      MOV	R30,R20
    03960 27FF      CLR	R31
    03961 0FE8      ADD	R30,R24
    03962 1FF9      ADC	R31,R25
    03963 2422      CLR	R2
    03964 8220      ST	Z,R2
    03965 9543      INC	R20
    03966 3048      CPI	R20,0x8
    03967 F3B0      BCS	0x395E
    03968 C013      RJMP	0x397C
(0078) 	while(data>=10000000L){ ++da[7];data-=10000000L;}
    03969 818F      LDD	R24,Y+7
    0396A 5F8F      SUBI	R24,0xFF
    0396B 838F      STD	Y+7,R24
    0396C E880      LDI	R24,0x80
    0396D E996      LDI	R25,0x96
    0396E E9A8      LDI	R26,0x98
    0396F E0B0      LDI	R27,0
    03970 8429      LDD	R2,Y+9
    03971 843A      LDD	R3,Y+10
    03972 844B      LDD	R4,Y+11
    03973 845C      LDD	R5,Y+12
    03974 1A28      SUB	R2,R24
    03975 0A39      SBC	R3,R25
    03976 0A4A      SBC	R4,R26
    03977 0A5B      SBC	R5,R27
    03978 8629      STD	Y+9,R2
    03979 863A      STD	Y+10,R3
    0397A 864B      STD	Y+11,R4
    0397B 865C      STD	Y+12,R5
    0397C E880      LDI	R24,0x80
    0397D E996      LDI	R25,0x96
    0397E E9A8      LDI	R26,0x98
    0397F E0B0      LDI	R27,0
    03980 8429      LDD	R2,Y+9
    03981 843A      LDD	R3,Y+10
    03982 844B      LDD	R4,Y+11
    03983 845C      LDD	R5,Y+12
    03984 1628      CP	R2,R24
    03985 0639      CPC	R3,R25
    03986 064A      CPC	R4,R26
    03987 065B      CPC	R5,R27
    03988 F700      BCC	0x3969
(0079) 	if(da[7])	i=0;
    03989 802F      LDD	R2,Y+7
    0398A 2022      TST	R2
    0398B F009      BEQ	0x398D
    0398C 2744      CLR	R20
(0080) 	if(i==0)	Usart_Transmit('0'+da[7]);
    0398D 2344      TST	R20
    0398E F4B9      BNE	0x39A6
    0398F 810F      LDD	R16,Y+7
    03990 5D00      SUBI	R16,0xD0
    03991 DF72      RCALL	_Usart_Transmit
    03992 C013      RJMP	0x39A6
(0081) 	while(data>=1000000L) { ++da[6];data-=1000000L;}
    03993 818E      LDD	R24,Y+6
    03994 5F8F      SUBI	R24,0xFF
    03995 838E      STD	Y+6,R24
    03996 E480      LDI	R24,0x40
    03997 E492      LDI	R25,0x42
    03998 E0AF      LDI	R26,0xF
    03999 E0B0      LDI	R27,0
    0399A 8429      LDD	R2,Y+9
    0399B 843A      LDD	R3,Y+10
    0399C 844B      LDD	R4,Y+11
    0399D 845C      LDD	R5,Y+12
    0399E 1A28      SUB	R2,R24
    0399F 0A39      SBC	R3,R25
    039A0 0A4A      SBC	R4,R26
    039A1 0A5B      SBC	R5,R27
    039A2 8629      STD	Y+9,R2
    039A3 863A      STD	Y+10,R3
    039A4 864B      STD	Y+11,R4
    039A5 865C      STD	Y+12,R5
    039A6 E480      LDI	R24,0x40
    039A7 E492      LDI	R25,0x42
    039A8 E0AF      LDI	R26,0xF
    039A9 E0B0      LDI	R27,0
    039AA 8429      LDD	R2,Y+9
    039AB 843A      LDD	R3,Y+10
    039AC 844B      LDD	R4,Y+11
    039AD 845C      LDD	R5,Y+12
    039AE 1628      CP	R2,R24
    039AF 0639      CPC	R3,R25
    039B0 064A      CPC	R4,R26
    039B1 065B      CPC	R5,R27
    039B2 F700      BCC	0x3993
(0082) 	if(da[6])	i=0;
    039B3 802E      LDD	R2,Y+6
    039B4 2022      TST	R2
    039B5 F009      BEQ	0x39B7
    039B6 2744      CLR	R20
(0083) 	if(i==0)	Usart_Transmit('0'+da[6]);
    039B7 2344      TST	R20
    039B8 F4B9      BNE	0x39D0
    039B9 810E      LDD	R16,Y+6
    039BA 5D00      SUBI	R16,0xD0
    039BB DF48      RCALL	_Usart_Transmit
    039BC C013      RJMP	0x39D0
(0084) 	while(data>=100000L)  { ++da[5];data-=100000L;}
    039BD 818D      LDD	R24,Y+5
    039BE 5F8F      SUBI	R24,0xFF
    039BF 838D      STD	Y+5,R24
    039C0 EA80      LDI	R24,0xA0
    039C1 E896      LDI	R25,0x86
    039C2 E0A1      LDI	R26,1
    039C3 E0B0      LDI	R27,0
    039C4 8429      LDD	R2,Y+9
    039C5 843A      LDD	R3,Y+10
    039C6 844B      LDD	R4,Y+11
    039C7 845C      LDD	R5,Y+12
    039C8 1A28      SUB	R2,R24
    039C9 0A39      SBC	R3,R25
    039CA 0A4A      SBC	R4,R26
    039CB 0A5B      SBC	R5,R27
    039CC 8629      STD	Y+9,R2
    039CD 863A      STD	Y+10,R3
    039CE 864B      STD	Y+11,R4
    039CF 865C      STD	Y+12,R5
    039D0 EA80      LDI	R24,0xA0
    039D1 E896      LDI	R25,0x86
    039D2 E0A1      LDI	R26,1
    039D3 E0B0      LDI	R27,0
    039D4 8429      LDD	R2,Y+9
    039D5 843A      LDD	R3,Y+10
    039D6 844B      LDD	R4,Y+11
    039D7 845C      LDD	R5,Y+12
    039D8 1628      CP	R2,R24
    039D9 0639      CPC	R3,R25
    039DA 064A      CPC	R4,R26
    039DB 065B      CPC	R5,R27
    039DC F700      BCC	0x39BD
(0085) 	if(da[5])	i=0;
    039DD 802D      LDD	R2,Y+5
    039DE 2022      TST	R2
    039DF F009      BEQ	0x39E1
    039E0 2744      CLR	R20
(0086) 	if(i==0)	Usart_Transmit('0'+da[5]);
    039E1 2344      TST	R20
    039E2 F4B9      BNE	0x39FA
    039E3 810D      LDD	R16,Y+5
    039E4 5D00      SUBI	R16,0xD0
    039E5 DF1E      RCALL	_Usart_Transmit
    039E6 C013      RJMP	0x39FA
(0087) 	while(data>=10000L)   { ++da[4];data-=10000L;}
    039E7 818C      LDD	R24,Y+4
    039E8 5F8F      SUBI	R24,0xFF
    039E9 838C      STD	Y+4,R24
    039EA E180      LDI	R24,0x10
    039EB E297      LDI	R25,0x27
    039EC E0A0      LDI	R26,0
    039ED E0B0      LDI	R27,0
    039EE 8429      LDD	R2,Y+9
    039EF 843A      LDD	R3,Y+10
    039F0 844B      LDD	R4,Y+11
    039F1 845C      LDD	R5,Y+12
    039F2 1A28      SUB	R2,R24
    039F3 0A39      SBC	R3,R25
    039F4 0A4A      SBC	R4,R26
    039F5 0A5B      SBC	R5,R27
    039F6 8629      STD	Y+9,R2
    039F7 863A      STD	Y+10,R3
    039F8 864B      STD	Y+11,R4
    039F9 865C      STD	Y+12,R5
    039FA E180      LDI	R24,0x10
    039FB E297      LDI	R25,0x27
    039FC E0A0      LDI	R26,0
    039FD E0B0      LDI	R27,0
    039FE 8429      LDD	R2,Y+9
    039FF 843A      LDD	R3,Y+10
    03A00 844B      LDD	R4,Y+11
    03A01 845C      LDD	R5,Y+12
    03A02 1628      CP	R2,R24
    03A03 0639      CPC	R3,R25
    03A04 064A      CPC	R4,R26
    03A05 065B      CPC	R5,R27
    03A06 F700      BCC	0x39E7
(0088) 	if(da[4])	i=0;
    03A07 802C      LDD	R2,Y+4
    03A08 2022      TST	R2
    03A09 F009      BEQ	0x3A0B
    03A0A 2744      CLR	R20
(0089) 	if(i==0)	Usart_Transmit('0'+da[4]);
    03A0B 2344      TST	R20
    03A0C F4B9      BNE	0x3A24
    03A0D 810C      LDD	R16,Y+4
    03A0E 5D00      SUBI	R16,0xD0
    03A0F DEF4      RCALL	_Usart_Transmit
    03A10 C013      RJMP	0x3A24
(0090) 	while(data>=1000L)    { ++da[3];data-=1000L;}
    03A11 818B      LDD	R24,Y+3
    03A12 5F8F      SUBI	R24,0xFF
    03A13 838B      STD	Y+3,R24
    03A14 EE88      LDI	R24,0xE8
    03A15 E093      LDI	R25,3
    03A16 E0A0      LDI	R26,0
    03A17 E0B0      LDI	R27,0
    03A18 8429      LDD	R2,Y+9
    03A19 843A      LDD	R3,Y+10
    03A1A 844B      LDD	R4,Y+11
    03A1B 845C      LDD	R5,Y+12
    03A1C 1A28      SUB	R2,R24
    03A1D 0A39      SBC	R3,R25
    03A1E 0A4A      SBC	R4,R26
    03A1F 0A5B      SBC	R5,R27
    03A20 8629      STD	Y+9,R2
    03A21 863A      STD	Y+10,R3
    03A22 864B      STD	Y+11,R4
    03A23 865C      STD	Y+12,R5
    03A24 EE88      LDI	R24,0xE8
    03A25 E093      LDI	R25,3
    03A26 E0A0      LDI	R26,0
    03A27 E0B0      LDI	R27,0
    03A28 8429      LDD	R2,Y+9
    03A29 843A      LDD	R3,Y+10
    03A2A 844B      LDD	R4,Y+11
    03A2B 845C      LDD	R5,Y+12
    03A2C 1628      CP	R2,R24
    03A2D 0639      CPC	R3,R25
    03A2E 064A      CPC	R4,R26
    03A2F 065B      CPC	R5,R27
    03A30 F700      BCC	0x3A11
(0091) 	if(da[3])	i=0;
    03A31 802B      LDD	R2,Y+3
    03A32 2022      TST	R2
    03A33 F009      BEQ	0x3A35
    03A34 2744      CLR	R20
(0092) 	if(i==0)	Usart_Transmit('0'+da[3]);
    03A35 2344      TST	R20
    03A36 F4B9      BNE	0x3A4E
    03A37 810B      LDD	R16,Y+3
    03A38 5D00      SUBI	R16,0xD0
    03A39 DECA      RCALL	_Usart_Transmit
    03A3A C013      RJMP	0x3A4E
(0093) 	while(data>=100L)     { ++da[2];data-=100L;}
    03A3B 818A      LDD	R24,Y+2
    03A3C 5F8F      SUBI	R24,0xFF
    03A3D 838A      STD	Y+2,R24
    03A3E E684      LDI	R24,0x64
    03A3F E090      LDI	R25,0
    03A40 E0A0      LDI	R26,0
    03A41 E0B0      LDI	R27,0
    03A42 8429      LDD	R2,Y+9
    03A43 843A      LDD	R3,Y+10
    03A44 844B      LDD	R4,Y+11
    03A45 845C      LDD	R5,Y+12
    03A46 1A28      SUB	R2,R24
    03A47 0A39      SBC	R3,R25
    03A48 0A4A      SBC	R4,R26
    03A49 0A5B      SBC	R5,R27
    03A4A 8629      STD	Y+9,R2
    03A4B 863A      STD	Y+10,R3
    03A4C 864B      STD	Y+11,R4
    03A4D 865C      STD	Y+12,R5
    03A4E E684      LDI	R24,0x64
    03A4F E090      LDI	R25,0
    03A50 E0A0      LDI	R26,0
    03A51 E0B0      LDI	R27,0
    03A52 8429      LDD	R2,Y+9
    03A53 843A      LDD	R3,Y+10
    03A54 844B      LDD	R4,Y+11
    03A55 845C      LDD	R5,Y+12
    03A56 1628      CP	R2,R24
    03A57 0639      CPC	R3,R25
    03A58 064A      CPC	R4,R26
    03A59 065B      CPC	R5,R27
    03A5A F700      BCC	0x3A3B
(0094) 	if(da[2])	i=0;
    03A5B 802A      LDD	R2,Y+2
    03A5C 2022      TST	R2
    03A5D F009      BEQ	0x3A5F
    03A5E 2744      CLR	R20
(0095) 	if(i==0)	Usart_Transmit('0'+da[2]);
    03A5F 2344      TST	R20
    03A60 F4B9      BNE	0x3A78
    03A61 810A      LDD	R16,Y+2
    03A62 5D00      SUBI	R16,0xD0
    03A63 DEA0      RCALL	_Usart_Transmit
    03A64 C013      RJMP	0x3A78
(0096) 	while(data>=10L)      { ++da[1];data-=10L;}
    03A65 8189      LDD	R24,Y+1
    03A66 5F8F      SUBI	R24,0xFF
    03A67 8389      STD	Y+1,R24
    03A68 E08A      LDI	R24,0xA
    03A69 E090      LDI	R25,0
    03A6A E0A0      LDI	R26,0
    03A6B E0B0      LDI	R27,0
    03A6C 8429      LDD	R2,Y+9
    03A6D 843A      LDD	R3,Y+10
    03A6E 844B      LDD	R4,Y+11
    03A6F 845C      LDD	R5,Y+12
    03A70 1A28      SUB	R2,R24
    03A71 0A39      SBC	R3,R25
    03A72 0A4A      SBC	R4,R26
    03A73 0A5B      SBC	R5,R27
    03A74 8629      STD	Y+9,R2
    03A75 863A      STD	Y+10,R3
    03A76 864B      STD	Y+11,R4
    03A77 865C      STD	Y+12,R5
    03A78 E08A      LDI	R24,0xA
    03A79 E090      LDI	R25,0
    03A7A E0A0      LDI	R26,0
    03A7B E0B0      LDI	R27,0
    03A7C 8429      LDD	R2,Y+9
    03A7D 843A      LDD	R3,Y+10
    03A7E 844B      LDD	R4,Y+11
    03A7F 845C      LDD	R5,Y+12
    03A80 1628      CP	R2,R24
    03A81 0639      CPC	R3,R25
    03A82 064A      CPC	R4,R26
    03A83 065B      CPC	R5,R27
    03A84 F700      BCC	0x3A65
(0097) 	if(da[1])	i=0;
    03A85 8029      LDD	R2,Y+1
    03A86 2022      TST	R2
    03A87 F009      BEQ	0x3A89
    03A88 2744      CLR	R20
(0098) 	if(i==0)	Usart_Transmit('0'+da[1]);
    03A89 2344      TST	R20
    03A8A F419      BNE	0x3A8E
    03A8B 8109      LDD	R16,Y+1
    03A8C 5D00      SUBI	R16,0xD0
    03A8D DE76      RCALL	_Usart_Transmit
(0099) 	Usart_Transmit('0'+data);
    03A8E E380      LDI	R24,0x30
    03A8F E090      LDI	R25,0
    03A90 E0A0      LDI	R26,0
    03A91 E0B0      LDI	R27,0
    03A92 8429      LDD	R2,Y+9
    03A93 843A      LDD	R3,Y+10
    03A94 844B      LDD	R4,Y+11
    03A95 845C      LDD	R5,Y+12
    03A96 0E28      ADD	R2,R24
    03A97 1E39      ADC	R3,R25
    03A98 1E4A      ADC	R4,R26
    03A99 1E5B      ADC	R5,R27
    03A9A 2D02      MOV	R16,R2
    03A9B DE68      RCALL	_Usart_Transmit
    03A9C 9628      ADIW	R28,0x8
    03A9D 9149      LD	R20,Y+
    03A9E 9624      ADIW	R28,4
    03A9F 9508      RET
_PrintChar:
  h                    --> R20
  d                    --> R22
    03AA0 934A      ST	-Y,R20
    03AA1 936A      ST	-Y,R22
    03AA2 2F60      MOV	R22,R16
(0100)  
(0101) }
(0102)  
(0103) void PrintChar(unsigned char d)
(0104) {
(0105) 	unsigned char h=(d&0xF0)>>4;
    03AA3 2F46      MOV	R20,R22
    03AA4 7F40      ANDI	R20,0xF0
    03AA5 9542      SWAP	R20
    03AA6 704F      ANDI	R20,0xF
(0106) 	if(h<10)	Usart_Transmit('0'+h);
    03AA7 304A      CPI	R20,0xA
    03AA8 F420      BCC	0x3AAD
    03AA9 2F04      MOV	R16,R20
    03AAA 5D00      SUBI	R16,0xD0
    03AAB DE58      RCALL	_Usart_Transmit
    03AAC C003      RJMP	0x3AB0
(0107) 	else		Usart_Transmit('A'-10+h);
    03AAD 2F04      MOV	R16,R20
    03AAE 5C09      SUBI	R16,0xC9
    03AAF DE54      RCALL	_Usart_Transmit
(0108) 	h=d&0x0f;
    03AB0 2F46      MOV	R20,R22
    03AB1 704F      ANDI	R20,0xF
(0109) 	if(h<10)	Usart_Transmit('0'+h);
    03AB2 304A      CPI	R20,0xA
    03AB3 F420      BCC	0x3AB8
    03AB4 2F04      MOV	R16,R20
    03AB5 5D00      SUBI	R16,0xD0
    03AB6 DE4D      RCALL	_Usart_Transmit
    03AB7 C003      RJMP	0x3ABB
(0110) 	else		Usart_Transmit('A'-10+h);
    03AB8 2F04      MOV	R16,R20
    03AB9 5C09      SUBI	R16,0xC9
    03ABA DE49      RCALL	_Usart_Transmit
(0111) 	Usart_Transmit(' ');
    03ABB E200      LDI	R16,0x20
    03ABC DE47      RCALL	_Usart_Transmit
    03ABD 9169      LD	R22,Y+
    03ABE 9149      LD	R20,Y+
    03ABF 9508      RET
FILE: D:\LQD\software\software_src\SPI.c
(0001) //*****************************************************************************//
(0002) //*								 
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SPI接口控制
(0006) //*****************************************************************************//
(0007) #include "SPI.h"
(0008) 
(0009) /******************************************************************
(0010) SPI接口函数初始化
(0011) ******************************************************************/
(0012) void SPI_IO_Init(void)
(0013) {
(0014) 	SPI_PORT |= (1<<SS);////拉高CS
_SPI_IO_Init:
    03AC0 9AC0      SBI	0x18,0
(0015) 	SPI_DDR |= (1<<SCLK)|(1<<MOSI)|(1<<SS);////CS,CLK,MOSI设为输出
    03AC1 B387      IN	R24,0x17
    03AC2 6087      ORI	R24,7
    03AC3 BB87      OUT	0x17,R24
(0016) 	SPI_DDR &=~(1<<MISO);//MISO设为输入
    03AC4 98BB      CBI	0x17,3
(0017) 	SPI_PORT |= (1<<SCLK);//拉高CLK
    03AC5 9AC1      SBI	0x18,1
(0018) 	SPI_High();//SPI高通
    03AC6 E580      LDI	R24,0x50
    03AC7 B98D      OUT	0x0D,R24
    03AC8 9A70      SBI	0x0E,0
    03AC9 9508      RET
(0019) }
(0020) /******************************************************************
(0021) SPI写一个字节
(0022) ******************************************************************/
(0023) void SPI_Write(UINT8 data)
(0024) {
(0025) 	SPDR = data;
_SPI_Write:
  data                 --> R16
    03ACA B90F      OUT	0x0F,R16
(0026) 	while ((SPSR&(1<<SPIF))==0);
    03ACB 9B77      SBIS	0x0E,7
    03ACC CFFE      RJMP	0x3ACB
    03ACD 9508      RET
(0027) 	//loop_until_bit_is_set(SPSR,SPIF);
(0028) }
(0029) /******************************************************************
(0030) SPI读一个字节
(0031) ******************************************************************/
(0032) unsigned char SPI_Read(void)
(0033) {
(0034) 	SPDR = 0xFF;//写0xFF启动SPI
_SPI_Read:
    03ACE EF8F      LDI	R24,0xFF
    03ACF B98F      OUT	0x0F,R24
(0035) 	while ((SPSR&(1<<SPIF))==0);
    03AD0 9B77      SBIS	0x0E,7
    03AD1 CFFE      RJMP	0x3AD0
(0036) 	//loop_until_bit_is_set(SPSR,SPIF);//等待SPIF为高电平
(0037) 	return  SPDR;//返回读取值
    03AD2 B10F      IN	R16,0x0F
    03AD3 9508      RET
FILE: D:\LQD\software\software_src\lcd.c
(0001) #include "config.h"
(0002) 
(0003) //此硬件引脚适合冷强度检测仪第2版电路  mega128
(0004) #define LCD_PIN_CS   4
(0005) #define LCD_PIN_SID  3
(0006) #define LCD_PIN_SCLK 2
(0007) #define LCD_PIN_RST  1
(0008) #define LCD_BACKLIGHT_SW		0
(0009) #define LCD_PORT PORTC
(0010) #define LCD_PIN_DDR DDRC
(0011) #define Set_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT |= (1<<LCD_PIN_CS) 
(0012) #define Set_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT |= (1<<LCD_PIN_SID) 
(0013) #define Set_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT |= (1<<LCD_PIN_SCLK) 
(0014) #define LCD_LIGHT_ON()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT |= (1<<LCD_BACKLIGHT_SW) 
(0015) #define Set_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT |= (1<<LCD_PIN_RST) 
(0016) 
(0017) #define Clr_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT &=~(1<<LCD_PIN_CS) 
(0018) #define Clr_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT &=~(1<<LCD_PIN_SID) 
(0019) #define Clr_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT &=~(1<<LCD_PIN_SCLK) 
(0020) #define LCD_LIGHT_OFF()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT &=~(1<<LCD_BACKLIGHT_SW) 
(0021) #define Clr_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT &=~(1<<LCD_PIN_RST) 
(0022)  
(0023) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data); 
(0024) void Write_8bits(unsigned int W_bits); 
(0025) void LCD_Init(void); 
(0026) unsigned char LCD_INT(void); 
(0027) 
(0028) unsigned char LCD_SW(unsigned char i)
(0029) {
(0030)  if(i==0){
_LCD_SW:
  i                    --> R16
    03AD4 2300      TST	R16
    03AD5 F421      BNE	0x3ADA
(0031)  LCD_LIGHT_OFF();
    03AD6 9AA0      SBI	0x14,0
    03AD7 98A8      CBI	0x15,0
(0032)  return 0;
    03AD8 2700      CLR	R16
    03AD9 C003      RJMP	0x3ADD
(0033)  }
(0034)  else{
(0035)  LCD_LIGHT_ON();
    03ADA 9AA0      SBI	0x14,0
    03ADB 9AA8      SBI	0x15,0
(0036)  return 1;
    03ADC E001      LDI	R16,1
    03ADD 9508      RET
(0037)  }
(0038)  
(0039) }
(0040)  
(0041) unsigned char LCD_INT(void) 
(0042) { 
(0043)   Clr_CS(); 
_LCD_INT:
    03ADE 9AA4      SBI	0x14,4
    03ADF 98AC      CBI	0x15,4
(0044)   Clr_SID(); 
    03AE0 9AA3      SBI	0x14,3
    03AE1 98AB      CBI	0x15,3
(0045)   Clr_SCLK(); 
    03AE2 9AA2      SBI	0x14,2
    03AE3 98AA      CBI	0x15,2
(0046)   LCD_Init(); 
    03AE4 D097      RCALL	_LCD_Init
(0047)   return (0);
    03AE5 2700      CLR	R16
    03AE6 9508      RET
_address:
  a                    --> R20
  y                    --> R18
  x                    --> R16
    03AE7 940E 42B9 CALL	push_xgsetF000
(0048) } 
(0049)   
(0050) /******************************************************************** 
(0051) 函数 名：address
(0052) 入口参数：地址转换
(0053) 出口参数：无 
(0054) 函数作用： 
(0055) 说        明： 
(0056) ********************************************************************/ 
(0057) unsigned char address(unsigned char x,unsigned char y)
(0058) {  
(0059)  unsigned char a;
(0060) 
(0061) switch(x) 
    03AE9 2F60      MOV	R22,R16
    03AEA 2777      CLR	R23
    03AEB 3061      CPI	R22,1
    03AEC E0E0      LDI	R30,0
    03AED 077E      CPC	R23,R30
    03AEE F069      BEQ	0x3AFC
    03AEF 3062      CPI	R22,2
    03AF0 E0E0      LDI	R30,0
    03AF1 077E      CPC	R23,R30
    03AF2 F059      BEQ	0x3AFE
    03AF3 3063      CPI	R22,3
    03AF4 E0E0      LDI	R30,0
    03AF5 077E      CPC	R23,R30
    03AF6 F049      BEQ	0x3B00
    03AF7 3064      CPI	R22,4
    03AF8 E0E0      LDI	R30,0
    03AF9 077E      CPC	R23,R30
    03AFA F039      BEQ	0x3B02
    03AFB C007      RJMP	0x3B03
(0062) { 
(0063) case 1: 
(0064) {a=0x80;break;} 
    03AFC E840      LDI	R20,0x80
    03AFD C005      RJMP	0x3B03
(0065) case 2: 
(0066) {a=0x90;break;} 
    03AFE E940      LDI	R20,0x90
    03AFF C003      RJMP	0x3B03
(0067)   case 3: 
(0068) {a=0x88;break;} 
    03B00 E848      LDI	R20,0x88
    03B01 C001      RJMP	0x3B03
(0069)   case 4: 
(0070) {a=0x98;break;} 
    03B02 E948      LDI	R20,0x98
(0071) } 
(0072) a=a+y-1;
    03B03 0F42      ADD	R20,R18
    03B04 5041      SUBI	R20,1
(0073) 
(0074) return a;
    03B05 2F04      MOV	R16,R20
    03B06 940C 42BE JMP	pop_xgsetF000
_LCD_const_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    03B08 940E 42A6 CALL	push_xgset30FC
    03B0A 2EE2      MOV	R14,R18
    03B0B 2EC0      MOV	R12,R16
    03B0C 9721      SBIW	R28,1
    03B0D 84A9      LDD	R10,Y+9
    03B0E 84BA      LDD	R11,Y+10
(0075) }
(0076)  
(0077) //////////////////////////////////////////////////////////////
(0078) 
(0079) /******************************************************************** 
(0080) 函数 名：LCD_const_disp
(0081) 入口参数：x y  *single_data
(0082) 出口参数：无 
(0083) 函数作用：负责 显示一串常量
(0084) 说        明： 
(0085) ********************************************************************/ 
(0086) void LCD_const_disp(unsigned char x, unsigned char y, const unsigned char *single_data) 
(0087) { 
(0088) unsigned char  a,i; 
(0089) a=address(x,y);
    03B0F 2D2E      MOV	R18,R14
    03B10 2D0C      MOV	R16,R12
    03B11 DFD5      RCALL	_address
    03B12 2EC0      MOV	R12,R16
(0090) W_1byte(0,0,a);     //显示的地址 
    03B13 82C8      ST	Y,R12
    03B14 2722      CLR	R18
    03B15 2700      CLR	R16
    03B16 D0B7      RCALL	_W_1byte
(0091)    for(i=0; single_data[i]!='\0';i++) 
    03B17 2744      CLR	R20
    03B18 C00D      RJMP	0x3B26
(0092)    {
(0093)     if(i>=16) break; 
    03B19 3140      CPI	R20,0x10
    03B1A F008      BCS	0x3B1C
    03B1B C011      RJMP	0x3B2D
(0094)     W_1byte(0,1,single_data[i]); 
    03B1C 2FE4      MOV	R30,R20
    03B1D 27FF      CLR	R31
    03B1E 0DEA      ADD	R30,R10
    03B1F 1DFB      ADC	R31,R11
    03B20 8020      LD	R2,Z
    03B21 8228      ST	Y,R2
    03B22 E021      LDI	R18,1
    03B23 2700      CLR	R16
    03B24 D0A9      RCALL	_W_1byte
    03B25 9543      INC	R20
    03B26 2FE4      MOV	R30,R20
    03B27 27FF      CLR	R31
    03B28 0DEA      ADD	R30,R10
    03B29 1DFB      ADC	R31,R11
    03B2A 8020      LD	R2,Z
    03B2B 2022      TST	R2
    03B2C F761      BNE	0x3B19
(0095)     
(0096)    } 
(0097)    W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03B2D EF8F      LDI	R24,0xFF
    03B2E 8388      ST	Y,R24
    03B2F 2722      CLR	R18
    03B30 2700      CLR	R16
    03B31 D09C      RCALL	_W_1byte
    03B32 9621      ADIW	R28,1
    03B33 940C 4290 JMP	pop_xgset30FC
_LCD_var_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    03B35 940E 42A6 CALL	push_xgset30FC
    03B37 2EE2      MOV	R14,R18
    03B38 2EC0      MOV	R12,R16
    03B39 9721      SBIW	R28,1
    03B3A 84A9      LDD	R10,Y+9
    03B3B 84BA      LDD	R11,Y+10
(0098)  
(0099) } 
(0100) 
(0101) /******************************************************************** 
(0102) 函数 名：LCD_var_disp
(0103) 入口参数：single_row single_line  *single_data
(0104) 出口参数：无 
(0105) 函数作用：负责 显示一串变量
(0106) 说        明： 
(0107) ********************************************************************/ 
(0108) 
(0109) void LCD_var_disp(unsigned char x, unsigned char y, unsigned char *single_data) 
(0110) { 
(0111) unsigned char  a,i; 
(0112) 
(0113) #if _debug == 1 
(0114) 	PrintString_n(single_data);
(0115) #endif 
(0116) 
(0117) a=address( x,y);
    03B3C 2D2E      MOV	R18,R14
    03B3D 2D0C      MOV	R16,R12
    03B3E DFA8      RCALL	_address
    03B3F 2EC0      MOV	R12,R16
(0118) W_1byte(0,0,a);     //显示的地址0x88 
    03B40 82C8      ST	Y,R12
    03B41 2722      CLR	R18
    03B42 2700      CLR	R16
    03B43 D08A      RCALL	_W_1byte
(0119) 
(0120) for(i=0; single_data[i]!='\0';i++) 
    03B44 2744      CLR	R20
    03B45 C00D      RJMP	0x3B53
(0121)    { 
(0122)     if(i>=16) break;
    03B46 3140      CPI	R20,0x10
    03B47 F008      BCS	0x3B49
    03B48 C011      RJMP	0x3B5A
(0123)     W_1byte(0,1,single_data[i]); 
    03B49 2FE4      MOV	R30,R20
    03B4A 27FF      CLR	R31
    03B4B 0DEA      ADD	R30,R10
    03B4C 1DFB      ADC	R31,R11
    03B4D 8020      LD	R2,Z
    03B4E 8228      ST	Y,R2
    03B4F E021      LDI	R18,1
    03B50 2700      CLR	R16
    03B51 D07C      RCALL	_W_1byte
    03B52 9543      INC	R20
    03B53 2FE4      MOV	R30,R20
    03B54 27FF      CLR	R31
    03B55 0DEA      ADD	R30,R10
    03B56 1DFB      ADC	R31,R11
    03B57 8020      LD	R2,Z
    03B58 2022      TST	R2
    03B59 F761      BNE	0x3B46
(0124) 	} 
(0125)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03B5A EF8F      LDI	R24,0xFF
    03B5B 8388      ST	Y,R24
    03B5C 2722      CLR	R18
    03B5D 2700      CLR	R16
    03B5E D06F      RCALL	_W_1byte
    03B5F 9621      ADIW	R28,1
    03B60 940C 4290 JMP	pop_xgset30FC
_LCD_char_disp:
  a                    --> R12
  data                 --> R10
  y                    --> R14
  x                    --> R12
    03B62 940E 42A8 CALL	push_xgset00FC
    03B64 2EE2      MOV	R14,R18
    03B65 2EC0      MOV	R12,R16
    03B66 9721      SBIW	R28,1
    03B67 80AF      LDD	R10,Y+7
(0126) } 
(0127) /******************************************************************** 
(0128) 函数 名：LCD_char_disp
(0129) 入口参数：single_row single_line  data
(0130) 出口参数：无 
(0131) 函数作用：负责 显示一个 变量
(0132) 说        明： 
(0133) ********************************************************************/ 
(0134) 
(0135) void LCD_char_disp(unsigned char x, unsigned char y, unsigned char data) 
(0136) { 
(0137) unsigned char a; 
(0138) a=address(x,y);
    03B68 2D2E      MOV	R18,R14
    03B69 2D0C      MOV	R16,R12
    03B6A DF7C      RCALL	_address
    03B6B 2EC0      MOV	R12,R16
(0139) W_1byte(0,0,a);     //显示的地址 
    03B6C 82C8      ST	Y,R12
    03B6D 2722      CLR	R18
    03B6E 2700      CLR	R16
    03B6F D05E      RCALL	_W_1byte
(0140) W_1byte(0,1,data);  //显示内容
    03B70 82A8      ST	Y,R10
    03B71 E021      LDI	R18,1
    03B72 2700      CLR	R16
    03B73 D05A      RCALL	_W_1byte
(0141)  
(0142)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03B74 EF8F      LDI	R24,0xFF
    03B75 8388      ST	Y,R24
    03B76 2722      CLR	R18
    03B77 2700      CLR	R16
    03B78 D055      RCALL	_W_1byte
    03B79 9621      ADIW	R28,1
    03B7A 940C 4289 JMP	pop_xgset00FC
_LCD_Init:
  cmd                  --> R20
    03B7C 934A      ST	-Y,R20
    03B7D 9721      SBIW	R28,1
(0143) } 
(0144) 
(0145) /******************************************************************** 
(0146) 函数 名：LCD_Init
(0147) 入口参数：无
(0148) 出口参数：unsigned char  0/1
(0149) 函数作用：负责 清空液晶显示
(0150) 说        明： 
(0151) ********************************************************************/ 
(0152) void LCD_Init(void) 
(0153) { 
(0154)    unsigned char cmd; 
(0155)    cmd=0x30;      //功能设置 8 位数据，基本指令 
    03B7E E340      LDI	R20,0x30
(0156)   W_1byte(0,0,cmd); 
    03B7F 8348      ST	Y,R20
    03B80 2722      CLR	R18
    03B81 2700      CLR	R16
    03B82 D04B      RCALL	_W_1byte
(0157)   delayms(2); 
    03B83 E002      LDI	R16,2
    03B84 E010      LDI	R17,0
    03B85 940E 2440 CALL	_delayms
(0158)   cmd=0x0C;      //显示状态 ON，游标OFF，反白OFF 
    03B87 E04C      LDI	R20,0xC
(0159)   W_1byte(0,0,cmd); //写指令 
    03B88 8348      ST	Y,R20
    03B89 2722      CLR	R18
    03B8A 2700      CLR	R16
    03B8B D042      RCALL	_W_1byte
(0160)   delayms(2); 
    03B8C E002      LDI	R16,2
    03B8D E010      LDI	R17,0
    03B8E 940E 2440 CALL	_delayms
(0161)   cmd=0x01;      //清除显示 
    03B90 E041      LDI	R20,1
(0162)   W_1byte(0,0,cmd); //写指令 
    03B91 8348      ST	Y,R20
    03B92 2722      CLR	R18
    03B93 2700      CLR	R16
    03B94 D039      RCALL	_W_1byte
(0163)   delayms(2); 
    03B95 E002      LDI	R16,2
    03B96 E010      LDI	R17,0
    03B97 940E 2440 CALL	_delayms
(0164)   cmd=0x02;      //地址归位 
    03B99 E042      LDI	R20,2
(0165)   W_1byte(0,0,cmd); //写指令 
    03B9A 8348      ST	Y,R20
    03B9B 2722      CLR	R18
    03B9C 2700      CLR	R16
    03B9D D030      RCALL	_W_1byte
(0166)   delayms(2); 
    03B9E E002      LDI	R16,2
    03B9F E010      LDI	R17,0
    03BA0 940E 2440 CALL	_delayms
(0167)   cmd=0x80;      //设置DDRAM 地址 
    03BA2 E840      LDI	R20,0x80
(0168)   W_1byte(0,0,cmd); //写指令 
    03BA3 8348      ST	Y,R20
    03BA4 2722      CLR	R18
    03BA5 2700      CLR	R16
    03BA6 D027      RCALL	_W_1byte
(0169)   delayms(2);     //延时 
    03BA7 E002      LDI	R16,2
    03BA8 E010      LDI	R17,0
    03BA9 940E 2440 CALL	_delayms
    03BAB 9621      ADIW	R28,1
    03BAC 9149      LD	R20,Y+
    03BAD 9508      RET
_LCD_CLR:
  cmd                  --> R20
    03BAE 934A      ST	-Y,R20
    03BAF 9721      SBIW	R28,1
(0170) } 
(0171) 
(0172) void LCD_CLR(void)
(0173) {
(0174) unsigned char cmd;
(0175)   cmd=0x01;      //清除显示 
    03BB0 E041      LDI	R20,1
(0176)   W_1byte(0,0,cmd); //写指令 
    03BB1 8348      ST	Y,R20
    03BB2 2722      CLR	R18
    03BB3 2700      CLR	R16
    03BB4 D019      RCALL	_W_1byte
(0177)   delayms(1); 
    03BB5 E001      LDI	R16,1
    03BB6 E010      LDI	R17,0
    03BB7 940E 2440 CALL	_delayms
(0178)   cmd=0x02;      //地址归位 
    03BB9 E042      LDI	R20,2
(0179)   W_1byte(0,0,cmd); //写指令 
    03BBA 8348      ST	Y,R20
    03BBB 2722      CLR	R18
    03BBC 2700      CLR	R16
    03BBD D010      RCALL	_W_1byte
(0180)   delayms(1); 
    03BBE E001      LDI	R16,1
    03BBF E010      LDI	R17,0
    03BC0 940E 2440 CALL	_delayms
(0181)   cmd=0x80;      //设置DDRAM 地址 
    03BC2 E840      LDI	R20,0x80
(0182)   W_1byte(0,0,cmd); //写指令 
    03BC3 8348      ST	Y,R20
    03BC4 2722      CLR	R18
    03BC5 2700      CLR	R16
    03BC6 D007      RCALL	_W_1byte
(0183)   delayms(1);     //延时
    03BC7 E001      LDI	R16,1
    03BC8 E010      LDI	R17,0
    03BC9 940E 2440 CALL	_delayms
    03BCB 9621      ADIW	R28,1
    03BCC 9149      LD	R20,Y+
    03BCD 9508      RET
_W_1byte:
  H_data               --> R22
  S_ID                 --> R10
  L_data               --> R20
  W_data               --> R12
  RS                   --> R14
  RW                   --> R20
    03BCE 940E 42A4 CALL	push_xgsetF0FC
    03BD0 2EE2      MOV	R14,R18
    03BD1 2F40      MOV	R20,R16
    03BD2 84CA      LDD	R12,Y+10
(0184) 
(0185) }
(0186)  
(0187) /*******************************************************************
(0188) 函 数 名：W_1byte
(0189) 入口参数：RW、RS、W_data
(0190) 出口参数：无
(0191) 建立日期：2007年3月3日
(0192) 修改日期：
(0193) 函数作用：写一个字节的数据到12864液晶，包括指令和数据
(0194) 说    明：RW=1，从液晶读数据到MCU；RW=0，写一个数据到液晶；
(0195) 		 （一般RW都设为0，即只向液晶写数据，不读数据）
(0196)           RS=1，写入的是数据；RS=0，写入的是指令；
(0197) 		  一般模式：RW=0，RS=1;写数据
(0198) 		  			RW=0，RS=0;写指令
(0199) ********************************************************************/
(0200) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data)
(0201) {
(0202) 	unsigned int H_data,L_data,S_ID = 0xf8;	 //11111RWRS0
    03BD3 EF88      LDI	R24,0xF8
    03BD4 E090      LDI	R25,0
    03BD5 015C      MOVW	R10,R24
(0203) 	if(RW == 0)
    03BD6 2344      TST	R20
    03BD7 F419      BNE	0x3BDB
(0204) 	{
(0205) 	 	S_ID &=~ 0x04;
    03BD8 7F8B      ANDI	R24,0xFB
    03BD9 015C      MOVW	R10,R24
(0206) 	}
    03BDA C003      RJMP	0x3BDE
(0207) 	else					//if(RW==1)
(0208) 	{
(0209) 	 	S_ID |= 0X04;
    03BDB 01C5      MOVW	R24,R10
    03BDC 6084      ORI	R24,4
    03BDD 015C      MOVW	R10,R24
(0210) 	}
(0211) 	if(RS == 0)
    03BDE 20EE      TST	R14
    03BDF F421      BNE	0x3BE4
(0212) 	{
(0213) 	 	S_ID &=~ 0x02;
    03BE0 01C5      MOVW	R24,R10
    03BE1 7F8D      ANDI	R24,0xFD
    03BE2 015C      MOVW	R10,R24
(0214) 	}
    03BE3 C003      RJMP	0x3BE7
(0215) 	else					//if(RS==1)
(0216) 	{
(0217) 	 	S_ID |= 0X02;
    03BE4 01C5      MOVW	R24,R10
    03BE5 6082      ORI	R24,2
    03BE6 015C      MOVW	R10,R24
(0218) 	}
(0219) 	H_data = W_data;
    03BE7 2D6C      MOV	R22,R12
    03BE8 2777      CLR	R23
(0220) 	H_data &= 0xf0;			//屏蔽低4位的数据
    03BE9 7F60      ANDI	R22,0xF0
    03BEA 7070      ANDI	R23,0
(0221) 	L_data = W_data;	   	//xxxx0000格式
    03BEB 2D4C      MOV	R20,R12
    03BEC 2755      CLR	R21
(0222) 	L_data &= 0x0f;			//屏蔽高4位的数据
    03BED 704F      ANDI	R20,0xF
    03BEE 7050      ANDI	R21,0
(0223) 	L_data <<= 4;			//xxxx0000格式
    03BEF 0F44      LSL	R20
    03BF0 1F55      ROL	R21
    03BF1 0F44      LSL	R20
    03BF2 1F55      ROL	R21
    03BF3 0F44      LSL	R20
    03BF4 1F55      ROL	R21
    03BF5 0F44      LSL	R20
    03BF6 1F55      ROL	R21
(0224) 	Set_CS();
    03BF7 9AA4      SBI	0x14,4
    03BF8 9AAC      SBI	0x15,4
(0225) 	Write_8bits(S_ID); 		//发送S_ID
    03BF9 0185      MOVW	R16,R10
    03BFA D00C      RCALL	_Write_8bits
(0226) 	Write_8bits(H_data);	//发送H_data
    03BFB 018B      MOVW	R16,R22
    03BFC D00A      RCALL	_Write_8bits
(0227) 	Write_8bits(L_data);	//发送L_data
    03BFD 018A      MOVW	R16,R20
    03BFE D008      RCALL	_Write_8bits
(0228) 	Clr_CS();	Clr_CS();	Clr_CS();	
    03BFF 9AA4      SBI	0x14,4
    03C00 98AC      CBI	0x15,4
    03C01 9AA4      SBI	0x14,4
    03C02 98AC      CBI	0x15,4
    03C03 9AA4      SBI	0x14,4
    03C04 98AC      CBI	0x15,4
    03C05 940C 4299 JMP	pop_xgsetF0FC
_Write_8bits:
  Temp_data            --> R12
  i                    --> R20
  W_bits               --> R10
    03C07 940E 42D1 CALL	push_xgset303C
    03C09 0158      MOVW	R10,R16
(0229) 	 
(0230) 
(0231) }
(0232) /********************************************************************
(0233) 函 数 名：Write_8bits
(0234) 入口参数：W_bits
(0235) 出口参数：无
(0236) 建立日期：2007年3月3日
(0237) 修改日期：
(0238) 函数作用：负责串行输出8个bit位
(0239) 说    明：
(0240) ********************************************************************/
(0241) void Write_8bits(unsigned int W_bits)
(0242) {
(0243) 	unsigned int i,Temp_data;
(0244) 	for(i=0; i<8; i++)
    03C0A 2744      CLR	R20
    03C0B 2755      CLR	R21
    03C0C C019      RJMP	0x3C26
(0245) 	{
(0246) 		Temp_data = W_bits;
    03C0D 0165      MOVW	R12,R10
(0247) 		Temp_data <<= i;
    03C0E 019A      MOVW	R18,R20
    03C0F 0186      MOVW	R16,R12
    03C10 940E 431F CALL	lsl16
    03C12 0168      MOVW	R12,R16
(0248) 		if((Temp_data&0x80)==0) 
    03C13 FD07      SBRC	R16,7
    03C14 C003      RJMP	0x3C18
(0249) 		{
(0250) 		 	Clr_SID();
    03C15 9AA3      SBI	0x14,3
    03C16 98AB      CBI	0x15,3
(0251) 		}
    03C17 C002      RJMP	0x3C1A
(0252) 		else
(0253) 		{
(0254) 		 	Set_SID();
    03C18 9AA3      SBI	0x14,3
    03C19 9AAB      SBI	0x15,3
(0255) 		} 
(0256) 		NOP();
    03C1A 0000      NOP
(0257) 		Set_SCLK();
    03C1B 9AA2      SBI	0x14,2
    03C1C 9AAA      SBI	0x15,2
(0258) 		NOP();
    03C1D 0000      NOP
(0259) 		NOP();
    03C1E 0000      NOP
(0260) 		Clr_SCLK();
    03C1F 9AA2      SBI	0x14,2
    03C20 98AA      CBI	0x15,2
(0261) 		NOP();
    03C21 0000      NOP
(0262) 		Clr_SID();
    03C22 9AA3      SBI	0x14,3
    03C23 98AB      CBI	0x15,3
    03C24 5F4F      SUBI	R20,0xFF
    03C25 4F5F      SBCI	R21,0xFF
    03C26 3048      CPI	R20,0x8
    03C27 E0E0      LDI	R30,0
    03C28 075E      CPC	R21,R30
    03C29 F318      BCS	0x3C0D
    03C2A 940C 42D8 JMP	pop_xgset303C
_Set_Draw:
    03C2C 9721      SBIW	R28,1
(0263) 	}
(0264) }
(0265)  
(0266) /********************************************************************
(0267) 函 数 名：Set_Draw(
(0268) 入口参数：无
(0269) 出口参数：无
(0270) 函数作用：设置为绘图模式
(0271) 说    明：
(0272) ********************************************************************/
(0273) void Set_Draw(void)
(0274) {  	
(0275) 	//W_1byte(0,0,0x34);			//8BIT控制界面，扩充指令集,，绘图显示OFF
(0276) 	W_1byte(0,0,0x36);
    03C2D E386      LDI	R24,0x36
    03C2E 8388      ST	Y,R24
    03C2F 2722      CLR	R18
    03C30 2700      CLR	R16
    03C31 DF9C      RCALL	_W_1byte
(0277) 	delayms(1);					//延时
    03C32 E001      LDI	R16,1
    03C33 E010      LDI	R17,0
    03C34 940E 2440 CALL	_delayms
    03C36 9621      ADIW	R28,1
    03C37 9508      RET
_Set_White:
  clr_y                --> R10
  clr_x                --> R20
  white_y              --> Y,+2
  white_x              --> Y,+1
  i                    --> R22
  white_end_x          --> R12
  j                    --> R14
  clear                --> Y,+15
  end_x                --> R12
  y                    --> R14
  x                    --> R22
    03C38 940E 42A4 CALL	push_xgsetF0FC
    03C3A 2EE2      MOV	R14,R18
    03C3B 2F60      MOV	R22,R16
    03C3C 9723      SBIW	R28,3
    03C3D 84CD      LDD	R12,Y+13
(0278) } 
(0279)  
(0280) 
(0281) /******************************************************************** 
(0282) 函数 名：Set_White 
(0283) 入口参数：  x,   y,  end_x,  clear
(0284) 出口参数：无 
(0285) 函数作用： 设置反显
(0286) 说        明： 
(0287) ********************************************************************/ 
(0288) void Set_White(unsigned char x,unsigned char y,unsigned char end_x,unsigned char clear)
(0289) {
(0290)  
(0291) 	unsigned char i, j, white_x, white_y,white_end_x,clr_x,clr_y ;		//
(0292)   
(0293) 	W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03C3E E386      LDI	R24,0x36
    03C3F 8388      ST	Y,R24
    03C40 2722      CLR	R18
    03C41 2700      CLR	R16
    03C42 DF8B      RCALL	_W_1byte
(0294) 	delayus(20);					//延时
    03C43 E104      LDI	R16,0x14
    03C44 E010      LDI	R17,0
    03C45 940E 2438 CALL	_delayus
(0295)  
(0296) 	white_end_x = (end_x-x+1);
    03C47 2D8C      MOV	R24,R12
    03C48 1B86      SUB	R24,R22
    03C49 5F8F      SUBI	R24,0xFF
    03C4A 2EC8      MOV	R12,R24
(0297) 	white_end_x <<= 1;
    03C4B 0CCC      LSL	R12
(0298) 	if(y==1)   //x,1  a=80+x-1                   
    03C4C 2D8E      MOV	R24,R14
    03C4D 3081      CPI	R24,1
    03C4E F449      BNE	0x3C58
(0299) 	{
(0300) 	 	white_x = (0x80+x-1); 
    03C4F 2F86      MOV	R24,R22
    03C50 5880      SUBI	R24,0x80
    03C51 5081      SUBI	R24,1
    03C52 8389      STD	Y+1,R24
(0301) 		white_y = 0x80;
    03C53 E880      LDI	R24,0x80
    03C54 838A      STD	Y+2,R24
(0302) 		clr_x = 0x80;
    03C55 E840      LDI	R20,0x80
(0303) 		clr_y = 0x80;
    03C56 2EA8      MOV	R10,R24
(0304) 	}
    03C57 C023      RJMP	0x3C7B
(0305) 	else if(y==2)
    03C58 2D8E      MOV	R24,R14
    03C59 3082      CPI	R24,2
    03C5A F449      BNE	0x3C64
(0306) 	{
(0307) 	 	white_x = (0x80+x-1);
    03C5B 2F86      MOV	R24,R22
    03C5C 5880      SUBI	R24,0x80
    03C5D 5081      SUBI	R24,1
    03C5E 8389      STD	Y+1,R24
(0308) 		white_y = 0x90;
    03C5F E980      LDI	R24,0x90
    03C60 838A      STD	Y+2,R24
(0309) 		clr_x = 0x80;
    03C61 E840      LDI	R20,0x80
(0310) 		clr_y = 0x90;
    03C62 2EA8      MOV	R10,R24
(0311) 	}
    03C63 C017      RJMP	0x3C7B
(0312) 	else if(y==3)
    03C64 2D8E      MOV	R24,R14
    03C65 3083      CPI	R24,3
    03C66 F449      BNE	0x3C70
(0313) 	{
(0314) 	 	white_x = (0x88+x-1);
    03C67 2F86      MOV	R24,R22
    03C68 5788      SUBI	R24,0x78
    03C69 5081      SUBI	R24,1
    03C6A 8389      STD	Y+1,R24
(0315) 		white_y = 0x80;
    03C6B E880      LDI	R24,0x80
    03C6C 838A      STD	Y+2,R24
(0316) 		clr_x = 0x88;
    03C6D E848      LDI	R20,0x88
(0317) 		clr_y = 0x80;
    03C6E 2EA8      MOV	R10,R24
(0318) 	}
    03C6F C00B      RJMP	0x3C7B
(0319) 	else if(y==4)
    03C70 2D8E      MOV	R24,R14
    03C71 3084      CPI	R24,4
    03C72 F441      BNE	0x3C7B
(0320) 	{
(0321) 	 	white_x = (0x88+x-1);
    03C73 2F86      MOV	R24,R22
    03C74 5788      SUBI	R24,0x78
    03C75 5081      SUBI	R24,1
    03C76 8389      STD	Y+1,R24
(0322) 		white_y = 0x90;
    03C77 E980      LDI	R24,0x90
    03C78 838A      STD	Y+2,R24
(0323) 		clr_x = 0x88;
    03C79 E848      LDI	R20,0x88
(0324) 		clr_y = 0x90;
    03C7A 2EA8      MOV	R10,R24
(0325) 	}
(0326)   if(clear==0)//要反白时，先将整行的液晶全部清成不反白（此处行指y）
    03C7B 840F      LDD	R0,Y+15
    03C7C 2000      TST	R0
    03C7D F4E9      BNE	0x3C9B
(0327) 	{
(0328) 	 	for(i=0;i<16;i++ )			//16行
    03C7E 2766      CLR	R22
    03C7F C019      RJMP	0x3C99
(0329) 		{
(0330) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03C80 2C2A      MOV	R2,R10
    03C81 2D82      MOV	R24,R2
    03C82 5F8F      SUBI	R24,0xFF
    03C83 2EA8      MOV	R10,R24
    03C84 8228      ST	Y,R2
    03C85 2722      CLR	R18
    03C86 2700      CLR	R16
    03C87 DF46      RCALL	_W_1byte
(0331) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03C88 8348      ST	Y,R20
    03C89 2722      CLR	R18
    03C8A 2700      CLR	R16
    03C8B DF42      RCALL	_W_1byte
(0332) 			for(j=0;j<16;j++)		//
    03C8C 24EE      CLR	R14
    03C8D C007      RJMP	0x3C95
(0333) 			{
(0334) 			 	W_1byte(0,1,0x00);	//清成不反白
    03C8E 2422      CLR	R2
    03C8F 8228      ST	Y,R2
    03C90 E021      LDI	R18,1
    03C91 2700      CLR	R16
    03C92 DF3B      RCALL	_W_1byte
(0335) 			 	nop();
    03C93 0000      NOP
    03C94 94E3      INC	R14
    03C95 2D8E      MOV	R24,R14
    03C96 3180      CPI	R24,0x10
    03C97 F3B0      BCS	0x3C8E
    03C98 9563      INC	R22
    03C99 3160      CPI	R22,0x10
    03C9A F328      BCS	0x3C80
(0336) 			}
(0337) 		}
(0338) 	}
(0339) 	nop();
    03C9B 0000      NOP
(0340) //	
(0341) 	for(i=0;i<16;i++ )				//16行，因为是16*16汉字
    03C9C 2766      CLR	R22
    03C9D C022      RJMP	0x3CC0
(0342) 	{
(0343) 		W_1byte(0,0,white_y++);		//设置绘图区的Y地址坐标0
    03C9E 802A      LDD	R2,Y+2
    03C9F 2D82      MOV	R24,R2
    03CA0 5F8F      SUBI	R24,0xFF
    03CA1 838A      STD	Y+2,R24
    03CA2 8228      ST	Y,R2
    03CA3 2722      CLR	R18
    03CA4 2700      CLR	R16
    03CA5 DF28      RCALL	_W_1byte
(0344) 		W_1byte(0,0,white_x);		//设置绘图区的X地址坐标0
    03CA6 8009      LDD	R0,Y+1
    03CA7 8208      ST	Y,R0
    03CA8 2722      CLR	R18
    03CA9 2700      CLR	R16
    03CAA DF23      RCALL	_W_1byte
(0345) 		for(j=0;j<white_end_x;j++)	//
    03CAB 24EE      CLR	R14
    03CAC C010      RJMP	0x3CBD
(0346) 		{
(0347) 			 if(clear==1)
    03CAD 858F      LDD	R24,Y+15
    03CAE 3081      CPI	R24,1
    03CAF F431      BNE	0x3CB6
(0348) 			 {
(0349) 			  	W_1byte(0,1,0x00); //取消这一行的8个点的反白，液晶地址自动加1
    03CB0 2422      CLR	R2
    03CB1 8228      ST	Y,R2
    03CB2 E021      LDI	R18,1
    03CB3 2700      CLR	R16
    03CB4 DF19      RCALL	_W_1byte
(0350) 								   //（此处行指一个一个液晶点所组成的行）
(0351) 			 }
    03CB5 C005      RJMP	0x3CBB
(0352) 			 else
(0353) 			 {
(0354) 				W_1byte(0,1,0xff); //反白这一行的8个点，液晶地址自动加1
    03CB6 EF8F      LDI	R24,0xFF
    03CB7 8388      ST	Y,R24
    03CB8 E021      LDI	R18,1
    03CB9 2700      CLR	R16
    03CBA DF13      RCALL	_W_1byte
(0355) 								   //（此处行指一个一个液晶点所组成的行）
(0356) 			 }
(0357) 			nop();
    03CBB 0000      NOP
    03CBC 94E3      INC	R14
    03CBD 14EC      CP	R14,R12
    03CBE F370      BCS	0x3CAD
    03CBF 9563      INC	R22
    03CC0 3160      CPI	R22,0x10
    03CC1 F2E0      BCS	0x3C9E
(0358) 		}
(0359) 	}
(0360) 	W_1byte(0,0,0x30);		//基本指令集,，绘图显示OFF
    03CC2 E380      LDI	R24,0x30
    03CC3 8388      ST	Y,R24
    03CC4 2722      CLR	R18
    03CC5 2700      CLR	R16
    03CC6 DF07      RCALL	_W_1byte
    03CC7 9623      ADIW	R28,3
    03CC8 940C 4299 JMP	pop_xgsetF0FC
_set_white_n:
  tempendx             --> R10
  tempy                --> R22
  tempx                --> R20
  clear                --> R12
  n                    --> R14
    03CCA 940E 42A4 CALL	push_xgsetF0FC
    03CCC 2EC2      MOV	R12,R18
    03CCD 2EE0      MOV	R14,R16
    03CCE 9723      SBIW	R28,3
(0361)  }
(0362) 
(0363) /******************************************************************** 
(0364) 函数 名：set_white_n
(0365) 入口参数： n ,  clear
(0366) 出口参数：无 
(0367) 函数作用：   将四行分成八个位置。n代表位置1-8。本函数用于反显或取消反显
(0368)           某一位置的文字。
(0369) 说        明： 例如 set_white_n(1,0); 表示反显第一行前四个字
(0370) ********************************************************************/ 
(0371) void set_white_n(unsigned char n,unsigned char clear)
(0372) {
(0373) unsigned char tempx,tempy,tempendx;
(0374) if(n==1) {tempx=1;tempy=1;tempendx=4;}
    03CCF 2D8E      MOV	R24,R14
    03CD0 3081      CPI	R24,1
    03CD1 F429      BNE	0x3CD7
    03CD2 E041      LDI	R20,1
    03CD3 E061      LDI	R22,1
    03CD4 E084      LDI	R24,4
    03CD5 2EA8      MOV	R10,R24
    03CD6 C037      RJMP	0x3D0E
(0375) else if(n==2) {tempx=5;tempy=1;tempendx=8;}
    03CD7 2D8E      MOV	R24,R14
    03CD8 3082      CPI	R24,2
    03CD9 F429      BNE	0x3CDF
    03CDA E045      LDI	R20,5
    03CDB E061      LDI	R22,1
    03CDC E088      LDI	R24,0x8
    03CDD 2EA8      MOV	R10,R24
    03CDE C02F      RJMP	0x3D0E
(0376) else if(n==3) {tempx=1;tempy=2;tempendx=4;}
    03CDF 2D8E      MOV	R24,R14
    03CE0 3083      CPI	R24,3
    03CE1 F429      BNE	0x3CE7
    03CE2 E041      LDI	R20,1
    03CE3 E062      LDI	R22,2
    03CE4 E084      LDI	R24,4
    03CE5 2EA8      MOV	R10,R24
    03CE6 C027      RJMP	0x3D0E
(0377) else if(n==4) {tempx=5;tempy=2;tempendx=8;}
    03CE7 2D8E      MOV	R24,R14
    03CE8 3084      CPI	R24,4
    03CE9 F429      BNE	0x3CEF
    03CEA E045      LDI	R20,5
    03CEB E062      LDI	R22,2
    03CEC E088      LDI	R24,0x8
    03CED 2EA8      MOV	R10,R24
    03CEE C01F      RJMP	0x3D0E
(0378) else if(n==5) {tempx=1;tempy=3;tempendx=4;}
    03CEF 2D8E      MOV	R24,R14
    03CF0 3085      CPI	R24,5
    03CF1 F429      BNE	0x3CF7
    03CF2 E041      LDI	R20,1
    03CF3 E063      LDI	R22,3
    03CF4 E084      LDI	R24,4
    03CF5 2EA8      MOV	R10,R24
    03CF6 C017      RJMP	0x3D0E
(0379) else if(n==6) {tempx=5;tempy=3;tempendx=8;}
    03CF7 2D8E      MOV	R24,R14
    03CF8 3086      CPI	R24,6
    03CF9 F429      BNE	0x3CFF
    03CFA E045      LDI	R20,5
    03CFB E063      LDI	R22,3
    03CFC E088      LDI	R24,0x8
    03CFD 2EA8      MOV	R10,R24
    03CFE C00F      RJMP	0x3D0E
(0380) else if(n==7) {tempx=1;tempy=4;tempendx=4;}
    03CFF 2D8E      MOV	R24,R14
    03D00 3087      CPI	R24,7
    03D01 F429      BNE	0x3D07
    03D02 E041      LDI	R20,1
    03D03 E064      LDI	R22,4
    03D04 E084      LDI	R24,4
    03D05 2EA8      MOV	R10,R24
    03D06 C007      RJMP	0x3D0E
(0381) else if(n==8) {tempx=5;tempy=4;tempendx=8;}
    03D07 2D8E      MOV	R24,R14
    03D08 3088      CPI	R24,0x8
    03D09 F421      BNE	0x3D0E
    03D0A E045      LDI	R20,5
    03D0B E064      LDI	R22,4
    03D0C E088      LDI	R24,0x8
    03D0D 2EA8      MOV	R10,R24
(0382) Set_White(tempx,tempy,tempendx,clear);
    03D0E 82CA      STD	Y+2,R12
    03D0F 82A8      ST	Y,R10
    03D10 2F26      MOV	R18,R22
    03D11 2F04      MOV	R16,R20
    03D12 DF25      RCALL	_Set_White
    03D13 9623      ADIW	R28,3
    03D14 940C 4299 JMP	pop_xgsetF0FC
_clr_white:
  clr_x                --> R10
  clr_y                --> R20
  i                    --> R22
  j                    --> R12
    03D16 940E 42A4 CALL	push_xgsetF0FC
    03D18 9721      SBIW	R28,1
(0383) 
(0384) }
(0385)  
(0386) /******************************************************************** 
(0387) 函数 名：clr_white
(0388) 入口参数： 清所有 反白
(0389) 出口参数：无 
(0390) 函数作用： 
(0391) 说        明： 
(0392) ********************************************************************/ 
(0393) void clr_white(void)
(0394) {      unsigned char i,j;
(0395) 
(0396)        unsigned char  clr_y=0x80;
    03D19 E840      LDI	R20,0x80
(0397) 	   unsigned char  clr_x=0x80;
    03D1A E880      LDI	R24,0x80
    03D1B 2EA8      MOV	R10,R24
(0398) 	   W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03D1C E386      LDI	R24,0x36
    03D1D 8388      ST	Y,R24
    03D1E 2722      CLR	R18
    03D1F 2700      CLR	R16
    03D20 DEAD      RCALL	_W_1byte
(0399) 	 	for(i=0;i<16;i++ )			//16行
    03D21 2766      CLR	R22
    03D22 C017      RJMP	0x3D3A
(0400) 		{
(0401) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03D23 2E24      MOV	R2,R20
    03D24 5F4F      SUBI	R20,0xFF
    03D25 8228      ST	Y,R2
    03D26 2722      CLR	R18
    03D27 2700      CLR	R16
    03D28 DEA5      RCALL	_W_1byte
(0402) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03D29 82A8      ST	Y,R10
    03D2A 2722      CLR	R18
    03D2B 2700      CLR	R16
    03D2C DEA1      RCALL	_W_1byte
(0403) 			for(j=0;j<16;j++)		//
    03D2D 24CC      CLR	R12
    03D2E C007      RJMP	0x3D36
(0404) 			{
(0405) 			 	W_1byte(0,1,0x00);	//清成不反白
    03D2F 2422      CLR	R2
    03D30 8228      ST	Y,R2
    03D31 E021      LDI	R18,1
    03D32 2700      CLR	R16
    03D33 DE9A      RCALL	_W_1byte
(0406) 			 	nop();
    03D34 0000      NOP
    03D35 94C3      INC	R12
    03D36 2D8C      MOV	R24,R12
    03D37 3180      CPI	R24,0x10
    03D38 F3B0      BCS	0x3D2F
    03D39 9563      INC	R22
    03D3A 3160      CPI	R22,0x10
    03D3B F338      BCS	0x3D23
(0407) 			}
(0408) 		}
(0409) 	
(0410) 	    clr_y=0x80;
    03D3C E840      LDI	R20,0x80
(0411) 	    clr_x=0x90;
    03D3D E980      LDI	R24,0x90
    03D3E 2EA8      MOV	R10,R24
(0412) 		 	for(i=0;i<16;i++ )			//16行
    03D3F 2766      CLR	R22
    03D40 C017      RJMP	0x3D58
(0413) 		{
(0414) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03D41 2E24      MOV	R2,R20
    03D42 5F4F      SUBI	R20,0xFF
    03D43 8228      ST	Y,R2
    03D44 2722      CLR	R18
    03D45 2700      CLR	R16
    03D46 DE87      RCALL	_W_1byte
(0415) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03D47 82A8      ST	Y,R10
    03D48 2722      CLR	R18
    03D49 2700      CLR	R16
    03D4A DE83      RCALL	_W_1byte
(0416) 			for(j=0;j<16;j++)		//
    03D4B 24CC      CLR	R12
    03D4C C007      RJMP	0x3D54
(0417) 			{
(0418) 			 	W_1byte(0,1,0x00);	//清成不反白
    03D4D 2422      CLR	R2
    03D4E 8228      ST	Y,R2
    03D4F E021      LDI	R18,1
    03D50 2700      CLR	R16
    03D51 DE7C      RCALL	_W_1byte
(0419) 			 	nop();
    03D52 0000      NOP
    03D53 94C3      INC	R12
    03D54 2D8C      MOV	R24,R12
    03D55 3180      CPI	R24,0x10
    03D56 F3B0      BCS	0x3D4D
    03D57 9563      INC	R22
    03D58 3160      CPI	R22,0x10
    03D59 F338      BCS	0x3D41
(0420) 			}
(0421) 		}   
(0422) 	   
(0423) 	     clr_y=0x88;
    03D5A E848      LDI	R20,0x88
(0424) 	     clr_x=0x80;
    03D5B E880      LDI	R24,0x80
    03D5C 2EA8      MOV	R10,R24
(0425) 		 	for(i=0;i<16;i++ )			//16行
    03D5D 2766      CLR	R22
    03D5E C017      RJMP	0x3D76
(0426) 		{
(0427) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03D5F 2EE4      MOV	R14,R20
    03D60 5F4F      SUBI	R20,0xFF
    03D61 82E8      ST	Y,R14
    03D62 2722      CLR	R18
    03D63 2700      CLR	R16
    03D64 DE69      RCALL	_W_1byte
(0428) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03D65 82A8      ST	Y,R10
    03D66 2722      CLR	R18
    03D67 2700      CLR	R16
    03D68 DE65      RCALL	_W_1byte
(0429) 			for(j=0;j<16;j++)		//
    03D69 24CC      CLR	R12
    03D6A C007      RJMP	0x3D72
(0430) 			{
(0431) 			 	W_1byte(0,1,0x00);	//清成不反白
    03D6B 2422      CLR	R2
    03D6C 8228      ST	Y,R2
    03D6D E021      LDI	R18,1
    03D6E 2700      CLR	R16
    03D6F DE5E      RCALL	_W_1byte
(0432) 			 	nop();
    03D70 0000      NOP
    03D71 94C3      INC	R12
    03D72 2D8C      MOV	R24,R12
    03D73 3180      CPI	R24,0x10
    03D74 F3B0      BCS	0x3D6B
    03D75 9563      INC	R22
    03D76 3160      CPI	R22,0x10
    03D77 F338      BCS	0x3D5F
(0433) 			}
(0434) 		} 
(0435) 	     clr_y=0x88;
    03D78 E848      LDI	R20,0x88
(0436) 	     clr_x=0x90;
    03D79 E980      LDI	R24,0x90
    03D7A 2EA8      MOV	R10,R24
(0437) 		 	for(i=0;i<16;i++ )			//16行
    03D7B 2766      CLR	R22
    03D7C C017      RJMP	0x3D94
(0438) 		{
(0439) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03D7D 2EE4      MOV	R14,R20
    03D7E 5F4F      SUBI	R20,0xFF
    03D7F 82E8      ST	Y,R14
    03D80 2722      CLR	R18
    03D81 2700      CLR	R16
    03D82 DE4B      RCALL	_W_1byte
(0440) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03D83 82A8      ST	Y,R10
    03D84 2722      CLR	R18
    03D85 2700      CLR	R16
    03D86 DE47      RCALL	_W_1byte
(0441) 			for(j=0;j<16;j++)		//
    03D87 24CC      CLR	R12
    03D88 C007      RJMP	0x3D90
(0442) 			{
(0443) 			 	W_1byte(0,1,0x00);	//清成不反白
    03D89 2422      CLR	R2
    03D8A 8228      ST	Y,R2
    03D8B E021      LDI	R18,1
    03D8C 2700      CLR	R16
    03D8D DE40      RCALL	_W_1byte
(0444) 			 	nop();
    03D8E 0000      NOP
    03D8F 94C3      INC	R12
    03D90 2D8C      MOV	R24,R12
    03D91 3180      CPI	R24,0x10
    03D92 F3B0      BCS	0x3D89
    03D93 9563      INC	R22
    03D94 3160      CPI	R22,0x10
    03D95 F338      BCS	0x3D7D
(0445) 			}
(0446) 		} 		
(0447)   W_1byte(0,0,0x30);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03D96 E380      LDI	R24,0x30
    03D97 8388      ST	Y,R24
    03D98 2722      CLR	R18
    03D99 2700      CLR	R16
    03D9A DE33      RCALL	_W_1byte
    03D9B 9621      ADIW	R28,1
    03D9C 940C 4299 JMP	pop_xgsetF0FC
_LCD_print2num:
  a                    --> R12
  tem                  --> R20
  num                  --> R10
  y                    --> R14
  x                    --> R12
    03D9E 940E 42A6 CALL	push_xgset30FC
    03DA0 2EE2      MOV	R14,R18
    03DA1 2EC0      MOV	R12,R16
    03DA2 9721      SBIW	R28,1
    03DA3 84A9      LDD	R10,Y+9
(0448) 	}
(0449) /******************************************************************** 
(0450) 函数 名：LCD_print2num
(0451) 入口参数： 显示2数字
(0452) 出口参数：无 
(0453) 函数作用： 
(0454) 说        明： 
(0455) ********************************************************************/ 
(0456) void LCD_print2num(unsigned char x,unsigned char y,unsigned char num){
(0457) unsigned char tem;
(0458) unsigned char a; 
(0459) 
(0460) a=address(x,y);
    03DA4 2D2E      MOV	R18,R14
    03DA5 2D0C      MOV	R16,R12
    03DA6 DD40      RCALL	_address
    03DA7 2EC0      MOV	R12,R16
(0461) W_1byte(0,0,a);     //显示的地址 
    03DA8 82C8      ST	Y,R12
    03DA9 2722      CLR	R18
    03DAA 2700      CLR	R16
    03DAB DE22      RCALL	_W_1byte
(0462) tem=num/10;
    03DAC E01A      LDI	R17,0xA
    03DAD 2D0A      MOV	R16,R10
    03DAE 940E 4216 CALL	div8u
    03DB0 2F40      MOV	R20,R16
(0463) W_1byte(0,1,tem+0x30);
    03DB1 2F84      MOV	R24,R20
    03DB2 5D80      SUBI	R24,0xD0
    03DB3 8388      ST	Y,R24
    03DB4 E021      LDI	R18,1
    03DB5 2700      CLR	R16
    03DB6 DE17      RCALL	_W_1byte
(0464) tem=num%10;
    03DB7 E01A      LDI	R17,0xA
    03DB8 2D0A      MOV	R16,R10
    03DB9 940E 4214 CALL	mod8u
    03DBB 2F40      MOV	R20,R16
(0465) W_1byte(0,1,tem+0x30); 
    03DBC 2F84      MOV	R24,R20
    03DBD 5D80      SUBI	R24,0xD0
    03DBE 8388      ST	Y,R24
    03DBF E021      LDI	R18,1
    03DC0 2700      CLR	R16
    03DC1 DE0C      RCALL	_W_1byte
(0466) W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03DC2 EF8F      LDI	R24,0xFF
    03DC3 8388      ST	Y,R24
    03DC4 2722      CLR	R18
    03DC5 2700      CLR	R16
    03DC6 DE07      RCALL	_W_1byte
    03DC7 9621      ADIW	R28,1
    03DC8 940C 4290 JMP	pop_xgset30FC
_LCD_print4num:
  tem                  --> R12
  num                  --> R14
  y                    --> R20
  x                    --> R10
    03DCA 940E 42A6 CALL	push_xgset30FC
    03DCC 2F42      MOV	R20,R18
    03DCD 2EA0      MOV	R10,R16
    03DCE 9721      SBIW	R28,1
    03DCF 84E9      LDD	R14,Y+9
    03DD0 84FA      LDD	R15,Y+10
(0467) }
(0468)  
(0469) /******************************************************************** 
(0470) 函数 名：LCD_print4num
(0471) 入口参数： 显示4数字
(0472) 出口参数：无 
(0473) 函数作用： 
(0474) 说        明： 
(0475) ********************************************************************/ 
(0476) void LCD_print4num(unsigned char x,unsigned char y,unsigned int num){
(0477) unsigned char tem;
(0478) tem=num/100;
    03DD1 E624      LDI	R18,0x64
    03DD2 E030      LDI	R19,0
    03DD3 0187      MOVW	R16,R14
    03DD4 940E 4190 CALL	div16u
    03DD6 2EC0      MOV	R12,R16
(0479) LCD_print2num(x,y,tem);
    03DD7 82C8      ST	Y,R12
    03DD8 2F24      MOV	R18,R20
    03DD9 2D0A      MOV	R16,R10
    03DDA DFC3      RCALL	_LCD_print2num
(0480) 
(0481) tem=num%100;   
    03DDB E624      LDI	R18,0x64
    03DDC E030      LDI	R19,0
    03DDD 0187      MOVW	R16,R14
    03DDE 940E 418E CALL	mod16u
    03DE0 2EC0      MOV	R12,R16
(0482) LCD_print2num(x,y+1,tem);
    03DE1 82C8      ST	Y,R12
    03DE2 2F24      MOV	R18,R20
    03DE3 5F2F      SUBI	R18,0xFF
    03DE4 2D0A      MOV	R16,R10
    03DE5 DFB8      RCALL	_LCD_print2num
(0483) 
(0484) 
(0485)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03DE6 EF8F      LDI	R24,0xFF
    03DE7 8388      ST	Y,R24
    03DE8 2722      CLR	R18
    03DE9 2700      CLR	R16
    03DEA DDE3      RCALL	_W_1byte
    03DEB 9621      ADIW	R28,1
    03DEC 940C 4290 JMP	pop_xgset30FC
_LCD_print:
  a                    --> R12
  ch                   --> R10
  y                    --> R14
  x                    --> R12
    03DEE 940E 42A8 CALL	push_xgset00FC
    03DF0 2EE2      MOV	R14,R18
    03DF1 2EC0      MOV	R12,R16
    03DF2 9721      SBIW	R28,1
    03DF3 80AF      LDD	R10,Y+7
(0486) }
(0487)  
(0488) //////////////////////////////////////////////////////////////
(0489) 
(0490) /******************************************************************** 
(0491) 函数 名：LCD_print 
(0492) 入口参数： 显示1 ascii
(0493) 出口参数：无 
(0494) 函数作用： 
(0495) 说        明： 
(0496) ********************************************************************/ 
(0497) void LCD_print(unsigned char x,unsigned char y,unsigned char ch)
(0498) {  
(0499) unsigned char a; 
(0500) a=address(x,y);
    03DF4 2D2E      MOV	R18,R14
    03DF5 2D0C      MOV	R16,R12
    03DF6 DCF0      RCALL	_address
    03DF7 2EC0      MOV	R12,R16
(0501) W_1byte(0,0,a);     //显示的地址 
    03DF8 82C8      ST	Y,R12
    03DF9 2722      CLR	R18
    03DFA 2700      CLR	R16
    03DFB DDD2      RCALL	_W_1byte
(0502) W_1byte(0,1,ch); 
    03DFC 82A8      ST	Y,R10
    03DFD E021      LDI	R18,1
    03DFE 2700      CLR	R16
    03DFF DDCE      RCALL	_W_1byte
    03E00 9621      ADIW	R28,1
    03E01 940C 4289 JMP	pop_xgset00FC
_LCD_print1:
  ch                   --> R10
    03E03 92AA      ST	-Y,R10
    03E04 2EA0      MOV	R10,R16
    03E05 9721      SBIW	R28,1
(0503) 
(0504) 
(0505) 
(0506) }
(0507) /******************************************************************** 
(0508) 函数 名：LCD_print1 
(0509) 入口参数： 显示1 ascii
(0510) 出口参数：无 
(0511) 函数作用：接着上文地址显示，不重设地址 
(0512) 说        明： 
(0513) ********************************************************************/ 
(0514) void LCD_print1(char ch)
(0515) {  
(0516) W_1byte(0,1,ch); 
    03E06 82A8      ST	Y,R10
    03E07 E021      LDI	R18,1
    03E08 2700      CLR	R16
    03E09 DDC4      RCALL	_W_1byte
    03E0A 9621      ADIW	R28,1
    03E0B 90A9      LD	R10,Y+
    03E0C 9508      RET
_lp:
  p                    --> R10
    03E0D 92AA      ST	-Y,R10
    03E0E 92BA      ST	-Y,R11
    03E0F 0158      MOVW	R10,R16
    03E10 9722      SBIW	R28,2
(0517) }
(0518) //////////////////////////////////////////////////////////////
(0519) 
(0520) 
(0521) 
(0522)  void lp(unsigned char *p)
(0523)  {
(0524)  static unsigned char *p1=" ",*p2=" ",*p3=" ",*p4=" ";
(0525)  p4=p3;
    03E11 9020 0555 LDS	R2,lcd.c:p3
    03E13 9030 0556 LDS	R3,lcd.c:p3+1
    03E15 9230 0558 STS	lcd.c:p4+1,R3
    03E17 9220 0557 STS	lcd.c:p4,R2
(0526)  p3=p2;
    03E19 9020 0553 LDS	R2,lcd.c:p2
    03E1B 9030 0554 LDS	R3,lcd.c:p2+1
    03E1D 9230 0556 STS	lcd.c:p3+1,R3
    03E1F 9220 0555 STS	lcd.c:p3,R2
(0527)  p2=p1;
    03E21 9020 0551 LDS	R2,lcd.c:p1
    03E23 9030 0552 LDS	R3,lcd.c:p1+1
    03E25 9230 0554 STS	lcd.c:p2+1,R3
    03E27 9220 0553 STS	lcd.c:p2,R2
(0528)  p1=p;
    03E29 92B0 0552 STS	lcd.c:p1+1,R11
    03E2B 92A0 0551 STS	lcd.c:p1,R10
(0529)   LCD_const_disp(1,1,"                ");
    03E2D E589      LDI	R24,0x59
    03E2E E095      LDI	R25,5
    03E2F 8399      STD	Y+1,R25
    03E30 8388      ST	Y,R24
    03E31 E021      LDI	R18,1
    03E32 E001      LDI	R16,1
    03E33 DCD4      RCALL	_LCD_const_disp
(0530)   LCD_const_disp(2,1,"                ");
    03E34 E589      LDI	R24,0x59
    03E35 E095      LDI	R25,5
    03E36 8399      STD	Y+1,R25
    03E37 8388      ST	Y,R24
    03E38 E021      LDI	R18,1
    03E39 E002      LDI	R16,2
    03E3A DCCD      RCALL	_LCD_const_disp
(0531)   LCD_const_disp(3,1,"                ");
    03E3B E589      LDI	R24,0x59
    03E3C E095      LDI	R25,5
    03E3D 8399      STD	Y+1,R25
    03E3E 8388      ST	Y,R24
    03E3F E021      LDI	R18,1
    03E40 E003      LDI	R16,3
    03E41 DCC6      RCALL	_LCD_const_disp
(0532)   LCD_const_disp(4,1,"                ");
    03E42 E589      LDI	R24,0x59
    03E43 E095      LDI	R25,5
    03E44 8399      STD	Y+1,R25
    03E45 8388      ST	Y,R24
    03E46 E021      LDI	R18,1
    03E47 E004      LDI	R16,4
    03E48 DCBF      RCALL	_LCD_const_disp
(0533)   LCD_var_disp(1,1,p4);
    03E49 9020 0557 LDS	R2,lcd.c:p4
    03E4B 9030 0558 LDS	R3,lcd.c:p4+1
    03E4D 8239      STD	Y+1,R3
    03E4E 8228      ST	Y,R2
    03E4F E021      LDI	R18,1
    03E50 E001      LDI	R16,1
    03E51 DCE3      RCALL	_LCD_var_disp
(0534)   LCD_var_disp(2,1,p3);
    03E52 9020 0555 LDS	R2,lcd.c:p3
    03E54 9030 0556 LDS	R3,lcd.c:p3+1
    03E56 8239      STD	Y+1,R3
    03E57 8228      ST	Y,R2
    03E58 E021      LDI	R18,1
    03E59 E002      LDI	R16,2
    03E5A DCDA      RCALL	_LCD_var_disp
(0535)   LCD_var_disp(3,1,p2);
    03E5B 9020 0553 LDS	R2,lcd.c:p2
    03E5D 9030 0554 LDS	R3,lcd.c:p2+1
    03E5F 8239      STD	Y+1,R3
    03E60 8228      ST	Y,R2
    03E61 E021      LDI	R18,1
    03E62 E003      LDI	R16,3
    03E63 DCD1      RCALL	_LCD_var_disp
(0536)   LCD_var_disp(4,1,p1);
    03E64 9020 0551 LDS	R2,lcd.c:p1
    03E66 9030 0552 LDS	R3,lcd.c:p1+1
    03E68 8239      STD	Y+1,R3
    03E69 8228      ST	Y,R2
    03E6A E021      LDI	R18,1
    03E6B E004      LDI	R16,4
    03E6C DCC8      RCALL	_LCD_var_disp
(0537)   delayms(300);
    03E6D E20C      LDI	R16,0x2C
    03E6E E011      LDI	R17,1
    03E6F 940E 2440 CALL	_delayms
    03E71 9622      ADIW	R28,2
    03E72 90B9      LD	R11,Y+
    03E73 90A9      LD	R10,Y+
    03E74 9508      RET
FILE: D:\LQD\software\software_src\relay.c
(0001) #include "config.h"
(0002) /*继电器初始化
(0003) *设置端口
(0004) *初始化关闭
(0005) */
(0006) void relay_init(void){
(0007) 	
(0008) 		RELAY_DDR_SET() ;
_relay_init:
    03E75 9AA5      SBI	0x14,5
(0009) 		RELAY_OFF();
    03E76 98AD      CBI	0x15,5
    03E77 9508      RET
(0010) 		//state.Relay = 0;
(0011) 	}	
(0012) 
(0013) /*继电器控制
(0014) *传入 ： 温度
(0015) *传出 ： 当前继电器状态
(0016) *
(0017) */
(0018) unsigned char  relay(int temp)
(0019) {
(0020) 	if(temp<HEAT_THRESHOLD)
_relay:
  temp                 --> R16
    03E78 3005      CPI	R16,5
    03E79 E0E0      LDI	R30,0
    03E7A 071E      CPC	R17,R30
    03E7B F41C      BGE	0x3E7F
(0021) 	{
(0022) 	 		RELAY_DDR_SET();
    03E7C 9AA5      SBI	0x14,5
(0023) 			RELAY_ON();
    03E7D 9AAD      SBI	0x15,5
(0024) 			//state.Relay = 1 ;
(0025) 	}
    03E7E C002      RJMP	0x3E81
(0026) 	else
(0027) 	{
(0028) 	 	RELAY_DDR_SET();
    03E7F 9AA5      SBI	0x14,5
(0029) 		RELAY_OFF();
    03E80 98AD      CBI	0x15,5
(0030) 		//state.Relay = 0 ;
(0031) 	}		
(0032) 	//return state.Relay;
(0033) 	return 0;
    03E81 2700      CLR	R16
    03E82 9508      RET
_beep:
  i                    --> R10
  short_beep           --> R12
  long_beep            --> R14
    03E83 940E 42A8 CALL	push_xgset00FC
    03E85 2EC2      MOV	R12,R18
    03E86 2EE0      MOV	R14,R16
FILE: D:\LQD\software\software_src\beep.c
(0001) #include "config.h"
(0002) 
(0003) #define BEEP_PORT	PORTC
(0004) #define BEEP_PIN	6
(0005) #define BEEP_OFF() BEEP_PORT|=(1<<BEEP_PIN)
(0006) #define BEEP_ON()  BEEP_PORT&=~(1<<BEEP_PIN)
(0007) //楦ｅ
(0008) void beep(unsigned char long_beep,unsigned char short_beep)
(0009) { 
(0010) unsigned char i;
(0011) DDRB|=(1<<0);
    03E87 9AB8      SBI	0x17,0
(0012) for(i=0;i<long_beep;i++)
    03E88 24AA      CLR	R10
    03E89 C00B      RJMP	0x3E95
(0013) {
(0014) BEEP_ON();  delayms(200);
    03E8A 98AE      CBI	0x15,6
    03E8B EC08      LDI	R16,0xC8
    03E8C E010      LDI	R17,0
    03E8D 940E 2440 CALL	_delayms
(0015) BEEP_OFF(); delayms(50);
    03E8F 9AAE      SBI	0x15,6
    03E90 E302      LDI	R16,0x32
    03E91 E010      LDI	R17,0
    03E92 940E 2440 CALL	_delayms
    03E94 94A3      INC	R10
    03E95 14AE      CP	R10,R14
    03E96 F398      BCS	0x3E8A
(0016) }
(0017) delayms(100);
    03E97 E604      LDI	R16,0x64
    03E98 E010      LDI	R17,0
    03E99 940E 2440 CALL	_delayms
(0018) for(i=0;i<short_beep;i++)
    03E9B 24AA      CLR	R10
    03E9C C00B      RJMP	0x3EA8
(0019) {
(0020) BEEP_ON();  delayms(80);
    03E9D 98AE      CBI	0x15,6
    03E9E E500      LDI	R16,0x50
    03E9F E010      LDI	R17,0
    03EA0 940E 2440 CALL	_delayms
(0021) BEEP_OFF(); delayms(50);
    03EA2 9AAE      SBI	0x15,6
    03EA3 E302      LDI	R16,0x32
    03EA4 E010      LDI	R17,0
    03EA5 940E 2440 CALL	_delayms
    03EA7 94A3      INC	R10
    03EA8 14AC      CP	R10,R12
    03EA9 F398      BCS	0x3E9D
    03EAA 940C 4289 JMP	pop_xgset00FC
_Delay_nus:
  i                    --> R20
  n                    --> R16
    03EAC 934A      ST	-Y,R20
    03EAD 935A      ST	-Y,R21
FILE: D:\LQD\software\software_src\DS18B20_driver.c
(0001) //------------------------------------------------------------------------------
(0002) // 文件名：DS18B20_driver.c
(0003) // 说明：  DS18B20驱动头文件
(0004) // 功能：  实现1-wire器件的读写
(0005) // 使用方法：   void Delay_nus(unsigned int n);             //延时n微秒函数
(0006) //              unsigned char reset_18B20(void);            //18B20复位
(0007) //              void write_bit_18B20(char bitval);          //写一位到18B20
(0008) //              unsigned char read_bit_18B20(void);         //读一位从18B20
(0009) //              void write_byte_18B20(unsigned char data);  //写一字节到18B20
(0010) //              unsigned char read_18B20(void);             //读一字节到18B20
(0011) //
(0012) // 运行平台：   AVR 8bit (M16已验证)
(0013) // 依存关系：   DS18B20_driver.h    DS18B20基本驱动头文件（函数声明）
(0014) // 移植人：     
(0015) // 最后修改：   
(0016) //------------------------------------------------------------------------------
(0017) 
(0018) #include "config.h"
(0019) #define DS18B20_PORT PORTG
(0020) #define DS18B20_PIN  PING
(0021) #define DS18B20_DDR  DDRG
(0022) #define CL_DQ   DS18B20_PORT&=~(1<<T_NUM)					   
(0023) #define SET_DQ  DS18B20_PORT|=(1<<T_NUM)			   
(0024) #define SET_OUT DS18B20_DDR|=(1<<T_NUM)				   
(0025) #define SET_IN  DS18B20_DDR&=~(1<<T_NUM)			   
(0026) #define IN_DQ   DS18B20_PIN&(1<<T_NUM)				  
(0027) unsigned char T_NUM=0;
(0028) 
(0029) 
(0030) //------------------------------------------------------------------------------
(0031) // 延时N微秒程序 供控制读写DS18B20时序使用
(0032) //------------------------------------------------------------------------------
(0033) void Delay_nus(unsigned int n)   
(0034) {  unsigned int i;
(0035) 	  for (i=0;i<n;i++) 
    03EAE 2744      CLR	R20
    03EAF 2755      CLR	R21
    03EB0 C005      RJMP	0x3EB6
(0036) 	  		{NOP();
    03EB1 0000      NOP
(0037) 						NOP();
    03EB2 0000      NOP
(0038) 						NOP();				        //20--300//比较接近
    03EB3 0000      NOP
    03EB4 5F4F      SUBI	R20,0xFF
    03EB5 4F5F      SBCI	R21,0xFF
    03EB6 1740      CP	R20,R16
    03EB7 0751      CPC	R21,R17
    03EB8 F3C0      BCS	0x3EB1
    03EB9 9159      LD	R21,Y+
    03EBA 9149      LD	R20,Y+
    03EBB 9508      RET
_reset_18B20:
  bus_flag             --> R10
    03EBC 92AA      ST	-Y,R10
(0039) 					}
(0040) }
(0041) 
(0042) 
(0043) //------------------------------------------------------------------------------
(0044) // 1-wire总线复位
(0045) //------------------------------------------------------------------------------
(0046) unsigned char reset_18B20(void)
(0047) {
(0048) 	char bus_flag;
(0049) 	CLI();
    03EBD 94F8      BCLR	7
(0050) 	SET_DQ;
    03EBE 9110 056C LDS	R17,T_NUM
    03EC0 E001      LDI	R16,1
    03EC1 940E 4332 CALL	lsl8
    03EC3 9020 0065 LDS	R2,0x65
    03EC5 2A20      OR	R2,R16
    03EC6 9220 0065 STS	0x65,R2
(0051) 	SET_OUT;
    03EC8 9110 056C LDS	R17,T_NUM
    03ECA E001      LDI	R16,1
    03ECB 940E 4332 CALL	lsl8
    03ECD 9020 0064 LDS	R2,0x64
    03ECF 2A20      OR	R2,R16
    03ED0 9220 0064 STS	0x64,R2
(0052)  	
(0053)   	Delay_nus(1);
    03ED2 E001      LDI	R16,1
    03ED3 E010      LDI	R17,0
    03ED4 DFD7      RCALL	_Delay_nus
(0054)   	CL_DQ;
    03ED5 9110 056C LDS	R17,T_NUM
    03ED7 E001      LDI	R16,1
    03ED8 940E 4332 CALL	lsl8
    03EDA 2E20      MOV	R2,R16
    03EDB 9420      COM	R2
    03EDC 9030 0065 LDS	R3,0x65
    03EDE 2032      AND	R3,R2
    03EDF 9230 0065 STS	0x65,R3
(0055)   	Delay_nus(550);		//拉低至少480us时间
    03EE1 E206      LDI	R16,0x26
    03EE2 E012      LDI	R17,2
    03EE3 DFC8      RCALL	_Delay_nus
(0056)   	SET_DQ;				//释放
    03EE4 9110 056C LDS	R17,T_NUM
    03EE6 E001      LDI	R16,1
    03EE7 940E 4332 CALL	lsl8
    03EE9 9020 0065 LDS	R2,0x65
    03EEB 2A20      OR	R2,R16
    03EEC 9220 0065 STS	0x65,R2
(0057) 					NOP();
    03EEE 0000      NOP
(0058) 					NOP();
    03EEF 0000      NOP
(0059)   	SET_IN;				//输入
    03EF0 9110 056C LDS	R17,T_NUM
    03EF2 E001      LDI	R16,1
    03EF3 940E 4332 CALL	lsl8
    03EF5 2E20      MOV	R2,R16
    03EF6 9420      COM	R2
    03EF7 9030 0064 LDS	R3,0x64
    03EF9 2032      AND	R3,R2
    03EFA 9230 0064 STS	0x64,R3
(0060)   	Delay_nus(60);
    03EFC E30C      LDI	R16,0x3C
    03EFD E010      LDI	R17,0
    03EFE DFAD      RCALL	_Delay_nus
(0061)   	
(0062) 						//等待回复
(0063)   	bus_flag = IN_DQ;
    03EFF 9110 056C LDS	R17,T_NUM
    03F01 E001      LDI	R16,1
    03F02 940E 4332 CALL	lsl8
    03F04 90A0 0063 LDS	R10,0x63
    03F06 22A0      AND	R10,R16
(0064)   	
(0065)   	Delay_nus(240);		//回复的低电平在60到240US
    03F07 EF00      LDI	R16,0xF0
    03F08 E010      LDI	R17,0
    03F09 DFA2      RCALL	_Delay_nus
(0066)   	SET_OUT;
    03F0A 9110 056C LDS	R17,T_NUM
    03F0C E001      LDI	R16,1
    03F0D 940E 4332 CALL	lsl8
    03F0F 9020 0064 LDS	R2,0x64
    03F11 2A20      OR	R2,R16
    03F12 9220 0064 STS	0x64,R2
(0067) 					NOP();
    03F14 0000      NOP
(0068) 					NOP();
    03F15 0000      NOP
(0069)   	SET_DQ;				//回到初始DQ=1；
    03F16 9110 056C LDS	R17,T_NUM
    03F18 E001      LDI	R16,1
    03F19 940E 4332 CALL	lsl8
    03F1B 9020 0065 LDS	R2,0x65
    03F1D 2A20      OR	R2,R16
    03F1E 9220 0065 STS	0x65,R2
(0070) 
(0071)   	SEI();
    03F20 9478      BSET	7
(0072) 	if(bus_flag){
    03F21 20AA      TST	R10
    03F22 F011      BEQ	0x3F25
(0073) 		return FALSE;
    03F23 2700      CLR	R16
    03F24 C001      RJMP	0x3F26
(0074) 	}else{
(0075) 		return TRUE;
    03F25 E001      LDI	R16,1
    03F26 90A9      LD	R10,Y+
    03F27 9508      RET
_write_bit_18B20:
  bitval               --> R10
    03F28 92AA      ST	-Y,R10
    03F29 2EA0      MOV	R10,R16
(0076) 	}
(0077) 
(0078) }
(0079) 
(0080) //------------------------------------------------------------------------------
(0081) // 写一位到总线
(0082) //------------------------------------------------------------------------------
(0083) void write_bit_18B20(char bitval)
(0084) {
(0085)     SET_OUT;
    03F2A 9110 056C LDS	R17,T_NUM
    03F2C E001      LDI	R16,1
    03F2D 940E 4332 CALL	lsl8
    03F2F 9020 0064 LDS	R2,0x64
    03F31 2A20      OR	R2,R16
    03F32 9220 0064 STS	0x64,R2
(0086) 					NOP();
    03F34 0000      NOP
(0087) 					NOP();
    03F35 0000      NOP
(0088) 			 CL_DQ;
    03F36 9110 056C LDS	R17,T_NUM
    03F38 E001      LDI	R16,1
    03F39 940E 4332 CALL	lsl8
    03F3B 2E20      MOV	R2,R16
    03F3C 9420      COM	R2
    03F3D 9030 0065 LDS	R3,0x65
    03F3F 2032      AND	R3,R2
    03F40 9230 0065 STS	0x65,R3
(0089) 	   Delay_nus(1);
    03F42 E001      LDI	R16,1
    03F43 E010      LDI	R17,0
    03F44 DF67      RCALL	_Delay_nus
(0090) 	   if(bitval){    //写数据，从低位开始
    03F45 20AA      TST	R10
    03F46 F059      BEQ	0x3F52
(0091) 		     SET_DQ;
    03F47 9110 056C LDS	R17,T_NUM
    03F49 E001      LDI	R16,1
    03F4A 940E 4332 CALL	lsl8
    03F4C 9020 0065 LDS	R2,0x65
    03F4E 2A20      OR	R2,R16
    03F4F 9220 0065 STS	0x65,R2
(0092) 	  }else{
    03F51 C00C      RJMP	0x3F5E
(0093) 		     CL_DQ;
    03F52 9110 056C LDS	R17,T_NUM
    03F54 E001      LDI	R16,1
    03F55 940E 4332 CALL	lsl8
    03F57 2E20      MOV	R2,R16
    03F58 9420      COM	R2
    03F59 9030 0065 LDS	R3,0x65
    03F5B 2032      AND	R3,R2
    03F5C 9230 0065 STS	0x65,R3
(0094) 	  }
(0095) 	Delay_nus(40);		//15~60us
    03F5E E208      LDI	R16,0x28
    03F5F E010      LDI	R17,0
    03F60 DF4B      RCALL	_Delay_nus
(0096) 	SET_DQ;
    03F61 9110 056C LDS	R17,T_NUM
    03F63 E001      LDI	R16,1
    03F64 940E 4332 CALL	lsl8
    03F66 9020 0065 LDS	R2,0x65
    03F68 2A20      OR	R2,R16
    03F69 9220 0065 STS	0x65,R2
(0097) 	Delay_nus(10);
    03F6B E00A      LDI	R16,0xA
    03F6C E010      LDI	R17,0
    03F6D DF3E      RCALL	_Delay_nus
    03F6E 90A9      LD	R10,Y+
    03F6F 9508      RET
_read_bit_18B20:
  k                    --> R10
    03F70 92AA      ST	-Y,R10
(0098) }
(0099) 
(0100) //------------------------------------------------------------------------------
(0101) // 读一位从总线
(0102) //------------------------------------------------------------------------------
(0103) unsigned char read_bit_18B20(void)
(0104) {
(0105) 	unsigned char k;
(0106) 	SET_OUT;
    03F71 9110 056C LDS	R17,T_NUM
    03F73 E001      LDI	R16,1
    03F74 940E 4332 CALL	lsl8
    03F76 9020 0064 LDS	R2,0x64
    03F78 2A20      OR	R2,R16
    03F79 9220 0064 STS	0x64,R2
(0107) 	CL_DQ;			//读时间片开始，拉低总线至少1us
    03F7B 9110 056C LDS	R17,T_NUM
    03F7D E001      LDI	R16,1
    03F7E 940E 4332 CALL	lsl8
    03F80 2E20      MOV	R2,R16
    03F81 9420      COM	R2
    03F82 9030 0065 LDS	R3,0x65
    03F84 2032      AND	R3,R2
    03F85 9230 0065 STS	0x65,R3
(0108) 	Delay_nus(1);
    03F87 E001      LDI	R16,1
    03F88 E010      LDI	R17,0
    03F89 DF22      RCALL	_Delay_nus
(0109) 	
(0110) 					//SET_DQ;	
(0111) 	SET_IN;
    03F8A 9110 056C LDS	R17,T_NUM
    03F8C E001      LDI	R16,1
    03F8D 940E 4332 CALL	lsl8
    03F8F 2E20      MOV	R2,R16
    03F90 9420      COM	R2
    03F91 9030 0064 LDS	R3,0x64
    03F93 2032      AND	R3,R2
    03F94 9230 0064 STS	0x64,R3
(0112) 	Delay_nus(4);
    03F96 E004      LDI	R16,4
    03F97 E010      LDI	R17,0
    03F98 DF13      RCALL	_Delay_nus
(0113) 	k=IN_DQ;    	//读数据,从低位开始
    03F99 9110 056C LDS	R17,T_NUM
    03F9B E001      LDI	R16,1
    03F9C 940E 4332 CALL	lsl8
    03F9E 90A0 0063 LDS	R10,0x63
    03FA0 22A0      AND	R10,R16
(0114) 	Delay_nus(10);
    03FA1 E00A      LDI	R16,0xA
    03FA2 E010      LDI	R17,0
    03FA3 DF08      RCALL	_Delay_nus
(0115) 	SET_DQ;	
    03FA4 9110 056C LDS	R17,T_NUM
    03FA6 E001      LDI	R16,1
    03FA7 940E 4332 CALL	lsl8
    03FA9 9020 0065 LDS	R2,0x65
    03FAB 2A20      OR	R2,R16
    03FAC 9220 0065 STS	0x65,R2
(0116) 				NOP();
    03FAE 0000      NOP
(0117) 				NOP();
    03FAF 0000      NOP
(0118) 	SET_OUT;
    03FB0 9110 056C LDS	R17,T_NUM
    03FB2 E001      LDI	R16,1
    03FB3 940E 4332 CALL	lsl8
    03FB5 9020 0064 LDS	R2,0x64
    03FB7 2A20      OR	R2,R16
    03FB8 9220 0064 STS	0x64,R2
(0119) 	    NOP();
    03FBA 0000      NOP
(0120) 					NOP();
    03FBB 0000      NOP
(0121) 	if(k){
    03FBC 20AA      TST	R10
    03FBD F011      BEQ	0x3FC0
(0122) 	    return 1;
    03FBE E001      LDI	R16,1
    03FBF C001      RJMP	0x3FC1
(0123) 	}else{
(0124) 	    return 0;
    03FC0 2700      CLR	R16
    03FC1 90A9      LD	R10,Y+
    03FC2 9508      RET
_write_byte_18B20:
  i                    --> R20
  data                 --> R10
    03FC3 92AA      ST	-Y,R10
    03FC4 934A      ST	-Y,R20
    03FC5 2EA0      MOV	R10,R16
(0125) 	}
(0126) 	
(0127) }
(0128) 
(0129) //------------------------------------------------------------------------------
(0130) // 写一个字节到总线
(0131) //------------------------------------------------------------------------------
(0132) void write_byte_18B20(unsigned char data)
(0133) {
(0134) 	unsigned char i;
(0135)    CLI();
    03FC6 94F8      BCLR	7
(0136)     for(i=0;i<8;i++)
    03FC7 2744      CLR	R20
    03FC8 C009      RJMP	0x3FD2
(0137)     {
(0138)         write_bit_18B20(data&(1<<i));
    03FC9 E001      LDI	R16,1
    03FCA 2F14      MOV	R17,R20
    03FCB 940E 4332 CALL	lsl8
    03FCD 2E20      MOV	R2,R16
    03FCE 2D0A      MOV	R16,R10
    03FCF 2102      AND	R16,R2
    03FD0 DF57      RCALL	_write_bit_18B20
    03FD1 9543      INC	R20
    03FD2 3048      CPI	R20,0x8
    03FD3 F3A8      BCS	0x3FC9
(0139)         
(0140)     }
(0141)     SET_DQ;
    03FD4 9110 056C LDS	R17,T_NUM
    03FD6 E001      LDI	R16,1
    03FD7 940E 4332 CALL	lsl8
    03FD9 9020 0065 LDS	R2,0x65
    03FDB 2A20      OR	R2,R16
    03FDC 9220 0065 STS	0x65,R2
(0142) 				  NOP();
    03FDE 0000      NOP
(0143) 					 NOP();
    03FDF 0000      NOP
(0144)     SEI();
    03FE0 9478      BSET	7
    03FE1 9149      LD	R20,Y+
    03FE2 90A9      LD	R10,Y+
    03FE3 9508      RET
_read_byte_18B20:
  temp                 --> R10
  n                    --> R20
    03FE4 92AA      ST	-Y,R10
    03FE5 934A      ST	-Y,R20
(0145)     
(0146)     //return;
(0147) }
(0148) 
(0149) //------------------------------------------------------------------------------
(0150) // 读一个字节
(0151) //------------------------------------------------------------------------------
(0152) unsigned char read_byte_18B20(void)
(0153) {
(0154) 	unsigned char temp,n;
(0155)     CLI();
    03FE6 94F8      BCLR	7
(0156)   	temp=0;
    03FE7 24AA      CLR	R10
(0157)     for(n=0;n<8;n++)
    03FE8 2744      CLR	R20
    03FE9 C014      RJMP	0x3FFE
(0158)     {
(0159)       	if(read_bit_18B20()){
    03FEA DF85      RCALL	_read_bit_18B20
    03FEB 2300      TST	R16
    03FEC F031      BEQ	0x3FF3
(0160)       		temp|=(1<<n);
    03FED E001      LDI	R16,1
    03FEE 2F14      MOV	R17,R20
    03FEF 940E 4332 CALL	lsl8
    03FF1 2AA0      OR	R10,R16
(0161)       	}else{
    03FF2 C007      RJMP	0x3FFA
(0162)       		temp&=~(1<<n);
    03FF3 E001      LDI	R16,1
    03FF4 2F14      MOV	R17,R20
    03FF5 940E 4332 CALL	lsl8
    03FF7 2E20      MOV	R2,R16
    03FF8 9420      COM	R2
    03FF9 20A2      AND	R10,R2
(0163)       	}
(0164)       	Delay_nus(70); //60~120us
    03FFA E406      LDI	R16,0x46
    03FFB E010      LDI	R17,0
    03FFC DEAF      RCALL	_Delay_nus
    03FFD 9543      INC	R20
    03FFE 3048      CPI	R20,0x8
    03FFF F350      BCS	0x3FEA
(0165)       	
(0166)    }
(0167)    SEI();
    04000 9478      BSET	7
(0168) 
(0169)    return temp;
    04001 2D0A      MOV	R16,R10
    04002 9149      LD	R20,Y+
    04003 90A9      LD	R10,Y+
    04004 9508      RET
(0170) }
(0171) 
(0172) 
(0173) 
(0174) //------------------------------------------------------------------------------
(0175) // 应用函数部分！ 供外部调用
(0176) //------------------------------------------------------------------------------
(0177) //------------------------------------------------------------------------------
(0178) // 单器件/多器件：开始转换
(0179) //------------------------------------------------------------------------------
(0180) void convert_T(void)
(0181) {
(0182) 					if(reset_18B20()){
_convert_T:
    04005 DEB6      RCALL	_reset_18B20
    04006 2300      TST	R16
    04007 F021      BEQ	0x400C
(0183) 					write_byte_18B20(0xcc);
    04008 EC0C      LDI	R16,0xCC
    04009 DFB9      RCALL	_write_byte_18B20
(0184) 					write_byte_18B20(0x44);
    0400A E404      LDI	R16,0x44
    0400B DFB7      RCALL	_write_byte_18B20
(0185) 					}
    0400C 9508      RET
_read_T:
  tmp                  --> Y,+0
  tl                   --> R12
  th                   --> R10
    0400D 940E 42A8 CALL	push_xgset00FC
    0400F 9724      SBIW	R28,4
(0186) }
(0187) 
(0188) //------------------------------------------------------------------------------
(0189) // 单器件：读温度，返回INIT8U型温度数据（原始数据）
(0190) //------------------------------------------------------------------------------
(0191) float read_T(void)
(0192) {
(0193)     unsigned char th=0,tl=0;
    04010 24AA      CLR	R10
    04011 24CC      CLR	R12
(0194) 	float tmp;
(0195)     if(reset_18B20()){
    04012 DEA9      RCALL	_reset_18B20
    04013 2300      TST	R16
    04014 F021      BEQ	0x4019
(0196)     	write_byte_18B20(0xcc);
    04015 EC0C      LDI	R16,0xCC
    04016 DFAC      RCALL	_write_byte_18B20
(0197)     	write_byte_18B20(0xbe);
    04017 EB0E      LDI	R16,0xBE
    04018 DFAA      RCALL	_write_byte_18B20
(0198)     }
(0199)     
(0200)     tl = read_byte_18B20();
    04019 DFCA      RCALL	_read_byte_18B20
    0401A 2EC0      MOV	R12,R16
(0201)     th = read_byte_18B20();
    0401B DFC8      RCALL	_read_byte_18B20
    0401C 2EE0      MOV	R14,R16
    0401D 2CAE      MOV	R10,R14
(0202)  	tmp= ((float)(th<<8|tl))*0.0625;
    0401E EC08      LDI	R16,0xC8
    0401F E010      LDI	R17,0
    04020 940E 422C CALL	elpm32
    04022 0118      MOVW	R2,R16
    04023 0129      MOVW	R4,R18
    04024 2D1A      MOV	R17,R10
    04025 2D0C      MOV	R16,R12
    04026 940E 4400 CALL	int2fp
    04028 933A      ST	-Y,R19
    04029 932A      ST	-Y,R18
    0402A 931A      ST	-Y,R17
    0402B 930A      ST	-Y,R16
    0402C 0181      MOVW	R16,R2
    0402D 0192      MOVW	R18,R4
    0402E 940E 45A5 CALL	fpmule2
    04030 8308      ST	Y,R16
    04031 8319      STD	Y+1,R17
    04032 832A      STD	Y+2,R18
    04033 833B      STD	Y+3,R19
(0203)     return( tmp);
    04034 8108      LD	R16,Y
    04035 8119      LDD	R17,Y+1
    04036 812A      LDD	R18,Y+2
    04037 813B      LDD	R19,Y+3
    04038 9624      ADIW	R28,4
    04039 940C 4289 JMP	pop_xgset00FC
_read_T_NUM:
  ttemp                --> Y,+0
  NUM                  --> R10
    0403B 92AA      ST	-Y,R10
    0403C 2EA0      MOV	R10,R16
    0403D 9724      SBIW	R28,4
(0204) }
(0205) 
(0206) float read_T_NUM(unsigned char NUM){
(0207) float ttemp;
(0208) if ( NUM >1) return 123.45;
    0403E E081      LDI	R24,1
    0403F 158A      CP	R24,R10
    04040 F428      BCC	0x4046
    04041 EC04      LDI	R16,0xC4
    04042 E010      LDI	R17,0
    04043 940E 422C CALL	elpm32
    04045 C010      RJMP	0x4056
(0209) T_NUM=NUM;//设置访问器件
    04046 92A0 056C STS	T_NUM,R10
(0210) convert_T();//温度转换
    04048 DFBC      RCALL	_convert_T
(0211) delayms(800);
    04049 E200      LDI	R16,0x20
    0404A E013      LDI	R17,3
    0404B 940E 2440 CALL	_delayms
(0212) ttemp=read_T();
    0404D DFBF      RCALL	_read_T
    0404E 8308      ST	Y,R16
    0404F 8319      STD	Y+1,R17
    04050 832A      STD	Y+2,R18
    04051 833B      STD	Y+3,R19
(0213) return ttemp;
    04052 8108      LD	R16,Y
    04053 8119      LDD	R17,Y+1
    04054 812A      LDD	R18,Y+2
    04055 813B      LDD	R19,Y+3
    04056 9624      ADIW	R28,4
    04057 90A9      LD	R10,Y+
    04058 9508      RET
FILE: D:\LQD\software\software_src\ds1302.c
(0001) #include "config.h"
(0002) 
(0003) #define TPORT PORTB
(0004) #define TDDR DDRB
(0005) #define TPIN PINB
(0006) #define PIN_RST	 4
(0007) #define PIN_IO	 5
(0008) #define PIN_SCK	 6
(0009) /******************复位脚*********************/
(0010) #define RST_CLR	TPORT &= ~(1 << PIN_RST)   /*电平置低*/
(0011) #define RST_SET	TPORT |= (1 << PIN_RST)    /*电平置高*/
(0012) #define RST_IN	TDDR &= ~(1 << PIN_RST)    /*方向输入*/
(0013) #define RST_OUT	TDDR |= (1 << PIN_RST)     /*方向输出*/
(0014) 
(0015) /*****************双向数据********************/
(0016) #define IO_CLR	TPORT &= ~(1 << PIN_IO)  /*电平置低*/
(0017) #define IO_SET	TPORT |= (1 << PIN_IO)   /*电平置高*/
(0018) #define IO_R	TPIN & (1 << PIN_IO)     /*电平读取*/
(0019) #define IO_IN	TDDR &= ~(1 << PIN_IO)   /*方向输入*/
(0020) #define IO_OUT	TDDR |= (1 << PIN_IO)    /*方向输出*/
(0021) 
(0022) /*****************时钟信号*******************/
(0023) #define SCK_CLR	TPORT &= ~(1 << PIN_SCK)  /*时钟信号*/
(0024) #define SCK_SET	TPORT |= (1 << PIN_SCK)   /*电平置高*/
(0025) #define SCK_IN	TDDR &= ~(1 << PIN_SCK)   /*方向输入*/
(0026) #define SCK_OUT	TDDR |= (1 << PIN_SCK)    /*方向输出*/
(0027) 
(0028) #define ds1302_sec_add			0x80		//秒数据地址
(0029) #define ds1302_min_add			0x82		//分数据地址
(0030) #define ds1302_hr_add			0x84		//时数据地址
(0031) #define ds1302_date_add			0x86		//日数据地址
(0032) #define ds1302_month_add		0x88		//月数据地址
(0033) #define ds1302_day_add			0x8a		//星期数据地址
(0034) #define ds1302_year_add			0x8c		//年数据地址
(0035) #define ds1302_control_add		0x8e		//控制数据地址
(0036) #define ds1302_charger_add		0x90 					 
(0037) #define ds1302_clkburst_add		0xbe
(0038) 
(0039) unsigned char time_buf[8] = {0x20,0x0c,0x0A,0x1c,0x22,0x46,0x00,0x06};
(0040) /*
(0041)  struct tm {
(0042)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0043)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0044) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0045) 	int tm_mday;  // 日 day of the month, 1 to 31
(0046) 	int tm_mon;   // 月 months since January, 0 to 11
(0047) 	int tm_year;  // 年 years since 1900
(0048) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0049) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0050)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0051)  	};	
(0052) 	*/
(0053) 
(0054) //DS1302初始化函数
(0055) void ds1302_init(void) 
(0056) {
(0057) 	RST_CLR;			/*RST脚置低*/
_ds1302_init:
    04059 98C4      CBI	0x18,4
(0058) 	SCK_CLR;			/*SCK脚置低*/
    0405A 98C6      CBI	0x18,6
(0059) 	RST_OUT;			/*RST脚设置为输出*/
    0405B 9ABC      SBI	0x17,4
(0060) 	SCK_OUT;			/*SCK脚设置为输出*/
    0405C 9ABE      SBI	0x17,6
    0405D 9508      RET
_ds1302_write_byte:
  i                    --> R20
  d                    --> R18
  addr                 --> R16
    0405E 934A      ST	-Y,R20
(0061) }
(0062) 
(0063) //向DS1302写入一字节数据
(0064) void ds1302_write_byte(unsigned char addr, unsigned char d) {
(0065) 
(0066) 	unsigned char i;
(0067) 	RST_SET;					/*启动DS1302总线*/
    0405F 9AC4      SBI	0x18,4
(0068) 	
(0069) 	/*写入目标地址：addr*/
(0070) 	IO_OUT;
    04060 9ABD      SBI	0x17,5
(0071) 	addr = addr & 0xFE;   //最低位置零，寄存器0位为0时写，为1时读
    04061 7F0E      ANDI	R16,0xFE
(0072) 	for (i = 0; i < 8; i ++) {
    04062 2744      CLR	R20
    04063 C009      RJMP	0x406D
(0073) 		if (addr & 0x01) {
    04064 FF00      SBRS	R16,0
    04065 C002      RJMP	0x4068
(0074) 			IO_SET;
    04066 9AC5      SBI	0x18,5
(0075) 			}
    04067 C001      RJMP	0x4069
(0076) 		else {
(0077) 			IO_CLR;
    04068 98C5      CBI	0x18,5
(0078) 			}
(0079) 		SCK_SET;      //产生时钟
    04069 9AC6      SBI	0x18,6
(0080) 		SCK_CLR;
    0406A 98C6      CBI	0x18,6
(0081) 		addr = addr >> 1;
    0406B 9506      LSR	R16
    0406C 9543      INC	R20
    0406D 3048      CPI	R20,0x8
    0406E F3A8      BCS	0x4064
(0082) 		}
(0083) 	
(0084) 	/*写入数据：d*/
(0085) 	IO_OUT;
    0406F 9ABD      SBI	0x17,5
(0086) 	for (i = 0; i < 8; i ++) {
    04070 2744      CLR	R20
    04071 C009      RJMP	0x407B
(0087) 		if (d & 0x01) {
    04072 FF20      SBRS	R18,0
    04073 C002      RJMP	0x4076
(0088) 			IO_SET;
    04074 9AC5      SBI	0x18,5
(0089) 			}
    04075 C001      RJMP	0x4077
(0090) 		else {
(0091) 			IO_CLR;
    04076 98C5      CBI	0x18,5
(0092) 			}
(0093) 		SCK_SET;    //产生时钟
    04077 9AC6      SBI	0x18,6
(0094) 		SCK_CLR;
    04078 98C6      CBI	0x18,6
(0095) 		d = d >> 1;
    04079 9526      LSR	R18
    0407A 9543      INC	R20
    0407B 3048      CPI	R20,0x8
    0407C F3A8      BCS	0x4072
(0096) 		}
(0097) 	RST_CLR;		//停止DS1302总线
    0407D 98C4      CBI	0x18,4
    0407E 9149      LD	R20,Y+
    0407F 9508      RET
_ds1302_read_byte:
  temp                 --> R20
  i                    --> R22
  addr                 --> R16
    04080 934A      ST	-Y,R20
    04081 936A      ST	-Y,R22
(0098) 	
(0099) }
(0100) 
(0101) //从DS1302读出一字节数据
(0102) unsigned char ds1302_read_byte(unsigned char addr) {
(0103) 
(0104) 	unsigned char i;
(0105) 	unsigned char temp;
(0106) 	RST_SET;					/*启动DS1302总线*/
    04082 9AC4      SBI	0x18,4
(0107) 
(0108) 	/*写入目标地址：addr*/
(0109) 	IO_OUT;
    04083 9ABD      SBI	0x17,5
(0110) 	addr = addr | 0x01;    //最低位置高，寄存器0位为0时写，为1时读
    04084 6001      ORI	R16,1
(0111) 	for (i = 0; i < 8; i ++) {
    04085 2766      CLR	R22
    04086 C009      RJMP	0x4090
(0112) 		if (addr & 0x01) {
    04087 FF00      SBRS	R16,0
    04088 C002      RJMP	0x408B
(0113) 			IO_SET;
    04089 9AC5      SBI	0x18,5
(0114) 			}
    0408A C001      RJMP	0x408C
(0115) 		else {
(0116) 			IO_CLR;
    0408B 98C5      CBI	0x18,5
(0117) 			}
(0118) 		SCK_SET;
    0408C 9AC6      SBI	0x18,6
(0119) 		SCK_CLR;
    0408D 98C6      CBI	0x18,6
(0120) 		addr = addr >> 1;
    0408E 9506      LSR	R16
    0408F 9563      INC	R22
    04090 3068      CPI	R22,0x8
    04091 F3A8      BCS	0x4087
(0121) 		}
(0122) 	
(0123) 	/*输出数据：temp*/
(0124) 	IO_IN;
    04092 98BD      CBI	0x17,5
(0125) 	for (i = 0; i < 8; i ++) {
    04093 2766      CLR	R22
    04094 C009      RJMP	0x409E
(0126) 		temp = temp >> 1;
    04095 9546      LSR	R20
(0127) 		if (IO_R) {
    04096 9BB5      SBIS	0x16,5
    04097 C002      RJMP	0x409A
(0128) 			temp |= 0x80;
    04098 6840      ORI	R20,0x80
(0129) 			}
    04099 C001      RJMP	0x409B
(0130) 		else {
(0131) 			temp &= 0x7F;
    0409A 774F      ANDI	R20,0x7F
(0132) 			}
(0133) 		SCK_SET;
    0409B 9AC6      SBI	0x18,6
(0134) 		SCK_CLR;
    0409C 98C6      CBI	0x18,6
    0409D 9563      INC	R22
    0409E 3068      CPI	R22,0x8
    0409F F3A8      BCS	0x4095
(0135) 		}
(0136) 	
(0137) 	RST_CLR;					/*停止DS1302总线*/
    040A0 98C4      CBI	0x18,4
(0138) 	return temp;
    040A1 2F04      MOV	R16,R20
    040A2 9169      LD	R22,Y+
    040A3 9149      LD	R20,Y+
    040A4 9508      RET
(0139) }
(0140) 
(0141) //向DS302写入时钟数据
(0142) void ds1302_write_time(void) {
(0143) 
(0144) 	ds1302_write_byte(ds1302_control_add,0x00);			//关闭写保护 
_ds1302_write_time:
    040A5 2722      CLR	R18
    040A6 E80E      LDI	R16,0x8E
    040A7 DFB6      RCALL	_ds1302_write_byte
(0145) 	ds1302_write_byte(ds1302_sec_add,0x80);				//暂停时钟 
    040A8 E820      LDI	R18,0x80
    040A9 E800      LDI	R16,0x80
    040AA DFB3      RCALL	_ds1302_write_byte
(0146) 	//ds1302_write_byte(ds1302_charger_add,0xa9);	    //涓流充电 
(0147) 	ds1302_write_byte(ds1302_year_add,time_buf[1]);		//年 
    040AB 9120 056E LDS	R18,time_buf+1
    040AD E80C      LDI	R16,0x8C
    040AE DFAF      RCALL	_ds1302_write_byte
(0148) 	ds1302_write_byte(ds1302_month_add,time_buf[2]);	//月 
    040AF 9120 056F LDS	R18,time_buf+2
    040B1 E808      LDI	R16,0x88
    040B2 DFAB      RCALL	_ds1302_write_byte
(0149) 	ds1302_write_byte(ds1302_date_add,time_buf[3]);		//日 
    040B3 9120 0570 LDS	R18,time_buf+3
    040B5 E806      LDI	R16,0x86
    040B6 DFA7      RCALL	_ds1302_write_byte
(0150) 	ds1302_write_byte(ds1302_hr_add,time_buf[4]);		//时 
    040B7 9120 0571 LDS	R18,time_buf+4
    040B9 E804      LDI	R16,0x84
    040BA DFA3      RCALL	_ds1302_write_byte
(0151) 	ds1302_write_byte(ds1302_min_add,time_buf[5]);		//分
    040BB 9120 0572 LDS	R18,time_buf+5
    040BD E802      LDI	R16,0x82
    040BE DF9F      RCALL	_ds1302_write_byte
(0152) 	ds1302_write_byte(ds1302_sec_add,time_buf[6]);		//秒
    040BF 9120 0573 LDS	R18,time_buf+6
    040C1 E800      LDI	R16,0x80
    040C2 DF9B      RCALL	_ds1302_write_byte
(0153) 	ds1302_write_byte(ds1302_day_add,time_buf[7]);		//周 
    040C3 9120 0574 LDS	R18,time_buf+7
    040C5 E80A      LDI	R16,0x8A
    040C6 DF97      RCALL	_ds1302_write_byte
(0154) 	ds1302_write_byte(ds1302_control_add,0x80);			//打开写保护 
    040C7 E820      LDI	R18,0x80
    040C8 E80E      LDI	R16,0x8E
    040C9 CF94      RJMP	_ds1302_write_byte
_ds1302_read_time:
    040CA 92AA      ST	-Y,R10
    040CB 934A      ST	-Y,R20
(0155) }
(0156) 
(0157) //从DS302读出时钟数据
(0158) void ds1302_read_time(void)  { 
(0159) 	time_buf[1]=ds1302_read_byte(ds1302_year_add);		//年 
    040CC E80C      LDI	R16,0x8C
    040CD DFB2      RCALL	_ds1302_read_byte
    040CE 9300 056E STS	time_buf+1,R16
(0160) 	time_buf[2]=ds1302_read_byte(ds1302_month_add);		//月 
    040D0 E808      LDI	R16,0x88
    040D1 DFAE      RCALL	_ds1302_read_byte
    040D2 9300 056F STS	time_buf+2,R16
(0161) 	time_buf[3]=ds1302_read_byte(ds1302_date_add);		//日 
    040D4 E806      LDI	R16,0x86
    040D5 DFAA      RCALL	_ds1302_read_byte
    040D6 2EA0      MOV	R10,R16
    040D7 92A0 0570 STS	time_buf+3,R10
(0162) 	time_buf[4]=ds1302_read_byte(ds1302_hr_add);		//时 
    040D9 E804      LDI	R16,0x84
    040DA DFA5      RCALL	_ds1302_read_byte
    040DB 2EA0      MOV	R10,R16
    040DC 92A0 0571 STS	time_buf+4,R10
(0163) 	time_buf[5]=ds1302_read_byte(ds1302_min_add);		//分 
    040DE E802      LDI	R16,0x82
    040DF DFA0      RCALL	_ds1302_read_byte
    040E0 2EA0      MOV	R10,R16
    040E1 92A0 0572 STS	time_buf+5,R10
(0164) 	time_buf[6]=(ds1302_read_byte(ds1302_sec_add))&0x7F;//秒，屏蔽秒的第7位，避免超出59
    040E3 E800      LDI	R16,0x80
    040E4 DF9B      RCALL	_ds1302_read_byte
    040E5 2F40      MOV	R20,R16
    040E6 2F84      MOV	R24,R20
    040E7 778F      ANDI	R24,0x7F
    040E8 9380 0573 STS	time_buf+6,R24
(0165) 	time_buf[7]=ds1302_read_byte(ds1302_day_add);		//周 
    040EA E80A      LDI	R16,0x8A
    040EB DF94      RCALL	_ds1302_read_byte
    040EC 2EA0      MOV	R10,R16
    040ED 92A0 0574 STS	time_buf+7,R10
    040EF 9149      LD	R20,Y+
    040F0 90A9      LD	R10,Y+
    040F1 9508      RET
_kbscan:
  key                  --> R20
  temp                 --> Y,+0
    040F2 934A      ST	-Y,R20
    040F3 9724      SBIW	R28,4
FILE: D:\LQD\software\software_src\key.c
(0001) #include "config.h"
(0002) //键盘扫描函数
(0003) unsigned char kbscan(void)
(0004)   {
(0005)    unsigned char key;
(0006)    unsigned long temp=0;
    040F4 E080      LDI	R24,0
    040F5 8388      ST	Y,R24
    040F6 8389      STD	Y+1,R24
    040F7 838A      STD	Y+2,R24
    040F8 838B      STD	Y+3,R24
(0007)    DDR_SET;
    040F9 B38A      IN	R24,0x1A
    040FA 7087      ANDI	R24,7
    040FB BB8A      OUT	0x1A,R24
(0008)    
(0009)    if((KEY_PIN) != KEY_MASK)         //检测A口按键引脚电平，如果全是高电平则退出
    040FC B389      IN	R24,0x19
    040FD 718F      ANDI	R24,0x1F
    040FE 318F      CPI	R24,0x1F
    040FF F1A9      BEQ	0x4135
(0010)     {
(0011)      delayms(20);           //防抖
    04100 E104      LDI	R16,0x14
    04101 E010      LDI	R17,0
    04102 940E 2440 CALL	_delayms
(0012)      if((KEY_PIN) != KEY_MASK )      //再次检测A口电平，如果不全是高电平则继续执行程序
    04104 B389      IN	R24,0x19
    04105 718F      ANDI	R24,0x1F
    04106 318F      CPI	R24,0x1F
    04107 F179      BEQ	0x4137
(0013)       {
(0014)        key = KEY_PIN ;          //读取PINA，将其存放在key中
    04108 B349      IN	R20,0x19
    04109 714F      ANDI	R20,0x1F
    0410A C024      RJMP	0x412F
(0015)         while((KEY_PIN) != KEY_MASK)
(0016) 		{
(0017) 		 temp++ ;
    0410B E081      LDI	R24,1
    0410C E090      LDI	R25,0
    0410D E0A0      LDI	R26,0
    0410E E0B0      LDI	R27,0
    0410F 8028      LD	R2,Y
    04110 8039      LDD	R3,Y+1
    04111 804A      LDD	R4,Y+2
    04112 805B      LDD	R5,Y+3
    04113 0E28      ADD	R2,R24
    04114 1E39      ADC	R3,R25
    04115 1E4A      ADC	R4,R26
    04116 1E5B      ADC	R5,R27
    04117 8228      ST	Y,R2
    04118 8239      STD	Y+1,R3
    04119 824A      STD	Y+2,R4
    0411A 825B      STD	Y+3,R5
(0018) 		 if(temp>LONGKEY) {  
    0411B E880      LDI	R24,0x80
    0411C E398      LDI	R25,0x38
    0411D E0A1      LDI	R26,1
    0411E E0B0      LDI	R27,0
    0411F 8028      LD	R2,Y
    04120 8039      LDD	R3,Y+1
    04121 804A      LDD	R4,Y+2
    04122 805B      LDD	R5,Y+3
    04123 1582      CP	R24,R2
    04124 0593      CPC	R25,R3
    04125 05A4      CPC	R26,R4
    04126 05B5      CPC	R27,R5
    04127 F438      BCC	0x412F
(0019) 		     delayms(30);
    04128 E10E      LDI	R16,0x1E
    04129 E010      LDI	R17,0
    0412A 940E 2440 CALL	_delayms
(0020) 			 return key+0x80;  
    0412C 2F04      MOV	R16,R20
    0412D 5800      SUBI	R16,0x80
    0412E C009      RJMP	0x4138
    0412F B389      IN	R24,0x19
    04130 718F      ANDI	R24,0x1F
    04131 318F      CPI	R24,0x1F
    04132 F6C1      BNE	0x410B
(0021) 		 };
(0022) 		}
(0023) 		; //当前有按键处于按下状态，再按其他按键时程序维持当前状态 
(0024)       	
(0025) 		return key;
    04133 2F04      MOV	R16,R20
    04134 C003      RJMP	0x4138
(0026) 	  
(0027) 	  }
(0028)     }
(0029) 	else return NO_KEY;
    04135 2700      CLR	R16
    04136 C001      RJMP	0x4138
(0030) 	
(0031) 	return NO_KEY;
FILE: <library>
    04137 2700      CLR	R16
    04138 9624      ADIW	R28,4
    04139 9149      LD	R20,Y+
    0413A 9508      RET
_memset:
    0413B 8188      LD	R24,Y
    0413C 8199      LDD	R25,Y+1
    0413D 3080      CPI	R24,0
    0413E 0789      CPC	R24,R25
    0413F F029      BEQ	0x4145
    04140 2FE0      MOV	R30,R16
    04141 2FF1      MOV	R31,R17
    04142 9321      ST	Z+,R18
    04143 9701      SBIW	R24,1
    04144 F7E9      BNE	0x4142
    04145 9508      RET
_strcat:
    04146 2FA0      MOV	R26,R16
    04147 2FB1      MOV	R27,R17
    04148 2FE2      MOV	R30,R18
    04149 2FF3      MOV	R31,R19
    0414A 912D      LD	R18,X+
    0414B 2322      TST	R18
    0414C F7E9      BNE	0x414A
    0414D 9711      SBIW	R26,1
    0414E 9121      LD	R18,Z+
    0414F 932D      ST	X+,R18
    04150 2322      TST	R18
    04151 F7E1      BNE	0x414E
    04152 9508      RET
_strlen:
    04153 2FE0      MOV	R30,R16
    04154 2FF1      MOV	R31,R17
    04155 27AA      CLR	R26
    04156 27BB      CLR	R27
    04157 9001      LD	R0,Z+
    04158 2000      TST	R0
    04159 F011      BEQ	0x415C
    0415A 9611      ADIW	R26,1
    0415B CFFB      RJMP	0x4157
    0415C 2F0A      MOV	R16,R26
    0415D 2F1B      MOV	R17,R27
    0415E 9508      RET
push_arg4:
    0415F 933A      ST	-Y,R19
    04160 932A      ST	-Y,R18
push_arg2:
    04161 931A      ST	-Y,R17
    04162 930A      ST	-Y,R16
    04163 9508      RET
asr32:
    04164 920F      PUSH	R0
    04165 9009      LD	R0,Y+
    04166 2000      TST	R0
    04167 F031      BEQ	0x416E
    04168 9535      ASR	R19
    04169 9527      ROR	R18
    0416A 9517      ROR	R17
    0416B 9507      ROR	R16
    0416C 940A      DEC	R0
    0416D CFF8      RJMP	0x4166
    0416E 900F      POP	R0
    0416F 9508      RET
mod16s:
    04170 9468      BSET	6
    04171 92DA      ST	-Y,R13
    04172 2ED1      MOV	R13,R17
    04173 C004      RJMP	0x4178
div16s:
    04174 94E8      BCLR	6
    04175 92DA      ST	-Y,R13
    04176 2ED1      MOV	R13,R17
    04177 26D3      EOR	R13,R19
    04178 FF17      SBRS	R17,7
    04179 C004      RJMP	0x417E
    0417A 9510      COM	R17
    0417B 9500      COM	R16
    0417C 5F0F      SUBI	R16,0xFF
    0417D 4F1F      SBCI	R17,0xFF
    0417E FF37      SBRS	R19,7
    0417F C004      RJMP	0x4184
    04180 9530      COM	R19
    04181 9520      COM	R18
    04182 5F2F      SUBI	R18,0xFF
    04183 4F3F      SBCI	R19,0xFF
    04184 940E 4191 CALL	xdiv16u
    04186 FED7      SBRS	R13,7
    04187 C004      RJMP	0x418C
    04188 9510      COM	R17
    04189 9500      COM	R16
    0418A 5F0F      SUBI	R16,0xFF
    0418B 4F1F      SBCI	R17,0xFF
    0418C 90D9      LD	R13,Y+
    0418D 9508      RET
mod16u:
    0418E 9468      BSET	6
    0418F C001      RJMP	xdiv16u
div16u:
    04190 94E8      BCLR	6
xdiv16u:
    04191 92EA      ST	-Y,R14
    04192 92FA      ST	-Y,R15
    04193 938A      ST	-Y,R24
    04194 24EE      CLR	R14
    04195 24FF      CLR	R15
    04196 E180      LDI	R24,0x10
    04197 0F00      LSL	R16
    04198 1F11      ROL	R17
    04199 1CEE      ROL	R14
    0419A 1CFF      ROL	R15
    0419B 16E2      CP	R14,R18
    0419C 06F3      CPC	R15,R19
    0419D F018      BCS	0x41A1
    0419E 1AE2      SUB	R14,R18
    0419F 0AF3      SBC	R15,R19
    041A0 9503      INC	R16
    041A1 958A      DEC	R24
    041A2 F7A1      BNE	0x4197
    041A3 F416      BRTC	0x41A6
    041A4 2D0E      MOV	R16,R14
    041A5 2D1F      MOV	R17,R15
    041A6 9189      LD	R24,Y+
    041A7 90F9      LD	R15,Y+
    041A8 90E9      LD	R14,Y+
    041A9 9508      RET
div32u:
    041AA 94E8      BCLR	6
    041AB C001      RJMP	0x41AD
mod32u:
    041AC 9468      BSET	6
    041AD D030      RCALL	long_div_prolog
    041AE 24CC      CLR	R12
    041AF C009      RJMP	0x41B9
div32s:
    041B0 94E8      BCLR	6
    041B1 C001      RJMP	0x41B3
mod32s:
    041B2 9468      BSET	6
    041B3 D02A      RCALL	long_div_prolog
    041B4 FD37      SBRC	R19,7
    041B5 940E 42F1 CALL	neg32
    041B7 FDB7      SBRC	R27,7
    041B8 D052      RCALL	neg_R24_R27
    041B9 2477      CLR	R7
    041BA 2488      CLR	R8
    041BB 2499      CLR	R9
    041BC 24AA      CLR	R10
    041BD 24BB      CLR	R11
    041BE D042      RCALL	tst_R16_R19
    041BF F0C1      BEQ	0x41D8
    041C0 D045      RCALL	tst_R24_R27
    041C1 F0B1      BEQ	0x41D8
    041C2 E2E8      LDI	R30,0x28
    041C3 0F00      LSL	R16
    041C4 1F11      ROL	R17
    041C5 1F22      ROL	R18
    041C6 1F33      ROL	R19
    041C7 1C77      ROL	R7
    041C8 1C88      ROL	R8
    041C9 1C99      ROL	R9
    041CA 1CAA      ROL	R10
    041CB 1CBB      ROL	R11
    041CC 1688      CP	R8,R24
    041CD 0699      CPC	R9,R25
    041CE 06AA      CPC	R10,R26
    041CF 06BB      CPC	R11,R27
    041D0 F028      BCS	0x41D6
    041D1 1A88      SUB	R8,R24
    041D2 0A99      SBC	R9,R25
    041D3 0AAA      SBC	R10,R26
    041D4 0ABB      SBC	R11,R27
    041D5 9503      INC	R16
    041D6 95EA      DEC	R30
    041D7 F759      BNE	0x41C3
    041D8 F426      BRTC	0x41DD
    041D9 2D08      MOV	R16,R8
    041DA 2D19      MOV	R17,R9
    041DB 2D2A      MOV	R18,R10
    041DC 2D3B      MOV	R19,R11
    041DD C013      RJMP	long_div_epilog
long_div_prolog:
    041DE 927A      ST	-Y,R7
    041DF 928A      ST	-Y,R8
    041E0 929A      ST	-Y,R9
    041E1 92AA      ST	-Y,R10
    041E2 92BA      ST	-Y,R11
    041E3 92CA      ST	-Y,R12
    041E4 93EA      ST	-Y,R30
    041E5 938A      ST	-Y,R24
    041E6 939A      ST	-Y,R25
    041E7 93AA      ST	-Y,R26
    041E8 93BA      ST	-Y,R27
    041E9 858B      LDD	R24,Y+11
    041EA 859C      LDD	R25,Y+12
    041EB 85AD      LDD	R26,Y+13
    041EC 85BE      LDD	R27,Y+14
    041ED 2EC3      MOV	R12,R19
    041EE F00E      BRTS	0x41F0
    041EF 26CB      EOR	R12,R27
    041F0 9508      RET
long_div_epilog:
    041F1 FCC7      SBRC	R12,7
    041F2 940E 42F1 CALL	neg32
    041F4 91B9      LD	R27,Y+
    041F5 91A9      LD	R26,Y+
    041F6 9199      LD	R25,Y+
    041F7 9189      LD	R24,Y+
    041F8 91E9      LD	R30,Y+
    041F9 90C9      LD	R12,Y+
    041FA 90B9      LD	R11,Y+
    041FB 90A9      LD	R10,Y+
    041FC 9099      LD	R9,Y+
    041FD 9089      LD	R8,Y+
    041FE 9079      LD	R7,Y+
    041FF 9624      ADIW	R28,4
    04200 9508      RET
tst_R16_R19:
    04201 2FE0      MOV	R30,R16
    04202 2BE1      OR	R30,R17
    04203 2BE2      OR	R30,R18
    04204 2BE3      OR	R30,R19
    04205 9508      RET
tst_R24_R27:
    04206 2FE8      MOV	R30,R24
    04207 2BE9      OR	R30,R25
    04208 2BEA      OR	R30,R26
    04209 2BEB      OR	R30,R27
    0420A 9508      RET
neg_R24_R27:
    0420B 9580      COM	R24
    0420C 9590      COM	R25
    0420D 95A0      COM	R26
    0420E 95B0      COM	R27
    0420F 5F8F      SUBI	R24,0xFF
    04210 4F9F      SBCI	R25,0xFF
    04211 4FAF      SBCI	R26,0xFF
    04212 4FBF      SBCI	R27,0xFF
    04213 9508      RET
mod8u:
    04214 9468      BSET	6
    04215 C001      RJMP	xdiv8u
div8u:
    04216 94E8      BCLR	6
xdiv8u:
    04217 932A      ST	-Y,R18
    04218 92FA      ST	-Y,R15
    04219 92EA      ST	-Y,R14
    0421A 24FF      CLR	R15
    0421B 24EE      CLR	R14
    0421C E120      LDI	R18,0x10
    0421D 0F00      LSL	R16
    0421E 1CFF      ROL	R15
    0421F 1CEE      ROL	R14
    04220 16E1      CP	R14,R17
    04221 F010      BCS	0x4224
    04222 1AE1      SUB	R14,R17
    04223 9503      INC	R16
    04224 952A      DEC	R18
    04225 F7B9      BNE	0x421D
    04226 F40E      BRTC	0x4228
    04227 2D0E      MOV	R16,R14
    04228 90E9      LD	R14,Y+
    04229 90F9      LD	R15,Y+
    0422A 9129      LD	R18,Y+
    0422B 9508      RET
elpm32:
    0422C 93EA      ST	-Y,R30
    0422D 93FA      ST	-Y,R31
    0422E 920A      ST	-Y,R0
    0422F 2FE0      MOV	R30,R16
    04230 2FF1      MOV	R31,R17
    04231 95D8      ELPM
    04232 2D00      MOV	R16,R0
    04233 9631      ADIW	R30,1
    04234 95D8      ELPM
    04235 2D10      MOV	R17,R0
    04236 9631      ADIW	R30,1
    04237 95D8      ELPM
    04238 2D20      MOV	R18,R0
    04239 9631      ADIW	R30,1
    0423A 95D8      ELPM
    0423B 2D30      MOV	R19,R0
    0423C 9009      LD	R0,Y+
    0423D 91F9      LD	R31,Y+
    0423E 91E9      LD	R30,Y+
    0423F 9508      RET
empy16s:
    04240 920A      ST	-Y,R0
    04241 921A      ST	-Y,R1
    04242 938A      ST	-Y,R24
    04243 939A      ST	-Y,R25
    04244 9F02      MUL	R16,R18
    04245 01C0      MOVW	R24,R0
    04246 9F12      MUL	R17,R18
    04247 0D90      ADD	R25,R0
    04248 9F03      MUL	R16,R19
    04249 0D90      ADD	R25,R0
    0424A 018C      MOVW	R16,R24
    0424B 9199      LD	R25,Y+
    0424C 9189      LD	R24,Y+
    0424D 9019      LD	R1,Y+
    0424E 9009      LD	R0,Y+
    0424F 9508      RET
empy32u|empy32s:
    04250 940E 42FA CALL	long_prolog
    04252 927A      ST	-Y,R7
    04253 940E 4313 CALL	tstzero1
    04255 F159      BEQ	0x4281
    04256 2477      CLR	R7
    04257 940E 4319 CALL	tstzero2
    04259 F419      BNE	0x425D
    0425A 018C      MOVW	R16,R24
    0425B 019D      MOVW	R18,R26
    0425C C024      RJMP	0x4281
    0425D 920A      ST	-Y,R0
    0425E 921A      ST	-Y,R1
    0425F 9F08      MUL	R16,R24
    04260 2CB0      MOV	R11,R0
    04261 2CA1      MOV	R10,R1
    04262 9F28      MUL	R18,R24
    04263 2C90      MOV	R9,R0
    04264 2C81      MOV	R8,R1
    04265 9F18      MUL	R17,R24
    04266 0CA0      ADD	R10,R0
    04267 1C91      ADC	R9,R1
    04268 1C87      ADC	R8,R7
    04269 9F09      MUL	R16,R25
    0426A 0CA0      ADD	R10,R0
    0426B 1C91      ADC	R9,R1
    0426C 1C87      ADC	R8,R7
    0426D 9F19      MUL	R17,R25
    0426E 0C90      ADD	R9,R0
    0426F 1C81      ADC	R8,R1
    04270 9F0A      MUL	R16,R26
    04271 0C90      ADD	R9,R0
    04272 1C81      ADC	R8,R1
    04273 9F38      MUL	R19,R24
    04274 0C80      ADD	R8,R0
    04275 9F29      MUL	R18,R25
    04276 0C80      ADD	R8,R0
    04277 9F1A      MUL	R17,R26
    04278 0C80      ADD	R8,R0
    04279 9F0B      MUL	R16,R27
    0427A 0C80      ADD	R8,R0
    0427B 9019      LD	R1,Y+
    0427C 9009      LD	R0,Y+
    0427D 2D0B      MOV	R16,R11
    0427E 2D1A      MOV	R17,R10
    0427F 2D29      MOV	R18,R9
    04280 2D38      MOV	R19,R8
    04281 9079      LD	R7,Y+
    04282 940C 4308 JMP	long_epilog
pop_xgset003C:
    04284 90A9      LD	R10,Y+
    04285 90B9      LD	R11,Y+
    04286 90C9      LD	R12,Y+
    04287 90D9      LD	R13,Y+
    04288 9508      RET
pop_xgset00FC:
    04289 90A9      LD	R10,Y+
    0428A 90B9      LD	R11,Y+
    0428B 90C9      LD	R12,Y+
    0428C 90D9      LD	R13,Y+
    0428D 90E9      LD	R14,Y+
    0428E 90F9      LD	R15,Y+
    0428F 9508      RET
pop_xgset30FC:
    04290 90A9      LD	R10,Y+
    04291 90B9      LD	R11,Y+
    04292 90C9      LD	R12,Y+
    04293 90D9      LD	R13,Y+
    04294 90E9      LD	R14,Y+
    04295 90F9      LD	R15,Y+
    04296 9149      LD	R20,Y+
    04297 9159      LD	R21,Y+
    04298 9508      RET
pop_xgsetF0FC:
    04299 90A9      LD	R10,Y+
    0429A 90B9      LD	R11,Y+
    0429B 90C9      LD	R12,Y+
    0429C 90D9      LD	R13,Y+
    0429D 90E9      LD	R14,Y+
    0429E 90F9      LD	R15,Y+
    0429F 9149      LD	R20,Y+
    042A0 9159      LD	R21,Y+
    042A1 9169      LD	R22,Y+
    042A2 9179      LD	R23,Y+
    042A3 9508      RET
push_xgsetF0FC:
    042A4 937A      ST	-Y,R23
    042A5 936A      ST	-Y,R22
push_xgset30FC:
    042A6 935A      ST	-Y,R21
    042A7 934A      ST	-Y,R20
push_xgset00FC:
    042A8 92FA      ST	-Y,R15
    042A9 92EA      ST	-Y,R14
push_xgset003C:
    042AA 92DA      ST	-Y,R13
    042AB 92CA      ST	-Y,R12
    042AC 92BA      ST	-Y,R11
    042AD 92AA      ST	-Y,R10
    042AE 9508      RET
push_xgset300C:
    042AF 935A      ST	-Y,R21
    042B0 934A      ST	-Y,R20
    042B1 92BA      ST	-Y,R11
    042B2 92AA      ST	-Y,R10
    042B3 9508      RET
pop_xgset300C:
    042B4 90A9      LD	R10,Y+
    042B5 90B9      LD	R11,Y+
    042B6 9149      LD	R20,Y+
    042B7 9159      LD	R21,Y+
    042B8 9508      RET
push_xgsetF000:
    042B9 937A      ST	-Y,R23
    042BA 936A      ST	-Y,R22
    042BB 935A      ST	-Y,R21
    042BC 934A      ST	-Y,R20
    042BD 9508      RET
pop_xgsetF000:
    042BE 9149      LD	R20,Y+
    042BF 9159      LD	R21,Y+
    042C0 9169      LD	R22,Y+
    042C1 9179      LD	R23,Y+
    042C2 9508      RET
push_xgsetF00C:
    042C3 937A      ST	-Y,R23
    042C4 936A      ST	-Y,R22
    042C5 935A      ST	-Y,R21
    042C6 934A      ST	-Y,R20
    042C7 92BA      ST	-Y,R11
    042C8 92AA      ST	-Y,R10
    042C9 9508      RET
pop_xgsetF00C:
    042CA 90A9      LD	R10,Y+
    042CB 90B9      LD	R11,Y+
    042CC 9149      LD	R20,Y+
    042CD 9159      LD	R21,Y+
    042CE 9169      LD	R22,Y+
    042CF 9179      LD	R23,Y+
    042D0 9508      RET
push_xgset303C:
    042D1 935A      ST	-Y,R21
    042D2 934A      ST	-Y,R20
    042D3 92DA      ST	-Y,R13
    042D4 92CA      ST	-Y,R12
    042D5 92BA      ST	-Y,R11
    042D6 92AA      ST	-Y,R10
    042D7 9508      RET
pop_xgset303C:
    042D8 90A9      LD	R10,Y+
    042D9 90B9      LD	R11,Y+
    042DA 90C9      LD	R12,Y+
    042DB 90D9      LD	R13,Y+
    042DC 9149      LD	R20,Y+
    042DD 9159      LD	R21,Y+
    042DE 9508      RET
push_xgsetF03C:
    042DF 937A      ST	-Y,R23
    042E0 936A      ST	-Y,R22
    042E1 935A      ST	-Y,R21
    042E2 934A      ST	-Y,R20
    042E3 92DA      ST	-Y,R13
    042E4 92CA      ST	-Y,R12
    042E5 92BA      ST	-Y,R11
    042E6 92AA      ST	-Y,R10
    042E7 9508      RET
pop_xgsetF03C:
    042E8 90A9      LD	R10,Y+
    042E9 90B9      LD	R11,Y+
    042EA 90C9      LD	R12,Y+
    042EB 90D9      LD	R13,Y+
    042EC 9149      LD	R20,Y+
    042ED 9159      LD	R21,Y+
    042EE 9169      LD	R22,Y+
    042EF 9179      LD	R23,Y+
    042F0 9508      RET
neg32:
    042F1 9500      COM	R16
    042F2 9510      COM	R17
    042F3 9520      COM	R18
    042F4 9530      COM	R19
    042F5 5F0F      SUBI	R16,0xFF
    042F6 4F1F      SBCI	R17,0xFF
    042F7 4F2F      SBCI	R18,0xFF
    042F8 4F3F      SBCI	R19,0xFF
    042F9 9508      RET
long_prolog:
    042FA 928A      ST	-Y,R8
    042FB 929A      ST	-Y,R9
    042FC 92AA      ST	-Y,R10
    042FD 92BA      ST	-Y,R11
    042FE 93EA      ST	-Y,R30
    042FF 938A      ST	-Y,R24
    04300 939A      ST	-Y,R25
    04301 93AA      ST	-Y,R26
    04302 93BA      ST	-Y,R27
    04303 8589      LDD	R24,Y+9
    04304 859A      LDD	R25,Y+10
    04305 85AB      LDD	R26,Y+11
    04306 85BC      LDD	R27,Y+12
    04307 9508      RET
long_epilog:
    04308 91B9      LD	R27,Y+
    04309 91A9      LD	R26,Y+
    0430A 9199      LD	R25,Y+
    0430B 9189      LD	R24,Y+
    0430C 91E9      LD	R30,Y+
    0430D 90B9      LD	R11,Y+
    0430E 90A9      LD	R10,Y+
    0430F 9099      LD	R9,Y+
    04310 9089      LD	R8,Y+
    04311 9624      ADIW	R28,4
    04312 9508      RET
tstzero1:
    04313 27EE      CLR	R30
    04314 2BE0      OR	R30,R16
    04315 2BE1      OR	R30,R17
    04316 2BE2      OR	R30,R18
    04317 2BE3      OR	R30,R19
    04318 9508      RET
tstzero2:
    04319 27EE      CLR	R30
    0431A 2BE8      OR	R30,R24
    0431B 2BE9      OR	R30,R25
    0431C 2BEA      OR	R30,R26
    0431D 2BEB      OR	R30,R27
    0431E 9508      RET
lsl16:
    0431F 2322      TST	R18
    04320 F021      BEQ	0x4325
    04321 0F00      LSL	R16
    04322 1F11      ROL	R17
    04323 952A      DEC	R18
    04324 CFFA      RJMP	lsl16
    04325 9508      RET
lsl32:
    04326 920F      PUSH	R0
    04327 9009      LD	R0,Y+
    04328 2000      TST	R0
    04329 F031      BEQ	0x4330
    0432A 0F00      LSL	R16
    0432B 1F11      ROL	R17
    0432C 1F22      ROL	R18
    0432D 1F33      ROL	R19
    0432E 940A      DEC	R0
    0432F CFF8      RJMP	0x4328
    04330 900F      POP	R0
    04331 9508      RET
lsl8:
    04332 2311      TST	R17
    04333 F019      BEQ	0x4337
    04334 0F00      LSL	R16
    04335 951A      DEC	R17
    04336 CFFB      RJMP	lsl8
    04337 9508      RET
lsr16:
    04338 2322      TST	R18
    04339 F021      BEQ	0x433E
    0433A 9516      LSR	R17
    0433B 9507      ROR	R16
    0433C 952A      DEC	R18
    0433D CFFA      RJMP	lsr16
    0433E 9508      RET
lsr32:
    0433F 920F      PUSH	R0
    04340 9009      LD	R0,Y+
    04341 2000      TST	R0
    04342 F031      BEQ	0x4349
    04343 9536      LSR	R19
    04344 9527      ROR	R18
    04345 9517      ROR	R17
    04346 9507      ROR	R16
    04347 940A      DEC	R0
    04348 CFF8      RJMP	0x4341
    04349 900F      POP	R0
    0434A 9508      RET
asgnblk:
    0434B 93AA      ST	-Y,R26
    0434C 93BA      ST	-Y,R27
    0434D 93EA      ST	-Y,R30
    0434E 93FA      ST	-Y,R31
    0434F 920A      ST	-Y,R0
    04350 81AF      LDD	R26,Y+7
    04351 85B8      LDD	R27,Y+8
    04352 81ED      LDD	R30,Y+5
    04353 81FE      LDD	R31,Y+6
    04354 3000      CPI	R16,0
    04355 0701      CPC	R16,R17
    04356 F029      BEQ	0x435C
    04357 9001      LD	R0,Z+
    04358 920D      ST	X+,R0
    04359 5001      SUBI	R16,1
    0435A 4010      SBCI	R17,0
    0435B CFF8      RJMP	0x4354
    0435C 9009      LD	R0,Y+
    0435D 91F9      LD	R31,Y+
    0435E 91E9      LD	R30,Y+
    0435F 91B9      LD	R27,Y+
    04360 91A9      LD	R26,Y+
    04361 9624      ADIW	R28,4
    04362 9508      RET
fpsub:
    04363 9468      BSET	6
    04364 C001      RJMP	fpadd_alt
fpadd:
    04365 94E8      BCLR	6
fpadd_alt:
    04366 940E 452A CALL	saveFPRegs
    04368 940E 44BC CALL	unpacks
    0436A F409      BNE	0x436C
    0436B C048      RJMP	0x43B4
    0436C 2CE6      MOV	R14,R6
    0436D 2CD5      MOV	R13,R5
    0436E 2CC4      MOV	R12,R4
    0436F 2EB3      MOV	R11,R19
    04370 2EA2      MOV	R10,R18
    04371 2E91      MOV	R9,R17
    04372 2E80      MOV	R8,R16
    04373 8100      LD	R16,Z
    04374 8111      LDD	R17,Z+1
    04375 8122      LDD	R18,Z+2
    04376 8133      LDD	R19,Z+3
    04377 940E 44BC CALL	unpacks
    04379 F409      BNE	0x437B
    0437A C044      RJMP	0x43BF
    0437B 2D84      MOV	R24,R4
    0437C 2D95      MOV	R25,R5
    0437D 198C      SUB	R24,R12
    0437E 099D      SBC	R25,R13
    0437F F0B9      BEQ	0x4397
    04380 F472      BPL	0x438F
    04381 9590      COM	R25
    04382 9580      COM	R24
    04383 9601      ADIW	R24,1
    04384 2C4C      MOV	R4,R12
    04385 2C5D      MOV	R5,R13
    04386 3188      CPI	R24,0x18
    04387 F5B8      BCC	0x43BF
    04388 9535      ASR	R19
    04389 9527      ROR	R18
    0438A 9517      ROR	R17
    0438B 9507      ROR	R16
    0438C 9701      SBIW	R24,1
    0438D F7D1      BNE	0x4388
    0438E C008      RJMP	0x4397
    0438F 3188      CPI	R24,0x18
    04390 F518      BCC	0x43B4
    04391 94B5      ASR	R11
    04392 94A7      ROR	R10
    04393 9497      ROR	R9
    04394 9487      ROR	R8
    04395 9701      SBIW	R24,1
    04396 F7D1      BNE	0x4391
    04397 2466      CLR	R6
    04398 F02E      BRTS	0x439E
    04399 0D08      ADD	R16,R8
    0439A 1D19      ADC	R17,R9
    0439B 1D2A      ADC	R18,R10
    0439C 1D3B      ADC	R19,R11
    0439D C009      RJMP	0x43A7
    0439E 1A80      SUB	R8,R16
    0439F 0A91      SBC	R9,R17
    043A0 0AA2      SBC	R10,R18
    043A1 0AB3      SBC	R11,R19
    043A2 2D08      MOV	R16,R8
    043A3 2D19      MOV	R17,R9
    043A4 2D2A      MOV	R18,R10
    043A5 2D3B      MOV	R19,R11
    043A6 2333      TST	R19
    043A7 F422      BPL	0x43AC
    043A8 940E 42F1 CALL	neg32
    043AA E880      LDI	R24,0x80
    043AB 2E68      MOV	R6,R24
    043AC 940E 44E5 CALL	normalize_and_pack
    043AE C002      RJMP	0x43B1
    043AF 940E 451A CALL	pack
    043B1 940E 4539 CALL	restoreFPRegs
    043B3 9508      RET
    043B4 8100      LD	R16,Z
    043B5 8111      LDD	R17,Z+1
    043B6 8122      LDD	R18,Z+2
    043B7 8133      LDD	R19,Z+3
    043B8 F7C6      BRTC	0x43B1
    043B9 940E 44C4 CALL	tstR16_R19
    043BB F3A9      BEQ	0x43B1
    043BC E880      LDI	R24,0x80
    043BD 2738      EOR	R19,R24
    043BE CFF2      RJMP	0x43B1
    043BF 2D08      MOV	R16,R8
    043C0 2D19      MOV	R17,R9
    043C1 2D2A      MOV	R18,R10
    043C2 2D3B      MOV	R19,R11
    043C3 2C4C      MOV	R4,R12
    043C4 2C5D      MOV	R5,R13
    043C5 2C6E      MOV	R6,R14
    043C6 2333      TST	R19
    043C7 F73A      BPL	0x43AF
    043C8 940E 42F1 CALL	neg32
    043CA E880      LDI	R24,0x80
    043CB 2E68      MOV	R6,R24
    043CC CFE2      RJMP	0x43AF
fpadd2:
    043CD 93FA      ST	-Y,R31
    043CE 93EA      ST	-Y,R30
    043CF 2FEC      MOV	R30,R28
    043D0 2FFD      MOV	R31,R29
    043D1 9632      ADIW	R30,2
    043D2 940E 4365 CALL	fpadd
    043D4 91E9      LD	R30,Y+
    043D5 91F9      LD	R31,Y+
    043D6 9624      ADIW	R28,4
    043D7 9508      RET
fpsub2:
    043D8 93FA      ST	-Y,R31
    043D9 93EA      ST	-Y,R30
    043DA 2FEC      MOV	R30,R28
    043DB 2FFD      MOV	R31,R29
    043DC 9632      ADIW	R30,2
    043DD 940E 4363 CALL	fpsub
    043DF 91E9      LD	R30,Y+
    043E0 91F9      LD	R31,Y+
    043E1 9624      ADIW	R28,4
    043E2 9508      RET
fpsub1x:
    043E3 93FA      ST	-Y,R31
    043E4 93EA      ST	-Y,R30
    043E5 81EA      LDD	R30,Y+2
    043E6 81FB      LDD	R31,Y+3
    043E7 940E 4363 CALL	fpsub
    043E9 91E9      LD	R30,Y+
    043EA 91F9      LD	R31,Y+
    043EB 8339      STD	Y+1,R19
    043EC 8328      ST	Y,R18
    043ED 931A      ST	-Y,R17
    043EE 930A      ST	-Y,R16
    043EF 9508      RET
fpsub2x:
    043F0 93FA      ST	-Y,R31
    043F1 93EA      ST	-Y,R30
    043F2 2FEC      MOV	R30,R28
    043F3 2FFD      MOV	R31,R29
    043F4 9632      ADIW	R30,2
    043F5 940E 4363 CALL	fpsub
    043F7 91E9      LD	R30,Y+
    043F8 91F9      LD	R31,Y+
    043F9 833B      STD	Y+3,R19
    043FA 832A      STD	Y+2,R18
    043FB 8319      STD	Y+1,R17
    043FC 8308      ST	Y,R16
    043FD 9508      RET
uint2fp:
    043FE 9468      BSET	6
    043FF C001      RJMP	0x4401
int2fp:
    04400 94E8      BCLR	6
    04401 2722      CLR	R18
    04402 2733      CLR	R19
    04403 F046      BRTS	0x440C
    04404 FD17      SBRC	R17,7
    04405 9520      COM	R18
    04406 FD17      SBRC	R17,7
    04407 9530      COM	R19
    04408 C003      RJMP	0x440C
ulong2fp:
    04409 9468      BSET	6
    0440A C001      RJMP	0x440C
long2fp:
    0440B 94E8      BCLR	6
    0440C 924A      ST	-Y,R4
    0440D 925A      ST	-Y,R5
    0440E 926A      ST	-Y,R6
    0440F 938A      ST	-Y,R24
    04410 E187      LDI	R24,0x17
    04411 2E48      MOV	R4,R24
    04412 2455      CLR	R5
    04413 2466      CLR	R6
    04414 F036      BRTS	0x441B
    04415 2333      TST	R19
    04416 F422      BPL	0x441B
    04417 940E 42F1 CALL	neg32
    04419 E880      LDI	R24,0x80
    0441A 2E68      MOV	R6,R24
    0441B 940E 44E5 CALL	normalize_and_pack
    0441D 9189      LD	R24,Y+
    0441E 9069      LD	R6,Y+
    0441F 9059      LD	R5,Y+
    04420 9049      LD	R4,Y+
    04421 9508      RET
fpdiv1:
    04422 93FA      ST	-Y,R31
    04423 93EA      ST	-Y,R30
    04424 81EA      LDD	R30,Y+2
    04425 81FB      LDD	R31,Y+3
    04426 D027      RCALL	0x444E
    04427 91E9      LD	R30,Y+
    04428 91F9      LD	R31,Y+
    04429 9622      ADIW	R28,2
    0442A 9508      RET
fpdiv2:
    0442B 93FA      ST	-Y,R31
    0442C 93EA      ST	-Y,R30
    0442D 2FEC      MOV	R30,R28
    0442E 2FFD      MOV	R31,R29
    0442F 9632      ADIW	R30,2
    04430 D01D      RCALL	0x444E
    04431 91E9      LD	R30,Y+
    04432 91F9      LD	R31,Y+
    04433 9624      ADIW	R28,4
    04434 9508      RET
fpdiv1x:
    04435 93FA      ST	-Y,R31
    04436 93EA      ST	-Y,R30
    04437 81EA      LDD	R30,Y+2
    04438 81FB      LDD	R31,Y+3
    04439 D014      RCALL	0x444E
    0443A 91E9      LD	R30,Y+
    0443B 91F9      LD	R31,Y+
    0443C 8339      STD	Y+1,R19
    0443D 8328      ST	Y,R18
    0443E 931A      ST	-Y,R17
    0443F 930A      ST	-Y,R16
    04440 9508      RET
fpdiv2x:
    04441 93FA      ST	-Y,R31
    04442 93EA      ST	-Y,R30
    04443 2FEC      MOV	R30,R28
    04444 2FFD      MOV	R31,R29
    04445 9632      ADIW	R30,2
    04446 D007      RCALL	0x444E
    04447 91E9      LD	R30,Y+
    04448 91F9      LD	R31,Y+
    04449 833B      STD	Y+3,R19
    0444A 832A      STD	Y+2,R18
    0444B 8319      STD	Y+1,R17
    0444C 8308      ST	Y,R16
    0444D 9508      RET
    0444E 920A      ST	-Y,R0
    0444F 921A      ST	-Y,R1
    04450 922A      ST	-Y,R2
    04451 923A      ST	-Y,R3
    04452 940E 452A CALL	saveFPRegs
    04454 933A      ST	-Y,R19
    04455 932A      ST	-Y,R18
    04456 931A      ST	-Y,R17
    04457 930A      ST	-Y,R16
    04458 8100      LD	R16,Z
    04459 8111      LDD	R17,Z+1
    0445A 8122      LDD	R18,Z+2
    0445B 8133      LDD	R19,Z+3
    0445C 940E 44CC CALL	unpacku
    0445E F409      BNE	0x4460
    0445F C057      RJMP	0x44B7
    04460 2CE6      MOV	R14,R6
    04461 2CD5      MOV	R13,R5
    04462 2CC4      MOV	R12,R4
    04463 2EB3      MOV	R11,R19
    04464 2EA2      MOV	R10,R18
    04465 2E91      MOV	R9,R17
    04466 2E80      MOV	R8,R16
    04467 9109      LD	R16,Y+
    04468 9119      LD	R17,Y+
    04469 9129      LD	R18,Y+
    0446A 9139      LD	R19,Y+
    0446B 940E 44CC CALL	unpacku
    0446D F1A1      BEQ	0x44A2
    0446E 246E      EOR	R6,R14
    0446F 184C      SUB	R4,R12
    04470 085D      SBC	R5,R13
    04471 E880      LDI	R24,0x80
    04472 1648      CP	R4,R24
    04473 0653      CPC	R5,R19
    04474 F00C      BLT	0x4476
    04475 C033      RJMP	0x44A9
    04476 E881      LDI	R24,0x81
    04477 1648      CP	R4,R24
    04478 EF8F      LDI	R24,0xFF
    04479 0658      CPC	R5,R24
    0447A F40C      BGE	0x447C
    0447B C036      RJMP	0x44B2
    0447C E280      LDI	R24,0x20
    0447D 2433      CLR	R3
    0447E 2E23      MOV	R2,R19
    0447F 2E12      MOV	R1,R18
    04480 2E01      MOV	R0,R17
    04481 2F30      MOV	R19,R16
    04482 2722      CLR	R18
    04483 2711      CLR	R17
    04484 2700      CLR	R16
    04485 9426      LSR	R2
    04486 9417      ROR	R1
    04487 9407      ROR	R0
    04488 9537      ROR	R19
    04489 9527      ROR	R18
    0448A 0F00      LSL	R16
    0448B 1F11      ROL	R17
    0448C 1F22      ROL	R18
    0448D 1F33      ROL	R19
    0448E 1C00      ROL	R0
    0448F 1C11      ROL	R1
    04490 1C22      ROL	R2
    04491 1C33      ROL	R3
    04492 F028      BCS	0x4498
    04493 1808      SUB	R0,R8
    04494 0819      SBC	R1,R9
    04495 082A      SBC	R2,R10
    04496 083B      SBC	R3,R11
    04497 C004      RJMP	0x449C
    04498 0C08      ADD	R0,R8
    04499 1C19      ADC	R1,R9
    0449A 1C2A      ADC	R2,R10
    0449B 1C3B      ADC	R3,R11
    0449C F00A      BMI	0x449E
    0449D 6001      ORI	R16,1
    0449E 958A      DEC	R24
    0449F F751      BNE	0x448A
    044A0 940E 44E5 CALL	normalize_and_pack
    044A2 940E 4539 CALL	restoreFPRegs
    044A4 9039      LD	R3,Y+
    044A5 9029      LD	R2,Y+
    044A6 9019      LD	R1,Y+
    044A7 9009      LD	R0,Y+
    044A8 9508      RET
    044A9 EF0F      LDI	R16,0xFF
    044AA 2F10      MOV	R17,R16
    044AB E72F      LDI	R18,0x7F
    044AC E73F      LDI	R19,0x7F
    044AD 2066      TST	R6
    044AE F399      BEQ	0x44A2
    044AF 940E 42F1 CALL	neg32
    044B1 CFF0      RJMP	0x44A2
    044B2 2700      CLR	R16
    044B3 2F10      MOV	R17,R16
    044B4 2F20      MOV	R18,R16
    044B5 2F30      MOV	R19,R16
    044B6 CFEB      RJMP	0x44A2
    044B7 9109      LD	R16,Y+
    044B8 9119      LD	R17,Y+
    044B9 9129      LD	R18,Y+
    044BA 9139      LD	R19,Y+
    044BB CFED      RJMP	0x44A9
unpacks:
    044BC D00F      RCALL	unpacku
    044BD F029      BEQ	0x44C3
    044BE 2066      TST	R6
    044BF F011      BEQ	0x44C2
    044C0 940E 42F1 CALL	neg32
    044C2 9498      BCLR	1
    044C3 9508      RET
tstR16_R19:
    044C4 2300      TST	R16
    044C5 F429      BNE	0x44CB
    044C6 2311      TST	R17
    044C7 F419      BNE	0x44CB
    044C8 2322      TST	R18
    044C9 F409      BNE	0x44CB
    044CA 2333      TST	R19
    044CB 9508      RET
unpacku:
    044CC DFF7      RCALL	tstR16_R19
    044CD F099      BEQ	0x44E1
    044CE 938A      ST	-Y,R24
    044CF 2E63      MOV	R6,R19
    044D0 E880      LDI	R24,0x80
    044D1 2268      AND	R6,R24
    044D2 0F22      LSL	R18
    044D3 1F33      ROL	R19
    044D4 2E43      MOV	R4,R19
    044D5 E78F      LDI	R24,0x7F
    044D6 1A48      SUB	R4,R24
    044D7 2455      CLR	R5
    044D8 2788      CLR	R24
    044D9 0A58      SBC	R5,R24
    044DA 9526      LSR	R18
    044DB E830      LDI	R19,0x80
    044DC 2B23      OR	R18,R19
    044DD 2733      CLR	R19
    044DE 9189      LD	R24,Y+
    044DF 9498      BCLR	1
    044E0 9508      RET
    044E1 2444      CLR	R4
    044E2 2455      CLR	R5
    044E3 2466      CLR	R6
    044E4 9508      RET
normalize_and_pack:
    044E5 DFDE      RCALL	tstR16_R19
    044E6 F409      BNE	0x44E8
    044E7 9508      RET
    044E8 93AA      ST	-Y,R26
    044E9 93BA      ST	-Y,R27
    044EA 01D2      MOVW	R26,R4
    044EB 939A      ST	-Y,R25
    044EC 938A      ST	-Y,R24
    044ED E78E      LDI	R24,0x7E
    044EE E090      LDI	R25,0
    044EF 2333      TST	R19
    044F0 F049      BEQ	0x44FA
    044F1 9536      LSR	R19
    044F2 9527      ROR	R18
    044F3 9517      ROR	R17
    044F4 9507      ROR	R16
    044F5 17A8      CP	R26,R24
    044F6 07B9      CPC	R27,R25
    044F7 F4CC      BGE	0x4511
    044F8 9611      ADIW	R26,1
    044F9 CFF5      RJMP	0x44EF
    044FA 9580      COM	R24
    044FB 9590      COM	R25
    044FC 9601      ADIW	R24,1
    044FD 2322      TST	R18
    044FE F0BA      BMI	0x4516
    044FF 0F00      LSL	R16
    04500 1F11      ROL	R17
    04501 1F22      ROL	R18
    04502 17A8      CP	R26,R24
    04503 07B9      CPC	R27,R25
    04504 F014      BLT	0x4507
    04505 9711      SBIW	R26,1
    04506 CFF6      RJMP	0x44FD
    04507 2700      CLR	R16
    04508 2711      CLR	R17
    04509 2722      CLR	R18
    0450A 2733      CLR	R19
    0450B 9189      LD	R24,Y+
    0450C 9199      LD	R25,Y+
    0450D 012D      MOVW	R4,R26
    0450E 91B9      LD	R27,Y+
    0450F 91A9      LD	R26,Y+
    04510 9508      RET
    04511 2733      CLR	R19
    04512 EF0F      LDI	R16,0xFF
    04513 2F10      MOV	R17,R16
    04514 E72F      LDI	R18,0x7F
    04515 2F32      MOV	R19,R18
    04516 9189      LD	R24,Y+
    04517 9199      LD	R25,Y+
    04518 012D      MOVW	R4,R26
    04519 C002      RJMP	0x451C
pack:
    0451A 93AA      ST	-Y,R26
    0451B 93BA      ST	-Y,R27
    0451C DFA7      RCALL	tstR16_R19
    0451D F049      BEQ	0x4527
    0451E 01D2      MOVW	R26,R4
    0451F 58A1      SUBI	R26,0x81
    04520 4FBF      SBCI	R27,0xFF
    04521 012D      MOVW	R4,R26
    04522 2D34      MOV	R19,R4
    04523 0F22      LSL	R18
    04524 9536      LSR	R19
    04525 9527      ROR	R18
    04526 2936      OR	R19,R6
    04527 91B9      LD	R27,Y+
    04528 91A9      LD	R26,Y+
    04529 9508      RET
saveFPRegs:
    0452A 924A      ST	-Y,R4
    0452B 925A      ST	-Y,R5
    0452C 926A      ST	-Y,R6
    0452D 927A      ST	-Y,R7
    0452E 928A      ST	-Y,R8
    0452F 929A      ST	-Y,R9
    04530 92AA      ST	-Y,R10
    04531 92BA      ST	-Y,R11
    04532 92CA      ST	-Y,R12
    04533 92DA      ST	-Y,R13
    04534 92EA      ST	-Y,R14
    04535 92FA      ST	-Y,R15
    04536 938A      ST	-Y,R24
    04537 939A      ST	-Y,R25
    04538 9508      RET
restoreFPRegs:
    04539 9199      LD	R25,Y+
    0453A 9189      LD	R24,Y+
    0453B 90F9      LD	R15,Y+
    0453C 90E9      LD	R14,Y+
    0453D 90D9      LD	R13,Y+
    0453E 90C9      LD	R12,Y+
    0453F 90B9      LD	R11,Y+
    04540 90A9      LD	R10,Y+
    04541 9099      LD	R9,Y+
    04542 9089      LD	R8,Y+
    04543 9079      LD	R7,Y+
    04544 9069      LD	R6,Y+
    04545 9059      LD	R5,Y+
    04546 9049      LD	R4,Y+
    04547 9508      RET
fpmule:
    04548 940E 452A CALL	saveFPRegs
    0454A 93AA      ST	-Y,R26
    0454B 93BA      ST	-Y,R27
    0454C 940E 44CC CALL	unpacku
    0454E F1E1      BEQ	0x458B
    0454F 2CE6      MOV	R14,R6
    04550 2CD5      MOV	R13,R5
    04551 2CC4      MOV	R12,R4
    04552 2EB3      MOV	R11,R19
    04553 2EA2      MOV	R10,R18
    04554 2E91      MOV	R9,R17
    04555 2E80      MOV	R8,R16
    04556 8100      LD	R16,Z
    04557 8111      LDD	R17,Z+1
    04558 8122      LDD	R18,Z+2
    04559 8133      LDD	R19,Z+3
    0455A 940E 44CC CALL	unpacku
    0455C F171      BEQ	0x458B
    0455D 246E      EOR	R6,R14
    0455E 0C4C      ADD	R4,R12
    0455F 1C5D      ADC	R5,R13
    04560 E880      LDI	R24,0x80
    04561 1648      CP	R4,R24
    04562 0653      CPC	R5,R19
    04563 F564      BGE	0x4590
    04564 E881      LDI	R24,0x81
    04565 1648      CP	R4,R24
    04566 EF8F      LDI	R24,0xFF
    04567 0658      CPC	R5,R24
    04568 F16C      BLT	0x4596
    04569 9EA2      MUL	R10,R18
    0456A 2DB1      MOV	R27,R1
    0456B 2DA0      MOV	R26,R0
    0456C 9E91      MUL	R9,R17
    0456D 2D91      MOV	R25,R1
    0456E 2D80      MOV	R24,R0
    0456F 9EA0      MUL	R10,R16
    04570 0D80      ADD	R24,R0
    04571 1D91      ADC	R25,R1
    04572 1FA3      ADC	R26,R19
    04573 1FB3      ADC	R27,R19
    04574 9E82      MUL	R8,R18
    04575 0D80      ADD	R24,R0
    04576 1D91      ADC	R25,R1
    04577 1FA3      ADC	R26,R19
    04578 1FB3      ADC	R27,R19
    04579 9E92      MUL	R9,R18
    0457A 0D90      ADD	R25,R0
    0457B 1DA1      ADC	R26,R1
    0457C 1FB3      ADC	R27,R19
    0457D 9EA1      MUL	R10,R17
    0457E 0D90      ADD	R25,R0
    0457F 1DA1      ADC	R26,R1
    04580 1FB3      ADC	R27,R19
    04581 2F2B      MOV	R18,R27
    04582 2F1A      MOV	R17,R26
    04583 2F09      MOV	R16,R25
    04584 0F88      LSL	R24
    04585 1F00      ROL	R16
    04586 1F11      ROL	R17
    04587 1F22      ROL	R18
    04588 1F33      ROL	R19
    04589 940E 44E5 CALL	normalize_and_pack
    0458B 91B9      LD	R27,Y+
    0458C 91A9      LD	R26,Y+
    0458D 940E 4539 CALL	restoreFPRegs
    0458F 9508      RET
    04590 EF0F      LDI	R16,0xFF
    04591 2F10      MOV	R17,R16
    04592 E72F      LDI	R18,0x7F
    04593 E78F      LDI	R24,0x7F
    04594 2E48      MOV	R4,R24
    04595 CFF5      RJMP	0x458B
    04596 2700      CLR	R16
    04597 2F10      MOV	R17,R16
    04598 2F20      MOV	R18,R16
    04599 2F30      MOV	R19,R16
    0459A CFF0      RJMP	0x458B
fpmule1:
    0459B 93FA      ST	-Y,R31
    0459C 93EA      ST	-Y,R30
    0459D 81EA      LDD	R30,Y+2
    0459E 81FB      LDD	R31,Y+3
    0459F 940E 4548 CALL	fpmule
    045A1 91E9      LD	R30,Y+
    045A2 91F9      LD	R31,Y+
    045A3 9622      ADIW	R28,2
    045A4 9508      RET
fpmule2:
    045A5 93FA      ST	-Y,R31
    045A6 93EA      ST	-Y,R30
    045A7 2FEC      MOV	R30,R28
    045A8 2FFD      MOV	R31,R29
    045A9 9632      ADIW	R30,2
    045AA 940E 4548 CALL	fpmule
    045AC 91E9      LD	R30,Y+
    045AD 91F9      LD	R31,Y+
    045AE 9624      ADIW	R28,4
    045AF 9508      RET
fpmule1x:
    045B0 93FA      ST	-Y,R31
    045B1 93EA      ST	-Y,R30
    045B2 81EA      LDD	R30,Y+2
    045B3 81FB      LDD	R31,Y+3
    045B4 940E 4548 CALL	fpmule
    045B6 91E9      LD	R30,Y+
    045B7 91F9      LD	R31,Y+
    045B8 8339      STD	Y+1,R19
    045B9 8328      ST	Y,R18
    045BA 931A      ST	-Y,R17
    045BB 930A      ST	-Y,R16
    045BC 9508      RET
fpcmp:
    045BD 940E 4363 CALL	fpsub
    045BF 2333      TST	R19
    045C0 F03A      BMI	0x45C8
    045C1 940E 44C4 CALL	tstR16_R19
    045C3 F011      BEQ	0x45C6
    045C4 E001      LDI	R16,1
    045C5 9508      RET
    045C6 2700      CLR	R16
    045C7 9508      RET
    045C8 EF0F      LDI	R16,0xFF
    045C9 9508      RET
fpcmp2:
    045CA 93FA      ST	-Y,R31
    045CB 93EA      ST	-Y,R30
    045CC 2FEC      MOV	R30,R28
    045CD 2FFD      MOV	R31,R29
    045CE 9632      ADIW	R30,2
    045CF 940E 45BD CALL	fpcmp
    045D1 91E9      LD	R30,Y+
    045D2 91F9      LD	R31,Y+
    045D3 9624      ADIW	R28,4
    045D4 2300      TST	R16
    045D5 9508      RET
_itoa:
    045D6 940E 415F CALL	push_arg4
    045D8 940E 42A4 CALL	push_xgsetF0FC
    045DA 01A9      MOVW	R20,R18
    045DB 84EE      LDD	R14,Y+14
    045DC 84FF      LDD	R15,Y+15
    045DD 015A      MOVW	R10,R20
    045DE 20AA      TST	R10
    045DF F451      BNE	0x45EA
    045E0 20BB      TST	R11
    045E1 F441      BNE	0x45EA
    045E2 E380      LDI	R24,0x30
    045E3 85EA      LDD	R30,Y+10
    045E4 85FB      LDD	R31,Y+11
    045E5 8380      ST	Z,R24
    045E6 2422      CLR	R2
    045E7 8221      STD	Z+1,R2
    045E8 018F      MOVW	R16,R30
    045E9 C053      RJMP	0x463D
    045EA 3040      CPI	R20,0
    045EB E0E0      LDI	R30,0
    045EC 075E      CPC	R21,R30
    045ED F46C      BGE	0x45FB
    045EE 01C7      MOVW	R24,R14
    045EF 308A      CPI	R24,0xA
    045F0 E0E0      LDI	R30,0
    045F1 079E      CPC	R25,R30
    045F2 F441      BNE	0x45FB
    045F3 24CC      CLR	R12
    045F4 94C3      INC	R12
    045F5 01C5      MOVW	R24,R10
    045F6 9580      COM	R24
    045F7 9590      COM	R25
    045F8 9601      ADIW	R24,1
    045F9 015C      MOVW	R10,R24
    045FA C001      RJMP	0x45FC
    045FB 24CC      CLR	R12
    045FC 856A      LDD	R22,Y+10
    045FD 857B      LDD	R23,Y+11
    045FE 0197      MOVW	R18,R14
    045FF 0185      MOVW	R16,R10
    04600 940E 418E CALL	mod16u
    04602 01A8      MOVW	R20,R16
    04603 E089      LDI	R24,0x9
    04604 E090      LDI	R25,0
    04605 1780      CP	R24,R16
    04606 0791      CPC	R25,R17
    04607 F034      BLT	0x460E
    04608 01CA      MOVW	R24,R20
    04609 96C0      ADIW	R24,0x30
    0460A 01FB      MOVW	R30,R22
    0460B 9381      ST	Z+,R24
    0460C 01BF      MOVW	R22,R30
    0460D C006      RJMP	0x4614
    0460E 01CA      MOVW	R24,R20
    0460F 5A89      SUBI	R24,0xA9
    04610 4F9F      SBCI	R25,0xFF
    04611 01FB      MOVW	R30,R22
    04612 9381      ST	Z+,R24
    04613 01BF      MOVW	R22,R30
    04614 0197      MOVW	R18,R14
    04615 0185      MOVW	R16,R10
    04616 940E 4190 CALL	div16u
    04618 0158      MOVW	R10,R16
    04619 20AA      TST	R10
    0461A F719      BNE	0x45FE
    0461B 20BB      TST	R11
    0461C F709      BNE	0x45FE
    0461D 20CC      TST	R12
    0461E F021      BEQ	0x4623
    0461F E28D      LDI	R24,0x2D
    04620 01FB      MOVW	R30,R22
    04621 9381      ST	Z+,R24
    04622 01BF      MOVW	R22,R30
    04623 012B      MOVW	R4,R22
    04624 5061      SUBI	R22,1
    04625 4070      SBCI	R23,0
    04626 2422      CLR	R2
    04627 01F2      MOVW	R30,R4
    04628 8220      ST	Z,R2
    04629 84AA      LDD	R10,Y+10
    0462A 84BB      LDD	R11,Y+11
    0462B C00C      RJMP	0x4638
    0462C 01F5      MOVW	R30,R10
    0462D 80C0      LD	R12,Z
    0462E 01FB      MOVW	R30,R22
    0462F 8020      LD	R2,Z
    04630 01F5      MOVW	R30,R10
    04631 9221      ST	Z+,R2
    04632 015F      MOVW	R10,R30
    04633 011B      MOVW	R2,R22
    04634 5061      SUBI	R22,1
    04635 4070      SBCI	R23,0
    04636 01F1      MOVW	R30,R2
    04637 82C0      ST	Z,R12
    04638 16A6      CP	R10,R22
    04639 06B7      CPC	R11,R23
    0463A F388      BCS	0x462C
    0463B 850A      LDD	R16,Y+10
    0463C 851B      LDD	R17,Y+11
    0463D 940E 4299 CALL	pop_xgsetF0FC
    0463F 9624      ADIW	R28,4
    04640 9508      RET
_ltoa:
    04641 940E 415F CALL	push_arg4
    04643 940E 42A4 CALL	push_xgsetF0FC
    04645 9724      SBIW	R28,4
    04646 8828      LDD	R2,Y+16
    04647 8839      LDD	R3,Y+17
    04648 884A      LDD	R4,Y+18
    04649 885B      LDD	R5,Y+19
    0464A 8228      ST	Y,R2
    0464B 8239      STD	Y+1,R3
    0464C 824A      STD	Y+2,R4
    0464D 825B      STD	Y+3,R5
    0464E 8828      LDD	R2,Y+16
    0464F 8839      LDD	R3,Y+17
    04650 884A      LDD	R4,Y+18
    04651 885B      LDD	R5,Y+19
    04652 9488      BCLR	0
    04653 2022      TST	R2
    04654 0432      CPC	R3,R2
    04655 0442      CPC	R4,R2
    04656 0452      CPC	R5,R2
    04657 F441      BNE	0x4660
    04658 E380      LDI	R24,0x30
    04659 85EE      LDD	R30,Y+14
    0465A 85FF      LDD	R31,Y+15
    0465B 8380      ST	Z,R24
    0465C 2422      CLR	R2
    0465D 8221      STD	Z+1,R2
    0465E 018F      MOVW	R16,R30
    0465F C094      RJMP	0x46F4
    04660 E040      LDI	R20,0
    04661 E050      LDI	R21,0
    04662 E060      LDI	R22,0
    04663 E070      LDI	R23,0
    04664 8828      LDD	R2,Y+16
    04665 8839      LDD	R3,Y+17
    04666 884A      LDD	R4,Y+18
    04667 885B      LDD	R5,Y+19
    04668 1624      CP	R2,R20
    04669 0635      CPC	R3,R21
    0466A 0646      CPC	R4,R22
    0466B 0657      CPC	R5,R23
    0466C F4EC      BGE	0x468A
    0466D 898C      LDD	R24,Y+20
    0466E 899D      LDD	R25,Y+21
    0466F 308A      CPI	R24,0xA
    04670 E0A0      LDI	R26,0
    04671 079A      CPC	R25,R26
    04672 F4B9      BNE	0x468A
    04673 24AA      CLR	R10
    04674 94A3      INC	R10
    04675 E041      LDI	R20,1
    04676 E050      LDI	R21,0
    04677 E060      LDI	R22,0
    04678 E070      LDI	R23,0
    04679 8028      LD	R2,Y
    0467A 8039      LDD	R3,Y+1
    0467B 804A      LDD	R4,Y+2
    0467C 805B      LDD	R5,Y+3
    0467D 9420      COM	R2
    0467E 9430      COM	R3
    0467F 9440      COM	R4
    04680 9450      COM	R5
    04681 0E24      ADD	R2,R20
    04682 1E35      ADC	R3,R21
    04683 1E46      ADC	R4,R22
    04684 1E57      ADC	R5,R23
    04685 8228      ST	Y,R2
    04686 8239      STD	Y+1,R3
    04687 824A      STD	Y+2,R4
    04688 825B      STD	Y+3,R5
    04689 C001      RJMP	0x468B
    0468A 24AA      CLR	R10
    0468B 84CE      LDD	R12,Y+14
    0468C 84DF      LDD	R13,Y+15
    0468D 882C      LDD	R2,Y+20
    0468E 883D      LDD	R3,Y+21
    0468F 2444      CLR	R4
    04690 FC37      SBRC	R3,7
    04691 9440      COM	R4
    04692 2455      CLR	R5
    04693 FC47      SBRC	R4,7
    04694 9450      COM	R5
    04695 8108      LD	R16,Y
    04696 8119      LDD	R17,Y+1
    04697 812A      LDD	R18,Y+2
    04698 813B      LDD	R19,Y+3
    04699 925A      ST	-Y,R5
    0469A 924A      ST	-Y,R4
    0469B 923A      ST	-Y,R3
    0469C 922A      ST	-Y,R2
    0469D 940E 41AC CALL	mod32u
    0469F 0178      MOVW	R14,R16
    046A0 E089      LDI	R24,0x9
    046A1 E090      LDI	R25,0
    046A2 1780      CP	R24,R16
    046A3 0791      CPC	R25,R17
    046A4 F034      BLT	0x46AB
    046A5 01C7      MOVW	R24,R14
    046A6 96C0      ADIW	R24,0x30
    046A7 01F6      MOVW	R30,R12
    046A8 9381      ST	Z+,R24
    046A9 016F      MOVW	R12,R30
    046AA C006      RJMP	0x46B1
    046AB 01C7      MOVW	R24,R14
    046AC 5A89      SUBI	R24,0xA9
    046AD 4F9F      SBCI	R25,0xFF
    046AE 01F6      MOVW	R30,R12
    046AF 9381      ST	Z+,R24
    046B0 016F      MOVW	R12,R30
    046B1 882C      LDD	R2,Y+20
    046B2 883D      LDD	R3,Y+21
    046B3 2444      CLR	R4
    046B4 FC37      SBRC	R3,7
    046B5 9440      COM	R4
    046B6 2455      CLR	R5
    046B7 FC47      SBRC	R4,7
    046B8 9450      COM	R5
    046B9 8108      LD	R16,Y
    046BA 8119      LDD	R17,Y+1
    046BB 812A      LDD	R18,Y+2
    046BC 813B      LDD	R19,Y+3
    046BD 925A      ST	-Y,R5
    046BE 924A      ST	-Y,R4
    046BF 923A      ST	-Y,R3
    046C0 922A      ST	-Y,R2
    046C1 940E 41AA CALL	div32u
    046C3 8308      ST	Y,R16
    046C4 8319      STD	Y+1,R17
    046C5 832A      STD	Y+2,R18
    046C6 833B      STD	Y+3,R19
    046C7 8028      LD	R2,Y
    046C8 8039      LDD	R3,Y+1
    046C9 804A      LDD	R4,Y+2
    046CA 805B      LDD	R5,Y+3
    046CB 9488      BCLR	0
    046CC 2022      TST	R2
    046CD 0432      CPC	R3,R2
    046CE 0442      CPC	R4,R2
    046CF 0452      CPC	R5,R2
    046D0 F009      BEQ	0x46D2
    046D1 CFBB      RJMP	0x468D
    046D2 20AA      TST	R10
    046D3 F021      BEQ	0x46D8
    046D4 E28D      LDI	R24,0x2D
    046D5 01F6      MOVW	R30,R12
    046D6 9381      ST	Z+,R24
    046D7 016F      MOVW	R12,R30
    046D8 0126      MOVW	R4,R12
    046D9 01C2      MOVW	R24,R4
    046DA 9701      SBIW	R24,1
    046DB 016C      MOVW	R12,R24
    046DC 2422      CLR	R2
    046DD 01F2      MOVW	R30,R4
    046DE 8220      ST	Z,R2
    046DF 84EE      LDD	R14,Y+14
    046E0 84FF      LDD	R15,Y+15
    046E1 C00D      RJMP	0x46EF
    046E2 01F7      MOVW	R30,R14
    046E3 80A0      LD	R10,Z
    046E4 01F6      MOVW	R30,R12
    046E5 8020      LD	R2,Z
    046E6 01F7      MOVW	R30,R14
    046E7 9221      ST	Z+,R2
    046E8 017F      MOVW	R14,R30
    046E9 0116      MOVW	R2,R12
    046EA 01C1      MOVW	R24,R2
    046EB 9701      SBIW	R24,1
    046EC 016C      MOVW	R12,R24
    046ED 01F1      MOVW	R30,R2
    046EE 82A0      ST	Z,R10
    046EF 14EC      CP	R14,R12
    046F0 04FD      CPC	R15,R13
    046F1 F380      BCS	0x46E2
    046F2 850E      LDD	R16,Y+14
    046F3 851F      LDD	R17,Y+15
    046F4 9624      ADIW	R28,4
    046F5 940E 4299 CALL	pop_xgsetF0FC
    046F7 9624      ADIW	R28,4
    046F8 9508      RET
_ftoa:
    046F9 940E 415F CALL	push_arg4
    046FB 940E 42A4 CALL	push_xgsetF0FC
    046FD 9764      SBIW	R28,0x14
    046FE A0CA      LDD	R12,Y+34
    046FF A0DB      LDD	R13,Y+35
    04700 2422      CLR	R2
    04701 2433      CLR	R3
    04702 01F6      MOVW	R30,R12
    04703 8231      STD	Z+1,R3
    04704 8220      ST	Z,R2
    04705 8C2E      LDD	R2,Y+30
    04706 8C3F      LDD	R3,Y+31
    04707 A048      LDD	R4,Y+32
    04708 A059      LDD	R5,Y+33
    04709 EC0C      LDI	R16,0xCC
    0470A E010      LDI	R17,0
    0470B 940E 422C CALL	elpm32
    0470D 933A      ST	-Y,R19
    0470E 932A      ST	-Y,R18
    0470F 931A      ST	-Y,R17
    04710 930A      ST	-Y,R16
    04711 0181      MOVW	R16,R2
    04712 0192      MOVW	R18,R4
    04713 940E 45CA CALL	fpcmp2
    04715 F479      BNE	0x4725
    04716 E380      LDI	R24,0x30
    04717 9380 084F STS	config+20,R24
    04719 E28E      LDI	R24,0x2E
    0471A 9380 0850 STS	config+21,R24
    0471C E380      LDI	R24,0x30
    0471D 9380 0851 STS	config+22,R24
    0471F 2422      CLR	R2
    04720 9220 0852 STS	config+23,R2
    04722 E40F      LDI	R16,0x4F
    04723 E018      LDI	R17,0x8
    04724 C15E      RJMP	0x4883
    04725 8C2E      LDD	R2,Y+30
    04726 8C3F      LDD	R3,Y+31
    04727 A048      LDD	R4,Y+32
    04728 A059      LDD	R5,Y+33
    04729 8628      STD	Y+8,R2
    0472A 8639      STD	Y+9,R3
    0472B 864A      STD	Y+10,R4
    0472C 865B      STD	Y+11,R5
    0472D E187      LDI	R24,0x17
    0472E E090      LDI	R25,0
    0472F 8508      LDD	R16,Y+8
    04730 8519      LDD	R17,Y+9
    04731 852A      LDD	R18,Y+10
    04732 853B      LDD	R19,Y+11
    04733 938A      ST	-Y,R24
    04734 940E 4164 CALL	asr32
    04736 2F80      MOV	R24,R16
    04737 2799      CLR	R25
    04738 578F      SUBI	R24,0x7F
    04739 4090      SBCI	R25,0
    0473A 015C      MOVW	R10,R24
    0473B EF4F      LDI	R20,0xFF
    0473C EF5F      LDI	R21,0xFF
    0473D EF6F      LDI	R22,0xFF
    0473E E070      LDI	R23,0
    0473F 8428      LDD	R2,Y+8
    04740 8439      LDD	R3,Y+9
    04741 844A      LDD	R4,Y+10
    04742 845B      LDD	R5,Y+11
    04743 2224      AND	R2,R20
    04744 2235      AND	R3,R21
    04745 2246      AND	R4,R22
    04746 2257      AND	R5,R23
    04747 93EF      PUSH	R30
    04748 2DE4      MOV	R30,R4
    04749 68E0      ORI	R30,0x80
    0474A 2E4E      MOV	R4,R30
    0474B 91EF      POP	R30
    0474C 8A28      STD	Y+16,R2
    0474D 8A39      STD	Y+17,R3
    0474E 8A4A      STD	Y+18,R4
    0474F 8A5B      STD	Y+19,R5
    04750 E080      LDI	R24,0
    04751 838C      STD	Y+4,R24
    04752 838D      STD	Y+5,R24
    04753 838E      STD	Y+6,R24
    04754 838F      STD	Y+7,R24
    04755 E080      LDI	R24,0
    04756 878C      STD	Y+12,R24
    04757 878D      STD	Y+13,R24
    04758 878E      STD	Y+14,R24
    04759 878F      STD	Y+15,R24
    0475A 01C5      MOVW	R24,R10
    0475B 318F      CPI	R24,0x1F
    0475C E0E0      LDI	R30,0
    0475D 079E      CPC	R25,R30
    0475E F044      BLT	0x4767
    0475F EF8E      LDI	R24,0xFE
    04760 EF9F      LDI	R25,0xFF
    04761 01F6      MOVW	R30,R12
    04762 8391      STD	Z+1,R25
    04763 8380      ST	Z,R24
    04764 2700      CLR	R16
    04765 2711      CLR	R17
    04766 C11C      RJMP	0x4883
    04767 01C5      MOVW	R24,R10
    04768 3E89      CPI	R24,0xE9
    04769 EFEF      LDI	R30,0xFF
    0476A 079E      CPC	R25,R30
    0476B F444      BGE	0x4774
    0476C EF8F      LDI	R24,0xFF
    0476D EF9F      LDI	R25,0xFF
    0476E 01F6      MOVW	R30,R12
    0476F 8391      STD	Z+1,R25
    04770 8380      ST	Z,R24
    04771 2700      CLR	R16
    04772 2711      CLR	R17
    04773 C10F      RJMP	0x4883
    04774 01C5      MOVW	R24,R10
    04775 3187      CPI	R24,0x17
    04776 E0A0      LDI	R26,0
    04777 079A      CPC	R25,R26
    04778 F06C      BLT	0x4786
    04779 9747      SBIW	R24,0x17
    0477A 8908      LDD	R16,Y+16
    0477B 8919      LDD	R17,Y+17
    0477C 892A      LDD	R18,Y+18
    0477D 893B      LDD	R19,Y+19
    0477E 938A      ST	-Y,R24
    0477F 940E 4326 CALL	lsl32
    04781 870C      STD	Y+12,R16
    04782 871D      STD	Y+13,R17
    04783 872E      STD	Y+14,R18
    04784 873F      STD	Y+15,R19
    04785 C045      RJMP	0x47CB
    04786 01C5      MOVW	R24,R10
    04787 3080      CPI	R24,0
    04788 E0A0      LDI	R26,0
    04789 079A      CPC	R25,R26
    0478A F13C      BLT	0x47B2
    0478B E187      LDI	R24,0x17
    0478C E090      LDI	R25,0
    0478D 198A      SUB	R24,R10
    0478E 099B      SBC	R25,R11
    0478F 8908      LDD	R16,Y+16
    04790 8919      LDD	R17,Y+17
    04791 892A      LDD	R18,Y+18
    04792 893B      LDD	R19,Y+19
    04793 938A      ST	-Y,R24
    04794 940E 4164 CALL	asr32
    04796 870C      STD	Y+12,R16
    04797 871D      STD	Y+13,R17
    04798 872E      STD	Y+14,R18
    04799 873F      STD	Y+15,R19
    0479A 01C5      MOVW	R24,R10
    0479B 9601      ADIW	R24,1
    0479C 8908      LDD	R16,Y+16
    0479D 8919      LDD	R17,Y+17
    0479E 892A      LDD	R18,Y+18
    0479F 893B      LDD	R19,Y+19
    047A0 938A      ST	-Y,R24
    047A1 940E 4326 CALL	lsl32
    047A3 0118      MOVW	R2,R16
    047A4 0129      MOVW	R4,R18
    047A5 EF4F      LDI	R20,0xFF
    047A6 EF5F      LDI	R21,0xFF
    047A7 EF6F      LDI	R22,0xFF
    047A8 E070      LDI	R23,0
    047A9 2224      AND	R2,R20
    047AA 2235      AND	R3,R21
    047AB 2246      AND	R4,R22
    047AC 2257      AND	R5,R23
    047AD 822C      STD	Y+4,R2
    047AE 823D      STD	Y+5,R3
    047AF 824E      STD	Y+6,R4
    047B0 825F      STD	Y+7,R5
    047B1 C019      RJMP	0x47CB
    047B2 EF4F      LDI	R20,0xFF
    047B3 EF5F      LDI	R21,0xFF
    047B4 EF6F      LDI	R22,0xFF
    047B5 E070      LDI	R23,0
    047B6 8908      LDD	R16,Y+16
    047B7 8919      LDD	R17,Y+17
    047B8 892A      LDD	R18,Y+18
    047B9 893B      LDD	R19,Y+19
    047BA 2304      AND	R16,R20
    047BB 2315      AND	R17,R21
    047BC 2326      AND	R18,R22
    047BD 2337      AND	R19,R23
    047BE 01C5      MOVW	R24,R10
    047BF 9601      ADIW	R24,1
    047C0 9580      COM	R24
    047C1 9590      COM	R25
    047C2 5F8F      SUBI	R24,0xFF
    047C3 4F9F      SBCI	R25,0xFF
    047C4 938A      ST	-Y,R24
    047C5 940E 4164 CALL	asr32
    047C7 830C      STD	Y+4,R16
    047C8 831D      STD	Y+5,R17
    047C9 832E      STD	Y+6,R18
    047CA 833F      STD	Y+7,R19
    047CB E48F      LDI	R24,0x4F
    047CC E098      LDI	R25,0x8
    047CD 015C      MOVW	R10,R24
    047CE E040      LDI	R20,0
    047CF E050      LDI	R21,0
    047D0 E060      LDI	R22,0
    047D1 E070      LDI	R23,0
    047D2 8428      LDD	R2,Y+8
    047D3 8439      LDD	R3,Y+9
    047D4 844A      LDD	R4,Y+10
    047D5 845B      LDD	R5,Y+11
    047D6 1624      CP	R2,R20
    047D7 0635      CPC	R3,R21
    047D8 0646      CPC	R4,R22
    047D9 0657      CPC	R5,R23
    047DA F424      BGE	0x47DF
    047DB E28D      LDI	R24,0x2D
    047DC 01F5      MOVW	R30,R10
    047DD 9381      ST	Z+,R24
    047DE 015F      MOVW	R10,R30
    047DF 842C      LDD	R2,Y+12
    047E0 843D      LDD	R3,Y+13
    047E1 844E      LDD	R4,Y+14
    047E2 845F      LDD	R5,Y+15
    047E3 9488      BCLR	0
    047E4 2022      TST	R2
    047E5 0432      CPC	R3,R2
    047E6 0442      CPC	R4,R2
    047E7 0452      CPC	R5,R2
    047E8 F429      BNE	0x47EE
    047E9 E380      LDI	R24,0x30
    047EA 01F5      MOVW	R30,R10
    047EB 9381      ST	Z+,R24
    047EC 015F      MOVW	R10,R30
    047ED C016      RJMP	0x4804
    047EE E08A      LDI	R24,0xA
    047EF E090      LDI	R25,0
    047F0 839B      STD	Y+3,R25
    047F1 838A      STD	Y+2,R24
    047F2 842C      LDD	R2,Y+12
    047F3 843D      LDD	R3,Y+13
    047F4 844E      LDD	R4,Y+14
    047F5 845F      LDD	R5,Y+15
    047F6 8248      ST	Y,R4
    047F7 8259      STD	Y+1,R5
    047F8 0191      MOVW	R18,R2
    047F9 0185      MOVW	R16,R10
    047FA 940E 4641 CALL	_ltoa
    047FC C003      RJMP	0x4800
    047FD 01C5      MOVW	R24,R10
    047FE 9601      ADIW	R24,1
    047FF 015C      MOVW	R10,R24
    04800 01F5      MOVW	R30,R10
    04801 8020      LD	R2,Z
    04802 2022      TST	R2
    04803 F7C9      BNE	0x47FD
    04804 E28E      LDI	R24,0x2E
    04805 01F5      MOVW	R30,R10
    04806 9381      ST	Z+,R24
    04807 015F      MOVW	R10,R30
    04808 802C      LDD	R2,Y+4
    04809 803D      LDD	R3,Y+5
    0480A 804E      LDD	R4,Y+6
    0480B 805F      LDD	R5,Y+7
    0480C 9488      BCLR	0
    0480D 2022      TST	R2
    0480E 0432      CPC	R3,R2
    0480F 0442      CPC	R4,R2
    04810 0452      CPC	R5,R2
    04811 F421      BNE	0x4816
    04812 E380      LDI	R24,0x30
    04813 9381      ST	Z+,R24
    04814 015F      MOVW	R10,R30
    04815 C068      RJMP	0x487E
    04816 E48F      LDI	R24,0x4F
    04817 E098      LDI	R25,0x8
    04818 0115      MOVW	R2,R10
    04819 1A28      SUB	R2,R24
    0481A 0A39      SBC	R3,R25
    0481B E08F      LDI	R24,0xF
    0481C E090      LDI	R25,0
    0481D 1982      SUB	R24,R2
    0481E 0993      SBC	R25,R3
    0481F 9701      SBIW	R24,1
    04820 2EC8      MOV	R12,R24
    04821 E087      LDI	R24,7
    04822 158C      CP	R24,R12
    04823 F408      BCC	0x4825
    04824 2EC8      MOV	R12,R24
    04825 24EE      CLR	R14
    04826 C042      RJMP	0x4869
    04827 E083      LDI	R24,3
    04828 E090      LDI	R25,0
    04829 810C      LDD	R16,Y+4
    0482A 811D      LDD	R17,Y+5
    0482B 812E      LDD	R18,Y+6
    0482C 813F      LDD	R19,Y+7
    0482D 938A      ST	-Y,R24
    0482E 940E 4326 CALL	lsl32
    04830 0118      MOVW	R2,R16
    04831 0129      MOVW	R4,R18
    04832 806C      LDD	R6,Y+4
    04833 807D      LDD	R7,Y+5
    04834 808E      LDD	R8,Y+6
    04835 809F      LDD	R9,Y+7
    04836 0C66      LSL	R6
    04837 1C77      ROL	R7
    04838 1C88      ROL	R8
    04839 1C99      ROL	R9
    0483A 0C26      ADD	R2,R6
    0483B 1C37      ADC	R3,R7
    0483C 1C48      ADC	R4,R8
    0483D 1C59      ADC	R5,R9
    0483E 822C      STD	Y+4,R2
    0483F 823D      STD	Y+5,R3
    04840 824E      STD	Y+6,R4
    04841 825F      STD	Y+7,R5
    04842 E188      LDI	R24,0x18
    04843 E090      LDI	R25,0
    04844 810C      LDD	R16,Y+4
    04845 811D      LDD	R17,Y+5
    04846 812E      LDD	R18,Y+6
    04847 813F      LDD	R19,Y+7
    04848 938A      ST	-Y,R24
    04849 940E 4164 CALL	asr32
    0484B 0118      MOVW	R2,R16
    0484C 0129      MOVW	R4,R18
    0484D E340      LDI	R20,0x30
    0484E E050      LDI	R21,0
    0484F E060      LDI	R22,0
    04850 E070      LDI	R23,0
    04851 0E24      ADD	R2,R20
    04852 1E35      ADC	R3,R21
    04853 1E46      ADC	R4,R22
    04854 1E57      ADC	R5,R23
    04855 01F5      MOVW	R30,R10
    04856 9221      ST	Z+,R2
    04857 015F      MOVW	R10,R30
    04858 EF4F      LDI	R20,0xFF
    04859 EF5F      LDI	R21,0xFF
    0485A EF6F      LDI	R22,0xFF
    0485B E070      LDI	R23,0
    0485C 802C      LDD	R2,Y+4
    0485D 803D      LDD	R3,Y+5
    0485E 804E      LDD	R4,Y+6
    0485F 805F      LDD	R5,Y+7
    04860 2224      AND	R2,R20
    04861 2235      AND	R3,R21
    04862 2246      AND	R4,R22
    04863 2257      AND	R5,R23
    04864 822C      STD	Y+4,R2
    04865 823D      STD	Y+5,R3
    04866 824E      STD	Y+6,R4
    04867 825F      STD	Y+7,R5
    04868 94E3      INC	R14
    04869 14EC      CP	R14,R12
    0486A F408      BCC	0x486C
    0486B CFBB      RJMP	0x4827
    0486C 01C5      MOVW	R24,R10
    0486D 9701      SBIW	R24,1
    0486E 015C      MOVW	R10,R24
    0486F C003      RJMP	0x4873
    04870 01C5      MOVW	R24,R10
    04871 9701      SBIW	R24,1
    04872 015C      MOVW	R10,R24
    04873 01F5      MOVW	R30,R10
    04874 8180      LD	R24,Z
    04875 3380      CPI	R24,0x30
    04876 F421      BNE	0x487B
    04877 9731      SBIW	R30,1
    04878 8180      LD	R24,Z
    04879 328E      CPI	R24,0x2E
    0487A F7A9      BNE	0x4870
    0487B 01C5      MOVW	R24,R10
    0487C 9601      ADIW	R24,1
    0487D 015C      MOVW	R10,R24
    0487E 2422      CLR	R2
    0487F 01F5      MOVW	R30,R10
    04880 8220      ST	Z,R2
    04881 E40F      LDI	R16,0x4F
    04882 E018      LDI	R17,0x8
    04883 9664      ADIW	R28,0x14
    04884 940E 4299 CALL	pop_xgsetF0FC
    04886 9624      ADIW	R28,4
    04887 9508      RET
