Interrupt Vectors
    00000 940C 026A JMP	__start|__text_start
    0003C 940C 36FD JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    0026A EFCF      LDI	R28,0xFF
    0026B E1D0      LDI	R29,0x10
    0026C BFCD      OUT	0x3D,R28
    0026D BFDE      OUT	0x3E,R29
    0026E 51CE      SUBI	R28,0x1E
    0026F 40D0      SBCI	R29,0
    00270 EA0A      LDI	R16,0xAA
    00271 8308      ST	Y,R16
    00272 2400      CLR	R0
    00273 E0E4      LDI	R30,4
    00274 E0F5      LDI	R31,5
    00275 E017      LDI	R17,7
    00276 3EEB      CPI	R30,0xEB
    00277 07F1      CPC	R31,R17
    00278 F011      BEQ	0x027B
    00279 9201      ST	Z+,R0
    0027A CFFB      RJMP	0x0276
    0027B 8300      ST	Z,R16
    0027C EDE0      LDI	R30,0xD0
    0027D E0F0      LDI	R31,0
    0027E E0A0      LDI	R26,0
    0027F E0B1      LDI	R27,1
    00280 E014      LDI	R17,4
    00281 E000      LDI	R16,0
    00282 BF0B      OUT	0x3B,R16
    00283 3DE4      CPI	R30,0xD4
    00284 07F1      CPC	R31,R17
    00285 F021      BEQ	0x028A
    00286 95C8      LPM
    00287 9631      ADIW	R30,1
    00288 920D      ST	X+,R0
    00289 CFF9      RJMP	0x0283
    0028A 940E 245D CALL	_main
_exit:
    0028C CFFF      RJMP	_exit
_disk_initialize:
  state                --> R20
  drv                  --> R10
    0028D 92AA      ST	-Y,R10
    0028E 934A      ST	-Y,R20
    0028F 2EA0      MOV	R10,R16
FILE: D:\LQD\software\master\software_src\diskio.c
(0001) 
(0002) 
(0003) /*-----------------------------------------------------------------------*/
(0004) /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
(0005) /*-----------------------------------------------------------------------*/
(0006) /* This is a stub disk I/O module that acts as front end of the existing */
(0007) /* disk I/O modules and attach it to FatFs module with common interface. */
(0008) /*-----------------------------------------------------------------------*/
(0009) 
(0010) #include "diskio.h"
(0011) #include "sd.h"
(0012) 
(0013) 
(0014) /*-----------------------------------------------------------------------*/
(0015) /* Correspondence between physical drive number and physical drive.      */
(0016) /* Note that Tiny-FatFs supports only single drive and always            */
(0017)                                       
(0018) 
(0019) ////////////////////////////
(0020) /*
(0021)    struct tm {
(0022)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0023)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0024) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0025) 	int tm_mday;  // 日 day of the month, 1 to 31
(0026) 	int tm_mon;   // 月 months since January, 0 to 11
(0027) 	int tm_year;  // 年 years since 1900
(0028) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0029) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0030)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0031)  	};
(0032) */
(0033) /*-----------------------------------------------------------------------*/
(0034) /* Inidialize a Drive                                                    */
(0035) 
(0036) DSTATUS disk_initialize ( 
(0037) BYTE drv				/* Physical drive nmuber (0..) */
(0038) )
(0039) {
(0040)     unsigned char state;
(0041) 
(0042)     if(drv)
    00290 20AA      TST	R10
    00291 F011      BEQ	0x0294
(0043)     {
(0044)         return STA_NOINIT;  //仅支持磁盘0的操作
    00292 E001      LDI	R16,1
    00293 C00C      RJMP	0x02A0
(0045)     }
(0046) 
(0047)     state = SD_Init();
    00294 940E 2B72 CALL	_SD_Init
    00296 2F40      MOV	R20,R16
(0048)     if(state == STA_NODISK)
    00297 3002      CPI	R16,2
    00298 F411      BNE	0x029B
(0049)     {
(0050)         return STA_NODISK;
    00299 E002      LDI	R16,2
    0029A C005      RJMP	0x02A0
(0051)     }
(0052)     else if(state != 0)
    0029B 2344      TST	R20
    0029C F011      BEQ	0x029F
(0053)     {
(0054)         return STA_NOINIT;  //其他错误：初始化失败
    0029D E001      LDI	R16,1
    0029E C001      RJMP	0x02A0
(0055)     }
(0056)     else
(0057)     {
(0058)         return 0;           //初始化成功
    0029F 2700      CLR	R16
    002A0 9149      LD	R20,Y+
    002A1 90A9      LD	R10,Y+
    002A2 9508      RET
(0059)     }
(0060) }
(0061) 
(0062) 
(0063) 
(0064) /*-----------------------------------------------------------------------*/
(0065) /* Return Disk Status                                                    */
(0066) 
(0067) DSTATUS disk_status (
(0068) 	BYTE drv		/* Physical drive nmuber (0..) */
(0069) )
(0070) {
(0071)     if(drv)
_disk_status:
  drv                  --> R16
    002A3 2300      TST	R16
    002A4 F011      BEQ	0x02A7
(0072)     {
(0073)         return STA_NOINIT;  //仅支持磁盘0操作
    002A5 E001      LDI	R16,1
    002A6 C001      RJMP	0x02A8
(0074)     }
(0075)     return 0;
    002A7 2700      CLR	R16
    002A8 9508      RET
_disk_read:
  res                  --> R10
  count                --> R20
  sector               --> Y,+10
  buff                 --> R12
  drv                  --> R14
    002A9 940E 40A9 CALL	push_xgset30FC
    002AB 0169      MOVW	R12,R18
    002AC 2EE0      MOV	R14,R16
    002AD 9722      SBIW	R28,2
    002AE 854E      LDD	R20,Y+14
(0076) }
(0077) 
(0078) 
(0079) 
(0080) /*-----------------------------------------------------------------------*/
(0081) /* Read Sector(s)                                                        */
(0082) 
(0083) DRESULT disk_read (
(0084) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0085) 	BYTE *buff,		/* Data buffer to store read data */
(0086) 	DWORD sector,	/* Sector address (LBA) */
(0087) 	BYTE count		/* Number of sectors to read (1..255) */
(0088) )
(0089) {
(0090) 	unsigned char res=0;
    002AF 24AA      CLR	R10
(0091)     if (drv || !count)
    002B0 20EE      TST	R14
    002B1 F411      BNE	0x02B4
    002B2 2344      TST	R20
    002B3 F411      BNE	0x02B6
(0092)     {    
(0093)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002B4 E004      LDI	R16,4
    002B5 C010      RJMP	0x02C6
(0094)     }
(0095) 
(0096)     if(count==1)            //1个sector的读操作      
    002B6 3041      CPI	R20,1
    002B7 F449      BNE	0x02C1
(0097)     {                                                
(0098)         res = SD_Read_Sector(sector, buff);      
    002B8 82D9      STD	Y+1,R13
    002B9 82C8      ST	Y,R12
    002BA 850A      LDD	R16,Y+10
    002BB 851B      LDD	R17,Y+11
    002BC 852C      LDD	R18,Y+12
    002BD 853D      LDD	R19,Y+13
    002BE 940E 2C58 CALL	_SD_Read_Sector
    002C0 2EA0      MOV	R10,R16
(0099)     }                                                                                                 
(0100) 
(0101)     //处理返回值，将SD_driver.c的返回值转成ff.c的返回值
(0102)     if(res == 0x00)
    002C1 20AA      TST	R10
    002C2 F411      BNE	0x02C5
(0103)     {
(0104)         return RES_OK;
    002C3 2700      CLR	R16
    002C4 C001      RJMP	0x02C6
(0105)     }
(0106)     else
(0107)     {
(0108)         return RES_ERROR;
    002C5 E001      LDI	R16,1
    002C6 9622      ADIW	R28,2
    002C7 940C 4093 JMP	pop_xgset30FC
_disk_write:
  count                --> R12
  sector               --> Y,+8
  buff                 --> R10
  drv                  --> R14
    002C9 940E 40AB CALL	push_xgset00FC
    002CB 0159      MOVW	R10,R18
    002CC 2EE0      MOV	R14,R16
    002CD 9722      SBIW	R28,2
    002CE 84CC      LDD	R12,Y+12
(0109)     }
(0110) }
(0111) 
(0112) 
(0113) 
(0114) /*-----------------------------------------------------------------------*/
(0115) /* Write Sector(s)                                                       */
(0116) 
(0117) #if _READONLY == 0
(0118) DRESULT disk_write (
(0119) 	BYTE drv,			/* Physical drive nmuber (0..) */
(0120) 	BYTE *buff,	        /* Data to be written */
(0121) 	DWORD sector,		/* Sector address (LBA) */
(0122) 	BYTE count			/* Number of sectors to write (1..255) */
(0123) )
(0124) {
(0125)     if (drv || !count)
    002CF 20EE      TST	R14
    002D0 F411      BNE	0x02D3
    002D1 20CC      TST	R12
    002D2 F411      BNE	0x02D5
(0126)     {    
(0127)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002D3 E004      LDI	R16,4
    002D4 C009      RJMP	0x02DE
(0128)     }   
(0129)    // 读写操作
(0130)     SD_Write_Sector(sector,buff);
    002D5 82B9      STD	Y+1,R11
    002D6 82A8      ST	Y,R10
    002D7 8508      LDD	R16,Y+8
    002D8 8519      LDD	R17,Y+9
    002D9 852A      LDD	R18,Y+10
    002DA 853B      LDD	R19,Y+11
    002DB 940E 2BD2 CALL	_SD_Write_Sector
(0131) 	  
(0132)     return RES_OK;
    002DD 2700      CLR	R16
    002DE 9622      ADIW	R28,2
    002DF 940C 408C JMP	pop_xgset00FC
_disk_ioctl:
  buff                 --> Y,+4
  ctrl                 --> Y,+2
  drv                  --> Y,+0
    002E1 940E 3F62 CALL	push_arg4
(0133) }
(0134) #endif /* _READONLY */
(0135) 
(0136) 
(0137) 
(0138) /*-----------------------------------------------------------------------*/
(0139) /* Miscellaneous Functions                                               */
(0140) DRESULT disk_ioctl (
(0141) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0142) 	BYTE ctrl,		/* Control code */
(0143) 	void *buff		/* Buffer to send/receive control data */
(0144) )
(0145) {
(0146)  	drv=drv;
(0147) 	ctrl=ctrl;
(0148) 	buff=buff;
(0149) 	return 0;
    002E3 2700      CLR	R16
    002E4 9624      ADIW	R28,4
    002E5 9508      RET
(0150) }
(0151) DWORD get_fattime (void)
(0152) {
(0153) 
(0154)   return 1950466005;
_get_fattime:
    002E6 ED05      LDI	R16,0xD5
    002E7 EB1F      LDI	R17,0xBF
    002E8 E421      LDI	R18,0x41
    002E9 E734      LDI	R19,0x74
    002EA 9508      RET
ff.c:mem_cpy:
  s                    --> R12
  d                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    002EB 940E 40D4 CALL	push_xgset303C
    002ED 814E      LDD	R20,Y+6
    002EE 815F      LDD	R21,Y+7
FILE: D:\LQD\software\master\software_src\ff.c
(0001) /*----------------------------------------------------------------------------/
(0002) /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
(0003) /-----------------------------------------------------------------------------/
(0004) / FatFs module is a generic FAT file system module for small embedded systems.
(0005) / This is a free software that opened for education, research and commercial
(0006) / developments under license policy of following terms.
(0007) /
(0008) /  Copyright (C) 2011, ChaN, all right reserved.
(0009) /
(0010) / * The FatFs module is a free software and there is NO WARRANTY.
(0011) / * No restriction on use. You can use, modify and redistribute it for
(0012) /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
(0013) / * Redistributions of source code must retain the above copyright notice.
(0014) /
(0015) /-----------------------------------------------------------------------------/
(0016) / Feb 26,'06 R0.00  Prototype.
(0017) /
(0018) / Apr 29,'06 R0.01  First stable version.
(0019) /
(0020) / Jun 01,'06 R0.02  Added FAT12 support.
(0021) /                   Removed unbuffered mode.
(0022) /                   Fixed a problem on small (<32M) partition.
(0023) / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
(0024) /
(0025) / Sep 22,'06 R0.03  Added f_rename().
(0026) /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
(0027) / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
(0028) /                   Fixed f_mkdir() creates incorrect directory on FAT32.
(0029) /
(0030) / Feb 04,'07 R0.04  Supported multiple drive system.
(0031) /                   Changed some interfaces for multiple drive system.
(0032) /                   Changed f_mountdrv() to f_mount().
(0033) /                   Added f_mkfs().
(0034) / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
(0035) /                   Added a capability of extending file size to f_lseek().
(0036) /                   Added minimization level 3.
(0037) /                   Fixed an endian sensitive code in f_mkfs().
(0038) / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
(0039) /                   Added FSInfo support.
(0040) /                   Fixed DBCS name can result FR_INVALID_NAME.
(0041) /                   Fixed short seek (<= csize) collapses the file object.
(0042) /
(0043) / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
(0044) /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
(0045) /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
(0046) / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
(0047) /                   Fixed off by one error at FAT sub-type determination.
(0048) /                   Fixed btr in f_read() can be mistruncated.
(0049) /                   Fixed cached sector is not flushed when create and close without write.
(0050) /
(0051) / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
(0052) /                   Improved performance of f_lseek() on moving to the same or following cluster.
(0053) /
(0054) / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
(0055) /                   Added long file name feature.
(0056) /                   Added multiple code page feature.
(0057) /                   Added re-entrancy for multitask operation.
(0058) /                   Added auto cluster size selection to f_mkfs().
(0059) /                   Added rewind option to f_readdir().
(0060) /                   Changed result code of critical errors.
(0061) /                   Renamed string functions to avoid name collision.
(0062) / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
(0063) /                   Added multiple sector size feature.
(0064) / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
(0065) /                   Fixed wrong cache control in f_lseek().
(0066) /                   Added relative path feature.
(0067) /                   Added f_chdir() and f_chdrive().
(0068) /                   Added proper case conversion to extended char.
(0069) / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
(0070) /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
(0071) /                   Fixed name matching error on the 13 char boundary.
(0072) /                   Added a configuration option, _LFN_UNICODE.
(0073) /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
(0074) /
(0075) / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
(0076) /                   Added file lock feature. (_FS_SHARE)
(0077) /                   Added fast seek feature. (_USE_FASTSEEK)
(0078) /                   Changed some types on the API, XCHAR->TCHAR.
(0079) /                   Changed fname member in the FILINFO structure on Unicode cfg.
(0080) /                   String functions support UTF-8 encoding files on Unicode cfg.
(0081) / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
(0082) /                   Added sector erase feature. (_USE_ERASE)
(0083) /                   Moved file lock semaphore table from fs object to the bss.
(0084) /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
(0085) /                   Fixed f_mkfs() creates wrong FAT32 volume.
(0086) / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
(0087) /                   f_lseek() reports required table size on creating CLMP.
(0088) /                   Extended format syntax of f_printf function.
(0089) /                   Ignores duplicated directory separators in given path names.
(0090) /
(0091) / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
(0092) /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
(0093) /---------------------------------------------------------------------------*/
(0094) 
(0095) #include "ff.h"			/* FatFs configurations and declarations */
(0096) #include "diskio.h"		/* Declarations of low level disk I/O functions */
(0097) #include <string.h>
(0098) 
(0099) /*--------------------------------------------------------------------------
(0100) 
(0101)    Module Private Definitions
(0102) 
(0103) ---------------------------------------------------------------------------*/
(0104) 
(0105) #if _FATFS != 6502	/* Revision ID */
(0106) #error Wrong include file (ff.h).
(0107) #endif
(0108) 
(0109) 
(0110) /* Definitions on sector size */
(0111) #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
(0112) #error Wrong sector size.
(0113) #endif
(0114) #if _MAX_SS != 512
(0115) #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
(0116) #else
(0117) #define	SS(fs)	512U			/* Fixed sector size */
(0118) #endif
(0119) 
(0120) 
(0121) /* Reentrancy related */
(0122) #if _FS_REENTRANT
(0123) #if _USE_LFN == 1
(0124) #error Static LFN work area must not be used in re-entrant configuration.
(0125) #endif
(0126) #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
(0127) #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
(0128) #else
(0129) #define	ENTER_FF(fs)
(0130) #define LEAVE_FF(fs, res)	return res
(0131) #endif
(0132) 
(0133) #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
(0134) 
(0135) 
(0136) /* File shareing feature */
(0137) #if _FS_SHARE
(0138) #if _FS_READONLY
(0139) #error _FS_SHARE must be 0 on read-only cfg.
(0140) #endif
(0141) typedef struct {
(0142) 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
(0143) 	DWORD clu;				/* File ID 2, directory */
(0144) 	WORD idx;				/* File ID 3, directory index */
(0145) 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
(0146) } FILESEM;
(0147) #endif
(0148) 
(0149) 
(0150) /* Misc definitions */
(0151) #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
(0152) #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
(0153) 
(0154) 
(0155) /* DBCS code ranges and SBCS extend char conversion table */
(0156) 
(0157) #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
(0158) #define _DF1S	0x81	/* DBC 1st byte range 1 start */
(0159) #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
(0160) #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
(0161) #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
(0162) #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
(0163) #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
(0164) #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
(0165) #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
(0166) 
(0167) #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
(0168) #define _DF1S	0x81
(0169) #define _DF1E	0xFE
(0170) #define _DS1S	0x40
(0171) #define _DS1E	0x7E
(0172) #define _DS2S	0x80
(0173) #define _DS2E	0xFE
(0174) 
(0175) #elif _CODE_PAGE == 949	/* Korean */
(0176) #define _DF1S	0x81
(0177) #define _DF1E	0xFE
(0178) #define _DS1S	0x41
(0179) #define _DS1E	0x5A
(0180) #define _DS2S	0x61
(0181) #define _DS2E	0x7A
(0182) #define _DS3S	0x81
(0183) #define _DS3E	0xFE
(0184) 
(0185) #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
(0186) #define _DF1S	0x81
(0187) #define _DF1E	0xFE
(0188) #define _DS1S	0x40
(0189) #define _DS1E	0x7E
(0190) #define _DS2S	0xA1
(0191) #define _DS2E	0xFE
(0192) 
(0193) #elif _CODE_PAGE == 437	/* U.S. (OEM) */
(0194) #define _DF1S	0
(0195) #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0196) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0197) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0198) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0199) 
(0200) #elif _CODE_PAGE == 720	/* Arabic (OEM) */
(0201) #define _DF1S	0
(0202) #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0203) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0204) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0205) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0206) 
(0207) #elif _CODE_PAGE == 737	/* Greek (OEM) */
(0208) #define _DF1S	0
(0209) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
(0210) 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0211) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0212) 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0213) 
(0214) #elif _CODE_PAGE == 775	/* Baltic (OEM) */
(0215) #define _DF1S	0
(0216) #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0217) 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0218) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0219) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0220) 
(0221) #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
(0222) #define _DF1S	0
(0223) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0224) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0225) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0226) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0227) 
(0228) #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
(0229) #define _DF1S	0
(0230) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
(0231) 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
(0232) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0233) 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
(0234) 
(0235) #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
(0236) #define _DF1S	0
(0237) #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
(0238) 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
(0239) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
(0240) 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
(0241) 
(0242) #elif _CODE_PAGE == 857	/* Turkish (OEM) */
(0243) #define _DF1S	0
(0244) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
(0245) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0246) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0247) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0248) 
(0249) #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
(0250) #define _DF1S	0
(0251) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0252) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0253) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0254) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0255) 
(0256) #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
(0257) #define _DF1S	0
(0258) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0259) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0260) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0261) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0262) 
(0263) #elif _CODE_PAGE == 866	/* Russian (OEM) */
(0264) #define _DF1S	0
(0265) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0266) 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0267) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0268) 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0269) 
(0270) #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
(0271) #define _DF1S	0
(0272) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0273) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0274) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0275) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0276) 
(0277) #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
(0278) #define _DF1S	0
(0279) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0280) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
(0281) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0282) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0283) 
(0284) #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
(0285) #define _DF1S	0
(0286) #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0287) 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
(0288) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0289) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
(0290) 
(0291) #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
(0292) #define _DF1S	0
(0293) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
(0294) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0295) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0296) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0297) 
(0298) #elif _CODE_PAGE == 1253 /* Greek (Windows) */
(0299) #define _DF1S	0
(0300) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0301) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0302) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
(0303) 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
(0304) 
(0305) #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
(0306) #define _DF1S	0
(0307) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0308) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0309) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0310) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0311) 
(0312) #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
(0313) #define _DF1S	0
(0314) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0315) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0316) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0317) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0318) 
(0319) #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
(0320) #define _DF1S	0
(0321) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0322) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0323) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0324) 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
(0325) 
(0326) #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
(0327) #define _DF1S	0
(0328) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0329) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
(0330) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0331) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0332) 
(0333) #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
(0334) #define _DF1S	0
(0335) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
(0336) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0337) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0338) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
(0339) 
(0340) #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
(0341) #if _USE_LFN
(0342) #error Cannot use LFN feature without valid code page.
(0343) #endif
(0344) #define _DF1S	0
(0345) 
(0346) #else
(0347) #error Unknown code page
(0348) 
(0349) #endif
(0350) 
(0351) 
(0352) /* Character code support macros */
(0353) #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
(0354) #define IsLower(c)	(((c)>='a')&&((c)<='z'))
(0355) #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
(0356) 
(0357) #if _DF1S		/* Code page is DBCS */
(0358) 
(0359) #ifdef _DF2S	/* Two 1st byte areas */
(0360) #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
(0361) #else			/* One 1st byte area */
(0362) #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
(0363) #endif
(0364) 
(0365) #ifdef _DS3S	/* Three 2nd byte areas */
(0366) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
(0367) #else			/* Two 2nd byte areas */
(0368) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
(0369) #endif
(0370) 
(0371) #else			/* Code page is SBCS */
(0372) 
(0373) #define IsDBCS1(c)	0
(0374) #define IsDBCS2(c)	0
(0375) 
(0376) #endif /* _DF1S */
(0377) 
(0378) 
(0379) /* Name status flags */
(0380) #define NS			11		/* Index of name status byte in fn[] */
(0381) #define NS_LOSS		0x01	/* Out of 8.3 format */
(0382) #define NS_LFN		0x02	/* Force to create LFN entry */
(0383) #define NS_LAST		0x04	/* Last segment */
(0384) #define NS_BODY		0x08	/* Lower case flag (body) */
(0385) #define NS_EXT		0x10	/* Lower case flag (ext) */
(0386) #define NS_DOT		0x20	/* Dot entry */
(0387) 
(0388) 
(0389) /* FAT sub-type boundaries */
(0390) /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
(0391) #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
(0392) #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
(0393) 
(0394) 
(0395) /* FatFs refers the members in the FAT structures as byte array instead of
(0396) / structure member because the structure is not binary compatible between
(0397) / different platforms */
(0398) 
(0399) #define BS_jmpBoot			0	/* Jump instruction (3) */
(0400) #define BS_OEMName			3	/* OEM name (8) */
(0401) #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
(0402) #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
(0403) #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
(0404) #define BPB_NumFATs			16	/* Number of FAT copies (1) */
(0405) #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
(0406) #define BPB_TotSec16		19	/* Volume size [sector] (2) */
(0407) #define BPB_Media			21	/* Media descriptor (1) */
(0408) #define BPB_FATSz16			22	/* FAT size [sector] (2) */
(0409) #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
(0410) #define BPB_NumHeads		26	/* Number of heads (2) */
(0411) #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
(0412) #define BPB_TotSec32		32	/* Volume size [sector] (4) */
(0413) #define BS_DrvNum			36	/* Physical drive number (2) */
(0414) #define BS_BootSig			38	/* Extended boot signature (1) */
(0415) #define BS_VolID			39	/* Volume serial number (4) */
(0416) #define BS_VolLab			43	/* Volume label (8) */
(0417) #define BS_FilSysType		54	/* File system type (1) */
(0418) #define BPB_FATSz32			36	/* FAT size [sector] (4) */
(0419) #define BPB_ExtFlags		40	/* Extended flags (2) */
(0420) #define BPB_FSVer			42	/* File system version (2) */
(0421) #define BPB_RootClus		44	/* Root dir first cluster (4) */
(0422) #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
(0423) #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
(0424) #define BS_DrvNum32			64	/* Physical drive number (2) */
(0425) #define BS_BootSig32		66	/* Extended boot signature (1) */
(0426) #define BS_VolID32			67	/* Volume serial number (4) */
(0427) #define BS_VolLab32			71	/* Volume label (8) */
(0428) #define BS_FilSysType32		82	/* File system type (1) */
(0429) #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
(0430) #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
(0431) #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
(0432) #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
(0433) #define MBR_Table			446	/* MBR: Partition table offset (2) */
(0434) #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
(0435) #define BS_55AA				510	/* Boot sector signature (2) */
(0436) 
(0437) #define	DIR_Name			0	/* Short file name (11) */
(0438) #define	DIR_Attr			11	/* Attribute (1) */
(0439) #define	DIR_NTres			12	/* NT flag (1) */
(0440) #define	DIR_CrtTime			14	/* Created time (2) */
(0441) #define	DIR_CrtDate			16	/* Created date (2) */
(0442) #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
(0443) #define	DIR_WrtTime			22	/* Modified time (2) */
(0444) #define	DIR_WrtDate			24	/* Modified date (2) */
(0445) #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
(0446) #define	DIR_FileSize		28	/* File size (4) */
(0447) #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
(0448) #define	LDIR_Attr			11	/* LFN attribute (1) */
(0449) #define	LDIR_Type			12	/* LFN type (1) */
(0450) #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
(0451) #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
(0452) #define	SZ_DIR				32		/* Size of a directory entry */
(0453) #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
(0454) #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
(0455) #define	NDDE				0x05	/* Replacement of a character collides with DDE */
(0456) 
(0457) 
(0458) /*------------------------------------------------------------*/
(0459) /* Module private work area                                   */
(0460) /*------------------------------------------------------------*/
(0461) /* Note that uninitialized variables with static duration are
(0462) /  zeroed/nulled at start-up. If not, the compiler or start-up
(0463) /  routine is out of ANSI-C standard.
(0464) */
(0465) 
(0466) #if _VOLUMES
(0467) static
(0468) FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
(0469) #else
(0470) #error Number of volumes must not be 0.
(0471) #endif
(0472) 
(0473) static
(0474) WORD Fsid;				/* File system mount ID */
(0475) 
(0476) #if _FS_RPATH
(0477) static
(0478) BYTE CurrVol;			/* Current drive */
(0479) #endif
(0480) 
(0481) #if _FS_SHARE
(0482) static
(0483) FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
(0484) #endif
(0485) 
(0486) #if _USE_LFN == 0			/* No LFN feature */
(0487) #define	DEF_NAMEBUF			BYTE sfn[12]
(0488) #define INIT_BUF(dobj)		(dobj).fn = sfn
(0489) #define	FREE_BUF()
(0490) 
(0491) #elif _USE_LFN == 1			/* LFN feature with static working buffer */
(0492) static WCHAR LfnBuf[_MAX_LFN+1];
(0493) #define	DEF_NAMEBUF			BYTE sfn[12]
(0494) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
(0495) #define	FREE_BUF()
(0496) 
(0497) #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
(0498) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
(0499) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
(0500) #define	FREE_BUF()
(0501) 
(0502) #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
(0503) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
(0504) #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
(0505) 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
(0506) 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
(0507) #define	FREE_BUF()			ff_memfree(lfn)
(0508) 
(0509) #else
(0510) #error Wrong LFN configuration.
(0511) #endif
(0512) 
(0513) 
(0514) 
(0515) 
(0516) /*--------------------------------------------------------------------------
(0517) 
(0518)    Module Private Functions
(0519) 
(0520) ---------------------------------------------------------------------------*/
(0521) 
(0522) 
(0523) /*-----------------------------------------------------------------------*/
(0524) /* String functions                                                      */
(0525) /*-----------------------------------------------------------------------*/
(0526) 
(0527) /* Copy memory to memory */
(0528) static
(0529) void mem_cpy (void* dst, const void* src, UINT cnt) {
(0530) 	BYTE *d = (BYTE*)dst;
    002EF 0158      MOVW	R10,R16
(0531) 	const BYTE *s = (const BYTE*)src;
    002F0 0169      MOVW	R12,R18
    002F1 C006      RJMP	0x02F8
(0532) 
(0533) #if _WORD_ACCESS == 1
(0534) 	while (cnt >= sizeof(int)) {
(0535) 		*(int*)d = *(int*)s;
(0536) 		d += sizeof(int); s += sizeof(int);
(0537) 		cnt -= sizeof(int);
(0538) 	}
(0539) #endif
(0540) 	while (cnt--)
(0541) 		*d++ = *s++;
    002F2 01F6      MOVW	R30,R12
    002F3 01D5      MOVW	R26,R10
    002F4 9001      LD	R0,Z+
    002F5 016F      MOVW	R12,R30
    002F6 920D      ST	X+,R0
    002F7 015D      MOVW	R10,R26
    002F8 011A      MOVW	R2,R20
    002F9 5041      SUBI	R20,1
    002FA 4050      SBCI	R21,0
    002FB 2022      TST	R2
    002FC F7A9      BNE	0x02F2
    002FD 2033      TST	R3
    002FE F799      BNE	0x02F2
    002FF 940C 40DB JMP	pop_xgset303C
ff.c:mem_set:
  d                    --> R10
  cnt                  --> R20
  val                  --> R18
  dst                  --> R16
    00301 940E 40B2 CALL	push_xgset300C
    00303 814C      LDD	R20,Y+4
    00304 815D      LDD	R21,Y+5
(0542) }
(0543) 
(0544) /* Fill memory */
(0545) static
(0546) void mem_set (void* dst, int val, UINT cnt) {
(0547) 	BYTE *d = (BYTE*)dst;
    00305 0158      MOVW	R10,R16
    00306 C003      RJMP	0x030A
(0548) 
(0549) 	while (cnt--)
(0550) 		*d++ = (BYTE)val;
    00307 01F5      MOVW	R30,R10
    00308 9321      ST	Z+,R18
    00309 015F      MOVW	R10,R30
    0030A 011A      MOVW	R2,R20
    0030B 5041      SUBI	R20,1
    0030C 4050      SBCI	R21,0
    0030D 2022      TST	R2
    0030E F7C1      BNE	0x0307
    0030F 2033      TST	R3
    00310 F7B1      BNE	0x0307
    00311 940C 40B7 JMP	pop_xgset300C
ff.c:mem_cmp:
  s                    --> R14
  d                    --> R12
  r                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    00313 940E 40A9 CALL	push_xgset30FC
    00315 8548      LDD	R20,Y+8
    00316 8559      LDD	R21,Y+9
(0551) }
(0552) 
(0553) /* Compare memory to memory */
(0554) static
(0555) int mem_cmp (const void* dst, const void* src, UINT cnt) {
(0556) 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    00317 0168      MOVW	R12,R16
    00318 0179      MOVW	R14,R18
(0557) 	int r = 0;
    00319 24AA      CLR	R10
    0031A 24BB      CLR	R11
(0558) 
(0559) 	while (cnt-- && (r = *d++ - *s++) == 0) ;
    0031B 011A      MOVW	R2,R20
    0031C 5041      SUBI	R20,1
    0031D 4050      SBCI	R21,0
    0031E 2022      TST	R2
    0031F F411      BNE	0x0322
    00320 2033      TST	R3
    00321 F079      BEQ	0x0331
    00322 01F7      MOVW	R30,R14
    00323 9021      LD	R2,Z+
    00324 017F      MOVW	R14,R30
    00325 2433      CLR	R3
    00326 01F6      MOVW	R30,R12
    00327 9041      LD	R4,Z+
    00328 016F      MOVW	R12,R30
    00329 2455      CLR	R5
    0032A 1842      SUB	R4,R2
    0032B 0853      SBC	R5,R3
    0032C 0152      MOVW	R10,R4
    0032D 20AA      TST	R10
    0032E F411      BNE	0x0331
    0032F 20BB      TST	R11
    00330 F351      BEQ	0x031B
(0560) 	return r;
    00331 0185      MOVW	R16,R10
    00332 940C 4093 JMP	pop_xgset30FC
(0561) }
(0562) 
(0563) /* Check if chr is contained in the string */
(0564) static
(0565) int chk_chr (const char* str, int chr) {
ff.c:chk_chr:
  chr                  --> R18
  str                  --> R16
    00334 C002      RJMP	0x0337
(0566) 	while (*str && *str != chr) str++;
    00335 5F0F      SUBI	R16,0xFF
    00336 4F1F      SBCI	R17,0xFF
    00337 01F8      MOVW	R30,R16
    00338 8020      LD	R2,Z
    00339 2433      CLR	R3
    0033A 2022      TST	R2
    0033B F021      BEQ	0x0340
    0033C 2433      CLR	R3
    0033D 1622      CP	R2,R18
    0033E 0633      CPC	R3,R19
    0033F F7A9      BNE	0x0335
(0567) 	return *str;
    00340 01F8      MOVW	R30,R16
    00341 8100      LD	R16,Z
    00342 2711      CLR	R17
    00343 9508      RET
ff.c:move_window:
  nf                   --> R10
  wsect                --> Y,+5
  sector               --> Y,+13
  fs                   --> R20
    00344 933A      ST	-Y,R19
    00345 932A      ST	-Y,R18
    00346 940E 40B2 CALL	push_xgset300C
    00348 01A8      MOVW	R20,R16
    00349 9729      SBIW	R28,0x9
(0568) }
(0569) 
(0570) 
(0571) 
(0572) /*-----------------------------------------------------------------------*/
(0573) /* Request/Release grant to access the volume                            */
(0574) /*-----------------------------------------------------------------------*/
(0575) #if _FS_REENTRANT
(0576) 
(0577) static
(0578) int lock_fs (
(0579) 	FATFS *fs		/* File system object */
(0580) )
(0581) {
(0582) 	return ff_req_grant(fs->sobj);
(0583) }
(0584) 
(0585) 
(0586) static
(0587) void unlock_fs (
(0588) 	FATFS *fs,		/* File system object */
(0589) 	FRESULT res		/* Result code to be returned */
(0590) )
(0591) {
(0592) 	if (res != FR_NOT_ENABLED &&
(0593) 		res != FR_INVALID_DRIVE &&
(0594) 		res != FR_INVALID_OBJECT &&
(0595) 		res != FR_TIMEOUT) {
(0596) 		ff_rel_grant(fs->sobj);
(0597) 	}
(0598) }
(0599) #endif
(0600) 
(0601) 
(0602) 
(0603) /*-----------------------------------------------------------------------*/
(0604) /* File shareing control functions                                       */
(0605) /*-----------------------------------------------------------------------*/
(0606) #if _FS_SHARE
(0607) 
(0608) static
(0609) FRESULT chk_lock (	/* Check if the file can be accessed */
(0610) 	DIR* dj,		/* Directory object pointing the file to be checked */
(0611) 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
(0612) )
(0613) {
(0614) 	UINT i, be;
(0615) 
(0616) 	/* Search file semaphore table */
(0617) 	for (i = be = 0; i < _FS_SHARE; i++) {
(0618) 		if (Files[i].fs) {	/* Existing entry */
(0619) 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
(0620) 				Files[i].clu == dj->sclust &&
(0621) 				Files[i].idx == dj->index) break;
(0622) 		} else {			/* Blank entry */
(0623) 			be++;
(0624) 		}
(0625) 	}
(0626) 	if (i == _FS_SHARE)	/* The file is not opened */
(0627) 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
(0628) 
(0629) 	/* The file has been opened. Reject any open against writing file and all write mode open */
(0630) 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
(0631) }
(0632) 
(0633) 
(0634) static
(0635) int enq_lock (void)	/* Check if an entry is available for a new file */
(0636) {
(0637) 	UINT i;
(0638) 
(0639) 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0640) 	return (i == _FS_SHARE) ? 0 : 1;
(0641) }
(0642) 
(0643) 
(0644) static
(0645) UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
(0646) 	DIR* dj,	/* Directory object pointing the file to register or increment */
(0647) 	int acc		/* Desired access mode (0:Read, !0:Write) */
(0648) )
(0649) {
(0650) 	UINT i;
(0651) 
(0652) 
(0653) 	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
(0654) 		if (Files[i].fs == dj->fs &&
(0655) 			Files[i].clu == dj->sclust &&
(0656) 			Files[i].idx == dj->index) break;
(0657) 	}
(0658) 
(0659) 	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
(0660) 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0661) 		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
(0662) 		Files[i].fs = dj->fs;
(0663) 		Files[i].clu = dj->sclust;
(0664) 		Files[i].idx = dj->index;
(0665) 		Files[i].ctr = 0;
(0666) 	}
(0667) 
(0668) 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
(0669) 
(0670) 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
(0671) 
(0672) 	return i + 1;
(0673) }
(0674) 
(0675) 
(0676) static
(0677) FRESULT dec_lock (	/* Decrement file open counter */
(0678) 	UINT i			/* Semaphore index */
(0679) )
(0680) {
(0681) 	WORD n;
(0682) 	FRESULT res;
(0683) 
(0684) 
(0685) 	if (--i < _FS_SHARE) {
(0686) 		n = Files[i].ctr;
(0687) 		if (n == 0x100) n = 0;
(0688) 		if (n) n--;
(0689) 		Files[i].ctr = n;
(0690) 		if (!n) Files[i].fs = 0;
(0691) 		res = FR_OK;
(0692) 	} else {
(0693) 		res = FR_INT_ERR;
(0694) 	}
(0695) 	return res;
(0696) }
(0697) 
(0698) 
(0699) static
(0700) void clear_lock (	/* Clear lock entries of the volume */
(0701) 	FATFS *fs
(0702) )
(0703) {
(0704) 	UINT i;
(0705) 
(0706) 	for (i = 0; i < _FS_SHARE; i++) {
(0707) 		if (Files[i].fs == fs) Files[i].fs = 0;
(0708) 	}
(0709) }
(0710) #endif
(0711) 
(0712) 
(0713) 
(0714) /*-----------------------------------------------------------------------*/
(0715) /* Change window offset                                                  */
(0716) /*-----------------------------------------------------------------------*/
(0717) 
(0718) static
(0719) FRESULT move_window (
(0720) 	FATFS *fs,		/* File system object */
(0721) 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
(0722) )					/* Move to zero only writes back dirty window */
(0723) {
(0724) 	DWORD wsect;
(0725) 
(0726) 
(0727) 	wsect = fs->winsect;
    0034A 01FA      MOVW	R30,R20
    0034B 96BA      ADIW	R30,0x2A
    0034C 8020      LD	R2,Z
    0034D 8031      LDD	R3,Z+1
    0034E 8042      LDD	R4,Z+2
    0034F 8053      LDD	R5,Z+3
    00350 822D      STD	Y+5,R2
    00351 823E      STD	Y+6,R3
    00352 824F      STD	Y+7,R4
    00353 8658      STD	Y+8,R5
(0728) 	if (wsect != sector) {	/* Changed current window */
    00354 842D      LDD	R2,Y+13
    00355 843E      LDD	R3,Y+14
    00356 844F      LDD	R4,Y+15
    00357 8858      LDD	R5,Y+16
    00358 806D      LDD	R6,Y+5
    00359 807E      LDD	R7,Y+6
    0035A 808F      LDD	R8,Y+7
    0035B 8498      LDD	R9,Y+8
    0035C 1462      CP	R6,R2
    0035D 0473      CPC	R7,R3
    0035E 0484      CPC	R8,R4
    0035F 0495      CPC	R9,R5
    00360 F409      BNE	0x0362
    00361 C07E      RJMP	0x03E0
(0729) #if !_FS_READONLY
(0730) 		if (fs->wflag) {	/* Write back dirty window if needed */
    00362 01FA      MOVW	R30,R20
    00363 8024      LDD	R2,Z+4
    00364 2022      TST	R2
    00365 F409      BNE	0x0367
    00366 C055      RJMP	0x03BC
(0731) 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    00367 E081      LDI	R24,1
    00368 838C      STD	Y+4,R24
    00369 0113      MOVW	R2,R6
    0036A 0124      MOVW	R4,R8
    0036B 8228      ST	Y,R2
    0036C 8239      STD	Y+1,R3
    0036D 824A      STD	Y+2,R4
    0036E 825B      STD	Y+3,R5
    0036F 019A      MOVW	R18,R20
    00370 5D22      SUBI	R18,0xD2
    00371 4F3F      SBCI	R19,0xFF
    00372 8101      LDD	R16,Z+1
    00373 940E 02C9 CALL	_disk_write
    00375 2300      TST	R16
    00376 F011      BEQ	0x0379
(0732) 				return FR_DISK_ERR;
    00377 E001      LDI	R16,1
    00378 C068      RJMP	0x03E1
(0733) 			fs->wflag = 0;
    00379 2422      CLR	R2
    0037A 01FA      MOVW	R30,R20
    0037B 8224      STD	Z+4,R2
(0734) 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    0037C 8C22      LDD	R2,Z+26
    0037D 8C33      LDD	R3,Z+27
    0037E 8C44      LDD	R4,Z+28
    0037F 8C55      LDD	R5,Z+29
    00380 967E      ADIW	R30,0x1E
    00381 8060      LD	R6,Z
    00382 8071      LDD	R7,Z+1
    00383 8082      LDD	R8,Z+2
    00384 8093      LDD	R9,Z+3
    00385 0C62      ADD	R6,R2
    00386 1C73      ADC	R7,R3
    00387 1C84      ADC	R8,R4
    00388 1C95      ADC	R9,R5
    00389 802D      LDD	R2,Y+5
    0038A 803E      LDD	R3,Y+6
    0038B 804F      LDD	R4,Y+7
    0038C 8458      LDD	R5,Y+8
    0038D 1426      CP	R2,R6
    0038E 0437      CPC	R3,R7
    0038F 0448      CPC	R4,R8
    00390 0459      CPC	R5,R9
    00391 F550      BCC	0x03BC
(0735) 				BYTE nf;
(0736) 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    00392 01FA      MOVW	R30,R20
    00393 80A3      LDD	R10,Z+3
    00394 C024      RJMP	0x03B9
(0737) 					wsect += fs->fsize;
    00395 01FA      MOVW	R30,R20
    00396 967A      ADIW	R30,0x1A
    00397 8020      LD	R2,Z
    00398 8031      LDD	R3,Z+1
    00399 8042      LDD	R4,Z+2
    0039A 8053      LDD	R5,Z+3
    0039B 806D      LDD	R6,Y+5
    0039C 807E      LDD	R7,Y+6
    0039D 808F      LDD	R8,Y+7
    0039E 8498      LDD	R9,Y+8
    0039F 0C62      ADD	R6,R2
    003A0 1C73      ADC	R7,R3
    003A1 1C84      ADC	R8,R4
    003A2 1C95      ADC	R9,R5
    003A3 826D      STD	Y+5,R6
    003A4 827E      STD	Y+6,R7
    003A5 828F      STD	Y+7,R8
    003A6 8698      STD	Y+8,R9
(0738) 					disk_write(fs->drv, fs->win, wsect, 1);
    003A7 E081      LDI	R24,1
    003A8 838C      STD	Y+4,R24
    003A9 802D      LDD	R2,Y+5
    003AA 803E      LDD	R3,Y+6
    003AB 804F      LDD	R4,Y+7
    003AC 8458      LDD	R5,Y+8
    003AD 8228      ST	Y,R2
    003AE 8239      STD	Y+1,R3
    003AF 824A      STD	Y+2,R4
    003B0 825B      STD	Y+3,R5
    003B1 019A      MOVW	R18,R20
    003B2 5D22      SUBI	R18,0xD2
    003B3 4F3F      SBCI	R19,0xFF
    003B4 01FA      MOVW	R30,R20
    003B5 8101      LDD	R16,Z+1
    003B6 940E 02C9 CALL	_disk_write
    003B8 94AA      DEC	R10
    003B9 E081      LDI	R24,1
    003BA 158A      CP	R24,R10
    003BB F2C8      BCS	0x0395
(0739) 				}
(0740) 			}
(0741) 		}
(0742) #endif
(0743) 		if (sector) {
    003BC 842D      LDD	R2,Y+13
    003BD 843E      LDD	R3,Y+14
    003BE 844F      LDD	R4,Y+15
    003BF 8858      LDD	R5,Y+16
    003C0 9488      BCLR	0
    003C1 2022      TST	R2
    003C2 0432      CPC	R3,R2
    003C3 0442      CPC	R4,R2
    003C4 0452      CPC	R5,R2
    003C5 F0D1      BEQ	0x03E0
(0744) 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    003C6 E081      LDI	R24,1
    003C7 838C      STD	Y+4,R24
    003C8 8228      ST	Y,R2
    003C9 8239      STD	Y+1,R3
    003CA 824A      STD	Y+2,R4
    003CB 825B      STD	Y+3,R5
    003CC 019A      MOVW	R18,R20
    003CD 5D22      SUBI	R18,0xD2
    003CE 4F3F      SBCI	R19,0xFF
    003CF 01FA      MOVW	R30,R20
    003D0 8101      LDD	R16,Z+1
    003D1 940E 02A9 CALL	_disk_read
    003D3 2300      TST	R16
    003D4 F011      BEQ	0x03D7
(0745) 				return FR_DISK_ERR;
    003D5 E001      LDI	R16,1
    003D6 C00A      RJMP	0x03E1
(0746) 			fs->winsect = sector;
    003D7 842D      LDD	R2,Y+13
    003D8 843E      LDD	R3,Y+14
    003D9 844F      LDD	R4,Y+15
    003DA 8858      LDD	R5,Y+16
    003DB 01FA      MOVW	R30,R20
    003DC A622      STD	Z+42,R2
    003DD A633      STD	Z+43,R3
    003DE A644      STD	Z+44,R4
    003DF A655      STD	Z+45,R5
(0747) 		}
(0748) 	}
(0749) 
(0750) 	return FR_OK;
    003E0 2700      CLR	R16
    003E1 9629      ADIW	R28,0x9
    003E2 940E 40B7 CALL	pop_xgset300C
    003E4 9622      ADIW	R28,2
    003E5 9508      RET
ff.c:sync:
  res                  --> R20
  fs                   --> R22
    003E6 940E 40BC CALL	push_xgsetF000
    003E8 01B8      MOVW	R22,R16
    003E9 9725      SBIW	R28,5
(0751) }
(0752) 
(0753) 
(0754) 
(0755) 
(0756) /*-----------------------------------------------------------------------*/
(0757) /* Clean-up cached data                                                  */
(0758) /*-----------------------------------------------------------------------*/
(0759) #if !_FS_READONLY
(0760) static
(0761) FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
(0762) 	FATFS *fs	/* File system object */
(0763) )
(0764) {
(0765) 	FRESULT res;
(0766) 
(0767) 
(0768) 	res = move_window(fs, 0);
    003EA E080      LDI	R24,0
    003EB E090      LDI	R25,0
    003EC E0A0      LDI	R26,0
    003ED E0B0      LDI	R27,0
    003EE 83A8      ST	Y,R26
    003EF 83B9      STD	Y+1,R27
    003F0 019C      MOVW	R18,R24
    003F1 018B      MOVW	R16,R22
    003F2 DF51      RCALL	ff.c:move_window
    003F3 2F40      MOV	R20,R16
(0769) 	if (res == FR_OK) {
    003F4 2300      TST	R16
    003F5 F009      BEQ	0x03F7
    003F6 C0C0      RJMP	0x04B7
(0770) 		/* Update FSInfo sector if needed */
(0771) 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    003F7 01FB      MOVW	R30,R22
    003F8 8180      LD	R24,Z
    003F9 3083      CPI	R24,3
    003FA F009      BEQ	0x03FC
    003FB C0AC      RJMP	0x04A8
    003FC 8025      LDD	R2,Z+5
    003FD 2022      TST	R2
    003FE F409      BNE	0x0400
    003FF C0A8      RJMP	0x04A8
(0772) 			fs->winsect = 0;
    00400 96BA      ADIW	R30,0x2A
    00401 E080      LDI	R24,0
    00402 8380      ST	Z,R24
    00403 8381      STD	Z+1,R24
    00404 8382      STD	Z+2,R24
    00405 8383      STD	Z+3,R24
(0773) 			/* Create FSInfo structure */
(0774) 			mem_set(fs->win, 0, 512);
    00406 E080      LDI	R24,0
    00407 E092      LDI	R25,2
    00408 8399      STD	Y+1,R25
    00409 8388      ST	Y,R24
    0040A 2722      CLR	R18
    0040B 2733      CLR	R19
    0040C 018B      MOVW	R16,R22
    0040D 5D02      SUBI	R16,0xD2
    0040E 4F1F      SBCI	R17,0xFF
    0040F DEF1      RCALL	ff.c:mem_set
(0775) 			ST_WORD(fs->win+BS_55AA, 0xAA55);
    00410 E585      LDI	R24,0x55
    00411 01FB      MOVW	R30,R22
    00412 5DE4      SUBI	R30,0xD4
    00413 4FFD      SBCI	R31,0xFD
    00414 8380      ST	Z,R24
    00415 52EC      SUBI	R30,0x2C
    00416 40F2      SBCI	R31,2
    00417 EA8A      LDI	R24,0xAA
    00418 5DE3      SUBI	R30,0xD3
    00419 4FFD      SBCI	R31,0xFD
    0041A 8380      ST	Z,R24
    0041B 52ED      SUBI	R30,0x2D
    0041C 40F2      SBCI	R31,2
(0776) 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    0041D E582      LDI	R24,0x52
    0041E A786      STD	Z+46,R24
    0041F A787      STD	Z+47,R24
    00420 E681      LDI	R24,0x61
    00421 AB80      STD	Z+48,R24
    00422 E481      LDI	R24,0x41
    00423 AB81      STD	Z+49,R24
(0777) 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    00424 E782      LDI	R24,0x72
    00425 5EEE      SUBI	R30,0xEE
    00426 4FFD      SBCI	R31,0xFD
    00427 8380      ST	Z,R24
    00428 51E2      SUBI	R30,0x12
    00429 40F2      SBCI	R31,2
    0042A 5EED      SUBI	R30,0xED
    0042B 4FFD      SBCI	R31,0xFD
    0042C 8380      ST	Z,R24
    0042D 51E3      SUBI	R30,0x13
    0042E 40F2      SBCI	R31,2
    0042F E481      LDI	R24,0x41
    00430 5EEC      SUBI	R30,0xEC
    00431 4FFD      SBCI	R31,0xFD
    00432 8380      ST	Z,R24
    00433 51E4      SUBI	R30,0x14
    00434 40F2      SBCI	R31,2
    00435 E681      LDI	R24,0x61
    00436 5EEB      SUBI	R30,0xEB
    00437 4FFD      SBCI	R31,0xFD
    00438 8380      ST	Z,R24
    00439 51E5      SUBI	R30,0x15
    0043A 40F2      SBCI	R31,2
(0778) 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    0043B 8426      LDD	R2,Z+14
    0043C 8437      LDD	R3,Z+15
    0043D 8840      LDD	R4,Z+16
    0043E 8851      LDD	R5,Z+17
    0043F 5EEA      SUBI	R30,0xEA
    00440 4FFD      SBCI	R31,0xFD
    00441 8220      ST	Z,R2
    00442 51E6      SUBI	R30,0x16
    00443 40F2      SBCI	R31,2
    00444 8426      LDD	R2,Z+14
    00445 8437      LDD	R3,Z+15
    00446 2C23      MOV	R2,R3
    00447 2433      CLR	R3
    00448 5EE9      SUBI	R30,0xE9
    00449 4FFD      SBCI	R31,0xFD
    0044A 8220      ST	Z,R2
    0044B 51E7      SUBI	R30,0x17
    0044C 40F2      SBCI	R31,2
    0044D 8426      LDD	R2,Z+14
    0044E 8437      LDD	R3,Z+15
    0044F 8840      LDD	R4,Z+16
    00450 8851      LDD	R5,Z+17
    00451 0112      MOVW	R2,R4
    00452 2444      CLR	R4
    00453 2455      CLR	R5
    00454 5EE8      SUBI	R30,0xE8
    00455 4FFD      SBCI	R31,0xFD
    00456 8220      ST	Z,R2
    00457 51E8      SUBI	R30,0x18
    00458 40F2      SBCI	R31,2
    00459 E188      LDI	R24,0x18
    0045A E090      LDI	R25,0
    0045B 8506      LDD	R16,Z+14
    0045C 8517      LDD	R17,Z+15
    0045D 8920      LDD	R18,Z+16
    0045E 8931      LDD	R19,Z+17
    0045F 938A      ST	-Y,R24
    00460 940E 4142 CALL	lsr32
    00462 01FB      MOVW	R30,R22
    00463 5EE7      SUBI	R30,0xE7
    00464 4FFD      SBCI	R31,0xFD
    00465 8300      ST	Z,R16
    00466 51E9      SUBI	R30,0x19
    00467 40F2      SBCI	R31,2
(0779) 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    00468 8422      LDD	R2,Z+10
    00469 8433      LDD	R3,Z+11
    0046A 8444      LDD	R4,Z+12
    0046B 8455      LDD	R5,Z+13
    0046C 5EE6      SUBI	R30,0xE6
    0046D 4FFD      SBCI	R31,0xFD
    0046E 8220      ST	Z,R2
    0046F 51EA      SUBI	R30,0x1A
    00470 40F2      SBCI	R31,2
    00471 8422      LDD	R2,Z+10
    00472 8433      LDD	R3,Z+11
    00473 2C23      MOV	R2,R3
    00474 2433      CLR	R3
    00475 5EE5      SUBI	R30,0xE5
    00476 4FFD      SBCI	R31,0xFD
    00477 8220      ST	Z,R2
    00478 51EB      SUBI	R30,0x1B
    00479 40F2      SBCI	R31,2
    0047A 8422      LDD	R2,Z+10
    0047B 8433      LDD	R3,Z+11
    0047C 8444      LDD	R4,Z+12
    0047D 8455      LDD	R5,Z+13
    0047E 0112      MOVW	R2,R4
    0047F 2444      CLR	R4
    00480 2455      CLR	R5
    00481 5EE4      SUBI	R30,0xE4
    00482 4FFD      SBCI	R31,0xFD
    00483 8220      ST	Z,R2
    00484 51EC      SUBI	R30,0x1C
    00485 40F2      SBCI	R31,2
    00486 E188      LDI	R24,0x18
    00487 E090      LDI	R25,0
    00488 8502      LDD	R16,Z+10
    00489 8513      LDD	R17,Z+11
    0048A 8524      LDD	R18,Z+12
    0048B 8535      LDD	R19,Z+13
    0048C 938A      ST	-Y,R24
    0048D 940E 4142 CALL	lsr32
    0048F 01FB      MOVW	R30,R22
    00490 5EE3      SUBI	R30,0xE3
    00491 4FFD      SBCI	R31,0xFD
    00492 8300      ST	Z,R16
    00493 51ED      SUBI	R30,0x1D
    00494 40F2      SBCI	R31,2
(0780) 			/* Write it into the FSInfo sector */
(0781) 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    00495 E081      LDI	R24,1
    00496 838C      STD	Y+4,R24
    00497 8822      LDD	R2,Z+18
    00498 8833      LDD	R3,Z+19
    00499 8844      LDD	R4,Z+20
    0049A 8855      LDD	R5,Z+21
    0049B 8228      ST	Y,R2
    0049C 8239      STD	Y+1,R3
    0049D 824A      STD	Y+2,R4
    0049E 825B      STD	Y+3,R5
    0049F 019F      MOVW	R18,R30
    004A0 5D22      SUBI	R18,0xD2
    004A1 4F3F      SBCI	R19,0xFF
    004A2 8101      LDD	R16,Z+1
    004A3 940E 02C9 CALL	_disk_write
(0782) 			fs->fsi_flag = 0;
    004A5 2422      CLR	R2
    004A6 01FB      MOVW	R30,R22
    004A7 8225      STD	Z+5,R2
(0783) 		}
(0784) 		/* Make sure that no pending write process in the physical drive */
(0785) 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    004A8 2422      CLR	R2
    004A9 2433      CLR	R3
    004AA 8239      STD	Y+1,R3
    004AB 8228      ST	Y,R2
    004AC 2722      CLR	R18
    004AD 2733      CLR	R19
    004AE 01FB      MOVW	R30,R22
    004AF 8101      LDD	R16,Z+1
    004B0 2711      CLR	R17
    004B1 940E 02E1 CALL	_disk_ioctl
    004B3 3000      CPI	R16,0
    004B4 0701      CPC	R16,R17
    004B5 F009      BEQ	0x04B7
(0786) 			res = FR_DISK_ERR;
    004B6 E041      LDI	R20,1
(0787) 	}
(0788) 
(0789) 	return res;
    004B7 2F04      MOV	R16,R20
    004B8 9625      ADIW	R28,5
    004B9 940C 40C1 JMP	pop_xgsetF000
_clust2sect:
  clst                 --> Y,+6
  fs                   --> R10
    004BB 933A      ST	-Y,R19
    004BC 932A      ST	-Y,R18
    004BD 940E 40C6 CALL	push_xgsetF00C
    004BF 0158      MOVW	R10,R16
(0790) }
(0791) #endif
(0792) 
(0793) 
(0794) 
(0795) 
(0796) /*-----------------------------------------------------------------------*/
(0797) /* Get sector# from cluster#                                             */
(0798) /*-----------------------------------------------------------------------*/
(0799) 
(0800) 
(0801) DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
(0802) 	FATFS *fs,		/* File system object */
(0803) 	DWORD clst		/* Cluster# to be converted */
(0804) )
(0805) {
(0806) 	clst -= 2;
    004C0 E042      LDI	R20,2
    004C1 E050      LDI	R21,0
    004C2 E060      LDI	R22,0
    004C3 E070      LDI	R23,0
    004C4 802E      LDD	R2,Y+6
    004C5 803F      LDD	R3,Y+7
    004C6 8448      LDD	R4,Y+8
    004C7 8459      LDD	R5,Y+9
    004C8 1A24      SUB	R2,R20
    004C9 0A35      SBC	R3,R21
    004CA 0A46      SBC	R4,R22
    004CB 0A57      SBC	R5,R23
    004CC 822E      STD	Y+6,R2
    004CD 823F      STD	Y+7,R3
    004CE 8648      STD	Y+8,R4
    004CF 8659      STD	Y+9,R5
(0807) 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    004D0 E042      LDI	R20,2
    004D1 E050      LDI	R21,0
    004D2 E060      LDI	R22,0
    004D3 E070      LDI	R23,0
    004D4 01F5      MOVW	R30,R10
    004D5 9676      ADIW	R30,0x16
    004D6 8020      LD	R2,Z
    004D7 8031      LDD	R3,Z+1
    004D8 8042      LDD	R4,Z+2
    004D9 8053      LDD	R5,Z+3
    004DA 1A24      SUB	R2,R20
    004DB 0A35      SBC	R3,R21
    004DC 0A46      SBC	R4,R22
    004DD 0A57      SBC	R5,R23
    004DE 806E      LDD	R6,Y+6
    004DF 807F      LDD	R7,Y+7
    004E0 8488      LDD	R8,Y+8
    004E1 8499      LDD	R9,Y+9
    004E2 1462      CP	R6,R2
    004E3 0473      CPC	R7,R3
    004E4 0484      CPC	R8,R4
    004E5 0495      CPC	R9,R5
    004E6 F028      BCS	0x04EC
    004E7 E000      LDI	R16,0
    004E8 E010      LDI	R17,0
    004E9 E020      LDI	R18,0
    004EA E030      LDI	R19,0
    004EB C01D      RJMP	0x0509
(0808) 	return clst * fs->csize + fs->database;
    004EC 01F5      MOVW	R30,R10
    004ED 9632      ADIW	R30,2
    004EE 8020      LD	R2,Z
    004EF 2433      CLR	R3
    004F0 2444      CLR	R4
    004F1 2455      CLR	R5
    004F2 810E      LDD	R16,Y+6
    004F3 811F      LDD	R17,Y+7
    004F4 8528      LDD	R18,Y+8
    004F5 8539      LDD	R19,Y+9
    004F6 925A      ST	-Y,R5
    004F7 924A      ST	-Y,R4
    004F8 923A      ST	-Y,R3
    004F9 922A      ST	-Y,R2
    004FA 940E 4053 CALL	empy32u|empy32s
    004FC 0118      MOVW	R2,R16
    004FD 0129      MOVW	R4,R18
    004FE 01F5      MOVW	R30,R10
    004FF A066      LDD	R6,Z+38
    00500 A077      LDD	R7,Z+39
    00501 A480      LDD	R8,Z+40
    00502 A491      LDD	R9,Z+41
    00503 0C26      ADD	R2,R6
    00504 1C37      ADC	R3,R7
    00505 1C48      ADC	R4,R8
    00506 1C59      ADC	R5,R9
    00507 0181      MOVW	R16,R2
    00508 0192      MOVW	R18,R4
    00509 940E 40CD CALL	pop_xgsetF00C
    0050B 9622      ADIW	R28,2
    0050C 9508      RET
_get_fat:
  wc                   --> R14
  p                    --> R10
  bc                   --> R10
  clst                 --> Y,+12
  fs                   --> R12
    0050D 933A      ST	-Y,R19
    0050E 932A      ST	-Y,R18
    0050F 940E 40A7 CALL	push_xgsetF0FC
    00511 0168      MOVW	R12,R16
    00512 9722      SBIW	R28,2
(0809) }
(0810) 
(0811) 
(0812) 
(0813) 
(0814) /*-----------------------------------------------------------------------*/
(0815) /* FAT access - Read value of a FAT entry                                */
(0816) /*-----------------------------------------------------------------------*/
(0817) 
(0818) 
(0819) DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
(0820) 	FATFS *fs,	/* File system object */
(0821) 	DWORD clst	/* Cluster# to get the link information */
(0822) )
(0823) {
(0824) 	UINT wc, bc;
(0825) 	BYTE *p;
(0826) 
(0827) 
(0828) 	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    00513 E042      LDI	R20,2
    00514 E050      LDI	R21,0
    00515 E060      LDI	R22,0
    00516 E070      LDI	R23,0
    00517 842C      LDD	R2,Y+12
    00518 843D      LDD	R3,Y+13
    00519 844E      LDD	R4,Y+14
    0051A 845F      LDD	R5,Y+15
    0051B 1624      CP	R2,R20
    0051C 0635      CPC	R3,R21
    0051D 0646      CPC	R4,R22
    0051E 0657      CPC	R5,R23
    0051F F078      BCS	0x052F
    00520 01F6      MOVW	R30,R12
    00521 9676      ADIW	R30,0x16
    00522 8020      LD	R2,Z
    00523 8031      LDD	R3,Z+1
    00524 8042      LDD	R4,Z+2
    00525 8053      LDD	R5,Z+3
    00526 846C      LDD	R6,Y+12
    00527 847D      LDD	R7,Y+13
    00528 848E      LDD	R8,Y+14
    00529 849F      LDD	R9,Y+15
    0052A 1462      CP	R6,R2
    0052B 0473      CPC	R7,R3
    0052C 0484      CPC	R8,R4
    0052D 0495      CPC	R9,R5
    0052E F028      BCS	0x0534
(0829) 		return 1;
    0052F E001      LDI	R16,1
    00530 E010      LDI	R17,0
    00531 E020      LDI	R18,0
    00532 E030      LDI	R19,0
    00533 C124      RJMP	0x0658
(0830) 
(0831) 	switch (fs->fs_type) {
    00534 01F6      MOVW	R30,R12
    00535 80A0      LD	R10,Z
    00536 24BB      CLR	R11
    00537 01C5      MOVW	R24,R10
    00538 3081      CPI	R24,1
    00539 E0E0      LDI	R30,0
    0053A 079E      CPC	R25,R30
    0053B F059      BEQ	0x0547
    0053C 3082      CPI	R24,2
    0053D E0E0      LDI	R30,0
    0053E 079E      CPC	R25,R30
    0053F F409      BNE	0x0541
    00540 C06F      RJMP	0x05B0
    00541 3083      CPI	R24,3
    00542 E0E0      LDI	R30,0
    00543 079E      CPC	R25,R30
    00544 F409      BNE	0x0546
    00545 C0A6      RJMP	0x05EC
    00546 C10D      RJMP	0x0654
(0832) 	case FS_FAT12 :
(0833) 		bc = (UINT)clst; bc += bc / 2;
    00547 84AC      LDD	R10,Y+12
    00548 84BD      LDD	R11,Y+13
    00549 0115      MOVW	R2,R10
    0054A 9436      LSR	R3
    0054B 9427      ROR	R2
    0054C 0CA2      ADD	R10,R2
    0054D 1CB3      ADC	R11,R3
(0834) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    0054E E029      LDI	R18,0x9
    0054F E030      LDI	R19,0
    00550 0185      MOVW	R16,R10
    00551 940E 413B CALL	lsr16
    00553 0118      MOVW	R2,R16
    00554 2444      CLR	R4
    00555 2455      CLR	R5
    00556 01F6      MOVW	R30,R12
    00557 8C66      LDD	R6,Z+30
    00558 8C77      LDD	R7,Z+31
    00559 A080      LDD	R8,Z+32
    0055A A091      LDD	R9,Z+33
    0055B 0C62      ADD	R6,R2
    0055C 1C73      ADC	R7,R3
    0055D 1C84      ADC	R8,R4
    0055E 1C95      ADC	R9,R5
    0055F 8288      ST	Y,R8
    00560 8299      STD	Y+1,R9
    00561 0193      MOVW	R18,R6
    00562 018F      MOVW	R16,R30
    00563 DDE0      RCALL	ff.c:move_window
    00564 2300      TST	R16
    00565 F009      BEQ	0x0567
    00566 C0ED      RJMP	0x0654
(0835) 		wc = fs->win[bc % SS(fs)]; bc++;
    00567 01C6      MOVW	R24,R12
    00568 968E      ADIW	R24,0x2E
    00569 01F5      MOVW	R30,R10
    0056A 70F1      ANDI	R31,1
    0056B 0FE8      ADD	R30,R24
    0056C 1FF9      ADC	R31,R25
    0056D 80E0      LD	R14,Z
    0056E 24FF      CLR	R15
    0056F 01C5      MOVW	R24,R10
    00570 9601      ADIW	R24,1
    00571 015C      MOVW	R10,R24
(0836) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00572 E029      LDI	R18,0x9
    00573 E030      LDI	R19,0
    00574 018C      MOVW	R16,R24
    00575 940E 413B CALL	lsr16
    00577 0118      MOVW	R2,R16
    00578 2444      CLR	R4
    00579 2455      CLR	R5
    0057A 01F6      MOVW	R30,R12
    0057B 8C66      LDD	R6,Z+30
    0057C 8C77      LDD	R7,Z+31
    0057D A080      LDD	R8,Z+32
    0057E A091      LDD	R9,Z+33
    0057F 0C62      ADD	R6,R2
    00580 1C73      ADC	R7,R3
    00581 1C84      ADC	R8,R4
    00582 1C95      ADC	R9,R5
    00583 8288      ST	Y,R8
    00584 8299      STD	Y+1,R9
    00585 0193      MOVW	R18,R6
    00586 018F      MOVW	R16,R30
    00587 DDBC      RCALL	ff.c:move_window
    00588 2300      TST	R16
    00589 F009      BEQ	0x058B
    0058A C0C9      RJMP	0x0654
(0837) 		wc |= fs->win[bc % SS(fs)] << 8;
    0058B 01C6      MOVW	R24,R12
    0058C 968E      ADIW	R24,0x2E
    0058D 01F5      MOVW	R30,R10
    0058E 70F1      ANDI	R31,1
    0058F 0FE8      ADD	R30,R24
    00590 1FF9      ADC	R31,R25
    00591 8020      LD	R2,Z
    00592 2433      CLR	R3
    00593 2C32      MOV	R3,R2
    00594 2422      CLR	R2
    00595 28E2      OR	R14,R2
    00596 28F3      OR	R15,R3
(0838) 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    00597 842C      LDD	R2,Y+12
    00598 843D      LDD	R3,Y+13
    00599 844E      LDD	R4,Y+14
    0059A 845F      LDD	R5,Y+15
    0059B 2DE2      MOV	R30,R2
    0059C 70E1      ANDI	R30,1
    0059D F051      BEQ	0x05A8
    0059E 0157      MOVW	R10,R14
    0059F 94B6      LSR	R11
    005A0 94A7      ROR	R10
    005A1 94B6      LSR	R11
    005A2 94A7      ROR	R10
    005A3 94B6      LSR	R11
    005A4 94A7      ROR	R10
    005A5 94B6      LSR	R11
    005A6 94A7      ROR	R10
    005A7 C003      RJMP	0x05AB
    005A8 01C7      MOVW	R24,R14
    005A9 709F      ANDI	R25,0xF
    005AA 015C      MOVW	R10,R24
    005AB 0185      MOVW	R16,R10
    005AC 0196      MOVW	R18,R12
    005AD 2722      CLR	R18
    005AE 2733      CLR	R19
    005AF C0A8      RJMP	0x0658
(0839) 
(0840) 	case FS_FAT16 :
(0841) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    005B0 E088      LDI	R24,0x8
    005B1 E090      LDI	R25,0
    005B2 850C      LDD	R16,Y+12
    005B3 851D      LDD	R17,Y+13
    005B4 852E      LDD	R18,Y+14
    005B5 853F      LDD	R19,Y+15
    005B6 938A      ST	-Y,R24
    005B7 940E 4142 CALL	lsr32
    005B9 01F6      MOVW	R30,R12
    005BA 8C26      LDD	R2,Z+30
    005BB 8C37      LDD	R3,Z+31
    005BC A040      LDD	R4,Z+32
    005BD A051      LDD	R5,Z+33
    005BE 0E20      ADD	R2,R16
    005BF 1E31      ADC	R3,R17
    005C0 1E42      ADC	R4,R18
    005C1 1E53      ADC	R5,R19
    005C2 8248      ST	Y,R4
    005C3 8259      STD	Y+1,R5
    005C4 0191      MOVW	R18,R2
    005C5 018F      MOVW	R16,R30
    005C6 DD7D      RCALL	ff.c:move_window
    005C7 2EA0      MOV	R10,R16
    005C8 2300      TST	R16
    005C9 F009      BEQ	0x05CB
    005CA C089      RJMP	0x0654
(0842) 		p = &fs->win[clst * 2 % SS(fs)];
    005CB EF4F      LDI	R20,0xFF
    005CC E051      LDI	R21,1
    005CD E060      LDI	R22,0
    005CE E070      LDI	R23,0
    005CF 842C      LDD	R2,Y+12
    005D0 843D      LDD	R3,Y+13
    005D1 844E      LDD	R4,Y+14
    005D2 845F      LDD	R5,Y+15
    005D3 0C22      LSL	R2
    005D4 1C33      ROL	R3
    005D5 1C44      ROL	R4
    005D6 1C55      ROL	R5
    005D7 2224      AND	R2,R20
    005D8 2235      AND	R3,R21
    005D9 2246      AND	R4,R22
    005DA 2257      AND	R5,R23
    005DB 0151      MOVW	R10,R2
    005DC 01C6      MOVW	R24,R12
    005DD 968E      ADIW	R24,0x2E
    005DE 0EA8      ADD	R10,R24
    005DF 1EB9      ADC	R11,R25
(0843) 		return LD_WORD(p);
    005E0 01F5      MOVW	R30,R10
    005E1 8020      LD	R2,Z
    005E2 2433      CLR	R3
    005E3 8101      LDD	R16,Z+1
    005E4 2711      CLR	R17
    005E5 2F10      MOV	R17,R16
    005E6 2700      CLR	R16
    005E7 2902      OR	R16,R2
    005E8 2913      OR	R17,R3
    005E9 2722      CLR	R18
    005EA 2733      CLR	R19
    005EB C06C      RJMP	0x0658
(0844) 
(0845) 	case FS_FAT32 :
(0846) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    005EC E087      LDI	R24,7
    005ED E090      LDI	R25,0
    005EE 850C      LDD	R16,Y+12
    005EF 851D      LDD	R17,Y+13
    005F0 852E      LDD	R18,Y+14
    005F1 853F      LDD	R19,Y+15
    005F2 938A      ST	-Y,R24
    005F3 940E 4142 CALL	lsr32
    005F5 01F6      MOVW	R30,R12
    005F6 8C26      LDD	R2,Z+30
    005F7 8C37      LDD	R3,Z+31
    005F8 A040      LDD	R4,Z+32
    005F9 A051      LDD	R5,Z+33
    005FA 0E20      ADD	R2,R16
    005FB 1E31      ADC	R3,R17
    005FC 1E42      ADC	R4,R18
    005FD 1E53      ADC	R5,R19
    005FE 8248      ST	Y,R4
    005FF 8259      STD	Y+1,R5
    00600 0191      MOVW	R18,R2
    00601 018F      MOVW	R16,R30
    00602 DD41      RCALL	ff.c:move_window
    00603 2EE0      MOV	R14,R16
    00604 2300      TST	R16
    00605 F009      BEQ	0x0607
    00606 C04D      RJMP	0x0654
(0847) 		p = &fs->win[clst * 4 % SS(fs)];
    00607 E082      LDI	R24,2
    00608 E090      LDI	R25,0
    00609 850C      LDD	R16,Y+12
    0060A 851D      LDD	R17,Y+13
    0060B 852E      LDD	R18,Y+14
    0060C 853F      LDD	R19,Y+15
    0060D 938A      ST	-Y,R24
    0060E 940E 4129 CALL	lsl32
    00610 0118      MOVW	R2,R16
    00611 0129      MOVW	R4,R18
    00612 EF4F      LDI	R20,0xFF
    00613 E051      LDI	R21,1
    00614 E060      LDI	R22,0
    00615 E070      LDI	R23,0
    00616 2224      AND	R2,R20
    00617 2235      AND	R3,R21
    00618 2246      AND	R4,R22
    00619 2257      AND	R5,R23
    0061A 0151      MOVW	R10,R2
    0061B 01C6      MOVW	R24,R12
    0061C 968E      ADIW	R24,0x2E
    0061D 0EA8      ADD	R10,R24
    0061E 1EB9      ADC	R11,R25
(0848) 		return LD_DWORD(p) & 0x0FFFFFFF;
    0061F E188      LDI	R24,0x18
    00620 E090      LDI	R25,0
    00621 01F5      MOVW	R30,R10
    00622 8103      LDD	R16,Z+3
    00623 2711      CLR	R17
    00624 2722      CLR	R18
    00625 2733      CLR	R19
    00626 938A      ST	-Y,R24
    00627 940E 4129 CALL	lsl32
    00629 0118      MOVW	R2,R16
    0062A 0129      MOVW	R4,R18
    0062B 01F5      MOVW	R30,R10
    0062C 8062      LDD	R6,Z+2
    0062D 2477      CLR	R7
    0062E 2488      CLR	R8
    0062F 2499      CLR	R9
    00630 0143      MOVW	R8,R6
    00631 2466      CLR	R6
    00632 2477      CLR	R7
    00633 2826      OR	R2,R6
    00634 2837      OR	R3,R7
    00635 2848      OR	R4,R8
    00636 2859      OR	R5,R9
    00637 8061      LDD	R6,Z+1
    00638 2477      CLR	R7
    00639 2C76      MOV	R7,R6
    0063A 2466      CLR	R6
    0063B 2488      CLR	R8
    0063C 2499      CLR	R9
    0063D 2826      OR	R2,R6
    0063E 2837      OR	R3,R7
    0063F 2848      OR	R4,R8
    00640 2859      OR	R5,R9
    00641 8060      LD	R6,Z
    00642 2477      CLR	R7
    00643 2488      CLR	R8
    00644 2499      CLR	R9
    00645 2826      OR	R2,R6
    00646 2837      OR	R3,R7
    00647 2848      OR	R4,R8
    00648 2859      OR	R5,R9
    00649 EF4F      LDI	R20,0xFF
    0064A EF5F      LDI	R21,0xFF
    0064B EF6F      LDI	R22,0xFF
    0064C E07F      LDI	R23,0xF
    0064D 2224      AND	R2,R20
    0064E 2235      AND	R3,R21
    0064F 2246      AND	R4,R22
    00650 2257      AND	R5,R23
    00651 0181      MOVW	R16,R2
    00652 0192      MOVW	R18,R4
    00653 C004      RJMP	0x0658
(0849) 	}
(0850) 
(0851) 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    00654 EF0F      LDI	R16,0xFF
    00655 EF1F      LDI	R17,0xFF
    00656 EF2F      LDI	R18,0xFF
    00657 EF3F      LDI	R19,0xFF
    00658 9622      ADIW	R28,2
    00659 940E 409C CALL	pop_xgsetF0FC
    0065B 9622      ADIW	R28,2
    0065C 9508      RET
_put_fat:
  bc                   --> R12
  p                    --> R14
  res                  --> Y,+2
  val                  --> Y,+19
  clst                 --> Y,+15
  fs                   --> Y,+13
    0065D 940E 3F62 CALL	push_arg4
    0065F 940E 40A7 CALL	push_xgsetF0FC
    00661 9723      SBIW	R28,3
(0852) }
(0853) 
(0854) 
(0855) 
(0856) 
(0857) /*-----------------------------------------------------------------------*/
(0858) /* FAT access - Change value of a FAT entry                              */
(0859) /*-----------------------------------------------------------------------*/
(0860) #if !_FS_READONLY
(0861) 
(0862) FRESULT put_fat (
(0863) 	FATFS *fs,	/* File system object */
(0864) 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
(0865) 	DWORD val	/* New value to mark the cluster */
(0866) )
(0867) {
(0868) 	UINT bc;
(0869) 	BYTE *p;
(0870) 	FRESULT res;
(0871) 
(0872) 
(0873) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    00662 E042      LDI	R20,2
    00663 E050      LDI	R21,0
    00664 E060      LDI	R22,0
    00665 E070      LDI	R23,0
    00666 842F      LDD	R2,Y+15
    00667 8838      LDD	R3,Y+16
    00668 8849      LDD	R4,Y+17
    00669 885A      LDD	R5,Y+18
    0066A 1624      CP	R2,R20
    0066B 0635      CPC	R3,R21
    0066C 0646      CPC	R4,R22
    0066D 0657      CPC	R5,R23
    0066E F080      BCS	0x067F
    0066F 85ED      LDD	R30,Y+13
    00670 85FE      LDD	R31,Y+14
    00671 9676      ADIW	R30,0x16
    00672 8020      LD	R2,Z
    00673 8031      LDD	R3,Z+1
    00674 8042      LDD	R4,Z+2
    00675 8053      LDD	R5,Z+3
    00676 846F      LDD	R6,Y+15
    00677 8878      LDD	R7,Y+16
    00678 8889      LDD	R8,Y+17
    00679 889A      LDD	R9,Y+18
    0067A 1462      CP	R6,R2
    0067B 0473      CPC	R7,R3
    0067C 0484      CPC	R8,R4
    0067D 0495      CPC	R9,R5
    0067E F018      BCS	0x0682
(0874) 		res = FR_INT_ERR;
    0067F E082      LDI	R24,2
    00680 838A      STD	Y+2,R24
(0875) 
(0876) 	} else {
    00681 C194      RJMP	0x0816
(0877) 		switch (fs->fs_type) {
    00682 85ED      LDD	R30,Y+13
    00683 85FE      LDD	R31,Y+14
    00684 80A0      LD	R10,Z
    00685 24BB      CLR	R11
    00686 01C5      MOVW	R24,R10
    00687 3081      CPI	R24,1
    00688 E0E0      LDI	R30,0
    00689 079E      CPC	R25,R30
    0068A F059      BEQ	0x0696
    0068B 3082      CPI	R24,2
    0068C E0E0      LDI	R30,0
    0068D 079E      CPC	R25,R30
    0068E F409      BNE	0x0690
    0068F C0B0      RJMP	0x0740
    00690 3083      CPI	R24,3
    00691 E0E0      LDI	R30,0
    00692 079E      CPC	R25,R30
    00693 F409      BNE	0x0695
    00694 C0E7      RJMP	0x077C
    00695 C17A      RJMP	0x0810
(0878) 		case FS_FAT12 :
(0879) 			bc = clst; bc += bc / 2;
    00696 84CF      LDD	R12,Y+15
    00697 88D8      LDD	R13,Y+16
    00698 0116      MOVW	R2,R12
    00699 9436      LSR	R3
    0069A 9427      ROR	R2
    0069B 0CC2      ADD	R12,R2
    0069C 1CD3      ADC	R13,R3
(0880) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    0069D E029      LDI	R18,0x9
    0069E E030      LDI	R19,0
    0069F 0186      MOVW	R16,R12
    006A0 940E 413B CALL	lsr16
    006A2 0118      MOVW	R2,R16
    006A3 2444      CLR	R4
    006A4 2455      CLR	R5
    006A5 85ED      LDD	R30,Y+13
    006A6 85FE      LDD	R31,Y+14
    006A7 8C66      LDD	R6,Z+30
    006A8 8C77      LDD	R7,Z+31
    006A9 A080      LDD	R8,Z+32
    006AA A091      LDD	R9,Z+33
    006AB 0C62      ADD	R6,R2
    006AC 1C73      ADC	R7,R3
    006AD 1C84      ADC	R8,R4
    006AE 1C95      ADC	R9,R5
    006AF 8288      ST	Y,R8
    006B0 8299      STD	Y+1,R9
    006B1 0193      MOVW	R18,R6
    006B2 018F      MOVW	R16,R30
    006B3 DC90      RCALL	ff.c:move_window
    006B4 830A      STD	Y+2,R16
(0881) 			if (res != FR_OK) break;
    006B5 2E00      MOV	R0,R16
    006B6 2300      TST	R16
    006B7 F009      BEQ	0x06B9
    006B8 C159      RJMP	0x0812
(0882) 			p = &fs->win[bc % SS(fs)];
    006B9 858D      LDD	R24,Y+13
    006BA 859E      LDD	R25,Y+14
    006BB 968E      ADIW	R24,0x2E
    006BC 01F6      MOVW	R30,R12
    006BD 70F1      ANDI	R31,1
    006BE 017F      MOVW	R14,R30
    006BF 0EE8      ADD	R14,R24
    006C0 1EF9      ADC	R15,R25
(0883) 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    006C1 842F      LDD	R2,Y+15
    006C2 8838      LDD	R3,Y+16
    006C3 8849      LDD	R4,Y+17
    006C4 885A      LDD	R5,Y+18
    006C5 93EF      PUSH	R30
    006C6 2DE2      MOV	R30,R2
    006C7 70E1      ANDI	R30,1
    006C8 91EF      POP	R30
    006C9 F0B1      BEQ	0x06E0
    006CA 882B      LDD	R2,Y+19
    006CB 883C      LDD	R3,Y+20
    006CC 884D      LDD	R4,Y+21
    006CD 885E      LDD	R5,Y+22
    006CE 2433      CLR	R3
    006CF 0C22      LSL	R2
    006D0 1C33      ROL	R3
    006D1 0C22      LSL	R2
    006D2 1C33      ROL	R3
    006D3 0C22      LSL	R2
    006D4 1C33      ROL	R3
    006D5 0C22      LSL	R2
    006D6 1C33      ROL	R3
    006D7 01F7      MOVW	R30,R14
    006D8 8180      LD	R24,Z
    006D9 2799      CLR	R25
    006DA 708F      ANDI	R24,0xF
    006DB 7090      ANDI	R25,0
    006DC 015C      MOVW	R10,R24
    006DD 28A2      OR	R10,R2
    006DE 28B3      OR	R11,R3
    006DF C006      RJMP	0x06E6
    006E0 882B      LDD	R2,Y+19
    006E1 883C      LDD	R3,Y+20
    006E2 884D      LDD	R4,Y+21
    006E3 885E      LDD	R5,Y+22
    006E4 2CA2      MOV	R10,R2
    006E5 24BB      CLR	R11
    006E6 01F7      MOVW	R30,R14
    006E7 82A0      ST	Z,R10
(0884) 			bc++;
    006E8 01C6      MOVW	R24,R12
    006E9 9601      ADIW	R24,1
    006EA 016C      MOVW	R12,R24
(0885) 			fs->wflag = 1;
    006EB E081      LDI	R24,1
    006EC 85ED      LDD	R30,Y+13
    006ED 85FE      LDD	R31,Y+14
    006EE 8384      STD	Z+4,R24
(0886) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006EF E029      LDI	R18,0x9
    006F0 E030      LDI	R19,0
    006F1 0186      MOVW	R16,R12
    006F2 940E 413B CALL	lsr16
    006F4 0118      MOVW	R2,R16
    006F5 2444      CLR	R4
    006F6 2455      CLR	R5
    006F7 85ED      LDD	R30,Y+13
    006F8 85FE      LDD	R31,Y+14
    006F9 8C66      LDD	R6,Z+30
    006FA 8C77      LDD	R7,Z+31
    006FB A080      LDD	R8,Z+32
    006FC A091      LDD	R9,Z+33
    006FD 0C62      ADD	R6,R2
    006FE 1C73      ADC	R7,R3
    006FF 1C84      ADC	R8,R4
    00700 1C95      ADC	R9,R5
    00701 8288      ST	Y,R8
    00702 8299      STD	Y+1,R9
    00703 0193      MOVW	R18,R6
    00704 018F      MOVW	R16,R30
    00705 DC3E      RCALL	ff.c:move_window
    00706 830A      STD	Y+2,R16
(0887) 			if (res != FR_OK) break;
    00707 2E00      MOV	R0,R16
    00708 2300      TST	R16
    00709 F009      BEQ	0x070B
    0070A C107      RJMP	0x0812
(0888) 			p = &fs->win[bc % SS(fs)];
    0070B 858D      LDD	R24,Y+13
    0070C 859E      LDD	R25,Y+14
    0070D 968E      ADIW	R24,0x2E
    0070E 01F6      MOVW	R30,R12
    0070F 70F1      ANDI	R31,1
    00710 017F      MOVW	R14,R30
    00711 0EE8      ADD	R14,R24
    00712 1EF9      ADC	R15,R25
(0889) 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    00713 842F      LDD	R2,Y+15
    00714 8838      LDD	R3,Y+16
    00715 8849      LDD	R4,Y+17
    00716 885A      LDD	R5,Y+18
    00717 93EF      PUSH	R30
    00718 2DE2      MOV	R30,R2
    00719 70E1      ANDI	R30,1
    0071A 91EF      POP	R30
    0071B F061      BEQ	0x0728
    0071C E084      LDI	R24,4
    0071D E090      LDI	R25,0
    0071E 890B      LDD	R16,Y+19
    0071F 891C      LDD	R17,Y+20
    00720 892D      LDD	R18,Y+21
    00721 893E      LDD	R19,Y+22
    00722 938A      ST	-Y,R24
    00723 940E 4142 CALL	lsr32
    00725 2EC0      MOV	R12,R16
    00726 24DD      CLR	R13
    00727 C015      RJMP	0x073D
    00728 E088      LDI	R24,0x8
    00729 E090      LDI	R25,0
    0072A 890B      LDD	R16,Y+19
    0072B 891C      LDD	R17,Y+20
    0072C 892D      LDD	R18,Y+21
    0072D 893E      LDD	R19,Y+22
    0072E 938A      ST	-Y,R24
    0072F 940E 4142 CALL	lsr32
    00731 2F80      MOV	R24,R16
    00732 2799      CLR	R25
    00733 708F      ANDI	R24,0xF
    00734 7090      ANDI	R25,0
    00735 01F7      MOVW	R30,R14
    00736 81E0      LD	R30,Z
    00737 27FF      CLR	R31
    00738 7FE0      ANDI	R30,0xF0
    00739 70F0      ANDI	R31,0
    0073A 016F      MOVW	R12,R30
    0073B 2AC8      OR	R12,R24
    0073C 2AD9      OR	R13,R25
    0073D 01F7      MOVW	R30,R14
    0073E 82C0      ST	Z,R12
(0890) 			break;
    0073F C0D2      RJMP	0x0812
(0891) 
(0892) 		case FS_FAT16 :
(0893) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    00740 E088      LDI	R24,0x8
    00741 E090      LDI	R25,0
    00742 850F      LDD	R16,Y+15
    00743 8918      LDD	R17,Y+16
    00744 8929      LDD	R18,Y+17
    00745 893A      LDD	R19,Y+18
    00746 938A      ST	-Y,R24
    00747 940E 4142 CALL	lsr32
    00749 85ED      LDD	R30,Y+13
    0074A 85FE      LDD	R31,Y+14
    0074B 8C26      LDD	R2,Z+30
    0074C 8C37      LDD	R3,Z+31
    0074D A040      LDD	R4,Z+32
    0074E A051      LDD	R5,Z+33
    0074F 0E20      ADD	R2,R16
    00750 1E31      ADC	R3,R17
    00751 1E42      ADC	R4,R18
    00752 1E53      ADC	R5,R19
    00753 8248      ST	Y,R4
    00754 8259      STD	Y+1,R5
    00755 0191      MOVW	R18,R2
    00756 018F      MOVW	R16,R30
    00757 DBEC      RCALL	ff.c:move_window
    00758 2EC0      MOV	R12,R16
    00759 82CA      STD	Y+2,R12
(0894) 			if (res != FR_OK) break;
    0075A 2C0C      MOV	R0,R12
    0075B 2300      TST	R16
    0075C F009      BEQ	0x075E
    0075D C0B4      RJMP	0x0812
(0895) 			p = &fs->win[clst * 2 % SS(fs)];
    0075E EF4F      LDI	R20,0xFF
    0075F E051      LDI	R21,1
    00760 E060      LDI	R22,0
    00761 E070      LDI	R23,0
    00762 842F      LDD	R2,Y+15
    00763 8838      LDD	R3,Y+16
    00764 8849      LDD	R4,Y+17
    00765 885A      LDD	R5,Y+18
    00766 0C22      LSL	R2
    00767 1C33      ROL	R3
    00768 1C44      ROL	R4
    00769 1C55      ROL	R5
    0076A 2224      AND	R2,R20
    0076B 2235      AND	R3,R21
    0076C 2246      AND	R4,R22
    0076D 2257      AND	R5,R23
    0076E 0171      MOVW	R14,R2
    0076F 858D      LDD	R24,Y+13
    00770 859E      LDD	R25,Y+14
    00771 968E      ADIW	R24,0x2E
    00772 0EE8      ADD	R14,R24
    00773 1EF9      ADC	R15,R25
(0896) 			ST_WORD(p, (WORD)val);
    00774 882B      LDD	R2,Y+19
    00775 883C      LDD	R3,Y+20
    00776 01F7      MOVW	R30,R14
    00777 8220      ST	Z,R2
    00778 2C23      MOV	R2,R3
    00779 2433      CLR	R3
    0077A 8221      STD	Z+1,R2
(0897) 			break;
    0077B C096      RJMP	0x0812
(0898) 
(0899) 		case FS_FAT32 :
(0900) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    0077C E087      LDI	R24,7
    0077D E090      LDI	R25,0
    0077E 850F      LDD	R16,Y+15
    0077F 8918      LDD	R17,Y+16
    00780 8929      LDD	R18,Y+17
    00781 893A      LDD	R19,Y+18
    00782 938A      ST	-Y,R24
    00783 940E 4142 CALL	lsr32
    00785 85ED      LDD	R30,Y+13
    00786 85FE      LDD	R31,Y+14
    00787 8C26      LDD	R2,Z+30
    00788 8C37      LDD	R3,Z+31
    00789 A040      LDD	R4,Z+32
    0078A A051      LDD	R5,Z+33
    0078B 0E20      ADD	R2,R16
    0078C 1E31      ADC	R3,R17
    0078D 1E42      ADC	R4,R18
    0078E 1E53      ADC	R5,R19
    0078F 8248      ST	Y,R4
    00790 8259      STD	Y+1,R5
    00791 0191      MOVW	R18,R2
    00792 018F      MOVW	R16,R30
    00793 DBB0      RCALL	ff.c:move_window
    00794 2EC0      MOV	R12,R16
    00795 82CA      STD	Y+2,R12
(0901) 			if (res != FR_OK) break;
    00796 2C0C      MOV	R0,R12
    00797 2300      TST	R16
    00798 F009      BEQ	0x079A
    00799 C078      RJMP	0x0812
(0902) 			p = &fs->win[clst * 4 % SS(fs)];
    0079A E082      LDI	R24,2
    0079B E090      LDI	R25,0
    0079C 850F      LDD	R16,Y+15
    0079D 8918      LDD	R17,Y+16
    0079E 8929      LDD	R18,Y+17
    0079F 893A      LDD	R19,Y+18
    007A0 938A      ST	-Y,R24
    007A1 940E 4129 CALL	lsl32
    007A3 0118      MOVW	R2,R16
    007A4 0129      MOVW	R4,R18
    007A5 EF4F      LDI	R20,0xFF
    007A6 E051      LDI	R21,1
    007A7 E060      LDI	R22,0
    007A8 E070      LDI	R23,0
    007A9 2224      AND	R2,R20
    007AA 2235      AND	R3,R21
    007AB 2246      AND	R4,R22
    007AC 2257      AND	R5,R23
    007AD 0171      MOVW	R14,R2
    007AE 858D      LDD	R24,Y+13
    007AF 859E      LDD	R25,Y+14
    007B0 968E      ADIW	R24,0x2E
    007B1 0EE8      ADD	R14,R24
    007B2 1EF9      ADC	R15,R25
(0903) 			val |= LD_DWORD(p) & 0xF0000000;
    007B3 E188      LDI	R24,0x18
    007B4 E090      LDI	R25,0
    007B5 01F7      MOVW	R30,R14
    007B6 8103      LDD	R16,Z+3
    007B7 2711      CLR	R17
    007B8 2722      CLR	R18
    007B9 2733      CLR	R19
    007BA 938A      ST	-Y,R24
    007BB 940E 4129 CALL	lsl32
    007BD 0118      MOVW	R2,R16
    007BE 0129      MOVW	R4,R18
    007BF 01F7      MOVW	R30,R14
    007C0 8062      LDD	R6,Z+2
    007C1 2477      CLR	R7
    007C2 2488      CLR	R8
    007C3 2499      CLR	R9
    007C4 0143      MOVW	R8,R6
    007C5 2466      CLR	R6
    007C6 2477      CLR	R7
    007C7 2826      OR	R2,R6
    007C8 2837      OR	R3,R7
    007C9 2848      OR	R4,R8
    007CA 2859      OR	R5,R9
    007CB 8061      LDD	R6,Z+1
    007CC 2477      CLR	R7
    007CD 2C76      MOV	R7,R6
    007CE 2466      CLR	R6
    007CF 2488      CLR	R8
    007D0 2499      CLR	R9
    007D1 2826      OR	R2,R6
    007D2 2837      OR	R3,R7
    007D3 2848      OR	R4,R8
    007D4 2859      OR	R5,R9
    007D5 8060      LD	R6,Z
    007D6 2477      CLR	R7
    007D7 2488      CLR	R8
    007D8 2499      CLR	R9
    007D9 2826      OR	R2,R6
    007DA 2837      OR	R3,R7
    007DB 2848      OR	R4,R8
    007DC 2859      OR	R5,R9
    007DD E040      LDI	R20,0
    007DE E050      LDI	R21,0
    007DF E060      LDI	R22,0
    007E0 EF70      LDI	R23,0xF0
    007E1 2224      AND	R2,R20
    007E2 2235      AND	R3,R21
    007E3 2246      AND	R4,R22
    007E4 2257      AND	R5,R23
    007E5 886B      LDD	R6,Y+19
    007E6 887C      LDD	R7,Y+20
    007E7 888D      LDD	R8,Y+21
    007E8 889E      LDD	R9,Y+22
    007E9 2862      OR	R6,R2
    007EA 2873      OR	R7,R3
    007EB 2884      OR	R8,R4
    007EC 2895      OR	R9,R5
    007ED 8A6B      STD	Y+19,R6
    007EE 8A7C      STD	Y+20,R7
    007EF 8A8D      STD	Y+21,R8
    007F0 8A9E      STD	Y+22,R9
(0904) 			ST_DWORD(p, val);
    007F1 882B      LDD	R2,Y+19
    007F2 883C      LDD	R3,Y+20
    007F3 884D      LDD	R4,Y+21
    007F4 885E      LDD	R5,Y+22
    007F5 8220      ST	Z,R2
    007F6 2C23      MOV	R2,R3
    007F7 2433      CLR	R3
    007F8 9631      ADIW	R30,1
    007F9 8220      ST	Z,R2
    007FA 882B      LDD	R2,Y+19
    007FB 883C      LDD	R3,Y+20
    007FC 884D      LDD	R4,Y+21
    007FD 885E      LDD	R5,Y+22
    007FE 0112      MOVW	R2,R4
    007FF 2444      CLR	R4
    00800 2455      CLR	R5
    00801 01F7      MOVW	R30,R14
    00802 9632      ADIW	R30,2
    00803 8220      ST	Z,R2
    00804 E188      LDI	R24,0x18
    00805 E090      LDI	R25,0
    00806 890B      LDD	R16,Y+19
    00807 891C      LDD	R17,Y+20
    00808 892D      LDD	R18,Y+21
    00809 893E      LDD	R19,Y+22
    0080A 938A      ST	-Y,R24
    0080B 940E 4142 CALL	lsr32
    0080D 01F7      MOVW	R30,R14
    0080E 8303      STD	Z+3,R16
(0905) 			break;
    0080F C002      RJMP	0x0812
(0906) 
(0907) 		default :
(0908) 			res = FR_INT_ERR;
    00810 E082      LDI	R24,2
    00811 838A      STD	Y+2,R24
(0909) 		}
(0910) 		fs->wflag = 1;
    00812 E081      LDI	R24,1
    00813 85ED      LDD	R30,Y+13
    00814 85FE      LDD	R31,Y+14
    00815 8384      STD	Z+4,R24
(0911) 	}
(0912) 
(0913) 	return res;
    00816 810A      LDD	R16,Y+2
    00817 9623      ADIW	R28,3
    00818 940E 409C CALL	pop_xgsetF0FC
    0081A 9624      ADIW	R28,4
    0081B 9508      RET
ff.c:remove_chain:
  res                  --> R10
  nxt                  --> Y,+6
  clst                 --> Y,+18
  fs                   --> R12
    0081C 933A      ST	-Y,R19
    0081D 932A      ST	-Y,R18
    0081E 940E 40E2 CALL	push_xgsetF03C
    00820 0168      MOVW	R12,R16
    00821 972A      SBIW	R28,0xA
(0914) }
(0915) #endif /* !_FS_READONLY */
(0916) 
(0917) 
(0918) 
(0919) 
(0920) /*-----------------------------------------------------------------------*/
(0921) /* FAT handling - Remove a cluster chain                                 */
(0922) /*-----------------------------------------------------------------------*/
(0923) #if !_FS_READONLY
(0924) static
(0925) FRESULT remove_chain (
(0926) 	FATFS *fs,			/* File system object */
(0927) 	DWORD clst			/* Cluster# to remove a chain from */
(0928) )
(0929) {
(0930) 	FRESULT res;
(0931) 	DWORD nxt;
(0932) #if _USE_ERASE
(0933) 	DWORD scl = clst, ecl = clst, resion[2];
(0934) #endif
(0935) 
(0936) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    00822 E042      LDI	R20,2
    00823 E050      LDI	R21,0
    00824 E060      LDI	R22,0
    00825 E070      LDI	R23,0
    00826 882A      LDD	R2,Y+18
    00827 883B      LDD	R3,Y+19
    00828 884C      LDD	R4,Y+20
    00829 885D      LDD	R5,Y+21
    0082A 1624      CP	R2,R20
    0082B 0635      CPC	R3,R21
    0082C 0646      CPC	R4,R22
    0082D 0657      CPC	R5,R23
    0082E F078      BCS	0x083E
    0082F 01F6      MOVW	R30,R12
    00830 9676      ADIW	R30,0x16
    00831 8020      LD	R2,Z
    00832 8031      LDD	R3,Z+1
    00833 8042      LDD	R4,Z+2
    00834 8053      LDD	R5,Z+3
    00835 886A      LDD	R6,Y+18
    00836 887B      LDD	R7,Y+19
    00837 888C      LDD	R8,Y+20
    00838 889D      LDD	R9,Y+21
    00839 1462      CP	R6,R2
    0083A 0473      CPC	R7,R3
    0083B 0484      CPC	R8,R4
    0083C 0495      CPC	R9,R5
    0083D F018      BCS	0x0841
(0937) 		res = FR_INT_ERR;
    0083E E082      LDI	R24,2
    0083F 2EA8      MOV	R10,R24
(0938) 
(0939) 	} else {
    00840 C088      RJMP	0x08C9
(0940) 		res = FR_OK;
    00841 24AA      CLR	R10
    00842 C076      RJMP	0x08B9
(0941) 		while (clst < fs->n_fatent) {			/* Not a last link? */
(0942) 			nxt = get_fat(fs, clst);			/* Get cluster status */
    00843 882A      LDD	R2,Y+18
    00844 883B      LDD	R3,Y+19
    00845 884C      LDD	R4,Y+20
    00846 885D      LDD	R5,Y+21
    00847 8248      ST	Y,R4
    00848 8259      STD	Y+1,R5
    00849 0191      MOVW	R18,R2
    0084A 0186      MOVW	R16,R12
    0084B DCC1      RCALL	_get_fat
    0084C 830E      STD	Y+6,R16
    0084D 831F      STD	Y+7,R17
    0084E 8728      STD	Y+8,R18
    0084F 8739      STD	Y+9,R19
(0943) 			if (nxt == 0) break;				/* Empty cluster? */
    00850 802E      LDD	R2,Y+6
    00851 803F      LDD	R3,Y+7
    00852 8448      LDD	R4,Y+8
    00853 8459      LDD	R5,Y+9
    00854 9488      BCLR	0
    00855 2022      TST	R2
    00856 0432      CPC	R3,R2
    00857 0442      CPC	R4,R2
    00858 0452      CPC	R5,R2
    00859 F409      BNE	0x085B
    0085A C06E      RJMP	0x08C9
(0944) 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    0085B E041      LDI	R20,1
    0085C E050      LDI	R21,0
    0085D E060      LDI	R22,0
    0085E E070      LDI	R23,0
    0085F 802E      LDD	R2,Y+6
    00860 803F      LDD	R3,Y+7
    00861 8448      LDD	R4,Y+8
    00862 8459      LDD	R5,Y+9
    00863 1624      CP	R2,R20
    00864 0635      CPC	R3,R21
    00865 0646      CPC	R4,R22
    00866 0657      CPC	R5,R23
    00867 F419      BNE	0x086B
    00868 E082      LDI	R24,2
    00869 2EA8      MOV	R10,R24
    0086A C05E      RJMP	0x08C9
(0945) 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    0086B EF4F      LDI	R20,0xFF
    0086C EF5F      LDI	R21,0xFF
    0086D EF6F      LDI	R22,0xFF
    0086E EF7F      LDI	R23,0xFF
    0086F 802E      LDD	R2,Y+6
    00870 803F      LDD	R3,Y+7
    00871 8448      LDD	R4,Y+8
    00872 8459      LDD	R5,Y+9
    00873 1624      CP	R2,R20
    00874 0635      CPC	R3,R21
    00875 0646      CPC	R4,R22
    00876 0657      CPC	R5,R23
    00877 F419      BNE	0x087B
    00878 24AA      CLR	R10
    00879 94A3      INC	R10
    0087A C04E      RJMP	0x08C9
(0946) 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    0087B E080      LDI	R24,0
    0087C 838A      STD	Y+2,R24
    0087D 838B      STD	Y+3,R24
    0087E 838C      STD	Y+4,R24
    0087F 838D      STD	Y+5,R24
    00880 882A      LDD	R2,Y+18
    00881 883B      LDD	R3,Y+19
    00882 884C      LDD	R4,Y+20
    00883 885D      LDD	R5,Y+21
    00884 8248      ST	Y,R4
    00885 8259      STD	Y+1,R5
    00886 0191      MOVW	R18,R2
    00887 0186      MOVW	R16,R12
    00888 DDD4      RCALL	_put_fat
    00889 2EA0      MOV	R10,R16
(0947) 			if (res != FR_OK) break;
    0088A 2300      TST	R16
    0088B F009      BEQ	0x088D
    0088C C03C      RJMP	0x08C9
(0948) 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    0088D EF4F      LDI	R20,0xFF
    0088E EF5F      LDI	R21,0xFF
    0088F EF6F      LDI	R22,0xFF
    00890 EF7F      LDI	R23,0xFF
    00891 01F6      MOVW	R30,R12
    00892 8426      LDD	R2,Z+14
    00893 8437      LDD	R3,Z+15
    00894 8840      LDD	R4,Z+16
    00895 8851      LDD	R5,Z+17
    00896 1624      CP	R2,R20
    00897 0635      CPC	R3,R21
    00898 0646      CPC	R4,R22
    00899 0657      CPC	R5,R23
    0089A F0B1      BEQ	0x08B1
(0949) 				fs->free_clust++;
    0089B 01CF      MOVW	R24,R30
    0089C 960E      ADIW	R24,0xE
    0089D E041      LDI	R20,1
    0089E E050      LDI	R21,0
    0089F E060      LDI	R22,0
    008A0 E070      LDI	R23,0
    008A1 01FC      MOVW	R30,R24
    008A2 8020      LD	R2,Z
    008A3 8031      LDD	R3,Z+1
    008A4 8042      LDD	R4,Z+2
    008A5 8053      LDD	R5,Z+3
    008A6 0E24      ADD	R2,R20
    008A7 1E35      ADC	R3,R21
    008A8 1E46      ADC	R4,R22
    008A9 1E57      ADC	R5,R23
    008AA 8220      ST	Z,R2
    008AB 8231      STD	Z+1,R3
    008AC 8242      STD	Z+2,R4
    008AD 8253      STD	Z+3,R5
(0950) 				fs->fsi_flag = 1;
    008AE E081      LDI	R24,1
    008AF 01F6      MOVW	R30,R12
    008B0 8385      STD	Z+5,R24
(0951) 			}
(0952) #if _USE_ERASE
(0953) 			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
(0954) 				ecl = nxt;
(0955) 			} else {				/* End of contiguous clusters */ 
(0956) 				resion[0] = clust2sect(fs, scl);					/* Start sector */
(0957) 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
(0958) 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
(0959) 				scl = ecl = nxt;
(0960) 			}
(0961) #endif
(0962) 			clst = nxt;	/* Next cluster */
    008B1 802E      LDD	R2,Y+6
    008B2 803F      LDD	R3,Y+7
    008B3 8448      LDD	R4,Y+8
    008B4 8459      LDD	R5,Y+9
    008B5 8A2A      STD	Y+18,R2
    008B6 8A3B      STD	Y+19,R3
    008B7 8A4C      STD	Y+20,R4
    008B8 8A5D      STD	Y+21,R5
    008B9 01F6      MOVW	R30,R12
    008BA 9676      ADIW	R30,0x16
    008BB 8020      LD	R2,Z
    008BC 8031      LDD	R3,Z+1
    008BD 8042      LDD	R4,Z+2
    008BE 8053      LDD	R5,Z+3
    008BF 886A      LDD	R6,Y+18
    008C0 887B      LDD	R7,Y+19
    008C1 888C      LDD	R8,Y+20
    008C2 889D      LDD	R9,Y+21
    008C3 1462      CP	R6,R2
    008C4 0473      CPC	R7,R3
    008C5 0484      CPC	R8,R4
    008C6 0495      CPC	R9,R5
    008C7 F408      BCC	0x08C9
    008C8 CF7A      RJMP	0x0843
(0963) 		}
(0964) 	}
(0965) 
(0966) 	return res;
    008C9 2D0A      MOV	R16,R10
    008CA 962A      ADIW	R28,0xA
    008CB 940E 40EB CALL	pop_xgsetF03C
    008CD 9622      ADIW	R28,2
    008CE 9508      RET
ff.c:create_chain:
  res                  --> R10
  scl                  --> Y,+14
  cs                   --> Y,+10
  ncl                  --> Y,+6
  clst                 --> Y,+32
  fs                   --> R12
    008CF 933A      ST	-Y,R19
    008D0 932A      ST	-Y,R18
    008D1 940E 40A7 CALL	push_xgsetF0FC
    008D3 0168      MOVW	R12,R16
    008D4 9766      SBIW	R28,0x16
(0967) }
(0968) #endif
(0969) 
(0970) 
(0971) 
(0972) 
(0973) /*-----------------------------------------------------------------------*/
(0974) /* FAT handling - Stretch or Create a cluster chain                      */
(0975) /*-----------------------------------------------------------------------*/
(0976) #if !_FS_READONLY
(0977) static
(0978) DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
(0979) 	FATFS *fs,			/* File system object */
(0980) 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
(0981) )
(0982) {
(0983) 	DWORD cs, ncl, scl;
(0984) 	FRESULT res;
(0985) 
(0986) 
(0987) 	if (clst == 0) {		/* Create a new chain */
    008D5 A028      LDD	R2,Y+32
    008D6 A039      LDD	R3,Y+33
    008D7 A04A      LDD	R4,Y+34
    008D8 A05B      LDD	R5,Y+35
    008D9 9488      BCLR	0
    008DA 2022      TST	R2
    008DB 0432      CPC	R3,R2
    008DC 0442      CPC	R4,R2
    008DD 0452      CPC	R5,R2
    008DE F559      BNE	0x090A
(0988) 		scl = fs->last_clust;			/* Get suggested start point */
    008DF 01F6      MOVW	R30,R12
    008E0 963A      ADIW	R30,0xA
    008E1 8020      LD	R2,Z
    008E2 8031      LDD	R3,Z+1
    008E3 8042      LDD	R4,Z+2
    008E4 8053      LDD	R5,Z+3
    008E5 862E      STD	Y+14,R2
    008E6 863F      STD	Y+15,R3
    008E7 8A48      STD	Y+16,R4
    008E8 8A59      STD	Y+17,R5
(0989) 		if (!scl || scl >= fs->n_fatent) scl = 1;
    008E9 842E      LDD	R2,Y+14
    008EA 843F      LDD	R3,Y+15
    008EB 8848      LDD	R4,Y+16
    008EC 8859      LDD	R5,Y+17
    008ED 9488      BCLR	0
    008EE 2022      TST	R2
    008EF 0432      CPC	R3,R2
    008F0 0442      CPC	R4,R2
    008F1 0452      CPC	R5,R2
    008F2 F081      BEQ	0x0903
    008F3 01F6      MOVW	R30,R12
    008F4 9676      ADIW	R30,0x16
    008F5 8020      LD	R2,Z
    008F6 8031      LDD	R3,Z+1
    008F7 8042      LDD	R4,Z+2
    008F8 8053      LDD	R5,Z+3
    008F9 846E      LDD	R6,Y+14
    008FA 847F      LDD	R7,Y+15
    008FB 8888      LDD	R8,Y+16
    008FC 8899      LDD	R9,Y+17
    008FD 1462      CP	R6,R2
    008FE 0473      CPC	R7,R3
    008FF 0484      CPC	R8,R4
    00900 0495      CPC	R9,R5
    00901 F408      BCC	0x0903
    00902 C040      RJMP	0x0943
    00903 E081      LDI	R24,1
    00904 878E      STD	Y+14,R24
    00905 E080      LDI	R24,0
    00906 878F      STD	Y+15,R24
    00907 8B88      STD	Y+16,R24
    00908 8B89      STD	Y+17,R24
(0990) 	}
    00909 C039      RJMP	0x0943
(0991) 	else {					/* Stretch the current chain */
(0992) 		cs = get_fat(fs, clst);			/* Check the cluster status */
    0090A A028      LDD	R2,Y+32
    0090B A039      LDD	R3,Y+33
    0090C A04A      LDD	R4,Y+34
    0090D A05B      LDD	R5,Y+35
    0090E 8248      ST	Y,R4
    0090F 8259      STD	Y+1,R5
    00910 0191      MOVW	R18,R2
    00911 0186      MOVW	R16,R12
    00912 DBFA      RCALL	_get_fat
    00913 870A      STD	Y+10,R16
    00914 871B      STD	Y+11,R17
    00915 872C      STD	Y+12,R18
    00916 873D      STD	Y+13,R19
(0993) 		if (cs < 2) return 1;			/* It is an invalid cluster */
    00917 E042      LDI	R20,2
    00918 E050      LDI	R21,0
    00919 E060      LDI	R22,0
    0091A E070      LDI	R23,0
    0091B 842A      LDD	R2,Y+10
    0091C 843B      LDD	R3,Y+11
    0091D 844C      LDD	R4,Y+12
    0091E 845D      LDD	R5,Y+13
    0091F 1624      CP	R2,R20
    00920 0635      CPC	R3,R21
    00921 0646      CPC	R4,R22
    00922 0657      CPC	R5,R23
    00923 F428      BCC	0x0929
    00924 E001      LDI	R16,1
    00925 E010      LDI	R17,0
    00926 E020      LDI	R18,0
    00927 E030      LDI	R19,0
    00928 C119      RJMP	0x0A42
(0994) 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    00929 01F6      MOVW	R30,R12
    0092A 9676      ADIW	R30,0x16
    0092B 8020      LD	R2,Z
    0092C 8031      LDD	R3,Z+1
    0092D 8042      LDD	R4,Z+2
    0092E 8053      LDD	R5,Z+3
    0092F 846A      LDD	R6,Y+10
    00930 847B      LDD	R7,Y+11
    00931 848C      LDD	R8,Y+12
    00932 849D      LDD	R9,Y+13
    00933 1462      CP	R6,R2
    00934 0473      CPC	R7,R3
    00935 0484      CPC	R8,R4
    00936 0495      CPC	R9,R5
    00937 F418      BCC	0x093B
    00938 0183      MOVW	R16,R6
    00939 0194      MOVW	R18,R8
    0093A C107      RJMP	0x0A42
(0995) 		scl = clst;
    0093B A028      LDD	R2,Y+32
    0093C A039      LDD	R3,Y+33
    0093D A04A      LDD	R4,Y+34
    0093E A05B      LDD	R5,Y+35
    0093F 862E      STD	Y+14,R2
    00940 863F      STD	Y+15,R3
    00941 8A48      STD	Y+16,R4
    00942 8A59      STD	Y+17,R5
(0996) 	}
(0997) 
(0998) 	ncl = scl;				/* Start cluster */
    00943 842E      LDD	R2,Y+14
    00944 843F      LDD	R3,Y+15
    00945 8848      LDD	R4,Y+16
    00946 8859      LDD	R5,Y+17
    00947 822E      STD	Y+6,R2
    00948 823F      STD	Y+7,R3
    00949 8648      STD	Y+8,R4
    0094A 8659      STD	Y+9,R5
(0999) 	for (;;) {
(1000) 		ncl++;							/* Next cluster */
    0094B E041      LDI	R20,1
    0094C E050      LDI	R21,0
    0094D E060      LDI	R22,0
    0094E E070      LDI	R23,0
    0094F 802E      LDD	R2,Y+6
    00950 803F      LDD	R3,Y+7
    00951 8448      LDD	R4,Y+8
    00952 8459      LDD	R5,Y+9
    00953 0E24      ADD	R2,R20
    00954 1E35      ADC	R3,R21
    00955 1E46      ADC	R4,R22
    00956 1E57      ADC	R5,R23
    00957 822E      STD	Y+6,R2
    00958 823F      STD	Y+7,R3
    00959 8648      STD	Y+8,R4
    0095A 8659      STD	Y+9,R5
(1001) 		if (ncl >= fs->n_fatent) {		/* Wrap around */
    0095B 01F6      MOVW	R30,R12
    0095C 9676      ADIW	R30,0x16
    0095D 8020      LD	R2,Z
    0095E 8031      LDD	R3,Z+1
    0095F 8042      LDD	R4,Z+2
    00960 8053      LDD	R5,Z+3
    00961 806E      LDD	R6,Y+6
    00962 807F      LDD	R7,Y+7
    00963 8488      LDD	R8,Y+8
    00964 8499      LDD	R9,Y+9
    00965 1462      CP	R6,R2
    00966 0473      CPC	R7,R3
    00967 0484      CPC	R8,R4
    00968 0495      CPC	R9,R5
    00969 F0C0      BCS	0x0982
(1002) 			ncl = 2;
    0096A E082      LDI	R24,2
    0096B 838E      STD	Y+6,R24
    0096C E080      LDI	R24,0
    0096D 838F      STD	Y+7,R24
    0096E 8788      STD	Y+8,R24
    0096F 8789      STD	Y+9,R24
(1003) 			if (ncl > scl) return 0;	/* No free cluster */
    00970 842E      LDD	R2,Y+14
    00971 843F      LDD	R3,Y+15
    00972 8848      LDD	R4,Y+16
    00973 8859      LDD	R5,Y+17
    00974 806E      LDD	R6,Y+6
    00975 807F      LDD	R7,Y+7
    00976 8488      LDD	R8,Y+8
    00977 8499      LDD	R9,Y+9
    00978 1426      CP	R2,R6
    00979 0437      CPC	R3,R7
    0097A 0448      CPC	R4,R8
    0097B 0459      CPC	R5,R9
    0097C F428      BCC	0x0982
    0097D E000      LDI	R16,0
    0097E E010      LDI	R17,0
    0097F E020      LDI	R18,0
    00980 E030      LDI	R19,0
    00981 C0C0      RJMP	0x0A42
(1004) 		}
(1005) 		cs = get_fat(fs, ncl);			/* Get the cluster status */
    00982 802E      LDD	R2,Y+6
    00983 803F      LDD	R3,Y+7
    00984 8448      LDD	R4,Y+8
    00985 8459      LDD	R5,Y+9
    00986 8248      ST	Y,R4
    00987 8259      STD	Y+1,R5
    00988 0191      MOVW	R18,R2
    00989 0186      MOVW	R16,R12
    0098A DB82      RCALL	_get_fat
    0098B 870A      STD	Y+10,R16
    0098C 871B      STD	Y+11,R17
    0098D 872C      STD	Y+12,R18
    0098E 873D      STD	Y+13,R19
(1006) 		if (cs == 0) break;				/* Found a free cluster */
    0098F 842A      LDD	R2,Y+10
    00990 843B      LDD	R3,Y+11
    00991 844C      LDD	R4,Y+12
    00992 845D      LDD	R5,Y+13
    00993 9488      BCLR	0
    00994 2022      TST	R2
    00995 0432      CPC	R3,R2
    00996 0442      CPC	R4,R2
    00997 0452      CPC	R5,R2
    00998 F409      BNE	0x099A
    00999 C02E      RJMP	0x09C8
(1007) 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    0099A EF4F      LDI	R20,0xFF
    0099B EF5F      LDI	R21,0xFF
    0099C EF6F      LDI	R22,0xFF
    0099D EF7F      LDI	R23,0xFF
    0099E 842A      LDD	R2,Y+10
    0099F 843B      LDD	R3,Y+11
    009A0 844C      LDD	R4,Y+12
    009A1 845D      LDD	R5,Y+13
    009A2 1624      CP	R2,R20
    009A3 0635      CPC	R3,R21
    009A4 0646      CPC	R4,R22
    009A5 0657      CPC	R5,R23
    009A6 F049      BEQ	0x09B0
    009A7 E041      LDI	R20,1
    009A8 E050      LDI	R21,0
    009A9 E060      LDI	R22,0
    009AA E070      LDI	R23,0
    009AB 1624      CP	R2,R20
    009AC 0635      CPC	R3,R21
    009AD 0646      CPC	R4,R22
    009AE 0657      CPC	R5,R23
    009AF F429      BNE	0x09B5
(1008) 			return cs;
    009B0 850A      LDD	R16,Y+10
    009B1 851B      LDD	R17,Y+11
    009B2 852C      LDD	R18,Y+12
    009B3 853D      LDD	R19,Y+13
    009B4 C08D      RJMP	0x0A42
(1009) 		if (ncl == scl) return 0;		/* No free cluster */
    009B5 842E      LDD	R2,Y+14
    009B6 843F      LDD	R3,Y+15
    009B7 8848      LDD	R4,Y+16
    009B8 8859      LDD	R5,Y+17
    009B9 806E      LDD	R6,Y+6
    009BA 807F      LDD	R7,Y+7
    009BB 8488      LDD	R8,Y+8
    009BC 8499      LDD	R9,Y+9
    009BD 1462      CP	R6,R2
    009BE 0473      CPC	R7,R3
    009BF 0484      CPC	R8,R4
    009C0 0495      CPC	R9,R5
    009C1 F009      BEQ	0x09C3
    009C2 CF88      RJMP	0x094B
    009C3 E000      LDI	R16,0
    009C4 E010      LDI	R17,0
    009C5 E020      LDI	R18,0
    009C6 E030      LDI	R19,0
    009C7 C07A      RJMP	0x0A42
(1010) 	}
(1011) 
(1012) 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    009C8 EF8F      LDI	R24,0xFF
    009C9 838A      STD	Y+2,R24
    009CA 838B      STD	Y+3,R24
    009CB 838C      STD	Y+4,R24
    009CC E08F      LDI	R24,0xF
    009CD 838D      STD	Y+5,R24
    009CE 802E      LDD	R2,Y+6
    009CF 803F      LDD	R3,Y+7
    009D0 8448      LDD	R4,Y+8
    009D1 8459      LDD	R5,Y+9
    009D2 8248      ST	Y,R4
    009D3 8259      STD	Y+1,R5
    009D4 0191      MOVW	R18,R2
    009D5 0186      MOVW	R16,R12
    009D6 DC86      RCALL	_put_fat
    009D7 2EA0      MOV	R10,R16
(1013) 	if (res == FR_OK && clst != 0) {
    009D8 2300      TST	R16
    009D9 F4E1      BNE	0x09F6
    009DA A028      LDD	R2,Y+32
    009DB A039      LDD	R3,Y+33
    009DC A04A      LDD	R4,Y+34
    009DD A05B      LDD	R5,Y+35
    009DE 9488      BCLR	0
    009DF 2022      TST	R2
    009E0 0432      CPC	R3,R2
    009E1 0442      CPC	R4,R2
    009E2 0452      CPC	R5,R2
    009E3 F091      BEQ	0x09F6
(1014) 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    009E4 802E      LDD	R2,Y+6
    009E5 803F      LDD	R3,Y+7
    009E6 8448      LDD	R4,Y+8
    009E7 8459      LDD	R5,Y+9
    009E8 822A      STD	Y+2,R2
    009E9 823B      STD	Y+3,R3
    009EA 824C      STD	Y+4,R4
    009EB 825D      STD	Y+5,R5
    009EC A028      LDD	R2,Y+32
    009ED A039      LDD	R3,Y+33
    009EE A04A      LDD	R4,Y+34
    009EF A05B      LDD	R5,Y+35
    009F0 8248      ST	Y,R4
    009F1 8259      STD	Y+1,R5
    009F2 0191      MOVW	R18,R2
    009F3 0186      MOVW	R16,R12
    009F4 DC68      RCALL	_put_fat
    009F5 2EA0      MOV	R10,R16
(1015) 	}
(1016) 	if (res == FR_OK) {
    009F6 20AA      TST	R10
    009F7 F009      BEQ	0x09F9
    009F8 C02E      RJMP	0x0A27
(1017) 		fs->last_clust = ncl;			/* Update FSINFO */
    009F9 802E      LDD	R2,Y+6
    009FA 803F      LDD	R3,Y+7
    009FB 8448      LDD	R4,Y+8
    009FC 8459      LDD	R5,Y+9
    009FD 01F6      MOVW	R30,R12
    009FE 8622      STD	Z+10,R2
    009FF 8633      STD	Z+11,R3
    00A00 8644      STD	Z+12,R4
    00A01 8655      STD	Z+13,R5
(1018) 		if (fs->free_clust != 0xFFFFFFFF) {
    00A02 EF4F      LDI	R20,0xFF
    00A03 EF5F      LDI	R21,0xFF
    00A04 EF6F      LDI	R22,0xFF
    00A05 EF7F      LDI	R23,0xFF
    00A06 8426      LDD	R2,Z+14
    00A07 8437      LDD	R3,Z+15
    00A08 8840      LDD	R4,Z+16
    00A09 8851      LDD	R5,Z+17
    00A0A 1624      CP	R2,R20
    00A0B 0635      CPC	R3,R21
    00A0C 0646      CPC	R4,R22
    00A0D 0657      CPC	R5,R23
    00A0E F179      BEQ	0x0A3E
(1019) 			fs->free_clust--;
    00A0F 01CF      MOVW	R24,R30
    00A10 960E      ADIW	R24,0xE
    00A11 017C      MOVW	R14,R24
    00A12 E041      LDI	R20,1
    00A13 E050      LDI	R21,0
    00A14 E060      LDI	R22,0
    00A15 E070      LDI	R23,0
    00A16 01FC      MOVW	R30,R24
    00A17 8020      LD	R2,Z
    00A18 8031      LDD	R3,Z+1
    00A19 8042      LDD	R4,Z+2
    00A1A 8053      LDD	R5,Z+3
    00A1B 1A24      SUB	R2,R20
    00A1C 0A35      SBC	R3,R21
    00A1D 0A46      SBC	R4,R22
    00A1E 0A57      SBC	R5,R23
    00A1F 8220      ST	Z,R2
    00A20 8231      STD	Z+1,R3
    00A21 8242      STD	Z+2,R4
    00A22 8253      STD	Z+3,R5
(1020) 			fs->fsi_flag = 1;
    00A23 E081      LDI	R24,1
    00A24 01F6      MOVW	R30,R12
    00A25 8385      STD	Z+5,R24
(1021) 		}
(1022) 	} else {
    00A26 C017      RJMP	0x0A3E
(1023) 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    00A27 2D8A      MOV	R24,R10
    00A28 3081      CPI	R24,1
    00A29 F431      BNE	0x0A30
    00A2A EF8F      LDI	R24,0xFF
    00A2B 8B8A      STD	Y+18,R24
    00A2C 8B8B      STD	Y+19,R24
    00A2D 8B8C      STD	Y+20,R24
    00A2E 8B8D      STD	Y+21,R24
    00A2F C006      RJMP	0x0A36
    00A30 E081      LDI	R24,1
    00A31 8B8A      STD	Y+18,R24
    00A32 E080      LDI	R24,0
    00A33 8B8B      STD	Y+19,R24
    00A34 8B8C      STD	Y+20,R24
    00A35 8B8D      STD	Y+21,R24
    00A36 882A      LDD	R2,Y+18
    00A37 883B      LDD	R3,Y+19
    00A38 884C      LDD	R4,Y+20
    00A39 885D      LDD	R5,Y+21
    00A3A 822E      STD	Y+6,R2
    00A3B 823F      STD	Y+7,R3
    00A3C 8648      STD	Y+8,R4
    00A3D 8659      STD	Y+9,R5
(1024) 	}
(1025) 
(1026) 	return ncl;		/* Return new cluster number or error code */
    00A3E 810E      LDD	R16,Y+6
    00A3F 811F      LDD	R17,Y+7
    00A40 8528      LDD	R18,Y+8
    00A41 8539      LDD	R19,Y+9
    00A42 9666      ADIW	R28,0x16
    00A43 940E 409C CALL	pop_xgsetF0FC
    00A45 9622      ADIW	R28,2
    00A46 9508      RET
ff.c:clmt_clust:
  tbl                  --> R10
  cl                   --> Y,+4
  ncl                  --> Y,+0
  ofs                  --> Y,+12
  fp                   --> R12
    00A47 933A      ST	-Y,R19
    00A48 932A      ST	-Y,R18
    00A49 940E 40AD CALL	push_xgset003C
    00A4B 0168      MOVW	R12,R16
    00A4C 9728      SBIW	R28,0x8
(1027) }
(1028) #endif /* !_FS_READONLY */
(1029) 
(1030) 
(1031) 
(1032) /*-----------------------------------------------------------------------*/
(1033) /* FAT handling - Convert offset into cluster with link map table        */
(1034) /*-----------------------------------------------------------------------*/
(1035) 
(1036) #if _USE_FASTSEEK
(1037) static
(1038) DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
(1039) 	FIL* fp,		/* Pointer to the file object */
(1040) 	DWORD ofs		/* File offset to be converted to cluster# */
(1041) )
(1042) {
(1043) 	DWORD cl, ncl, *tbl;
(1044) 
(1045) 
(1046) 	tbl = fp->cltbl + 1;	/* Top of CLMT */
    00A4D 01F6      MOVW	R30,R12
    00A4E 96B0      ADIW	R30,0x20
    00A4F 8180      LD	R24,Z
    00A50 8191      LDD	R25,Z+1
    00A51 9604      ADIW	R24,4
    00A52 015C      MOVW	R10,R24
(1047) 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
    00A53 E089      LDI	R24,0x9
    00A54 E090      LDI	R25,0
    00A55 850C      LDD	R16,Y+12
    00A56 851D      LDD	R17,Y+13
    00A57 852E      LDD	R18,Y+14
    00A58 853F      LDD	R19,Y+15
    00A59 938A      ST	-Y,R24
    00A5A 940E 4142 CALL	lsr32
    00A5C 01F6      MOVW	R30,R12
    00A5D 93AF      PUSH	R26
    00A5E 93BF      PUSH	R27
    00A5F 81A0      LD	R26,Z
    00A60 81B1      LDD	R27,Z+1
    00A61 01FD      MOVW	R30,R26
    00A62 91BF      POP	R27
    00A63 91AF      POP	R26
    00A64 9632      ADIW	R30,2
    00A65 8020      LD	R2,Z
    00A66 2433      CLR	R3
    00A67 2444      CLR	R4
    00A68 2455      CLR	R5
    00A69 925A      ST	-Y,R5
    00A6A 924A      ST	-Y,R4
    00A6B 923A      ST	-Y,R3
    00A6C 922A      ST	-Y,R2
    00A6D 940E 3FAD CALL	div32u
    00A6F 830C      STD	Y+4,R16
    00A70 831D      STD	Y+5,R17
    00A71 832E      STD	Y+6,R18
    00A72 833F      STD	Y+7,R19
(1048) 	for (;;) {
(1049) 		ncl = *tbl++;			/* Number of cluters in the fragment */
    00A73 01F5      MOVW	R30,R10
    00A74 9021      LD	R2,Z+
    00A75 9031      LD	R3,Z+
    00A76 9041      LD	R4,Z+
    00A77 9051      LD	R5,Z+
    00A78 015F      MOVW	R10,R30
    00A79 8228      ST	Y,R2
    00A7A 8239      STD	Y+1,R3
    00A7B 824A      STD	Y+2,R4
    00A7C 825B      STD	Y+3,R5
(1050) 		if (!ncl) return 0;		/* End of table? (error) */
    00A7D 8028      LD	R2,Y
    00A7E 8039      LDD	R3,Y+1
    00A7F 804A      LDD	R4,Y+2
    00A80 805B      LDD	R5,Y+3
    00A81 9488      BCLR	0
    00A82 2022      TST	R2
    00A83 0432      CPC	R3,R2
    00A84 0442      CPC	R4,R2
    00A85 0452      CPC	R5,R2
    00A86 F429      BNE	0x0A8C
    00A87 E000      LDI	R16,0
    00A88 E010      LDI	R17,0
    00A89 E020      LDI	R18,0
    00A8A E030      LDI	R19,0
    00A8B C02F      RJMP	0x0ABB
(1051) 		if (cl < ncl) break;	/* In this fragment? */
    00A8C 8028      LD	R2,Y
    00A8D 8039      LDD	R3,Y+1
    00A8E 804A      LDD	R4,Y+2
    00A8F 805B      LDD	R5,Y+3
    00A90 806C      LDD	R6,Y+4
    00A91 807D      LDD	R7,Y+5
    00A92 808E      LDD	R8,Y+6
    00A93 809F      LDD	R9,Y+7
    00A94 1462      CP	R6,R2
    00A95 0473      CPC	R7,R3
    00A96 0484      CPC	R8,R4
    00A97 0495      CPC	R9,R5
    00A98 F408      BCC	0x0A9A
    00A99 C014      RJMP	0x0AAE
(1052) 		cl -= ncl; tbl++;		/* Next fragment */
    00A9A 8028      LD	R2,Y
    00A9B 8039      LDD	R3,Y+1
    00A9C 804A      LDD	R4,Y+2
    00A9D 805B      LDD	R5,Y+3
    00A9E 806C      LDD	R6,Y+4
    00A9F 807D      LDD	R7,Y+5
    00AA0 808E      LDD	R8,Y+6
    00AA1 809F      LDD	R9,Y+7
    00AA2 1862      SUB	R6,R2
    00AA3 0873      SBC	R7,R3
    00AA4 0884      SBC	R8,R4
    00AA5 0895      SBC	R9,R5
    00AA6 826C      STD	Y+4,R6
    00AA7 827D      STD	Y+5,R7
    00AA8 828E      STD	Y+6,R8
    00AA9 829F      STD	Y+7,R9
    00AAA 01C5      MOVW	R24,R10
    00AAB 9604      ADIW	R24,4
    00AAC 015C      MOVW	R10,R24
    00AAD CFC5      RJMP	0x0A73
(1053) 	}
(1054) 	return cl + *tbl;	/* Return the cluster number */
    00AAE 01F5      MOVW	R30,R10
    00AAF 8020      LD	R2,Z
    00AB0 8031      LDD	R3,Z+1
    00AB1 8042      LDD	R4,Z+2
    00AB2 8053      LDD	R5,Z+3
    00AB3 810C      LDD	R16,Y+4
    00AB4 811D      LDD	R17,Y+5
    00AB5 812E      LDD	R18,Y+6
    00AB6 813F      LDD	R19,Y+7
    00AB7 0D02      ADD	R16,R2
    00AB8 1D13      ADC	R17,R3
    00AB9 1D24      ADC	R18,R4
    00ABA 1D35      ADC	R19,R5
    00ABB 9628      ADIW	R28,0x8
    00ABC 940E 4087 CALL	pop_xgset003C
    00ABE 9622      ADIW	R28,2
    00ABF 9508      RET
ff.c:dir_sdi:
  ic                   --> R14
  clst                 --> Y,+2
  idx                  --> R12
  dj                   --> R10
    00AC0 940E 40A7 CALL	push_xgsetF0FC
    00AC2 0169      MOVW	R12,R18
    00AC3 0158      MOVW	R10,R16
    00AC4 9726      SBIW	R28,6
(1055) }
(1056) #endif	/* _USE_FASTSEEK */
(1057) 
(1058) 
(1059) 
(1060) /*-----------------------------------------------------------------------*/
(1061) /* Directory handling - Set directory index                              */
(1062) /*-----------------------------------------------------------------------*/
(1063) 
(1064) static
(1065) FRESULT dir_sdi (
(1066) 	DIR *dj,		/* Pointer to directory object */
(1067) 	WORD idx		/* Directory index number */
(1068) )
(1069) {
(1070) 	DWORD clst;
(1071) 	WORD ic;
(1072) 
(1073) 
(1074) 	dj->index = idx;
    00AC5 01F5      MOVW	R30,R10
    00AC6 82D5      STD	Z+5,R13
    00AC7 82C4      STD	Z+4,R12
(1075) 	clst = dj->sclust;
    00AC8 9636      ADIW	R30,6
    00AC9 8020      LD	R2,Z
    00ACA 8031      LDD	R3,Z+1
    00ACB 8042      LDD	R4,Z+2
    00ACC 8053      LDD	R5,Z+3
    00ACD 822A      STD	Y+2,R2
    00ACE 823B      STD	Y+3,R3
    00ACF 824C      STD	Y+4,R4
    00AD0 825D      STD	Y+5,R5
(1076) 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    00AD1 E041      LDI	R20,1
    00AD2 E050      LDI	R21,0
    00AD3 E060      LDI	R22,0
    00AD4 E070      LDI	R23,0
    00AD5 802A      LDD	R2,Y+2
    00AD6 803B      LDD	R3,Y+3
    00AD7 804C      LDD	R4,Y+4
    00AD8 805D      LDD	R5,Y+5
    00AD9 1624      CP	R2,R20
    00ADA 0635      CPC	R3,R21
    00ADB 0646      CPC	R4,R22
    00ADC 0657      CPC	R5,R23
    00ADD F089      BEQ	0x0AEF
    00ADE 01F5      MOVW	R30,R10
    00ADF 81A0      LD	R26,Z
    00AE0 81B1      LDD	R27,Z+1
    00AE1 9656      ADIW	R26,0x16
    00AE2 902D      LD	R2,X+
    00AE3 903D      LD	R3,X+
    00AE4 904D      LD	R4,X+
    00AE5 905C      LD	R5,X
    00AE6 806A      LDD	R6,Y+2
    00AE7 807B      LDD	R7,Y+3
    00AE8 808C      LDD	R8,Y+4
    00AE9 809D      LDD	R9,Y+5
    00AEA 1462      CP	R6,R2
    00AEB 0473      CPC	R7,R3
    00AEC 0484      CPC	R8,R4
    00AED 0495      CPC	R9,R5
    00AEE F010      BCS	0x0AF1
(1077) 		return FR_INT_ERR;
    00AEF E002      LDI	R16,2
    00AF0 C0D6      RJMP	0x0BC7
(1078) 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    00AF1 802A      LDD	R2,Y+2
    00AF2 803B      LDD	R3,Y+3
    00AF3 804C      LDD	R4,Y+4
    00AF4 805D      LDD	R5,Y+5
    00AF5 9488      BCLR	0
    00AF6 2022      TST	R2
    00AF7 0432      CPC	R3,R2
    00AF8 0442      CPC	R4,R2
    00AF9 0452      CPC	R5,R2
    00AFA F479      BNE	0x0B0A
    00AFB 01F5      MOVW	R30,R10
    00AFC 81A0      LD	R26,Z
    00AFD 81B1      LDD	R27,Z+1
    00AFE 918C      LD	R24,X
    00AFF 3083      CPI	R24,3
    00B00 F449      BNE	0x0B0A
(1079) 		clst = dj->fs->dirbase;
    00B01 9692      ADIW	R26,0x22
    00B02 902D      LD	R2,X+
    00B03 903D      LD	R3,X+
    00B04 904D      LD	R4,X+
    00B05 905C      LD	R5,X
    00B06 822A      STD	Y+2,R2
    00B07 823B      STD	Y+3,R3
    00B08 824C      STD	Y+4,R4
    00B09 825D      STD	Y+5,R5
(1080) 
(1081) 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    00B0A 802A      LDD	R2,Y+2
    00B0B 803B      LDD	R3,Y+3
    00B0C 804C      LDD	R4,Y+4
    00B0D 805D      LDD	R5,Y+5
    00B0E 9488      BCLR	0
    00B0F 2022      TST	R2
    00B10 0432      CPC	R3,R2
    00B11 0442      CPC	R4,R2
    00B12 0452      CPC	R5,R2
    00B13 F009      BEQ	0x0B15
    00B14 C02B      RJMP	0x0B40
(1082) 		dj->clust = clst;
    00B15 01F5      MOVW	R30,R10
    00B16 8622      STD	Z+10,R2
    00B17 8633      STD	Z+11,R3
    00B18 8644      STD	Z+12,R4
    00B19 8655      STD	Z+13,R5
(1083) 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    00B1A 81A0      LD	R26,Z
    00B1B 81B1      LDD	R27,Z+1
    00B1C 9618      ADIW	R26,0x8
    00B1D 902D      LD	R2,X+
    00B1E 903C      LD	R3,X
    00B1F 14C2      CP	R12,R2
    00B20 04D3      CPC	R13,R3
    00B21 F010      BCS	0x0B24
(1084) 			return FR_INT_ERR;
    00B22 E002      LDI	R16,2
    00B23 C0A3      RJMP	0x0BC7
(1085) 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B24 0116      MOVW	R2,R12
    00B25 9436      LSR	R3
    00B26 9427      ROR	R2
    00B27 9436      LSR	R3
    00B28 9427      ROR	R2
    00B29 9436      LSR	R3
    00B2A 9427      ROR	R2
    00B2B 9436      LSR	R3
    00B2C 9427      ROR	R2
    00B2D 2444      CLR	R4
    00B2E 2455      CLR	R5
    00B2F 01F5      MOVW	R30,R10
    00B30 81A0      LD	R26,Z
    00B31 81B1      LDD	R27,Z+1
    00B32 9692      ADIW	R26,0x22
    00B33 906D      LD	R6,X+
    00B34 907D      LD	R7,X+
    00B35 908D      LD	R8,X+
    00B36 909C      LD	R9,X
    00B37 0C62      ADD	R6,R2
    00B38 1C73      ADC	R7,R3
    00B39 1C84      ADC	R8,R4
    00B3A 1C95      ADC	R9,R5
    00B3B 8666      STD	Z+14,R6
    00B3C 8677      STD	Z+15,R7
    00B3D 8A80      STD	Z+16,R8
    00B3E 8A91      STD	Z+17,R9
(1086) 	}
    00B3F C076      RJMP	0x0BB6
(1087) 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
(1088) 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    00B40 01F5      MOVW	R30,R10
    00B41 93AF      PUSH	R26
    00B42 93BF      PUSH	R27
    00B43 81A0      LD	R26,Z
    00B44 81B1      LDD	R27,Z+1
    00B45 01FD      MOVW	R30,R26
    00B46 91BF      POP	R27
    00B47 91AF      POP	R26
    00B48 8022      LDD	R2,Z+2
    00B49 E180      LDI	R24,0x10
    00B4A 9D82      MUL	R24,R2
    00B4B 0170      MOVW	R14,R0
    00B4C C040      RJMP	0x0B8D
(1089) 		while (idx >= ic) {	/* Follow cluster chain */
(1090) 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    00B4D 802A      LDD	R2,Y+2
    00B4E 803B      LDD	R3,Y+3
    00B4F 804C      LDD	R4,Y+4
    00B50 805D      LDD	R5,Y+5
    00B51 8248      ST	Y,R4
    00B52 8259      STD	Y+1,R5
    00B53 0191      MOVW	R18,R2
    00B54 01F5      MOVW	R30,R10
    00B55 8100      LD	R16,Z
    00B56 8111      LDD	R17,Z+1
    00B57 D9B5      RCALL	_get_fat
    00B58 830A      STD	Y+2,R16
    00B59 831B      STD	Y+3,R17
    00B5A 832C      STD	Y+4,R18
    00B5B 833D      STD	Y+5,R19
(1091) 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    00B5C EF4F      LDI	R20,0xFF
    00B5D EF5F      LDI	R21,0xFF
    00B5E EF6F      LDI	R22,0xFF
    00B5F EF7F      LDI	R23,0xFF
    00B60 802A      LDD	R2,Y+2
    00B61 803B      LDD	R3,Y+3
    00B62 804C      LDD	R4,Y+4
    00B63 805D      LDD	R5,Y+5
    00B64 1624      CP	R2,R20
    00B65 0635      CPC	R3,R21
    00B66 0646      CPC	R4,R22
    00B67 0657      CPC	R5,R23
    00B68 F411      BNE	0x0B6B
    00B69 E001      LDI	R16,1
    00B6A C05C      RJMP	0x0BC7
(1092) 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    00B6B E042      LDI	R20,2
    00B6C E050      LDI	R21,0
    00B6D E060      LDI	R22,0
    00B6E E070      LDI	R23,0
    00B6F 802A      LDD	R2,Y+2
    00B70 803B      LDD	R3,Y+3
    00B71 804C      LDD	R4,Y+4
    00B72 805D      LDD	R5,Y+5
    00B73 1624      CP	R2,R20
    00B74 0635      CPC	R3,R21
    00B75 0646      CPC	R4,R22
    00B76 0657      CPC	R5,R23
    00B77 F088      BCS	0x0B89
    00B78 01F5      MOVW	R30,R10
    00B79 81A0      LD	R26,Z
    00B7A 81B1      LDD	R27,Z+1
    00B7B 9656      ADIW	R26,0x16
    00B7C 902D      LD	R2,X+
    00B7D 903D      LD	R3,X+
    00B7E 904D      LD	R4,X+
    00B7F 905C      LD	R5,X
    00B80 806A      LDD	R6,Y+2
    00B81 807B      LDD	R7,Y+3
    00B82 808C      LDD	R8,Y+4
    00B83 809D      LDD	R9,Y+5
    00B84 1462      CP	R6,R2
    00B85 0473      CPC	R7,R3
    00B86 0484      CPC	R8,R4
    00B87 0495      CPC	R9,R5
    00B88 F010      BCS	0x0B8B
(1093) 				return FR_INT_ERR;
    00B89 E002      LDI	R16,2
    00B8A C03C      RJMP	0x0BC7
(1094) 			idx -= ic;
    00B8B 18CE      SUB	R12,R14
    00B8C 08DF      SBC	R13,R15
    00B8D 14CE      CP	R12,R14
    00B8E 04DF      CPC	R13,R15
    00B8F F008      BCS	0x0B91
    00B90 CFBC      RJMP	0x0B4D
(1095) 		}
(1096) 		dj->clust = clst;
    00B91 802A      LDD	R2,Y+2
    00B92 803B      LDD	R3,Y+3
    00B93 804C      LDD	R4,Y+4
    00B94 805D      LDD	R5,Y+5
    00B95 01F5      MOVW	R30,R10
    00B96 8622      STD	Z+10,R2
    00B97 8633      STD	Z+11,R3
    00B98 8644      STD	Z+12,R4
    00B99 8655      STD	Z+13,R5
(1097) 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B9A 8248      ST	Y,R4
    00B9B 8259      STD	Y+1,R5
    00B9C 0191      MOVW	R18,R2
    00B9D 8100      LD	R16,Z
    00B9E 8111      LDD	R17,Z+1
    00B9F D91B      RCALL	_clust2sect
    00BA0 0116      MOVW	R2,R12
    00BA1 9436      LSR	R3
    00BA2 9427      ROR	R2
    00BA3 9436      LSR	R3
    00BA4 9427      ROR	R2
    00BA5 9436      LSR	R3
    00BA6 9427      ROR	R2
    00BA7 9436      LSR	R3
    00BA8 9427      ROR	R2
    00BA9 2444      CLR	R4
    00BAA 2455      CLR	R5
    00BAB 0138      MOVW	R6,R16
    00BAC 0149      MOVW	R8,R18
    00BAD 0C62      ADD	R6,R2
    00BAE 1C73      ADC	R7,R3
    00BAF 1C84      ADC	R8,R4
    00BB0 1C95      ADC	R9,R5
    00BB1 01F5      MOVW	R30,R10
    00BB2 8666      STD	Z+14,R6
    00BB3 8677      STD	Z+15,R7
    00BB4 8A80      STD	Z+16,R8
    00BB5 8A91      STD	Z+17,R9
(1098) 	}
(1099) 
(1100) 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    00BB6 0196      MOVW	R18,R12
    00BB7 702F      ANDI	R18,0xF
    00BB8 7030      ANDI	R19,0
    00BB9 E200      LDI	R16,0x20
    00BBA E010      LDI	R17,0
    00BBB 940E 4043 CALL	empy16s
    00BBD 0118      MOVW	R2,R16
    00BBE 01F5      MOVW	R30,R10
    00BBF 8180      LD	R24,Z
    00BC0 8191      LDD	R25,Z+1
    00BC1 968E      ADIW	R24,0x2E
    00BC2 0E28      ADD	R2,R24
    00BC3 1E39      ADC	R3,R25
    00BC4 8A33      STD	Z+19,R3
    00BC5 8A22      STD	Z+18,R2
(1101) 
(1102) 	return FR_OK;	/* Seek succeeded */
    00BC6 2700      CLR	R16
    00BC7 9626      ADIW	R28,6
    00BC8 940C 409C JMP	pop_xgsetF0FC
ff.c:dir_next:
  c                    --> R10
  clst                 --> Y,+2
  i                    --> R12
  stretch              --> R10
  dj                   --> Y,+16
    00BCA 940E 3F62 CALL	push_arg4
    00BCC 940E 40A7 CALL	push_xgsetF0FC
    00BCE 0159      MOVW	R10,R18
    00BCF 9726      SBIW	R28,6
(1103) }
(1104) 
(1105) 
(1106) 
(1107) 
(1108) /*-----------------------------------------------------------------------*/
(1109) /* Directory handling - Move directory index next                        */
(1110) /*-----------------------------------------------------------------------*/
(1111) 
(1112) static
(1113) FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
(1114) 	DIR *dj,		/* Pointer to directory object */
(1115) 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
(1116) )
(1117) {
(1118) 	DWORD clst;
(1119) 	WORD i;
(1120) 
(1121) 
(1122) 	stretch = stretch;		/* To suppress warning on read-only cfg. */
(1123) 	i = dj->index + 1;
    00BD0 89E8      LDD	R30,Y+16
    00BD1 89F9      LDD	R31,Y+17
    00BD2 8184      LDD	R24,Z+4
    00BD3 8195      LDD	R25,Z+5
    00BD4 9601      ADIW	R24,1
    00BD5 016C      MOVW	R12,R24
(1124) 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    00BD6 3080      CPI	R24,0
    00BD7 0789      CPC	R24,R25
    00BD8 F059      BEQ	0x0BE4
    00BD9 963E      ADIW	R30,0xE
    00BDA 8020      LD	R2,Z
    00BDB 8031      LDD	R3,Z+1
    00BDC 8042      LDD	R4,Z+2
    00BDD 8053      LDD	R5,Z+3
    00BDE 9488      BCLR	0
    00BDF 2022      TST	R2
    00BE0 0432      CPC	R3,R2
    00BE1 0442      CPC	R4,R2
    00BE2 0452      CPC	R5,R2
    00BE3 F411      BNE	0x0BE6
(1125) 		return FR_NO_FILE;
    00BE4 E004      LDI	R16,4
    00BE5 C18D      RJMP	0x0D73
(1126) 
(1127) 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    00BE6 01C6      MOVW	R24,R12
    00BE7 708F      ANDI	R24,0xF
    00BE8 7090      ANDI	R25,0
    00BE9 3080      CPI	R24,0
    00BEA 0789      CPC	R24,R25
    00BEB F009      BEQ	0x0BED
    00BEC C170      RJMP	0x0D5D
(1128) 		dj->sect++;					/* Next sector */
    00BED 8988      LDD	R24,Y+16
    00BEE 8999      LDD	R25,Y+17
    00BEF 960E      ADIW	R24,0xE
    00BF0 E041      LDI	R20,1
    00BF1 E050      LDI	R21,0
    00BF2 E060      LDI	R22,0
    00BF3 E070      LDI	R23,0
    00BF4 01FC      MOVW	R30,R24
    00BF5 8020      LD	R2,Z
    00BF6 8031      LDD	R3,Z+1
    00BF7 8042      LDD	R4,Z+2
    00BF8 8053      LDD	R5,Z+3
    00BF9 0E24      ADD	R2,R20
    00BFA 1E35      ADC	R3,R21
    00BFB 1E46      ADC	R4,R22
    00BFC 1E57      ADC	R5,R23
    00BFD 8220      ST	Z,R2
    00BFE 8231      STD	Z+1,R3
    00BFF 8242      STD	Z+2,R4
    00C00 8253      STD	Z+3,R5
(1129) 
(1130) 		if (dj->clust == 0) {	/* Static table */
    00C01 89E8      LDD	R30,Y+16
    00C02 89F9      LDD	R31,Y+17
    00C03 963A      ADIW	R30,0xA
    00C04 8020      LD	R2,Z
    00C05 8031      LDD	R3,Z+1
    00C06 8042      LDD	R4,Z+2
    00C07 8053      LDD	R5,Z+3
    00C08 9488      BCLR	0
    00C09 2022      TST	R2
    00C0A 0432      CPC	R3,R2
    00C0B 0442      CPC	R4,R2
    00C0C 0452      CPC	R5,R2
    00C0D F469      BNE	0x0C1B
(1131) 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    00C0E 89E8      LDD	R30,Y+16
    00C0F 89F9      LDD	R31,Y+17
    00C10 81A0      LD	R26,Z
    00C11 81B1      LDD	R27,Z+1
    00C12 9618      ADIW	R26,0x8
    00C13 902D      LD	R2,X+
    00C14 903C      LD	R3,X
    00C15 14C2      CP	R12,R2
    00C16 04D3      CPC	R13,R3
    00C17 F408      BCC	0x0C19
    00C18 C144      RJMP	0x0D5D
(1132) 				return FR_NO_FILE;
    00C19 E004      LDI	R16,4
    00C1A C158      RJMP	0x0D73
(1133) 		}
(1134) 		else {					/* Dynamic table */
(1135) 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    00C1B 89E8      LDD	R30,Y+16
    00C1C 89F9      LDD	R31,Y+17
    00C1D 93AF      PUSH	R26
    00C1E 93BF      PUSH	R27
    00C1F 81A0      LD	R26,Z
    00C20 81B1      LDD	R27,Z+1
    00C21 01FD      MOVW	R30,R26
    00C22 91BF      POP	R27
    00C23 91AF      POP	R26
    00C24 8182      LDD	R24,Z+2
    00C25 2799      CLR	R25
    00C26 9701      SBIW	R24,1
    00C27 0116      MOVW	R2,R12
    00C28 9436      LSR	R3
    00C29 9427      ROR	R2
    00C2A 9436      LSR	R3
    00C2B 9427      ROR	R2
    00C2C 9436      LSR	R3
    00C2D 9427      ROR	R2
    00C2E 9436      LSR	R3
    00C2F 9427      ROR	R2
    00C30 2228      AND	R2,R24
    00C31 2239      AND	R3,R25
    00C32 2022      TST	R2
    00C33 F009      BEQ	0x0C35
    00C34 C128      RJMP	0x0D5D
    00C35 2033      TST	R3
    00C36 F009      BEQ	0x0C38
    00C37 C125      RJMP	0x0D5D
(1136) 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    00C38 89E8      LDD	R30,Y+16
    00C39 89F9      LDD	R31,Y+17
    00C3A 8422      LDD	R2,Z+10
    00C3B 8433      LDD	R3,Z+11
    00C3C 8444      LDD	R4,Z+12
    00C3D 8455      LDD	R5,Z+13
    00C3E 8248      ST	Y,R4
    00C3F 8259      STD	Y+1,R5
    00C40 0191      MOVW	R18,R2
    00C41 8100      LD	R16,Z
    00C42 8111      LDD	R17,Z+1
    00C43 D8C9      RCALL	_get_fat
    00C44 830A      STD	Y+2,R16
    00C45 831B      STD	Y+3,R17
    00C46 832C      STD	Y+4,R18
    00C47 833D      STD	Y+5,R19
(1137) 				if (clst <= 1) return FR_INT_ERR;
    00C48 E041      LDI	R20,1
    00C49 E050      LDI	R21,0
    00C4A E060      LDI	R22,0
    00C4B E070      LDI	R23,0
    00C4C 802A      LDD	R2,Y+2
    00C4D 803B      LDD	R3,Y+3
    00C4E 804C      LDD	R4,Y+4
    00C4F 805D      LDD	R5,Y+5
    00C50 1542      CP	R20,R2
    00C51 0553      CPC	R21,R3
    00C52 0564      CPC	R22,R4
    00C53 0575      CPC	R23,R5
    00C54 F010      BCS	0x0C57
    00C55 E002      LDI	R16,2
    00C56 C11C      RJMP	0x0D73
(1138) 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C57 EF4F      LDI	R20,0xFF
    00C58 EF5F      LDI	R21,0xFF
    00C59 EF6F      LDI	R22,0xFF
    00C5A EF7F      LDI	R23,0xFF
    00C5B 802A      LDD	R2,Y+2
    00C5C 803B      LDD	R3,Y+3
    00C5D 804C      LDD	R4,Y+4
    00C5E 805D      LDD	R5,Y+5
    00C5F 1624      CP	R2,R20
    00C60 0635      CPC	R3,R21
    00C61 0646      CPC	R4,R22
    00C62 0657      CPC	R5,R23
    00C63 F411      BNE	0x0C66
    00C64 E001      LDI	R16,1
    00C65 C10D      RJMP	0x0D73
(1139) 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    00C66 89E8      LDD	R30,Y+16
    00C67 89F9      LDD	R31,Y+17
    00C68 81A0      LD	R26,Z
    00C69 81B1      LDD	R27,Z+1
    00C6A 9656      ADIW	R26,0x16
    00C6B 902D      LD	R2,X+
    00C6C 903D      LD	R3,X+
    00C6D 904D      LD	R4,X+
    00C6E 905C      LD	R5,X
    00C6F 806A      LDD	R6,Y+2
    00C70 807B      LDD	R7,Y+3
    00C71 808C      LDD	R8,Y+4
    00C72 809D      LDD	R9,Y+5
    00C73 1462      CP	R6,R2
    00C74 0473      CPC	R7,R3
    00C75 0484      CPC	R8,R4
    00C76 0495      CPC	R9,R5
    00C77 F408      BCC	0x0C79
    00C78 C0CD      RJMP	0x0D46
(1140) #if !_FS_READONLY
(1141) 					BYTE c;
(1142) 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    00C79 20AA      TST	R10
    00C7A F421      BNE	0x0C7F
    00C7B 20BB      TST	R11
    00C7C F411      BNE	0x0C7F
    00C7D E004      LDI	R16,4
    00C7E C0F4      RJMP	0x0D73
(1143) 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    00C7F 89E8      LDD	R30,Y+16
    00C80 89F9      LDD	R31,Y+17
    00C81 8422      LDD	R2,Z+10
    00C82 8433      LDD	R3,Z+11
    00C83 8444      LDD	R4,Z+12
    00C84 8455      LDD	R5,Z+13
    00C85 8248      ST	Y,R4
    00C86 8259      STD	Y+1,R5
    00C87 0191      MOVW	R18,R2
    00C88 8100      LD	R16,Z
    00C89 8111      LDD	R17,Z+1
    00C8A DC44      RCALL	ff.c:create_chain
    00C8B 830A      STD	Y+2,R16
    00C8C 831B      STD	Y+3,R17
    00C8D 832C      STD	Y+4,R18
    00C8E 833D      STD	Y+5,R19
(1144) 					if (clst == 0) return FR_DENIED;			/* No free cluster */
    00C8F 802A      LDD	R2,Y+2
    00C90 803B      LDD	R3,Y+3
    00C91 804C      LDD	R4,Y+4
    00C92 805D      LDD	R5,Y+5
    00C93 9488      BCLR	0
    00C94 2022      TST	R2
    00C95 0432      CPC	R3,R2
    00C96 0442      CPC	R4,R2
    00C97 0452      CPC	R5,R2
    00C98 F411      BNE	0x0C9B
    00C99 E007      LDI	R16,7
    00C9A C0D8      RJMP	0x0D73
(1145) 					if (clst == 1) return FR_INT_ERR;
    00C9B E041      LDI	R20,1
    00C9C E050      LDI	R21,0
    00C9D E060      LDI	R22,0
    00C9E E070      LDI	R23,0
    00C9F 802A      LDD	R2,Y+2
    00CA0 803B      LDD	R3,Y+3
    00CA1 804C      LDD	R4,Y+4
    00CA2 805D      LDD	R5,Y+5
    00CA3 1624      CP	R2,R20
    00CA4 0635      CPC	R3,R21
    00CA5 0646      CPC	R4,R22
    00CA6 0657      CPC	R5,R23
    00CA7 F411      BNE	0x0CAA
    00CA8 E002      LDI	R16,2
    00CA9 C0C9      RJMP	0x0D73
(1146) 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00CAA EF4F      LDI	R20,0xFF
    00CAB EF5F      LDI	R21,0xFF
    00CAC EF6F      LDI	R22,0xFF
    00CAD EF7F      LDI	R23,0xFF
    00CAE 802A      LDD	R2,Y+2
    00CAF 803B      LDD	R3,Y+3
    00CB0 804C      LDD	R4,Y+4
    00CB1 805D      LDD	R5,Y+5
    00CB2 1624      CP	R2,R20
    00CB3 0635      CPC	R3,R21
    00CB4 0646      CPC	R4,R22
    00CB5 0657      CPC	R5,R23
    00CB6 F411      BNE	0x0CB9
    00CB7 E001      LDI	R16,1
    00CB8 C0BA      RJMP	0x0D73
(1147) 					/* Clean-up stretched table */
(1148) 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    00CB9 E040      LDI	R20,0
    00CBA E050      LDI	R21,0
    00CBB E060      LDI	R22,0
    00CBC E070      LDI	R23,0
    00CBD 8368      ST	Y,R22
    00CBE 8379      STD	Y+1,R23
    00CBF 019A      MOVW	R18,R20
    00CC0 89E8      LDD	R30,Y+16
    00CC1 89F9      LDD	R31,Y+17
    00CC2 8100      LD	R16,Z
    00CC3 8111      LDD	R17,Z+1
    00CC4 940E 0344 CALL	ff.c:move_window
    00CC6 2300      TST	R16
    00CC7 F011      BEQ	0x0CCA
    00CC8 E001      LDI	R16,1
    00CC9 C0A9      RJMP	0x0D73
(1149) 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    00CCA E080      LDI	R24,0
    00CCB E092      LDI	R25,2
    00CCC 8399      STD	Y+1,R25
    00CCD 8388      ST	Y,R24
    00CCE 2722      CLR	R18
    00CCF 2733      CLR	R19
    00CD0 89E8      LDD	R30,Y+16
    00CD1 89F9      LDD	R31,Y+17
    00CD2 8100      LD	R16,Z
    00CD3 8111      LDD	R17,Z+1
    00CD4 5D02      SUBI	R16,0xD2
    00CD5 4F1F      SBCI	R17,0xFF
    00CD6 940E 0301 CALL	ff.c:mem_set
(1150) 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    00CD8 802A      LDD	R2,Y+2
    00CD9 803B      LDD	R3,Y+3
    00CDA 804C      LDD	R4,Y+4
    00CDB 805D      LDD	R5,Y+5
    00CDC 8248      ST	Y,R4
    00CDD 8259      STD	Y+1,R5
    00CDE 0191      MOVW	R18,R2
    00CDF 89E8      LDD	R30,Y+16
    00CE0 89F9      LDD	R31,Y+17
    00CE1 80A0      LD	R10,Z
    00CE2 80B1      LDD	R11,Z+1
    00CE3 0185      MOVW	R16,R10
    00CE4 940E 04BB CALL	_clust2sect
    00CE6 01F5      MOVW	R30,R10
    00CE7 A702      STD	Z+42,R16
    00CE8 A713      STD	Z+43,R17
    00CE9 A724      STD	Z+44,R18
    00CEA A735      STD	Z+45,R19
(1151) 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    00CEB 24AA      CLR	R10
    00CEC C035      RJMP	0x0D22
(1152) 						dj->fs->wflag = 1;
    00CED E081      LDI	R24,1
    00CEE 89E8      LDD	R30,Y+16
    00CEF 89F9      LDD	R31,Y+17
    00CF0 93AF      PUSH	R26
    00CF1 93BF      PUSH	R27
    00CF2 81A0      LD	R26,Z
    00CF3 81B1      LDD	R27,Z+1
    00CF4 01FD      MOVW	R30,R26
    00CF5 91BF      POP	R27
    00CF6 91AF      POP	R26
    00CF7 8384      STD	Z+4,R24
(1153) 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    00CF8 E040      LDI	R20,0
    00CF9 E050      LDI	R21,0
    00CFA E060      LDI	R22,0
    00CFB E070      LDI	R23,0
    00CFC 8368      ST	Y,R22
    00CFD 8379      STD	Y+1,R23
    00CFE 019A      MOVW	R18,R20
    00CFF 89E8      LDD	R30,Y+16
    00D00 89F9      LDD	R31,Y+17
    00D01 8100      LD	R16,Z
    00D02 8111      LDD	R17,Z+1
    00D03 940E 0344 CALL	ff.c:move_window
    00D05 2EE0      MOV	R14,R16
    00D06 2300      TST	R16
    00D07 F011      BEQ	0x0D0A
    00D08 E001      LDI	R16,1
    00D09 C069      RJMP	0x0D73
(1154) 						dj->fs->winsect++;
    00D0A 89E8      LDD	R30,Y+16
    00D0B 89F9      LDD	R31,Y+17
    00D0C 8180      LD	R24,Z
    00D0D 8191      LDD	R25,Z+1
    00D0E 968A      ADIW	R24,0x2A
    00D0F 017C      MOVW	R14,R24
    00D10 E041      LDI	R20,1
    00D11 E050      LDI	R21,0
    00D12 E060      LDI	R22,0
    00D13 E070      LDI	R23,0
    00D14 01FC      MOVW	R30,R24
    00D15 8020      LD	R2,Z
    00D16 8031      LDD	R3,Z+1
    00D17 8042      LDD	R4,Z+2
    00D18 8053      LDD	R5,Z+3
    00D19 0E24      ADD	R2,R20
    00D1A 1E35      ADC	R3,R21
    00D1B 1E46      ADC	R4,R22
    00D1C 1E57      ADC	R5,R23
    00D1D 8220      ST	Z,R2
    00D1E 8231      STD	Z+1,R3
    00D1F 8242      STD	Z+2,R4
    00D20 8253      STD	Z+3,R5
    00D21 94A3      INC	R10
    00D22 89E8      LDD	R30,Y+16
    00D23 89F9      LDD	R31,Y+17
    00D24 93AF      PUSH	R26
    00D25 93BF      PUSH	R27
    00D26 81A0      LD	R26,Z
    00D27 81B1      LDD	R27,Z+1
    00D28 01FD      MOVW	R30,R26
    00D29 91BF      POP	R27
    00D2A 91AF      POP	R26
    00D2B 8022      LDD	R2,Z+2
    00D2C 14A2      CP	R10,R2
    00D2D F408      BCC	0x0D2F
    00D2E CFBE      RJMP	0x0CED
(1155) 					}
(1156) 					dj->fs->winsect -= c;						/* Rewind window address */
    00D2F 89E8      LDD	R30,Y+16
    00D30 89F9      LDD	R31,Y+17
    00D31 8180      LD	R24,Z
    00D32 8191      LDD	R25,Z+1
    00D33 968A      ADIW	R24,0x2A
    00D34 017C      MOVW	R14,R24
    00D35 2C2A      MOV	R2,R10
    00D36 2433      CLR	R3
    00D37 2444      CLR	R4
    00D38 2455      CLR	R5
    00D39 01FC      MOVW	R30,R24
    00D3A 8060      LD	R6,Z
    00D3B 8071      LDD	R7,Z+1
    00D3C 8082      LDD	R8,Z+2
    00D3D 8093      LDD	R9,Z+3
    00D3E 1862      SUB	R6,R2
    00D3F 0873      SBC	R7,R3
    00D40 0884      SBC	R8,R4
    00D41 0895      SBC	R9,R5
    00D42 8260      ST	Z,R6
    00D43 8271      STD	Z+1,R7
    00D44 8282      STD	Z+2,R8
    00D45 8293      STD	Z+3,R9
(1157) #else
(1158) 					return FR_NO_FILE;			/* Report EOT */
(1159) #endif
(1160) 				}
(1161) 				dj->clust = clst;				/* Initialize data for new cluster */
    00D46 802A      LDD	R2,Y+2
    00D47 803B      LDD	R3,Y+3
    00D48 804C      LDD	R4,Y+4
    00D49 805D      LDD	R5,Y+5
    00D4A 89E8      LDD	R30,Y+16
    00D4B 89F9      LDD	R31,Y+17
    00D4C 8622      STD	Z+10,R2
    00D4D 8633      STD	Z+11,R3
    00D4E 8644      STD	Z+12,R4
    00D4F 8655      STD	Z+13,R5
(1162) 				dj->sect = clust2sect(dj->fs, clst);
    00D50 8248      ST	Y,R4
    00D51 8259      STD	Y+1,R5
    00D52 0191      MOVW	R18,R2
    00D53 8100      LD	R16,Z
    00D54 8111      LDD	R17,Z+1
    00D55 940E 04BB CALL	_clust2sect
    00D57 89E8      LDD	R30,Y+16
    00D58 89F9      LDD	R31,Y+17
    00D59 8706      STD	Z+14,R16
    00D5A 8717      STD	Z+15,R17
    00D5B 8B20      STD	Z+16,R18
    00D5C 8B31      STD	Z+17,R19
(1163) 			}
(1164) 		}
(1165) 	}
(1166) 
(1167) 	dj->index = i;
    00D5D 89E8      LDD	R30,Y+16
    00D5E 89F9      LDD	R31,Y+17
    00D5F 82D5      STD	Z+5,R13
    00D60 82C4      STD	Z+4,R12
(1168) 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    00D61 0196      MOVW	R18,R12
    00D62 702F      ANDI	R18,0xF
    00D63 7030      ANDI	R19,0
    00D64 E200      LDI	R16,0x20
    00D65 E010      LDI	R17,0
    00D66 940E 4043 CALL	empy16s
    00D68 0118      MOVW	R2,R16
    00D69 89E8      LDD	R30,Y+16
    00D6A 89F9      LDD	R31,Y+17
    00D6B 8180      LD	R24,Z
    00D6C 8191      LDD	R25,Z+1
    00D6D 968E      ADIW	R24,0x2E
    00D6E 0E28      ADD	R2,R24
    00D6F 1E39      ADC	R3,R25
    00D70 8A33      STD	Z+19,R3
    00D71 8A22      STD	Z+18,R2
(1169) 
(1170) 	return FR_OK;
    00D72 2700      CLR	R16
    00D73 9626      ADIW	R28,6
    00D74 940E 409C CALL	pop_xgsetF0FC
    00D76 9624      ADIW	R28,4
    00D77 9508      RET
ff.c:dir_find:
  c                    --> R12
  dir                  --> R10
  res                  --> R20
  dj                   --> R22
    00D78 940E 40E2 CALL	push_xgsetF03C
    00D7A 01B8      MOVW	R22,R16
    00D7B 9722      SBIW	R28,2
(1171) }
(1172) 
(1173) 
(1174) 
(1175) 
(1176) /*-----------------------------------------------------------------------*/
(1177) /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
(1178) /*-----------------------------------------------------------------------*/
(1179) #if _USE_LFN
(1180) static
(1181) const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
(1182) 
(1183) 
(1184) static
(1185) int cmp_lfn (			/* 1:Matched, 0:Not matched */
(1186) 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
(1187) 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
(1188) )
(1189) {
(1190) 	UINT i, s;
(1191) 	WCHAR wc, uc;
(1192) 
(1193) 
(1194) 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
(1195) 	s = 0; wc = 1;
(1196) 	do {
(1197) 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
(1198) 		if (wc) {	/* Last char has not been processed */
(1199) 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
(1200) 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
(1201) 				return 0;				/* Not matched */
(1202) 		} else {
(1203) 			if (uc != 0xFFFF) return 0;	/* Check filler */
(1204) 		}
(1205) 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
(1206) 
(1207) 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
(1208) 		return 0;
(1209) 
(1210) 	return 1;						/* The part of LFN matched */
(1211) }
(1212) 
(1213) 
(1214) 
(1215) static
(1216) int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
(1217) 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
(1218) 	BYTE *dir			/* Pointer to the directory entry */
(1219) )
(1220) {
(1221) 	UINT i, s;
(1222) 	WCHAR wc, uc;
(1223) 
(1224) 
(1225) 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
(1226) 
(1227) 	s = 0; wc = 1;
(1228) 	do {
(1229) 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
(1230) 		if (wc) {	/* Last char has not been processed */
(1231) 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
(1232) 			lfnbuf[i++] = wc = uc;			/* Store it */
(1233) 		} else {
(1234) 			if (uc != 0xFFFF) return 0;		/* Check filler */
(1235) 		}
(1236) 	} while (++s < 13);						/* Read all character in the entry */
(1237) 
(1238) 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
(1239) 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
(1240) 		lfnbuf[i] = 0;
(1241) 	}
(1242) 
(1243) 	return 1;
(1244) }
(1245) 
(1246) 
(1247) #if !_FS_READONLY
(1248) static
(1249) void fit_lfn (
(1250) 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
(1251) 	BYTE *dir,				/* Pointer to the directory entry */
(1252) 	BYTE ord,				/* LFN order (1-20) */
(1253) 	BYTE sum				/* SFN sum */
(1254) )
(1255) {
(1256) 	UINT i, s;
(1257) 	WCHAR wc;
(1258) 
(1259) 
(1260) 	dir[LDIR_Chksum] = sum;			/* Set check sum */
(1261) 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
(1262) 	dir[LDIR_Type] = 0;
(1263) 	ST_WORD(dir+LDIR_FstClusLO, 0);
(1264) 
(1265) 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
(1266) 	s = wc = 0;
(1267) 	do {
(1268) 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
(1269) 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
(1270) 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
(1271) 	} while (++s < 13);
(1272) 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
(1273) 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
(1274) }
(1275) 
(1276) #endif
(1277) #endif
(1278) 
(1279) 
(1280) 
(1281) /*-----------------------------------------------------------------------*/
(1282) /* Create numbered name                                                  */
(1283) /*-----------------------------------------------------------------------*/
(1284) #if _USE_LFN
(1285) void gen_numname (
(1286) 	BYTE *dst,			/* Pointer to generated SFN */
(1287) 	const BYTE *src,	/* Pointer to source SFN to be modified */
(1288) 	const WCHAR *lfn,	/* Pointer to LFN */
(1289) 	WORD seq			/* Sequence number */
(1290) )
(1291) {
(1292) 	BYTE ns[8], c;
(1293) 	UINT i, j;
(1294) 
(1295) 
(1296) 	mem_cpy(dst, src, 11);
(1297) 
(1298) 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
(1299) 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
(1300) 	}
(1301) 
(1302) 	/* itoa (hexdecimal) */
(1303) 	i = 7;
(1304) 	do {
(1305) 		c = (seq % 16) + '0';
(1306) 		if (c > '9') c += 7;
(1307) 		ns[i--] = c;
(1308) 		seq /= 16;
(1309) 	} while (seq);
(1310) 	ns[i] = '~';
(1311) 
(1312) 	/* Append the number */
(1313) 	for (j = 0; j < i && dst[j] != ' '; j++) {
(1314) 		if (IsDBCS1(dst[j])) {
(1315) 			if (j == i - 1) break;
(1316) 			j++;
(1317) 		}
(1318) 	}
(1319) 	do {
(1320) 		dst[j++] = (i < 8) ? ns[i++] : ' ';
(1321) 	} while (j < 8);
(1322) }
(1323) #endif
(1324) 
(1325) 
(1326) 
(1327) 
(1328) /*-----------------------------------------------------------------------*/
(1329) /* Calculate sum of an SFN                                               */
(1330) /*-----------------------------------------------------------------------*/
(1331) #if _USE_LFN
(1332) static
(1333) BYTE sum_sfn (
(1334) 	const BYTE *dir		/* Ptr to directory entry */
(1335) )
(1336) {
(1337) 	BYTE sum = 0;
(1338) 	UINT n = 11;
(1339) 
(1340) 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
(1341) 	return sum;
(1342) }
(1343) #endif
(1344) 
(1345) 
(1346) 
(1347) 
(1348) /*-----------------------------------------------------------------------*/
(1349) /* Directory handling - Find an object in the directory                  */
(1350) /*-----------------------------------------------------------------------*/
(1351) 
(1352) static
(1353) FRESULT dir_find (
(1354) 	DIR *dj			/* Pointer to the directory object linked to the file name */
(1355) )
(1356) {
(1357) 	FRESULT res;
(1358) 	BYTE c, *dir;
(1359) #if _USE_LFN
(1360) 	BYTE a, ord, sum;
(1361) #endif
(1362) 
(1363) 	res = dir_sdi(dj, 0);			/* Rewind directory object */
    00D7C 2722      CLR	R18
    00D7D 2733      CLR	R19
    00D7E 018B      MOVW	R16,R22
    00D7F DD40      RCALL	ff.c:dir_sdi
    00D80 2F40      MOV	R20,R16
(1364) 	if (res != FR_OK) return res;
    00D81 2300      TST	R16
    00D82 F009      BEQ	0x0D84
    00D83 C036      RJMP	0x0DBA
(1365) 
(1366) #if _USE_LFN
(1367) 	ord = sum = 0xFF;
(1368) #endif
(1369) 	do {
(1370) 		res = move_window(dj->fs, dj->sect);
    00D84 01FB      MOVW	R30,R22
    00D85 8426      LDD	R2,Z+14
    00D86 8437      LDD	R3,Z+15
    00D87 8840      LDD	R4,Z+16
    00D88 8851      LDD	R5,Z+17
    00D89 8248      ST	Y,R4
    00D8A 8259      STD	Y+1,R5
    00D8B 0191      MOVW	R18,R2
    00D8C 8100      LD	R16,Z
    00D8D 8111      LDD	R17,Z+1
    00D8E 940E 0344 CALL	ff.c:move_window
    00D90 2F40      MOV	R20,R16
(1371) 		if (res != FR_OK) break;
    00D91 2300      TST	R16
    00D92 F009      BEQ	0x0D94
    00D93 C025      RJMP	0x0DB9
(1372) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00D94 01FB      MOVW	R30,R22
    00D95 88A2      LDD	R10,Z+18
    00D96 88B3      LDD	R11,Z+19
(1373) 		c = dir[DIR_Name];
    00D97 01F5      MOVW	R30,R10
    00D98 80C0      LD	R12,Z
(1374) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00D99 20CC      TST	R12
    00D9A F411      BNE	0x0D9D
    00D9B E044      LDI	R20,4
    00D9C C01C      RJMP	0x0DB9
(1375) #if _USE_LFN	/* LFN configuration */
(1376) 		a = dir[DIR_Attr] & AM_MASK;
(1377) 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1378) 			ord = 0xFF;
(1379) 		} else {
(1380) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1381) 				if (dj->lfn) {
(1382) 					if (c & LLE) {		/* Is it start of LFN sequence? */
(1383) 						sum = dir[LDIR_Chksum];
(1384) 						c &= ~LLE; ord = c;	/* LFN start order */
(1385) 						dj->lfn_idx = dj->index;
(1386) 					}
(1387) 					/* Check validity of the LFN entry and compare it with given name */
(1388) 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1389) 				}
(1390) 			} else {					/* An SFN entry is found */
(1391) 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
(1392) 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
(1393) 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
(1394) 			}
(1395) 		}
(1396) #else		/* Non LFN configuration */
(1397) 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    00D9D 01F5      MOVW	R30,R10
    00D9E 8423      LDD	R2,Z+11
    00D9F FC23      SBRC	R2,3
    00DA0 C00F      RJMP	0x0DB0
    00DA1 E08B      LDI	R24,0xB
    00DA2 E090      LDI	R25,0
    00DA3 8399      STD	Y+1,R25
    00DA4 8388      ST	Y,R24
    00DA5 01FB      MOVW	R30,R22
    00DA6 8924      LDD	R18,Z+20
    00DA7 8935      LDD	R19,Z+21
    00DA8 0185      MOVW	R16,R10
    00DA9 940E 0313 CALL	ff.c:mem_cmp
    00DAB 0158      MOVW	R10,R16
    00DAC 3000      CPI	R16,0
    00DAD 0701      CPC	R16,R17
    00DAE F409      BNE	0x0DB0
(1398) 			break;
    00DAF C009      RJMP	0x0DB9
(1399) #endif
(1400) 		res = dir_next(dj, 0);		/* Next entry */
    00DB0 2722      CLR	R18
    00DB1 2733      CLR	R19
    00DB2 018B      MOVW	R16,R22
    00DB3 DE16      RCALL	ff.c:dir_next
    00DB4 2EA0      MOV	R10,R16
    00DB5 2D4A      MOV	R20,R10
(1401) 	} while (res == FR_OK);
    00DB6 2344      TST	R20
    00DB7 F409      BNE	0x0DB9
    00DB8 CFCB      RJMP	0x0D84
(1402) 
(1403) 	return res;
    00DB9 2F04      MOV	R16,R20
    00DBA 9622      ADIW	R28,2
    00DBB 940C 40EB JMP	pop_xgsetF03C
ff.c:dir_read:
  dir                  --> R10
  c                    --> R12
  res                  --> R20
  dj                   --> R22
    00DBD 940E 40E2 CALL	push_xgsetF03C
    00DBF 01B8      MOVW	R22,R16
    00DC0 9722      SBIW	R28,2
(1404) }
(1405) 
(1406) 
(1407) 
(1408) 
(1409) /*-----------------------------------------------------------------------*/
(1410) /* Read an object from the directory                                     */
(1411) /*-----------------------------------------------------------------------*/
(1412) #if _FS_MINIMIZE <= 1
(1413) static
(1414) FRESULT dir_read (
(1415) 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
(1416) )
(1417) {
(1418) 	FRESULT res;
(1419) 	BYTE c, *dir;
(1420) #if _USE_LFN
(1421) 	BYTE a, ord = 0xFF, sum = 0xFF;
(1422) #endif
(1423) 
(1424) 	res = FR_NO_FILE;
    00DC1 E044      LDI	R20,4
    00DC2 C02B      RJMP	0x0DEE
(1425) 	while (dj->sect) {
(1426) 		res = move_window(dj->fs, dj->sect);
    00DC3 01FB      MOVW	R30,R22
    00DC4 8426      LDD	R2,Z+14
    00DC5 8437      LDD	R3,Z+15
    00DC6 8840      LDD	R4,Z+16
    00DC7 8851      LDD	R5,Z+17
    00DC8 8248      ST	Y,R4
    00DC9 8259      STD	Y+1,R5
    00DCA 0191      MOVW	R18,R2
    00DCB 8100      LD	R16,Z
    00DCC 8111      LDD	R17,Z+1
    00DCD 940E 0344 CALL	ff.c:move_window
    00DCF 2F40      MOV	R20,R16
(1427) 		if (res != FR_OK) break;
    00DD0 2300      TST	R16
    00DD1 F009      BEQ	0x0DD3
    00DD2 C028      RJMP	0x0DFB
(1428) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00DD3 01FB      MOVW	R30,R22
    00DD4 88A2      LDD	R10,Z+18
    00DD5 88B3      LDD	R11,Z+19
(1429) 		c = dir[DIR_Name];
    00DD6 01F5      MOVW	R30,R10
    00DD7 80C0      LD	R12,Z
(1430) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00DD8 20CC      TST	R12
    00DD9 F411      BNE	0x0DDC
    00DDA E044      LDI	R20,4
    00DDB C01F      RJMP	0x0DFB
(1431) #if _USE_LFN	/* LFN configuration */
(1432) 		a = dir[DIR_Attr] & AM_MASK;
(1433) 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1434) 			ord = 0xFF;
(1435) 		} else {
(1436) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1437) 				if (c & LLE) {			/* Is it start of LFN sequence? */
(1438) 					sum = dir[LDIR_Chksum];
(1439) 					c &= ~LLE; ord = c;
(1440) 					dj->lfn_idx = dj->index;
(1441) 				}
(1442) 				/* Check LFN validity and capture it */
(1443) 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1444) 			} else {					/* An SFN entry is found */
(1445) 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
(1446) 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
(1447) 				break;
(1448) 			}
(1449) 		}
(1450) #else		/* Non LFN configuration */
(1451) 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    00DDC 2D8C      MOV	R24,R12
    00DDD 3E85      CPI	R24,0xE5
    00DDE F039      BEQ	0x0DE6
    00DDF 328E      CPI	R24,0x2E
    00DE0 F029      BEQ	0x0DE6
    00DE1 01F5      MOVW	R30,R10
    00DE2 8423      LDD	R2,Z+11
    00DE3 FC23      SBRC	R2,3
    00DE4 C001      RJMP	0x0DE6
(1452) 			break;
    00DE5 C015      RJMP	0x0DFB
(1453) #endif
(1454) 		res = dir_next(dj, 0);				/* Next entry */
    00DE6 2722      CLR	R18
    00DE7 2733      CLR	R19
    00DE8 018B      MOVW	R16,R22
    00DE9 DDE0      RCALL	ff.c:dir_next
    00DEA 2F40      MOV	R20,R16
(1455) 		if (res != FR_OK) break;
    00DEB 2300      TST	R16
    00DEC F009      BEQ	0x0DEE
    00DED C00D      RJMP	0x0DFB
    00DEE 01FB      MOVW	R30,R22
    00DEF 963E      ADIW	R30,0xE
    00DF0 8020      LD	R2,Z
    00DF1 8031      LDD	R3,Z+1
    00DF2 8042      LDD	R4,Z+2
    00DF3 8053      LDD	R5,Z+3
    00DF4 9488      BCLR	0
    00DF5 2022      TST	R2
    00DF6 0432      CPC	R3,R2
    00DF7 0442      CPC	R4,R2
    00DF8 0452      CPC	R5,R2
    00DF9 F009      BEQ	0x0DFB
    00DFA CFC8      RJMP	0x0DC3
(1456) 	}
(1457) 
(1458) 	if (res != FR_OK) dj->sect = 0;
    00DFB 2344      TST	R20
    00DFC F039      BEQ	0x0E04
    00DFD 01FB      MOVW	R30,R22
    00DFE 963E      ADIW	R30,0xE
    00DFF E080      LDI	R24,0
    00E00 8380      ST	Z,R24
    00E01 8381      STD	Z+1,R24
    00E02 8382      STD	Z+2,R24
    00E03 8383      STD	Z+3,R24
(1459) 
(1460) 	return res;
    00E04 2F04      MOV	R16,R20
    00E05 9622      ADIW	R28,2
    00E06 940C 40EB JMP	pop_xgsetF03C
ff.c:dir_register:
  dir                  --> R12
  c                    --> R22
  res                  --> R10
  dj                   --> R20
    00E08 940E 40E2 CALL	push_xgsetF03C
    00E0A 01A8      MOVW	R20,R16
    00E0B 9722      SBIW	R28,2
(1461) }
(1462) #endif
(1463) 
(1464) 
(1465) 
(1466) /*-----------------------------------------------------------------------*/
(1467) /* Register an object to the directory                                   */
(1468) /*-----------------------------------------------------------------------*/
(1469) #if !_FS_READONLY
(1470) static
(1471) FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
(1472) 	DIR *dj				/* Target directory with object name to be created */
(1473) )
(1474) {
(1475) 	FRESULT res;
(1476) 	BYTE c, *dir;
(1477) #if _USE_LFN	/* LFN configuration */
(1478) 	WORD n, ne, is;
(1479) 	BYTE sn[12], *fn, sum;
(1480) 	WCHAR *lfn;
(1481) 
(1482) 
(1483) 	fn = dj->fn; lfn = dj->lfn;
(1484) 	mem_cpy(sn, fn, 12);
(1485) 
(1486) 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
(1487) 		return FR_INVALID_NAME;
(1488) 
(1489) 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
(1490) 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
(1491) 		for (n = 1; n < 100; n++) {
(1492) 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
(1493) 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
(1494) 			if (res != FR_OK) break;
(1495) 		}
(1496) 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
(1497) 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
(1498) 		fn[NS] = sn[NS]; dj->lfn = lfn;
(1499) 	}
(1500) 
(1501) 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
(1502) 		for (ne = 0; lfn[ne]; ne++) ;
(1503) 		ne = (ne + 25) / 13;
(1504) 	} else {						/* Otherwise reserve only an SFN entry. */
(1505) 		ne = 1;
(1506) 	}
(1507) 
(1508) 	/* Reserve contiguous entries */
(1509) 	res = dir_sdi(dj, 0);
(1510) 	if (res != FR_OK) return res;
(1511) 	n = is = 0;
(1512) 	do {
(1513) 		res = move_window(dj->fs, dj->sect);
(1514) 		if (res != FR_OK) break;
(1515) 		c = *dj->dir;				/* Check the entry status */
(1516) 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
(1517) 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
(1518) 			if (++n == ne) break;	/* A contiguous entry that required count is found */
(1519) 		} else {
(1520) 			n = 0;					/* Not a blank entry. Restart to search */
(1521) 		}
(1522) 		res = dir_next(dj, 1);		/* Next entry with table stretch */
(1523) 	} while (res == FR_OK);
(1524) 
(1525) 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
(1526) 		res = dir_sdi(dj, is);
(1527) 		if (res == FR_OK) {
(1528) 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
(1529) 			ne--;
(1530) 			do {					/* Store LFN entries in bottom first */
(1531) 				res = move_window(dj->fs, dj->sect);
(1532) 				if (res != FR_OK) break;
(1533) 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
(1534) 				dj->fs->wflag = 1;
(1535) 				res = dir_next(dj, 0);	/* Next entry */
(1536) 			} while (res == FR_OK && --ne);
(1537) 		}
(1538) 	}
(1539) 
(1540) #else	/* Non LFN configuration */
(1541) 	res = dir_sdi(dj, 0);
    00E0C 2722      CLR	R18
    00E0D 2733      CLR	R19
    00E0E 018A      MOVW	R16,R20
    00E0F DCB0      RCALL	ff.c:dir_sdi
    00E10 2EA0      MOV	R10,R16
(1542) 	if (res == FR_OK) {
    00E11 2300      TST	R16
    00E12 F509      BNE	0x0E34
(1543) 		do {	/* Find a blank entry for the SFN */
(1544) 			res = move_window(dj->fs, dj->sect);
    00E13 01FA      MOVW	R30,R20
    00E14 8426      LDD	R2,Z+14
    00E15 8437      LDD	R3,Z+15
    00E16 8840      LDD	R4,Z+16
    00E17 8851      LDD	R5,Z+17
    00E18 8248      ST	Y,R4
    00E19 8259      STD	Y+1,R5
    00E1A 0191      MOVW	R18,R2
    00E1B 8100      LD	R16,Z
    00E1C 8111      LDD	R17,Z+1
    00E1D 940E 0344 CALL	ff.c:move_window
    00E1F 2EA0      MOV	R10,R16
(1545) 			if (res != FR_OK) break;
    00E20 2300      TST	R16
    00E21 F009      BEQ	0x0E23
    00E22 C011      RJMP	0x0E34
(1546) 			c = *dj->dir;
    00E23 01FA      MOVW	R30,R20
    00E24 89A2      LDD	R26,Z+18
    00E25 89B3      LDD	R27,Z+19
    00E26 916C      LD	R22,X
(1547) 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    00E27 3E65      CPI	R22,0xE5
    00E28 F011      BEQ	0x0E2B
    00E29 2366      TST	R22
    00E2A F409      BNE	0x0E2C
    00E2B C008      RJMP	0x0E34
(1548) 			res = dir_next(dj, 1);			/* Next entry with table stretch */
    00E2C E021      LDI	R18,1
    00E2D E030      LDI	R19,0
    00E2E 018A      MOVW	R16,R20
    00E2F DD9A      RCALL	ff.c:dir_next
    00E30 2EC0      MOV	R12,R16
    00E31 2CAC      MOV	R10,R12
(1549) 		} while (res == FR_OK);
    00E32 20AA      TST	R10
    00E33 F2F9      BEQ	0x0E13
(1550) 	}
(1551) #endif
(1552) 
(1553) 	if (res == FR_OK) {		/* Initialize the SFN entry */
    00E34 20AA      TST	R10
    00E35 F009      BEQ	0x0E37
    00E36 C030      RJMP	0x0E67
(1554) 		res = move_window(dj->fs, dj->sect);
    00E37 01FA      MOVW	R30,R20
    00E38 8426      LDD	R2,Z+14
    00E39 8437      LDD	R3,Z+15
    00E3A 8840      LDD	R4,Z+16
    00E3B 8851      LDD	R5,Z+17
    00E3C 8248      ST	Y,R4
    00E3D 8259      STD	Y+1,R5
    00E3E 0191      MOVW	R18,R2
    00E3F 8100      LD	R16,Z
    00E40 8111      LDD	R17,Z+1
    00E41 940E 0344 CALL	ff.c:move_window
    00E43 2EC0      MOV	R12,R16
    00E44 2CAC      MOV	R10,R12
(1555) 		if (res == FR_OK) {
    00E45 2300      TST	R16
    00E46 F501      BNE	0x0E67
(1556) 			dir = dj->dir;
    00E47 01FA      MOVW	R30,R20
    00E48 88C2      LDD	R12,Z+18
    00E49 88D3      LDD	R13,Z+19
(1557) 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    00E4A E280      LDI	R24,0x20
    00E4B E090      LDI	R25,0
    00E4C 8399      STD	Y+1,R25
    00E4D 8388      ST	Y,R24
    00E4E 2722      CLR	R18
    00E4F 2733      CLR	R19
    00E50 0186      MOVW	R16,R12
    00E51 940E 0301 CALL	ff.c:mem_set
(1558) 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    00E53 E08B      LDI	R24,0xB
    00E54 E090      LDI	R25,0
    00E55 8399      STD	Y+1,R25
    00E56 8388      ST	Y,R24
    00E57 01FA      MOVW	R30,R20
    00E58 8924      LDD	R18,Z+20
    00E59 8935      LDD	R19,Z+21
    00E5A 0186      MOVW	R16,R12
    00E5B 940E 02EB CALL	ff.c:mem_cpy
(1559) #if _USE_LFN
(1560) 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
(1561) #endif
(1562) 			dj->fs->wflag = 1;
    00E5D E081      LDI	R24,1
    00E5E 01FA      MOVW	R30,R20
    00E5F 93AF      PUSH	R26
    00E60 93BF      PUSH	R27
    00E61 81A0      LD	R26,Z
    00E62 81B1      LDD	R27,Z+1
    00E63 01FD      MOVW	R30,R26
    00E64 91BF      POP	R27
    00E65 91AF      POP	R26
    00E66 8384      STD	Z+4,R24
(1563) 		}
(1564) 	}
(1565) 
(1566) 	return res;
    00E67 2D0A      MOV	R16,R10
    00E68 9622      ADIW	R28,2
    00E69 940C 40EB JMP	pop_xgsetF03C
ff.c:create_name:
  si                   --> R22
  b                    --> Y,+8
  sfn                  --> Y,+6
  ni                   --> R12
  d                    --> R10
  i                    --> Y,+4
  p                    --> Y,+2
  c                    --> R20
  path                 --> Y,+19
  dj                   --> R20
    00E6B 933A      ST	-Y,R19
    00E6C 932A      ST	-Y,R18
    00E6D 940E 40A7 CALL	push_xgsetF0FC
    00E6F 01A8      MOVW	R20,R16
    00E70 9729      SBIW	R28,0x9
(1567) }
(1568) #endif /* !_FS_READONLY */
(1569) 
(1570) 
(1571) 
(1572) 
(1573) /*-----------------------------------------------------------------------*/
(1574) /* Remove an object from the directory                                   */
(1575) /*-----------------------------------------------------------------------*/
(1576) #if !_FS_READONLY && !_FS_MINIMIZE
(1577) static
(1578) FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
(1579) 	DIR *dj				/* Directory object pointing the entry to be removed */
(1580) )
(1581) {
(1582) 	FRESULT res;
(1583) #if _USE_LFN	/* LFN configuration */
(1584) 	WORD i;
(1585) 
(1586) 	i = dj->index;	/* SFN index */
(1587) 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
(1588) 	if (res == FR_OK) {
(1589) 		do {
(1590) 			res = move_window(dj->fs, dj->sect);
(1591) 			if (res != FR_OK) break;
(1592) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1593) 			dj->fs->wflag = 1;
(1594) 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
(1595) 			res = dir_next(dj, 0);		/* Next entry */
(1596) 		} while (res == FR_OK);
(1597) 		if (res == FR_NO_FILE) res = FR_INT_ERR;
(1598) 	}
(1599) 
(1600) #else			/* Non LFN configuration */
(1601) 	res = dir_sdi(dj, dj->index);
(1602) 	if (res == FR_OK) {
(1603) 		res = move_window(dj->fs, dj->sect);
(1604) 		if (res == FR_OK) {
(1605) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1606) 			dj->fs->wflag = 1;
(1607) 		}
(1608) 	}
(1609) #endif
(1610) 
(1611) 	return res;
(1612) }
(1613) #endif /* !_FS_READONLY */
(1614) 
(1615) 
(1616) 
(1617) 
(1618) /*-----------------------------------------------------------------------*/
(1619) /* Pick a segment and create the object name in directory form           */
(1620) /*-----------------------------------------------------------------------*/
(1621) 
(1622) static
(1623) FRESULT create_name (
(1624) 	DIR *dj,			/* Pointer to the directory object */
(1625) 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
(1626) )
(1627) {
(1628) #ifdef _EXCVT
(1629) 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
(1630) #endif
(1631) 
(1632) #if _USE_LFN	/* LFN configuration */
(1633) 	BYTE b, cf;
(1634) 	WCHAR w, *lfn;
(1635) 	UINT i, ni, si, di;
(1636) 	const TCHAR *p;
(1637) 
(1638) 	/* Create LFN in Unicode */
(1639) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
(1640) 	lfn = dj->lfn;
(1641) 	si = di = 0;
(1642) 	for (;;) {
(1643) 		w = p[si++];					/* Get a character */
(1644) 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
(1645) 		if (di >= _MAX_LFN)				/* Reject too long name */
(1646) 			return FR_INVALID_NAME;
(1647) #if !_LFN_UNICODE
(1648) 		w &= 0xFF;
(1649) 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
(1650) 			b = (BYTE)p[si++];			/* Get 2nd byte */
(1651) 			if (!IsDBCS2(b))
(1652) 				return FR_INVALID_NAME;	/* Reject invalid sequence */
(1653) 			w = (w << 8) + b;			/* Create a DBC */
(1654) 		}
(1655) 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
(1656) 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
(1657) #endif
(1658) 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
(1659) 			return FR_INVALID_NAME;
(1660) 		lfn[di++] = w;					/* Store the Unicode char */
(1661) 	}
(1662) 	*path = &p[si];						/* Return pointer to the next segment */
(1663) 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
(1664) #if _FS_RPATH
(1665) 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
(1666) 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
(1667) 		lfn[di] = 0;
(1668) 		for (i = 0; i < 11; i++)
(1669) 			dj->fn[i] = (i < di) ? '.' : ' ';
(1670) 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
(1671) 		return FR_OK;
(1672) 	}
(1673) #endif
(1674) 	while (di) {						/* Strip trailing spaces and dots */
(1675) 		w = lfn[di-1];
(1676) 		if (w != ' ' && w != '.') break;
(1677) 		di--;
(1678) 	}
(1679) 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
(1680) 
(1681) 	lfn[di] = 0;						/* LFN is created */
(1682) 
(1683) 	/* Create SFN in directory form */
(1684) 	mem_set(dj->fn, ' ', 11);
(1685) 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
(1686) 	if (si) cf |= NS_LOSS | NS_LFN;
(1687) 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
(1688) 
(1689) 	b = i = 0; ni = 8;
(1690) 	for (;;) {
(1691) 		w = lfn[si++];					/* Get an LFN char */
(1692) 		if (!w) break;					/* Break on end of the LFN */
(1693) 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
(1694) 			cf |= NS_LOSS | NS_LFN; continue;
(1695) 		}
(1696) 
(1697) 		if (i >= ni || si == di) {		/* Extension or end of SFN */
(1698) 			if (ni == 11) {				/* Long extension */
(1699) 				cf |= NS_LOSS | NS_LFN; break;
(1700) 			}
(1701) 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
(1702) 			if (si > di) break;			/* No extension */
(1703) 			si = di; i = 8; ni = 11;	/* Enter extension section */
(1704) 			b <<= 2; continue;
(1705) 		}
(1706) 
(1707) 		if (w >= 0x80) {				/* Non ASCII char */
(1708) #ifdef _EXCVT
(1709) 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
(1710) 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
(1711) #else
(1712) 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
(1713) #endif
(1714) 			cf |= NS_LFN;				/* Force create LFN entry */
(1715) 		}
(1716) 
(1717) 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
(1718) 			if (i >= ni - 1) {
(1719) 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
(1720) 			}
(1721) 			dj->fn[i++] = (BYTE)(w >> 8);
(1722) 		} else {						/* Single byte char */
(1723) 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
(1724) 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
(1725) 			} else {
(1726) 				if (IsUpper(w)) {		/* ASCII large capital */
(1727) 					b |= 2;
(1728) 				} else {
(1729) 					if (IsLower(w)) {	/* ASCII small capital */
(1730) 						b |= 1; w -= 0x20;
(1731) 					}
(1732) 				}
(1733) 			}
(1734) 		}
(1735) 		dj->fn[i++] = (BYTE)w;
(1736) 	}
(1737) 
(1738) 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
(1739) 
(1740) 	if (ni == 8) b <<= 2;
(1741) 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
(1742) 		cf |= NS_LFN;
(1743) 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
(1744) 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
(1745) 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
(1746) 	}
(1747) 
(1748) 	dj->fn[NS] = cf;	/* SFN is created */
(1749) 
(1750) 	return FR_OK;
(1751) 
(1752) 
(1753) #else	/* Non-LFN configuration */
(1754) 	BYTE b, c, d, *sfn;
(1755) 	UINT ni, si, i;
(1756) 	const char *p;
(1757) 
(1758) 	/* Create file name in directory form */
(1759) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    00E71 89EB      LDD	R30,Y+19
    00E72 89FC      LDD	R31,Y+20
    00E73 8020      LD	R2,Z
    00E74 8031      LDD	R3,Z+1
    00E75 823B      STD	Y+3,R3
    00E76 822A      STD	Y+2,R2
    00E77 C005      RJMP	0x0E7D
    00E78 818A      LDD	R24,Y+2
    00E79 819B      LDD	R25,Y+3
    00E7A 9601      ADIW	R24,1
    00E7B 839B      STD	Y+3,R25
    00E7C 838A      STD	Y+2,R24
    00E7D 81EA      LDD	R30,Y+2
    00E7E 81FB      LDD	R31,Y+3
    00E7F 8020      LD	R2,Z
    00E80 2433      CLR	R3
    00E81 2D82      MOV	R24,R2
    00E82 328F      CPI	R24,0x2F
    00E83 F3A1      BEQ	0x0E78
    00E84 358C      CPI	R24,0x5C
    00E85 F391      BEQ	0x0E78
(1760) 	sfn = dj->fn;
    00E86 01FA      MOVW	R30,R20
    00E87 8824      LDD	R2,Z+20
    00E88 8835      LDD	R3,Z+21
    00E89 823F      STD	Y+7,R3
    00E8A 822E      STD	Y+6,R2
(1761) 	mem_set(sfn, ' ', 11);
    00E8B E08B      LDI	R24,0xB
    00E8C E090      LDI	R25,0
    00E8D 8399      STD	Y+1,R25
    00E8E 8388      ST	Y,R24
    00E8F E220      LDI	R18,0x20
    00E90 E030      LDI	R19,0
    00E91 0181      MOVW	R16,R2
    00E92 940E 0301 CALL	ff.c:mem_set
(1762) 	si = i = b = 0; ni = 8;
    00E94 2400      CLR	R0
    00E95 8608      STD	Y+8,R0
    00E96 2422      CLR	R2
    00E97 2433      CLR	R3
    00E98 823D      STD	Y+5,R3
    00E99 822C      STD	Y+4,R2
    00E9A 01B1      MOVW	R22,R2
    00E9B E088      LDI	R24,0x8
    00E9C E090      LDI	R25,0
    00E9D 016C      MOVW	R12,R24
(1763) #if _FS_RPATH
(1764) 	if (p[si] == '.') { /* Is this a dot entry? */
(1765) 		for (;;) {
(1766) 			c = (BYTE)p[si++];
(1767) 			if (c != '.' || si >= 3) break;
(1768) 			sfn[i++] = c;
(1769) 		}
(1770) 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
(1771) 		*path = &p[si];									/* Return pointer to the next segment */
(1772) 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
(1773) 		return FR_OK;
(1774) 	}
(1775) #endif
(1776) 	for (;;) {
(1777) 		c = (BYTE)p[si++];
    00E9E 01AB      MOVW	R20,R22
    00E9F 5F6F      SUBI	R22,0xFF
    00EA0 4F7F      SBCI	R23,0xFF
    00EA1 01FA      MOVW	R30,R20
    00EA2 800A      LDD	R0,Y+2
    00EA3 801B      LDD	R1,Y+3
    00EA4 0DE0      ADD	R30,R0
    00EA5 1DF1      ADC	R31,R1
    00EA6 8140      LD	R20,Z
(1778) 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    00EA7 E280      LDI	R24,0x20
    00EA8 1784      CP	R24,R20
    00EA9 F420      BCC	0x0EAE
    00EAA 324F      CPI	R20,0x2F
    00EAB F011      BEQ	0x0EAE
    00EAC 354C      CPI	R20,0x5C
    00EAD F409      BNE	0x0EAF
    00EAE C087      RJMP	0x0F36
(1779) 		if (c == '.' || i >= ni) {
    00EAF 324E      CPI	R20,0x2E
    00EB0 F029      BEQ	0x0EB6
    00EB1 800C      LDD	R0,Y+4
    00EB2 801D      LDD	R1,Y+5
    00EB3 140C      CP	R0,R12
    00EB4 041D      CPC	R1,R13
    00EB5 F0A0      BCS	0x0ECA
(1780) 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    00EB6 01C6      MOVW	R24,R12
    00EB7 3088      CPI	R24,0x8
    00EB8 E0E0      LDI	R30,0
    00EB9 079E      CPC	R25,R30
    00EBA F411      BNE	0x0EBD
    00EBB 324E      CPI	R20,0x2E
    00EBC F011      BEQ	0x0EBF
    00EBD E006      LDI	R16,6
    00EBE C0AF      RJMP	0x0F6E
(1781) 			i = 8; ni = 11;
    00EBF E088      LDI	R24,0x8
    00EC0 E090      LDI	R25,0
    00EC1 839D      STD	Y+5,R25
    00EC2 838C      STD	Y+4,R24
    00EC3 E08B      LDI	R24,0xB
    00EC4 016C      MOVW	R12,R24
(1782) 			b <<= 2; continue;
    00EC5 8408      LDD	R0,Y+8
    00EC6 0C00      LSL	R0
    00EC7 0C00      LSL	R0
    00EC8 8608      STD	Y+8,R0
    00EC9 CFD4      RJMP	0x0E9E
(1783) 		}
(1784) 		if (c >= 0x80) {				/* Extended char? */
    00ECA 3840      CPI	R20,0x80
    00ECB F018      BCS	0x0ECF
(1785) 			b |= 3;						/* Eliminate NT flag */
    00ECC 8588      LDD	R24,Y+8
    00ECD 6083      ORI	R24,3
    00ECE 8788      STD	Y+8,R24
(1786) #ifdef _EXCVT
(1787) 			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
(1788) #else
(1789) #if !_DF1S	/* ASCII only cfg */
(1790) 			return FR_INVALID_NAME;
(1791) #endif
(1792) #endif
(1793) 		}
(1794) 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    00ECF 3841      CPI	R20,0x81
    00ED0 F408      BCC	0x0ED2
    00ED1 C039      RJMP	0x0F0B
    00ED2 EF8E      LDI	R24,0xFE
    00ED3 1784      CP	R24,R20
    00ED4 F408      BCC	0x0ED6
    00ED5 C035      RJMP	0x0F0B
(1795) 			d = (BYTE)p[si++];			/* Get 2nd byte */
    00ED6 015B      MOVW	R10,R22
    00ED7 5F6F      SUBI	R22,0xFF
    00ED8 4F7F      SBCI	R23,0xFF
    00ED9 01F5      MOVW	R30,R10
    00EDA 800A      LDD	R0,Y+2
    00EDB 801B      LDD	R1,Y+3
    00EDC 0DE0      ADD	R30,R0
    00EDD 1DF1      ADC	R31,R1
    00EDE 80A0      LD	R10,Z
(1796) 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    00EDF 2D8A      MOV	R24,R10
    00EE0 3480      CPI	R24,0x40
    00EE1 F018      BCS	0x0EE5
    00EE2 E78E      LDI	R24,0x7E
    00EE3 158A      CP	R24,R10
    00EE4 F430      BCC	0x0EEB
    00EE5 2D8A      MOV	R24,R10
    00EE6 3880      CPI	R24,0x80
    00EE7 F050      BCS	0x0EF2
    00EE8 EF8E      LDI	R24,0xFE
    00EE9 158A      CP	R24,R10
    00EEA F038      BCS	0x0EF2
    00EEB 01C6      MOVW	R24,R12
    00EEC 9701      SBIW	R24,1
    00EED 800C      LDD	R0,Y+4
    00EEE 801D      LDD	R1,Y+5
    00EEF 1608      CP	R0,R24
    00EF0 0619      CPC	R1,R25
    00EF1 F010      BCS	0x0EF4
(1797) 				return FR_INVALID_NAME;
    00EF2 E006      LDI	R16,6
    00EF3 C07A      RJMP	0x0F6E
(1798) 			sfn[i++] = c;
    00EF4 80EC      LDD	R14,Y+4
    00EF5 80FD      LDD	R15,Y+5
    00EF6 01C7      MOVW	R24,R14
    00EF7 9601      ADIW	R24,1
    00EF8 839D      STD	Y+5,R25
    00EF9 838C      STD	Y+4,R24
    00EFA 01F7      MOVW	R30,R14
    00EFB 800E      LDD	R0,Y+6
    00EFC 801F      LDD	R1,Y+7
    00EFD 0DE0      ADD	R30,R0
    00EFE 1DF1      ADC	R31,R1
    00EFF 8340      ST	Z,R20
(1799) 			sfn[i++] = d;
    00F00 017C      MOVW	R14,R24
    00F01 9601      ADIW	R24,1
    00F02 839D      STD	Y+5,R25
    00F03 838C      STD	Y+4,R24
    00F04 01F7      MOVW	R30,R14
    00F05 800E      LDD	R0,Y+6
    00F06 801F      LDD	R1,Y+7
    00F07 0DE0      ADD	R30,R0
    00F08 1DF1      ADC	R31,R1
    00F09 82A0      ST	Z,R10
(1800) 		} else {						/* Single byte code */
    00F0A CF93      RJMP	0x0E9E
(1801) 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    00F0B 2F24      MOV	R18,R20
    00F0C 2733      CLR	R19
    00F0D E000      LDI	R16,0
    00F0E E011      LDI	R17,1
    00F0F 940E 0334 CALL	ff.c:chk_chr
    00F11 0158      MOVW	R10,R16
    00F12 3000      CPI	R16,0
    00F13 0701      CPC	R16,R17
    00F14 F011      BEQ	0x0F17
(1802) 				return FR_INVALID_NAME;
    00F15 E006      LDI	R16,6
    00F16 C057      RJMP	0x0F6E
(1803) 			if (IsUpper(c)) {			/* ASCII large capital? */
    00F17 3441      CPI	R20,0x41
    00F18 F038      BCS	0x0F20
    00F19 E58A      LDI	R24,0x5A
    00F1A 1784      CP	R24,R20
    00F1B F020      BCS	0x0F20
(1804) 				b |= 2;
    00F1C 8588      LDD	R24,Y+8
    00F1D 6082      ORI	R24,2
    00F1E 8788      STD	Y+8,R24
(1805) 			} else {
    00F1F C009      RJMP	0x0F29
(1806) 				if (IsLower(c)) {		/* ASCII small capital? */
    00F20 3641      CPI	R20,0x61
    00F21 F038      BCS	0x0F29
    00F22 E78A      LDI	R24,0x7A
    00F23 1784      CP	R24,R20
    00F24 F020      BCS	0x0F29
(1807) 					b |= 1; c -= 0x20;
    00F25 8588      LDD	R24,Y+8
    00F26 6081      ORI	R24,1
    00F27 8788      STD	Y+8,R24
    00F28 5240      SUBI	R20,0x20
(1808) 				}
(1809) 			}
(1810) 			sfn[i++] = c;
    00F29 80AC      LDD	R10,Y+4
    00F2A 80BD      LDD	R11,Y+5
    00F2B 01C5      MOVW	R24,R10
    00F2C 9601      ADIW	R24,1
    00F2D 839D      STD	Y+5,R25
    00F2E 838C      STD	Y+4,R24
    00F2F 01F5      MOVW	R30,R10
    00F30 800E      LDD	R0,Y+6
    00F31 801F      LDD	R1,Y+7
    00F32 0DE0      ADD	R30,R0
    00F33 1DF1      ADC	R31,R1
    00F34 8340      ST	Z,R20
    00F35 CF68      RJMP	0x0E9E
(1811) 		}
(1812) 	}
(1813) 	*path = &p[si];						/* Return pointer to the next segment */
    00F36 011B      MOVW	R2,R22
    00F37 800A      LDD	R0,Y+2
    00F38 801B      LDD	R1,Y+3
    00F39 0C20      ADD	R2,R0
    00F3A 1C31      ADC	R3,R1
    00F3B 89EB      LDD	R30,Y+19
    00F3C 89FC      LDD	R31,Y+20
    00F3D 8231      STD	Z+1,R3
    00F3E 8220      ST	Z,R2
(1814) 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    00F3F E280      LDI	R24,0x20
    00F40 1784      CP	R24,R20
    00F41 F018      BCS	0x0F45
    00F42 E064      LDI	R22,4
    00F43 E070      LDI	R23,0
    00F44 C002      RJMP	0x0F47
    00F45 2766      CLR	R22
    00F46 2777      CLR	R23
    00F47 2F46      MOV	R20,R22
(1815) 
(1816) 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    00F48 800C      LDD	R0,Y+4
    00F49 801D      LDD	R1,Y+5
    00F4A 2000      TST	R0
    00F4B F421      BNE	0x0F50
    00F4C 2011      TST	R1
    00F4D F411      BNE	0x0F50
    00F4E E006      LDI	R16,6
    00F4F C01E      RJMP	0x0F6E
(1817) 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    00F50 81EE      LDD	R30,Y+6
    00F51 81FF      LDD	R31,Y+7
    00F52 8180      LD	R24,Z
    00F53 3E85      CPI	R24,0xE5
    00F54 F411      BNE	0x0F57
    00F55 E085      LDI	R24,5
    00F56 8380      ST	Z,R24
(1818) 
(1819) 	if (ni == 8) b <<= 2;
    00F57 01C6      MOVW	R24,R12
    00F58 3088      CPI	R24,0x8
    00F59 E0E0      LDI	R30,0
    00F5A 079E      CPC	R25,R30
    00F5B F421      BNE	0x0F60
    00F5C 8408      LDD	R0,Y+8
    00F5D 0C00      LSL	R0
    00F5E 0C00      LSL	R0
    00F5F 8608      STD	Y+8,R0
(1820) 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    00F60 8588      LDD	R24,Y+8
    00F61 7083      ANDI	R24,3
    00F62 3081      CPI	R24,1
    00F63 F409      BNE	0x0F65
    00F64 6140      ORI	R20,0x10
(1821) 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    00F65 8588      LDD	R24,Y+8
    00F66 708C      ANDI	R24,0xC
    00F67 3084      CPI	R24,4
    00F68 F409      BNE	0x0F6A
    00F69 6048      ORI	R20,0x8
(1822) 
(1823) 	sfn[NS] = c;		/* Store NT flag, File name is created */
    00F6A 81EE      LDD	R30,Y+6
    00F6B 81FF      LDD	R31,Y+7
    00F6C 8743      STD	Z+11,R20
(1824) 
(1825) 	return FR_OK;
    00F6D 2700      CLR	R16
    00F6E 9629      ADIW	R28,0x9
    00F6F 940E 409C CALL	pop_xgsetF0FC
    00F71 9622      ADIW	R28,2
    00F72 9508      RET
ff.c:get_fileinfo:
  nt                   --> R12
  p                    --> R20
  dir                  --> R10
  i                    --> R12
  c                    --> R14
  fno                  --> R22
  dj                   --> R10
    00F73 940E 40A7 CALL	push_xgsetF0FC
    00F75 01B9      MOVW	R22,R18
    00F76 0158      MOVW	R10,R16
(1826) #endif
(1827) }
(1828) 
(1829) 
(1830) 
(1831) 
(1832) /*-----------------------------------------------------------------------*/
(1833) /* Get file information from directory entry                             */
(1834) /*-----------------------------------------------------------------------*/
(1835) #if _FS_MINIMIZE <= 1
(1836) static
(1837) void get_fileinfo (		/* No return code */
(1838) 	DIR *dj,			/* Pointer to the directory object */
(1839) 	FILINFO *fno	 	/* Pointer to the file information to be filled */
(1840) )
(1841) {
(1842) 	UINT i;
(1843) 	BYTE nt, *dir;
(1844) 	TCHAR *p, c;
(1845) 
(1846) 
(1847) 	p = fno->fname;
    00F77 01AB      MOVW	R20,R22
    00F78 5F47      SUBI	R20,0xF7
    00F79 4F5F      SBCI	R21,0xFF
(1848) 	if (dj->sect) {
    00F7A 01F5      MOVW	R30,R10
    00F7B 963E      ADIW	R30,0xE
    00F7C 8020      LD	R2,Z
    00F7D 8031      LDD	R3,Z+1
    00F7E 8042      LDD	R4,Z+2
    00F7F 8053      LDD	R5,Z+3
    00F80 9488      BCLR	0
    00F81 2022      TST	R2
    00F82 0432      CPC	R3,R2
    00F83 0442      CPC	R4,R2
    00F84 0452      CPC	R5,R2
    00F85 F409      BNE	0x0F87
    00F86 C08A      RJMP	0x1011
(1849) 		dir = dj->dir;
    00F87 01F5      MOVW	R30,R10
    00F88 88A2      LDD	R10,Z+18
    00F89 88B3      LDD	R11,Z+19
(1850) 		nt = dir[DIR_NTres];		/* NT flag */
(1851) 		for (i = 0; i < 8; i++) {	/* Copy name body */
    00F8A 24CC      CLR	R12
    00F8B 24DD      CLR	R13
    00F8C C014      RJMP	0x0FA1
(1852) 			c = dir[i];
    00F8D 01F6      MOVW	R30,R12
    00F8E 0DEA      ADD	R30,R10
    00F8F 1DFB      ADC	R31,R11
    00F90 80E0      LD	R14,Z
(1853) 			if (c == ' ') break;
    00F91 2D8E      MOV	R24,R14
    00F92 3280      CPI	R24,0x20
    00F93 F409      BNE	0x0F95
    00F94 C011      RJMP	0x0FA6
(1854) 			if (c == NDDE) c = (TCHAR)DDE;
    00F95 2D8E      MOV	R24,R14
    00F96 3085      CPI	R24,5
    00F97 F411      BNE	0x0F9A
    00F98 EE85      LDI	R24,0xE5
    00F99 2EE8      MOV	R14,R24
(1855) 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
    00F9A C000      RJMP	0x0F9B
(1856) #if _LFN_UNICODE
(1857) 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
(1858) 				c = (c << 8) | dir[++i];
(1859) 			c = ff_convert(c, 1);
(1860) 			if (!c) c = '?';
(1861) #endif
(1862) 			*p++ = c;
    00F9B 01FA      MOVW	R30,R20
    00F9C 92E1      ST	Z+,R14
    00F9D 01AF      MOVW	R20,R30
    00F9E 01C6      MOVW	R24,R12
    00F9F 9601      ADIW	R24,1
    00FA0 016C      MOVW	R12,R24
    00FA1 01C6      MOVW	R24,R12
    00FA2 3088      CPI	R24,0x8
    00FA3 E0E0      LDI	R30,0
    00FA4 079E      CPC	R25,R30
    00FA5 F338      BCS	0x0F8D
(1863) 		}
(1864) 		if (dir[8] != ' ') {		/* Copy name extension */
    00FA6 01F5      MOVW	R30,R10
    00FA7 8580      LDD	R24,Z+8
    00FA8 3280      CPI	R24,0x20
    00FA9 F0E1      BEQ	0x0FC6
(1865) 			*p++ = '.';
    00FAA E28E      LDI	R24,0x2E
    00FAB 01FA      MOVW	R30,R20
    00FAC 9381      ST	Z+,R24
    00FAD 01AF      MOVW	R20,R30
(1866) 			for (i = 8; i < 11; i++) {
    00FAE E088      LDI	R24,0x8
    00FAF E090      LDI	R25,0
    00FB0 016C      MOVW	R12,R24
    00FB1 C00F      RJMP	0x0FC1
(1867) 				c = dir[i];
    00FB2 01F6      MOVW	R30,R12
    00FB3 0DEA      ADD	R30,R10
    00FB4 1DFB      ADC	R31,R11
    00FB5 80E0      LD	R14,Z
(1868) 				if (c == ' ') break;
    00FB6 2D8E      MOV	R24,R14
    00FB7 3280      CPI	R24,0x20
    00FB8 F409      BNE	0x0FBA
    00FB9 C00C      RJMP	0x0FC6
(1869) 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
    00FBA C000      RJMP	0x0FBB
(1870) #if _LFN_UNICODE
(1871) 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
(1872) 					c = (c << 8) | dir[++i];
(1873) 				c = ff_convert(c, 1);
(1874) 				if (!c) c = '?';
(1875) #endif
(1876) 				*p++ = c;
    00FBB 01FA      MOVW	R30,R20
    00FBC 92E1      ST	Z+,R14
    00FBD 01AF      MOVW	R20,R30
    00FBE 01C6      MOVW	R24,R12
    00FBF 9601      ADIW	R24,1
    00FC0 016C      MOVW	R12,R24
    00FC1 01C6      MOVW	R24,R12
    00FC2 308B      CPI	R24,0xB
    00FC3 E0E0      LDI	R30,0
    00FC4 079E      CPC	R25,R30
    00FC5 F360      BCS	0x0FB2
(1877) 			}
(1878) 		}
(1879) 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    00FC6 01F5      MOVW	R30,R10
    00FC7 8423      LDD	R2,Z+11
    00FC8 01FB      MOVW	R30,R22
    00FC9 8620      STD	Z+8,R2
(1880) 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    00FCA E188      LDI	R24,0x18
    00FCB E090      LDI	R25,0
    00FCC 01F5      MOVW	R30,R10
    00FCD 8D07      LDD	R16,Z+31
    00FCE 2711      CLR	R17
    00FCF 2722      CLR	R18
    00FD0 2733      CLR	R19
    00FD1 938A      ST	-Y,R24
    00FD2 940E 4129 CALL	lsl32
    00FD4 0118      MOVW	R2,R16
    00FD5 0129      MOVW	R4,R18
    00FD6 01F5      MOVW	R30,R10
    00FD7 8C66      LDD	R6,Z+30
    00FD8 2477      CLR	R7
    00FD9 2488      CLR	R8
    00FDA 2499      CLR	R9
    00FDB 0143      MOVW	R8,R6
    00FDC 2466      CLR	R6
    00FDD 2477      CLR	R7
    00FDE 2826      OR	R2,R6
    00FDF 2837      OR	R3,R7
    00FE0 2848      OR	R4,R8
    00FE1 2859      OR	R5,R9
    00FE2 8C65      LDD	R6,Z+29
    00FE3 2477      CLR	R7
    00FE4 2C76      MOV	R7,R6
    00FE5 2466      CLR	R6
    00FE6 2488      CLR	R8
    00FE7 2499      CLR	R9
    00FE8 2826      OR	R2,R6
    00FE9 2837      OR	R3,R7
    00FEA 2848      OR	R4,R8
    00FEB 2859      OR	R5,R9
    00FEC 8C64      LDD	R6,Z+28
    00FED 2477      CLR	R7
    00FEE 2488      CLR	R8
    00FEF 2499      CLR	R9
    00FF0 2826      OR	R2,R6
    00FF1 2837      OR	R3,R7
    00FF2 2848      OR	R4,R8
    00FF3 2859      OR	R5,R9
    00FF4 01FB      MOVW	R30,R22
    00FF5 8220      ST	Z,R2
    00FF6 8231      STD	Z+1,R3
    00FF7 8242      STD	Z+2,R4
    00FF8 8253      STD	Z+3,R5
(1881) 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    00FF9 01F5      MOVW	R30,R10
    00FFA 8C20      LDD	R2,Z+24
    00FFB 2433      CLR	R3
    00FFC 8C41      LDD	R4,Z+25
    00FFD 2455      CLR	R5
    00FFE 2C54      MOV	R5,R4
    00FFF 2444      CLR	R4
    01000 2842      OR	R4,R2
    01001 2853      OR	R5,R3
    01002 01FB      MOVW	R30,R22
    01003 8255      STD	Z+5,R5
    01004 8244      STD	Z+4,R4
(1882) 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    01005 01F5      MOVW	R30,R10
    01006 8826      LDD	R2,Z+22
    01007 2433      CLR	R3
    01008 8847      LDD	R4,Z+23
    01009 2455      CLR	R5
    0100A 2C54      MOV	R5,R4
    0100B 2444      CLR	R4
    0100C 2842      OR	R4,R2
    0100D 2853      OR	R5,R3
    0100E 01FB      MOVW	R30,R22
    0100F 8257      STD	Z+7,R5
    01010 8246      STD	Z+6,R4
(1883) 	}
(1884) 	*p = 0;		/* Terminate SFN str by a \0 */
    01011 2422      CLR	R2
    01012 01FA      MOVW	R30,R20
    01013 8220      ST	Z,R2
    01014 940C 409C JMP	pop_xgsetF0FC
ff.c:follow_path:
  ns                   --> R10
  res                  --> R20
  dir                  --> R10
  path                 --> Y,+6
  dj                   --> R22
    01016 933A      ST	-Y,R19
    01017 932A      ST	-Y,R18
    01018 940E 40C6 CALL	push_xgsetF00C
    0101A 01B8      MOVW	R22,R16
(1885) 
(1886) #if _USE_LFN
(1887) 	if (fno->lfname && fno->lfsize) {
(1888) 		TCHAR *tp = fno->lfname;
(1889) 		WCHAR w, *lfn;
(1890) 
(1891) 		i = 0;
(1892) 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
(1893) 			lfn = dj->lfn;
(1894) 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
(1895) #if !_LFN_UNICODE
(1896) 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
(1897) 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
(1898) 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
(1899) 					tp[i++] = (TCHAR)(w >> 8);
(1900) #endif
(1901) 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
(1902) 				tp[i++] = (TCHAR)w;
(1903) 			}
(1904) 		}
(1905) 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
(1906) 	}
(1907) #endif
(1908) }
(1909) #endif /* _FS_MINIMIZE <= 1 */
(1910) 
(1911) 
(1912) 
(1913) 
(1914) /*-----------------------------------------------------------------------*/
(1915) /* Follow a file path                                                    */
(1916) /*-----------------------------------------------------------------------*/
(1917) 
(1918) static
(1919) FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
(1920) 	DIR *dj,			/* Directory object to return last directory and found object */
(1921) 	const TCHAR *path	/* Full-path string to find a file or directory */
(1922) )
(1923) {
(1924) 	FRESULT res;
(1925) 	BYTE *dir, ns;
(1926) 
(1927) 
(1928) #if _FS_RPATH
(1929) 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
(1930) 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
(1931) 	} else {							/* No heading separator */
(1932) 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
(1933) 	}
(1934) #else
(1935) 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    0101B 81EE      LDD	R30,Y+6
    0101C 81FF      LDD	R31,Y+7
    0101D 8020      LD	R2,Z
    0101E 2433      CLR	R3
    0101F 2D82      MOV	R24,R2
    01020 328F      CPI	R24,0x2F
    01021 F011      BEQ	0x1024
    01022 358C      CPI	R24,0x5C
    01023 F429      BNE	0x1029
(1936) 		path++;
    01024 818E      LDD	R24,Y+6
    01025 819F      LDD	R25,Y+7
    01026 9601      ADIW	R24,1
    01027 839F      STD	Y+7,R25
    01028 838E      STD	Y+6,R24
(1937) 	dj->sclust = 0;						/* Start from the root dir */
    01029 01FB      MOVW	R30,R22
    0102A 9636      ADIW	R30,6
    0102B E080      LDI	R24,0
    0102C 8380      ST	Z,R24
    0102D 8381      STD	Z+1,R24
    0102E 8382      STD	Z+2,R24
    0102F 8383      STD	Z+3,R24
(1938) #endif
(1939) 
(1940) 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    01030 81EE      LDD	R30,Y+6
    01031 81FF      LDD	R31,Y+7
    01032 8180      LD	R24,Z
    01033 2799      CLR	R25
    01034 3280      CPI	R24,0x20
    01035 E0E0      LDI	R30,0
    01036 079E      CPC	R25,R30
    01037 F458      BCC	0x1043
(1941) 		res = dir_sdi(dj, 0);
    01038 2722      CLR	R18
    01039 2733      CLR	R19
    0103A 018B      MOVW	R16,R22
    0103B DA84      RCALL	ff.c:dir_sdi
    0103C 2F40      MOV	R20,R16
(1942) 		dj->dir = 0;
    0103D 2422      CLR	R2
    0103E 2433      CLR	R3
    0103F 01FB      MOVW	R30,R22
    01040 8A33      STD	Z+19,R3
    01041 8A22      STD	Z+18,R2
(1943) 
(1944) 	} else {							/* Follow path */
    01042 C052      RJMP	0x1095
(1945) 		for (;;) {
(1946) 			res = create_name(dj, &path);	/* Get a segment */
    01043 019E      MOVW	R18,R28
    01044 5F2A      SUBI	R18,0xFA
    01045 4F3F      SBCI	R19,0xFF
    01046 018B      MOVW	R16,R22
    01047 DE23      RCALL	ff.c:create_name
    01048 2EA0      MOV	R10,R16
    01049 2D4A      MOV	R20,R10
(1947) 			if (res != FR_OK) break;
    0104A 2300      TST	R16
    0104B F009      BEQ	0x104D
    0104C C048      RJMP	0x1095
(1948) 			res = dir_find(dj);				/* Find it */
    0104D 018B      MOVW	R16,R22
    0104E DD29      RCALL	ff.c:dir_find
    0104F 2EA0      MOV	R10,R16
    01050 2D4A      MOV	R20,R10
(1949) 			ns = *(dj->fn+NS);
    01051 01FB      MOVW	R30,R22
    01052 93AF      PUSH	R26
    01053 93BF      PUSH	R27
    01054 89A4      LDD	R26,Z+20
    01055 89B5      LDD	R27,Z+21
    01056 01FD      MOVW	R30,R26
    01057 91BF      POP	R27
    01058 91AF      POP	R26
    01059 84A3      LDD	R10,Z+11
(1950) 			if (res != FR_OK) {				/* Failed to find the object */
    0105A 2300      TST	R16
    0105B F049      BEQ	0x1065
(1951) 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    0105C 3004      CPI	R16,4
    0105D F009      BEQ	0x105F
    0105E C036      RJMP	0x1095
(1952) 				/* Object not found */
(1953) 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    0105F C001      RJMP	0x1061
(1954) 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
(1955) 					res = FR_OK;
(1956) 					if (!(ns & NS_LAST)) continue;
    01060 CFE2      RJMP	0x1043
(1957) 				} else {							/* Could not find the object */
(1958) 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    01061 FCA2      SBRC	R10,2
    01062 C032      RJMP	0x1095
    01063 E045      LDI	R20,5
(1959) 				}
(1960) 				break;
    01064 C030      RJMP	0x1095
(1961) 			}
(1962) 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    01065 FEA2      SBRS	R10,2
    01066 C001      RJMP	0x1068
    01067 C02D      RJMP	0x1095
(1963) 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    01068 01FB      MOVW	R30,R22
    01069 88A2      LDD	R10,Z+18
    0106A 88B3      LDD	R11,Z+19
(1964) 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    0106B 01F5      MOVW	R30,R10
    0106C 8423      LDD	R2,Z+11
    0106D FC24      SBRC	R2,4
    0106E C002      RJMP	0x1071
(1965) 				res = FR_NO_PATH; break;
    0106F E045      LDI	R20,5
    01070 C024      RJMP	0x1095
(1966) 			}
(1967) 			dj->sclust = LD_CLUST(dir);
    01071 01F5      MOVW	R30,R10
    01072 8C22      LDD	R2,Z+26
    01073 2433      CLR	R3
    01074 8C43      LDD	R4,Z+27
    01075 2455      CLR	R5
    01076 2C54      MOV	R5,R4
    01077 2444      CLR	R4
    01078 2842      OR	R4,R2
    01079 2853      OR	R5,R3
    0107A 0112      MOVW	R2,R4
    0107B 2444      CLR	R4
    0107C 2455      CLR	R5
    0107D 8864      LDD	R6,Z+20
    0107E 2477      CLR	R7
    0107F 8885      LDD	R8,Z+21
    01080 2499      CLR	R9
    01081 2C98      MOV	R9,R8
    01082 2488      CLR	R8
    01083 2886      OR	R8,R6
    01084 2897      OR	R9,R7
    01085 0134      MOVW	R6,R8
    01086 2488      CLR	R8
    01087 2499      CLR	R9
    01088 0143      MOVW	R8,R6
    01089 2466      CLR	R6
    0108A 2477      CLR	R7
    0108B 2862      OR	R6,R2
    0108C 2873      OR	R7,R3
    0108D 2884      OR	R8,R4
    0108E 2895      OR	R9,R5
    0108F 01FB      MOVW	R30,R22
    01090 8266      STD	Z+6,R6
    01091 8277      STD	Z+7,R7
    01092 8680      STD	Z+8,R8
    01093 8691      STD	Z+9,R9
    01094 CFAE      RJMP	0x1043
(1968) 		}
(1969) 	}
(1970) 
(1971) 	return res;
    01095 2F04      MOV	R16,R20
    01096 940E 40CD CALL	pop_xgsetF00C
    01098 9622      ADIW	R28,2
    01099 9508      RET
ff.c:check_fs:
  sect                 --> Y,+11
  fs                   --> R10
    0109A 933A      ST	-Y,R19
    0109B 932A      ST	-Y,R18
    0109C 940E 40C6 CALL	push_xgsetF00C
    0109E 0158      MOVW	R10,R16
    0109F 9725      SBIW	R28,5
(1972) }
(1973) 
(1974) 
(1975) 
(1976) 
(1977) /*-----------------------------------------------------------------------*/
(1978) /* Load a sector and check if it is an FAT Volume Boot Record            */
(1979) /*-----------------------------------------------------------------------*/
(1980) 
(1981) static
(1982) BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
(1983) 	FATFS *fs,	/* File system object */
(1984) 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
(1985) )
(1986) {
(1987) 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    010A0 E081      LDI	R24,1
    010A1 838C      STD	Y+4,R24
    010A2 842B      LDD	R2,Y+11
    010A3 843C      LDD	R3,Y+12
    010A4 844D      LDD	R4,Y+13
    010A5 845E      LDD	R5,Y+14
    010A6 8228      ST	Y,R2
    010A7 8239      STD	Y+1,R3
    010A8 824A      STD	Y+2,R4
    010A9 825B      STD	Y+3,R5
    010AA 0195      MOVW	R18,R10
    010AB 5D22      SUBI	R18,0xD2
    010AC 4F3F      SBCI	R19,0xFF
    010AD 01F5      MOVW	R30,R10
    010AE 8101      LDD	R16,Z+1
    010AF 940E 02A9 CALL	_disk_read
    010B1 2300      TST	R16
    010B2 F011      BEQ	0x10B5
(1988) 		return 3;
    010B3 E003      LDI	R16,3
    010B4 C0A8      RJMP	0x115D
(1989) 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    010B5 01F5      MOVW	R30,R10
    010B6 5DE4      SUBI	R30,0xD4
    010B7 4FFD      SBCI	R31,0xFD
    010B8 8020      LD	R2,Z
    010B9 52EC      SUBI	R30,0x2C
    010BA 40F2      SBCI	R31,2
    010BB 2433      CLR	R3
    010BC 5DE3      SUBI	R30,0xD3
    010BD 4FFD      SBCI	R31,0xFD
    010BE 8180      LD	R24,Z
    010BF 2799      CLR	R25
    010C0 2F98      MOV	R25,R24
    010C1 2788      CLR	R24
    010C2 2982      OR	R24,R2
    010C3 2993      OR	R25,R3
    010C4 3585      CPI	R24,0x55
    010C5 EAEA      LDI	R30,0xAA
    010C6 079E      CPC	R25,R30
    010C7 F011      BEQ	0x10CA
(1990) 		return 2;
    010C8 E002      LDI	R16,2
    010C9 C093      RJMP	0x115D
(1991) 
(1992) 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    010CA E188      LDI	R24,0x18
    010CB E090      LDI	R25,0
    010CC 01F5      MOVW	R30,R10
    010CD 59E9      SUBI	R30,0x99
    010CE 4FFF      SBCI	R31,0xFF
    010CF 8100      LD	R16,Z
    010D0 2711      CLR	R17
    010D1 2722      CLR	R18
    010D2 2733      CLR	R19
    010D3 938A      ST	-Y,R24
    010D4 940E 4129 CALL	lsl32
    010D6 0118      MOVW	R2,R16
    010D7 0129      MOVW	R4,R18
    010D8 01F5      MOVW	R30,R10
    010D9 59EA      SUBI	R30,0x9A
    010DA 4FFF      SBCI	R31,0xFF
    010DB 8060      LD	R6,Z
    010DC 56E6      SUBI	R30,0x66
    010DD 40F0      SBCI	R31,0
    010DE 2477      CLR	R7
    010DF 2488      CLR	R8
    010E0 2499      CLR	R9
    010E1 0143      MOVW	R8,R6
    010E2 2466      CLR	R6
    010E3 2477      CLR	R7
    010E4 2826      OR	R2,R6
    010E5 2837      OR	R3,R7
    010E6 2848      OR	R4,R8
    010E7 2859      OR	R5,R9
    010E8 59EB      SUBI	R30,0x9B
    010E9 4FFF      SBCI	R31,0xFF
    010EA 8060      LD	R6,Z
    010EB 56E5      SUBI	R30,0x65
    010EC 40F0      SBCI	R31,0
    010ED 2477      CLR	R7
    010EE 2C76      MOV	R7,R6
    010EF 2466      CLR	R6
    010F0 2488      CLR	R8
    010F1 2499      CLR	R9
    010F2 2826      OR	R2,R6
    010F3 2837      OR	R3,R7
    010F4 2848      OR	R4,R8
    010F5 2859      OR	R5,R9
    010F6 59EC      SUBI	R30,0x9C
    010F7 4FFF      SBCI	R31,0xFF
    010F8 8060      LD	R6,Z
    010F9 2477      CLR	R7
    010FA 2488      CLR	R8
    010FB 2499      CLR	R9
    010FC 2826      OR	R2,R6
    010FD 2837      OR	R3,R7
    010FE 2848      OR	R4,R8
    010FF 2859      OR	R5,R9
    01100 EF4F      LDI	R20,0xFF
    01101 EF5F      LDI	R21,0xFF
    01102 EF6F      LDI	R22,0xFF
    01103 E070      LDI	R23,0
    01104 2224      AND	R2,R20
    01105 2235      AND	R3,R21
    01106 2246      AND	R4,R22
    01107 2257      AND	R5,R23
    01108 E446      LDI	R20,0x46
    01109 E451      LDI	R21,0x41
    0110A E564      LDI	R22,0x54
    0110B E070      LDI	R23,0
    0110C 1624      CP	R2,R20
    0110D 0635      CPC	R3,R21
    0110E 0646      CPC	R4,R22
    0110F 0657      CPC	R5,R23
    01110 F411      BNE	0x1113
(1993) 		return 0;
    01111 2700      CLR	R16
    01112 C04A      RJMP	0x115D
(1994) 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    01113 E188      LDI	R24,0x18
    01114 E090      LDI	R25,0
    01115 01F5      MOVW	R30,R10
    01116 57ED      SUBI	R30,0x7D
    01117 4FFF      SBCI	R31,0xFF
    01118 8100      LD	R16,Z
    01119 2711      CLR	R17
    0111A 2722      CLR	R18
    0111B 2733      CLR	R19
    0111C 938A      ST	-Y,R24
    0111D 940E 4129 CALL	lsl32
    0111F 0118      MOVW	R2,R16
    01120 0129      MOVW	R4,R18
    01121 01F5      MOVW	R30,R10
    01122 57EE      SUBI	R30,0x7E
    01123 4FFF      SBCI	R31,0xFF
    01124 8060      LD	R6,Z
    01125 58E2      SUBI	R30,0x82
    01126 40F0      SBCI	R31,0
    01127 2477      CLR	R7
    01128 2488      CLR	R8
    01129 2499      CLR	R9
    0112A 0143      MOVW	R8,R6
    0112B 2466      CLR	R6
    0112C 2477      CLR	R7
    0112D 2826      OR	R2,R6
    0112E 2837      OR	R3,R7
    0112F 2848      OR	R4,R8
    01130 2859      OR	R5,R9
    01131 57EF      SUBI	R30,0x7F
    01132 4FFF      SBCI	R31,0xFF
    01133 8060      LD	R6,Z
    01134 58E1      SUBI	R30,0x81
    01135 40F0      SBCI	R31,0
    01136 2477      CLR	R7
    01137 2C76      MOV	R7,R6
    01138 2466      CLR	R6
    01139 2488      CLR	R8
    0113A 2499      CLR	R9
    0113B 2826      OR	R2,R6
    0113C 2837      OR	R3,R7
    0113D 2848      OR	R4,R8
    0113E 2859      OR	R5,R9
    0113F 58E0      SUBI	R30,0x80
    01140 4FFF      SBCI	R31,0xFF
    01141 8060      LD	R6,Z
    01142 2477      CLR	R7
    01143 2488      CLR	R8
    01144 2499      CLR	R9
    01145 2826      OR	R2,R6
    01146 2837      OR	R3,R7
    01147 2848      OR	R4,R8
    01148 2859      OR	R5,R9
    01149 EF4F      LDI	R20,0xFF
    0114A EF5F      LDI	R21,0xFF
    0114B EF6F      LDI	R22,0xFF
    0114C E070      LDI	R23,0
    0114D 2224      AND	R2,R20
    0114E 2235      AND	R3,R21
    0114F 2246      AND	R4,R22
    01150 2257      AND	R5,R23
    01151 E446      LDI	R20,0x46
    01152 E451      LDI	R21,0x41
    01153 E564      LDI	R22,0x54
    01154 E070      LDI	R23,0
    01155 1624      CP	R2,R20
    01156 0635      CPC	R3,R21
    01157 0646      CPC	R4,R22
    01158 0657      CPC	R5,R23
    01159 F411      BNE	0x115C
(1995) 		return 0;
    0115A 2700      CLR	R16
    0115B C001      RJMP	0x115D
(1996) 
(1997) 	return 1;
    0115C E001      LDI	R16,1
    0115D 9625      ADIW	R28,5
    0115E 940E 40CD CALL	pop_xgsetF00C
    01160 9622      ADIW	R28,2
    01161 9508      RET
ff.c:chk_mounted:
  pi                   --> R10
  szbfat               --> Y,+25
  tbl                  --> R10
  p                    --> R10
  nrsv                 --> R14
  sysect               --> Y,+21
  bsect                --> Y,+17
  stat                 --> R10
  tsect                --> Y,+13
  nclst                --> Y,+9
  vol                  --> R14
  fasize               --> Y,+5
  b                    --> R14
  fmt                  --> R12
  fs                   --> Y,+37
  chk_wp               --> Y,+51
  rfs                  --> Y,+49
  path                 --> R12
    01162 933A      ST	-Y,R19
    01163 932A      ST	-Y,R18
    01164 940E 40A7 CALL	push_xgsetF0FC
    01166 0168      MOVW	R12,R16
    01167 97A7      SBIW	R28,0x27
(1998) }
(1999) 
(2000) 
(2001) 
(2002) 
(2003) /*-----------------------------------------------------------------------*/
(2004) /* Check if the file system object is valid or not                       */
(2005) /*-----------------------------------------------------------------------*/
(2006) 
(2007) static
(2008) FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
(2009) 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
(2010) 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
(2011) 	BYTE chk_wp			/* !=0: Check media write protection for write access */
(2012) )
(2013) {
(2014) 	BYTE fmt, b, pi, *tbl;
(2015) 	UINT vol;
(2016) 	DSTATUS stat;
(2017) 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
(2018) 	WORD nrsv;
(2019) 	const TCHAR *p = *path;
    01168 01F6      MOVW	R30,R12
    01169 80A0      LD	R10,Z
    0116A 80B1      LDD	R11,Z+1
(2020) 	FATFS *fs;
(2021) 
(2022) 	/* Get logical drive number from the path name */
(2023) 	vol = p[0] - '0';					/* Is there a drive number? */
    0116B 01F5      MOVW	R30,R10
    0116C 8180      LD	R24,Z
    0116D 2799      CLR	R25
    0116E 97C0      SBIW	R24,0x30
    0116F 017C      MOVW	R14,R24
(2024) 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    01170 E089      LDI	R24,0x9
    01171 E090      LDI	R25,0
    01172 158E      CP	R24,R14
    01173 059F      CPC	R25,R15
    01174 F050      BCS	0x117F
    01175 8181      LDD	R24,Z+1
    01176 338A      CPI	R24,0x3A
    01177 F439      BNE	0x117F
(2025) 		p += 2; *path = p;				/* Return pointer to the path name */
    01178 01CF      MOVW	R24,R30
    01179 9602      ADIW	R24,2
    0117A 015C      MOVW	R10,R24
    0117B 01F6      MOVW	R30,R12
    0117C 82B1      STD	Z+1,R11
    0117D 82A0      ST	Z,R10
(2026) 	} else {							/* No drive number is given */
    0117E C002      RJMP	0x1181
(2027) #if _FS_RPATH
(2028) 		vol = CurrVol;					/* Use current drive */
(2029) #else
(2030) 		vol = 0;						/* Use drive 0 */
    0117F 24EE      CLR	R14
    01180 24FF      CLR	R15
(2031) #endif
(2032) 	}
(2033) 
(2034) 	/* Check if the file system object is valid or not */
(2035) 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    01181 01C7      MOVW	R24,R14
    01182 3081      CPI	R24,1
    01183 E0E0      LDI	R30,0
    01184 079E      CPC	R25,R30
    01185 F010      BCS	0x1188
(2036) 		return FR_INVALID_DRIVE;
    01186 E00B      LDI	R16,0xB
    01187 C4CF      RJMP	0x1657
(2037) 	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    01188 E086      LDI	R24,6
    01189 E095      LDI	R25,5
    0118A 01F7      MOVW	R30,R14
    0118B 0FEE      LSL	R30
    0118C 1FFF      ROL	R31
    0118D 0FE8      ADD	R30,R24
    0118E 1FF9      ADC	R31,R25
    0118F 8020      LD	R2,Z
    01190 8031      LDD	R3,Z+1
    01191 A23E      STD	Y+38,R3
    01192 A22D      STD	Y+37,R2
    01193 A9E9      LDD	R30,Y+49
    01194 A9FA      LDD	R31,Y+50
    01195 8231      STD	Z+1,R3
    01196 8220      ST	Z,R2
(2038) 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    01197 0101      MOVW	R0,R2
    01198 2022      TST	R2
    01199 F421      BNE	0x119E
    0119A 2033      TST	R3
    0119B F411      BNE	0x119E
    0119C E00C      LDI	R16,0xC
    0119D C4B9      RJMP	0x1657
(2039) 
(2040) 	ENTER_FF(fs);						/* Lock file system */
(2041) 
(2042) 	if (fs->fs_type) {					/* If the logical drive has been mounted */
    0119E A1ED      LDD	R30,Y+37
    0119F A1FE      LDD	R31,Y+38
    011A0 8020      LD	R2,Z
    011A1 2022      TST	R2
    011A2 F079      BEQ	0x11B2
(2043) 		stat = disk_status(fs->drv);
    011A3 8101      LDD	R16,Z+1
    011A4 940E 02A3 CALL	_disk_status
    011A6 2EA0      MOV	R10,R16
(2044) 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    011A7 FD00      SBRC	R16,0
    011A8 C009      RJMP	0x11B2
(2045) 			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    011A9 A80B      LDD	R0,Y+51
    011AA 2000      TST	R0
    011AB F021      BEQ	0x11B0
    011AC FF02      SBRS	R16,2
    011AD C002      RJMP	0x11B0
(2046) 				return FR_WRITE_PROTECTED;
    011AE E00A      LDI	R16,0xA
    011AF C4A7      RJMP	0x1657
(2047) 			return FR_OK;				/* The file system object is valid */
    011B0 2700      CLR	R16
    011B1 C4A5      RJMP	0x1657
(2048) 		}
(2049) 	}
(2050) 
(2051) 	/* The file system object is not valid. */
(2052) 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
(2053) 
(2054) 	fs->fs_type = 0;					/* Clear the file system object */
    011B2 2422      CLR	R2
    011B3 A1ED      LDD	R30,Y+37
    011B4 A1FE      LDD	R31,Y+38
    011B5 8220      ST	Z,R2
(2055) 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    011B6 82E1      STD	Z+1,R14
(2056) 	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    011B7 8101      LDD	R16,Z+1
    011B8 940E 028D CALL	_disk_initialize
    011BA 2EE0      MOV	R14,R16
    011BB 2CAE      MOV	R10,R14
(2057) 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    011BC FF00      SBRS	R16,0
    011BD C002      RJMP	0x11C0
(2058) 		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    011BE E003      LDI	R16,3
    011BF C497      RJMP	0x1657
(2059) 	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    011C0 A80B      LDD	R0,Y+51
    011C1 2000      TST	R0
    011C2 F021      BEQ	0x11C7
    011C3 FEA2      SBRS	R10,2
    011C4 C002      RJMP	0x11C7
(2060) 		return FR_WRITE_PROTECTED;
    011C5 E00A      LDI	R16,0xA
    011C6 C490      RJMP	0x1657
(2061) #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
(2062) 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
(2063) 		return FR_DISK_ERR;
(2064) #endif
(2065) 	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
(2066) 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    011C7 E080      LDI	R24,0
    011C8 8B89      STD	Y+17,R24
    011C9 8B8A      STD	Y+18,R24
    011CA 8B8B      STD	Y+19,R24
    011CB 8B8C      STD	Y+20,R24
    011CC E040      LDI	R20,0
    011CD E050      LDI	R21,0
    011CE E060      LDI	R22,0
    011CF E070      LDI	R23,0
    011D0 8368      ST	Y,R22
    011D1 8379      STD	Y+1,R23
    011D2 019A      MOVW	R18,R20
    011D3 A10D      LDD	R16,Y+37
    011D4 A11E      LDD	R17,Y+38
    011D5 DEC4      RCALL	ff.c:check_fs
    011D6 2EA0      MOV	R10,R16
    011D7 2CCA      MOV	R12,R10
(2067) 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
    011D8 C000      RJMP	0x11D9
(2068) 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    011D9 2D8C      MOV	R24,R12
    011DA 3081      CPI	R24,1
    011DB F009      BEQ	0x11DD
    011DC C04C      RJMP	0x1229
(2069) 		/* Check the partition listed in the partition table */
(2070) 		pi = LD2PT(vol);
    011DD 24AA      CLR	R10
(2071) 		if (pi) pi--;
    011DE F009      BEQ	0x11E0
    011DF 94AA      DEC	R10
(2072) 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
    011E0 E100      LDI	R16,0x10
    011E1 2D1A      MOV	R17,R10
    011E2 0301      MULSU	R16,R17
    011E3 0150      MOVW	R10,R0
    011E4 A18D      LDD	R24,Y+37
    011E5 A19E      LDD	R25,Y+38
    011E6 5184      SUBI	R24,0x14
    011E7 4F9E      SBCI	R25,0xFE
    011E8 0EA8      ADD	R10,R24
    011E9 1EB9      ADC	R11,R25
(2073) 		if (tbl[4]) {						/* Is the partition existing? */
    011EA 01F5      MOVW	R30,R10
    011EB 8024      LDD	R2,Z+4
    011EC 2022      TST	R2
    011ED F409      BNE	0x11EF
    011EE C03A      RJMP	0x1229
(2074) 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    011EF E188      LDI	R24,0x18
    011F0 E090      LDI	R25,0
    011F1 8503      LDD	R16,Z+11
    011F2 2711      CLR	R17
    011F3 2722      CLR	R18
    011F4 2733      CLR	R19
    011F5 938A      ST	-Y,R24
    011F6 940E 4129 CALL	lsl32
    011F8 0118      MOVW	R2,R16
    011F9 0129      MOVW	R4,R18
    011FA 01F5      MOVW	R30,R10
    011FB 8462      LDD	R6,Z+10
    011FC 2477      CLR	R7
    011FD 2488      CLR	R8
    011FE 2499      CLR	R9
    011FF 0143      MOVW	R8,R6
    01200 2466      CLR	R6
    01201 2477      CLR	R7
    01202 2826      OR	R2,R6
    01203 2837      OR	R3,R7
    01204 2848      OR	R4,R8
    01205 2859      OR	R5,R9
    01206 8461      LDD	R6,Z+9
    01207 2477      CLR	R7
    01208 2C76      MOV	R7,R6
    01209 2466      CLR	R6
    0120A 2488      CLR	R8
    0120B 2499      CLR	R9
    0120C 2826      OR	R2,R6
    0120D 2837      OR	R3,R7
    0120E 2848      OR	R4,R8
    0120F 2859      OR	R5,R9
    01210 9638      ADIW	R30,0x8
    01211 8060      LD	R6,Z
    01212 2477      CLR	R7
    01213 2488      CLR	R8
    01214 2499      CLR	R9
    01215 2826      OR	R2,R6
    01216 2837      OR	R3,R7
    01217 2848      OR	R4,R8
    01218 2859      OR	R5,R9
    01219 8A29      STD	Y+17,R2
    0121A 8A3A      STD	Y+18,R3
    0121B 8A4B      STD	Y+19,R4
    0121C 8A5C      STD	Y+20,R5
(2075) 			fmt = check_fs(fs, bsect);		/* Check the partition */
    0121D 8829      LDD	R2,Y+17
    0121E 883A      LDD	R3,Y+18
    0121F 884B      LDD	R4,Y+19
    01220 885C      LDD	R5,Y+20
    01221 8248      ST	Y,R4
    01222 8259      STD	Y+1,R5
    01223 0191      MOVW	R18,R2
    01224 A10D      LDD	R16,Y+37
    01225 A11E      LDD	R17,Y+38
    01226 DE73      RCALL	ff.c:check_fs
    01227 2EA0      MOV	R10,R16
    01228 2CCA      MOV	R12,R10
(2076) 		}
(2077) 	}
(2078) 	if (fmt == 3) return FR_DISK_ERR;
    01229 2D8C      MOV	R24,R12
    0122A 3083      CPI	R24,3
    0122B F411      BNE	0x122E
    0122C E001      LDI	R16,1
    0122D C429      RJMP	0x1657
(2079) 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    0122E 20CC      TST	R12
    0122F F011      BEQ	0x1232
    01230 E00D      LDI	R16,0xD
    01231 C425      RJMP	0x1657
(2080) 
(2081) 	/* An FAT volume is found. Following code initializes the file system object */
(2082) 
(2083) 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    01232 A1ED      LDD	R30,Y+37
    01233 A1FE      LDD	R31,Y+38
    01234 AC21      LDD	R2,Z+57
    01235 2433      CLR	R3
    01236 AD82      LDD	R24,Z+58
    01237 2799      CLR	R25
    01238 2F98      MOV	R25,R24
    01239 2788      CLR	R24
    0123A 2982      OR	R24,R2
    0123B 2993      OR	R25,R3
    0123C 3080      CPI	R24,0
    0123D E0E2      LDI	R30,2
    0123E 079E      CPC	R25,R30
    0123F F011      BEQ	0x1242
(2084) 		return FR_NO_FILESYSTEM;
    01240 E00D      LDI	R16,0xD
    01241 C415      RJMP	0x1657
(2085) 
(2086) 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    01242 A1ED      LDD	R30,Y+37
    01243 A1FE      LDD	R31,Y+38
    01244 5BEC      SUBI	R30,0xBC
    01245 4FFF      SBCI	R31,0xFF
    01246 8020      LD	R2,Z
    01247 54E4      SUBI	R30,0x44
    01248 40F0      SBCI	R31,0
    01249 2433      CLR	R3
    0124A 5BEB      SUBI	R30,0xBB
    0124B 4FFF      SBCI	R31,0xFF
    0124C 8040      LD	R4,Z
    0124D 2455      CLR	R5
    0124E 2C54      MOV	R5,R4
    0124F 2444      CLR	R4
    01250 2842      OR	R4,R2
    01251 2853      OR	R5,R3
    01252 0112      MOVW	R2,R4
    01253 2444      CLR	R4
    01254 2455      CLR	R5
    01255 822D      STD	Y+5,R2
    01256 823E      STD	Y+6,R3
    01257 824F      STD	Y+7,R4
    01258 8658      STD	Y+8,R5
(2087) 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    01259 802D      LDD	R2,Y+5
    0125A 803E      LDD	R3,Y+6
    0125B 804F      LDD	R4,Y+7
    0125C 8458      LDD	R5,Y+8
    0125D 9488      BCLR	0
    0125E 2022      TST	R2
    0125F 0432      CPC	R3,R2
    01260 0442      CPC	R4,R2
    01261 0452      CPC	R5,R2
    01262 F009      BEQ	0x1264
    01263 C03C      RJMP	0x12A0
    01264 E188      LDI	R24,0x18
    01265 E090      LDI	R25,0
    01266 A1ED      LDD	R30,Y+37
    01267 A1FE      LDD	R31,Y+38
    01268 5AEB      SUBI	R30,0xAB
    01269 4FFF      SBCI	R31,0xFF
    0126A 8100      LD	R16,Z
    0126B 2711      CLR	R17
    0126C 2722      CLR	R18
    0126D 2733      CLR	R19
    0126E 938A      ST	-Y,R24
    0126F 940E 4129 CALL	lsl32
    01271 0118      MOVW	R2,R16
    01272 0129      MOVW	R4,R18
    01273 A1ED      LDD	R30,Y+37
    01274 A1FE      LDD	R31,Y+38
    01275 5AEC      SUBI	R30,0xAC
    01276 4FFF      SBCI	R31,0xFF
    01277 8060      LD	R6,Z
    01278 55E4      SUBI	R30,0x54
    01279 40F0      SBCI	R31,0
    0127A 2477      CLR	R7
    0127B 2488      CLR	R8
    0127C 2499      CLR	R9
    0127D 0143      MOVW	R8,R6
    0127E 2466      CLR	R6
    0127F 2477      CLR	R7
    01280 2826      OR	R2,R6
    01281 2837      OR	R3,R7
    01282 2848      OR	R4,R8
    01283 2859      OR	R5,R9
    01284 5AED      SUBI	R30,0xAD
    01285 4FFF      SBCI	R31,0xFF
    01286 8060      LD	R6,Z
    01287 55E3      SUBI	R30,0x53
    01288 40F0      SBCI	R31,0
    01289 2477      CLR	R7
    0128A 2C76      MOV	R7,R6
    0128B 2466      CLR	R6
    0128C 2488      CLR	R8
    0128D 2499      CLR	R9
    0128E 2826      OR	R2,R6
    0128F 2837      OR	R3,R7
    01290 2848      OR	R4,R8
    01291 2859      OR	R5,R9
    01292 5AEE      SUBI	R30,0xAE
    01293 4FFF      SBCI	R31,0xFF
    01294 8060      LD	R6,Z
    01295 2477      CLR	R7
    01296 2488      CLR	R8
    01297 2499      CLR	R9
    01298 2826      OR	R2,R6
    01299 2837      OR	R3,R7
    0129A 2848      OR	R4,R8
    0129B 2859      OR	R5,R9
    0129C 822D      STD	Y+5,R2
    0129D 823E      STD	Y+6,R3
    0129E 824F      STD	Y+7,R4
    0129F 8658      STD	Y+8,R5
(2088) 	fs->fsize = fasize;
    012A0 802D      LDD	R2,Y+5
    012A1 803E      LDD	R3,Y+6
    012A2 804F      LDD	R4,Y+7
    012A3 8458      LDD	R5,Y+8
    012A4 A1ED      LDD	R30,Y+37
    012A5 A1FE      LDD	R31,Y+38
    012A6 8E22      STD	Z+26,R2
    012A7 8E33      STD	Z+27,R3
    012A8 8E44      STD	Z+28,R4
    012A9 8E55      STD	Z+29,R5
(2089) 
(2090) 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    012AA ACA6      LDD	R10,Z+62
    012AB 2CEA      MOV	R14,R10
    012AC 82A3      STD	Z+3,R10
(2091) 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    012AD 2D8E      MOV	R24,R14
    012AE 3081      CPI	R24,1
    012AF F021      BEQ	0x12B4
    012B0 3082      CPI	R24,2
    012B1 F011      BEQ	0x12B4
    012B2 E00D      LDI	R16,0xD
    012B3 C3A3      RJMP	0x1657
(2092) 	fasize *= b;										/* Number of sectors for FAT area */
    012B4 2C2E      MOV	R2,R14
    012B5 2433      CLR	R3
    012B6 2444      CLR	R4
    012B7 2455      CLR	R5
    012B8 810D      LDD	R16,Y+5
    012B9 811E      LDD	R17,Y+6
    012BA 812F      LDD	R18,Y+7
    012BB 8538      LDD	R19,Y+8
    012BC 925A      ST	-Y,R5
    012BD 924A      ST	-Y,R4
    012BE 923A      ST	-Y,R3
    012BF 922A      ST	-Y,R2
    012C0 940E 4053 CALL	empy32u|empy32s
    012C2 830D      STD	Y+5,R16
    012C3 831E      STD	Y+6,R17
    012C4 832F      STD	Y+7,R18
    012C5 8738      STD	Y+8,R19
(2093) 
(2094) 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    012C6 A1ED      LDD	R30,Y+37
    012C7 A1FE      LDD	R31,Y+38
    012C8 ACA3      LDD	R10,Z+59
    012C9 2CEA      MOV	R14,R10
    012CA 82A2      STD	Z+2,R10
(2095) 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    012CB 20AA      TST	R10
    012CC F029      BEQ	0x12D2
    012CD 2D8E      MOV	R24,R14
    012CE 5081      SUBI	R24,1
    012CF 2C2E      MOV	R2,R14
    012D0 2228      AND	R2,R24
    012D1 F011      BEQ	0x12D4
    012D2 E00D      LDI	R16,0xD
    012D3 C383      RJMP	0x1657
(2096) 
(2097) 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    012D4 A1ED      LDD	R30,Y+37
    012D5 A1FE      LDD	R31,Y+38
    012D6 AC27      LDD	R2,Z+63
    012D7 2433      CLR	R3
    012D8 5CE0      SUBI	R30,0xC0
    012D9 4FFF      SBCI	R31,0xFF
    012DA 8040      LD	R4,Z
    012DB 54E0      SUBI	R30,0x40
    012DC 40F0      SBCI	R31,0
    012DD 2455      CLR	R5
    012DE 2C54      MOV	R5,R4
    012DF 2444      CLR	R4
    012E0 2842      OR	R4,R2
    012E1 2853      OR	R5,R3
    012E2 8651      STD	Z+9,R5
    012E3 8640      STD	Z+8,R4
(2098) 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    012E4 8580      LDD	R24,Z+8
    012E5 8591      LDD	R25,Z+9
    012E6 708F      ANDI	R24,0xF
    012E7 7090      ANDI	R25,0
    012E8 3080      CPI	R24,0
    012E9 0789      CPC	R24,R25
    012EA F011      BEQ	0x12ED
    012EB E00D      LDI	R16,0xD
    012EC C36A      RJMP	0x1657
(2099) 
(2100) 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    012ED A1ED      LDD	R30,Y+37
    012EE A1FE      LDD	R31,Y+38
    012EF 5BEF      SUBI	R30,0xBF
    012F0 4FFF      SBCI	R31,0xFF
    012F1 8020      LD	R2,Z
    012F2 54E1      SUBI	R30,0x41
    012F3 40F0      SBCI	R31,0
    012F4 2433      CLR	R3
    012F5 5BEE      SUBI	R30,0xBE
    012F6 4FFF      SBCI	R31,0xFF
    012F7 8040      LD	R4,Z
    012F8 2455      CLR	R5
    012F9 2C54      MOV	R5,R4
    012FA 2444      CLR	R4
    012FB 2842      OR	R4,R2
    012FC 2853      OR	R5,R3
    012FD 0112      MOVW	R2,R4
    012FE 2444      CLR	R4
    012FF 2455      CLR	R5
    01300 862D      STD	Y+13,R2
    01301 863E      STD	Y+14,R3
    01302 864F      STD	Y+15,R4
    01303 8A58      STD	Y+16,R5
(2101) 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    01304 842D      LDD	R2,Y+13
    01305 843E      LDD	R3,Y+14
    01306 844F      LDD	R4,Y+15
    01307 8858      LDD	R5,Y+16
    01308 9488      BCLR	0
    01309 2022      TST	R2
    0130A 0432      CPC	R3,R2
    0130B 0442      CPC	R4,R2
    0130C 0452      CPC	R5,R2
    0130D F009      BEQ	0x130F
    0130E C03C      RJMP	0x134B
    0130F E188      LDI	R24,0x18
    01310 E090      LDI	R25,0
    01311 A1ED      LDD	R30,Y+37
    01312 A1FE      LDD	R31,Y+38
    01313 5AEF      SUBI	R30,0xAF
    01314 4FFF      SBCI	R31,0xFF
    01315 8100      LD	R16,Z
    01316 2711      CLR	R17
    01317 2722      CLR	R18
    01318 2733      CLR	R19
    01319 938A      ST	-Y,R24
    0131A 940E 4129 CALL	lsl32
    0131C 0118      MOVW	R2,R16
    0131D 0129      MOVW	R4,R18
    0131E A1ED      LDD	R30,Y+37
    0131F A1FE      LDD	R31,Y+38
    01320 5BE0      SUBI	R30,0xB0
    01321 4FFF      SBCI	R31,0xFF
    01322 8060      LD	R6,Z
    01323 55E0      SUBI	R30,0x50
    01324 40F0      SBCI	R31,0
    01325 2477      CLR	R7
    01326 2488      CLR	R8
    01327 2499      CLR	R9
    01328 0143      MOVW	R8,R6
    01329 2466      CLR	R6
    0132A 2477      CLR	R7
    0132B 2826      OR	R2,R6
    0132C 2837      OR	R3,R7
    0132D 2848      OR	R4,R8
    0132E 2859      OR	R5,R9
    0132F 5BE1      SUBI	R30,0xB1
    01330 4FFF      SBCI	R31,0xFF
    01331 8060      LD	R6,Z
    01332 54EF      SUBI	R30,0x4F
    01333 40F0      SBCI	R31,0
    01334 2477      CLR	R7
    01335 2C76      MOV	R7,R6
    01336 2466      CLR	R6
    01337 2488      CLR	R8
    01338 2499      CLR	R9
    01339 2826      OR	R2,R6
    0133A 2837      OR	R3,R7
    0133B 2848      OR	R4,R8
    0133C 2859      OR	R5,R9
    0133D 5BE2      SUBI	R30,0xB2
    0133E 4FFF      SBCI	R31,0xFF
    0133F 8060      LD	R6,Z
    01340 2477      CLR	R7
    01341 2488      CLR	R8
    01342 2499      CLR	R9
    01343 2826      OR	R2,R6
    01344 2837      OR	R3,R7
    01345 2848      OR	R4,R8
    01346 2859      OR	R5,R9
    01347 862D      STD	Y+13,R2
    01348 863E      STD	Y+14,R3
    01349 864F      STD	Y+15,R4
    0134A 8A58      STD	Y+16,R5
(2102) 
(2103) 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    0134B A1ED      LDD	R30,Y+37
    0134C A1FE      LDD	R31,Y+38
    0134D AC24      LDD	R2,Z+60
    0134E 2433      CLR	R3
    0134F ACE5      LDD	R14,Z+61
    01350 24FF      CLR	R15
    01351 2CFE      MOV	R15,R14
    01352 24EE      CLR	R14
    01353 28E2      OR	R14,R2
    01354 28F3      OR	R15,R3
(2104) 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    01355 20EE      TST	R14
    01356 F421      BNE	0x135B
    01357 20FF      TST	R15
    01358 F411      BNE	0x135B
    01359 E00D      LDI	R16,0xD
    0135A C2FC      RJMP	0x1657
(2105) 
(2106) 	/* Determine the FAT sub type */
(2107) 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    0135B 802D      LDD	R2,Y+5
    0135C 803E      LDD	R3,Y+6
    0135D 804F      LDD	R4,Y+7
    0135E 8458      LDD	R5,Y+8
    0135F 0137      MOVW	R6,R14
    01360 2488      CLR	R8
    01361 2499      CLR	R9
    01362 0C62      ADD	R6,R2
    01363 1C73      ADC	R7,R3
    01364 1C84      ADC	R8,R4
    01365 1C95      ADC	R9,R5
    01366 A1ED      LDD	R30,Y+37
    01367 A1FE      LDD	R31,Y+38
    01368 9638      ADIW	R30,0x8
    01369 8020      LD	R2,Z
    0136A 8031      LDD	R3,Z+1
    0136B 9436      LSR	R3
    0136C 9427      ROR	R2
    0136D 9436      LSR	R3
    0136E 9427      ROR	R2
    0136F 9436      LSR	R3
    01370 9427      ROR	R2
    01371 9436      LSR	R3
    01372 9427      ROR	R2
    01373 2444      CLR	R4
    01374 2455      CLR	R5
    01375 0C62      ADD	R6,R2
    01376 1C73      ADC	R7,R3
    01377 1C84      ADC	R8,R4
    01378 1C95      ADC	R9,R5
    01379 8A6D      STD	Y+21,R6
    0137A 8A7E      STD	Y+22,R7
    0137B 8A8F      STD	Y+23,R8
    0137C 8E98      STD	Y+24,R9
(2108) 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    0137D 882D      LDD	R2,Y+21
    0137E 883E      LDD	R3,Y+22
    0137F 884F      LDD	R4,Y+23
    01380 8C58      LDD	R5,Y+24
    01381 846D      LDD	R6,Y+13
    01382 847E      LDD	R7,Y+14
    01383 848F      LDD	R8,Y+15
    01384 8898      LDD	R9,Y+16
    01385 1462      CP	R6,R2
    01386 0473      CPC	R7,R3
    01387 0484      CPC	R8,R4
    01388 0495      CPC	R9,R5
    01389 F410      BCC	0x138C
    0138A E00D      LDI	R16,0xD
    0138B C2CB      RJMP	0x1657
(2109) 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    0138C 882D      LDD	R2,Y+21
    0138D 883E      LDD	R3,Y+22
    0138E 884F      LDD	R4,Y+23
    0138F 8C58      LDD	R5,Y+24
    01390 850D      LDD	R16,Y+13
    01391 851E      LDD	R17,Y+14
    01392 852F      LDD	R18,Y+15
    01393 8938      LDD	R19,Y+16
    01394 1902      SUB	R16,R2
    01395 0913      SBC	R17,R3
    01396 0924      SBC	R18,R4
    01397 0935      SBC	R19,R5
    01398 A1ED      LDD	R30,Y+37
    01399 A1FE      LDD	R31,Y+38
    0139A 9632      ADIW	R30,2
    0139B 8020      LD	R2,Z
    0139C 2433      CLR	R3
    0139D 2444      CLR	R4
    0139E 2455      CLR	R5
    0139F 925A      ST	-Y,R5
    013A0 924A      ST	-Y,R4
    013A1 923A      ST	-Y,R3
    013A2 922A      ST	-Y,R2
    013A3 940E 3FAD CALL	div32u
    013A5 8709      STD	Y+9,R16
    013A6 871A      STD	Y+10,R17
    013A7 872B      STD	Y+11,R18
    013A8 873C      STD	Y+12,R19
(2110) 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    013A9 8429      LDD	R2,Y+9
    013AA 843A      LDD	R3,Y+10
    013AB 844B      LDD	R4,Y+11
    013AC 845C      LDD	R5,Y+12
    013AD 9488      BCLR	0
    013AE 2022      TST	R2
    013AF 0432      CPC	R3,R2
    013B0 0442      CPC	R4,R2
    013B1 0452      CPC	R5,R2
    013B2 F411      BNE	0x13B5
    013B3 E00D      LDI	R16,0xD
    013B4 C2A2      RJMP	0x1657
(2111) 	fmt = FS_FAT12;
    013B5 24CC      CLR	R12
    013B6 94C3      INC	R12
(2112) 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    013B7 EF46      LDI	R20,0xF6
    013B8 E05F      LDI	R21,0xF
    013B9 E060      LDI	R22,0
    013BA E070      LDI	R23,0
    013BB 8429      LDD	R2,Y+9
    013BC 843A      LDD	R3,Y+10
    013BD 844B      LDD	R4,Y+11
    013BE 845C      LDD	R5,Y+12
    013BF 1624      CP	R2,R20
    013C0 0635      CPC	R3,R21
    013C1 0646      CPC	R4,R22
    013C2 0657      CPC	R5,R23
    013C3 F010      BCS	0x13C6
    013C4 E082      LDI	R24,2
    013C5 2EC8      MOV	R12,R24
(2113) 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    013C6 EF46      LDI	R20,0xF6
    013C7 EF5F      LDI	R21,0xFF
    013C8 E060      LDI	R22,0
    013C9 E070      LDI	R23,0
    013CA 8429      LDD	R2,Y+9
    013CB 843A      LDD	R3,Y+10
    013CC 844B      LDD	R4,Y+11
    013CD 845C      LDD	R5,Y+12
    013CE 1624      CP	R2,R20
    013CF 0635      CPC	R3,R21
    013D0 0646      CPC	R4,R22
    013D1 0657      CPC	R5,R23
    013D2 F010      BCS	0x13D5
    013D3 E083      LDI	R24,3
    013D4 2EC8      MOV	R12,R24
(2114) 
(2115) 	/* Boundaries and Limits */
(2116) 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    013D5 E042      LDI	R20,2
    013D6 E050      LDI	R21,0
    013D7 E060      LDI	R22,0
    013D8 E070      LDI	R23,0
    013D9 8429      LDD	R2,Y+9
    013DA 843A      LDD	R3,Y+10
    013DB 844B      LDD	R4,Y+11
    013DC 845C      LDD	R5,Y+12
    013DD 0E24      ADD	R2,R20
    013DE 1E35      ADC	R3,R21
    013DF 1E46      ADC	R4,R22
    013E0 1E57      ADC	R5,R23
    013E1 A1ED      LDD	R30,Y+37
    013E2 A1FE      LDD	R31,Y+38
    013E3 9676      ADIW	R30,0x16
    013E4 8220      ST	Z,R2
    013E5 8231      STD	Z+1,R3
    013E6 8242      STD	Z+2,R4
    013E7 8253      STD	Z+3,R5
(2117) 	fs->database = bsect + sysect;						/* Data start sector */
    013E8 882D      LDD	R2,Y+21
    013E9 883E      LDD	R3,Y+22
    013EA 884F      LDD	R4,Y+23
    013EB 8C58      LDD	R5,Y+24
    013EC 8869      LDD	R6,Y+17
    013ED 887A      LDD	R7,Y+18
    013EE 888B      LDD	R8,Y+19
    013EF 889C      LDD	R9,Y+20
    013F0 0C62      ADD	R6,R2
    013F1 1C73      ADC	R7,R3
    013F2 1C84      ADC	R8,R4
    013F3 1C95      ADC	R9,R5
    013F4 A1ED      LDD	R30,Y+37
    013F5 A1FE      LDD	R31,Y+38
    013F6 96B6      ADIW	R30,0x26
    013F7 8260      ST	Z,R6
    013F8 8271      STD	Z+1,R7
    013F9 8282      STD	Z+2,R8
    013FA 8293      STD	Z+3,R9
(2118) 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    013FB 0117      MOVW	R2,R14
    013FC 2444      CLR	R4
    013FD 2455      CLR	R5
    013FE 8869      LDD	R6,Y+17
    013FF 887A      LDD	R7,Y+18
    01400 888B      LDD	R8,Y+19
    01401 889C      LDD	R9,Y+20
    01402 0C62      ADD	R6,R2
    01403 1C73      ADC	R7,R3
    01404 1C84      ADC	R8,R4
    01405 1C95      ADC	R9,R5
    01406 A1ED      LDD	R30,Y+37
    01407 A1FE      LDD	R31,Y+38
    01408 8E66      STD	Z+30,R6
    01409 8E77      STD	Z+31,R7
    0140A A280      STD	Z+32,R8
    0140B A291      STD	Z+33,R9
(2119) 	if (fmt == FS_FAT32) {
    0140C 2D8C      MOV	R24,R12
    0140D 3083      CPI	R24,3
    0140E F009      BEQ	0x1410
    0140F C055      RJMP	0x1465
(2120) 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    01410 8420      LDD	R2,Z+8
    01411 8431      LDD	R3,Z+9
    01412 2022      TST	R2
    01413 F411      BNE	0x1416
    01414 2033      TST	R3
    01415 F011      BEQ	0x1418
    01416 E00D      LDI	R16,0xD
    01417 C23F      RJMP	0x1657
(2121) 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    01418 E188      LDI	R24,0x18
    01419 E090      LDI	R25,0
    0141A A1ED      LDD	R30,Y+37
    0141B A1FE      LDD	R31,Y+38
    0141C 5AE3      SUBI	R30,0xA3
    0141D 4FFF      SBCI	R31,0xFF
    0141E 8100      LD	R16,Z
    0141F 2711      CLR	R17
    01420 2722      CLR	R18
    01421 2733      CLR	R19
    01422 938A      ST	-Y,R24
    01423 940E 4129 CALL	lsl32
    01425 0118      MOVW	R2,R16
    01426 0129      MOVW	R4,R18
    01427 A1ED      LDD	R30,Y+37
    01428 A1FE      LDD	R31,Y+38
    01429 5AE4      SUBI	R30,0xA4
    0142A 4FFF      SBCI	R31,0xFF
    0142B 8060      LD	R6,Z
    0142C 55EC      SUBI	R30,0x5C
    0142D 40F0      SBCI	R31,0
    0142E 2477      CLR	R7
    0142F 2488      CLR	R8
    01430 2499      CLR	R9
    01431 0143      MOVW	R8,R6
    01432 2466      CLR	R6
    01433 2477      CLR	R7
    01434 2826      OR	R2,R6
    01435 2837      OR	R3,R7
    01436 2848      OR	R4,R8
    01437 2859      OR	R5,R9
    01438 5AE5      SUBI	R30,0xA5
    01439 4FFF      SBCI	R31,0xFF
    0143A 8060      LD	R6,Z
    0143B 55EB      SUBI	R30,0x5B
    0143C 40F0      SBCI	R31,0
    0143D 2477      CLR	R7
    0143E 2C76      MOV	R7,R6
    0143F 2466      CLR	R6
    01440 2488      CLR	R8
    01441 2499      CLR	R9
    01442 2826      OR	R2,R6
    01443 2837      OR	R3,R7
    01444 2848      OR	R4,R8
    01445 2859      OR	R5,R9
    01446 5AE6      SUBI	R30,0xA6
    01447 4FFF      SBCI	R31,0xFF
    01448 8060      LD	R6,Z
    01449 55EA      SUBI	R30,0x5A
    0144A 40F0      SBCI	R31,0
    0144B 2477      CLR	R7
    0144C 2488      CLR	R8
    0144D 2499      CLR	R9
    0144E 2826      OR	R2,R6
    0144F 2837      OR	R3,R7
    01450 2848      OR	R4,R8
    01451 2859      OR	R5,R9
    01452 A222      STD	Z+34,R2
    01453 A233      STD	Z+35,R3
    01454 A244      STD	Z+36,R4
    01455 A255      STD	Z+37,R5
(2122) 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    01456 E082      LDI	R24,2
    01457 E090      LDI	R25,0
    01458 9676      ADIW	R30,0x16
    01459 8100      LD	R16,Z
    0145A 8111      LDD	R17,Z+1
    0145B 8122      LDD	R18,Z+2
    0145C 8133      LDD	R19,Z+3
    0145D 938A      ST	-Y,R24
    0145E 940E 4129 CALL	lsl32
    01460 8F09      STD	Y+25,R16
    01461 8F1A      STD	Y+26,R17
    01462 8F2B      STD	Y+27,R18
    01463 8F3C      STD	Y+28,R19
(2123) 	} else {
    01464 C06A      RJMP	0x14CF
(2124) 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    01465 A1ED      LDD	R30,Y+37
    01466 A1FE      LDD	R31,Y+38
    01467 8420      LDD	R2,Z+8
    01468 8431      LDD	R3,Z+9
    01469 2022      TST	R2
    0146A F421      BNE	0x146F
    0146B 2033      TST	R3
    0146C F411      BNE	0x146F
    0146D E00D      LDI	R16,0xD
    0146E C1E8      RJMP	0x1657
(2125) 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    0146F 802D      LDD	R2,Y+5
    01470 803E      LDD	R3,Y+6
    01471 804F      LDD	R4,Y+7
    01472 8458      LDD	R5,Y+8
    01473 A1ED      LDD	R30,Y+37
    01474 A1FE      LDD	R31,Y+38
    01475 8C66      LDD	R6,Z+30
    01476 8C77      LDD	R7,Z+31
    01477 A080      LDD	R8,Z+32
    01478 A091      LDD	R9,Z+33
    01479 0C62      ADD	R6,R2
    0147A 1C73      ADC	R7,R3
    0147B 1C84      ADC	R8,R4
    0147C 1C95      ADC	R9,R5
    0147D A262      STD	Z+34,R6
    0147E A273      STD	Z+35,R7
    0147F A284      STD	Z+36,R8
    01480 A295      STD	Z+37,R9
(2126) 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    01481 2D8C      MOV	R24,R12
    01482 3082      CPI	R24,2
    01483 F471      BNE	0x1492
    01484 9676      ADIW	R30,0x16
    01485 8020      LD	R2,Z
    01486 8031      LDD	R3,Z+1
    01487 8042      LDD	R4,Z+2
    01488 8053      LDD	R5,Z+3
    01489 0C22      LSL	R2
    0148A 1C33      ROL	R3
    0148B 1C44      ROL	R4
    0148C 1C55      ROL	R5
    0148D 8E2D      STD	Y+29,R2
    0148E 8E3E      STD	Y+30,R3
    0148F 8E4F      STD	Y+31,R4
    01490 A258      STD	Y+32,R5
    01491 C035      RJMP	0x14C7
    01492 A1ED      LDD	R30,Y+37
    01493 A1FE      LDD	R31,Y+38
    01494 9676      ADIW	R30,0x16
    01495 8020      LD	R2,Z
    01496 8031      LDD	R3,Z+1
    01497 8042      LDD	R4,Z+2
    01498 8053      LDD	R5,Z+3
    01499 A229      STD	Y+33,R2
    0149A A23A      STD	Y+34,R3
    0149B A24B      STD	Y+35,R4
    0149C A25C      STD	Y+36,R5
    0149D E041      LDI	R20,1
    0149E E050      LDI	R21,0
    0149F E060      LDI	R22,0
    014A0 E070      LDI	R23,0
    014A1 A029      LDD	R2,Y+33
    014A2 A03A      LDD	R3,Y+34
    014A3 A04B      LDD	R4,Y+35
    014A4 A05C      LDD	R5,Y+36
    014A5 2224      AND	R2,R20
    014A6 2235      AND	R3,R21
    014A7 2246      AND	R4,R22
    014A8 2257      AND	R5,R23
    014A9 A069      LDD	R6,Y+33
    014AA A07A      LDD	R7,Y+34
    014AB A08B      LDD	R8,Y+35
    014AC A09C      LDD	R9,Y+36
    014AD E043      LDI	R20,3
    014AE E050      LDI	R21,0
    014AF E060      LDI	R22,0
    014B0 E070      LDI	R23,0
    014B1 929A      ST	-Y,R9
    014B2 928A      ST	-Y,R8
    014B3 927A      ST	-Y,R7
    014B4 926A      ST	-Y,R6
    014B5 018A      MOVW	R16,R20
    014B6 019B      MOVW	R18,R22
    014B7 940E 4053 CALL	empy32u|empy32s
    014B9 0138      MOVW	R6,R16
    014BA 0149      MOVW	R8,R18
    014BB 9496      LSR	R9
    014BC 9487      ROR	R8
    014BD 9477      ROR	R7
    014BE 9467      ROR	R6
    014BF 0C62      ADD	R6,R2
    014C0 1C73      ADC	R7,R3
    014C1 1C84      ADC	R8,R4
    014C2 1C95      ADC	R9,R5
    014C3 8E6D      STD	Y+29,R6
    014C4 8E7E      STD	Y+30,R7
    014C5 8E8F      STD	Y+31,R8
    014C6 A298      STD	Y+32,R9
    014C7 8C2D      LDD	R2,Y+29
    014C8 8C3E      LDD	R3,Y+30
    014C9 8C4F      LDD	R4,Y+31
    014CA A058      LDD	R5,Y+32
    014CB 8E29      STD	Y+25,R2
    014CC 8E3A      STD	Y+26,R3
    014CD 8E4B      STD	Y+27,R4
    014CE 8E5C      STD	Y+28,R5
(2127) 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
(2128) 	}
(2129) 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    014CF EF4F      LDI	R20,0xFF
    014D0 E051      LDI	R21,1
    014D1 E060      LDI	R22,0
    014D2 E070      LDI	R23,0
    014D3 8D09      LDD	R16,Y+25
    014D4 8D1A      LDD	R17,Y+26
    014D5 8D2B      LDD	R18,Y+27
    014D6 8D3C      LDD	R19,Y+28
    014D7 0F04      ADD	R16,R20
    014D8 1F15      ADC	R17,R21
    014D9 1F26      ADC	R18,R22
    014DA 1F37      ADC	R19,R23
    014DB E089      LDI	R24,0x9
    014DC E090      LDI	R25,0
    014DD 938A      ST	-Y,R24
    014DE 940E 4142 CALL	lsr32
    014E0 A1ED      LDD	R30,Y+37
    014E1 A1FE      LDD	R31,Y+38
    014E2 8C22      LDD	R2,Z+26
    014E3 8C33      LDD	R3,Z+27
    014E4 8C44      LDD	R4,Z+28
    014E5 8C55      LDD	R5,Z+29
    014E6 1620      CP	R2,R16
    014E7 0631      CPC	R3,R17
    014E8 0642      CPC	R4,R18
    014E9 0653      CPC	R5,R19
    014EA F410      BCC	0x14ED
(2130) 		return FR_NO_FILESYSTEM;
    014EB E00D      LDI	R16,0xD
    014EC C16A      RJMP	0x1657
(2131) 
(2132) #if !_FS_READONLY
(2133) 	/* Initialize cluster allocation information */
(2134) 	fs->free_clust = 0xFFFFFFFF;
    014ED A1ED      LDD	R30,Y+37
    014EE A1FE      LDD	R31,Y+38
    014EF 963E      ADIW	R30,0xE
    014F0 EF8F      LDI	R24,0xFF
    014F1 8380      ST	Z,R24
    014F2 8381      STD	Z+1,R24
    014F3 8382      STD	Z+2,R24
    014F4 8383      STD	Z+3,R24
(2135) 	fs->last_clust = 0;
    014F5 A1ED      LDD	R30,Y+37
    014F6 A1FE      LDD	R31,Y+38
    014F7 963A      ADIW	R30,0xA
    014F8 E080      LDI	R24,0
    014F9 8380      ST	Z,R24
    014FA 8381      STD	Z+1,R24
    014FB 8382      STD	Z+2,R24
    014FC 8383      STD	Z+3,R24
(2136) 
(2137) 	/* Get fsinfo if available */
(2138) 	if (fmt == FS_FAT32) {
    014FD 2D8C      MOV	R24,R12
    014FE 3083      CPI	R24,3
    014FF F009      BEQ	0x1501
    01500 C13C      RJMP	0x163D
(2139) 	 	fs->fsi_flag = 0;
    01501 2422      CLR	R2
    01502 A1ED      LDD	R30,Y+37
    01503 A1FE      LDD	R31,Y+38
    01504 8225      STD	Z+5,R2
(2140) 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    01505 5AE2      SUBI	R30,0xA2
    01506 4FFF      SBCI	R31,0xFF
    01507 8020      LD	R2,Z
    01508 55EE      SUBI	R30,0x5E
    01509 40F0      SBCI	R31,0
    0150A 2433      CLR	R3
    0150B 5AE1      SUBI	R30,0xA1
    0150C 4FFF      SBCI	R31,0xFF
    0150D 8040      LD	R4,Z
    0150E 2455      CLR	R5
    0150F 2C54      MOV	R5,R4
    01510 2444      CLR	R4
    01511 2842      OR	R4,R2
    01512 2853      OR	R5,R3
    01513 0112      MOVW	R2,R4
    01514 2444      CLR	R4
    01515 2455      CLR	R5
    01516 8869      LDD	R6,Y+17
    01517 887A      LDD	R7,Y+18
    01518 888B      LDD	R8,Y+19
    01519 889C      LDD	R9,Y+20
    0151A 0C62      ADD	R6,R2
    0151B 1C73      ADC	R7,R3
    0151C 1C84      ADC	R8,R4
    0151D 1C95      ADC	R9,R5
    0151E A1ED      LDD	R30,Y+37
    0151F A1FE      LDD	R31,Y+38
    01520 8A62      STD	Z+18,R6
    01521 8A73      STD	Z+19,R7
    01522 8A84      STD	Z+20,R8
    01523 8A95      STD	Z+21,R9
(2141) 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    01524 E081      LDI	R24,1
    01525 838C      STD	Y+4,R24
    01526 8822      LDD	R2,Z+18
    01527 8833      LDD	R3,Z+19
    01528 8844      LDD	R4,Z+20
    01529 8855      LDD	R5,Z+21
    0152A 8228      ST	Y,R2
    0152B 8239      STD	Y+1,R3
    0152C 824A      STD	Y+2,R4
    0152D 825B      STD	Y+3,R5
    0152E 019F      MOVW	R18,R30
    0152F 5D22      SUBI	R18,0xD2
    01530 4F3F      SBCI	R19,0xFF
    01531 8101      LDD	R16,Z+1
    01532 940E 02A9 CALL	_disk_read
    01534 2EE0      MOV	R14,R16
    01535 2300      TST	R16
    01536 F009      BEQ	0x1538
    01537 C105      RJMP	0x163D
    01538 A1ED      LDD	R30,Y+37
    01539 A1FE      LDD	R31,Y+38
    0153A 5DE4      SUBI	R30,0xD4
    0153B 4FFD      SBCI	R31,0xFD
    0153C 8020      LD	R2,Z
    0153D 52EC      SUBI	R30,0x2C
    0153E 40F2      SBCI	R31,2
    0153F 2433      CLR	R3
    01540 5DE3      SUBI	R30,0xD3
    01541 4FFD      SBCI	R31,0xFD
    01542 8180      LD	R24,Z
    01543 52ED      SUBI	R30,0x2D
    01544 40F2      SBCI	R31,2
    01545 2799      CLR	R25
    01546 2F98      MOV	R25,R24
    01547 2788      CLR	R24
    01548 2982      OR	R24,R2
    01549 2993      OR	R25,R3
    0154A 3585      CPI	R24,0x55
    0154B EAAA      LDI	R26,0xAA
    0154C 079A      CPC	R25,R26
    0154D F009      BEQ	0x154F
    0154E C0EE      RJMP	0x163D
    0154F E188      LDI	R24,0x18
    01550 E090      LDI	R25,0
    01551 A901      LDD	R16,Z+49
    01552 2711      CLR	R17
    01553 2722      CLR	R18
    01554 2733      CLR	R19
    01555 938A      ST	-Y,R24
    01556 940E 4129 CALL	lsl32
    01558 0118      MOVW	R2,R16
    01559 0129      MOVW	R4,R18
    0155A A1ED      LDD	R30,Y+37
    0155B A1FE      LDD	R31,Y+38
    0155C A860      LDD	R6,Z+48
    0155D 2477      CLR	R7
    0155E 2488      CLR	R8
    0155F 2499      CLR	R9
    01560 0143      MOVW	R8,R6
    01561 2466      CLR	R6
    01562 2477      CLR	R7
    01563 2826      OR	R2,R6
    01564 2837      OR	R3,R7
    01565 2848      OR	R4,R8
    01566 2859      OR	R5,R9
    01567 A467      LDD	R6,Z+47
    01568 2477      CLR	R7
    01569 2C76      MOV	R7,R6
    0156A 2466      CLR	R6
    0156B 2488      CLR	R8
    0156C 2499      CLR	R9
    0156D 2826      OR	R2,R6
    0156E 2837      OR	R3,R7
    0156F 2848      OR	R4,R8
    01570 2859      OR	R5,R9
    01571 A466      LDD	R6,Z+46
    01572 2477      CLR	R7
    01573 2488      CLR	R8
    01574 2499      CLR	R9
    01575 2826      OR	R2,R6
    01576 2837      OR	R3,R7
    01577 2848      OR	R4,R8
    01578 2859      OR	R5,R9
    01579 E542      LDI	R20,0x52
    0157A E552      LDI	R21,0x52
    0157B E661      LDI	R22,0x61
    0157C E471      LDI	R23,0x41
    0157D 1624      CP	R2,R20
    0157E 0635      CPC	R3,R21
    0157F 0646      CPC	R4,R22
    01580 0657      CPC	R5,R23
    01581 F009      BEQ	0x1583
    01582 C0BA      RJMP	0x163D
    01583 E188      LDI	R24,0x18
    01584 E090      LDI	R25,0
    01585 5EEB      SUBI	R30,0xEB
    01586 4FFD      SBCI	R31,0xFD
    01587 8100      LD	R16,Z
    01588 2711      CLR	R17
    01589 2722      CLR	R18
    0158A 2733      CLR	R19
    0158B 938A      ST	-Y,R24
    0158C 940E 4129 CALL	lsl32
    0158E 0118      MOVW	R2,R16
    0158F 0129      MOVW	R4,R18
    01590 A1ED      LDD	R30,Y+37
    01591 A1FE      LDD	R31,Y+38
    01592 5EEC      SUBI	R30,0xEC
    01593 4FFD      SBCI	R31,0xFD
    01594 8060      LD	R6,Z
    01595 51E4      SUBI	R30,0x14
    01596 40F2      SBCI	R31,2
    01597 2477      CLR	R7
    01598 2488      CLR	R8
    01599 2499      CLR	R9
    0159A 0143      MOVW	R8,R6
    0159B 2466      CLR	R6
    0159C 2477      CLR	R7
    0159D 2826      OR	R2,R6
    0159E 2837      OR	R3,R7
    0159F 2848      OR	R4,R8
    015A0 2859      OR	R5,R9
    015A1 5EED      SUBI	R30,0xED
    015A2 4FFD      SBCI	R31,0xFD
    015A3 8060      LD	R6,Z
    015A4 51E3      SUBI	R30,0x13
    015A5 40F2      SBCI	R31,2
    015A6 2477      CLR	R7
    015A7 2C76      MOV	R7,R6
    015A8 2466      CLR	R6
    015A9 2488      CLR	R8
    015AA 2499      CLR	R9
    015AB 2826      OR	R2,R6
    015AC 2837      OR	R3,R7
    015AD 2848      OR	R4,R8
    015AE 2859      OR	R5,R9
    015AF 5EEE      SUBI	R30,0xEE
    015B0 4FFD      SBCI	R31,0xFD
    015B1 8060      LD	R6,Z
    015B2 51E2      SUBI	R30,0x12
    015B3 40F2      SBCI	R31,2
    015B4 2477      CLR	R7
    015B5 2488      CLR	R8
    015B6 2499      CLR	R9
    015B7 2826      OR	R2,R6
    015B8 2837      OR	R3,R7
    015B9 2848      OR	R4,R8
    015BA 2859      OR	R5,R9
    015BB E742      LDI	R20,0x72
    015BC E752      LDI	R21,0x72
    015BD E461      LDI	R22,0x41
    015BE E671      LDI	R23,0x61
    015BF 1624      CP	R2,R20
    015C0 0635      CPC	R3,R21
    015C1 0646      CPC	R4,R22
    015C2 0657      CPC	R5,R23
    015C3 F009      BEQ	0x15C5
    015C4 C078      RJMP	0x163D
(2142) 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
(2143) 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
(2144) 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
(2145) 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    015C5 E188      LDI	R24,0x18
    015C6 E090      LDI	R25,0
    015C7 5EE3      SUBI	R30,0xE3
    015C8 4FFD      SBCI	R31,0xFD
    015C9 8100      LD	R16,Z
    015CA 2711      CLR	R17
    015CB 2722      CLR	R18
    015CC 2733      CLR	R19
    015CD 938A      ST	-Y,R24
    015CE 940E 4129 CALL	lsl32
    015D0 0118      MOVW	R2,R16
    015D1 0129      MOVW	R4,R18
    015D2 A1ED      LDD	R30,Y+37
    015D3 A1FE      LDD	R31,Y+38
    015D4 5EE4      SUBI	R30,0xE4
    015D5 4FFD      SBCI	R31,0xFD
    015D6 8060      LD	R6,Z
    015D7 51EC      SUBI	R30,0x1C
    015D8 40F2      SBCI	R31,2
    015D9 2477      CLR	R7
    015DA 2488      CLR	R8
    015DB 2499      CLR	R9
    015DC 0143      MOVW	R8,R6
    015DD 2466      CLR	R6
    015DE 2477      CLR	R7
    015DF 2826      OR	R2,R6
    015E0 2837      OR	R3,R7
    015E1 2848      OR	R4,R8
    015E2 2859      OR	R5,R9
    015E3 5EE5      SUBI	R30,0xE5
    015E4 4FFD      SBCI	R31,0xFD
    015E5 8060      LD	R6,Z
    015E6 51EB      SUBI	R30,0x1B
    015E7 40F2      SBCI	R31,2
    015E8 2477      CLR	R7
    015E9 2C76      MOV	R7,R6
    015EA 2466      CLR	R6
    015EB 2488      CLR	R8
    015EC 2499      CLR	R9
    015ED 2826      OR	R2,R6
    015EE 2837      OR	R3,R7
    015EF 2848      OR	R4,R8
    015F0 2859      OR	R5,R9
    015F1 5EE6      SUBI	R30,0xE6
    015F2 4FFD      SBCI	R31,0xFD
    015F3 8060      LD	R6,Z
    015F4 51EA      SUBI	R30,0x1A
    015F5 40F2      SBCI	R31,2
    015F6 2477      CLR	R7
    015F7 2488      CLR	R8
    015F8 2499      CLR	R9
    015F9 2826      OR	R2,R6
    015FA 2837      OR	R3,R7
    015FB 2848      OR	R4,R8
    015FC 2859      OR	R5,R9
    015FD 8622      STD	Z+10,R2
    015FE 8633      STD	Z+11,R3
    015FF 8644      STD	Z+12,R4
    01600 8655      STD	Z+13,R5
(2146) 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    01601 E188      LDI	R24,0x18
    01602 E090      LDI	R25,0
    01603 5EE7      SUBI	R30,0xE7
    01604 4FFD      SBCI	R31,0xFD
    01605 8100      LD	R16,Z
    01606 2711      CLR	R17
    01607 2722      CLR	R18
    01608 2733      CLR	R19
    01609 938A      ST	-Y,R24
    0160A 940E 4129 CALL	lsl32
    0160C 0118      MOVW	R2,R16
    0160D 0129      MOVW	R4,R18
    0160E A1ED      LDD	R30,Y+37
    0160F A1FE      LDD	R31,Y+38
    01610 5EE8      SUBI	R30,0xE8
    01611 4FFD      SBCI	R31,0xFD
    01612 8060      LD	R6,Z
    01613 51E8      SUBI	R30,0x18
    01614 40F2      SBCI	R31,2
    01615 2477      CLR	R7
    01616 2488      CLR	R8
    01617 2499      CLR	R9
    01618 0143      MOVW	R8,R6
    01619 2466      CLR	R6
    0161A 2477      CLR	R7
    0161B 2826      OR	R2,R6
    0161C 2837      OR	R3,R7
    0161D 2848      OR	R4,R8
    0161E 2859      OR	R5,R9
    0161F 5EE9      SUBI	R30,0xE9
    01620 4FFD      SBCI	R31,0xFD
    01621 8060      LD	R6,Z
    01622 51E7      SUBI	R30,0x17
    01623 40F2      SBCI	R31,2
    01624 2477      CLR	R7
    01625 2C76      MOV	R7,R6
    01626 2466      CLR	R6
    01627 2488      CLR	R8
    01628 2499      CLR	R9
    01629 2826      OR	R2,R6
    0162A 2837      OR	R3,R7
    0162B 2848      OR	R4,R8
    0162C 2859      OR	R5,R9
    0162D 5EEA      SUBI	R30,0xEA
    0162E 4FFD      SBCI	R31,0xFD
    0162F 8060      LD	R6,Z
    01630 51E6      SUBI	R30,0x16
    01631 40F2      SBCI	R31,2
    01632 2477      CLR	R7
    01633 2488      CLR	R8
    01634 2499      CLR	R9
    01635 2826      OR	R2,R6
    01636 2837      OR	R3,R7
    01637 2848      OR	R4,R8
    01638 2859      OR	R5,R9
    01639 8626      STD	Z+14,R2
    0163A 8637      STD	Z+15,R3
    0163B 8A40      STD	Z+16,R4
    0163C 8A51      STD	Z+17,R5
(2147) 		}
(2148) 	}
(2149) #endif
(2150) 	fs->fs_type = fmt;		/* FAT sub-type */
    0163D A1ED      LDD	R30,Y+37
    0163E A1FE      LDD	R31,Y+38
    0163F 82C0      ST	Z,R12
(2151) 	fs->id = ++Fsid;		/* File system mount ID */
    01640 9180 0504 LDS	R24,ff.c:Fsid
    01642 9190 0505 LDS	R25,ff.c:Fsid+1
    01644 9601      ADIW	R24,1
    01645 016C      MOVW	R12,R24
    01646 92D0 0505 STS	ff.c:Fsid+1,R13
    01648 92C0 0504 STS	ff.c:Fsid,R12
    0164A 82D7      STD	Z+7,R13
    0164B 82C6      STD	Z+6,R12
(2152) 	fs->winsect = 0;		/* Invalidate sector cache */
    0164C 96BA      ADIW	R30,0x2A
    0164D E080      LDI	R24,0
    0164E 8380      ST	Z,R24
    0164F 8381      STD	Z+1,R24
    01650 8382      STD	Z+2,R24
    01651 8383      STD	Z+3,R24
(2153) 	fs->wflag = 0;
    01652 2422      CLR	R2
    01653 A1ED      LDD	R30,Y+37
    01654 A1FE      LDD	R31,Y+38
    01655 8224      STD	Z+4,R2
(2154) #if _FS_RPATH
(2155) 	fs->cdir = 0;			/* Current directory (root dir) */
(2156) #endif
(2157) #if _FS_SHARE				/* Clear file lock semaphores */
(2158) 	clear_lock(fs);
(2159) #endif
(2160) 
(2161) 	return FR_OK;
    01656 2700      CLR	R16
    01657 96A7      ADIW	R28,0x27
    01658 940E 409C CALL	pop_xgsetF0FC
    0165A 9622      ADIW	R28,2
    0165B 9508      RET
ff.c:validate:
  id                   --> R10
  fs                   --> R20
    0165C 940E 40B2 CALL	push_xgset300C
    0165E 0159      MOVW	R10,R18
    0165F 01A8      MOVW	R20,R16
(2162) }
(2163) 
(2164) 
(2165) 
(2166) 
(2167) /*-----------------------------------------------------------------------*/
(2168) /* Check if the file/dir object is valid or not                          */
(2169) /*-----------------------------------------------------------------------*/
(2170) 
(2171) static
(2172) FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
(2173) 	FATFS *fs,		/* Pointer to the file system object */
(2174) 	WORD id			/* Member id of the target object to be checked */
(2175) )
(2176) {
(2177) 	if (!fs || !fs->fs_type || fs->id != id)
    01660 3040      CPI	R20,0
    01661 0745      CPC	R20,R21
    01662 F049      BEQ	0x166C
    01663 01FA      MOVW	R30,R20
    01664 8020      LD	R2,Z
    01665 2022      TST	R2
    01666 F029      BEQ	0x166C
    01667 8026      LDD	R2,Z+6
    01668 8037      LDD	R3,Z+7
    01669 142A      CP	R2,R10
    0166A 043B      CPC	R3,R11
    0166B F011      BEQ	0x166E
(2178) 		return FR_INVALID_OBJECT;
    0166C E009      LDI	R16,0x9
    0166D C009      RJMP	0x1677
(2179) 
(2180) 	ENTER_FF(fs);		/* Lock file system */
(2181) 
(2182) 	if (disk_status(fs->drv) & STA_NOINIT)
    0166E 01FA      MOVW	R30,R20
    0166F 8101      LDD	R16,Z+1
    01670 940E 02A3 CALL	_disk_status
    01672 FF00      SBRS	R16,0
    01673 C002      RJMP	0x1676
(2183) 		return FR_NOT_READY;
    01674 E003      LDI	R16,3
    01675 C001      RJMP	0x1677
(2184) 
(2185) 	return FR_OK;
    01676 2700      CLR	R16
    01677 940C 40B7 JMP	pop_xgset300C
_f_mount:
  rfs                  --> R10
  fs                   --> R18
  vol                  --> R16
    01679 92AA      ST	-Y,R10
    0167A 92BA      ST	-Y,R11
(2186) }
(2187) 
(2188) 
(2189) 
(2190) 
(2191) /*--------------------------------------------------------------------------
(2192) 
(2193)    Public Functions
(2194) 
(2195) --------------------------------------------------------------------------*/
(2196) 
(2197) 
(2198) 
(2199) /*-----------------------------------------------------------------------*/
(2200) /* Mount/Unmount a Logical Drive                                         */
(2201) /*-----------------------------------------------------------------------*/
(2202) 
(2203) FRESULT f_mount (
(2204) 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
(2205) 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
(2206) )
(2207) {
(2208) 	FATFS *rfs;
(2209) 
(2210) 
(2211) 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    0167B 3001      CPI	R16,1
    0167C F010      BCS	0x167F
(2212) 		return FR_INVALID_DRIVE;
    0167D E00B      LDI	R16,0xB
    0167E C022      RJMP	0x16A1
(2213) 	rfs = FatFs[vol];			/* Get current fs object */
    0167F E086      LDI	R24,6
    01680 E095      LDI	R25,5
    01681 2FE0      MOV	R30,R16
    01682 27FF      CLR	R31
    01683 0FEE      LSL	R30
    01684 1FFF      ROL	R31
    01685 0FE8      ADD	R30,R24
    01686 1FF9      ADC	R31,R25
    01687 80A0      LD	R10,Z
    01688 80B1      LDD	R11,Z+1
(2214) 
(2215) 	if (rfs) {
    01689 20AA      TST	R10
    0168A F411      BNE	0x168D
    0168B 20BB      TST	R11
    0168C F019      BEQ	0x1690
(2216) #if _FS_SHARE
(2217) 		clear_lock(rfs);
(2218) #endif
(2219) #if _FS_REENTRANT				/* Discard sync object of the current volume */
(2220) 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
(2221) #endif
(2222) 		rfs->fs_type = 0;		/* Clear old fs object */
    0168D 2422      CLR	R2
    0168E 01F5      MOVW	R30,R10
    0168F 8220      ST	Z,R2
(2223) 	}
(2224) 
(2225) 	if (fs) {
    01690 3020      CPI	R18,0
    01691 0723      CPC	R18,R19
    01692 F019      BEQ	0x1696
(2226) 		fs->fs_type = 0;		/* Clear new fs object */
    01693 2422      CLR	R2
    01694 01F9      MOVW	R30,R18
    01695 8220      ST	Z,R2
(2227) #if _FS_REENTRANT				/* Create sync object for the new volume */
(2228) 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
(2229) #endif
(2230) 	}
(2231) 	FatFs[vol] = fs;			/* Register new fs object */
    01696 E086      LDI	R24,6
    01697 E095      LDI	R25,5
    01698 2FE0      MOV	R30,R16
    01699 27FF      CLR	R31
    0169A 0FEE      LSL	R30
    0169B 1FFF      ROL	R31
    0169C 0FE8      ADD	R30,R24
    0169D 1FF9      ADC	R31,R25
    0169E 8331      STD	Z+1,R19
    0169F 8320      ST	Z,R18
(2232) 
(2233) 	return FR_OK;
    016A0 2700      CLR	R16
    016A1 90B9      LD	R11,Y+
    016A2 90A9      LD	R10,Y+
    016A3 9508      RET
_f_open:
  cl                   --> Y,+40
  dw                   --> Y,+36
  sfn                  --> Y,+24
  dj                   --> Y,+2
  res                  --> R10
  dir                  --> R14
  mode                 --> Y,+58
  path                 --> Y,+56
  fp                   --> Y,+54
    016A4 940E 3F62 CALL	push_arg4
    016A6 940E 40A7 CALL	push_xgsetF0FC
    016A8 97AC      SBIW	R28,0x2C
(2234) }
(2235) 
(2236) 
(2237) 
(2238) 
(2239) /*-----------------------------------------------------------------------*/
(2240) /* Open or Create a File                                                 */
(2241) /*-----------------------------------------------------------------------*/
(2242) 
(2243) FRESULT f_open (
(2244) 	FIL *fp,			/* Pointer to the blank file object */
(2245) 	const TCHAR *path,	/* Pointer to the file name */
(2246) 	BYTE mode			/* Access mode and file open mode flags */
(2247) )
(2248) {
(2249) 	FRESULT res;
(2250) 	DIR dj;
(2251) 	BYTE *dir;
(2252) 	DEF_NAMEBUF;
(2253) 
(2254) 
(2255) 	fp->fs = 0;			/* Clear file object */
    016A9 2422      CLR	R2
    016AA 2433      CLR	R3
    016AB A9EE      LDD	R30,Y+54
    016AC A9FF      LDD	R31,Y+55
    016AD 8231      STD	Z+1,R3
    016AE 8220      ST	Z,R2
(2256) 
(2257) #if !_FS_READONLY
(2258) 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    016AF AD8A      LDD	R24,Y+58
    016B0 718F      ANDI	R24,0x1F
    016B1 AF8A      STD	Y+58,R24
(2259) 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    016B2 2799      CLR	R25
    016B3 7F8E      ANDI	R24,0xFE
    016B4 8388      ST	Y,R24
    016B5 019E      MOVW	R18,R28
    016B6 5F2E      SUBI	R18,0xFE
    016B7 4F3F      SBCI	R19,0xFF
    016B8 018E      MOVW	R16,R28
    016B9 5C08      SUBI	R16,0xC8
    016BA 4F1F      SBCI	R17,0xFF
    016BB DAA6      RCALL	ff.c:chk_mounted
    016BC 2EA0      MOV	R10,R16
(2260) #else
(2261) 	mode &= FA_READ;
(2262) 	res = chk_mounted(&path, &dj.fs, 0);
(2263) #endif
(2264) 	INIT_BUF(dj);
    016BD 01CE      MOVW	R24,R28
    016BE 9648      ADIW	R24,0x18
    016BF 8B9F      STD	Y+23,R25
    016C0 8B8E      STD	Y+22,R24
(2265) 	if (res == FR_OK)
    016C1 2300      TST	R16
    016C2 F439      BNE	0x16CA
(2266) 		res = follow_path(&dj, path);	/* Follow the file path */
    016C3 AD28      LDD	R18,Y+56
    016C4 AD39      LDD	R19,Y+57
    016C5 018E      MOVW	R16,R28
    016C6 5F0E      SUBI	R16,0xFE
    016C7 4F1F      SBCI	R17,0xFF
    016C8 D94D      RCALL	ff.c:follow_path
    016C9 2EA0      MOV	R10,R16
(2267) 	dir = dj.dir;
    016CA 88EC      LDD	R14,Y+20
    016CB 88FD      LDD	R15,Y+21
(2268) 
(2269) #if !_FS_READONLY	/* R/W configuration */
(2270) 	if (res == FR_OK) {
    016CC 20AA      TST	R10
    016CD F431      BNE	0x16D4
(2271) 		if (!dir)	/* Current dir itself */
    016CE 20EE      TST	R14
    016CF F421      BNE	0x16D4
    016D0 20FF      TST	R15
    016D1 F411      BNE	0x16D4
(2272) 			res = FR_INVALID_NAME;
    016D2 E086      LDI	R24,6
    016D3 2EA8      MOV	R10,R24
(2273) #if _FS_SHARE
(2274) 		else
(2275) 			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2276) #endif
(2277) 	}
(2278) 	/* Create or Open a file */
(2279) 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    016D4 AD8A      LDD	R24,Y+58
    016D5 718C      ANDI	R24,0x1C
    016D6 F409      BNE	0x16D8
    016D7 C0C0      RJMP	0x1798
(2280) 		DWORD dw, cl;
(2281) 
(2282) 		if (res != FR_OK) {					/* No file, create new */
    016D8 20AA      TST	R10
    016D9 F081      BEQ	0x16EA
(2283) 			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    016DA 2D8A      MOV	R24,R10
    016DB 3084      CPI	R24,4
    016DC F439      BNE	0x16E4
(2284) #if _FS_SHARE
(2285) 				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
(2286) #else
(2287) 				res = dir_register(&dj);
    016DD 018E      MOVW	R16,R28
    016DE 5F0E      SUBI	R16,0xFE
    016DF 4F1F      SBCI	R17,0xFF
    016E0 940E 0E08 CALL	ff.c:dir_register
    016E2 2EC0      MOV	R12,R16
    016E3 2CAC      MOV	R10,R12
(2288) #endif
(2289) 			mode |= FA_CREATE_ALWAYS;		/* File is created */
    016E4 AD8A      LDD	R24,Y+58
    016E5 6088      ORI	R24,0x8
    016E6 AF8A      STD	Y+58,R24
(2290) 			dir = dj.dir;					/* New entry */
    016E7 88EC      LDD	R14,Y+20
    016E8 88FD      LDD	R15,Y+21
(2291) 		}
    016E9 C00C      RJMP	0x16F6
(2292) 		else {								/* Any object is already existing */
(2293) 			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    016EA 01F7      MOVW	R30,R14
    016EB 8583      LDD	R24,Z+11
    016EC 7181      ANDI	R24,0x11
    016ED F019      BEQ	0x16F1
(2294) 				res = FR_DENIED;
    016EE E087      LDI	R24,7
    016EF 2EA8      MOV	R10,R24
(2295) 			} else {
    016F0 C005      RJMP	0x16F6
(2296) 				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    016F1 AC0A      LDD	R0,Y+58
    016F2 FE02      SBRS	R0,2
    016F3 C002      RJMP	0x16F6
(2297) 					res = FR_EXIST;
    016F4 E088      LDI	R24,0x8
    016F5 2EA8      MOV	R10,R24
(2298) 			}
(2299) 		}
(2300) 		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    016F6 20AA      TST	R10
    016F7 F009      BEQ	0x16F9
    016F8 C0B1      RJMP	0x17AA
    016F9 AC0A      LDD	R0,Y+58
    016FA FE03      SBRS	R0,3
    016FB C0AE      RJMP	0x17AA
(2301) 			dw = get_fattime();					/* Created time */
    016FC 940E 02E6 CALL	_get_fattime
    016FE A30C      STD	Y+36,R16
    016FF A31D      STD	Y+37,R17
    01700 A32E      STD	Y+38,R18
    01701 A33F      STD	Y+39,R19
(2302) 			ST_DWORD(dir+DIR_CrtTime, dw);
    01702 A02C      LDD	R2,Y+36
    01703 A03D      LDD	R3,Y+37
    01704 A04E      LDD	R4,Y+38
    01705 A05F      LDD	R5,Y+39
    01706 01F7      MOVW	R30,R14
    01707 8626      STD	Z+14,R2
    01708 2C23      MOV	R2,R3
    01709 2433      CLR	R3
    0170A 963F      ADIW	R30,0xF
    0170B 8220      ST	Z,R2
    0170C A02C      LDD	R2,Y+36
    0170D A03D      LDD	R3,Y+37
    0170E A04E      LDD	R4,Y+38
    0170F A05F      LDD	R5,Y+39
    01710 0112      MOVW	R2,R4
    01711 2444      CLR	R4
    01712 2455      CLR	R5
    01713 01F7      MOVW	R30,R14
    01714 9670      ADIW	R30,0x10
    01715 8220      ST	Z,R2
    01716 E188      LDI	R24,0x18
    01717 E090      LDI	R25,0
    01718 A10C      LDD	R16,Y+36
    01719 A11D      LDD	R17,Y+37
    0171A A12E      LDD	R18,Y+38
    0171B A13F      LDD	R19,Y+39
    0171C 938A      ST	-Y,R24
    0171D 940E 4142 CALL	lsr32
    0171F 01F7      MOVW	R30,R14
    01720 8B01      STD	Z+17,R16
(2303) 			dir[DIR_Attr] = 0;					/* Reset attribute */
    01721 2422      CLR	R2
    01722 8623      STD	Z+11,R2
(2304) 			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    01723 8E24      STD	Z+28,R2
    01724 8E25      STD	Z+29,R2
    01725 8E26      STD	Z+30,R2
    01726 8E27      STD	Z+31,R2
(2305) 			cl = LD_CLUST(dir);					/* Get start cluster */
    01727 8C22      LDD	R2,Z+26
    01728 2433      CLR	R3
    01729 8C43      LDD	R4,Z+27
    0172A 2455      CLR	R5
    0172B 2C54      MOV	R5,R4
    0172C 2444      CLR	R4
    0172D 2842      OR	R4,R2
    0172E 2853      OR	R5,R3
    0172F 0112      MOVW	R2,R4
    01730 2444      CLR	R4
    01731 2455      CLR	R5
    01732 8864      LDD	R6,Z+20
    01733 2477      CLR	R7
    01734 9675      ADIW	R30,0x15
    01735 8080      LD	R8,Z
    01736 2499      CLR	R9
    01737 2C98      MOV	R9,R8
    01738 2488      CLR	R8
    01739 2886      OR	R8,R6
    0173A 2897      OR	R9,R7
    0173B 0134      MOVW	R6,R8
    0173C 2488      CLR	R8
    0173D 2499      CLR	R9
    0173E 0143      MOVW	R8,R6
    0173F 2466      CLR	R6
    01740 2477      CLR	R7
    01741 2862      OR	R6,R2
    01742 2873      OR	R7,R3
    01743 2884      OR	R8,R4
    01744 2895      OR	R9,R5
    01745 A668      STD	Y+40,R6
    01746 A679      STD	Y+41,R7
    01747 A68A      STD	Y+42,R8
    01748 A69B      STD	Y+43,R9
(2306) 			ST_CLUST(dir, 0);					/* cluster = 0 */
    01749 2422      CLR	R2
    0174A 01F7      MOVW	R30,R14
    0174B 8E22      STD	Z+26,R2
    0174C 8E23      STD	Z+27,R2
    0174D 8A24      STD	Z+20,R2
    0174E 8A25      STD	Z+21,R2
(2307) 			dj.fs->wflag = 1;
    0174F E081      LDI	R24,1
    01750 81EA      LDD	R30,Y+2
    01751 81FB      LDD	R31,Y+3
    01752 9634      ADIW	R30,4
    01753 8380      ST	Z,R24
(2308) 			if (cl) {							/* Remove the cluster chain if exist */
    01754 A428      LDD	R2,Y+40
    01755 A439      LDD	R3,Y+41
    01756 A44A      LDD	R4,Y+42
    01757 A45B      LDD	R5,Y+43
    01758 9488      BCLR	0
    01759 2022      TST	R2
    0175A 0432      CPC	R3,R2
    0175B 0442      CPC	R4,R2
    0175C 0452      CPC	R5,R2
    0175D F409      BNE	0x175F
    0175E C04B      RJMP	0x17AA
(2309) 				dw = dj.fs->winsect;
    0175F 81EA      LDD	R30,Y+2
    01760 81FB      LDD	R31,Y+3
    01761 A422      LDD	R2,Z+42
    01762 A433      LDD	R3,Z+43
    01763 A444      LDD	R4,Z+44
    01764 A455      LDD	R5,Z+45
    01765 A22C      STD	Y+36,R2
    01766 A23D      STD	Y+37,R3
    01767 A24E      STD	Y+38,R4
    01768 A25F      STD	Y+39,R5
(2310) 				res = remove_chain(dj.fs, cl);
    01769 A428      LDD	R2,Y+40
    0176A A439      LDD	R3,Y+41
    0176B A44A      LDD	R4,Y+42
    0176C A45B      LDD	R5,Y+43
    0176D 8248      ST	Y,R4
    0176E 8259      STD	Y+1,R5
    0176F 0191      MOVW	R18,R2
    01770 810A      LDD	R16,Y+2
    01771 811B      LDD	R17,Y+3
    01772 940E 081C CALL	ff.c:remove_chain
    01774 2EC0      MOV	R12,R16
    01775 2CAC      MOV	R10,R12
(2311) 				if (res == FR_OK) {
    01776 2300      TST	R16
    01777 F591      BNE	0x17AA
(2312) 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    01778 E041      LDI	R20,1
    01779 E050      LDI	R21,0
    0177A E060      LDI	R22,0
    0177B E070      LDI	R23,0
    0177C A428      LDD	R2,Y+40
    0177D A439      LDD	R3,Y+41
    0177E A44A      LDD	R4,Y+42
    0177F A45B      LDD	R5,Y+43
    01780 1A24      SUB	R2,R20
    01781 0A35      SBC	R3,R21
    01782 0A46      SBC	R4,R22
    01783 0A57      SBC	R5,R23
    01784 81EA      LDD	R30,Y+2
    01785 81FB      LDD	R31,Y+3
    01786 8622      STD	Z+10,R2
    01787 8633      STD	Z+11,R3
    01788 8644      STD	Z+12,R4
    01789 8655      STD	Z+13,R5
(2313) 					res = move_window(dj.fs, dw);
    0178A A02C      LDD	R2,Y+36
    0178B A03D      LDD	R3,Y+37
    0178C A04E      LDD	R4,Y+38
    0178D A05F      LDD	R5,Y+39
    0178E 8248      ST	Y,R4
    0178F 8259      STD	Y+1,R5
    01790 0191      MOVW	R18,R2
    01791 810A      LDD	R16,Y+2
    01792 811B      LDD	R17,Y+3
    01793 940E 0344 CALL	ff.c:move_window
    01795 2EC0      MOV	R12,R16
    01796 2CAC      MOV	R10,R12
(2314) 				}
(2315) 			}
(2316) 		}
(2317) 	}
    01797 C012      RJMP	0x17AA
(2318) 	else {	/* Open an existing file */
(2319) 		if (res == FR_OK) {						/* Follow succeeded */
    01798 20AA      TST	R10
    01799 F481      BNE	0x17AA
(2320) 			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    0179A 01F7      MOVW	R30,R14
    0179B 8423      LDD	R2,Z+11
    0179C FE24      SBRS	R2,4
    0179D C003      RJMP	0x17A1
(2321) 				res = FR_NO_FILE;
    0179E E084      LDI	R24,4
    0179F 2EA8      MOV	R10,R24
(2322) 			} else {
    017A0 C009      RJMP	0x17AA
(2323) 				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    017A1 AC0A      LDD	R0,Y+58
    017A2 FE01      SBRS	R0,1
    017A3 C006      RJMP	0x17AA
    017A4 01F7      MOVW	R30,R14
    017A5 8423      LDD	R2,Z+11
    017A6 FE20      SBRS	R2,0
    017A7 C002      RJMP	0x17AA
(2324) 					res = FR_DENIED;
    017A8 E087      LDI	R24,7
    017A9 2EA8      MOV	R10,R24
(2325) 			}
(2326) 		}
(2327) 	}
(2328) 	if (res == FR_OK) {
    017AA 20AA      TST	R10
    017AB F4A1      BNE	0x17C0
(2329) 		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    017AC AC0A      LDD	R0,Y+58
    017AD FE03      SBRS	R0,3
    017AE C003      RJMP	0x17B2
(2330) 			mode |= FA__WRITTEN;
    017AF 2D80      MOV	R24,R0
    017B0 6280      ORI	R24,0x20
    017B1 AF8A      STD	Y+58,R24
(2331) 		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    017B2 81EA      LDD	R30,Y+2
    017B3 81FB      LDD	R31,Y+3
    017B4 A422      LDD	R2,Z+42
    017B5 A433      LDD	R3,Z+43
    017B6 A444      LDD	R4,Z+44
    017B7 A455      LDD	R5,Z+45
    017B8 A9EE      LDD	R30,Y+54
    017B9 A9FF      LDD	R31,Y+55
    017BA 8E22      STD	Z+26,R2
    017BB 8E33      STD	Z+27,R3
    017BC 8E44      STD	Z+28,R4
    017BD 8E55      STD	Z+29,R5
(2332) 		fp->dir_ptr = dir;
    017BE 8EF7      STD	Z+31,R15
    017BF 8EE6      STD	Z+30,R14
(2333) #if _FS_SHARE
(2334) 		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2335) 		if (!fp->lockid) res = FR_INT_ERR;
(2336) #endif
(2337) 	}
(2338) 
(2339) #else				/* R/O configuration */
(2340) 	if (res == FR_OK) {					/* Follow succeeded */
(2341) 		if (!dir) {						/* Current dir itself */
(2342) 			res = FR_INVALID_NAME;
(2343) 		} else {
(2344) 			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
(2345) 				res = FR_NO_FILE;
(2346) 		}
(2347) 	}
(2348) #endif
(2349) 	FREE_BUF();
(2350) 
(2351) 	if (res == FR_OK) {
    017C0 20AA      TST	R10
    017C1 F009      BEQ	0x17C3
    017C2 C077      RJMP	0x183A
(2352) 		fp->flag = mode;					/* File access mode */
    017C3 A9EE      LDD	R30,Y+54
    017C4 A9FF      LDD	R31,Y+55
    017C5 AC0A      LDD	R0,Y+58
    017C6 8204      STD	Z+4,R0
(2353) 		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    017C7 01F7      MOVW	R30,R14
    017C8 8C22      LDD	R2,Z+26
    017C9 2433      CLR	R3
    017CA 8C43      LDD	R4,Z+27
    017CB 2455      CLR	R5
    017CC 2C54      MOV	R5,R4
    017CD 2444      CLR	R4
    017CE 2842      OR	R4,R2
    017CF 2853      OR	R5,R3
    017D0 0112      MOVW	R2,R4
    017D1 2444      CLR	R4
    017D2 2455      CLR	R5
    017D3 8864      LDD	R6,Z+20
    017D4 2477      CLR	R7
    017D5 8885      LDD	R8,Z+21
    017D6 2499      CLR	R9
    017D7 2C98      MOV	R9,R8
    017D8 2488      CLR	R8
    017D9 2886      OR	R8,R6
    017DA 2897      OR	R9,R7
    017DB 0134      MOVW	R6,R8
    017DC 2488      CLR	R8
    017DD 2499      CLR	R9
    017DE 0143      MOVW	R8,R6
    017DF 2466      CLR	R6
    017E0 2477      CLR	R7
    017E1 2862      OR	R6,R2
    017E2 2873      OR	R7,R3
    017E3 2884      OR	R8,R4
    017E4 2895      OR	R9,R5
    017E5 A9EE      LDD	R30,Y+54
    017E6 A9FF      LDD	R31,Y+55
    017E7 8666      STD	Z+14,R6
    017E8 8677      STD	Z+15,R7
    017E9 8A80      STD	Z+16,R8
    017EA 8A91      STD	Z+17,R9
(2354) 		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    017EB E188      LDI	R24,0x18
    017EC E090      LDI	R25,0
    017ED 01F7      MOVW	R30,R14
    017EE 8D07      LDD	R16,Z+31
    017EF 2711      CLR	R17
    017F0 2722      CLR	R18
    017F1 2733      CLR	R19
    017F2 938A      ST	-Y,R24
    017F3 940E 4129 CALL	lsl32
    017F5 0118      MOVW	R2,R16
    017F6 0129      MOVW	R4,R18
    017F7 01F7      MOVW	R30,R14
    017F8 8C66      LDD	R6,Z+30
    017F9 2477      CLR	R7
    017FA 2488      CLR	R8
    017FB 2499      CLR	R9
    017FC 0143      MOVW	R8,R6
    017FD 2466      CLR	R6
    017FE 2477      CLR	R7
    017FF 2826      OR	R2,R6
    01800 2837      OR	R3,R7
    01801 2848      OR	R4,R8
    01802 2859      OR	R5,R9
    01803 8C65      LDD	R6,Z+29
    01804 2477      CLR	R7
    01805 2C76      MOV	R7,R6
    01806 2466      CLR	R6
    01807 2488      CLR	R8
    01808 2499      CLR	R9
    01809 2826      OR	R2,R6
    0180A 2837      OR	R3,R7
    0180B 2848      OR	R4,R8
    0180C 2859      OR	R5,R9
    0180D 8C64      LDD	R6,Z+28
    0180E 2477      CLR	R7
    0180F 2488      CLR	R8
    01810 2499      CLR	R9
    01811 2826      OR	R2,R6
    01812 2837      OR	R3,R7
    01813 2848      OR	R4,R8
    01814 2859      OR	R5,R9
    01815 A9EE      LDD	R30,Y+54
    01816 A9FF      LDD	R31,Y+55
    01817 8622      STD	Z+10,R2
    01818 8633      STD	Z+11,R3
    01819 8644      STD	Z+12,R4
    0181A 8655      STD	Z+13,R5
(2355) 		fp->fptr = 0;						/* File pointer */
    0181B 9636      ADIW	R30,6
    0181C E080      LDI	R24,0
    0181D 8380      ST	Z,R24
    0181E 8381      STD	Z+1,R24
    0181F 8382      STD	Z+2,R24
    01820 8383      STD	Z+3,R24
(2356) 		fp->dsect = 0;
    01821 A9EE      LDD	R30,Y+54
    01822 A9FF      LDD	R31,Y+55
    01823 9676      ADIW	R30,0x16
    01824 E080      LDI	R24,0
    01825 8380      ST	Z,R24
    01826 8381      STD	Z+1,R24
    01827 8382      STD	Z+2,R24
    01828 8383      STD	Z+3,R24
(2357) #if _USE_FASTSEEK
(2358) 		fp->cltbl = 0;						/* Normal seek mode */
    01829 2422      CLR	R2
    0182A 2433      CLR	R3
    0182B A9EE      LDD	R30,Y+54
    0182C A9FF      LDD	R31,Y+55
    0182D A231      STD	Z+33,R3
    0182E A220      STD	Z+32,R2
(2359) #endif
(2360) 		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    0182F 802A      LDD	R2,Y+2
    01830 803B      LDD	R3,Y+3
    01831 8231      STD	Z+1,R3
    01832 8220      ST	Z,R2
    01833 01F1      MOVW	R30,R2
    01834 8026      LDD	R2,Z+6
    01835 8037      LDD	R3,Z+7
    01836 A9EE      LDD	R30,Y+54
    01837 A9FF      LDD	R31,Y+55
    01838 8233      STD	Z+3,R3
    01839 8222      STD	Z+2,R2
(2361) 	}
(2362) 
(2363) 	LEAVE_FF(dj.fs, res);
    0183A 2D0A      MOV	R16,R10
    0183B 96AC      ADIW	R28,0x2C
    0183C 940E 409C CALL	pop_xgsetF0FC
    0183E 9624      ADIW	R28,4
    0183F 9508      RET
_f_read:
  remain               --> Y,+13
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  rbuff                --> R14
  sect                 --> Y,+5
  rcnt                 --> R12
  br                   --> Y,+33
  btr                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01840 940E 3F62 CALL	push_arg4
    01842 940E 40A7 CALL	push_xgsetF0FC
    01844 0159      MOVW	R10,R18
    01845 9761      SBIW	R28,0x11
(2364) }
(2365) 
(2366) 
(2367) 
(2368) 
(2369) /*-----------------------------------------------------------------------*/
(2370) /* Read File                                                             */
(2371) /*-----------------------------------------------------------------------*/
(2372) 
(2373) FRESULT f_read (
(2374) 	FIL *fp, 		/* Pointer to the file object */
(2375) 	void *buff,		/* Pointer to data buffer */
(2376) 	UINT btr,		/* Number of bytes to read */
(2377) 	UINT *br		/* Pointer to number of bytes read */
(2378) )
(2379) {
(2380) 	FRESULT res;
(2381) 	DWORD clst, sect, remain;
(2382) 	UINT rcnt, cc;
(2383) 	BYTE csect, *rbuff = buff;
    01846 0175      MOVW	R14,R10
(2384) 
(2385) 	memset(buff,0,512);
    01847 E080      LDI	R24,0
    01848 E092      LDI	R25,2
    01849 8399      STD	Y+1,R25
    0184A 8388      ST	Y,R24
    0184B 2722      CLR	R18
    0184C 2733      CLR	R19
    0184D 0185      MOVW	R16,R10
    0184E 940E 3F3E CALL	_memset
(2386) 
(2387) 	*br = 0;	/* Initialize byte counter */
    01850 2422      CLR	R2
    01851 2433      CLR	R3
    01852 A1E9      LDD	R30,Y+33
    01853 A1FA      LDD	R31,Y+34
    01854 8231      STD	Z+1,R3
    01855 8220      ST	Z,R2
(2388) 
(2389) 	res = validate(fp->fs, fp->id);				/* Check validity */
    01856 8DEB      LDD	R30,Y+27
    01857 8DFC      LDD	R31,Y+28
    01858 8122      LDD	R18,Z+2
    01859 8133      LDD	R19,Z+3
    0185A 8100      LD	R16,Z
    0185B 8111      LDD	R17,Z+1
    0185C DDFF      RCALL	ff.c:validate
    0185D 2EA0      MOV	R10,R16
(2390) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    0185E 2300      TST	R16
    0185F F009      BEQ	0x1861
    01860 C245      RJMP	0x1AA6
(2391) 	if (fp->flag & FA__ERROR)					/* Aborted file? */
    01861 8DEB      LDD	R30,Y+27
    01862 8DFC      LDD	R31,Y+28
    01863 8024      LDD	R2,Z+4
    01864 FE27      SBRS	R2,7
    01865 C002      RJMP	0x1868
(2392) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01866 E002      LDI	R16,2
    01867 C23E      RJMP	0x1AA6
(2393) 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    01868 8DEB      LDD	R30,Y+27
    01869 8DFC      LDD	R31,Y+28
    0186A 8024      LDD	R2,Z+4
    0186B FC20      SBRC	R2,0
    0186C C002      RJMP	0x186F
(2394) 		LEAVE_FF(fp->fs, FR_DENIED);
    0186D E007      LDI	R16,7
    0186E C237      RJMP	0x1AA6
(2395) 	remain = fp->fsize - fp->fptr;
    0186F 8DEB      LDD	R30,Y+27
    01870 8DFC      LDD	R31,Y+28
    01871 8026      LDD	R2,Z+6
    01872 8037      LDD	R3,Z+7
    01873 8440      LDD	R4,Z+8
    01874 8451      LDD	R5,Z+9
    01875 963A      ADIW	R30,0xA
    01876 8060      LD	R6,Z
    01877 8071      LDD	R7,Z+1
    01878 8082      LDD	R8,Z+2
    01879 8093      LDD	R9,Z+3
    0187A 1862      SUB	R6,R2
    0187B 0873      SBC	R7,R3
    0187C 0884      SBC	R8,R4
    0187D 0895      SBC	R9,R5
    0187E 866D      STD	Y+13,R6
    0187F 867E      STD	Y+14,R7
    01880 868F      STD	Y+15,R8
    01881 8A98      STD	Y+16,R9
(2396) 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    01882 842D      LDD	R2,Y+13
    01883 843E      LDD	R3,Y+14
    01884 844F      LDD	R4,Y+15
    01885 8858      LDD	R5,Y+16
    01886 8C6F      LDD	R6,Y+31
    01887 A078      LDD	R7,Y+32
    01888 2488      CLR	R8
    01889 2499      CLR	R9
    0188A 1426      CP	R2,R6
    0188B 0437      CPC	R3,R7
    0188C 0448      CPC	R4,R8
    0188D 0459      CPC	R5,R9
    0188E F008      BCS	0x1890
    0188F C20D      RJMP	0x1A9D
    01890 A238      STD	Y+32,R3
    01891 8E2F      STD	Y+31,R2
(2397) 
(2398) 	for ( ;  btr;								/* Repeat until all data read */
    01892 C20A      RJMP	0x1A9D
(2399) 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
(2400) 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    01893 EF4F      LDI	R20,0xFF
    01894 E051      LDI	R21,1
    01895 E060      LDI	R22,0
    01896 E070      LDI	R23,0
    01897 8DEB      LDD	R30,Y+27
    01898 8DFC      LDD	R31,Y+28
    01899 9636      ADIW	R30,6
    0189A 8020      LD	R2,Z
    0189B 8031      LDD	R3,Z+1
    0189C 8042      LDD	R4,Z+2
    0189D 8053      LDD	R5,Z+3
    0189E 2224      AND	R2,R20
    0189F 2235      AND	R3,R21
    018A0 2246      AND	R4,R22
    018A1 2257      AND	R5,R23
    018A2 9488      BCLR	0
    018A3 2022      TST	R2
    018A4 0432      CPC	R3,R2
    018A5 0442      CPC	R4,R2
    018A6 0452      CPC	R5,R2
    018A7 F009      BEQ	0x18A9
    018A8 C180      RJMP	0x1A29
(2401) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    018A9 E089      LDI	R24,0x9
    018AA E090      LDI	R25,0
    018AB 8DEB      LDD	R30,Y+27
    018AC 8DFC      LDD	R31,Y+28
    018AD 8106      LDD	R16,Z+6
    018AE 8117      LDD	R17,Z+7
    018AF 8520      LDD	R18,Z+8
    018B0 8531      LDD	R19,Z+9
    018B1 938A      ST	-Y,R24
    018B2 940E 4142 CALL	lsr32
    018B4 0118      MOVW	R2,R16
    018B5 0129      MOVW	R4,R18
    018B6 8DEB      LDD	R30,Y+27
    018B7 8DFC      LDD	R31,Y+28
    018B8 93AF      PUSH	R26
    018B9 93BF      PUSH	R27
    018BA 81A0      LD	R26,Z
    018BB 81B1      LDD	R27,Z+1
    018BC 01FD      MOVW	R30,R26
    018BD 91BF      POP	R27
    018BE 91AF      POP	R26
    018BF 8182      LDD	R24,Z+2
    018C0 2799      CLR	R25
    018C1 9701      SBIW	R24,1
    018C2 013C      MOVW	R6,R24
    018C3 2488      CLR	R8
    018C4 FC77      SBRC	R7,7
    018C5 9480      COM	R8
    018C6 2499      CLR	R9
    018C7 FC87      SBRC	R8,7
    018C8 9490      COM	R9
    018C9 2026      AND	R2,R6
    018CA 2037      AND	R3,R7
    018CB 2048      AND	R4,R8
    018CC 2059      AND	R5,R9
    018CD 2CC2      MOV	R12,R2
(2402) 			if (!csect) {						/* On the cluster boundary? */
    018CE 2022      TST	R2
    018CF F009      BEQ	0x18D1
    018D0 C078      RJMP	0x1949
(2403) 				if (fp->fptr == 0) {			/* On the top of the file? */
    018D1 8DEB      LDD	R30,Y+27
    018D2 8DFC      LDD	R31,Y+28
    018D3 9636      ADIW	R30,6
    018D4 8020      LD	R2,Z
    018D5 8031      LDD	R3,Z+1
    018D6 8042      LDD	R4,Z+2
    018D7 8053      LDD	R5,Z+3
    018D8 9488      BCLR	0
    018D9 2022      TST	R2
    018DA 0432      CPC	R3,R2
    018DB 0442      CPC	R4,R2
    018DC 0452      CPC	R5,R2
    018DD F461      BNE	0x18EA
(2404) 					clst = fp->sclust;			/* Follow from the origin */
    018DE 8DEB      LDD	R30,Y+27
    018DF 8DFC      LDD	R31,Y+28
    018E0 963E      ADIW	R30,0xE
    018E1 8020      LD	R2,Z
    018E2 8031      LDD	R3,Z+1
    018E3 8042      LDD	R4,Z+2
    018E4 8053      LDD	R5,Z+3
    018E5 8629      STD	Y+9,R2
    018E6 863A      STD	Y+10,R3
    018E7 864B      STD	Y+11,R4
    018E8 865C      STD	Y+12,R5
(2405) 				} else {						/* Middle or end of the file */
    018E9 C028      RJMP	0x1912
(2406) #if _USE_FASTSEEK
(2407) 					if (fp->cltbl)
    018EA 8DEB      LDD	R30,Y+27
    018EB 8DFC      LDD	R31,Y+28
    018EC A020      LDD	R2,Z+32
    018ED A031      LDD	R3,Z+33
    018EE 2022      TST	R2
    018EF F411      BNE	0x18F2
    018F0 2033      TST	R3
    018F1 F079      BEQ	0x1901
(2408) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    018F2 8026      LDD	R2,Z+6
    018F3 8037      LDD	R3,Z+7
    018F4 8440      LDD	R4,Z+8
    018F5 8451      LDD	R5,Z+9
    018F6 8248      ST	Y,R4
    018F7 8259      STD	Y+1,R5
    018F8 0191      MOVW	R18,R2
    018F9 018F      MOVW	R16,R30
    018FA 940E 0A47 CALL	ff.c:clmt_clust
    018FC 8709      STD	Y+9,R16
    018FD 871A      STD	Y+10,R17
    018FE 872B      STD	Y+11,R18
    018FF 873C      STD	Y+12,R19
    01900 C011      RJMP	0x1912
(2409) 					else
(2410) #endif
(2411) 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    01901 8DEB      LDD	R30,Y+27
    01902 8DFC      LDD	R31,Y+28
    01903 8822      LDD	R2,Z+18
    01904 8833      LDD	R3,Z+19
    01905 8844      LDD	R4,Z+20
    01906 8855      LDD	R5,Z+21
    01907 8248      ST	Y,R4
    01908 8259      STD	Y+1,R5
    01909 0191      MOVW	R18,R2
    0190A 8100      LD	R16,Z
    0190B 8111      LDD	R17,Z+1
    0190C 940E 050D CALL	_get_fat
    0190E 8709      STD	Y+9,R16
    0190F 871A      STD	Y+10,R17
    01910 872B      STD	Y+11,R18
    01911 873C      STD	Y+12,R19
(2412) 				}
(2413) 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    01912 E042      LDI	R20,2
    01913 E050      LDI	R21,0
    01914 E060      LDI	R22,0
    01915 E070      LDI	R23,0
    01916 8429      LDD	R2,Y+9
    01917 843A      LDD	R3,Y+10
    01918 844B      LDD	R4,Y+11
    01919 845C      LDD	R5,Y+12
    0191A 1624      CP	R2,R20
    0191B 0635      CPC	R3,R21
    0191C 0646      CPC	R4,R22
    0191D 0657      CPC	R5,R23
    0191E F448      BCC	0x1928
    0191F 8D8B      LDD	R24,Y+27
    01920 8D9C      LDD	R25,Y+28
    01921 9604      ADIW	R24,4
    01922 01FC      MOVW	R30,R24
    01923 8180      LD	R24,Z
    01924 6880      ORI	R24,0x80
    01925 8380      ST	Z,R24
    01926 E002      LDI	R16,2
    01927 C17E      RJMP	0x1AA6
(2414) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01928 EF4F      LDI	R20,0xFF
    01929 EF5F      LDI	R21,0xFF
    0192A EF6F      LDI	R22,0xFF
    0192B EF7F      LDI	R23,0xFF
    0192C 8429      LDD	R2,Y+9
    0192D 843A      LDD	R3,Y+10
    0192E 844B      LDD	R4,Y+11
    0192F 845C      LDD	R5,Y+12
    01930 1624      CP	R2,R20
    01931 0635      CPC	R3,R21
    01932 0646      CPC	R4,R22
    01933 0657      CPC	R5,R23
    01934 F451      BNE	0x193F
    01935 8D8B      LDD	R24,Y+27
    01936 8D9C      LDD	R25,Y+28
    01937 9604      ADIW	R24,4
    01938 015C      MOVW	R10,R24
    01939 01FC      MOVW	R30,R24
    0193A 8180      LD	R24,Z
    0193B 6880      ORI	R24,0x80
    0193C 8380      ST	Z,R24
    0193D E001      LDI	R16,1
    0193E C167      RJMP	0x1AA6
(2415) 				fp->clust = clst;				/* Update current cluster */
    0193F 8429      LDD	R2,Y+9
    01940 843A      LDD	R3,Y+10
    01941 844B      LDD	R4,Y+11
    01942 845C      LDD	R5,Y+12
    01943 8DEB      LDD	R30,Y+27
    01944 8DFC      LDD	R31,Y+28
    01945 8A22      STD	Z+18,R2
    01946 8A33      STD	Z+19,R3
    01947 8A44      STD	Z+20,R4
    01948 8A55      STD	Z+21,R5
(2416) 			}
(2417) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01949 8DEB      LDD	R30,Y+27
    0194A 8DFC      LDD	R31,Y+28
    0194B 8822      LDD	R2,Z+18
    0194C 8833      LDD	R3,Z+19
    0194D 8844      LDD	R4,Z+20
    0194E 8855      LDD	R5,Z+21
    0194F 8248      ST	Y,R4
    01950 8259      STD	Y+1,R5
    01951 0191      MOVW	R18,R2
    01952 8100      LD	R16,Z
    01953 8111      LDD	R17,Z+1
    01954 940E 04BB CALL	_clust2sect
    01956 830D      STD	Y+5,R16
    01957 831E      STD	Y+6,R17
    01958 832F      STD	Y+7,R18
    01959 8738      STD	Y+8,R19
(2418) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    0195A 802D      LDD	R2,Y+5
    0195B 803E      LDD	R3,Y+6
    0195C 804F      LDD	R4,Y+7
    0195D 8458      LDD	R5,Y+8
    0195E 9488      BCLR	0
    0195F 2022      TST	R2
    01960 0432      CPC	R3,R2
    01961 0442      CPC	R4,R2
    01962 0452      CPC	R5,R2
    01963 F451      BNE	0x196E
    01964 8D8B      LDD	R24,Y+27
    01965 8D9C      LDD	R25,Y+28
    01966 9604      ADIW	R24,4
    01967 015C      MOVW	R10,R24
    01968 01FC      MOVW	R30,R24
    01969 8180      LD	R24,Z
    0196A 6880      ORI	R24,0x80
    0196B 8380      ST	Z,R24
    0196C E002      LDI	R16,2
    0196D C138      RJMP	0x1AA6
(2419) 			sect += csect;
    0196E 2C2C      MOV	R2,R12
    0196F 2433      CLR	R3
    01970 2444      CLR	R4
    01971 2455      CLR	R5
    01972 806D      LDD	R6,Y+5
    01973 807E      LDD	R7,Y+6
    01974 808F      LDD	R8,Y+7
    01975 8498      LDD	R9,Y+8
    01976 0C62      ADD	R6,R2
    01977 1C73      ADC	R7,R3
    01978 1C84      ADC	R8,R4
    01979 1C95      ADC	R9,R5
    0197A 826D      STD	Y+5,R6
    0197B 827E      STD	Y+6,R7
    0197C 828F      STD	Y+7,R8
    0197D 8698      STD	Y+8,R9
(2420) 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    0197E E029      LDI	R18,0x9
    0197F E030      LDI	R19,0
    01980 8D0F      LDD	R16,Y+31
    01981 A118      LDD	R17,Y+32
    01982 940E 413B CALL	lsr16
    01984 0158      MOVW	R10,R16
(2421) 			if (cc) {							/* Read maximum contiguous sectors directly */
    01985 3000      CPI	R16,0
    01986 0701      CPC	R16,R17
    01987 F409      BNE	0x1989
    01988 C096      RJMP	0x1A1F
(2422) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01989 2C2C      MOV	R2,R12
    0198A 2433      CLR	R3
    0198B 0E20      ADD	R2,R16
    0198C 1E31      ADC	R3,R17
    0198D 8DEB      LDD	R30,Y+27
    0198E 8DFC      LDD	R31,Y+28
    0198F 93AF      PUSH	R26
    01990 93BF      PUSH	R27
    01991 81A0      LD	R26,Z
    01992 81B1      LDD	R27,Z+1
    01993 01FD      MOVW	R30,R26
    01994 91BF      POP	R27
    01995 91AF      POP	R26
    01996 8042      LDD	R4,Z+2
    01997 2455      CLR	R5
    01998 1442      CP	R4,R2
    01999 0453      CPC	R5,R3
    0199A F478      BCC	0x19AA
(2423) 					cc = fp->fs->csize - csect;
    0199B 2C2C      MOV	R2,R12
    0199C 2433      CLR	R3
    0199D 8DEB      LDD	R30,Y+27
    0199E 8DFC      LDD	R31,Y+28
    0199F 93AF      PUSH	R26
    019A0 93BF      PUSH	R27
    019A1 81A0      LD	R26,Z
    019A2 81B1      LDD	R27,Z+1
    019A3 01FD      MOVW	R30,R26
    019A4 91BF      POP	R27
    019A5 91AF      POP	R26
    019A6 80A2      LDD	R10,Z+2
    019A7 24BB      CLR	R11
    019A8 18A2      SUB	R10,R2
    019A9 08B3      SBC	R11,R3
(2424) 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    019AA 82AC      STD	Y+4,R10
    019AB 802D      LDD	R2,Y+5
    019AC 803E      LDD	R3,Y+6
    019AD 804F      LDD	R4,Y+7
    019AE 8458      LDD	R5,Y+8
    019AF 8228      ST	Y,R2
    019B0 8239      STD	Y+1,R3
    019B1 824A      STD	Y+2,R4
    019B2 825B      STD	Y+3,R5
    019B3 0197      MOVW	R18,R14
    019B4 8DEB      LDD	R30,Y+27
    019B5 8DFC      LDD	R31,Y+28
    019B6 93AF      PUSH	R26
    019B7 93BF      PUSH	R27
    019B8 81A0      LD	R26,Z
    019B9 81B1      LDD	R27,Z+1
    019BA 01FD      MOVW	R30,R26
    019BB 91BF      POP	R27
    019BC 91AF      POP	R26
    019BD 8101      LDD	R16,Z+1
    019BE 940E 02A9 CALL	_disk_read
    019C0 2EC0      MOV	R12,R16
    019C1 2300      TST	R16
    019C2 F051      BEQ	0x19CD
(2425) 					ABORT(fp->fs, FR_DISK_ERR);
    019C3 8D8B      LDD	R24,Y+27
    019C4 8D9C      LDD	R25,Y+28
    019C5 9604      ADIW	R24,4
    019C6 016C      MOVW	R12,R24
    019C7 01FC      MOVW	R30,R24
    019C8 8180      LD	R24,Z
    019C9 6880      ORI	R24,0x80
    019CA 8380      ST	Z,R24
    019CB E001      LDI	R16,1
    019CC C0D9      RJMP	0x1AA6
(2426) #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
(2427) #if _FS_TINY
(2428) 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    019CD 8DEB      LDD	R30,Y+27
    019CE 8DFC      LDD	R31,Y+28
    019CF 80C0      LD	R12,Z
    019D0 80D1      LDD	R13,Z+1
    019D1 01F6      MOVW	R30,R12
    019D2 9634      ADIW	R30,4
    019D3 8020      LD	R2,Z
    019D4 2022      TST	R2
    019D5 F409      BNE	0x19D7
    019D6 C041      RJMP	0x1A18
    019D7 802D      LDD	R2,Y+5
    019D8 803E      LDD	R3,Y+6
    019D9 804F      LDD	R4,Y+7
    019DA 8458      LDD	R5,Y+8
    019DB 01F6      MOVW	R30,R12
    019DC A462      LDD	R6,Z+42
    019DD A473      LDD	R7,Z+43
    019DE A484      LDD	R8,Z+44
    019DF A495      LDD	R9,Z+45
    019E0 1862      SUB	R6,R2
    019E1 0873      SBC	R7,R3
    019E2 0884      SBC	R8,R4
    019E3 0895      SBC	R9,R5
    019E4 0115      MOVW	R2,R10
    019E5 2444      CLR	R4
    019E6 2455      CLR	R5
    019E7 1462      CP	R6,R2
    019E8 0473      CPC	R7,R3
    019E9 0484      CPC	R8,R4
    019EA 0495      CPC	R9,R5
    019EB F560      BCC	0x1A18
(2429) 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
    019EC E080      LDI	R24,0
    019ED E092      LDI	R25,2
    019EE 8399      STD	Y+1,R25
    019EF 8388      ST	Y,R24
    019F0 8DEB      LDD	R30,Y+27
    019F1 8DFC      LDD	R31,Y+28
    019F2 80C0      LD	R12,Z
    019F3 80D1      LDD	R13,Z+1
    019F4 0196      MOVW	R18,R12
    019F5 5D22      SUBI	R18,0xD2
    019F6 4F3F      SBCI	R19,0xFF
    019F7 802D      LDD	R2,Y+5
    019F8 803E      LDD	R3,Y+6
    019F9 804F      LDD	R4,Y+7
    019FA 8458      LDD	R5,Y+8
    019FB 01F6      MOVW	R30,R12
    019FC A462      LDD	R6,Z+42
    019FD A473      LDD	R7,Z+43
    019FE A484      LDD	R8,Z+44
    019FF A495      LDD	R9,Z+45
    01A00 1862      SUB	R6,R2
    01A01 0873      SBC	R7,R3
    01A02 0884      SBC	R8,R4
    01A03 0895      SBC	R9,R5
    01A04 E040      LDI	R20,0
    01A05 E052      LDI	R21,2
    01A06 E060      LDI	R22,0
    01A07 E070      LDI	R23,0
    01A08 932F      PUSH	R18
    01A09 933F      PUSH	R19
    01A0A 929A      ST	-Y,R9
    01A0B 928A      ST	-Y,R8
    01A0C 927A      ST	-Y,R7
    01A0D 926A      ST	-Y,R6
    01A0E 018A      MOVW	R16,R20
    01A0F 019B      MOVW	R18,R22
    01A10 940E 4053 CALL	empy32u|empy32s
    01A12 913F      POP	R19
    01A13 912F      POP	R18
    01A14 0D0E      ADD	R16,R14
    01A15 1D1F      ADC	R17,R15
    01A16 940E 02EB CALL	ff.c:mem_cpy
(2430) #else
(2431) 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
(2432) 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
(2433) #endif
(2434) #endif
(2435) 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    01A18 E000      LDI	R16,0
    01A19 E012      LDI	R17,2
    01A1A 0195      MOVW	R18,R10
    01A1B 940E 4043 CALL	empy16s
    01A1D 0168      MOVW	R12,R16
(2436) 				continue;
    01A1E C05A      RJMP	0x1A79
(2437) 			}
(2438) #if !_FS_TINY
(2439) 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
(2440) #if !_FS_READONLY
(2441) 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2442) 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2443) 						ABORT(fp->fs, FR_DISK_ERR);
(2444) 					fp->flag &= ~FA__DIRTY;
(2445) 				}
(2446) #endif
(2447) 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
(2448) 					ABORT(fp->fs, FR_DISK_ERR);
(2449) 			}
(2450) #endif
(2451) 			fp->dsect = sect;
    01A1F 802D      LDD	R2,Y+5
    01A20 803E      LDD	R3,Y+6
    01A21 804F      LDD	R4,Y+7
    01A22 8458      LDD	R5,Y+8
    01A23 8DEB      LDD	R30,Y+27
    01A24 8DFC      LDD	R31,Y+28
    01A25 8A26      STD	Z+22,R2
    01A26 8A37      STD	Z+23,R3
    01A27 8E40      STD	Z+24,R4
    01A28 8E51      STD	Z+25,R5
(2452) 		}
(2453) 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    01A29 EF4F      LDI	R20,0xFF
    01A2A E051      LDI	R21,1
    01A2B E060      LDI	R22,0
    01A2C E070      LDI	R23,0
    01A2D 8DEB      LDD	R30,Y+27
    01A2E 8DFC      LDD	R31,Y+28
    01A2F 8026      LDD	R2,Z+6
    01A30 8037      LDD	R3,Z+7
    01A31 8440      LDD	R4,Z+8
    01A32 8451      LDD	R5,Z+9
    01A33 2224      AND	R2,R20
    01A34 2235      AND	R3,R21
    01A35 2246      AND	R4,R22
    01A36 2257      AND	R5,R23
    01A37 E040      LDI	R20,0
    01A38 E052      LDI	R21,2
    01A39 E060      LDI	R22,0
    01A3A E070      LDI	R23,0
    01A3B 1942      SUB	R20,R2
    01A3C 0953      SBC	R21,R3
    01A3D 0964      SBC	R22,R4
    01A3E 0975      SBC	R23,R5
    01A3F 016A      MOVW	R12,R20
(2454) 		if (rcnt > btr) rcnt = btr;
    01A40 8C0F      LDD	R0,Y+31
    01A41 A018      LDD	R1,Y+32
    01A42 1604      CP	R0,R20
    01A43 0615      CPC	R1,R21
    01A44 F408      BCC	0x1A46
    01A45 0160      MOVW	R12,R0
(2455) #if _FS_TINY
(2456) 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    01A46 8DEB      LDD	R30,Y+27
    01A47 8DFC      LDD	R31,Y+28
    01A48 8826      LDD	R2,Z+22
    01A49 8837      LDD	R3,Z+23
    01A4A 8C40      LDD	R4,Z+24
    01A4B 8C51      LDD	R5,Z+25
    01A4C 8248      ST	Y,R4
    01A4D 8259      STD	Y+1,R5
    01A4E 0191      MOVW	R18,R2
    01A4F 8100      LD	R16,Z
    01A50 8111      LDD	R17,Z+1
    01A51 940E 0344 CALL	ff.c:move_window
    01A53 2EA0      MOV	R10,R16
    01A54 2300      TST	R16
    01A55 F051      BEQ	0x1A60
(2457) 			ABORT(fp->fs, FR_DISK_ERR);
    01A56 8D8B      LDD	R24,Y+27
    01A57 8D9C      LDD	R25,Y+28
    01A58 9604      ADIW	R24,4
    01A59 015C      MOVW	R10,R24
    01A5A 01FC      MOVW	R30,R24
    01A5B 8180      LD	R24,Z
    01A5C 6880      ORI	R24,0x80
    01A5D 8380      ST	Z,R24
    01A5E E001      LDI	R16,1
    01A5F C046      RJMP	0x1AA6
(2458) 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    01A60 82D9      STD	Y+1,R13
    01A61 82C8      ST	Y,R12
    01A62 EF4F      LDI	R20,0xFF
    01A63 E051      LDI	R21,1
    01A64 E060      LDI	R22,0
    01A65 E070      LDI	R23,0
    01A66 8DEB      LDD	R30,Y+27
    01A67 8DFC      LDD	R31,Y+28
    01A68 8026      LDD	R2,Z+6
    01A69 8037      LDD	R3,Z+7
    01A6A 8440      LDD	R4,Z+8
    01A6B 8451      LDD	R5,Z+9
    01A6C 2224      AND	R2,R20
    01A6D 2235      AND	R3,R21
    01A6E 2246      AND	R4,R22
    01A6F 2257      AND	R5,R23
    01A70 0191      MOVW	R18,R2
    01A71 8180      LD	R24,Z
    01A72 8191      LDD	R25,Z+1
    01A73 968E      ADIW	R24,0x2E
    01A74 0F28      ADD	R18,R24
    01A75 1F39      ADC	R19,R25
    01A76 0187      MOVW	R16,R14
    01A77 940E 02EB CALL	ff.c:mem_cpy
    01A79 0CEC      ADD	R14,R12
    01A7A 1CFD      ADC	R15,R13
    01A7B 8D8B      LDD	R24,Y+27
    01A7C 8D9C      LDD	R25,Y+28
    01A7D 9606      ADIW	R24,6
    01A7E 015C      MOVW	R10,R24
    01A7F 0116      MOVW	R2,R12
    01A80 2444      CLR	R4
    01A81 2455      CLR	R5
    01A82 01FC      MOVW	R30,R24
    01A83 8060      LD	R6,Z
    01A84 8071      LDD	R7,Z+1
    01A85 8082      LDD	R8,Z+2
    01A86 8093      LDD	R9,Z+3
    01A87 0C62      ADD	R6,R2
    01A88 1C73      ADC	R7,R3
    01A89 1C84      ADC	R8,R4
    01A8A 1C95      ADC	R9,R5
    01A8B 8260      ST	Z,R6
    01A8C 8271      STD	Z+1,R7
    01A8D 8282      STD	Z+2,R8
    01A8E 8293      STD	Z+3,R9
    01A8F A1E9      LDD	R30,Y+33
    01A90 A1FA      LDD	R31,Y+34
    01A91 8020      LD	R2,Z
    01A92 8031      LDD	R3,Z+1
    01A93 0C2C      ADD	R2,R12
    01A94 1C3D      ADC	R3,R13
    01A95 8231      STD	Z+1,R3
    01A96 8220      ST	Z,R2
    01A97 8C0F      LDD	R0,Y+31
    01A98 A018      LDD	R1,Y+32
    01A99 180C      SUB	R0,R12
    01A9A 081D      SBC	R1,R13
    01A9B A218      STD	Y+32,R1
    01A9C 8E0F      STD	Y+31,R0
    01A9D 8C0F      LDD	R0,Y+31
    01A9E A018      LDD	R1,Y+32
    01A9F 2000      TST	R0
    01AA0 F009      BEQ	0x1AA2
    01AA1 CDF1      RJMP	0x1893
    01AA2 2011      TST	R1
    01AA3 F009      BEQ	0x1AA5
    01AA4 CDEE      RJMP	0x1893
(2459) #else
(2460) 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
(2461) #endif
(2462) 	}
(2463) 
(2464) 	LEAVE_FF(fp->fs, FR_OK);
    01AA5 2700      CLR	R16
    01AA6 9661      ADIW	R28,0x11
    01AA7 940E 409C CALL	pop_xgsetF0FC
    01AA9 9624      ADIW	R28,4
    01AAA 9508      RET
_f_write:
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  wbuff                --> R14
  sect                 --> Y,+5
  wcnt                 --> R12
  bw                   --> Y,+33
  btw                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01AAB 940E 3F62 CALL	push_arg4
    01AAD 940E 40A7 CALL	push_xgsetF0FC
    01AAF 0159      MOVW	R10,R18
    01AB0 9761      SBIW	R28,0x11
(2465) }
(2466) 
(2467) 
(2468) 
(2469) 
(2470) #if !_FS_READONLY
(2471) /*-----------------------------------------------------------------------*/
(2472) /* Write File                                                            */
(2473) /*-----------------------------------------------------------------------*/
(2474) 
(2475) FRESULT f_write (
(2476) 	FIL *fp,			/* Pointer to the file object */
(2477) 	const void *buff,	/* Pointer to the data to be written */
(2478) 	UINT btw,			/* Number of bytes to write */
(2479) 	UINT *bw			/* Pointer to number of bytes written */
(2480) )
(2481) {
(2482) 	FRESULT res;
(2483) 	DWORD clst, sect;
(2484) 	UINT wcnt, cc;
(2485) 	const BYTE *wbuff = buff;
    01AB1 0175      MOVW	R14,R10
(2486) 	BYTE csect;
(2487) 
(2488) 
(2489) 	*bw = 0;	/* Initialize byte counter */
    01AB2 2422      CLR	R2
    01AB3 2433      CLR	R3
    01AB4 A1E9      LDD	R30,Y+33
    01AB5 A1FA      LDD	R31,Y+34
    01AB6 8231      STD	Z+1,R3
    01AB7 8220      ST	Z,R2
(2490) 
(2491) 	res = validate(fp->fs, fp->id);			/* Check validity */
    01AB8 8DEB      LDD	R30,Y+27
    01AB9 8DFC      LDD	R31,Y+28
    01ABA 8122      LDD	R18,Z+2
    01ABB 8133      LDD	R19,Z+3
    01ABC 8100      LD	R16,Z
    01ABD 8111      LDD	R17,Z+1
    01ABE DB9D      RCALL	ff.c:validate
    01ABF 2EA0      MOV	R10,R16
(2492) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01AC0 2300      TST	R16
    01AC1 F009      BEQ	0x1AC3
    01AC2 C2FC      RJMP	0x1DBF
(2493) 	if (fp->flag & FA__ERROR)				/* Aborted file? */
    01AC3 8DEB      LDD	R30,Y+27
    01AC4 8DFC      LDD	R31,Y+28
    01AC5 8024      LDD	R2,Z+4
    01AC6 FE27      SBRS	R2,7
    01AC7 C002      RJMP	0x1ACA
(2494) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01AC8 E002      LDI	R16,2
    01AC9 C2F5      RJMP	0x1DBF
(2495) 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    01ACA 8DEB      LDD	R30,Y+27
    01ACB 8DFC      LDD	R31,Y+28
    01ACC 8024      LDD	R2,Z+4
    01ACD FC21      SBRC	R2,1
    01ACE C002      RJMP	0x1AD1
(2496) 		LEAVE_FF(fp->fs, FR_DENIED);
    01ACF E007      LDI	R16,7
    01AD0 C2EE      RJMP	0x1DBF
(2497) 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    01AD1 8DEB      LDD	R30,Y+27
    01AD2 8DFC      LDD	R31,Y+28
    01AD3 963A      ADIW	R30,0xA
    01AD4 8020      LD	R2,Z
    01AD5 8031      LDD	R3,Z+1
    01AD6 8042      LDD	R4,Z+2
    01AD7 8053      LDD	R5,Z+3
    01AD8 862D      STD	Y+13,R2
    01AD9 863E      STD	Y+14,R3
    01ADA 864F      STD	Y+15,R4
    01ADB 8A58      STD	Y+16,R5
    01ADC 8C2F      LDD	R2,Y+31
    01ADD A038      LDD	R3,Y+32
    01ADE 2444      CLR	R4
    01ADF 2455      CLR	R5
    01AE0 846D      LDD	R6,Y+13
    01AE1 847E      LDD	R7,Y+14
    01AE2 848F      LDD	R8,Y+15
    01AE3 8898      LDD	R9,Y+16
    01AE4 0C62      ADD	R6,R2
    01AE5 1C73      ADC	R7,R3
    01AE6 1C84      ADC	R8,R4
    01AE7 1C95      ADC	R9,R5
    01AE8 842D      LDD	R2,Y+13
    01AE9 843E      LDD	R3,Y+14
    01AEA 844F      LDD	R4,Y+15
    01AEB 8858      LDD	R5,Y+16
    01AEC 1462      CP	R6,R2
    01AED 0473      CPC	R7,R3
    01AEE 0484      CPC	R8,R4
    01AEF 0495      CPC	R9,R5
    01AF0 F008      BCS	0x1AF2
    01AF1 C2A5      RJMP	0x1D97
    01AF2 2400      CLR	R0
    01AF3 2411      CLR	R1
    01AF4 A218      STD	Y+32,R1
    01AF5 8E0F      STD	Y+31,R0
(2498) 
(2499) 	for ( ;  btw;							/* Repeat until all data written */
    01AF6 C2A0      RJMP	0x1D97
(2500) 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
(2501) 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    01AF7 EF4F      LDI	R20,0xFF
    01AF8 E051      LDI	R21,1
    01AF9 E060      LDI	R22,0
    01AFA E070      LDI	R23,0
    01AFB 8DEB      LDD	R30,Y+27
    01AFC 8DFC      LDD	R31,Y+28
    01AFD 9636      ADIW	R30,6
    01AFE 8020      LD	R2,Z
    01AFF 8031      LDD	R3,Z+1
    01B00 8042      LDD	R4,Z+2
    01B01 8053      LDD	R5,Z+3
    01B02 2224      AND	R2,R20
    01B03 2235      AND	R3,R21
    01B04 2246      AND	R4,R22
    01B05 2257      AND	R5,R23
    01B06 9488      BCLR	0
    01B07 2022      TST	R2
    01B08 0432      CPC	R3,R2
    01B09 0442      CPC	R4,R2
    01B0A 0452      CPC	R5,R2
    01B0B F009      BEQ	0x1B0D
    01B0C C20B      RJMP	0x1D18
(2502) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01B0D E089      LDI	R24,0x9
    01B0E E090      LDI	R25,0
    01B0F 8DEB      LDD	R30,Y+27
    01B10 8DFC      LDD	R31,Y+28
    01B11 8106      LDD	R16,Z+6
    01B12 8117      LDD	R17,Z+7
    01B13 8520      LDD	R18,Z+8
    01B14 8531      LDD	R19,Z+9
    01B15 938A      ST	-Y,R24
    01B16 940E 4142 CALL	lsr32
    01B18 0118      MOVW	R2,R16
    01B19 0129      MOVW	R4,R18
    01B1A 8DEB      LDD	R30,Y+27
    01B1B 8DFC      LDD	R31,Y+28
    01B1C 93AF      PUSH	R26
    01B1D 93BF      PUSH	R27
    01B1E 81A0      LD	R26,Z
    01B1F 81B1      LDD	R27,Z+1
    01B20 01FD      MOVW	R30,R26
    01B21 91BF      POP	R27
    01B22 91AF      POP	R26
    01B23 8182      LDD	R24,Z+2
    01B24 2799      CLR	R25
    01B25 9701      SBIW	R24,1
    01B26 013C      MOVW	R6,R24
    01B27 2488      CLR	R8
    01B28 FC77      SBRC	R7,7
    01B29 9480      COM	R8
    01B2A 2499      CLR	R9
    01B2B FC87      SBRC	R8,7
    01B2C 9490      COM	R9
    01B2D 2026      AND	R2,R6
    01B2E 2037      AND	R3,R7
    01B2F 2048      AND	R4,R8
    01B30 2059      AND	R5,R9
    01B31 2CC2      MOV	R12,R2
(2503) 			if (!csect) {					/* On the cluster boundary? */
    01B32 2022      TST	R2
    01B33 F009      BEQ	0x1B35
    01B34 C0A5      RJMP	0x1BDA
(2504) 				if (fp->fptr == 0) {		/* On the top of the file? */
    01B35 8DEB      LDD	R30,Y+27
    01B36 8DFC      LDD	R31,Y+28
    01B37 9636      ADIW	R30,6
    01B38 8020      LD	R2,Z
    01B39 8031      LDD	R3,Z+1
    01B3A 8042      LDD	R4,Z+2
    01B3B 8053      LDD	R5,Z+3
    01B3C 9488      BCLR	0
    01B3D 2022      TST	R2
    01B3E 0432      CPC	R3,R2
    01B3F 0442      CPC	R4,R2
    01B40 0452      CPC	R5,R2
    01B41 F571      BNE	0x1B70
(2505) 					clst = fp->sclust;		/* Follow from the origin */
    01B42 8DEB      LDD	R30,Y+27
    01B43 8DFC      LDD	R31,Y+28
    01B44 963E      ADIW	R30,0xE
    01B45 8020      LD	R2,Z
    01B46 8031      LDD	R3,Z+1
    01B47 8042      LDD	R4,Z+2
    01B48 8053      LDD	R5,Z+3
    01B49 8629      STD	Y+9,R2
    01B4A 863A      STD	Y+10,R3
    01B4B 864B      STD	Y+11,R4
    01B4C 865C      STD	Y+12,R5
(2506) 					if (clst == 0)			/* When no cluster is allocated, */
    01B4D 8429      LDD	R2,Y+9
    01B4E 843A      LDD	R3,Y+10
    01B4F 844B      LDD	R4,Y+11
    01B50 845C      LDD	R5,Y+12
    01B51 9488      BCLR	0
    01B52 2022      TST	R2
    01B53 0432      CPC	R3,R2
    01B54 0442      CPC	R4,R2
    01B55 0452      CPC	R5,R2
    01B56 F009      BEQ	0x1B58
    01B57 C040      RJMP	0x1B98
(2507) 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    01B58 E040      LDI	R20,0
    01B59 E050      LDI	R21,0
    01B5A E060      LDI	R22,0
    01B5B E070      LDI	R23,0
    01B5C 8368      ST	Y,R22
    01B5D 8379      STD	Y+1,R23
    01B5E 019A      MOVW	R18,R20
    01B5F 8DEB      LDD	R30,Y+27
    01B60 8DFC      LDD	R31,Y+28
    01B61 8100      LD	R16,Z
    01B62 8111      LDD	R17,Z+1
    01B63 940E 08CF CALL	ff.c:create_chain
    01B65 8709      STD	Y+9,R16
    01B66 871A      STD	Y+10,R17
    01B67 872B      STD	Y+11,R18
    01B68 873C      STD	Y+12,R19
    01B69 8DEB      LDD	R30,Y+27
    01B6A 8DFC      LDD	R31,Y+28
    01B6B 8706      STD	Z+14,R16
    01B6C 8717      STD	Z+15,R17
    01B6D 8B20      STD	Z+16,R18
    01B6E 8B31      STD	Z+17,R19
(2508) 				} else {					/* Middle or end of the file */
    01B6F C028      RJMP	0x1B98
(2509) #if _USE_FASTSEEK
(2510) 					if (fp->cltbl)
    01B70 8DEB      LDD	R30,Y+27
    01B71 8DFC      LDD	R31,Y+28
    01B72 A020      LDD	R2,Z+32
    01B73 A031      LDD	R3,Z+33
    01B74 2022      TST	R2
    01B75 F411      BNE	0x1B78
    01B76 2033      TST	R3
    01B77 F079      BEQ	0x1B87
(2511) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    01B78 8026      LDD	R2,Z+6
    01B79 8037      LDD	R3,Z+7
    01B7A 8440      LDD	R4,Z+8
    01B7B 8451      LDD	R5,Z+9
    01B7C 8248      ST	Y,R4
    01B7D 8259      STD	Y+1,R5
    01B7E 0191      MOVW	R18,R2
    01B7F 018F      MOVW	R16,R30
    01B80 940E 0A47 CALL	ff.c:clmt_clust
    01B82 8709      STD	Y+9,R16
    01B83 871A      STD	Y+10,R17
    01B84 872B      STD	Y+11,R18
    01B85 873C      STD	Y+12,R19
    01B86 C011      RJMP	0x1B98
(2512) 					else
(2513) #endif
(2514) 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    01B87 8DEB      LDD	R30,Y+27
    01B88 8DFC      LDD	R31,Y+28
    01B89 8822      LDD	R2,Z+18
    01B8A 8833      LDD	R3,Z+19
    01B8B 8844      LDD	R4,Z+20
    01B8C 8855      LDD	R5,Z+21
    01B8D 8248      ST	Y,R4
    01B8E 8259      STD	Y+1,R5
    01B8F 0191      MOVW	R18,R2
    01B90 8100      LD	R16,Z
    01B91 8111      LDD	R17,Z+1
    01B92 940E 08CF CALL	ff.c:create_chain
    01B94 8709      STD	Y+9,R16
    01B95 871A      STD	Y+10,R17
    01B96 872B      STD	Y+11,R18
    01B97 873C      STD	Y+12,R19
(2515) 				}
(2516) 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    01B98 8429      LDD	R2,Y+9
    01B99 843A      LDD	R3,Y+10
    01B9A 844B      LDD	R4,Y+11
    01B9B 845C      LDD	R5,Y+12
    01B9C 9488      BCLR	0
    01B9D 2022      TST	R2
    01B9E 0432      CPC	R3,R2
    01B9F 0442      CPC	R4,R2
    01BA0 0452      CPC	R5,R2
    01BA1 F409      BNE	0x1BA3
    01BA2 C1FC      RJMP	0x1D9F
(2517) 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    01BA3 E041      LDI	R20,1
    01BA4 E050      LDI	R21,0
    01BA5 E060      LDI	R22,0
    01BA6 E070      LDI	R23,0
    01BA7 8429      LDD	R2,Y+9
    01BA8 843A      LDD	R3,Y+10
    01BA9 844B      LDD	R4,Y+11
    01BAA 845C      LDD	R5,Y+12
    01BAB 1624      CP	R2,R20
    01BAC 0635      CPC	R3,R21
    01BAD 0646      CPC	R4,R22
    01BAE 0657      CPC	R5,R23
    01BAF F449      BNE	0x1BB9
    01BB0 8D8B      LDD	R24,Y+27
    01BB1 8D9C      LDD	R25,Y+28
    01BB2 9604      ADIW	R24,4
    01BB3 01FC      MOVW	R30,R24
    01BB4 8180      LD	R24,Z
    01BB5 6880      ORI	R24,0x80
    01BB6 8380      ST	Z,R24
    01BB7 E002      LDI	R16,2
    01BB8 C206      RJMP	0x1DBF
(2518) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01BB9 EF4F      LDI	R20,0xFF
    01BBA EF5F      LDI	R21,0xFF
    01BBB EF6F      LDI	R22,0xFF
    01BBC EF7F      LDI	R23,0xFF
    01BBD 8429      LDD	R2,Y+9
    01BBE 843A      LDD	R3,Y+10
    01BBF 844B      LDD	R4,Y+11
    01BC0 845C      LDD	R5,Y+12
    01BC1 1624      CP	R2,R20
    01BC2 0635      CPC	R3,R21
    01BC3 0646      CPC	R4,R22
    01BC4 0657      CPC	R5,R23
    01BC5 F451      BNE	0x1BD0
    01BC6 8D8B      LDD	R24,Y+27
    01BC7 8D9C      LDD	R25,Y+28
    01BC8 9604      ADIW	R24,4
    01BC9 015C      MOVW	R10,R24
    01BCA 01FC      MOVW	R30,R24
    01BCB 8180      LD	R24,Z
    01BCC 6880      ORI	R24,0x80
    01BCD 8380      ST	Z,R24
    01BCE E001      LDI	R16,1
    01BCF C1EF      RJMP	0x1DBF
(2519) 				fp->clust = clst;			/* Update current cluster */
    01BD0 8429      LDD	R2,Y+9
    01BD1 843A      LDD	R3,Y+10
    01BD2 844B      LDD	R4,Y+11
    01BD3 845C      LDD	R5,Y+12
    01BD4 8DEB      LDD	R30,Y+27
    01BD5 8DFC      LDD	R31,Y+28
    01BD6 8A22      STD	Z+18,R2
    01BD7 8A33      STD	Z+19,R3
    01BD8 8A44      STD	Z+20,R4
    01BD9 8A55      STD	Z+21,R5
(2520) 			}
(2521) #if _FS_TINY
(2522) 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
    01BDA 8DEB      LDD	R30,Y+27
    01BDB 8DFC      LDD	R31,Y+28
    01BDC 80A0      LD	R10,Z
    01BDD 80B1      LDD	R11,Z+1
    01BDE 8826      LDD	R2,Z+22
    01BDF 8837      LDD	R3,Z+23
    01BE0 8C40      LDD	R4,Z+24
    01BE1 8C51      LDD	R5,Z+25
    01BE2 01F5      MOVW	R30,R10
    01BE3 A462      LDD	R6,Z+42
    01BE4 A473      LDD	R7,Z+43
    01BE5 A484      LDD	R8,Z+44
    01BE6 A495      LDD	R9,Z+45
    01BE7 1462      CP	R6,R2
    01BE8 0473      CPC	R7,R3
    01BE9 0484      CPC	R8,R4
    01BEA 0495      CPC	R9,R5
    01BEB F4B9      BNE	0x1C03
    01BEC E040      LDI	R20,0
    01BED E050      LDI	R21,0
    01BEE E060      LDI	R22,0
    01BEF E070      LDI	R23,0
    01BF0 8368      ST	Y,R22
    01BF1 8379      STD	Y+1,R23
    01BF2 019A      MOVW	R18,R20
    01BF3 018F      MOVW	R16,R30
    01BF4 940E 0344 CALL	ff.c:move_window
    01BF6 2EA0      MOV	R10,R16
    01BF7 2300      TST	R16
    01BF8 F051      BEQ	0x1C03
(2523) 				ABORT(fp->fs, FR_DISK_ERR);
    01BF9 8D8B      LDD	R24,Y+27
    01BFA 8D9C      LDD	R25,Y+28
    01BFB 9604      ADIW	R24,4
    01BFC 015C      MOVW	R10,R24
    01BFD 01FC      MOVW	R30,R24
    01BFE 8180      LD	R24,Z
    01BFF 6880      ORI	R24,0x80
    01C00 8380      ST	Z,R24
    01C01 E001      LDI	R16,1
    01C02 C1BC      RJMP	0x1DBF
(2524) #else
(2525) 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
(2526) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2527) 					ABORT(fp->fs, FR_DISK_ERR);
(2528) 				fp->flag &= ~FA__DIRTY;
(2529) 			}
(2530) #endif
(2531) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01C03 8DEB      LDD	R30,Y+27
    01C04 8DFC      LDD	R31,Y+28
    01C05 8822      LDD	R2,Z+18
    01C06 8833      LDD	R3,Z+19
    01C07 8844      LDD	R4,Z+20
    01C08 8855      LDD	R5,Z+21
    01C09 8248      ST	Y,R4
    01C0A 8259      STD	Y+1,R5
    01C0B 0191      MOVW	R18,R2
    01C0C 8100      LD	R16,Z
    01C0D 8111      LDD	R17,Z+1
    01C0E 940E 04BB CALL	_clust2sect
    01C10 830D      STD	Y+5,R16
    01C11 831E      STD	Y+6,R17
    01C12 832F      STD	Y+7,R18
    01C13 8738      STD	Y+8,R19
(2532) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01C14 802D      LDD	R2,Y+5
    01C15 803E      LDD	R3,Y+6
    01C16 804F      LDD	R4,Y+7
    01C17 8458      LDD	R5,Y+8
    01C18 9488      BCLR	0
    01C19 2022      TST	R2
    01C1A 0432      CPC	R3,R2
    01C1B 0442      CPC	R4,R2
    01C1C 0452      CPC	R5,R2
    01C1D F451      BNE	0x1C28
    01C1E 8D8B      LDD	R24,Y+27
    01C1F 8D9C      LDD	R25,Y+28
    01C20 9604      ADIW	R24,4
    01C21 015C      MOVW	R10,R24
    01C22 01FC      MOVW	R30,R24
    01C23 8180      LD	R24,Z
    01C24 6880      ORI	R24,0x80
    01C25 8380      ST	Z,R24
    01C26 E002      LDI	R16,2
    01C27 C197      RJMP	0x1DBF
(2533) 			sect += csect;
    01C28 2C2C      MOV	R2,R12
    01C29 2433      CLR	R3
    01C2A 2444      CLR	R4
    01C2B 2455      CLR	R5
    01C2C 806D      LDD	R6,Y+5
    01C2D 807E      LDD	R7,Y+6
    01C2E 808F      LDD	R8,Y+7
    01C2F 8498      LDD	R9,Y+8
    01C30 0C62      ADD	R6,R2
    01C31 1C73      ADC	R7,R3
    01C32 1C84      ADC	R8,R4
    01C33 1C95      ADC	R9,R5
    01C34 826D      STD	Y+5,R6
    01C35 827E      STD	Y+6,R7
    01C36 828F      STD	Y+7,R8
    01C37 8698      STD	Y+8,R9
(2534) 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    01C38 E029      LDI	R18,0x9
    01C39 E030      LDI	R19,0
    01C3A 8D0F      LDD	R16,Y+31
    01C3B A118      LDD	R17,Y+32
    01C3C 940E 413B CALL	lsr16
    01C3E 0158      MOVW	R10,R16
(2535) 			if (cc) {						/* Write maximum contiguous sectors directly */
    01C3F 3000      CPI	R16,0
    01C40 0701      CPC	R16,R17
    01C41 F409      BNE	0x1C43
    01C42 C097      RJMP	0x1CDA
(2536) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01C43 2C2C      MOV	R2,R12
    01C44 2433      CLR	R3
    01C45 0E20      ADD	R2,R16
    01C46 1E31      ADC	R3,R17
    01C47 8DEB      LDD	R30,Y+27
    01C48 8DFC      LDD	R31,Y+28
    01C49 93AF      PUSH	R26
    01C4A 93BF      PUSH	R27
    01C4B 81A0      LD	R26,Z
    01C4C 81B1      LDD	R27,Z+1
    01C4D 01FD      MOVW	R30,R26
    01C4E 91BF      POP	R27
    01C4F 91AF      POP	R26
    01C50 8042      LDD	R4,Z+2
    01C51 2455      CLR	R5
    01C52 1442      CP	R4,R2
    01C53 0453      CPC	R5,R3
    01C54 F478      BCC	0x1C64
(2537) 					cc = fp->fs->csize - csect;
    01C55 2C2C      MOV	R2,R12
    01C56 2433      CLR	R3
    01C57 8DEB      LDD	R30,Y+27
    01C58 8DFC      LDD	R31,Y+28
    01C59 93AF      PUSH	R26
    01C5A 93BF      PUSH	R27
    01C5B 81A0      LD	R26,Z
    01C5C 81B1      LDD	R27,Z+1
    01C5D 01FD      MOVW	R30,R26
    01C5E 91BF      POP	R27
    01C5F 91AF      POP	R26
    01C60 80A2      LDD	R10,Z+2
    01C61 24BB      CLR	R11
    01C62 18A2      SUB	R10,R2
    01C63 08B3      SBC	R11,R3
(2538) 				if (disk_write(fp->fs->drv,(char*)wbuff, sect, (BYTE)cc) != RES_OK)
    01C64 82AC      STD	Y+4,R10
    01C65 802D      LDD	R2,Y+5
    01C66 803E      LDD	R3,Y+6
    01C67 804F      LDD	R4,Y+7
    01C68 8458      LDD	R5,Y+8
    01C69 8228      ST	Y,R2
    01C6A 8239      STD	Y+1,R3
    01C6B 824A      STD	Y+2,R4
    01C6C 825B      STD	Y+3,R5
    01C6D 0197      MOVW	R18,R14
    01C6E 8DEB      LDD	R30,Y+27
    01C6F 8DFC      LDD	R31,Y+28
    01C70 93AF      PUSH	R26
    01C71 93BF      PUSH	R27
    01C72 81A0      LD	R26,Z
    01C73 81B1      LDD	R27,Z+1
    01C74 01FD      MOVW	R30,R26
    01C75 91BF      POP	R27
    01C76 91AF      POP	R26
    01C77 8101      LDD	R16,Z+1
    01C78 940E 02C9 CALL	_disk_write
    01C7A 2EC0      MOV	R12,R16
    01C7B 2300      TST	R16
    01C7C F051      BEQ	0x1C87
(2539) 					ABORT(fp->fs, FR_DISK_ERR);
    01C7D 8D8B      LDD	R24,Y+27
    01C7E 8D9C      LDD	R25,Y+28
    01C7F 9604      ADIW	R24,4
    01C80 016C      MOVW	R12,R24
    01C81 01FC      MOVW	R30,R24
    01C82 8180      LD	R24,Z
    01C83 6880      ORI	R24,0x80
    01C84 8380      ST	Z,R24
    01C85 E001      LDI	R16,1
    01C86 C138      RJMP	0x1DBF
(2540) #if _FS_TINY
(2541) 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
    01C87 802D      LDD	R2,Y+5
    01C88 803E      LDD	R3,Y+6
    01C89 804F      LDD	R4,Y+7
    01C8A 8458      LDD	R5,Y+8
    01C8B 8DEB      LDD	R30,Y+27
    01C8C 8DFC      LDD	R31,Y+28
    01C8D 81A0      LD	R26,Z
    01C8E 81B1      LDD	R27,Z+1
    01C8F 969A      ADIW	R26,0x2A
    01C90 906D      LD	R6,X+
    01C91 907D      LD	R7,X+
    01C92 908D      LD	R8,X+
    01C93 909C      LD	R9,X
    01C94 1862      SUB	R6,R2
    01C95 0873      SBC	R7,R3
    01C96 0884      SBC	R8,R4
    01C97 0895      SBC	R9,R5
    01C98 0115      MOVW	R2,R10
    01C99 2444      CLR	R4
    01C9A 2455      CLR	R5
    01C9B 1462      CP	R6,R2
    01C9C 0473      CPC	R7,R3
    01C9D 0484      CPC	R8,R4
    01C9E 0495      CPC	R9,R5
    01C9F F008      BCS	0x1CA1
    01CA0 C032      RJMP	0x1CD3
(2542) 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
    01CA1 E080      LDI	R24,0
    01CA2 E092      LDI	R25,2
    01CA3 8399      STD	Y+1,R25
    01CA4 8388      ST	Y,R24
    01CA5 80C0      LD	R12,Z
    01CA6 80D1      LDD	R13,Z+1
    01CA7 802D      LDD	R2,Y+5
    01CA8 803E      LDD	R3,Y+6
    01CA9 804F      LDD	R4,Y+7
    01CAA 8458      LDD	R5,Y+8
    01CAB 01F6      MOVW	R30,R12
    01CAC A462      LDD	R6,Z+42
    01CAD A473      LDD	R7,Z+43
    01CAE A484      LDD	R8,Z+44
    01CAF A495      LDD	R9,Z+45
    01CB0 1862      SUB	R6,R2
    01CB1 0873      SBC	R7,R3
    01CB2 0884      SBC	R8,R4
    01CB3 0895      SBC	R9,R5
    01CB4 E040      LDI	R20,0
    01CB5 E052      LDI	R21,2
    01CB6 E060      LDI	R22,0
    01CB7 E070      LDI	R23,0
    01CB8 929A      ST	-Y,R9
    01CB9 928A      ST	-Y,R8
    01CBA 927A      ST	-Y,R7
    01CBB 926A      ST	-Y,R6
    01CBC 018A      MOVW	R16,R20
    01CBD 019B      MOVW	R18,R22
    01CBE 940E 4053 CALL	empy32u|empy32s
    01CC0 0198      MOVW	R18,R16
    01CC1 0D2E      ADD	R18,R14
    01CC2 1D3F      ADC	R19,R15
    01CC3 0186      MOVW	R16,R12
    01CC4 5D02      SUBI	R16,0xD2
    01CC5 4F1F      SBCI	R17,0xFF
    01CC6 940E 02EB CALL	ff.c:mem_cpy
(2543) 					fp->fs->wflag = 0;
    01CC8 2422      CLR	R2
    01CC9 8DEB      LDD	R30,Y+27
    01CCA 8DFC      LDD	R31,Y+28
    01CCB 93AF      PUSH	R26
    01CCC 93BF      PUSH	R27
    01CCD 81A0      LD	R26,Z
    01CCE 81B1      LDD	R27,Z+1
    01CCF 01FD      MOVW	R30,R26
    01CD0 91BF      POP	R27
    01CD1 91AF      POP	R26
    01CD2 8224      STD	Z+4,R2
(2544) 				}
(2545) #else
(2546) 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
(2547) 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
(2548) 					fp->flag &= ~FA__DIRTY;
(2549) 				}
(2550) #endif
(2551) 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    01CD3 E000      LDI	R16,0
    01CD4 E012      LDI	R17,2
    01CD5 0195      MOVW	R18,R10
    01CD6 940E 4043 CALL	empy16s
    01CD8 0168      MOVW	R12,R16
(2552) 				continue;
    01CD9 C099      RJMP	0x1D73
(2553) 			}
(2554) #if _FS_TINY
(2555) 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
    01CDA 8DEB      LDD	R30,Y+27
    01CDB 8DFC      LDD	R31,Y+28
    01CDC 8422      LDD	R2,Z+10
    01CDD 8433      LDD	R3,Z+11
    01CDE 8444      LDD	R4,Z+12
    01CDF 8455      LDD	R5,Z+13
    01CE0 8066      LDD	R6,Z+6
    01CE1 8077      LDD	R7,Z+7
    01CE2 8480      LDD	R8,Z+8
    01CE3 8491      LDD	R9,Z+9
    01CE4 1462      CP	R6,R2
    01CE5 0473      CPC	R7,R3
    01CE6 0484      CPC	R8,R4
    01CE7 0495      CPC	R9,R5
    01CE8 F128      BCS	0x1D0E
(2556) 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    01CE9 E040      LDI	R20,0
    01CEA E050      LDI	R21,0
    01CEB E060      LDI	R22,0
    01CEC E070      LDI	R23,0
    01CED 8368      ST	Y,R22
    01CEE 8379      STD	Y+1,R23
    01CEF 019A      MOVW	R18,R20
    01CF0 8100      LD	R16,Z
    01CF1 8111      LDD	R17,Z+1
    01CF2 940E 0344 CALL	ff.c:move_window
    01CF4 2EA0      MOV	R10,R16
    01CF5 2300      TST	R16
    01CF6 F051      BEQ	0x1D01
    01CF7 8D8B      LDD	R24,Y+27
    01CF8 8D9C      LDD	R25,Y+28
    01CF9 9604      ADIW	R24,4
    01CFA 015C      MOVW	R10,R24
    01CFB 01FC      MOVW	R30,R24
    01CFC 8180      LD	R24,Z
    01CFD 6880      ORI	R24,0x80
    01CFE 8380      ST	Z,R24
    01CFF E001      LDI	R16,1
    01D00 C0BE      RJMP	0x1DBF
(2557) 				fp->fs->winsect = sect;
    01D01 802D      LDD	R2,Y+5
    01D02 803E      LDD	R3,Y+6
    01D03 804F      LDD	R4,Y+7
    01D04 8458      LDD	R5,Y+8
    01D05 8DEB      LDD	R30,Y+27
    01D06 8DFC      LDD	R31,Y+28
    01D07 81A0      LD	R26,Z
    01D08 81B1      LDD	R27,Z+1
    01D09 969A      ADIW	R26,0x2A
    01D0A 922D      ST	X+,R2
    01D0B 923D      ST	X+,R3
    01D0C 924D      ST	X+,R4
    01D0D 925C      ST	X,R5
(2558) 			}
(2559) #else
(2560) 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
(2561) 				if (fp->fptr < fp->fsize &&
(2562) 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
(2563) 						ABORT(fp->fs, FR_DISK_ERR);
(2564) 			}
(2565) #endif
(2566) 			fp->dsect = sect;
    01D0E 802D      LDD	R2,Y+5
    01D0F 803E      LDD	R3,Y+6
    01D10 804F      LDD	R4,Y+7
    01D11 8458      LDD	R5,Y+8
    01D12 8DEB      LDD	R30,Y+27
    01D13 8DFC      LDD	R31,Y+28
    01D14 8A26      STD	Z+22,R2
    01D15 8A37      STD	Z+23,R3
    01D16 8E40      STD	Z+24,R4
    01D17 8E51      STD	Z+25,R5
(2567) 		}
(2568) 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    01D18 EF4F      LDI	R20,0xFF
    01D19 E051      LDI	R21,1
    01D1A E060      LDI	R22,0
    01D1B E070      LDI	R23,0
    01D1C 8DEB      LDD	R30,Y+27
    01D1D 8DFC      LDD	R31,Y+28
    01D1E 8026      LDD	R2,Z+6
    01D1F 8037      LDD	R3,Z+7
    01D20 8440      LDD	R4,Z+8
    01D21 8451      LDD	R5,Z+9
    01D22 2224      AND	R2,R20
    01D23 2235      AND	R3,R21
    01D24 2246      AND	R4,R22
    01D25 2257      AND	R5,R23
    01D26 E040      LDI	R20,0
    01D27 E052      LDI	R21,2
    01D28 E060      LDI	R22,0
    01D29 E070      LDI	R23,0
    01D2A 1942      SUB	R20,R2
    01D2B 0953      SBC	R21,R3
    01D2C 0964      SBC	R22,R4
    01D2D 0975      SBC	R23,R5
    01D2E 016A      MOVW	R12,R20
(2569) 		if (wcnt > btw) wcnt = btw;
    01D2F 8C0F      LDD	R0,Y+31
    01D30 A018      LDD	R1,Y+32
    01D31 1604      CP	R0,R20
    01D32 0615      CPC	R1,R21
    01D33 F408      BCC	0x1D35
    01D34 0160      MOVW	R12,R0
(2570) #if _FS_TINY
(2571) 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
    01D35 8DEB      LDD	R30,Y+27
    01D36 8DFC      LDD	R31,Y+28
    01D37 8826      LDD	R2,Z+22
    01D38 8837      LDD	R3,Z+23
    01D39 8C40      LDD	R4,Z+24
    01D3A 8C51      LDD	R5,Z+25
    01D3B 8248      ST	Y,R4
    01D3C 8259      STD	Y+1,R5
    01D3D 0191      MOVW	R18,R2
    01D3E 8100      LD	R16,Z
    01D3F 8111      LDD	R17,Z+1
    01D40 940E 0344 CALL	ff.c:move_window
    01D42 2EA0      MOV	R10,R16
    01D43 2300      TST	R16
    01D44 F051      BEQ	0x1D4F
(2572) 			ABORT(fp->fs, FR_DISK_ERR);
    01D45 8D8B      LDD	R24,Y+27
    01D46 8D9C      LDD	R25,Y+28
    01D47 9604      ADIW	R24,4
    01D48 015C      MOVW	R10,R24
    01D49 01FC      MOVW	R30,R24
    01D4A 8180      LD	R24,Z
    01D4B 6880      ORI	R24,0x80
    01D4C 8380      ST	Z,R24
    01D4D E001      LDI	R16,1
    01D4E C070      RJMP	0x1DBF
(2573) 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    01D4F 82D9      STD	Y+1,R13
    01D50 82C8      ST	Y,R12
    01D51 0197      MOVW	R18,R14
    01D52 EF4F      LDI	R20,0xFF
    01D53 E051      LDI	R21,1
    01D54 E060      LDI	R22,0
    01D55 E070      LDI	R23,0
    01D56 8DEB      LDD	R30,Y+27
    01D57 8DFC      LDD	R31,Y+28
    01D58 8026      LDD	R2,Z+6
    01D59 8037      LDD	R3,Z+7
    01D5A 8440      LDD	R4,Z+8
    01D5B 8451      LDD	R5,Z+9
    01D5C 2224      AND	R2,R20
    01D5D 2235      AND	R3,R21
    01D5E 2246      AND	R4,R22
    01D5F 2257      AND	R5,R23
    01D60 0181      MOVW	R16,R2
    01D61 8180      LD	R24,Z
    01D62 8191      LDD	R25,Z+1
    01D63 968E      ADIW	R24,0x2E
    01D64 0F08      ADD	R16,R24
    01D65 1F19      ADC	R17,R25
    01D66 940E 02EB CALL	ff.c:mem_cpy
(2574) 		fp->fs->wflag = 1;
    01D68 E081      LDI	R24,1
    01D69 8DEB      LDD	R30,Y+27
    01D6A 8DFC      LDD	R31,Y+28
    01D6B 93AF      PUSH	R26
    01D6C 93BF      PUSH	R27
    01D6D 81A0      LD	R26,Z
    01D6E 81B1      LDD	R27,Z+1
    01D6F 01FD      MOVW	R30,R26
    01D70 91BF      POP	R27
    01D71 91AF      POP	R26
    01D72 8384      STD	Z+4,R24
    01D73 0CEC      ADD	R14,R12
    01D74 1CFD      ADC	R15,R13
    01D75 8D8B      LDD	R24,Y+27
    01D76 8D9C      LDD	R25,Y+28
    01D77 9606      ADIW	R24,6
    01D78 015C      MOVW	R10,R24
    01D79 0116      MOVW	R2,R12
    01D7A 2444      CLR	R4
    01D7B 2455      CLR	R5
    01D7C 01FC      MOVW	R30,R24
    01D7D 8060      LD	R6,Z
    01D7E 8071      LDD	R7,Z+1
    01D7F 8082      LDD	R8,Z+2
    01D80 8093      LDD	R9,Z+3
    01D81 0C62      ADD	R6,R2
    01D82 1C73      ADC	R7,R3
    01D83 1C84      ADC	R8,R4
    01D84 1C95      ADC	R9,R5
    01D85 8260      ST	Z,R6
    01D86 8271      STD	Z+1,R7
    01D87 8282      STD	Z+2,R8
    01D88 8293      STD	Z+3,R9
    01D89 A1E9      LDD	R30,Y+33
    01D8A A1FA      LDD	R31,Y+34
    01D8B 8020      LD	R2,Z
    01D8C 8031      LDD	R3,Z+1
    01D8D 0C2C      ADD	R2,R12
    01D8E 1C3D      ADC	R3,R13
    01D8F 8231      STD	Z+1,R3
    01D90 8220      ST	Z,R2
    01D91 8C0F      LDD	R0,Y+31
    01D92 A018      LDD	R1,Y+32
    01D93 180C      SUB	R0,R12
    01D94 081D      SBC	R1,R13
    01D95 A218      STD	Y+32,R1
    01D96 8E0F      STD	Y+31,R0
    01D97 8C0F      LDD	R0,Y+31
    01D98 A018      LDD	R1,Y+32
    01D99 2000      TST	R0
    01D9A F009      BEQ	0x1D9C
    01D9B CD5B      RJMP	0x1AF7
    01D9C 2011      TST	R1
    01D9D F009      BEQ	0x1D9F
    01D9E CD58      RJMP	0x1AF7
(2575) #else
(2576) 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
(2577) 		fp->flag |= FA__DIRTY;
(2578) #endif
(2579) 	}
(2580) 
(2581) 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    01D9F 8DEB      LDD	R30,Y+27
    01DA0 8DFC      LDD	R31,Y+28
    01DA1 8422      LDD	R2,Z+10
    01DA2 8433      LDD	R3,Z+11
    01DA3 8444      LDD	R4,Z+12
    01DA4 8455      LDD	R5,Z+13
    01DA5 8066      LDD	R6,Z+6
    01DA6 8077      LDD	R7,Z+7
    01DA7 8480      LDD	R8,Z+8
    01DA8 8491      LDD	R9,Z+9
    01DA9 1426      CP	R2,R6
    01DAA 0437      CPC	R3,R7
    01DAB 0448      CPC	R4,R8
    01DAC 0459      CPC	R5,R9
    01DAD F440      BCC	0x1DB6
    01DAE 8026      LDD	R2,Z+6
    01DAF 8037      LDD	R3,Z+7
    01DB0 8440      LDD	R4,Z+8
    01DB1 8451      LDD	R5,Z+9
    01DB2 8622      STD	Z+10,R2
    01DB3 8633      STD	Z+11,R3
    01DB4 8644      STD	Z+12,R4
    01DB5 8655      STD	Z+13,R5
(2582) 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    01DB6 8D8B      LDD	R24,Y+27
    01DB7 8D9C      LDD	R25,Y+28
    01DB8 9604      ADIW	R24,4
    01DB9 015C      MOVW	R10,R24
    01DBA 01FC      MOVW	R30,R24
    01DBB 8180      LD	R24,Z
    01DBC 6280      ORI	R24,0x20
    01DBD 8380      ST	Z,R24
(2583) 
(2584) 	LEAVE_FF(fp->fs, FR_OK);
    01DBE 2700      CLR	R16
    01DBF 9661      ADIW	R28,0x11
    01DC0 940E 409C CALL	pop_xgsetF0FC
    01DC2 9624      ADIW	R28,4
    01DC3 9508      RET
_f_sync:
  tim                  --> Y,+2
  dir                  --> R22
  res                  --> R10
  fp                   --> R20
    01DC4 940E 40E2 CALL	push_xgsetF03C
    01DC6 01A8      MOVW	R20,R16
    01DC7 9726      SBIW	R28,6
(2585) }
(2586) 
(2587) 
(2588) 
(2589) 
(2590) /*-----------------------------------------------------------------------*/
(2591) /* Synchronize the File Object                                           */
(2592) /*-----------------------------------------------------------------------*/
(2593) 
(2594) FRESULT f_sync (
(2595) 	FIL *fp		/* Pointer to the file object */
(2596) )
(2597) {
(2598) 	FRESULT res;
(2599) 	DWORD tim;
(2600) 	BYTE *dir;
(2601) 
(2602) 
(2603) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01DC8 01FA      MOVW	R30,R20
    01DC9 8122      LDD	R18,Z+2
    01DCA 8133      LDD	R19,Z+3
    01DCB 8100      LD	R16,Z
    01DCC 8111      LDD	R17,Z+1
    01DCD D88E      RCALL	ff.c:validate
    01DCE 2EA0      MOV	R10,R16
(2604) 	if (res == FR_OK) {
    01DCF 2300      TST	R16
    01DD0 F009      BEQ	0x1DD2
    01DD1 C09F      RJMP	0x1E71
(2605) 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    01DD2 01FA      MOVW	R30,R20
    01DD3 8024      LDD	R2,Z+4
    01DD4 FE25      SBRS	R2,5
    01DD5 C09B      RJMP	0x1E71
(2606) #if !_FS_TINY	/* Write-back dirty buffer */
(2607) 			if (fp->flag & FA__DIRTY) {
(2608) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2609) 					LEAVE_FF(fp->fs, FR_DISK_ERR);
(2610) 				fp->flag &= ~FA__DIRTY;
(2611) 			}
(2612) #endif
(2613) 			/* Update the directory entry */
(2614) 			res = move_window(fp->fs, fp->dir_sect);
    01DD6 8C22      LDD	R2,Z+26
    01DD7 8C33      LDD	R3,Z+27
    01DD8 8C44      LDD	R4,Z+28
    01DD9 8C55      LDD	R5,Z+29
    01DDA 8248      ST	Y,R4
    01DDB 8259      STD	Y+1,R5
    01DDC 0191      MOVW	R18,R2
    01DDD 8100      LD	R16,Z
    01DDE 8111      LDD	R17,Z+1
    01DDF 940E 0344 CALL	ff.c:move_window
    01DE1 2EA0      MOV	R10,R16
(2615) 			if (res == FR_OK) {
    01DE2 2300      TST	R16
    01DE3 F009      BEQ	0x1DE5
    01DE4 C08C      RJMP	0x1E71
(2616) 				dir = fp->dir_ptr;
    01DE5 01FA      MOVW	R30,R20
    01DE6 8D66      LDD	R22,Z+30
    01DE7 8D77      LDD	R23,Z+31
(2617) 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    01DE8 01CB      MOVW	R24,R22
    01DE9 960B      ADIW	R24,0xB
    01DEA 01FC      MOVW	R30,R24
    01DEB 8180      LD	R24,Z
    01DEC 6280      ORI	R24,0x20
    01DED 8380      ST	Z,R24
(2618) 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    01DEE 01FA      MOVW	R30,R20
    01DEF 8422      LDD	R2,Z+10
    01DF0 8433      LDD	R3,Z+11
    01DF1 8444      LDD	R4,Z+12
    01DF2 8455      LDD	R5,Z+13
    01DF3 01FB      MOVW	R30,R22
    01DF4 8E24      STD	Z+28,R2
    01DF5 01FA      MOVW	R30,R20
    01DF6 8422      LDD	R2,Z+10
    01DF7 8433      LDD	R3,Z+11
    01DF8 2C23      MOV	R2,R3
    01DF9 2433      CLR	R3
    01DFA 01FB      MOVW	R30,R22
    01DFB 8E25      STD	Z+29,R2
    01DFC 01FA      MOVW	R30,R20
    01DFD 8422      LDD	R2,Z+10
    01DFE 8433      LDD	R3,Z+11
    01DFF 8444      LDD	R4,Z+12
    01E00 8455      LDD	R5,Z+13
    01E01 0112      MOVW	R2,R4
    01E02 2444      CLR	R4
    01E03 2455      CLR	R5
    01E04 01FB      MOVW	R30,R22
    01E05 8E26      STD	Z+30,R2
    01E06 E188      LDI	R24,0x18
    01E07 E090      LDI	R25,0
    01E08 01FA      MOVW	R30,R20
    01E09 8502      LDD	R16,Z+10
    01E0A 8513      LDD	R17,Z+11
    01E0B 8524      LDD	R18,Z+12
    01E0C 8535      LDD	R19,Z+13
    01E0D 938A      ST	-Y,R24
    01E0E 940E 4142 CALL	lsr32
    01E10 01FB      MOVW	R30,R22
    01E11 8F07      STD	Z+31,R16
(2619) 				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    01E12 01FA      MOVW	R30,R20
    01E13 8426      LDD	R2,Z+14
    01E14 8437      LDD	R3,Z+15
    01E15 8840      LDD	R4,Z+16
    01E16 8851      LDD	R5,Z+17
    01E17 01FB      MOVW	R30,R22
    01E18 8E22      STD	Z+26,R2
    01E19 01FA      MOVW	R30,R20
    01E1A 8426      LDD	R2,Z+14
    01E1B 8437      LDD	R3,Z+15
    01E1C 2C23      MOV	R2,R3
    01E1D 2433      CLR	R3
    01E1E 01FB      MOVW	R30,R22
    01E1F 8E23      STD	Z+27,R2
    01E20 01FA      MOVW	R30,R20
    01E21 8426      LDD	R2,Z+14
    01E22 8437      LDD	R3,Z+15
    01E23 8840      LDD	R4,Z+16
    01E24 8851      LDD	R5,Z+17
    01E25 0112      MOVW	R2,R4
    01E26 2444      CLR	R4
    01E27 2455      CLR	R5
    01E28 01FB      MOVW	R30,R22
    01E29 8A24      STD	Z+20,R2
    01E2A 01FA      MOVW	R30,R20
    01E2B 8426      LDD	R2,Z+14
    01E2C 8437      LDD	R3,Z+15
    01E2D 8840      LDD	R4,Z+16
    01E2E 8851      LDD	R5,Z+17
    01E2F 0112      MOVW	R2,R4
    01E30 2C23      MOV	R2,R3
    01E31 2433      CLR	R3
    01E32 01FB      MOVW	R30,R22
    01E33 8A25      STD	Z+21,R2
(2620) 				tim = get_fattime();						/* Update updated time */
    01E34 940E 02E6 CALL	_get_fattime
    01E36 830A      STD	Y+2,R16
    01E37 831B      STD	Y+3,R17
    01E38 832C      STD	Y+4,R18
    01E39 833D      STD	Y+5,R19
(2621) 				ST_DWORD(dir+DIR_WrtTime, tim);
    01E3A 802A      LDD	R2,Y+2
    01E3B 803B      LDD	R3,Y+3
    01E3C 804C      LDD	R4,Y+4
    01E3D 805D      LDD	R5,Y+5
    01E3E 01FB      MOVW	R30,R22
    01E3F 8A26      STD	Z+22,R2
    01E40 2C23      MOV	R2,R3
    01E41 2433      CLR	R3
    01E42 9677      ADIW	R30,0x17
    01E43 8220      ST	Z,R2
    01E44 802A      LDD	R2,Y+2
    01E45 803B      LDD	R3,Y+3
    01E46 804C      LDD	R4,Y+4
    01E47 805D      LDD	R5,Y+5
    01E48 0112      MOVW	R2,R4
    01E49 2444      CLR	R4
    01E4A 2455      CLR	R5
    01E4B 01FB      MOVW	R30,R22
    01E4C 9678      ADIW	R30,0x18
    01E4D 8220      ST	Z,R2
    01E4E E188      LDI	R24,0x18
    01E4F E090      LDI	R25,0
    01E50 810A      LDD	R16,Y+2
    01E51 811B      LDD	R17,Y+3
    01E52 812C      LDD	R18,Y+4
    01E53 813D      LDD	R19,Y+5
    01E54 938A      ST	-Y,R24
    01E55 940E 4142 CALL	lsr32
    01E57 01FB      MOVW	R30,R22
    01E58 8F01      STD	Z+25,R16
(2622) 				fp->flag &= ~FA__WRITTEN;
    01E59 01BA      MOVW	R22,R20
    01E5A 5F6C      SUBI	R22,0xFC
    01E5B 4F7F      SBCI	R23,0xFF
    01E5C 01FB      MOVW	R30,R22
    01E5D 8180      LD	R24,Z
    01E5E 7D8F      ANDI	R24,0xDF
    01E5F 8380      ST	Z,R24
(2623) 				fp->fs->wflag = 1;
    01E60 E081      LDI	R24,1
    01E61 01FA      MOVW	R30,R20
    01E62 93AF      PUSH	R26
    01E63 93BF      PUSH	R27
    01E64 81A0      LD	R26,Z
    01E65 81B1      LDD	R27,Z+1
    01E66 01FD      MOVW	R30,R26
    01E67 91BF      POP	R27
    01E68 91AF      POP	R26
    01E69 8384      STD	Z+4,R24
(2624) 				res = sync(fp->fs);
    01E6A 01FA      MOVW	R30,R20
    01E6B 8100      LD	R16,Z
    01E6C 8111      LDD	R17,Z+1
    01E6D 940E 03E6 CALL	ff.c:sync
    01E6F 2EC0      MOV	R12,R16
    01E70 2CAC      MOV	R10,R12
(2625) 			}
(2626) 		}
(2627) 	}
(2628) 
(2629) 	LEAVE_FF(fp->fs, res);
    01E71 2D0A      MOV	R16,R10
    01E72 9626      ADIW	R28,6
    01E73 940C 40EB JMP	pop_xgsetF03C
_f_close:
  res                  --> R10
  fp                   --> R12
    01E75 940E 40AD CALL	push_xgset003C
    01E77 0168      MOVW	R12,R16
(2630) }
(2631) 
(2632) #endif /* !_FS_READONLY */
(2633) 
(2634) 
(2635) 
(2636) 
(2637) /*-----------------------------------------------------------------------*/
(2638) /* Close File                                                            */
(2639) /*-----------------------------------------------------------------------*/
(2640) 
(2641) FRESULT f_close (
(2642) 	FIL *fp		/* Pointer to the file object to be closed */
(2643) )
(2644) {
(2645) 	FRESULT res;
(2646) 
(2647) #if _FS_READONLY
(2648) 	FATFS *fs = fp->fs;
(2649) 	res = validate(fs, fp->id);
(2650) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
(2651) 	LEAVE_FF(fs, res);
(2652) 
(2653) #else
(2654) 	res = f_sync(fp);		/* Flush cached data */
    01E78 0186      MOVW	R16,R12
    01E79 DF4A      RCALL	_f_sync
    01E7A 2EA0      MOV	R10,R16
(2655) #if _FS_SHARE
(2656) 	if (res == FR_OK) {		/* Decrement open counter */
(2657) #if _FS_REENTRANT
(2658) 		res = validate(fp->fs, fp->id);
(2659) 		if (res == FR_OK) {
(2660) 			res = dec_lock(fp->lockid);	
(2661) 			unlock_fs(fp->fs, FR_OK);
(2662) 		}
(2663) #else
(2664) 		res = dec_lock(fp->lockid);
(2665) #endif
(2666) 	}
(2667) #endif
(2668) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    01E7B 2300      TST	R16
    01E7C F429      BNE	0x1E82
    01E7D 2422      CLR	R2
    01E7E 2433      CLR	R3
    01E7F 01F6      MOVW	R30,R12
    01E80 8231      STD	Z+1,R3
    01E81 8220      ST	Z,R2
(2669) 	return res;
    01E82 2D0A      MOV	R16,R10
    01E83 940C 4087 JMP	pop_xgset003C
_f_lseek:
  ifptr                --> Y,+14
  nsect                --> Y,+10
  bcs                  --> Y,+6
  clst                 --> Y,+2
  dsc                  --> Y,+26
  tlen                 --> Y,+22
  tbl                  --> R14
  tcl                  --> Y,+18
  ulen                 --> Y,+14
  ncl                  --> Y,+10
  pcl                  --> Y,+6
  cl                   --> Y,+2
  res                  --> R10
  ofs                  --> Y,+42
  fp                   --> Y,+40
    01E85 940E 3F62 CALL	push_arg4
    01E87 940E 40A7 CALL	push_xgsetF0FC
    01E89 976E      SBIW	R28,0x1E
(2670) #endif
(2671) }
(2672) 
(2673) 
(2674) 
(2675) 
(2676) /*-----------------------------------------------------------------------*/
(2677) /* Current Drive/Directory Handlings                                     */
(2678) /*-----------------------------------------------------------------------*/
(2679) 
(2680) #if _FS_RPATH >= 1
(2681) 
(2682) FRESULT f_chdrive (
(2683) 	BYTE drv		/* Drive number */
(2684) )
(2685) {
(2686) 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
(2687) 
(2688) 	CurrVol = drv;
(2689) 
(2690) 	return FR_OK;
(2691) }
(2692) 
(2693) 
(2694) 
(2695) FRESULT f_chdir (
(2696) 	const TCHAR *path	/* Pointer to the directory path */
(2697) )
(2698) {
(2699) 	FRESULT res;
(2700) 	DIR dj;
(2701) 	DEF_NAMEBUF;
(2702) 
(2703) 
(2704) 	res = chk_mounted(&path, &dj.fs, 0);
(2705) 	if (res == FR_OK) {
(2706) 		INIT_BUF(dj);
(2707) 		res = follow_path(&dj, path);		/* Follow the path */
(2708) 		FREE_BUF();
(2709) 		if (res == FR_OK) {					/* Follow completed */
(2710) 			if (!dj.dir) {
(2711) 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
(2712) 			} else {
(2713) 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
(2714) 					dj.fs->cdir = LD_CLUST(dj.dir);
(2715) 				else
(2716) 					res = FR_NO_PATH;		/* Reached but a file */
(2717) 			}
(2718) 		}
(2719) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
(2720) 	}
(2721) 
(2722) 	LEAVE_FF(dj.fs, res);
(2723) }
(2724) 
(2725) 
(2726) #if _FS_RPATH >= 2
(2727) FRESULT f_getcwd (
(2728) 	TCHAR *path,	/* Pointer to the directory path */
(2729) 	UINT sz_path	/* Size of path */
(2730) )
(2731) {
(2732) 	FRESULT res;
(2733) 	DIR dj;
(2734) 	UINT i, n;
(2735) 	DWORD ccl;
(2736) 	TCHAR *tp;
(2737) 	FILINFO fno;
(2738) 	DEF_NAMEBUF;
(2739) 
(2740) 
(2741) 	*path = 0;
(2742) 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
(2743) 	if (res == FR_OK) {
(2744) 		INIT_BUF(dj);
(2745) 		i = sz_path;		/* Bottom of buffer (dir stack base) */
(2746) 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
(2747) 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
(2748) 			res = dir_sdi(&dj, 1);			/* Get parent dir */
(2749) 			if (res != FR_OK) break;
(2750) 			res = dir_read(&dj);
(2751) 			if (res != FR_OK) break;
(2752) 			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
(2753) 			res = dir_sdi(&dj, 0);
(2754) 			if (res != FR_OK) break;
(2755) 			do {							/* Find the entry links to the child dir */
(2756) 				res = dir_read(&dj);
(2757) 				if (res != FR_OK) break;
(2758) 				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
(2759) 				res = dir_next(&dj, 0);	
(2760) 			} while (res == FR_OK);
(2761) 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
(2762) 			if (res != FR_OK) break;
(2763) #if _USE_LFN
(2764) 			fno.lfname = path;
(2765) 			fno.lfsize = i;
(2766) #endif
(2767) 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
(2768) 			tp = fno.fname;
(2769) 			if (_USE_LFN && *path) tp = path;
(2770) 			for (n = 0; tp[n]; n++) ;
(2771) 			if (i < n + 3) {
(2772) 				res = FR_NOT_ENOUGH_CORE; break;
(2773) 			}
(2774) 			while (n) path[--i] = tp[--n];
(2775) 			path[--i] = '/';
(2776) 		}
(2777) 		tp = path;
(2778) 		if (res == FR_OK) {
(2779) 			*tp++ = '0' + CurrVol;			/* Put drive number */
(2780) 			*tp++ = ':';
(2781) 			if (i == sz_path) {				/* Root-dir */
(2782) 				*tp++ = '/';
(2783) 			} else {						/* Sub-dir */
(2784) 				do		/* Add stacked path str */
(2785) 					*tp++ = path[i++];
(2786) 				while (i < sz_path);
(2787) 			}
(2788) 		}
(2789) 		*tp = 0;
(2790) 		FREE_BUF();
(2791) 	}
(2792) 
(2793) 	LEAVE_FF(dj.fs, res);
(2794) }
(2795) #endif /* _FS_RPATH >= 2 */
(2796) #endif /* _FS_RPATH >= 1 */
(2797) 
(2798) 
(2799) 
(2800) #if _FS_MINIMIZE <= 2
(2801) /*-----------------------------------------------------------------------*/
(2802) /* Seek File R/W Pointer                                                 */
(2803) /*-----------------------------------------------------------------------*/
(2804) 
(2805) FRESULT f_lseek (
(2806) 	FIL *fp,		/* Pointer to the file object */
(2807) 	DWORD ofs		/* File pointer from top of file */
(2808) )
(2809) {
(2810) 	FRESULT res;
(2811) 
(2812) 
(2813) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01E8A A5E8      LDD	R30,Y+40
    01E8B A5F9      LDD	R31,Y+41
    01E8C 8122      LDD	R18,Z+2
    01E8D 8133      LDD	R19,Z+3
    01E8E 8100      LD	R16,Z
    01E8F 8111      LDD	R17,Z+1
    01E90 940E 165C CALL	ff.c:validate
    01E92 2EA0      MOV	R10,R16
(2814) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01E93 2300      TST	R16
    01E94 F009      BEQ	0x1E96
    01E95 C4A7      RJMP	0x233D
(2815) 	if (fp->flag & FA__ERROR)			/* Check abort flag */
    01E96 A5E8      LDD	R30,Y+40
    01E97 A5F9      LDD	R31,Y+41
    01E98 8024      LDD	R2,Z+4
    01E99 FE27      SBRS	R2,7
    01E9A C002      RJMP	0x1E9D
(2816) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01E9B E002      LDI	R16,2
    01E9C C4A0      RJMP	0x233D
(2817) 
(2818) #if _USE_FASTSEEK
(2819) 	if (fp->cltbl) {	/* Fast seek */
    01E9D A5E8      LDD	R30,Y+40
    01E9E A5F9      LDD	R31,Y+41
    01E9F 96B0      ADIW	R30,0x20
    01EA0 8020      LD	R2,Z
    01EA1 8031      LDD	R3,Z+1
    01EA2 2022      TST	R2
    01EA3 F419      BNE	0x1EA7
    01EA4 2033      TST	R3
    01EA5 F409      BNE	0x1EA7
    01EA6 C1E3      RJMP	0x208A
(2820) 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
(2821) 
(2822) 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
    01EA7 EF4F      LDI	R20,0xFF
    01EA8 EF5F      LDI	R21,0xFF
    01EA9 EF6F      LDI	R22,0xFF
    01EAA EF7F      LDI	R23,0xFF
    01EAB A42A      LDD	R2,Y+42
    01EAC A43B      LDD	R3,Y+43
    01EAD A44C      LDD	R4,Y+44
    01EAE A45D      LDD	R5,Y+45
    01EAF 1624      CP	R2,R20
    01EB0 0635      CPC	R3,R21
    01EB1 0646      CPC	R4,R22
    01EB2 0657      CPC	R5,R23
    01EB3 F009      BEQ	0x1EB5
    01EB4 C109      RJMP	0x1FBE
(2823) 			tbl = fp->cltbl;
    01EB5 A5E8      LDD	R30,Y+40
    01EB6 A5F9      LDD	R31,Y+41
    01EB7 A0E0      LDD	R14,Z+32
    01EB8 A0F1      LDD	R15,Z+33
(2824) 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
    01EB9 01F7      MOVW	R30,R14
    01EBA 9021      LD	R2,Z+
    01EBB 9031      LD	R3,Z+
    01EBC 9041      LD	R4,Z+
    01EBD 9051      LD	R5,Z+
    01EBE 017F      MOVW	R14,R30
    01EBF 8A2E      STD	Y+22,R2
    01EC0 8A3F      STD	Y+23,R3
    01EC1 8E48      STD	Y+24,R4
    01EC2 8E59      STD	Y+25,R5
    01EC3 E082      LDI	R24,2
    01EC4 878E      STD	Y+14,R24
    01EC5 E080      LDI	R24,0
    01EC6 878F      STD	Y+15,R24
    01EC7 8B88      STD	Y+16,R24
    01EC8 8B89      STD	Y+17,R24
(2825) 			cl = fp->sclust;			/* Top of the chain */
    01EC9 A5E8      LDD	R30,Y+40
    01ECA A5F9      LDD	R31,Y+41
    01ECB 963E      ADIW	R30,0xE
    01ECC 8020      LD	R2,Z
    01ECD 8031      LDD	R3,Z+1
    01ECE 8042      LDD	R4,Z+2
    01ECF 8053      LDD	R5,Z+3
    01ED0 822A      STD	Y+2,R2
    01ED1 823B      STD	Y+3,R3
    01ED2 824C      STD	Y+4,R4
    01ED3 825D      STD	Y+5,R5
(2826) 			if (cl) {
    01ED4 802A      LDD	R2,Y+2
    01ED5 803B      LDD	R3,Y+3
    01ED6 804C      LDD	R4,Y+4
    01ED7 805D      LDD	R5,Y+5
    01ED8 9488      BCLR	0
    01ED9 2022      TST	R2
    01EDA 0432      CPC	R3,R2
    01EDB 0442      CPC	R4,R2
    01EDC 0452      CPC	R5,R2
    01EDD F409      BNE	0x1EDF
    01EDE C0BB      RJMP	0x1F9A
(2827) 				do {
(2828) 					/* Get a fragment */
(2829) 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
    01EDF 802A      LDD	R2,Y+2
    01EE0 803B      LDD	R3,Y+3
    01EE1 804C      LDD	R4,Y+4
    01EE2 805D      LDD	R5,Y+5
    01EE3 8A2A      STD	Y+18,R2
    01EE4 8A3B      STD	Y+19,R3
    01EE5 8A4C      STD	Y+20,R4
    01EE6 8A5D      STD	Y+21,R5
    01EE7 E080      LDI	R24,0
    01EE8 878A      STD	Y+10,R24
    01EE9 878B      STD	Y+11,R24
    01EEA 878C      STD	Y+12,R24
    01EEB 878D      STD	Y+13,R24
    01EEC E042      LDI	R20,2
    01EED E050      LDI	R21,0
    01EEE E060      LDI	R22,0
    01EEF E070      LDI	R23,0
    01EF0 842E      LDD	R2,Y+14
    01EF1 843F      LDD	R3,Y+15
    01EF2 8848      LDD	R4,Y+16
    01EF3 8859      LDD	R5,Y+17
    01EF4 0E24      ADD	R2,R20
    01EF5 1E35      ADC	R3,R21
    01EF6 1E46      ADC	R4,R22
    01EF7 1E57      ADC	R5,R23
    01EF8 862E      STD	Y+14,R2
    01EF9 863F      STD	Y+15,R3
    01EFA 8A48      STD	Y+16,R4
    01EFB 8A59      STD	Y+17,R5
(2830) 					do {
(2831) 						pcl = cl; ncl++;
    01EFC 802A      LDD	R2,Y+2
    01EFD 803B      LDD	R3,Y+3
    01EFE 804C      LDD	R4,Y+4
    01EFF 805D      LDD	R5,Y+5
    01F00 822E      STD	Y+6,R2
    01F01 823F      STD	Y+7,R3
    01F02 8648      STD	Y+8,R4
    01F03 8659      STD	Y+9,R5
    01F04 E041      LDI	R20,1
    01F05 E050      LDI	R21,0
    01F06 E060      LDI	R22,0
    01F07 E070      LDI	R23,0
    01F08 842A      LDD	R2,Y+10
    01F09 843B      LDD	R3,Y+11
    01F0A 844C      LDD	R4,Y+12
    01F0B 845D      LDD	R5,Y+13
    01F0C 0E24      ADD	R2,R20
    01F0D 1E35      ADC	R3,R21
    01F0E 1E46      ADC	R4,R22
    01F0F 1E57      ADC	R5,R23
    01F10 862A      STD	Y+10,R2
    01F11 863B      STD	Y+11,R3
    01F12 864C      STD	Y+12,R4
    01F13 865D      STD	Y+13,R5
(2832) 						cl = get_fat(fp->fs, cl);
    01F14 802A      LDD	R2,Y+2
    01F15 803B      LDD	R3,Y+3
    01F16 804C      LDD	R4,Y+4
    01F17 805D      LDD	R5,Y+5
    01F18 8248      ST	Y,R4
    01F19 8259      STD	Y+1,R5
    01F1A 0191      MOVW	R18,R2
    01F1B A5E8      LDD	R30,Y+40
    01F1C A5F9      LDD	R31,Y+41
    01F1D 8100      LD	R16,Z
    01F1E 8111      LDD	R17,Z+1
    01F1F 940E 050D CALL	_get_fat
    01F21 830A      STD	Y+2,R16
    01F22 831B      STD	Y+3,R17
    01F23 832C      STD	Y+4,R18
    01F24 833D      STD	Y+5,R19
(2833) 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
    01F25 E041      LDI	R20,1
    01F26 E050      LDI	R21,0
    01F27 E060      LDI	R22,0
    01F28 E070      LDI	R23,0
    01F29 802A      LDD	R2,Y+2
    01F2A 803B      LDD	R3,Y+3
    01F2B 804C      LDD	R4,Y+4
    01F2C 805D      LDD	R5,Y+5
    01F2D 1542      CP	R20,R2
    01F2E 0553      CPC	R21,R3
    01F2F 0564      CPC	R22,R4
    01F30 0575      CPC	R23,R5
    01F31 F048      BCS	0x1F3B
    01F32 A588      LDD	R24,Y+40
    01F33 A599      LDD	R25,Y+41
    01F34 9604      ADIW	R24,4
    01F35 01FC      MOVW	R30,R24
    01F36 8180      LD	R24,Z
    01F37 6880      ORI	R24,0x80
    01F38 8380      ST	Z,R24
    01F39 E002      LDI	R16,2
    01F3A C402      RJMP	0x233D
(2834) 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01F3B EF4F      LDI	R20,0xFF
    01F3C EF5F      LDI	R21,0xFF
    01F3D EF6F      LDI	R22,0xFF
    01F3E EF7F      LDI	R23,0xFF
    01F3F 802A      LDD	R2,Y+2
    01F40 803B      LDD	R3,Y+3
    01F41 804C      LDD	R4,Y+4
    01F42 805D      LDD	R5,Y+5
    01F43 1624      CP	R2,R20
    01F44 0635      CPC	R3,R21
    01F45 0646      CPC	R4,R22
    01F46 0657      CPC	R5,R23
    01F47 F451      BNE	0x1F52
    01F48 A588      LDD	R24,Y+40
    01F49 A599      LDD	R25,Y+41
    01F4A 9604      ADIW	R24,4
    01F4B 016C      MOVW	R12,R24
    01F4C 01FC      MOVW	R30,R24
    01F4D 8180      LD	R24,Z
    01F4E 6880      ORI	R24,0x80
    01F4F 8380      ST	Z,R24
    01F50 E001      LDI	R16,1
    01F51 C3EB      RJMP	0x233D
(2835) 					} while (cl == pcl + 1);
    01F52 E041      LDI	R20,1
    01F53 E050      LDI	R21,0
    01F54 E060      LDI	R22,0
    01F55 E070      LDI	R23,0
    01F56 802E      LDD	R2,Y+6
    01F57 803F      LDD	R3,Y+7
    01F58 8448      LDD	R4,Y+8
    01F59 8459      LDD	R5,Y+9
    01F5A 0E24      ADD	R2,R20
    01F5B 1E35      ADC	R3,R21
    01F5C 1E46      ADC	R4,R22
    01F5D 1E57      ADC	R5,R23
    01F5E 806A      LDD	R6,Y+2
    01F5F 807B      LDD	R7,Y+3
    01F60 808C      LDD	R8,Y+4
    01F61 809D      LDD	R9,Y+5
    01F62 1462      CP	R6,R2
    01F63 0473      CPC	R7,R3
    01F64 0484      CPC	R8,R4
    01F65 0495      CPC	R9,R5
    01F66 F409      BNE	0x1F68
    01F67 CF94      RJMP	0x1EFC
(2836) 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
    01F68 882E      LDD	R2,Y+22
    01F69 883F      LDD	R3,Y+23
    01F6A 8C48      LDD	R4,Y+24
    01F6B 8C59      LDD	R5,Y+25
    01F6C 846E      LDD	R6,Y+14
    01F6D 847F      LDD	R7,Y+15
    01F6E 8888      LDD	R8,Y+16
    01F6F 8899      LDD	R9,Y+17
    01F70 1426      CP	R2,R6
    01F71 0437      CPC	R3,R7
    01F72 0448      CPC	R4,R8
    01F73 0459      CPC	R5,R9
    01F74 F090      BCS	0x1F87
(2837) 						*tbl++ = ncl; *tbl++ = tcl;
    01F75 842A      LDD	R2,Y+10
    01F76 843B      LDD	R3,Y+11
    01F77 844C      LDD	R4,Y+12
    01F78 845D      LDD	R5,Y+13
    01F79 01F7      MOVW	R30,R14
    01F7A 9221      ST	Z+,R2
    01F7B 9231      ST	Z+,R3
    01F7C 9241      ST	Z+,R4
    01F7D 9251      ST	Z+,R5
    01F7E 882A      LDD	R2,Y+18
    01F7F 883B      LDD	R3,Y+19
    01F80 884C      LDD	R4,Y+20
    01F81 885D      LDD	R5,Y+21
    01F82 9221      ST	Z+,R2
    01F83 9231      ST	Z+,R3
    01F84 9241      ST	Z+,R4
    01F85 9251      ST	Z+,R5
    01F86 017F      MOVW	R14,R30
(2838) 					}
(2839) 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
    01F87 A5E8      LDD	R30,Y+40
    01F88 A5F9      LDD	R31,Y+41
    01F89 81A0      LD	R26,Z
    01F8A 81B1      LDD	R27,Z+1
    01F8B 9656      ADIW	R26,0x16
    01F8C 902D      LD	R2,X+
    01F8D 903D      LD	R3,X+
    01F8E 904D      LD	R4,X+
    01F8F 905C      LD	R5,X
    01F90 806A      LDD	R6,Y+2
    01F91 807B      LDD	R7,Y+3
    01F92 808C      LDD	R8,Y+4
    01F93 809D      LDD	R9,Y+5
    01F94 1462      CP	R6,R2
    01F95 0473      CPC	R7,R3
    01F96 0484      CPC	R8,R4
    01F97 0495      CPC	R9,R5
    01F98 F408      BCC	0x1F9A
    01F99 CF45      RJMP	0x1EDF
(2840) 			}
(2841) 			*fp->cltbl = ulen;	/* Number of items used */
    01F9A 842E      LDD	R2,Y+14
    01F9B 843F      LDD	R3,Y+15
    01F9C 8848      LDD	R4,Y+16
    01F9D 8859      LDD	R5,Y+17
    01F9E A5E8      LDD	R30,Y+40
    01F9F A5F9      LDD	R31,Y+41
    01FA0 96B0      ADIW	R30,0x20
    01FA1 81A0      LD	R26,Z
    01FA2 81B1      LDD	R27,Z+1
    01FA3 922D      ST	X+,R2
    01FA4 923D      ST	X+,R3
    01FA5 924D      ST	X+,R4
    01FA6 925C      ST	X,R5
(2842) 			if (ulen <= tlen)
    01FA7 882E      LDD	R2,Y+22
    01FA8 883F      LDD	R3,Y+23
    01FA9 8C48      LDD	R4,Y+24
    01FAA 8C59      LDD	R5,Y+25
    01FAB 846E      LDD	R6,Y+14
    01FAC 847F      LDD	R7,Y+15
    01FAD 8888      LDD	R8,Y+16
    01FAE 8899      LDD	R9,Y+17
    01FAF 1426      CP	R2,R6
    01FB0 0437      CPC	R3,R7
    01FB1 0448      CPC	R4,R8
    01FB2 0459      CPC	R5,R9
    01FB3 F038      BCS	0x1FBB
(2843) 				*tbl = 0;		/* Terminate table */
    01FB4 01F7      MOVW	R30,R14
    01FB5 E080      LDI	R24,0
    01FB6 8380      ST	Z,R24
    01FB7 8381      STD	Z+1,R24
    01FB8 8382      STD	Z+2,R24
    01FB9 8383      STD	Z+3,R24
    01FBA C381      RJMP	0x233C
(2844) 			else
(2845) 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
    01FBB E181      LDI	R24,0x11
    01FBC 2EA8      MOV	R10,R24
(2846) 
(2847) 		} else {						/* Fast seek */
    01FBD C37E      RJMP	0x233C
(2848) 			if (ofs > fp->fsize)		/* Clip offset at the file size */
    01FBE A5E8      LDD	R30,Y+40
    01FBF A5F9      LDD	R31,Y+41
    01FC0 963A      ADIW	R30,0xA
    01FC1 8020      LD	R2,Z
    01FC2 8031      LDD	R3,Z+1
    01FC3 8042      LDD	R4,Z+2
    01FC4 8053      LDD	R5,Z+3
    01FC5 A46A      LDD	R6,Y+42
    01FC6 A47B      LDD	R7,Y+43
    01FC7 A48C      LDD	R8,Y+44
    01FC8 A49D      LDD	R9,Y+45
    01FC9 1426      CP	R2,R6
    01FCA 0437      CPC	R3,R7
    01FCB 0448      CPC	R4,R8
    01FCC 0459      CPC	R5,R9
    01FCD F458      BCC	0x1FD9
(2849) 				ofs = fp->fsize;
    01FCE A5E8      LDD	R30,Y+40
    01FCF A5F9      LDD	R31,Y+41
    01FD0 963A      ADIW	R30,0xA
    01FD1 8020      LD	R2,Z
    01FD2 8031      LDD	R3,Z+1
    01FD3 8042      LDD	R4,Z+2
    01FD4 8053      LDD	R5,Z+3
    01FD5 A62A      STD	Y+42,R2
    01FD6 A63B      STD	Y+43,R3
    01FD7 A64C      STD	Y+44,R4
    01FD8 A65D      STD	Y+45,R5
(2850) 			fp->fptr = ofs;				/* Set file pointer */
    01FD9 A42A      LDD	R2,Y+42
    01FDA A43B      LDD	R3,Y+43
    01FDB A44C      LDD	R4,Y+44
    01FDC A45D      LDD	R5,Y+45
    01FDD A5E8      LDD	R30,Y+40
    01FDE A5F9      LDD	R31,Y+41
    01FDF 9636      ADIW	R30,6
    01FE0 8220      ST	Z,R2
    01FE1 8231      STD	Z+1,R3
    01FE2 8242      STD	Z+2,R4
    01FE3 8253      STD	Z+3,R5
(2851) 			if (ofs) {
    01FE4 9488      BCLR	0
    01FE5 2022      TST	R2
    01FE6 0432      CPC	R3,R2
    01FE7 0442      CPC	R4,R2
    01FE8 0452      CPC	R5,R2
    01FE9 F409      BNE	0x1FEB
    01FEA C351      RJMP	0x233C
(2852) 				fp->clust = clmt_clust(fp, ofs - 1);
    01FEB E041      LDI	R20,1
    01FEC E050      LDI	R21,0
    01FED E060      LDI	R22,0
    01FEE E070      LDI	R23,0
    01FEF 1A24      SUB	R2,R20
    01FF0 0A35      SBC	R3,R21
    01FF1 0A46      SBC	R4,R22
    01FF2 0A57      SBC	R5,R23
    01FF3 8248      ST	Y,R4
    01FF4 8259      STD	Y+1,R5
    01FF5 0191      MOVW	R18,R2
    01FF6 A508      LDD	R16,Y+40
    01FF7 A519      LDD	R17,Y+41
    01FF8 940E 0A47 CALL	ff.c:clmt_clust
    01FFA A5E8      LDD	R30,Y+40
    01FFB A5F9      LDD	R31,Y+41
    01FFC 8B02      STD	Z+18,R16
    01FFD 8B13      STD	Z+19,R17
    01FFE 8B24      STD	Z+20,R18
    01FFF 8B35      STD	Z+21,R19
(2853) 				dsc = clust2sect(fp->fs, fp->clust);
    02000 8822      LDD	R2,Z+18
    02001 8833      LDD	R3,Z+19
    02002 8844      LDD	R4,Z+20
    02003 8855      LDD	R5,Z+21
    02004 8248      ST	Y,R4
    02005 8259      STD	Y+1,R5
    02006 0191      MOVW	R18,R2
    02007 8100      LD	R16,Z
    02008 8111      LDD	R17,Z+1
    02009 940E 04BB CALL	_clust2sect
    0200B 8F0A      STD	Y+26,R16
    0200C 8F1B      STD	Y+27,R17
    0200D 8F2C      STD	Y+28,R18
    0200E 8F3D      STD	Y+29,R19
(2854) 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
    0200F 8C2A      LDD	R2,Y+26
    02010 8C3B      LDD	R3,Y+27
    02011 8C4C      LDD	R4,Y+28
    02012 8C5D      LDD	R5,Y+29
    02013 9488      BCLR	0
    02014 2022      TST	R2
    02015 0432      CPC	R3,R2
    02016 0442      CPC	R4,R2
    02017 0452      CPC	R5,R2
    02018 F451      BNE	0x2023
    02019 A588      LDD	R24,Y+40
    0201A A599      LDD	R25,Y+41
    0201B 9604      ADIW	R24,4
    0201C 017C      MOVW	R14,R24
    0201D 01FC      MOVW	R30,R24
    0201E 8180      LD	R24,Z
    0201F 6880      ORI	R24,0x80
    02020 8380      ST	Z,R24
    02021 E002      LDI	R16,2
    02022 C31A      RJMP	0x233D
(2855) 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
    02023 E041      LDI	R20,1
    02024 E050      LDI	R21,0
    02025 E060      LDI	R22,0
    02026 E070      LDI	R23,0
    02027 A50A      LDD	R16,Y+42
    02028 A51B      LDD	R17,Y+43
    02029 A52C      LDD	R18,Y+44
    0202A A53D      LDD	R19,Y+45
    0202B 1B04      SUB	R16,R20
    0202C 0B15      SBC	R17,R21
    0202D 0B26      SBC	R18,R22
    0202E 0B37      SBC	R19,R23
    0202F E089      LDI	R24,0x9
    02030 E090      LDI	R25,0
    02031 938A      ST	-Y,R24
    02032 940E 4142 CALL	lsr32
    02034 0118      MOVW	R2,R16
    02035 0129      MOVW	R4,R18
    02036 A5E8      LDD	R30,Y+40
    02037 A5F9      LDD	R31,Y+41
    02038 93AF      PUSH	R26
    02039 93BF      PUSH	R27
    0203A 81A0      LD	R26,Z
    0203B 81B1      LDD	R27,Z+1
    0203C 01FD      MOVW	R30,R26
    0203D 91BF      POP	R27
    0203E 91AF      POP	R26
    0203F 9632      ADIW	R30,2
    02040 8180      LD	R24,Z
    02041 2799      CLR	R25
    02042 9701      SBIW	R24,1
    02043 013C      MOVW	R6,R24
    02044 2488      CLR	R8
    02045 FC77      SBRC	R7,7
    02046 9480      COM	R8
    02047 2499      CLR	R9
    02048 FC87      SBRC	R8,7
    02049 9490      COM	R9
    0204A 2026      AND	R2,R6
    0204B 2037      AND	R3,R7
    0204C 2048      AND	R4,R8
    0204D 2059      AND	R5,R9
    0204E 8C6A      LDD	R6,Y+26
    0204F 8C7B      LDD	R7,Y+27
    02050 8C8C      LDD	R8,Y+28
    02051 8C9D      LDD	R9,Y+29
    02052 0C62      ADD	R6,R2
    02053 1C73      ADC	R7,R3
    02054 1C84      ADC	R8,R4
    02055 1C95      ADC	R9,R5
    02056 8E6A      STD	Y+26,R6
    02057 8E7B      STD	Y+27,R7
    02058 8E8C      STD	Y+28,R8
    02059 8E9D      STD	Y+29,R9
(2856) 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
    0205A EF4F      LDI	R20,0xFF
    0205B E051      LDI	R21,1
    0205C E060      LDI	R22,0
    0205D E070      LDI	R23,0
    0205E A5E8      LDD	R30,Y+40
    0205F A5F9      LDD	R31,Y+41
    02060 9636      ADIW	R30,6
    02061 8020      LD	R2,Z
    02062 8031      LDD	R3,Z+1
    02063 8042      LDD	R4,Z+2
    02064 8053      LDD	R5,Z+3
    02065 2224      AND	R2,R20
    02066 2235      AND	R3,R21
    02067 2246      AND	R4,R22
    02068 2257      AND	R5,R23
    02069 9488      BCLR	0
    0206A 2022      TST	R2
    0206B 0432      CPC	R3,R2
    0206C 0442      CPC	R4,R2
    0206D 0452      CPC	R5,R2
    0206E F409      BNE	0x2070
    0206F C2CC      RJMP	0x233C
    02070 A5E8      LDD	R30,Y+40
    02071 A5F9      LDD	R31,Y+41
    02072 9676      ADIW	R30,0x16
    02073 8020      LD	R2,Z
    02074 8031      LDD	R3,Z+1
    02075 8042      LDD	R4,Z+2
    02076 8053      LDD	R5,Z+3
    02077 8C6A      LDD	R6,Y+26
    02078 8C7B      LDD	R7,Y+27
    02079 8C8C      LDD	R8,Y+28
    0207A 8C9D      LDD	R9,Y+29
    0207B 1462      CP	R6,R2
    0207C 0473      CPC	R7,R3
    0207D 0484      CPC	R8,R4
    0207E 0495      CPC	R9,R5
    0207F F409      BNE	0x2081
    02080 C2BB      RJMP	0x233C
(2857) #if !_FS_TINY
(2858) #if !_FS_READONLY
(2859) 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2860) 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2861) 							ABORT(fp->fs, FR_DISK_ERR);
(2862) 						fp->flag &= ~FA__DIRTY;
(2863) 					}
(2864) #endif
(2865) 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
(2866) 						ABORT(fp->fs, FR_DISK_ERR);
(2867) #endif
(2868) 					fp->dsect = dsc;
    02081 0113      MOVW	R2,R6
    02082 0124      MOVW	R4,R8
    02083 A5E8      LDD	R30,Y+40
    02084 A5F9      LDD	R31,Y+41
    02085 8A26      STD	Z+22,R2
    02086 8A37      STD	Z+23,R3
    02087 8E40      STD	Z+24,R4
    02088 8E51      STD	Z+25,R5
(2869) 				}
(2870) 			}
(2871) 		}
(2872) 	} else
    02089 C2B2      RJMP	0x233C
(2873) #endif
(2874) 
(2875) 	/* Normal Seek */
(2876) 	{
(2877) 		DWORD clst, bcs, nsect, ifptr;
(2878) 
(2879) 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    0208A A5E8      LDD	R30,Y+40
    0208B A5F9      LDD	R31,Y+41
    0208C 963A      ADIW	R30,0xA
    0208D 8020      LD	R2,Z
    0208E 8031      LDD	R3,Z+1
    0208F 8042      LDD	R4,Z+2
    02090 8053      LDD	R5,Z+3
    02091 A46A      LDD	R6,Y+42
    02092 A47B      LDD	R7,Y+43
    02093 A48C      LDD	R8,Y+44
    02094 A49D      LDD	R9,Y+45
    02095 1426      CP	R2,R6
    02096 0437      CPC	R3,R7
    02097 0448      CPC	R4,R8
    02098 0459      CPC	R5,R9
    02099 F470      BCC	0x20A8
    0209A A5E8      LDD	R30,Y+40
    0209B A5F9      LDD	R31,Y+41
    0209C 8024      LDD	R2,Z+4
    0209D FC21      SBRC	R2,1
    0209E C009      RJMP	0x20A8
(2880) #if !_FS_READONLY
(2881) 			 && !(fp->flag & FA_WRITE)
(2882) #endif
(2883) 			) ofs = fp->fsize;
    0209F 963A      ADIW	R30,0xA
    020A0 8020      LD	R2,Z
    020A1 8031      LDD	R3,Z+1
    020A2 8042      LDD	R4,Z+2
    020A3 8053      LDD	R5,Z+3
    020A4 A62A      STD	Y+42,R2
    020A5 A63B      STD	Y+43,R3
    020A6 A64C      STD	Y+44,R4
    020A7 A65D      STD	Y+45,R5
(2884) 
(2885) 		ifptr = fp->fptr;
    020A8 A5E8      LDD	R30,Y+40
    020A9 A5F9      LDD	R31,Y+41
    020AA 9636      ADIW	R30,6
    020AB 8020      LD	R2,Z
    020AC 8031      LDD	R3,Z+1
    020AD 8042      LDD	R4,Z+2
    020AE 8053      LDD	R5,Z+3
    020AF 862E      STD	Y+14,R2
    020B0 863F      STD	Y+15,R3
    020B1 8A48      STD	Y+16,R4
    020B2 8A59      STD	Y+17,R5
(2886) 		fp->fptr = nsect = 0;
    020B3 E080      LDI	R24,0
    020B4 878A      STD	Y+10,R24
    020B5 878B      STD	Y+11,R24
    020B6 878C      STD	Y+12,R24
    020B7 878D      STD	Y+13,R24
    020B8 A5E8      LDD	R30,Y+40
    020B9 A5F9      LDD	R31,Y+41
    020BA 9636      ADIW	R30,6
    020BB E080      LDI	R24,0
    020BC 8380      ST	Z,R24
    020BD 8381      STD	Z+1,R24
    020BE 8382      STD	Z+2,R24
    020BF 8383      STD	Z+3,R24
(2887) 		if (ofs) {
    020C0 A42A      LDD	R2,Y+42
    020C1 A43B      LDD	R3,Y+43
    020C2 A44C      LDD	R4,Y+44
    020C3 A45D      LDD	R5,Y+45
    020C4 9488      BCLR	0
    020C5 2022      TST	R2
    020C6 0432      CPC	R3,R2
    020C7 0442      CPC	R4,R2
    020C8 0452      CPC	R5,R2
    020C9 F409      BNE	0x20CB
    020CA C226      RJMP	0x22F1
(2888) 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    020CB A5E8      LDD	R30,Y+40
    020CC A5F9      LDD	R31,Y+41
    020CD 93AF      PUSH	R26
    020CE 93BF      PUSH	R27
    020CF 81A0      LD	R26,Z
    020D0 81B1      LDD	R27,Z+1
    020D1 01FD      MOVW	R30,R26
    020D2 91BF      POP	R27
    020D3 91AF      POP	R26
    020D4 9632      ADIW	R30,2
    020D5 8020      LD	R2,Z
    020D6 2433      CLR	R3
    020D7 2444      CLR	R4
    020D8 2455      CLR	R5
    020D9 E040      LDI	R20,0
    020DA E052      LDI	R21,2
    020DB E060      LDI	R22,0
    020DC E070      LDI	R23,0
    020DD 925A      ST	-Y,R5
    020DE 924A      ST	-Y,R4
    020DF 923A      ST	-Y,R3
    020E0 922A      ST	-Y,R2
    020E1 018A      MOVW	R16,R20
    020E2 019B      MOVW	R18,R22
    020E3 940E 4053 CALL	empy32u|empy32s
    020E5 830E      STD	Y+6,R16
    020E6 831F      STD	Y+7,R17
    020E7 8728      STD	Y+8,R18
    020E8 8739      STD	Y+9,R19
(2889) 			if (ifptr > 0 &&
    020E9 842E      LDD	R2,Y+14
    020EA 843F      LDD	R3,Y+15
    020EB 8848      LDD	R4,Y+16
    020EC 8859      LDD	R5,Y+17
    020ED 9488      BCLR	0
    020EE 2022      TST	R2
    020EF 0432      CPC	R3,R2
    020F0 0442      CPC	R4,R2
    020F1 0452      CPC	R5,R2
    020F2 F409      BNE	0x20F4
    020F3 C075      RJMP	0x2169
    020F4 E041      LDI	R20,1
    020F5 E050      LDI	R21,0
    020F6 E060      LDI	R22,0
    020F7 E070      LDI	R23,0
    020F8 0181      MOVW	R16,R2
    020F9 0192      MOVW	R18,R4
    020FA 1B04      SUB	R16,R20
    020FB 0B15      SBC	R17,R21
    020FC 0B26      SBC	R18,R22
    020FD 0B37      SBC	R19,R23
    020FE 802E      LDD	R2,Y+6
    020FF 803F      LDD	R3,Y+7
    02100 8448      LDD	R4,Y+8
    02101 8459      LDD	R5,Y+9
    02102 925A      ST	-Y,R5
    02103 924A      ST	-Y,R4
    02104 923A      ST	-Y,R3
    02105 922A      ST	-Y,R2
    02106 940E 3FAD CALL	div32u
    02108 0118      MOVW	R2,R16
    02109 0129      MOVW	R4,R18
    0210A E041      LDI	R20,1
    0210B E050      LDI	R21,0
    0210C E060      LDI	R22,0
    0210D E070      LDI	R23,0
    0210E A50A      LDD	R16,Y+42
    0210F A51B      LDD	R17,Y+43
    02110 A52C      LDD	R18,Y+44
    02111 A53D      LDD	R19,Y+45
    02112 1B04      SUB	R16,R20
    02113 0B15      SBC	R17,R21
    02114 0B26      SBC	R18,R22
    02115 0B37      SBC	R19,R23
    02116 806E      LDD	R6,Y+6
    02117 807F      LDD	R7,Y+7
    02118 8488      LDD	R8,Y+8
    02119 8499      LDD	R9,Y+9
    0211A 929A      ST	-Y,R9
    0211B 928A      ST	-Y,R8
    0211C 927A      ST	-Y,R7
    0211D 926A      ST	-Y,R6
    0211E 940E 3FAD CALL	div32u
    02120 1502      CP	R16,R2
    02121 0513      CPC	R17,R3
    02122 0524      CPC	R18,R4
    02123 0535      CPC	R19,R5
    02124 F408      BCC	0x2126
    02125 C043      RJMP	0x2169
(2890) 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
(2891) 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    02126 E041      LDI	R20,1
    02127 E050      LDI	R21,0
    02128 E060      LDI	R22,0
    02129 E070      LDI	R23,0
    0212A 802E      LDD	R2,Y+6
    0212B 803F      LDD	R3,Y+7
    0212C 8448      LDD	R4,Y+8
    0212D 8459      LDD	R5,Y+9
    0212E 1A24      SUB	R2,R20
    0212F 0A35      SBC	R3,R21
    02130 0A46      SBC	R4,R22
    02131 0A57      SBC	R5,R23
    02132 9420      COM	R2
    02133 9430      COM	R3
    02134 9440      COM	R4
    02135 9450      COM	R5
    02136 E041      LDI	R20,1
    02137 E050      LDI	R21,0
    02138 E060      LDI	R22,0
    02139 E070      LDI	R23,0
    0213A 846E      LDD	R6,Y+14
    0213B 847F      LDD	R7,Y+15
    0213C 8888      LDD	R8,Y+16
    0213D 8899      LDD	R9,Y+17
    0213E 1A64      SUB	R6,R20
    0213F 0A75      SBC	R7,R21
    02140 0A86      SBC	R8,R22
    02141 0A97      SBC	R9,R23
    02142 2062      AND	R6,R2
    02143 2073      AND	R7,R3
    02144 2084      AND	R8,R4
    02145 2095      AND	R9,R5
    02146 A5E8      LDD	R30,Y+40
    02147 A5F9      LDD	R31,Y+41
    02148 8266      STD	Z+6,R6
    02149 8277      STD	Z+7,R7
    0214A 8680      STD	Z+8,R8
    0214B 8691      STD	Z+9,R9
(2892) 				ofs -= fp->fptr;
    0214C 9636      ADIW	R30,6
    0214D 8020      LD	R2,Z
    0214E 8031      LDD	R3,Z+1
    0214F 8042      LDD	R4,Z+2
    02150 8053      LDD	R5,Z+3
    02151 A46A      LDD	R6,Y+42
    02152 A47B      LDD	R7,Y+43
    02153 A48C      LDD	R8,Y+44
    02154 A49D      LDD	R9,Y+45
    02155 1862      SUB	R6,R2
    02156 0873      SBC	R7,R3
    02157 0884      SBC	R8,R4
    02158 0895      SBC	R9,R5
    02159 A66A      STD	Y+42,R6
    0215A A67B      STD	Y+43,R7
    0215B A68C      STD	Y+44,R8
    0215C A69D      STD	Y+45,R9
(2893) 				clst = fp->clust;
    0215D A5E8      LDD	R30,Y+40
    0215E A5F9      LDD	R31,Y+41
    0215F 9672      ADIW	R30,0x12
    02160 8020      LD	R2,Z
    02161 8031      LDD	R3,Z+1
    02162 8042      LDD	R4,Z+2
    02163 8053      LDD	R5,Z+3
    02164 822A      STD	Y+2,R2
    02165 823B      STD	Y+3,R3
    02166 824C      STD	Y+4,R4
    02167 825D      STD	Y+5,R5
(2894) 			} else {									/* When seek to back cluster, */
    02168 C069      RJMP	0x21D2
(2895) 				clst = fp->sclust;						/* start from the first cluster */
    02169 A5E8      LDD	R30,Y+40
    0216A A5F9      LDD	R31,Y+41
    0216B 963E      ADIW	R30,0xE
    0216C 8020      LD	R2,Z
    0216D 8031      LDD	R3,Z+1
    0216E 8042      LDD	R4,Z+2
    0216F 8053      LDD	R5,Z+3
    02170 822A      STD	Y+2,R2
    02171 823B      STD	Y+3,R3
    02172 824C      STD	Y+4,R4
    02173 825D      STD	Y+5,R5
(2896) #if !_FS_READONLY
(2897) 				if (clst == 0) {						/* If no cluster chain, create a new chain */
    02174 802A      LDD	R2,Y+2
    02175 803B      LDD	R3,Y+3
    02176 804C      LDD	R4,Y+4
    02177 805D      LDD	R5,Y+5
    02178 9488      BCLR	0
    02179 2022      TST	R2
    0217A 0432      CPC	R3,R2
    0217B 0442      CPC	R4,R2
    0217C 0452      CPC	R5,R2
    0217D F009      BEQ	0x217F
    0217E C049      RJMP	0x21C8
(2898) 					clst = create_chain(fp->fs, 0);
    0217F E040      LDI	R20,0
    02180 E050      LDI	R21,0
    02181 E060      LDI	R22,0
    02182 E070      LDI	R23,0
    02183 8368      ST	Y,R22
    02184 8379      STD	Y+1,R23
    02185 019A      MOVW	R18,R20
    02186 A5E8      LDD	R30,Y+40
    02187 A5F9      LDD	R31,Y+41
    02188 8100      LD	R16,Z
    02189 8111      LDD	R17,Z+1
    0218A 940E 08CF CALL	ff.c:create_chain
    0218C 830A      STD	Y+2,R16
    0218D 831B      STD	Y+3,R17
    0218E 832C      STD	Y+4,R18
    0218F 833D      STD	Y+5,R19
(2899) 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    02190 E041      LDI	R20,1
    02191 E050      LDI	R21,0
    02192 E060      LDI	R22,0
    02193 E070      LDI	R23,0
    02194 802A      LDD	R2,Y+2
    02195 803B      LDD	R3,Y+3
    02196 804C      LDD	R4,Y+4
    02197 805D      LDD	R5,Y+5
    02198 1624      CP	R2,R20
    02199 0635      CPC	R3,R21
    0219A 0646      CPC	R4,R22
    0219B 0657      CPC	R5,R23
    0219C F451      BNE	0x21A7
    0219D A588      LDD	R24,Y+40
    0219E A599      LDD	R25,Y+41
    0219F 9604      ADIW	R24,4
    021A0 017C      MOVW	R14,R24
    021A1 01FC      MOVW	R30,R24
    021A2 8180      LD	R24,Z
    021A3 6880      ORI	R24,0x80
    021A4 8380      ST	Z,R24
    021A5 E002      LDI	R16,2
    021A6 C196      RJMP	0x233D
(2900) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    021A7 EF4F      LDI	R20,0xFF
    021A8 EF5F      LDI	R21,0xFF
    021A9 EF6F      LDI	R22,0xFF
    021AA EF7F      LDI	R23,0xFF
    021AB 802A      LDD	R2,Y+2
    021AC 803B      LDD	R3,Y+3
    021AD 804C      LDD	R4,Y+4
    021AE 805D      LDD	R5,Y+5
    021AF 1624      CP	R2,R20
    021B0 0635      CPC	R3,R21
    021B1 0646      CPC	R4,R22
    021B2 0657      CPC	R5,R23
    021B3 F451      BNE	0x21BE
    021B4 A588      LDD	R24,Y+40
    021B5 A599      LDD	R25,Y+41
    021B6 9604      ADIW	R24,4
    021B7 017C      MOVW	R14,R24
    021B8 01FC      MOVW	R30,R24
    021B9 8180      LD	R24,Z
    021BA 6880      ORI	R24,0x80
    021BB 8380      ST	Z,R24
    021BC E001      LDI	R16,1
    021BD C17F      RJMP	0x233D
(2901) 					fp->sclust = clst;
    021BE 802A      LDD	R2,Y+2
    021BF 803B      LDD	R3,Y+3
    021C0 804C      LDD	R4,Y+4
    021C1 805D      LDD	R5,Y+5
    021C2 A5E8      LDD	R30,Y+40
    021C3 A5F9      LDD	R31,Y+41
    021C4 8626      STD	Z+14,R2
    021C5 8637      STD	Z+15,R3
    021C6 8A40      STD	Z+16,R4
    021C7 8A51      STD	Z+17,R5
(2902) 				}
(2903) #endif
(2904) 				fp->clust = clst;
    021C8 802A      LDD	R2,Y+2
    021C9 803B      LDD	R3,Y+3
    021CA 804C      LDD	R4,Y+4
    021CB 805D      LDD	R5,Y+5
    021CC A5E8      LDD	R30,Y+40
    021CD A5F9      LDD	R31,Y+41
    021CE 8A22      STD	Z+18,R2
    021CF 8A33      STD	Z+19,R3
    021D0 8A44      STD	Z+20,R4
    021D1 8A55      STD	Z+21,R5
(2905) 			}
(2906) 			if (clst != 0) {
    021D2 802A      LDD	R2,Y+2
    021D3 803B      LDD	R3,Y+3
    021D4 804C      LDD	R4,Y+4
    021D5 805D      LDD	R5,Y+5
    021D6 9488      BCLR	0
    021D7 2022      TST	R2
    021D8 0432      CPC	R3,R2
    021D9 0442      CPC	R4,R2
    021DA 0452      CPC	R5,R2
    021DB F409      BNE	0x21DD
    021DC C114      RJMP	0x22F1
    021DD C0A7      RJMP	0x2285
(2907) 				while (ofs > bcs) {						/* Cluster following loop */
(2908) #if !_FS_READONLY
(2909) 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    021DE A5E8      LDD	R30,Y+40
    021DF A5F9      LDD	R31,Y+41
    021E0 9634      ADIW	R30,4
    021E1 8020      LD	R2,Z
    021E2 FE21      SBRS	R2,1
    021E3 C024      RJMP	0x2208
(2910) 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    021E4 802A      LDD	R2,Y+2
    021E5 803B      LDD	R3,Y+3
    021E6 804C      LDD	R4,Y+4
    021E7 805D      LDD	R5,Y+5
    021E8 8248      ST	Y,R4
    021E9 8259      STD	Y+1,R5
    021EA 0191      MOVW	R18,R2
    021EB A5E8      LDD	R30,Y+40
    021EC A5F9      LDD	R31,Y+41
    021ED 8100      LD	R16,Z
    021EE 8111      LDD	R17,Z+1
    021EF 940E 08CF CALL	ff.c:create_chain
    021F1 830A      STD	Y+2,R16
    021F2 831B      STD	Y+3,R17
    021F3 832C      STD	Y+4,R18
    021F4 833D      STD	Y+5,R19
(2911) 						if (clst == 0) {				/* When disk gets full, clip file size */
    021F5 802A      LDD	R2,Y+2
    021F6 803B      LDD	R3,Y+3
    021F7 804C      LDD	R4,Y+4
    021F8 805D      LDD	R5,Y+5
    021F9 9488      BCLR	0
    021FA 2022      TST	R2
    021FB 0432      CPC	R3,R2
    021FC 0442      CPC	R4,R2
    021FD 0452      CPC	R5,R2
    021FE F4D1      BNE	0x2219
(2912) 							ofs = bcs; break;
    021FF 802E      LDD	R2,Y+6
    02200 803F      LDD	R3,Y+7
    02201 8448      LDD	R4,Y+8
    02202 8459      LDD	R5,Y+9
    02203 A62A      STD	Y+42,R2
    02204 A63B      STD	Y+43,R3
    02205 A64C      STD	Y+44,R4
    02206 A65D      STD	Y+45,R5
    02207 C08B      RJMP	0x2293
(2913) 						}
(2914) 					} else
(2915) #endif
(2916) 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    02208 802A      LDD	R2,Y+2
    02209 803B      LDD	R3,Y+3
    0220A 804C      LDD	R4,Y+4
    0220B 805D      LDD	R5,Y+5
    0220C 8248      ST	Y,R4
    0220D 8259      STD	Y+1,R5
    0220E 0191      MOVW	R18,R2
    0220F A5E8      LDD	R30,Y+40
    02210 A5F9      LDD	R31,Y+41
    02211 8100      LD	R16,Z
    02212 8111      LDD	R17,Z+1
    02213 940E 050D CALL	_get_fat
    02215 830A      STD	Y+2,R16
    02216 831B      STD	Y+3,R17
    02217 832C      STD	Y+4,R18
    02218 833D      STD	Y+5,R19
(2917) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    02219 EF4F      LDI	R20,0xFF
    0221A EF5F      LDI	R21,0xFF
    0221B EF6F      LDI	R22,0xFF
    0221C EF7F      LDI	R23,0xFF
    0221D 802A      LDD	R2,Y+2
    0221E 803B      LDD	R3,Y+3
    0221F 804C      LDD	R4,Y+4
    02220 805D      LDD	R5,Y+5
    02221 1624      CP	R2,R20
    02222 0635      CPC	R3,R21
    02223 0646      CPC	R4,R22
    02224 0657      CPC	R5,R23
    02225 F451      BNE	0x2230
    02226 A588      LDD	R24,Y+40
    02227 A599      LDD	R25,Y+41
    02228 9604      ADIW	R24,4
    02229 017C      MOVW	R14,R24
    0222A 01FC      MOVW	R30,R24
    0222B 8180      LD	R24,Z
    0222C 6880      ORI	R24,0x80
    0222D 8380      ST	Z,R24
    0222E E001      LDI	R16,1
    0222F C10D      RJMP	0x233D
(2918) 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    02230 E041      LDI	R20,1
    02231 E050      LDI	R21,0
    02232 E060      LDI	R22,0
    02233 E070      LDI	R23,0
    02234 802A      LDD	R2,Y+2
    02235 803B      LDD	R3,Y+3
    02236 804C      LDD	R4,Y+4
    02237 805D      LDD	R5,Y+5
    02238 1542      CP	R20,R2
    02239 0553      CPC	R21,R3
    0223A 0564      CPC	R22,R4
    0223B 0575      CPC	R23,R5
    0223C F490      BCC	0x224F
    0223D A5E8      LDD	R30,Y+40
    0223E A5F9      LDD	R31,Y+41
    0223F 81A0      LD	R26,Z
    02240 81B1      LDD	R27,Z+1
    02241 9656      ADIW	R26,0x16
    02242 902D      LD	R2,X+
    02243 903D      LD	R3,X+
    02244 904D      LD	R4,X+
    02245 905C      LD	R5,X
    02246 806A      LDD	R6,Y+2
    02247 807B      LDD	R7,Y+3
    02248 808C      LDD	R8,Y+4
    02249 809D      LDD	R9,Y+5
    0224A 1462      CP	R6,R2
    0224B 0473      CPC	R7,R3
    0224C 0484      CPC	R8,R4
    0224D 0495      CPC	R9,R5
    0224E F050      BCS	0x2259
    0224F A588      LDD	R24,Y+40
    02250 A599      LDD	R25,Y+41
    02251 9604      ADIW	R24,4
    02252 017C      MOVW	R14,R24
    02253 01FC      MOVW	R30,R24
    02254 8180      LD	R24,Z
    02255 6880      ORI	R24,0x80
    02256 8380      ST	Z,R24
    02257 E002      LDI	R16,2
    02258 C0E4      RJMP	0x233D
(2919) 					fp->clust = clst;
    02259 802A      LDD	R2,Y+2
    0225A 803B      LDD	R3,Y+3
    0225B 804C      LDD	R4,Y+4
    0225C 805D      LDD	R5,Y+5
    0225D A5E8      LDD	R30,Y+40
    0225E A5F9      LDD	R31,Y+41
    0225F 9672      ADIW	R30,0x12
    02260 8220      ST	Z,R2
    02261 8231      STD	Z+1,R3
    02262 8242      STD	Z+2,R4
    02263 8253      STD	Z+3,R5
(2920) 					fp->fptr += bcs;
    02264 A588      LDD	R24,Y+40
    02265 A599      LDD	R25,Y+41
    02266 9606      ADIW	R24,6
    02267 017C      MOVW	R14,R24
    02268 802E      LDD	R2,Y+6
    02269 803F      LDD	R3,Y+7
    0226A 8448      LDD	R4,Y+8
    0226B 8459      LDD	R5,Y+9
    0226C 01FC      MOVW	R30,R24
    0226D 8060      LD	R6,Z
    0226E 8071      LDD	R7,Z+1
    0226F 8082      LDD	R8,Z+2
    02270 8093      LDD	R9,Z+3
    02271 0C62      ADD	R6,R2
    02272 1C73      ADC	R7,R3
    02273 1C84      ADC	R8,R4
    02274 1C95      ADC	R9,R5
    02275 8260      ST	Z,R6
    02276 8271      STD	Z+1,R7
    02277 8282      STD	Z+2,R8
    02278 8293      STD	Z+3,R9
(2921) 					ofs -= bcs;
    02279 A46A      LDD	R6,Y+42
    0227A A47B      LDD	R7,Y+43
    0227B A48C      LDD	R8,Y+44
    0227C A49D      LDD	R9,Y+45
    0227D 1862      SUB	R6,R2
    0227E 0873      SBC	R7,R3
    0227F 0884      SBC	R8,R4
    02280 0895      SBC	R9,R5
    02281 A66A      STD	Y+42,R6
    02282 A67B      STD	Y+43,R7
    02283 A68C      STD	Y+44,R8
    02284 A69D      STD	Y+45,R9
    02285 802E      LDD	R2,Y+6
    02286 803F      LDD	R3,Y+7
    02287 8448      LDD	R4,Y+8
    02288 8459      LDD	R5,Y+9
    02289 A46A      LDD	R6,Y+42
    0228A A47B      LDD	R7,Y+43
    0228B A48C      LDD	R8,Y+44
    0228C A49D      LDD	R9,Y+45
    0228D 1426      CP	R2,R6
    0228E 0437      CPC	R3,R7
    0228F 0448      CPC	R4,R8
    02290 0459      CPC	R5,R9
    02291 F408      BCC	0x2293
    02292 CF4B      RJMP	0x21DE
(2922) 				}
(2923) 				fp->fptr += ofs;
    02293 A588      LDD	R24,Y+40
    02294 A599      LDD	R25,Y+41
    02295 9606      ADIW	R24,6
    02296 017C      MOVW	R14,R24
    02297 A42A      LDD	R2,Y+42
    02298 A43B      LDD	R3,Y+43
    02299 A44C      LDD	R4,Y+44
    0229A A45D      LDD	R5,Y+45
    0229B 01FC      MOVW	R30,R24
    0229C 8060      LD	R6,Z
    0229D 8071      LDD	R7,Z+1
    0229E 8082      LDD	R8,Z+2
    0229F 8093      LDD	R9,Z+3
    022A0 0C62      ADD	R6,R2
    022A1 1C73      ADC	R7,R3
    022A2 1C84      ADC	R8,R4
    022A3 1C95      ADC	R9,R5
    022A4 8260      ST	Z,R6
    022A5 8271      STD	Z+1,R7
    022A6 8282      STD	Z+2,R8
    022A7 8293      STD	Z+3,R9
(2924) 				if (ofs % SS(fp->fs)) {
    022A8 EF4F      LDI	R20,0xFF
    022A9 E051      LDI	R21,1
    022AA E060      LDI	R22,0
    022AB E070      LDI	R23,0
    022AC 2224      AND	R2,R20
    022AD 2235      AND	R3,R21
    022AE 2246      AND	R4,R22
    022AF 2257      AND	R5,R23
    022B0 9488      BCLR	0
    022B1 2022      TST	R2
    022B2 0432      CPC	R3,R2
    022B3 0442      CPC	R4,R2
    022B4 0452      CPC	R5,R2
    022B5 F409      BNE	0x22B7
    022B6 C03A      RJMP	0x22F1
(2925) 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    022B7 802A      LDD	R2,Y+2
    022B8 803B      LDD	R3,Y+3
    022B9 804C      LDD	R4,Y+4
    022BA 805D      LDD	R5,Y+5
    022BB 8248      ST	Y,R4
    022BC 8259      STD	Y+1,R5
    022BD 0191      MOVW	R18,R2
    022BE A5E8      LDD	R30,Y+40
    022BF A5F9      LDD	R31,Y+41
    022C0 8100      LD	R16,Z
    022C1 8111      LDD	R17,Z+1
    022C2 940E 04BB CALL	_clust2sect
    022C4 870A      STD	Y+10,R16
    022C5 871B      STD	Y+11,R17
    022C6 872C      STD	Y+12,R18
    022C7 873D      STD	Y+13,R19
(2926) 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    022C8 842A      LDD	R2,Y+10
    022C9 843B      LDD	R3,Y+11
    022CA 844C      LDD	R4,Y+12
    022CB 845D      LDD	R5,Y+13
    022CC 9488      BCLR	0
    022CD 2022      TST	R2
    022CE 0432      CPC	R3,R2
    022CF 0442      CPC	R4,R2
    022D0 0452      CPC	R5,R2
    022D1 F451      BNE	0x22DC
    022D2 A588      LDD	R24,Y+40
    022D3 A599      LDD	R25,Y+41
    022D4 9604      ADIW	R24,4
    022D5 017C      MOVW	R14,R24
    022D6 01FC      MOVW	R30,R24
    022D7 8180      LD	R24,Z
    022D8 6880      ORI	R24,0x80
    022D9 8380      ST	Z,R24
    022DA E002      LDI	R16,2
    022DB C061      RJMP	0x233D
(2927) 					nsect += ofs / SS(fp->fs);
    022DC E089      LDI	R24,0x9
    022DD E090      LDI	R25,0
    022DE A50A      LDD	R16,Y+42
    022DF A51B      LDD	R17,Y+43
    022E0 A52C      LDD	R18,Y+44
    022E1 A53D      LDD	R19,Y+45
    022E2 938A      ST	-Y,R24
    022E3 940E 4142 CALL	lsr32
    022E5 842A      LDD	R2,Y+10
    022E6 843B      LDD	R3,Y+11
    022E7 844C      LDD	R4,Y+12
    022E8 845D      LDD	R5,Y+13
    022E9 0E20      ADD	R2,R16
    022EA 1E31      ADC	R3,R17
    022EB 1E42      ADC	R4,R18
    022EC 1E53      ADC	R5,R19
    022ED 862A      STD	Y+10,R2
    022EE 863B      STD	Y+11,R3
    022EF 864C      STD	Y+12,R4
    022F0 865D      STD	Y+13,R5
(2928) 				}
(2929) 			}
(2930) 		}
(2931) 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    022F1 EF4F      LDI	R20,0xFF
    022F2 E051      LDI	R21,1
    022F3 E060      LDI	R22,0
    022F4 E070      LDI	R23,0
    022F5 A5E8      LDD	R30,Y+40
    022F6 A5F9      LDD	R31,Y+41
    022F7 9636      ADIW	R30,6
    022F8 8020      LD	R2,Z
    022F9 8031      LDD	R3,Z+1
    022FA 8042      LDD	R4,Z+2
    022FB 8053      LDD	R5,Z+3
    022FC 2224      AND	R2,R20
    022FD 2235      AND	R3,R21
    022FE 2246      AND	R4,R22
    022FF 2257      AND	R5,R23
    02300 9488      BCLR	0
    02301 2022      TST	R2
    02302 0432      CPC	R3,R2
    02303 0442      CPC	R4,R2
    02304 0452      CPC	R5,R2
    02305 F0C1      BEQ	0x231E
    02306 A5E8      LDD	R30,Y+40
    02307 A5F9      LDD	R31,Y+41
    02308 9676      ADIW	R30,0x16
    02309 8020      LD	R2,Z
    0230A 8031      LDD	R3,Z+1
    0230B 8042      LDD	R4,Z+2
    0230C 8053      LDD	R5,Z+3
    0230D 846A      LDD	R6,Y+10
    0230E 847B      LDD	R7,Y+11
    0230F 848C      LDD	R8,Y+12
    02310 849D      LDD	R9,Y+13
    02311 1462      CP	R6,R2
    02312 0473      CPC	R7,R3
    02313 0484      CPC	R8,R4
    02314 0495      CPC	R9,R5
    02315 F041      BEQ	0x231E
(2932) #if !_FS_TINY
(2933) #if !_FS_READONLY
(2934) 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
(2935) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2936) 					ABORT(fp->fs, FR_DISK_ERR);
(2937) 				fp->flag &= ~FA__DIRTY;
(2938) 			}
(2939) #endif
(2940) 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
(2941) 				ABORT(fp->fs, FR_DISK_ERR);
(2942) #endif
(2943) 			fp->dsect = nsect;
    02316 0113      MOVW	R2,R6
    02317 0124      MOVW	R4,R8
    02318 A5E8      LDD	R30,Y+40
    02319 A5F9      LDD	R31,Y+41
    0231A 8A26      STD	Z+22,R2
    0231B 8A37      STD	Z+23,R3
    0231C 8E40      STD	Z+24,R4
    0231D 8E51      STD	Z+25,R5
(2944) 		}
(2945) #if !_FS_READONLY
(2946) 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    0231E A5E8      LDD	R30,Y+40
    0231F A5F9      LDD	R31,Y+41
    02320 8422      LDD	R2,Z+10
    02321 8433      LDD	R3,Z+11
    02322 8444      LDD	R4,Z+12
    02323 8455      LDD	R5,Z+13
    02324 8066      LDD	R6,Z+6
    02325 8077      LDD	R7,Z+7
    02326 8480      LDD	R8,Z+8
    02327 8491      LDD	R9,Z+9
    02328 1426      CP	R2,R6
    02329 0437      CPC	R3,R7
    0232A 0448      CPC	R4,R8
    0232B 0459      CPC	R5,R9
    0232C F478      BCC	0x233C
(2947) 			fp->fsize = fp->fptr;
    0232D 8026      LDD	R2,Z+6
    0232E 8037      LDD	R3,Z+7
    0232F 8440      LDD	R4,Z+8
    02330 8451      LDD	R5,Z+9
    02331 8622      STD	Z+10,R2
    02332 8633      STD	Z+11,R3
    02333 8644      STD	Z+12,R4
    02334 8655      STD	Z+13,R5
(2948) 			fp->flag |= FA__WRITTEN;
    02335 01CF      MOVW	R24,R30
    02336 9604      ADIW	R24,4
    02337 016C      MOVW	R12,R24
    02338 01FC      MOVW	R30,R24
    02339 8180      LD	R24,Z
    0233A 6280      ORI	R24,0x20
    0233B 8380      ST	Z,R24
(2949) 		}
(2950) #endif
(2951) 	}
(2952) 
(2953) 	LEAVE_FF(fp->fs, res);
    0233C 2D0A      MOV	R16,R10
    0233D 966E      ADIW	R28,0x1E
    0233E 940E 409C CALL	pop_xgsetF0FC
    02340 9624      ADIW	R28,4
    02341 9508      RET
_f_opendir:
  sfn                  --> Y,+1
  res                  --> R20
  path                 --> Y,+19
  dj                   --> R22
    02342 933A      ST	-Y,R19
    02343 932A      ST	-Y,R18
    02344 940E 40C6 CALL	push_xgsetF00C
    02346 01B8      MOVW	R22,R16
    02347 972D      SBIW	R28,0xD
(2954) }
(2955) 
(2956) 
(2957) 
(2958) #if _FS_MINIMIZE <= 1
(2959) /*-----------------------------------------------------------------------*/
(2960) /* Create a Directroy Object                                             */
(2961) /*-----------------------------------------------------------------------*/
(2962) 
(2963) FRESULT f_opendir (
(2964) 	DIR *dj,			/* Pointer to directory object to create */
(2965) 	const TCHAR *path	/* Pointer to the directory path */
(2966) )
(2967) {
(2968) 	FRESULT res;
(2969) 	DEF_NAMEBUF;
(2970) 
(2971) 
(2972) 	res = chk_mounted(&path, &dj->fs, 0);
    02348 2422      CLR	R2
    02349 8228      ST	Y,R2
    0234A 019B      MOVW	R18,R22
    0234B 018E      MOVW	R16,R28
    0234C 5E0D      SUBI	R16,0xED
    0234D 4F1F      SBCI	R17,0xFF
    0234E 940E 1162 CALL	ff.c:chk_mounted
    02350 2F40      MOV	R20,R16
(2973) 	if (res == FR_OK) {
    02351 2300      TST	R16
    02352 F009      BEQ	0x2354
    02353 C05C      RJMP	0x23B0
(2974) 		INIT_BUF(*dj);
    02354 01CE      MOVW	R24,R28
    02355 9601      ADIW	R24,1
    02356 01FB      MOVW	R30,R22
    02357 8B95      STD	Z+21,R25
    02358 8B84      STD	Z+20,R24
(2975) 		res = follow_path(dj, path);			/* Follow the path to the directory */
    02359 892B      LDD	R18,Y+19
    0235A 893C      LDD	R19,Y+20
    0235B 018F      MOVW	R16,R30
    0235C 940E 1016 CALL	ff.c:follow_path
    0235E 2F40      MOV	R20,R16
(2976) 		FREE_BUF();
(2977) 		if (res == FR_OK) {						/* Follow completed */
    0235F 2300      TST	R16
    02360 F009      BEQ	0x2362
    02361 C04B      RJMP	0x23AD
(2978) 			if (dj->dir) {						/* It is not the root dir */
    02362 01FB      MOVW	R30,R22
    02363 8822      LDD	R2,Z+18
    02364 8833      LDD	R3,Z+19
    02365 2022      TST	R2
    02366 F419      BNE	0x236A
    02367 2033      TST	R3
    02368 F409      BNE	0x236A
    02369 C032      RJMP	0x239C
(2979) 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    0236A 93AF      PUSH	R26
    0236B 93BF      PUSH	R27
    0236C 89A2      LDD	R26,Z+18
    0236D 89B3      LDD	R27,Z+19
    0236E 01FD      MOVW	R30,R26
    0236F 91BF      POP	R27
    02370 91AF      POP	R26
    02371 8423      LDD	R2,Z+11
    02372 FE24      SBRS	R2,4
    02373 C027      RJMP	0x239B
(2980) 					dj->sclust = LD_CLUST(dj->dir);
    02374 01FB      MOVW	R30,R22
    02375 88A2      LDD	R10,Z+18
    02376 88B3      LDD	R11,Z+19
    02377 01F5      MOVW	R30,R10
    02378 8C22      LDD	R2,Z+26
    02379 2433      CLR	R3
    0237A 8C43      LDD	R4,Z+27
    0237B 2455      CLR	R5
    0237C 2C54      MOV	R5,R4
    0237D 2444      CLR	R4
    0237E 2842      OR	R4,R2
    0237F 2853      OR	R5,R3
    02380 0112      MOVW	R2,R4
    02381 2444      CLR	R4
    02382 2455      CLR	R5
    02383 8864      LDD	R6,Z+20
    02384 2477      CLR	R7
    02385 8885      LDD	R8,Z+21
    02386 2499      CLR	R9
    02387 2C98      MOV	R9,R8
    02388 2488      CLR	R8
    02389 2886      OR	R8,R6
    0238A 2897      OR	R9,R7
    0238B 0134      MOVW	R6,R8
    0238C 2488      CLR	R8
    0238D 2499      CLR	R9
    0238E 0143      MOVW	R8,R6
    0238F 2466      CLR	R6
    02390 2477      CLR	R7
    02391 2862      OR	R6,R2
    02392 2873      OR	R7,R3
    02393 2884      OR	R8,R4
    02394 2895      OR	R9,R5
    02395 01FB      MOVW	R30,R22
    02396 8266      STD	Z+6,R6
    02397 8277      STD	Z+7,R7
    02398 8680      STD	Z+8,R8
    02399 8691      STD	Z+9,R9
(2981) 				} else {						/* The object is not a directory */
    0239A C001      RJMP	0x239C
(2982) 					res = FR_NO_PATH;
    0239B E045      LDI	R20,5
(2983) 				}
(2984) 			}
(2985) 			if (res == FR_OK) {
    0239C 2344      TST	R20
    0239D F479      BNE	0x23AD
(2986) 				dj->id = dj->fs->id;
    0239E 01FB      MOVW	R30,R22
    0239F 81A0      LD	R26,Z
    023A0 81B1      LDD	R27,Z+1
    023A1 9616      ADIW	R26,6
    023A2 902D      LD	R2,X+
    023A3 903C      LD	R3,X
    023A4 8233      STD	Z+3,R3
    023A5 8222      STD	Z+2,R2
(2987) 				res = dir_sdi(dj, 0);			/* Rewind dir */
    023A6 2722      CLR	R18
    023A7 2733      CLR	R19
    023A8 018F      MOVW	R16,R30
    023A9 940E 0AC0 CALL	ff.c:dir_sdi
    023AB 2EA0      MOV	R10,R16
    023AC 2D4A      MOV	R20,R10
(2988) 			}
(2989) 		}
(2990) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
    023AD 3044      CPI	R20,4
    023AE F409      BNE	0x23B0
    023AF E045      LDI	R20,5
(2991) 	}
(2992) 
(2993) 	LEAVE_FF(dj->fs, res);
    023B0 2F04      MOV	R16,R20
    023B1 962D      ADIW	R28,0xD
    023B2 940E 40CD CALL	pop_xgsetF00C
    023B4 9622      ADIW	R28,2
    023B5 9508      RET
_f_readdir:
  sfn                  --> Y,+0
  res                  --> R20
  fno                  --> R10
  dj                   --> R22
    023B6 940E 40E2 CALL	push_xgsetF03C
    023B8 0159      MOVW	R10,R18
    023B9 01B8      MOVW	R22,R16
    023BA 972C      SBIW	R28,0xC
(2994) }
(2995) 
(2996) 
(2997) 
(2998) 
(2999) /*-----------------------------------------------------------------------*/
(3000) /* Read Directory Entry in Sequense                                      */
(3001) /*-----------------------------------------------------------------------*/
(3002) 
(3003) FRESULT f_readdir (
(3004) 	DIR *dj,			/* Pointer to the open directory object */
(3005) 	FILINFO *fno		/* Pointer to file information to return */
(3006) )
(3007) {
(3008) 	FRESULT res;
(3009) 	DEF_NAMEBUF;
(3010) 
(3011) 
(3012) 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    023BB 01FB      MOVW	R30,R22
    023BC 8122      LDD	R18,Z+2
    023BD 8133      LDD	R19,Z+3
    023BE 8100      LD	R16,Z
    023BF 8111      LDD	R17,Z+1
    023C0 940E 165C CALL	ff.c:validate
    023C2 2F40      MOV	R20,R16
(3013) 	if (res == FR_OK) {
    023C3 2300      TST	R16
    023C4 F009      BEQ	0x23C6
    023C5 C035      RJMP	0x23FB
(3014) 		if (!fno) {
    023C6 20AA      TST	R10
    023C7 F449      BNE	0x23D1
    023C8 20BB      TST	R11
    023C9 F439      BNE	0x23D1
(3015) 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    023CA 2722      CLR	R18
    023CB 2733      CLR	R19
    023CC 018B      MOVW	R16,R22
    023CD 940E 0AC0 CALL	ff.c:dir_sdi
    023CF 2F40      MOV	R20,R16
(3016) 		} else {
    023D0 C02A      RJMP	0x23FB
(3017) 			INIT_BUF(*dj);
    023D1 01CE      MOVW	R24,R28
    023D2 01FB      MOVW	R30,R22
    023D3 8B95      STD	Z+21,R25
    023D4 8B84      STD	Z+20,R24
(3018) 			res = dir_read(dj);				/* Read an directory item */
    023D5 018F      MOVW	R16,R30
    023D6 940E 0DBD CALL	ff.c:dir_read
    023D8 2EC0      MOV	R12,R16
    023D9 2D4C      MOV	R20,R12
(3019) 			if (res == FR_NO_FILE) {		/* Reached end of dir */
    023DA 3004      CPI	R16,4
    023DB F441      BNE	0x23E4
(3020) 				dj->sect = 0;
    023DC 01FB      MOVW	R30,R22
    023DD 963E      ADIW	R30,0xE
    023DE E080      LDI	R24,0
    023DF 8380      ST	Z,R24
    023E0 8381      STD	Z+1,R24
    023E1 8382      STD	Z+2,R24
    023E2 8383      STD	Z+3,R24
(3021) 				res = FR_OK;
    023E3 2744      CLR	R20
(3022) 			}
(3023) 			if (res == FR_OK) {				/* A valid entry is found */
    023E4 2344      TST	R20
    023E5 F4A9      BNE	0x23FB
(3024) 				get_fileinfo(dj, fno);		/* Get the object information */
    023E6 0195      MOVW	R18,R10
    023E7 018B      MOVW	R16,R22
    023E8 940E 0F73 CALL	ff.c:get_fileinfo
(3025) 				res = dir_next(dj, 0);		/* Increment index for next */
    023EA 2722      CLR	R18
    023EB 2733      CLR	R19
    023EC 018B      MOVW	R16,R22
    023ED 940E 0BCA CALL	ff.c:dir_next
    023EF 2EA0      MOV	R10,R16
    023F0 2D4A      MOV	R20,R10
(3026) 				if (res == FR_NO_FILE) {
    023F1 3004      CPI	R16,4
    023F2 F441      BNE	0x23FB
(3027) 					dj->sect = 0;
    023F3 01FB      MOVW	R30,R22
    023F4 963E      ADIW	R30,0xE
    023F5 E080      LDI	R24,0
    023F6 8380      ST	Z,R24
    023F7 8381      STD	Z+1,R24
    023F8 8382      STD	Z+2,R24
    023F9 8383      STD	Z+3,R24
(3028) 					res = FR_OK;
    023FA 2744      CLR	R20
(3029) 				}
(3030) 			}
(3031) 			FREE_BUF();
(3032) 		}
(3033) 	}
(3034) 
(3035) 	LEAVE_FF(dj->fs, res);
    023FB 2F04      MOV	R16,R20
    023FC 962C      ADIW	R28,0xC
    023FD 940C 40EB JMP	pop_xgsetF03C
FILE: D:\LQD\software\master\software_src\delay.c
(0001) /*******************************
(0002)  function ：延时函数
(0003) Clock F  :7.3728M 
(0004) Software : ICCAVR7.14C
(0005) ********************************/
(0006) /*---------------------------------------------------------------------------------
(0007)      延时程序计算方法
(0008)      计数个数j = 延时时间/6*晶振频率 - 1
(0009) ---------------------------------------------------------------------------------*/
(0010) void delayus(unsigned int tttt)   // 1.2us 延时子函数   
(0011) { 
(0012)    do
(0013)    {
(0014)        tttt--;
_delayus:
  tttt                 --> R16
    023FF 5001      SUBI	R16,1
    02400 4010      SBCI	R17,0
(0015)    }
(0016)    while(tttt>1);
    02401 E081      LDI	R24,1
    02402 E090      LDI	R25,0
    02403 1780      CP	R24,R16
    02404 0791      CPC	R25,R17
    02405 F3C8      BCS	0x23FF
    02406 9508      RET
_delayms:
  j                    --> R20
  i                    --> R16
    02407 934A      ST	-Y,R20
    02408 935A      ST	-Y,R21
(0017) }
(0018) void delayms(unsigned int i)                 //1ms延时
(0019)    {
    02409 C00A      RJMP	0x2414
(0020)     while(i--)
(0021)     {                          
(0022) 	    unsigned int j;                
(0023)         for(j=1;j<=1227;j++)   
    0240A E041      LDI	R20,1
    0240B E050      LDI	R21,0
    0240C C002      RJMP	0x240F
    0240D 5F4F      SUBI	R20,0xFF
    0240E 4F5F      SBCI	R21,0xFF
    0240F EC8B      LDI	R24,0xCB
    02410 E094      LDI	R25,4
    02411 1784      CP	R24,R20
    02412 0795      CPC	R25,R21
    02413 F7C8      BCC	0x240D
    02414 0118      MOVW	R2,R16
    02415 5001      SUBI	R16,1
    02416 4010      SBCI	R17,0
    02417 2022      TST	R2
    02418 F789      BNE	0x240A
    02419 2033      TST	R3
    0241A F779      BNE	0x240A
    0241B 9159      LD	R21,Y+
    0241C 9149      LD	R20,Y+
    0241D 9508      RET
_initDevices:
    0241E 940E 40AD CALL	push_xgset003C
FILE: D:\LQD\software\master\software_src\main.c
(0001) #include "config.h"
(0002) #define  N_per_Second  (2.72*60)
(0003) const char tab[]="\t\0";
(0004) const char enter[]="\n\0";
(0005) char buffer[512];
(0006) char TempChar[80]; //存放临时字串
(0007) struct DATA Result;
(0008) struct tm t;
(0009) unsigned long now =0; 
(0010) void debug(UINT8 *str,UINT8 val);
(0011) void WriteSDFile(void);
(0012) struct CONFIG config;
(0013) void initDevices(void){
(0014)      CLI();
    02420 94F8      BCLR	7
(0015) 	 DDRA=0XFF;
    02421 EF8F      LDI	R24,0xFF
    02422 BB8A      OUT	0x1A,R24
(0016) 	 PORTA=0XFF;
    02423 BB8B      OUT	0x1B,R24
(0017) 	 DDRB=0XFF;
    02424 BB87      OUT	0x17,R24
(0018) 	 PORTB=0XFF; 	 
    02425 BB88      OUT	0x18,R24
(0019) 	 DDRC=0XFF;
    02426 BB84      OUT	0x14,R24
(0020) 	 PORTC=0XFF;
    02427 BB85      OUT	0x15,R24
(0021) 	 DDRG=0XFF;
    02428 9380 0064 STS	0x64,R24
(0022) 	 PORTG=0XFF;	 
    0242A 9380 0065 STS	0x65,R24
(0023) 	 SPI_IO_Init(); 
    0242C 940E 38C2 CALL	_SPI_IO_Init
(0024) 	 SD_Init();
    0242E 940E 2B72 CALL	_SD_Init
(0025) 	 uart1_init();
    02430 940E 36EC CALL	_uart1_init
(0026) 	 LCD_INT();delayms(50);LCD_INT();
    02432 940E 38E0 CALL	_LCD_INT
    02434 E302      LDI	R16,0x32
    02435 E010      LDI	R17,0
    02436 940E 2407 CALL	_delayms
    02438 940E 38E0 CALL	_LCD_INT
(0027) 	 LCD_SW(1);
    0243A E001      LDI	R16,1
    0243B 940E 38D6 CALL	_LCD_SW
(0028) 	 config.THRESHOLD_delta_sec=10; //一次检测用时
    0243D E08A      LDI	R24,0xA
    0243E 9380 07CC STS	config+4,R24
    02440 E080      LDI	R24,0
    02441 9380 07CD STS	config+5,R24
    02443 9380 07CE STS	config+6,R24
    02445 9380 07CF STS	config+7,R24
(0029) 	 config.autocheck=0;
    02447 2422      CLR	R2
    02448 9220 07D8 STS	config+16,R2
(0030) 	 config.checkDeltaTime=20;  //自动检测模式 时间间隔
    0244A E184      LDI	R24,0x14
    0244B E090      LDI	R25,0
    0244C 9390 07DA STS	config+18,R25
    0244E 9380 07D9 STS	config+17,R24
(0031) 	 config.readMode = 0;
    02450 9220 07DB STS	config+19,R2
(0032) 	 SEI();
    02452 9478      BSET	7
    02453 940C 4087 JMP	pop_xgset003C
(0033) }
(0034) void timer1_init(void)
(0035) {
(0036)  TCCR1B = 0x00; //stop
_timer1_init:
    02455 2422      CLR	R2
    02456 BC2E      OUT	0x2E,R2
(0037)  TCNT1H = 0x00 /*INVALID SETTING*/; //setup
    02457 BC2D      OUT	0x2D,R2
(0038)  TCNT1L = 0x00 /*INVALID SETTING*/;
    02458 BC2C      OUT	0x2C,R2
(0039)  TCCR1A = 0x00;
    02459 BC2F      OUT	0x2F,R2
(0040)  TCCR1B = 0x46; //start Timer
    0245A E486      LDI	R24,0x46
    0245B BD8E      OUT	0x2E,R24
    0245C 9508      RET
_main:
  keycode              --> Y,+1
  i                    --> R10
  filename             --> Y,+513
  buf512               --> Y,+0
  tmp                  --> R14
    0245D 97EF      SBIW	R28,0x3F
    0245E 97EF      SBIW	R28,0x3F
    0245F 97EF      SBIW	R28,0x3F
    02460 97EF      SBIW	R28,0x3F
    02461 97EF      SBIW	R28,0x3F
    02462 97EF      SBIW	R28,0x3F
    02463 97EF      SBIW	R28,0x3F
    02464 97EF      SBIW	R28,0x3F
    02465 9767      SBIW	R28,0x17
(0041) }
(0042) ////////////////////////////////////////////////////////////////
(0043) void main(void){
(0044) 	 UINT8 tmp,keycode;
(0045) 	 UINT8 buf512[513];
(0046) 	 char filename[]="201302.xls\0\0\0";
    02466 E189      LDI	R24,0x19
    02467 E091      LDI	R25,1
    02468 01FE      MOVW	R30,R28
    02469 5FEF      SUBI	R30,0xFF
    0246A 4FFD      SBCI	R31,0xFD
    0246B E00E      LDI	R16,0xE
    0246C E010      LDI	R17,0
    0246D 93FA      ST	-Y,R31
    0246E 93EA      ST	-Y,R30
    0246F 939A      ST	-Y,R25
    02470 938A      ST	-Y,R24
    02471 940E 414E CALL	asgnblk
(0047) 	 int i=0;
    02473 24AA      CLR	R10
    02474 24BB      CLR	R11
(0048) 	 initDevices();
    02475 DFA8      RCALL	_initDevices
(0049) 	 dateRefresh(1);
    02476 E001      LDI	R16,1
    02477 940E 359F CALL	_dateRefresh
(0050) 	 WriteFileHead();
    02479 D103      RCALL	_WriteFileHead
(0051)      Result.Index=findIndex(get_name(filename),buf512);
    0247A 018E      MOVW	R16,R28
    0247B 5F0F      SUBI	R16,0xFF
    0247C 4F1D      SBCI	R17,0xFD
    0247D D5CA      RCALL	_get_name
    0247E 019E      MOVW	R18,R28
    0247F D240      RCALL	_findIndex
    02480 0118      MOVW	R2,R16
    02481 2444      CLR	R4
    02482 2455      CLR	R5
    02483 9230 0563 STS	Result+11,R3
    02485 9220 0562 STS	Result+10,R2
    02487 9250 0565 STS	Result+13,R5
    02489 9240 0564 STS	Result+12,R4
(0052) 	 //selfTest();
(0053) 	 GUI_welcome();
    0248B 940E 3582 CALL	_GUI_welcome
    0248D C004      RJMP	0x2492
(0054) 	 while(1){
(0055) 	     delayms(8000);
    0248E E400      LDI	R16,0x40
    0248F E11F      LDI	R17,0x1F
    02490 940E 2407 CALL	_delayms
    02492 CFFB      RJMP	0x248E
(0056) 	 }
(0057) 	 while(1){
(0058) 	    tmp=GUI_mainmeu();
    02493 940E 2D4B CALL	_GUI_mainmeu
    02495 2EC0      MOV	R12,R16
    02496 2CEC      MOV	R14,R12
(0059) 		switch(tmp){
    02497 2D4E      MOV	R20,R14
    02498 2755      CLR	R21
    02499 3043      CPI	R20,3
    0249A E0E0      LDI	R30,0
    0249B 075E      CPC	R21,R30
    0249C F069      BEQ	0x24AA
    0249D 3044      CPI	R20,4
    0249E E0E0      LDI	R30,0
    0249F 075E      CPC	R21,R30
    024A0 F061      BEQ	0x24AD
    024A1 3045      CPI	R20,5
    024A2 E0E0      LDI	R30,0
    024A3 075E      CPC	R21,R30
    024A4 F059      BEQ	0x24B0
    024A5 3047      CPI	R20,7
    024A6 E0E0      LDI	R30,0
    024A7 075E      CPC	R21,R30
    024A8 F059      BEQ	0x24B4
    024A9 C00B      RJMP	0x24B5
(0060) 		    case 3 : GUI_check(); break; 
    024AA 940E 2E2F CALL	_GUI_check
    024AC C008      RJMP	0x24B5
(0061) 			case 4 : GUI_set_time(); break ;
    024AD 940E 321E CALL	_GUI_set_time
    024AF C005      RJMP	0x24B5
(0062) 			case 5 : GUI_readback(buf512); break;
    024B0 018E      MOVW	R16,R28
    024B1 940E 3466 CALL	_GUI_readback
    024B3 C001      RJMP	0x24B5
(0063) 			//case 6 : GUI_send_date();
(0064) 			case 7 : selfTest(); break ;
    024B4 D00F      RCALL	_selfTest
(0065) 			default : break;
(0066) 	   }
(0067) 	   delayms(100);
    024B5 E604      LDI	R16,0x64
    024B6 E010      LDI	R17,0
    024B7 940E 2407 CALL	_delayms
    024B9 CFD9      RJMP	0x2493
    024BA 96EF      ADIW	R28,0x3F
    024BB 96EF      ADIW	R28,0x3F
    024BC 96EF      ADIW	R28,0x3F
    024BD 96EF      ADIW	R28,0x3F
    024BE 96EF      ADIW	R28,0x3F
    024BF 96EF      ADIW	R28,0x3F
    024C0 96EF      ADIW	R28,0x3F
    024C1 96EF      ADIW	R28,0x3F
    024C2 9667      ADIW	R28,0x17
    024C3 9508      RET
_selfTest:
  str2                 --> Y,+12
  str1                 --> Y,+6
  tmp                  --> Y,+2
    024C4 9762      SBIW	R28,0x12
(0068) 	 }
(0069) 
(0070) }
(0071) void selfTest(void){
(0072) 	float tmp=0;                                                                
    024C5 EB04      LDI	R16,0xB4
    024C6 E010      LDI	R17,0
    024C7 940E 402F CALL	elpm32
    024C9 830A      STD	Y+2,R16
    024CA 831B      STD	Y+3,R17
    024CB 832C      STD	Y+4,R18
    024CC 833D      STD	Y+5,R19
(0073) 	char str1[6],str2[6];
(0074) 	
(0075) 	 //自检程序
(0076) 	lp("自检程序");delayms(500);
    024CD E401      LDI	R16,0x41
    024CE E012      LDI	R17,2
    024CF 940E 3C0F CALL	_lp
    024D1 EF04      LDI	R16,0xF4
    024D2 E011      LDI	R17,1
    024D3 940E 2407 CALL	_delayms
(0077) 	lp("外部温度 ");
    024D5 E307      LDI	R16,0x37
    024D6 E012      LDI	R17,2
    024D7 940E 3C0F CALL	_lp
(0078) 	tmp=read_T_NUM(0);
    024D9 2700      CLR	R16
    024DA 940E 3E42 CALL	_read_T_NUM
    024DC 830A      STD	Y+2,R16
    024DD 831B      STD	Y+3,R17
    024DE 832C      STD	Y+4,R18
    024DF 833D      STD	Y+5,R19
(0079) 	ftochr(tmp,str1);
    024E0 01CE      MOVW	R24,R28
    024E1 9606      ADIW	R24,6
    024E2 8399      STD	Y+1,R25
    024E3 8388      ST	Y,R24
    024E4 810A      LDD	R16,Y+2
    024E5 811B      LDD	R17,Y+3
    024E6 812C      LDD	R18,Y+4
    024E7 813D      LDD	R19,Y+5
    024E8 D465      RCALL	_ftochr
(0080) 	str1[6]=0;
    024E9 2422      CLR	R2
    024EA 862C      STD	Y+12,R2
(0081) 	lp(str1);
    024EB 018E      MOVW	R16,R28
    024EC 5F0A      SUBI	R16,0xFA
    024ED 4F1F      SBCI	R17,0xFF
    024EE 940E 3C0F CALL	_lp
(0082) 	delayms(500);
    024F0 EF04      LDI	R16,0xF4
    024F1 E011      LDI	R17,1
    024F2 940E 2407 CALL	_delayms
(0083) 	lp("内部温度");
    024F4 E20E      LDI	R16,0x2E
    024F5 E012      LDI	R17,2
    024F6 940E 3C0F CALL	_lp
(0084) 	tmp=read_T_NUM(1);
    024F8 E001      LDI	R16,1
    024F9 940E 3E42 CALL	_read_T_NUM
    024FB 830A      STD	Y+2,R16
    024FC 831B      STD	Y+3,R17
    024FD 832C      STD	Y+4,R18
    024FE 833D      STD	Y+5,R19
(0085) 	ftochr(tmp,str2);
    024FF 01CE      MOVW	R24,R28
    02500 960C      ADIW	R24,0xC
    02501 8399      STD	Y+1,R25
    02502 8388      ST	Y,R24
    02503 810A      LDD	R16,Y+2
    02504 811B      LDD	R17,Y+3
    02505 812C      LDD	R18,Y+4
    02506 813D      LDD	R19,Y+5
    02507 D446      RCALL	_ftochr
(0086) 	str2[6]=0;
    02508 2422      CLR	R2
    02509 8A2A      STD	Y+18,R2
(0087) 	lp(str2);
    0250A 018E      MOVW	R16,R28
    0250B 5F04      SUBI	R16,0xF4
    0250C 4F1F      SBCI	R17,0xFF
    0250D 940E 3C0F CALL	_lp
(0088) 	delayms(500);
    0250F EF04      LDI	R16,0xF4
    02510 E011      LDI	R17,1
    02511 940E 2407 CALL	_delayms
(0089) 	lp("风速脉冲：");delayms(500);
    02513 E203      LDI	R16,0x23
    02514 E012      LDI	R17,2
    02515 940E 3C0F CALL	_lp
    02517 EF04      LDI	R16,0xF4
    02518 E011      LDI	R17,1
    02519 940E 2407 CALL	_delayms
(0090) 	lp("蜂鸣器"); beep(2,2);delayms(500);
    0251B E10C      LDI	R16,0x1C
    0251C E012      LDI	R17,2
    0251D 940E 3C0F CALL	_lp
    0251F E022      LDI	R18,2
    02520 E002      LDI	R16,2
    02521 940E 3C85 CALL	_beep
    02523 EF04      LDI	R16,0xF4
    02524 E011      LDI	R17,1
    02525 940E 2407 CALL	_delayms
(0091) 	lp("power 指示灯");
    02527 E00F      LDI	R16,0xF
    02528 E012      LDI	R17,2
    02529 940E 3C0F CALL	_lp
(0092) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    0252B 9AA7      SBI	0x14,7
    0252C 98AF      CBI	0x15,7
    0252D E604      LDI	R16,0x64
    0252E E010      LDI	R17,0
    0252F 940E 2407 CALL	_delayms
    02531 9AA7      SBI	0x14,7
    02532 9AAF      SBI	0x15,7
    02533 E604      LDI	R16,0x64
    02534 E010      LDI	R17,0
    02535 940E 2407 CALL	_delayms
(0093) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02537 9AA7      SBI	0x14,7
    02538 98AF      CBI	0x15,7
    02539 E604      LDI	R16,0x64
    0253A E010      LDI	R17,0
    0253B 940E 2407 CALL	_delayms
    0253D 9AA7      SBI	0x14,7
    0253E 9AAF      SBI	0x15,7
    0253F E604      LDI	R16,0x64
    02540 E010      LDI	R17,0
    02541 940E 2407 CALL	_delayms
(0094) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02543 9AA7      SBI	0x14,7
    02544 98AF      CBI	0x15,7
    02545 E604      LDI	R16,0x64
    02546 E010      LDI	R17,0
    02547 940E 2407 CALL	_delayms
    02549 9AA7      SBI	0x14,7
    0254A 9AAF      SBI	0x15,7
    0254B E604      LDI	R16,0x64
    0254C E010      LDI	R17,0
    0254D 940E 2407 CALL	_delayms
(0095) 	delayms(500);
    0254F EF04      LDI	R16,0xF4
    02550 E011      LDI	R17,1
    02551 940E 2407 CALL	_delayms
(0096) 	lp("加热开关");
    02553 E006      LDI	R16,6
    02554 E012      LDI	R17,2
    02555 940E 3C0F CALL	_lp
(0097) 	RELAY_ON();delayms(100);  
    02557 9AAD      SBI	0x15,5
    02558 E604      LDI	R16,0x64
    02559 E010      LDI	R17,0
    0255A 940E 2407 CALL	_delayms
(0098) 	RELAY_OFF();delayms(100);
    0255C 98AD      CBI	0x15,5
    0255D E604      LDI	R16,0x64
    0255E E010      LDI	R17,0
    0255F 940E 2407 CALL	_delayms
(0099) 	RELAY_ON();delayms(100);
    02561 9AAD      SBI	0x15,5
    02562 E604      LDI	R16,0x64
    02563 E010      LDI	R17,0
    02564 940E 2407 CALL	_delayms
(0100) 	RELAY_OFF();delayms(100);
    02566 98AD      CBI	0x15,5
    02567 E604      LDI	R16,0x64
    02568 E010      LDI	R17,0
    02569 940E 2407 CALL	_delayms
(0101) 	lp("  ");delayms(500);
    0256B E003      LDI	R16,3
    0256C E012      LDI	R17,2
    0256D 940E 3C0F CALL	_lp
    0256F EF04      LDI	R16,0xF4
    02570 E011      LDI	R17,1
    02571 940E 2407 CALL	_delayms
(0102) 	lp("完成自检");delayms(500);
    02573 EF0A      LDI	R16,0xFA
    02574 E011      LDI	R17,1
    02575 940E 3C0F CALL	_lp
    02577 EF04      LDI	R16,0xF4
    02578 E011      LDI	R17,1
    02579 940E 2407 CALL	_delayms
    0257B 9662      ADIW	R28,0x12
    0257C 9508      RET
_WriteFileHead:
  fs                   --> Y,+177
  bw                   --> Y,+175
  fnamep               --> Y,+161
  itam                 --> Y,+38
  file                 --> Y,+4
  res                  --> R10
    0257D 940E 40AD CALL	push_xgset003C
    0257F 97EF      SBIW	R28,0x3F
    02580 97EF      SBIW	R28,0x3F
    02581 97EF      SBIW	R28,0x3F
    02582 97EF      SBIW	R28,0x3F
    02583 97EF      SBIW	R28,0x3F
    02584 97EF      SBIW	R28,0x3F
    02585 97EF      SBIW	R28,0x3F
    02586 97EF      SBIW	R28,0x3F
    02587 97EF      SBIW	R28,0x3F
    02588 97EF      SBIW	R28,0x3F
    02589 97EF      SBIW	R28,0x3F
    0258A 97AA      SBIW	R28,0x2A
(0103) 	  
(0104) }
(0105) void WriteFileHead(void)   
(0106) {
(0107)  	 unsigned int bw;
(0108) 	 FRESULT res;
(0109) 	 FATFS fs;
(0110) 	 FIL file;
(0111) 	 char fnamep[]="201201.xls\0\0\0"; 
    0258B E287      LDI	R24,0x27
    0258C E091      LDI	R25,1
    0258D 01FE      MOVW	R30,R28
    0258E 55EF      SUBI	R30,0x5F
    0258F 4FFF      SBCI	R31,0xFF
    02590 E00E      LDI	R16,0xE
    02591 E010      LDI	R17,0
    02592 93FA      ST	-Y,R31
    02593 93EA      ST	-Y,R30
    02594 939A      ST	-Y,R25
    02595 938A      ST	-Y,R24
    02596 940E 414E CALL	asgnblk
(0112) 	 UINT8 itam[]="DEV000001\t\t\t\t\t\t\t\t\t\t\r\n序号\t日期\t时分\t温度\t风速\t风冷指数\t等价制冷温度\t相当温度\t冻伤危害性\t安静作业\t中等强度作业\t高强度作业\n\0";
    02598 E385      LDI	R24,0x35
    02599 E091      LDI	R25,1
    0259A 01FE      MOVW	R30,R28
    0259B 96B6      ADIW	R30,0x26
    0259C E70B      LDI	R16,0x7B
    0259D E010      LDI	R17,0
    0259E 93FA      ST	-Y,R31
    0259F 93EA      ST	-Y,R30
    025A0 939A      ST	-Y,R25
    025A1 938A      ST	-Y,R24
    025A2 940E 414E CALL	asgnblk
(0113) 	 res=disk_initialize(0);
    025A4 2700      CLR	R16
    025A5 940E 028D CALL	_disk_initialize
    025A7 2EA0      MOV	R10,R16
(0114) 	 #ifdef _DEBUG
(0115) 	 debug("dinit",res);
    025A8 2D2A      MOV	R18,R10
    025A9 EF04      LDI	R16,0xF4
    025AA E011      LDI	R17,1
    025AB D577      RCALL	_debug
(0116) 	 #endif
(0117) 	 res = f_mount(0, &fs);
    025AC 019E      MOVW	R18,R28
    025AD 542F      SUBI	R18,0x4F
    025AE 4F3F      SBCI	R19,0xFF
    025AF 2700      CLR	R16
    025B0 940E 1679 CALL	_f_mount
    025B2 2EA0      MOV	R10,R16
(0118) 	 #ifdef _DEBUG
(0119)  	 debug("dmnt",res);
    025B3 2D2A      MOV	R18,R10
    025B4 EE0F      LDI	R16,0xEF
    025B5 E011      LDI	R17,1
    025B6 D56C      RCALL	_debug
(0120) 	 #endif
(0121) 	 //get_name(fnamep)
(0122) 	 res = f_open(&file, get_name(fnamep) , FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    025B7 018E      MOVW	R16,R28
    025B8 550F      SUBI	R16,0x5F
    025B9 4F1F      SBCI	R17,0xFF
    025BA D48D      RCALL	_get_name
    025BB 0168      MOVW	R12,R16
    025BC E182      LDI	R24,0x12
    025BD 8388      ST	Y,R24
    025BE 0196      MOVW	R18,R12
    025BF 018E      MOVW	R16,R28
    025C0 5F0C      SUBI	R16,0xFC
    025C1 4F1F      SBCI	R17,0xFF
    025C2 940E 16A4 CALL	_f_open
    025C4 2EC0      MOV	R12,R16
    025C5 2CAC      MOV	R10,R12
(0123) 	 #ifdef _DEBUG
(0124) 	 debug("fopen",res);
    025C6 2D2A      MOV	R18,R10
    025C7 EE09      LDI	R16,0xE9
    025C8 E011      LDI	R17,1
    025C9 D559      RCALL	_debug
(0125) 	 #endif
(0126) 	 res = f_write(&file,itam,sizeof(itam),&bw);   //bw 已写入字节数
    025CA 01CE      MOVW	R24,R28
    025CB 5581      SUBI	R24,0x51
    025CC 4F9F      SBCI	R25,0xFF
    025CD 839B      STD	Y+3,R25
    025CE 838A      STD	Y+2,R24
    025CF E78B      LDI	R24,0x7B
    025D0 E090      LDI	R25,0
    025D1 8399      STD	Y+1,R25
    025D2 8388      ST	Y,R24
    025D3 019E      MOVW	R18,R28
    025D4 5D2A      SUBI	R18,0xDA
    025D5 4F3F      SBCI	R19,0xFF
    025D6 018E      MOVW	R16,R28
    025D7 5F0C      SUBI	R16,0xFC
    025D8 4F1F      SBCI	R17,0xFF
    025D9 940E 1AAB CALL	_f_write
    025DB 2EC0      MOV	R12,R16
    025DC 2CAC      MOV	R10,R12
(0127) 	 #ifdef _DEBUG
(0128) 	 debug("fwrite",res);
    025DD 2D2A      MOV	R18,R10
    025DE EE02      LDI	R16,0xE2
    025DF E011      LDI	R17,1
    025E0 D542      RCALL	_debug
(0129) 	 #endif
(0130) 	 f_close(&file);
    025E1 018E      MOVW	R16,R28
    025E2 5F0C      SUBI	R16,0xFC
    025E3 4F1F      SBCI	R17,0xFF
    025E4 940E 1E75 CALL	_f_close
(0131) 	 f_mount(0, NULL);
    025E6 2722      CLR	R18
    025E7 2733      CLR	R19
    025E8 2700      CLR	R16
    025E9 940E 1679 CALL	_f_mount
    025EB 96EF      ADIW	R28,0x3F
    025EC 96EF      ADIW	R28,0x3F
    025ED 96EF      ADIW	R28,0x3F
    025EE 96EF      ADIW	R28,0x3F
    025EF 96EF      ADIW	R28,0x3F
    025F0 96EF      ADIW	R28,0x3F
    025F1 96EF      ADIW	R28,0x3F
    025F2 96EF      ADIW	R28,0x3F
    025F3 96EF      ADIW	R28,0x3F
    025F4 96EF      ADIW	R28,0x3F
    025F5 96EF      ADIW	R28,0x3F
    025F6 96AA      ADIW	R28,0x2A
    025F7 940C 4087 JMP	pop_xgset003C
_WriteSDFile:
  fnamep               --> Y,+602
  fs                   --> Y,+44
  bw                   --> Y,+42
  lenth                --> Y,+38
  res                  --> R10
  file                 --> Y,+4
    025F9 92AA      ST	-Y,R10
    025FA 92CA      ST	-Y,R12
    025FB 97EF      SBIW	R28,0x3F
    025FC 97EF      SBIW	R28,0x3F
    025FD 97EF      SBIW	R28,0x3F
    025FE 97EF      SBIW	R28,0x3F
    025FF 97EF      SBIW	R28,0x3F
    02600 97EF      SBIW	R28,0x3F
    02601 97EF      SBIW	R28,0x3F
    02602 97EF      SBIW	R28,0x3F
    02603 97EF      SBIW	R28,0x3F
    02604 97E0      SBIW	R28,0x30
(0132) } /////////////////////////////////////////////////
(0133) //       写入文件函数 
(0134) //(创建)打开文件 
(0135) // data 指向欲写入的的字符串 64byt 
(0136) //////////////////////////////////////////////// 
(0137) void WriteSDFile(void)   
(0138) {
(0139)     unsigned int bw;
(0140) 	FRESULT res;
(0141) 	FATFS fs;
(0142)     FIL file;
(0143) 	char fnamep[13];
(0144) 	long lenth=0;
    02605 E080      LDI	R24,0
    02606 A38E      STD	Y+38,R24
    02607 A38F      STD	Y+39,R24
    02608 A788      STD	Y+40,R24
    02609 A789      STD	Y+41,R24
(0145) 	disk_initialize(0);
    0260A 2700      CLR	R16
    0260B 940E 028D CALL	_disk_initialize
(0146) 	res = f_mount(0, &fs);
    0260D 019E      MOVW	R18,R28
    0260E 5D24      SUBI	R18,0xD4
    0260F 4F3F      SBCI	R19,0xFF
    02610 2700      CLR	R16
    02611 940E 1679 CALL	_f_mount
(0147) 	res = f_open(&file,get_name(fnamep), FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    02613 018E      MOVW	R16,R28
    02614 5A06      SUBI	R16,0xA6
    02615 4F1D      SBCI	R17,0xFD
    02616 D431      RCALL	_get_name
    02617 E182      LDI	R24,0x12
    02618 8388      ST	Y,R24
    02619 0198      MOVW	R18,R16
    0261A 018E      MOVW	R16,R28
    0261B 5F0C      SUBI	R16,0xFC
    0261C 4F1F      SBCI	R17,0xFF
    0261D 940E 16A4 CALL	_f_open
(0148) 	lenth=file.fsize;   
    0261F 842E      LDD	R2,Y+14
    02620 843F      LDD	R3,Y+15
    02621 8848      LDD	R4,Y+16
    02622 8859      LDD	R5,Y+17
    02623 A22E      STD	Y+38,R2
    02624 A23F      STD	Y+39,R3
    02625 A648      STD	Y+40,R4
    02626 A659      STD	Y+41,R5
(0149) 	res = f_lseek (&file,lenth);	 
    02627 A02E      LDD	R2,Y+38
    02628 A03F      LDD	R3,Y+39
    02629 A448      LDD	R4,Y+40
    0262A A459      LDD	R5,Y+41
    0262B 8248      ST	Y,R4
    0262C 8259      STD	Y+1,R5
    0262D 0191      MOVW	R18,R2
    0262E 018E      MOVW	R16,R28
    0262F 5F0C      SUBI	R16,0xFC
    02630 4F1F      SBCI	R17,0xFF
    02631 940E 1E85 CALL	_f_lseek
(0150) 	res = f_write(&file,TempChar,64,&bw);   //bw 已写入字节数
    02633 01CE      MOVW	R24,R28
    02634 968A      ADIW	R24,0x2A
    02635 839B      STD	Y+3,R25
    02636 838A      STD	Y+2,R24
    02637 E480      LDI	R24,0x40
    02638 E090      LDI	R25,0
    02639 8399      STD	Y+1,R25
    0263A 8388      ST	Y,R24
    0263B E028      LDI	R18,0x8
    0263C E035      LDI	R19,5
    0263D 018E      MOVW	R16,R28
    0263E 5F0C      SUBI	R16,0xFC
    0263F 4F1F      SBCI	R17,0xFF
    02640 940E 1AAB CALL	_f_write
    02642 2EC0      MOV	R12,R16
    02643 2CAC      MOV	R10,R12
(0151) 	f_close(&file);
    02644 018E      MOVW	R16,R28
    02645 5F0C      SUBI	R16,0xFC
    02646 4F1F      SBCI	R17,0xFF
    02647 940E 1E75 CALL	_f_close
(0152) 	f_mount(0, NULL);
    02649 2722      CLR	R18
    0264A 2733      CLR	R19
    0264B 2700      CLR	R16
    0264C 940E 1679 CALL	_f_mount
    0264E 96EF      ADIW	R28,0x3F
    0264F 96EF      ADIW	R28,0x3F
    02650 96EF      ADIW	R28,0x3F
    02651 96EF      ADIW	R28,0x3F
    02652 96EF      ADIW	R28,0x3F
    02653 96EF      ADIW	R28,0x3F
    02654 96EF      ADIW	R28,0x3F
    02655 96EF      ADIW	R28,0x3F
    02656 96EF      ADIW	R28,0x3F
    02657 96E0      ADIW	R28,0x30
    02658 90C9      LD	R12,Y+
    02659 90A9      LD	R10,Y+
    0265A 9508      RET
_ReadSDFile:
  fs                   --> Y,+53
  bw                   --> Y,+51
  fnamep               --> Y,+38
  file                 --> Y,+4
  res                  --> R20
  data                 --> R10
  index                --> R22
    0265B 940E 40E2 CALL	push_xgsetF03C
    0265D 0159      MOVW	R10,R18
    0265E 01B8      MOVW	R22,R16
    0265F 97EF      SBIW	R28,0x3F
    02660 97EF      SBIW	R28,0x3F
    02661 97EF      SBIW	R28,0x3F
    02662 97EF      SBIW	R28,0x3F
    02663 97EF      SBIW	R28,0x3F
    02664 97EF      SBIW	R28,0x3F
    02665 97EF      SBIW	R28,0x3F
    02666 97EF      SBIW	R28,0x3F
    02667 97EF      SBIW	R28,0x3F
    02668 97AC      SBIW	R28,0x2C
(0153) }
(0154) /////////////////////////////////////////////////
(0155) //       读取文件函数
(0156) //以64byte为一块 读取
(0157) //index数据偏移量   data读出后存放地
(0158) //////////////////////////////////////////////// 
(0159) char ReadSDFile(unsigned int index,char *data)
(0160) {
(0161)  	unsigned int bw;
(0162) 	char res;
(0163) 	FATFS fs;
(0164)     FIL file;
(0165) 	char fnamep[13];
(0166)     get_name(fnamep); 
    02669 018E      MOVW	R16,R28
    0266A 5D0A      SUBI	R16,0xDA
    0266B 4F1F      SBCI	R17,0xFF
    0266C D3DB      RCALL	_get_name
(0167)     disk_initialize(0);
    0266D 2700      CLR	R16
    0266E 940E 028D CALL	_disk_initialize
(0168)     res = f_mount(0, &fs);
    02670 019E      MOVW	R18,R28
    02671 5C2B      SUBI	R18,0xCB
    02672 4F3F      SBCI	R19,0xFF
    02673 2700      CLR	R16
    02674 940E 1679 CALL	_f_mount
(0169)     res = f_open(&file,fnamep,FA_READ);  
    02676 E081      LDI	R24,1
    02677 8388      ST	Y,R24
    02678 019E      MOVW	R18,R28
    02679 5D2A      SUBI	R18,0xDA
    0267A 4F3F      SBCI	R19,0xFF
    0267B 018E      MOVW	R16,R28
    0267C 5F0C      SUBI	R16,0xFC
    0267D 4F1F      SBCI	R17,0xFF
    0267E 940E 16A4 CALL	_f_open
    02680 2F40      MOV	R20,R16
(0170)     if(res==FR_NO_FILE) {data=NULL;
    02681 3004      CPI	R16,4
    02682 F419      BNE	0x2686
    02683 24AA      CLR	R10
    02684 24BB      CLR	R11
(0171)     #if _debug >= 1 
(0172)     debug_out("now file",255);
(0173) 	debug_out(filename,res);
(0174) 	debug_out("file is no exist....",255);
(0175)     #endif 
(0176)     return res;
    02685 C02E      RJMP	0x26B4
(0177)     }   
(0178)     res = f_lseek (&file,(index+2)*64);	 //前两个字节数据为文件头空间 所以从第三块读/写起
    02686 019B      MOVW	R18,R22
    02687 5F2E      SUBI	R18,0xFE
    02688 4F3F      SBCI	R19,0xFF
    02689 E400      LDI	R16,0x40
    0268A E010      LDI	R17,0
    0268B 940E 4043 CALL	empy16s
    0268D 0118      MOVW	R2,R16
    0268E 2444      CLR	R4
    0268F 2455      CLR	R5
    02690 8248      ST	Y,R4
    02691 8259      STD	Y+1,R5
    02692 0191      MOVW	R18,R2
    02693 018E      MOVW	R16,R28
    02694 5F0C      SUBI	R16,0xFC
    02695 4F1F      SBCI	R17,0xFF
    02696 940E 1E85 CALL	_f_lseek
    02698 2EC0      MOV	R12,R16
(0179)     res = f_read(&file,data,64,&bw);
    02699 01CE      MOVW	R24,R28
    0269A 96C3      ADIW	R24,0x33
    0269B 839B      STD	Y+3,R25
    0269C 838A      STD	Y+2,R24
    0269D E480      LDI	R24,0x40
    0269E E090      LDI	R25,0
    0269F 8399      STD	Y+1,R25
    026A0 8388      ST	Y,R24
    026A1 0195      MOVW	R18,R10
    026A2 018E      MOVW	R16,R28
    026A3 5F0C      SUBI	R16,0xFC
    026A4 4F1F      SBCI	R17,0xFF
    026A5 940E 1840 CALL	_f_read
    026A7 2EA0      MOV	R10,R16
    026A8 2D4A      MOV	R20,R10
(0180)     f_close(&file);
    026A9 018E      MOVW	R16,R28
    026AA 5F0C      SUBI	R16,0xFC
    026AB 4F1F      SBCI	R17,0xFF
    026AC 940E 1E75 CALL	_f_close
(0181) 	f_mount(0, NULL);
    026AE 2722      CLR	R18
    026AF 2733      CLR	R19
    026B0 2700      CLR	R16
    026B1 940E 1679 CALL	_f_mount
(0182) 	return res;
    026B3 2F04      MOV	R16,R20
    026B4 96EF      ADIW	R28,0x3F
    026B5 96EF      ADIW	R28,0x3F
    026B6 96EF      ADIW	R28,0x3F
    026B7 96EF      ADIW	R28,0x3F
    026B8 96EF      ADIW	R28,0x3F
    026B9 96EF      ADIW	R28,0x3F
    026BA 96EF      ADIW	R28,0x3F
    026BB 96EF      ADIW	R28,0x3F
    026BC 96EF      ADIW	R28,0x3F
    026BD 96AC      ADIW	R28,0x2C
    026BE 940C 40EB JMP	pop_xgsetF03C
_findIndex:
  fs                   --> Y,+48
  bw                   --> Y,+46
  fnamep               --> R14
  readsize             --> R10
  res                  --> R12
  file                 --> Y,+12
  lenth                --> Y,+8
  index                --> Y,+4
  is_first_end         --> Y,+606
  tmp                  --> R10
  buf                  --> Y,+617
  filename             --> R10
    026C0 933A      ST	-Y,R19
    026C1 932A      ST	-Y,R18
    026C2 940E 40A7 CALL	push_xgsetF0FC
    026C4 0158      MOVW	R10,R16
    026C5 97EF      SBIW	R28,0x3F
    026C6 97EF      SBIW	R28,0x3F
    026C7 97EF      SBIW	R28,0x3F
    026C8 97EF      SBIW	R28,0x3F
    026C9 97EF      SBIW	R28,0x3F
    026CA 97EF      SBIW	R28,0x3F
    026CB 97EF      SBIW	R28,0x3F
    026CC 97EF      SBIW	R28,0x3F
    026CD 97EF      SBIW	R28,0x3F
    026CE 97A8      SBIW	R28,0x28
(0183) } 
(0184) //////////////////////////////////
(0185) //   find index
(0186) // 检查当前文件尺寸，根据倒数第二个
(0187) //'\n'及其后面的index确定当前index值
(0188) //////////////////////////////////
(0189) unsigned int findIndex(char *filename,char *buf){
(0190)     unsigned int bw,tmp;
(0191) 	long index =0;
    026CF E080      LDI	R24,0
    026D0 838C      STD	Y+4,R24
    026D1 838D      STD	Y+5,R24
    026D2 838E      STD	Y+6,R24
    026D3 838F      STD	Y+7,R24
(0192) 	unsigned char is_first_end=0;
    026D4 2400      CLR	R0
    026D5 01DE      MOVW	R26,R28
    026D6 5AA2      SUBI	R26,0xA2
    026D7 4FBD      SBCI	R27,0xFD
    026D8 920C      ST	X,R0
(0193) 	char *fnamep=filename;
    026D9 0175      MOVW	R14,R10
(0194) 	FRESULT res;
(0195) 	FATFS fs;
(0196) 	FIL file;
(0197) 	long lenth=0;
    026DA E080      LDI	R24,0
    026DB 8788      STD	Y+8,R24
    026DC 8789      STD	Y+9,R24
    026DD 878A      STD	Y+10,R24
    026DE 878B      STD	Y+11,R24
(0198) 	int readsize=0;
    026DF 24AA      CLR	R10
    026E0 24BB      CLR	R11
(0199) 	//PrintString_n(fnamep);
(0200) 	res = f_mount(0, &fs);
    026E1 019E      MOVW	R18,R28
    026E2 5D20      SUBI	R18,0xD0
    026E3 4F3F      SBCI	R19,0xFF
    026E4 2700      CLR	R16
    026E5 940E 1679 CALL	_f_mount
(0201) 	res = f_open(&file,fnamep, FA_OPEN_ALWAYS | FA_READ );  //创建一个新的文件
    026E7 E181      LDI	R24,0x11
    026E8 8388      ST	Y,R24
    026E9 0197      MOVW	R18,R14
    026EA 018E      MOVW	R16,R28
    026EB 5F04      SUBI	R16,0xF4
    026EC 4F1F      SBCI	R17,0xFF
    026ED 940E 16A4 CALL	_f_open
    026EF 2EC0      MOV	R12,R16
(0202) 	if(res !=  FR_OK){ //openerror
    026F0 2300      TST	R16
    026F1 F011      BEQ	0x26F4
(0203) 	    return res;}
    026F2 2711      CLR	R17
    026F3 C11E      RJMP	0x2812
(0204) 	lenth=file.fsize;   //文件尾部为 file.size 
    026F4 882E      LDD	R2,Y+22
    026F5 883F      LDD	R3,Y+23
    026F6 8C48      LDD	R4,Y+24
    026F7 8C59      LDD	R5,Y+25
    026F8 8628      STD	Y+8,R2
    026F9 8639      STD	Y+9,R3
    026FA 864A      STD	Y+10,R4
    026FB 865B      STD	Y+11,R5
(0205) 	//debug("size=",0xff);
(0206) 	//PrintLong(lenth);
(0207) 	if(lenth > 512) {
    026FC E040      LDI	R20,0
    026FD E052      LDI	R21,2
    026FE E060      LDI	R22,0
    026FF E070      LDI	R23,0
    02700 8428      LDD	R2,Y+8
    02701 8439      LDD	R3,Y+9
    02702 844A      LDD	R4,Y+10
    02703 845B      LDD	R5,Y+11
    02704 1542      CP	R20,R2
    02705 0553      CPC	R21,R3
    02706 0564      CPC	R22,R4
    02707 0575      CPC	R23,R5
    02708 F464      BGE	0x2715
(0208) 	    readsize=512;
    02709 E080      LDI	R24,0
    0270A E092      LDI	R25,2
    0270B 015C      MOVW	R10,R24
(0209) 		lenth=file.fsize;
    0270C 882E      LDD	R2,Y+22
    0270D 883F      LDD	R3,Y+23
    0270E 8C48      LDD	R4,Y+24
    0270F 8C59      LDD	R5,Y+25
    02710 8628      STD	Y+8,R2
    02711 8639      STD	Y+9,R3
    02712 864A      STD	Y+10,R4
    02713 865B      STD	Y+11,R5
(0210) 	}
    02714 C007      RJMP	0x271C
(0211) 	else {
(0212) 	    readsize =file.fsize;
    02715 88AE      LDD	R10,Y+22
    02716 88BF      LDD	R11,Y+23
(0213) 		lenth=0;
    02717 E080      LDI	R24,0
    02718 8788      STD	Y+8,R24
    02719 8789      STD	Y+9,R24
    0271A 878A      STD	Y+10,R24
    0271B 878B      STD	Y+11,R24
(0214) 	}
(0215) 	res = f_lseek (&file,file.fsize-readsize);
    0271C 0115      MOVW	R2,R10
    0271D 2444      CLR	R4
    0271E FC37      SBRC	R3,7
    0271F 9440      COM	R4
    02720 2455      CLR	R5
    02721 FC47      SBRC	R4,7
    02722 9450      COM	R5
    02723 886E      LDD	R6,Y+22
    02724 887F      LDD	R7,Y+23
    02725 8C88      LDD	R8,Y+24
    02726 8C99      LDD	R9,Y+25
    02727 1862      SUB	R6,R2
    02728 0873      SBC	R7,R3
    02729 0884      SBC	R8,R4
    0272A 0895      SBC	R9,R5
    0272B 8288      ST	Y,R8
    0272C 8299      STD	Y+1,R9
    0272D 0193      MOVW	R18,R6
    0272E 018E      MOVW	R16,R28
    0272F 5F04      SUBI	R16,0xF4
    02730 4F1F      SBCI	R17,0xFF
    02731 940E 1E85 CALL	_f_lseek
(0216) 	//debug("readSIZE=",0x00);
(0217) 	//PrintLong((file.fsize-readsize));
(0218) 	res = f_read(&file,buf,readsize,&bw);
    02733 01CE      MOVW	R24,R28
    02734 968E      ADIW	R24,0x2E
    02735 839B      STD	Y+3,R25
    02736 838A      STD	Y+2,R24
    02737 82B9      STD	Y+1,R11
    02738 82A8      ST	Y,R10
    02739 01FE      MOVW	R30,R28
    0273A 59E7      SUBI	R30,0x97
    0273B 4FFD      SBCI	R31,0xFD
    0273C 8120      LD	R18,Z
    0273D 8131      LDD	R19,Z+1
    0273E 018E      MOVW	R16,R28
    0273F 5F04      SUBI	R16,0xF4
    02740 4F1F      SBCI	R17,0xFF
    02741 940E 1840 CALL	_f_read
    02743 2EE0      MOV	R14,R16
    02744 2CCE      MOV	R12,R14
(0219) 	f_close(&file);
    02745 018E      MOVW	R16,R28
    02746 5F04      SUBI	R16,0xF4
    02747 4F1F      SBCI	R17,0xFF
    02748 940E 1E75 CALL	_f_close
(0220) 	//debug("readRES=",res);
(0221) 	//debug("readbw=",0X00);
(0222) 	//PrintLong(bw);
(0223) 	//PrintString_n(buf);
(0224) 	for(tmp=readsize;tmp>0;tmp--){
    0274A C04E      RJMP	0x2799
(0225) 		//debug("buf index",buf[tmp]);
(0226) 		//PrintLong(tmp);
(0227) 		if(buf[tmp] == '\n') Usart_Transmit('@');						  
    0274B 01F5      MOVW	R30,R10
    0274C 01DE      MOVW	R26,R28
    0274D 59A7      SUBI	R26,0x97
    0274E 4FBD      SBCI	R27,0xFD
    0274F 900D      LD	R0,X+
    02750 901C      LD	R1,X
    02751 0DE0      ADD	R30,R0
    02752 1DF1      ADC	R31,R1
    02753 8180      LD	R24,Z
    02754 308A      CPI	R24,0xA
    02755 F419      BNE	0x2759
    02756 E400      LDI	R16,0x40
    02757 940E 3706 CALL	_Usart_Transmit
(0228) 		if(buf[tmp] == '\n' && is_first_end== 0){
    02759 01F5      MOVW	R30,R10
    0275A 01DE      MOVW	R26,R28
    0275B 59A7      SUBI	R26,0x97
    0275C 4FBD      SBCI	R27,0xFD
    0275D 900D      LD	R0,X+
    0275E 901C      LD	R1,X
    0275F 0DE0      ADD	R30,R0
    02760 1DF1      ADC	R31,R1
    02761 8180      LD	R24,Z
    02762 308A      CPI	R24,0xA
    02763 F469      BNE	0x2771
    02764 01FE      MOVW	R30,R28
    02765 5AE2      SUBI	R30,0xA2
    02766 4FFD      SBCI	R31,0xFD
    02767 8000      LD	R0,Z
    02768 2000      TST	R0
    02769 F439      BNE	0x2771
(0229) 		    is_first_end=1; 	
    0276A 2400      CLR	R0
    0276B 9403      INC	R0
    0276C 01FE      MOVW	R30,R28
    0276D 5AE2      SUBI	R30,0xA2
    0276E 4FFD      SBCI	R31,0xFD
    0276F 8200      ST	Z,R0
(0230) 			//debug("first=",0xf0);					      
(0231) 		}
    02770 C025      RJMP	0x2796
(0232) 		else if(buf[tmp] == '\n' && is_first_end== 1){
    02771 01F5      MOVW	R30,R10
    02772 01DE      MOVW	R26,R28
    02773 59A7      SUBI	R26,0x97
    02774 4FBD      SBCI	R27,0xFD
    02775 900D      LD	R0,X+
    02776 901C      LD	R1,X
    02777 0DE0      ADD	R30,R0
    02778 1DF1      ADC	R31,R1
    02779 8180      LD	R24,Z
    0277A 308A      CPI	R24,0xA
    0277B F4D1      BNE	0x2796
    0277C 01DE      MOVW	R26,R28
    0277D 5AA2      SUBI	R26,0xA2
    0277E 4FBD      SBCI	R27,0xFD
    0277F 918C      LD	R24,X
    02780 3081      CPI	R24,1
    02781 F4A1      BNE	0x2796
(0233) 		    lenth -= (512-tmp);
    02782 E080      LDI	R24,0
    02783 E092      LDI	R25,2
    02784 011C      MOVW	R2,R24
    02785 182A      SUB	R2,R10
    02786 083B      SBC	R3,R11
    02787 2444      CLR	R4
    02788 2455      CLR	R5
    02789 8468      LDD	R6,Y+8
    0278A 8479      LDD	R7,Y+9
    0278B 848A      LDD	R8,Y+10
    0278C 849B      LDD	R9,Y+11
    0278D 1862      SUB	R6,R2
    0278E 0873      SBC	R7,R3
    0278F 0884      SBC	R8,R4
    02790 0895      SBC	R9,R5
    02791 8668      STD	Y+8,R6
    02792 8679      STD	Y+9,R7
    02793 868A      STD	Y+10,R8
    02794 869B      STD	Y+11,R9
(0234) 			break;
    02795 C009      RJMP	0x279F
    02796 01C5      MOVW	R24,R10
    02797 9701      SBIW	R24,1
    02798 015C      MOVW	R10,R24
    02799 20AA      TST	R10
    0279A F009      BEQ	0x279C
    0279B CFAF      RJMP	0x274B
    0279C 20BB      TST	R11
    0279D F009      BEQ	0x279F
    0279E CFAC      RJMP	0x274B
(0235) 		} 						
(0236) 	}
(0237) 	//debug("start=",0X00); PrintLong(lenth);
(0238) 	if(lenth < 118 ){ 
    0279F E746      LDI	R20,0x76
    027A0 E050      LDI	R21,0
    027A1 E060      LDI	R22,0
    027A2 E070      LDI	R23,0
    027A3 8428      LDD	R2,Y+8
    027A4 8439      LDD	R3,Y+9
    027A5 844A      LDD	R4,Y+10
    027A6 845B      LDD	R5,Y+11
    027A7 1624      CP	R2,R20
    027A8 0635      CPC	R3,R21
    027A9 0646      CPC	R4,R22
    027AA 0657      CPC	R5,R23
    027AB F434      BGE	0x27B2
(0239)  		return 1;
    027AC E001      LDI	R16,1
    027AD E010      LDI	R17,0
    027AE C063      RJMP	0x2812
(0240) 	}
(0241) 	else {
(0242) 		 //debug(">128 ",0X00);
(0243) 		 while(buf[tmp] <= '0' || buf[tmp] >= '9') tmp++;
    027AF 01C5      MOVW	R24,R10
    027B0 9601      ADIW	R24,1
    027B1 015C      MOVW	R10,R24
    027B2 01F5      MOVW	R30,R10
    027B3 01DE      MOVW	R26,R28
    027B4 59A7      SUBI	R26,0x97
    027B5 4FBD      SBCI	R27,0xFD
    027B6 900D      LD	R0,X+
    027B7 901C      LD	R1,X
    027B8 0DE0      ADD	R30,R0
    027B9 1DF1      ADC	R31,R1
    027BA 80E0      LD	R14,Z
    027BB 24FF      CLR	R15
    027BC E380      LDI	R24,0x30
    027BD 158E      CP	R24,R14
    027BE F780      BCC	0x27AF
    027BF 2D8E      MOV	R24,R14
    027C0 3389      CPI	R24,0x39
    027C1 F768      BCC	0x27AF
    027C2 C02F      RJMP	0x27F2
(0244) 		 //debug("nozero ",bw); PrintLong(tmp);
(0245) 		 while(buf[tmp] != 't' && buf[tmp] >= '0' && buf[tmp] <= '9'){
(0246) 		     index=index*10+(buf[tmp]-'0');
    027C3 01F5      MOVW	R30,R10
    027C4 01DE      MOVW	R26,R28
    027C5 59A7      SUBI	R26,0x97
    027C6 4FBD      SBCI	R27,0xFD
    027C7 900D      LD	R0,X+
    027C8 901C      LD	R1,X
    027C9 0DE0      ADD	R30,R0
    027CA 1DF1      ADC	R31,R1
    027CB 8180      LD	R24,Z
    027CC 2799      CLR	R25
    027CD 97C0      SBIW	R24,0x30
    027CE 011C      MOVW	R2,R24
    027CF 2444      CLR	R4
    027D0 FC37      SBRC	R3,7
    027D1 9440      COM	R4
    027D2 2455      CLR	R5
    027D3 FC47      SBRC	R4,7
    027D4 9450      COM	R5
    027D5 806C      LDD	R6,Y+4
    027D6 807D      LDD	R7,Y+5
    027D7 808E      LDD	R8,Y+6
    027D8 809F      LDD	R9,Y+7
    027D9 E04A      LDI	R20,0xA
    027DA E050      LDI	R21,0
    027DB E060      LDI	R22,0
    027DC E070      LDI	R23,0
    027DD 929A      ST	-Y,R9
    027DE 928A      ST	-Y,R8
    027DF 927A      ST	-Y,R7
    027E0 926A      ST	-Y,R6
    027E1 018A      MOVW	R16,R20
    027E2 019B      MOVW	R18,R22
    027E3 940E 4053 CALL	empy32u|empy32s
    027E5 0138      MOVW	R6,R16
    027E6 0149      MOVW	R8,R18
    027E7 0C62      ADD	R6,R2
    027E8 1C73      ADC	R7,R3
    027E9 1C84      ADC	R8,R4
    027EA 1C95      ADC	R9,R5
    027EB 826C      STD	Y+4,R6
    027EC 827D      STD	Y+5,R7
    027ED 828E      STD	Y+6,R8
    027EE 829F      STD	Y+7,R9
(0247) 		 	 //Usart_Transmit(buf[tmp]);	
(0248) 		 	 tmp++;
    027EF 01C5      MOVW	R24,R10
    027F0 9601      ADIW	R24,1
    027F1 015C      MOVW	R10,R24
    027F2 01F5      MOVW	R30,R10
    027F3 01DE      MOVW	R26,R28
    027F4 59A7      SUBI	R26,0x97
    027F5 4FBD      SBCI	R27,0xFD
    027F6 900D      LD	R0,X+
    027F7 901C      LD	R1,X
    027F8 0DE0      ADD	R30,R0
    027F9 1DF1      ADC	R31,R1
    027FA 80E0      LD	R14,Z
    027FB 24FF      CLR	R15
    027FC 2D8E      MOV	R24,R14
    027FD 3784      CPI	R24,0x74
    027FE F031      BEQ	0x2805
    027FF 3380      CPI	R24,0x30
    02800 F020      BCS	0x2805
    02801 E389      LDI	R24,0x39
    02802 158E      CP	R24,R14
    02803 F008      BCS	0x2805
    02804 CFBE      RJMP	0x27C3
(0249) 		 }
(0250) 	}
(0251) 	//debug("index=",0X00);
(0252) 	//PrintLong(index+1);
(0253) 	return index+1;
    02805 E041      LDI	R20,1
    02806 E050      LDI	R21,0
    02807 E060      LDI	R22,0
    02808 E070      LDI	R23,0
    02809 802C      LDD	R2,Y+4
    0280A 803D      LDD	R3,Y+5
    0280B 804E      LDD	R4,Y+6
    0280C 805F      LDD	R5,Y+7
    0280D 0E24      ADD	R2,R20
    0280E 1E35      ADC	R3,R21
    0280F 1E46      ADC	R4,R22
    02810 1E57      ADC	R5,R23
    02811 0181      MOVW	R16,R2
    02812 96EF      ADIW	R28,0x3F
    02813 96EF      ADIW	R28,0x3F
    02814 96EF      ADIW	R28,0x3F
    02815 96EF      ADIW	R28,0x3F
    02816 96EF      ADIW	R28,0x3F
    02817 96EF      ADIW	R28,0x3F
    02818 96EF      ADIW	R28,0x3F
    02819 96EF      ADIW	R28,0x3F
    0281A 96EF      ADIW	R28,0x3F
    0281B 96A8      ADIW	R28,0x28
    0281C 940E 409C CALL	pop_xgsetF0FC
    0281E 9622      ADIW	R28,2
    0281F 9508      RET
_check:
  WScounter            --> R10
  tmp                  --> R12
    02820 940E 40AD CALL	push_xgset003C
    02822 9722      SBIW	R28,2
(0254) }
(0255) void check( void )
(0256) {
(0257)  unsigned char tmp;
(0258)  unsigned int WScounter;
(0259)  //检测风速
(0260)  //读计数器1 此步需严格按手册进行。
(0261)  tmp=SREG;
    02823 B6CF      IN	R12,0x3F
(0262)  CLI();
    02824 94F8      BCLR	7
(0263)  WScounter=TCNT1H*256+TCNT1L;
    02825 B52D      IN	R18,0x2D
    02826 2733      CLR	R19
    02827 E000      LDI	R16,0
    02828 E011      LDI	R17,1
    02829 940E 4043 CALL	empy16s
    0282B 0158      MOVW	R10,R16
    0282C B42C      IN	R2,0x2C
    0282D 2433      CLR	R3
    0282E 0CA2      ADD	R10,R2
    0282F 1CB3      ADC	R11,R3
(0264)  SREG=tmp;
    02830 BECF      OUT	0x3F,R12
(0265)  SEI();
    02831 9478      BSET	7
(0266)  //计算风速
(0267)  Result.WindSpeed=WScounter/N_per_Second;
    02832 0185      MOVW	R16,R10
    02833 940E 4201 CALL	uint2fp
    02835 0118      MOVW	R2,R16
    02836 0129      MOVW	R4,R18
    02837 EB00      LDI	R16,0xB0
    02838 E010      LDI	R17,0
    02839 940E 402F CALL	elpm32
    0283B 933A      ST	-Y,R19
    0283C 932A      ST	-Y,R18
    0283D 931A      ST	-Y,R17
    0283E 930A      ST	-Y,R16
    0283F 0181      MOVW	R16,R2
    02840 0192      MOVW	R18,R4
    02841 940E 422E CALL	fpdiv2
    02843 9310 058C STS	Result+52,R17
    02845 9300 058B STS	Result+51,R16
    02847 9330 058E STS	Result+54,R19
    02849 9320 058D STS	Result+53,R18
(0268)  //温度
(0269)  Result.Temperature=read_T_NUM(1);
    0284B E001      LDI	R16,1
    0284C 940E 3E42 CALL	_read_T_NUM
    0284E 9310 0582 STS	Result+42,R17
    02850 9300 0581 STS	Result+41,R16
    02852 9330 0584 STS	Result+44,R19
    02854 9320 0583 STS	Result+43,R18
(0270)  //WCI风冷指数
(0271)   Result.WCI = 4.18 *(10*SquareRootFloat(Result.WindSpeed) + 10.45 -  Result.WindSpeed  ) *( 33 - Result.Temperature );
    02856 9120 058D LDS	R18,Result+53
    02858 9130 058E LDS	R19,Result+54
    0285A 9100 058B LDS	R16,Result+51
    0285C 9110 058C LDS	R17,Result+52
    0285E D228      RCALL	_SquareRootFloat
    0285F 0118      MOVW	R2,R16
    02860 0129      MOVW	R4,R18
    02861 EA0C      LDI	R16,0xAC
    02862 E010      LDI	R17,0
    02863 940E 402F CALL	elpm32
    02865 0138      MOVW	R6,R16
    02866 0149      MOVW	R8,R18
    02867 EA08      LDI	R16,0xA8
    02868 E010      LDI	R17,0
    02869 940E 402F CALL	elpm32
    0286B 925A      ST	-Y,R5
    0286C 924A      ST	-Y,R4
    0286D 923A      ST	-Y,R3
    0286E 922A      ST	-Y,R2
    0286F 940E 43A8 CALL	fpmule2
    02871 0118      MOVW	R2,R16
    02872 0129      MOVW	R4,R18
    02873 EA04      LDI	R16,0xA4
    02874 E010      LDI	R17,0
    02875 940E 402F CALL	elpm32
    02877 933A      ST	-Y,R19
    02878 932A      ST	-Y,R18
    02879 931A      ST	-Y,R17
    0287A 930A      ST	-Y,R16
    0287B 0181      MOVW	R16,R2
    0287C 0192      MOVW	R18,R4
    0287D 940E 41D0 CALL	fpadd2
    0287F E88B      LDI	R24,0x8B
    02880 E095      LDI	R25,5
    02881 939A      ST	-Y,R25
    02882 938A      ST	-Y,R24
    02883 940E 41E6 CALL	fpsub1x
    02885 0183      MOVW	R16,R6
    02886 0194      MOVW	R18,R8
    02887 940E 43A8 CALL	fpmule2
    02889 0118      MOVW	R2,R16
    0288A 0129      MOVW	R4,R18
    0288B EA00      LDI	R16,0xA0
    0288C E010      LDI	R17,0
    0288D 940E 402F CALL	elpm32
    0288F E881      LDI	R24,0x81
    02890 E095      LDI	R25,5
    02891 939A      ST	-Y,R25
    02892 938A      ST	-Y,R24
    02893 940E 41E6 CALL	fpsub1x
    02895 0181      MOVW	R16,R2
    02896 0192      MOVW	R18,R4
    02897 940E 43A8 CALL	fpmule2
    02899 9310 0595 STS	Result+61,R17
    0289B 9300 0594 STS	Result+60,R16
    0289D 9330 0597 STS	Result+63,R19
    0289F 9320 0596 STS	Result+62,R18
(0272)  //ECT等价制冷温度
(0273)  Result.ECT = 33 - 0.01085 * Result.WCI;
    028A1 E90C      LDI	R16,0x9C
    028A2 E010      LDI	R17,0
    028A3 940E 402F CALL	elpm32
    028A5 0118      MOVW	R2,R16
    028A6 0129      MOVW	R4,R18
    028A7 E908      LDI	R16,0x98
    028A8 E010      LDI	R17,0
    028A9 940E 402F CALL	elpm32
    028AB E984      LDI	R24,0x94
    028AC E095      LDI	R25,5
    028AD 939A      ST	-Y,R25
    028AE 938A      ST	-Y,R24
    028AF 940E 43B3 CALL	fpmule1x
    028B1 0181      MOVW	R16,R2
    028B2 0192      MOVW	R18,R4
    028B3 940E 41DB CALL	fpsub2
    028B5 9310 059F STS	Result+71,R17
    028B7 9300 059E STS	Result+70,R16
    028B9 9330 05A1 STS	Result+73,R19
    028BB 9320 05A0 STS	Result+72,R18
(0274)  //TEQ 相当温度
(0275)  Result.Teq = Result.Temperature +( (Result.Temperature -36)/10 ) * Result.WindSpeed ;
    028BD 9040 0583 LDS	R4,Result+43
    028BF 9050 0584 LDS	R5,Result+44
    028C1 9020 0581 LDS	R2,Result+41
    028C3 9030 0582 LDS	R3,Result+42
    028C5 0131      MOVW	R6,R2
    028C6 0142      MOVW	R8,R4
    028C7 E904      LDI	R16,0x94
    028C8 E010      LDI	R17,0
    028C9 940E 402F CALL	elpm32
    028CB 933A      ST	-Y,R19
    028CC 932A      ST	-Y,R18
    028CD 931A      ST	-Y,R17
    028CE 930A      ST	-Y,R16
    028CF 0183      MOVW	R16,R6
    028D0 0194      MOVW	R18,R8
    028D1 940E 41DB CALL	fpsub2
    028D3 0138      MOVW	R6,R16
    028D4 0149      MOVW	R8,R18
    028D5 EA08      LDI	R16,0xA8
    028D6 E010      LDI	R17,0
    028D7 940E 402F CALL	elpm32
    028D9 933A      ST	-Y,R19
    028DA 932A      ST	-Y,R18
    028DB 931A      ST	-Y,R17
    028DC 930A      ST	-Y,R16
    028DD 0183      MOVW	R16,R6
    028DE 0194      MOVW	R18,R8
    028DF 940E 422E CALL	fpdiv2
    028E1 E88B      LDI	R24,0x8B
    028E2 E095      LDI	R25,5
    028E3 939A      ST	-Y,R25
    028E4 938A      ST	-Y,R24
    028E5 940E 43B3 CALL	fpmule1x
    028E7 0181      MOVW	R16,R2
    028E8 0192      MOVW	R18,R4
    028E9 940E 41D0 CALL	fpadd2
    028EB 9310 05A9 STS	Result+81,R17
    028ED 9300 05A8 STS	Result+80,R16
    028EF 9330 05AB STS	Result+83,R19
    028F1 9320 05AA STS	Result+82,R18
(0276) //将数据转换成字符串
(0277)  
(0278) ftochr(Result.WindSpeed,Result.WSChar);
    028F3 E88F      LDI	R24,0x8F
    028F4 E095      LDI	R25,5
    028F5 8399      STD	Y+1,R25
    028F6 8388      ST	Y,R24
    028F7 9120 058D LDS	R18,Result+53
    028F9 9130 058E LDS	R19,Result+54
    028FB 9100 058B LDS	R16,Result+51
    028FD 9110 058C LDS	R17,Result+52
    028FF D04E      RCALL	_ftochr
(0279) ftochr(Result.Temperature,Result.TempChar);
    02900 E885      LDI	R24,0x85
    02901 E095      LDI	R25,5
    02902 8399      STD	Y+1,R25
    02903 8388      ST	Y,R24
    02904 9120 0583 LDS	R18,Result+43
    02906 9130 0584 LDS	R19,Result+44
    02908 9100 0581 LDS	R16,Result+41
    0290A 9110 0582 LDS	R17,Result+42
    0290C D041      RCALL	_ftochr
(0280) ftochr(Result.WCI,Result.WCIChar);
    0290D E988      LDI	R24,0x98
    0290E E095      LDI	R25,5
    0290F 8399      STD	Y+1,R25
    02910 8388      ST	Y,R24
    02911 9120 0596 LDS	R18,Result+62
    02913 9130 0597 LDS	R19,Result+63
    02915 9100 0594 LDS	R16,Result+60
    02917 9110 0595 LDS	R17,Result+61
    02919 D034      RCALL	_ftochr
(0281) ftochr(Result.ECT,Result.ECTChar);
    0291A EA82      LDI	R24,0xA2
    0291B E095      LDI	R25,5
    0291C 8399      STD	Y+1,R25
    0291D 8388      ST	Y,R24
    0291E 9120 05A0 LDS	R18,Result+72
    02920 9130 05A1 LDS	R19,Result+73
    02922 9100 059E LDS	R16,Result+70
    02924 9110 059F LDS	R17,Result+71
    02926 D027      RCALL	_ftochr
(0282) ftochr(Result.Teq,Result.TeqChar);
    02927 EA8C      LDI	R24,0xAC
    02928 E095      LDI	R25,5
    02929 8399      STD	Y+1,R25
    0292A 8388      ST	Y,R24
    0292B 9120 05AA LDS	R18,Result+82
    0292D 9130 05AB LDS	R19,Result+83
    0292F 9100 05A8 LDS	R16,Result+80
    02931 9110 05A9 LDS	R17,Result+81
    02933 D01A      RCALL	_ftochr
(0283) itoa(Result.IndexChar,Result.Index,10);
    02934 E08A      LDI	R24,0xA
    02935 E090      LDI	R25,0
    02936 8399      STD	Y+1,R25
    02937 8388      ST	Y,R24
    02938 9120 0562 LDS	R18,Result+10
    0293A 9130 0563 LDS	R19,Result+11
    0293C E606      LDI	R16,0x66
    0293D E015      LDI	R17,5
    0293E 940E 43D9 CALL	_itoa
(0284) Result.TempChar[6]='\0';
    02940 2422      CLR	R2
    02941 9220 058B STS	Result+51,R2
(0285) Result.WSChar[5]='\0';
    02943 9220 0594 STS	Result+60,R2
(0286) Result.WCIChar[6]='\0';
    02945 9220 059E STS	Result+70,R2
(0287) Result.ECTChar[6]='\0';
    02947 9220 05A8 STS	Result+80,R2
(0288) Result.TeqChar[6]='\0';
    02949 9220 05B2 STS	Result+90,R2
(0289)  return ;
    0294B 9622      ADIW	R28,2
    0294C 940C 4087 JMP	pop_xgset003C
_ftochr:
  status               --> Y,+2
  j                    --> R12
  lenth                --> R20
  res                  --> R12
  i                    --> R10
  dest                 --> R14
  a                    --> Y,+12
    0294E 940E 3F62 CALL	push_arg4
    02950 940E 40A9 CALL	push_xgset30FC
    02952 9724      SBIW	R28,4
    02953 88E8      LDD	R14,Y+16
    02954 88F9      LDD	R15,Y+17
(0290) }
(0291) ////////////////////////////////////////////
(0292) //				字符串转换函数
(0293) //   浮点 到  字符串
(0294) ////////////////////////////////////////////
(0295) void ftochr(float a,char * dest){//float
(0296) char i=0,j=0,lenth;
(0297) int status;
(0298) char *res;
(0299)  res=ftoa(a,&status);  //float to ascii
    02955 01CE      MOVW	R24,R28
    02956 9602      ADIW	R24,2
    02957 8399      STD	Y+1,R25
    02958 8388      ST	Y,R24
    02959 850C      LDD	R16,Y+12
    0295A 851D      LDD	R17,Y+13
    0295B 852E      LDD	R18,Y+14
    0295C 853F      LDD	R19,Y+15
    0295D 940E 44FC CALL	_ftoa
    0295F 0168      MOVW	R12,R16
(0300) lenth=strlen(res);
    02960 940E 3F56 CALL	_strlen
    02962 2F40      MOV	R20,R16
(0301) 
(0302) for(i=0;i <lenth;i++) 
    02963 24AA      CLR	R10
    02964 C023      RJMP	0x2988
(0303)        {
(0304) 	   	dest[i]=res[i];
    02965 2DEA      MOV	R30,R10
    02966 27FF      CLR	R31
    02967 0DEC      ADD	R30,R12
    02968 1DFD      ADC	R31,R13
    02969 8020      LD	R2,Z
    0296A 2DEA      MOV	R30,R10
    0296B 27FF      CLR	R31
    0296C 0DEE      ADD	R30,R14
    0296D 1DFF      ADC	R31,R15
    0296E 8220      ST	Z,R2
(0305) 
(0306) 		if( res[i]=='.'  ) 
    0296F 2DEA      MOV	R30,R10
    02970 27FF      CLR	R31
    02971 0DEC      ADD	R30,R12
    02972 1DFD      ADC	R31,R13
    02973 8180      LD	R24,Z
    02974 328E      CPI	R24,0x2E
    02975 F489      BNE	0x2987
(0307) 			{
(0308) 				dest[i+1]=res[i+1];
    02976 2DEA      MOV	R30,R10
    02977 27FF      CLR	R31
    02978 0DEC      ADD	R30,R12
    02979 1DFD      ADC	R31,R13
    0297A 8021      LDD	R2,Z+1
    0297B 2DEA      MOV	R30,R10
    0297C 27FF      CLR	R31
    0297D 0DEE      ADD	R30,R14
    0297E 1DFF      ADC	R31,R15
    0297F 8221      STD	Z+1,R2
(0309) 					dest[i+2]='\0';
    02980 2DEA      MOV	R30,R10
    02981 27FF      CLR	R31
    02982 0DEE      ADD	R30,R14
    02983 1DFF      ADC	R31,R15
    02984 2422      CLR	R2
    02985 8222      STD	Z+2,R2
(0310) 						return ;    
    02986 C003      RJMP	0x298A
    02987 94A3      INC	R10
    02988 16A4      CP	R10,R20
    02989 F2D8      BCS	0x2965
    0298A 9624      ADIW	R28,4
    0298B 940E 4093 CALL	pop_xgset30FC
    0298D 9624      ADIW	R28,4
    0298E 9508      RET
_itochr:
  dest                 --> R10
  a                    --> R12
    0298F 940E 40AD CALL	push_xgset003C
    02991 0159      MOVW	R10,R18
    02992 0168      MOVW	R12,R16
    02993 9722      SBIW	R28,2
(0311) 		    }
(0312)  
(0313)  		}
(0314) }
(0315) //////////////////////////////////////////////////////
(0316) //              整型数据变字符串
(0317) //    a  到  dest
(0318) ///////////////////////////////////////////////////////
(0319) void itochr(int a,char * dest){ //int to ascii
(0320) 	 itoa(dest,a,10); 
    02994 E08A      LDI	R24,0xA
    02995 E090      LDI	R25,0
    02996 8399      STD	Y+1,R25
    02997 8388      ST	Y,R24
    02998 0196      MOVW	R18,R12
    02999 0185      MOVW	R16,R10
    0299A 940E 43D9 CALL	_itoa
    0299C 9622      ADIW	R28,2
    0299D 940C 4087 JMP	pop_xgset003C
_StructToChar:
  otherbyte            --> Y,+16
  ary                  --> Y,+0
  i                    --> R10
    0299F 92AA      ST	-Y,R10
    029A0 9768      SBIW	R28,0x18
(0321) }
(0322) //////////////////////////////////////////////////////
(0323) //                  结构体 变字符串
(0324) // 将目前存于结构体的数据转换到Temp_Char中。
(0325) ///////////////////////////////////////////////////////
(0326) void  StructToChar(void)
(0327) { 
(0328)   unsigned char i;
(0329)   char otherbyte[]="0\t0\t0\t0";
    029A1 EB80      LDI	R24,0xB0
    029A2 E091      LDI	R25,1
    029A3 01FE      MOVW	R30,R28
    029A4 9670      ADIW	R30,0x10
    029A5 E008      LDI	R16,0x8
    029A6 E010      LDI	R17,0
    029A7 93FA      ST	-Y,R31
    029A8 93EA      ST	-Y,R30
    029A9 939A      ST	-Y,R25
    029AA 938A      ST	-Y,R24
    029AB 940E 414E CALL	asgnblk
(0330)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    029AD EB88      LDI	R24,0xB8
    029AE E091      LDI	R25,1
    029AF 01FE      MOVW	R30,R28
    029B0 E100      LDI	R16,0x10
    029B1 E010      LDI	R17,0
    029B2 93FA      ST	-Y,R31
    029B3 93EA      ST	-Y,R30
    029B4 939A      ST	-Y,R25
    029B5 938A      ST	-Y,R24
    029B6 940E 414E CALL	asgnblk
(0331)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0332) 				Result.TeqChar
(0333) 			   };  //指向数组首地址的指针
(0334)   //strcat(Temp_Char,Result.Name);
(0335)   for(i=0;i<=80;i++) TempChar[i]='\0';  //清空数组
    029B8 24AA      CLR	R10
    029B9 C009      RJMP	0x29C3
    029BA E088      LDI	R24,0x8
    029BB E095      LDI	R25,5
    029BC 2DEA      MOV	R30,R10
    029BD 27FF      CLR	R31
    029BE 0FE8      ADD	R30,R24
    029BF 1FF9      ADC	R31,R25
    029C0 2422      CLR	R2
    029C1 8220      ST	Z,R2
    029C2 94A3      INC	R10
    029C3 E580      LDI	R24,0x50
    029C4 158A      CP	R24,R10
    029C5 F7A0      BCC	0x29BA
(0336)     for(i=0;i<=7;i++){
    029C6 24AA      CLR	R10
    029C7 C014      RJMP	0x29DC
(0337) 		strcat(TempChar,ary[i]);  // 按顺序复制字符串
    029C8 01CE      MOVW	R24,R28
    029C9 2DEA      MOV	R30,R10
    029CA 27FF      CLR	R31
    029CB 0FEE      LSL	R30
    029CC 1FFF      ROL	R31
    029CD 0FE8      ADD	R30,R24
    029CE 1FF9      ADC	R31,R25
    029CF 8120      LD	R18,Z
    029D0 8131      LDD	R19,Z+1
    029D1 E008      LDI	R16,0x8
    029D2 E015      LDI	R17,5
    029D3 940E 3F49 CALL	_strcat
(0338) 		strcat(TempChar,tab);     // 字串结尾加上制表符
    029D5 E02F      LDI	R18,0xF
    029D6 E031      LDI	R19,1
    029D7 E008      LDI	R16,0x8
    029D8 E015      LDI	R17,5
    029D9 940E 3F49 CALL	_strcat
    029DB 94A3      INC	R10
    029DC E087      LDI	R24,7
    029DD 158A      CP	R24,R10
    029DE F748      BCC	0x29C8
(0339)     }
(0340) 				 
(0341) 				 otherbyte[0]=otherbyte[0]+Result.WeiHai;
    029DF 9020 05B2 LDS	R2,Result+90
    029E1 8838      LDD	R3,Y+16
    029E2 0C32      ADD	R3,R2
    029E3 8A38      STD	Y+16,R3
(0342) 				 otherbyte[2]=otherbyte[0]+Result.LowLabor;
    029E4 9020 05B3 LDS	R2,Result+91
    029E6 0C32      ADD	R3,R2
    029E7 8A3A      STD	Y+18,R3
(0343) 				 otherbyte[4]=otherbyte[0]+Result.MidLabor;
    029E8 9020 05B4 LDS	R2,Result+92
    029EA 8838      LDD	R3,Y+16
    029EB 0C32      ADD	R3,R2
    029EC 8A3C      STD	Y+20,R3
(0344) 				 otherbyte[6]=otherbyte[0]+Result.HighLabor;
    029ED 9020 05B5 LDS	R2,Result+93
    029EF 8838      LDD	R3,Y+16
    029F0 0C32      ADD	R3,R2
    029F1 8A3E      STD	Y+22,R3
(0345)  
(0346)   strcat(TempChar,otherbyte);  
    029F2 019E      MOVW	R18,R28
    029F3 5F20      SUBI	R18,0xF0
    029F4 4F3F      SBCI	R19,0xFF
    029F5 E008      LDI	R16,0x8
    029F6 E015      LDI	R17,5
    029F7 940E 3F49 CALL	_strcat
(0347)   strcat(TempChar,enter);  
    029F9 E122      LDI	R18,0x12
    029FA E031      LDI	R19,1
    029FB E008      LDI	R16,0x8
    029FC E015      LDI	R17,5
    029FD 940E 3F49 CALL	_strcat
(0348)   strcat(TempChar,"\0\0");
    029FF ED2F      LDI	R18,0xDF
    02A00 E031      LDI	R19,1
    02A01 E008      LDI	R16,0x8
    02A02 E015      LDI	R17,5
    02A03 940E 3F49 CALL	_strcat
    02A05 9668      ADIW	R28,0x18
    02A06 90A9      LD	R10,Y+
    02A07 9508      RET
_CharToStruct:
  Temp_Char            --> Y,+16
  i                    --> R20
  ary                  --> Y,+0
  j                    --> R14
  p                    --> R10
  q                    --> R12
    02A08 940E 40A9 CALL	push_xgset30FC
    02A0A 97EF      SBIW	R28,0x3F
    02A0B 97A1      SBIW	R28,0x21
(0349) }
(0350) 
(0351) //////////////////////////////////////////////////////
(0352) //               字符串  变  结构体
(0353) // 
(0354) ///////////////////////////////////////////////////////
(0355) void CharToStruct(void)
(0356) {
(0357)   unsigned char i=0,j=0;
    02A0C 2744      CLR	R20
    02A0D 24EE      CLR	R14
(0358)   unsigned char *p,*q;
(0359)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    02A0E EC88      LDI	R24,0xC8
    02A0F E091      LDI	R25,1
    02A10 01FE      MOVW	R30,R28
    02A11 E100      LDI	R16,0x10
    02A12 E010      LDI	R17,0
    02A13 93FA      ST	-Y,R31
    02A14 93EA      ST	-Y,R30
    02A15 939A      ST	-Y,R25
    02A16 938A      ST	-Y,R24
    02A17 940E 414E CALL	asgnblk
(0360)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0361) 				Result.TeqChar
(0362) 			   };  //指向数组首地址的指针
(0363)   char Temp_Char[80];
(0364)     p=ary[j];
    02A19 01CE      MOVW	R24,R28
    02A1A 2DEE      MOV	R30,R14
    02A1B 27FF      CLR	R31
    02A1C 0FEE      LSL	R30
    02A1D 1FFF      ROL	R31
    02A1E 0FE8      ADD	R30,R24
    02A1F 1FF9      ADC	R31,R25
    02A20 80A0      LD	R10,Z
    02A21 80B1      LDD	R11,Z+1
(0365) 	q=Temp_Char;
    02A22 01CE      MOVW	R24,R28
    02A23 9640      ADIW	R24,0x10
    02A24 016C      MOVW	R12,R24
    02A25 C01D      RJMP	0x2A43
(0366) 	while(1){
(0367)     if(*q =='\n') {*p='\0'; return;} ;
    02A26 01F6      MOVW	R30,R12
    02A27 8180      LD	R24,Z
    02A28 308A      CPI	R24,0xA
    02A29 F421      BNE	0x2A2E
    02A2A 2422      CLR	R2
    02A2B 01F5      MOVW	R30,R10
    02A2C 8220      ST	Z,R2
    02A2D C016      RJMP	0x2A44
(0368) 	if(*q =='\t') {j++;p=ary[j];i=0;}
    02A2E 01F6      MOVW	R30,R12
    02A2F 8180      LD	R24,Z
    02A30 3089      CPI	R24,0x9
    02A31 F459      BNE	0x2A3D
    02A32 94E3      INC	R14
    02A33 01CE      MOVW	R24,R28
    02A34 2DEE      MOV	R30,R14
    02A35 27FF      CLR	R31
    02A36 0FEE      LSL	R30
    02A37 1FFF      ROL	R31
    02A38 0FE8      ADD	R30,R24
    02A39 1FF9      ADC	R31,R25
    02A3A 80A0      LD	R10,Z
    02A3B 80B1      LDD	R11,Z+1
    02A3C 2744      CLR	R20
(0369)     *p++=*q++;
    02A3D 01F6      MOVW	R30,R12
    02A3E 01D5      MOVW	R26,R10
    02A3F 9001      LD	R0,Z+
    02A40 016F      MOVW	R12,R30
    02A41 920D      ST	X+,R0
    02A42 015D      MOVW	R10,R26
    02A43 CFE2      RJMP	0x2A26
    02A44 96EF      ADIW	R28,0x3F
    02A45 96A1      ADIW	R28,0x21
    02A46 940C 4093 JMP	pop_xgset30FC
_get_name:
  i                    --> R20
  filenamep            --> R16
    02A48 940E 40BC CALL	push_xgsetF000
(0370) 	}
(0371)   }
(0372)  
(0373)  ////////////////////////////////////////////
(0374) //				根据当前日期获取文件名
(0375) //   
(0376) ////////////////////////////////////////////
(0377) char *get_name( char filenamep[] ){     
(0378) 	  unsigned char i=0;
(0379)  	  for(i=0;i<6;i++) {
    02A4A 2744      CLR	R20
    02A4B C00D      RJMP	0x2A59
(0380) 	  				    *(filenamep+i)=Result.Date[i];
    02A4C E68E      LDI	R24,0x6E
    02A4D E095      LDI	R25,5
    02A4E 2FE4      MOV	R30,R20
    02A4F 27FF      CLR	R31
    02A50 0FE8      ADD	R30,R24
    02A51 1FF9      ADC	R31,R25
    02A52 8020      LD	R2,Z
    02A53 2FE4      MOV	R30,R20
    02A54 27FF      CLR	R31
    02A55 0FE0      ADD	R30,R16
    02A56 1FF1      ADC	R31,R17
    02A57 8220      ST	Z,R2
    02A58 9543      INC	R20
    02A59 3046      CPI	R20,6
    02A5A F388      BCS	0x2A4C
(0381) 	  				   } 
(0382) 	 	*(filenamep+(i++))='.';
    02A5B 2E24      MOV	R2,R20
    02A5C 2433      CLR	R3
    02A5D 5F4F      SUBI	R20,0xFF
    02A5E 2DE2      MOV	R30,R2
    02A5F 27FF      CLR	R31
    02A60 0FE0      ADD	R30,R16
    02A61 1FF1      ADC	R31,R17
    02A62 E28E      LDI	R24,0x2E
    02A63 8380      ST	Z,R24
(0383) 		*(filenamep+(i++))='x';
    02A64 2E24      MOV	R2,R20
    02A65 2433      CLR	R3
    02A66 5F4F      SUBI	R20,0xFF
    02A67 2DE2      MOV	R30,R2
    02A68 27FF      CLR	R31
    02A69 0FE0      ADD	R30,R16
    02A6A 1FF1      ADC	R31,R17
    02A6B E788      LDI	R24,0x78
    02A6C 8380      ST	Z,R24
(0384) 		*(filenamep+(i++))='l';
    02A6D 2F64      MOV	R22,R20
    02A6E 2777      CLR	R23
    02A6F 5F4F      SUBI	R20,0xFF
    02A70 2FE6      MOV	R30,R22
    02A71 27FF      CLR	R31
    02A72 0FE0      ADD	R30,R16
    02A73 1FF1      ADC	R31,R17
    02A74 E68C      LDI	R24,0x6C
    02A75 8380      ST	Z,R24
(0385) 		*(filenamep+(i++))='s';
    02A76 2F64      MOV	R22,R20
    02A77 2777      CLR	R23
    02A78 5F4F      SUBI	R20,0xFF
    02A79 2FE6      MOV	R30,R22
    02A7A 27FF      CLR	R31
    02A7B 0FE0      ADD	R30,R16
    02A7C 1FF1      ADC	R31,R17
    02A7D E783      LDI	R24,0x73
    02A7E 8380      ST	Z,R24
(0386) 		*(filenamep+(i))='\0';
    02A7F 2FE4      MOV	R30,R20
    02A80 27FF      CLR	R31
    02A81 0FE0      ADD	R30,R16
    02A82 1FF1      ADC	R31,R17
    02A83 2422      CLR	R2
    02A84 8220      ST	Z,R2
(0387) 					   
(0388)       return filenamep;
    02A85 940C 40C1 JMP	pop_xgsetF000
_SquareRootFloat:
  f                    --> Y,+12
  x                    --> Y,+8
  i                    --> Y,+4
  y                    --> Y,+0
  number               --> Y,+20
    02A87 940E 3F62 CALL	push_arg4
    02A89 940E 40BC CALL	push_xgsetF000
    02A8B 9760      SBIW	R28,0x10
(0389) } 
(0390) float SquareRootFloat(float number)
(0391) {
(0392)     long i;
(0393)     float x, y;
(0394)     const float f = 1.5F;
    02A8C E900      LDI	R16,0x90
    02A8D E010      LDI	R17,0
    02A8E 940E 402F CALL	elpm32
    02A90 870C      STD	Y+12,R16
    02A91 871D      STD	Y+13,R17
    02A92 872E      STD	Y+14,R18
    02A93 873F      STD	Y+15,R19
(0395)     x = number * 0.5F;
    02A94 E80C      LDI	R16,0x8C
    02A95 E010      LDI	R17,0
    02A96 940E 402F CALL	elpm32
    02A98 01CE      MOVW	R24,R28
    02A99 9644      ADIW	R24,0x14
    02A9A 939A      ST	-Y,R25
    02A9B 938A      ST	-Y,R24
    02A9C 940E 439E CALL	fpmule1
    02A9E 8708      STD	Y+8,R16
    02A9F 8719      STD	Y+9,R17
    02AA0 872A      STD	Y+10,R18
    02AA1 873B      STD	Y+11,R19
(0396)     y  = number;
    02AA2 882C      LDD	R2,Y+20
    02AA3 883D      LDD	R3,Y+21
    02AA4 884E      LDD	R4,Y+22
    02AA5 885F      LDD	R5,Y+23
    02AA6 8228      ST	Y,R2
    02AA7 8239      STD	Y+1,R3
    02AA8 824A      STD	Y+2,R4
    02AA9 825B      STD	Y+3,R5
(0397)     i  = * ( long * ) &y;
    02AAA 01FE      MOVW	R30,R28
    02AAB 8020      LD	R2,Z
    02AAC 8031      LDD	R3,Z+1
    02AAD 8042      LDD	R4,Z+2
    02AAE 8053      LDD	R5,Z+3
    02AAF 822C      STD	Y+4,R2
    02AB0 823D      STD	Y+5,R3
    02AB1 824E      STD	Y+6,R4
    02AB2 825F      STD	Y+7,R5
(0398)     i  = 0x5f3759df - ( i >> 1 );  //卡马克
    02AB3 802C      LDD	R2,Y+4
    02AB4 803D      LDD	R3,Y+5
    02AB5 804E      LDD	R4,Y+6
    02AB6 805F      LDD	R5,Y+7
    02AB7 9455      ASR	R5
    02AB8 9447      ROR	R4
    02AB9 9437      ROR	R3
    02ABA 9427      ROR	R2
    02ABB ED4F      LDI	R20,0xDF
    02ABC E559      LDI	R21,0x59
    02ABD E367      LDI	R22,0x37
    02ABE E57F      LDI	R23,0x5F
    02ABF 1942      SUB	R20,R2
    02AC0 0953      SBC	R21,R3
    02AC1 0964      SBC	R22,R4
    02AC2 0975      SBC	R23,R5
    02AC3 834C      STD	Y+4,R20
    02AC4 835D      STD	Y+5,R21
    02AC5 836E      STD	Y+6,R22
    02AC6 837F      STD	Y+7,R23
(0399)   //i  = 0x5f375a86 - ( i >> 1 );  //Lomont
(0400)     y  = * ( float * ) &i;
    02AC7 01FE      MOVW	R30,R28
    02AC8 9634      ADIW	R30,4
    02AC9 8020      LD	R2,Z
    02ACA 8031      LDD	R3,Z+1
    02ACB 8042      LDD	R4,Z+2
    02ACC 8053      LDD	R5,Z+3
    02ACD 8228      ST	Y,R2
    02ACE 8239      STD	Y+1,R3
    02ACF 824A      STD	Y+2,R4
    02AD0 825B      STD	Y+3,R5
(0401)     y  = y * ( f - ( x * y * y ) );
    02AD1 8028      LD	R2,Y
    02AD2 8039      LDD	R3,Y+1
    02AD3 804A      LDD	R4,Y+2
    02AD4 805B      LDD	R5,Y+3
    02AD5 846C      LDD	R6,Y+12
    02AD6 847D      LDD	R7,Y+13
    02AD7 848E      LDD	R8,Y+14
    02AD8 849F      LDD	R9,Y+15
    02AD9 8508      LDD	R16,Y+8
    02ADA 8519      LDD	R17,Y+9
    02ADB 852A      LDD	R18,Y+10
    02ADC 853B      LDD	R19,Y+11
    02ADD 01CE      MOVW	R24,R28
    02ADE 939A      ST	-Y,R25
    02ADF 938A      ST	-Y,R24
    02AE0 940E 439E CALL	fpmule1
    02AE2 01CE      MOVW	R24,R28
    02AE3 939A      ST	-Y,R25
    02AE4 938A      ST	-Y,R24
    02AE5 940E 43B3 CALL	fpmule1x
    02AE7 0183      MOVW	R16,R6
    02AE8 0194      MOVW	R18,R8
    02AE9 940E 41F3 CALL	fpsub2x
    02AEB 0181      MOVW	R16,R2
    02AEC 0192      MOVW	R18,R4
    02AED 940E 43A8 CALL	fpmule2
    02AEF 8308      ST	Y,R16
    02AF0 8319      STD	Y+1,R17
    02AF1 832A      STD	Y+2,R18
    02AF2 833B      STD	Y+3,R19
(0402)     y  = y * ( f - ( x * y * y ) );
    02AF3 8028      LD	R2,Y
    02AF4 8039      LDD	R3,Y+1
    02AF5 804A      LDD	R4,Y+2
    02AF6 805B      LDD	R5,Y+3
    02AF7 846C      LDD	R6,Y+12
    02AF8 847D      LDD	R7,Y+13
    02AF9 848E      LDD	R8,Y+14
    02AFA 849F      LDD	R9,Y+15
    02AFB 8508      LDD	R16,Y+8
    02AFC 8519      LDD	R17,Y+9
    02AFD 852A      LDD	R18,Y+10
    02AFE 853B      LDD	R19,Y+11
    02AFF 01CE      MOVW	R24,R28
    02B00 939A      ST	-Y,R25
    02B01 938A      ST	-Y,R24
    02B02 940E 439E CALL	fpmule1
    02B04 01CE      MOVW	R24,R28
    02B05 939A      ST	-Y,R25
    02B06 938A      ST	-Y,R24
    02B07 940E 43B3 CALL	fpmule1x
    02B09 0183      MOVW	R16,R6
    02B0A 0194      MOVW	R18,R8
    02B0B 940E 41F3 CALL	fpsub2x
    02B0D 0181      MOVW	R16,R2
    02B0E 0192      MOVW	R18,R4
    02B0F 940E 43A8 CALL	fpmule2
    02B11 8308      ST	Y,R16
    02B12 8319      STD	Y+1,R17
    02B13 832A      STD	Y+2,R18
    02B14 833B      STD	Y+3,R19
(0403)     return number * y;
    02B15 890C      LDD	R16,Y+20
    02B16 891D      LDD	R17,Y+21
    02B17 892E      LDD	R18,Y+22
    02B18 893F      LDD	R19,Y+23
    02B19 01CE      MOVW	R24,R28
    02B1A 939A      ST	-Y,R25
    02B1B 938A      ST	-Y,R24
    02B1C 940E 439E CALL	fpmule1
    02B1E 9660      ADIW	R28,0x10
    02B1F 940E 40C1 CALL	pop_xgsetF000
    02B21 9624      ADIW	R28,4
    02B22 9508      RET
_debug:
  str2                 --> Y,+0
  val                  --> R10
  str                  --> R12
    02B23 940E 40AD CALL	push_xgset003C
    02B25 2EA2      MOV	R10,R18
    02B26 0168      MOVW	R12,R16
    02B27 9724      SBIW	R28,4
(0404) } 
(0405) //
(0406) //###############################################################//
(0407) //debug
(0408) void debug(UINT8 *str,UINT8 val)
(0409) {
(0410)  UINT8 str2[4]={0,0,0,0};
    02B28 ED88      LDI	R24,0xD8
    02B29 E091      LDI	R25,1
    02B2A 01FE      MOVW	R30,R28
    02B2B E004      LDI	R16,4
    02B2C E010      LDI	R17,0
    02B2D 93FA      ST	-Y,R31
    02B2E 93EA      ST	-Y,R30
    02B2F 939A      ST	-Y,R25
    02B30 938A      ST	-Y,R24
    02B31 940E 414E CALL	asgnblk
(0411)  str=str;
(0412)  val=val;
(0413)  #ifdef _UARTDEBUG
(0414)  PrintString("\r\n");
    02B33 ED0C      LDI	R16,0xDC
    02B34 E011      LDI	R17,1
    02B35 940E 3738 CALL	_PrintString
(0415)  PrintString(str);
    02B37 0186      MOVW	R16,R12
    02B38 940E 3738 CALL	_PrintString
(0416)  PrintChar(val);
    02B3A 2D0A      MOV	R16,R10
    02B3B 940E 38A2 CALL	_PrintChar
    02B3D 9624      ADIW	R28,4
    02B3E 940C 4087 JMP	pop_xgset003C
_SD_Write_cmd:
  k                    --> R22
  temp                 --> R20
  p                    --> R20
    02B40 940E 40BC CALL	push_xgsetF000
    02B42 01A8      MOVW	R20,R16
FILE: D:\LQD\software\master\software_src\sd.c
(0001) //*****************************************************************************//
(0002) //*								数码相框
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SD卡控制
(0006) //*修改者：  桃子
(0007) //*****************************************************************************//
(0008) #include "sd.h"
(0009) 
(0010) //****************************************************************
(0011) //*隶属模块：SD卡控制
(0012) //*函数功能：写6字节数据
(0013) //****************************************************************
(0014) UINT8 SD_Write_cmd(UINT8 *p)
(0015) {	
(0016) 	UINT16 temp,k=0;
    02B43 2766      CLR	R22
    02B44 2777      CLR	R23
(0017) 	SD_CS_DIS();//禁止SPI
    02B45 9AC0      SBI	0x18,0
(0018) 	SPI_Read();//空读一字节
    02B46 940E 38D0 CALL	_SPI_Read
(0019) 	SD_CS_EN();//使能SPI
    02B48 98C0      CBI	0x18,0
(0020) 
(0021) 	SPI_Write(p[0]);
    02B49 01FA      MOVW	R30,R20
    02B4A 8100      LD	R16,Z
    02B4B 940E 38CC CALL	_SPI_Write
(0022) 	SPI_Write(p[1]);
    02B4D 01FA      MOVW	R30,R20
    02B4E 8101      LDD	R16,Z+1
    02B4F 940E 38CC CALL	_SPI_Write
(0023) 	SPI_Write(p[2]);
    02B51 01FA      MOVW	R30,R20
    02B52 8102      LDD	R16,Z+2
    02B53 940E 38CC CALL	_SPI_Write
(0024) 	SPI_Write(p[3]);
    02B55 01FA      MOVW	R30,R20
    02B56 8103      LDD	R16,Z+3
    02B57 940E 38CC CALL	_SPI_Write
(0025) 	SPI_Write(p[4]);
    02B59 01FA      MOVW	R30,R20
    02B5A 8104      LDD	R16,Z+4
    02B5B 940E 38CC CALL	_SPI_Write
(0026) 	SPI_Write(p[5]);
    02B5D 01FA      MOVW	R30,R20
    02B5E 8105      LDD	R16,Z+5
    02B5F 940E 38CC CALL	_SPI_Write
(0027) 
(0028) 	do 
(0029)  	{  
(0030)   		temp = SPI_Read();//一直读，直到读到的不是0xff或超时
    02B61 940E 38D0 CALL	_SPI_Read
    02B63 2F40      MOV	R20,R16
    02B64 2755      CLR	R21
(0031)  		k++;
    02B65 5F6F      SUBI	R22,0xFF
    02B66 4F7F      SBCI	R23,0xFF
(0032)  	}while((temp==0xff)&&(k<TRY_TIME)); 
    02B67 3F4F      CPI	R20,0xFF
    02B68 E0E0      LDI	R30,0
    02B69 075E      CPC	R21,R30
    02B6A F421      BNE	0x2B6F
    02B6B 3164      CPI	R22,0x14
    02B6C E0E0      LDI	R30,0
    02B6D 077E      CPC	R23,R30
    02B6E F390      BCS	0x2B61
(0033) 
(0034) 	return temp;
    02B6F 2F04      MOV	R16,R20
    02B70 940C 40C1 JMP	pop_xgsetF000
_SD_Init:
  pcmd                 --> Y,+0
  temp                 --> R22
  time                 --> R20
    02B72 940E 40C6 CALL	push_xgsetF00C
    02B74 9726      SBIW	R28,6
(0035) }
(0036) //****************************************************************
(0037) //*隶属模块：SD卡控制
(0038) //*函数功能：初始化
(0039) //****************************************************************
(0040) UINT8 SD_Init(void)	
(0041) {  
(0042) 	UINT8 time=0,temp=0;
    02B75 2744      CLR	R20
    02B76 2766      CLR	R22
(0043) 	UINT8 pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; //命令0的字节序列
    02B77 E48A      LDI	R24,0x4A
    02B78 E092      LDI	R25,2
    02B79 01FE      MOVW	R30,R28
    02B7A E006      LDI	R16,6
    02B7B E010      LDI	R17,0
    02B7C 93FA      ST	-Y,R31
    02B7D 93EA      ST	-Y,R30
    02B7E 939A      ST	-Y,R25
    02B7F 938A      ST	-Y,R24
    02B80 940E 414E CALL	asgnblk
(0044) 	if(SD_DET()==0) return 0x02; //no disk
    02B82 B181      IN	R24,0x01
    02B83 9586      LSR	R24
    02B84 9586      LSR	R24
    02B85 9586      LSR	R24
    02B86 9586      LSR	R24
    02B87 9586      LSR	R24
    02B88 7081      ANDI	R24,1
    02B89 F421      BNE	0x2B8E
    02B8A E081      LDI	R24,1
    02B8B E090      LDI	R25,0
    02B8C 015C      MOVW	R10,R24
    02B8D C002      RJMP	0x2B90
    02B8E 24AA      CLR	R10
    02B8F 24BB      CLR	R11
    02B90 20AA      TST	R10
    02B91 F421      BNE	0x2B96
    02B92 20BB      TST	R11
    02B93 F411      BNE	0x2B96
    02B94 E002      LDI	R16,2
    02B95 C039      RJMP	0x2BCF
(0045) 	SD_PORT |= (1<<SD_CS);
    02B96 9AC0      SBI	0x18,0
(0046) 	SD_DDR |= (1<<SD_CS);
    02B97 9AB8      SBI	0x17,0
(0047) 
(0048) 	SPI_IO_Init();
    02B98 940E 38C2 CALL	_SPI_IO_Init
(0049) 	SPI_Low();
    02B9A E582      LDI	R24,0x52
    02B9B B98D      OUT	0x0D,R24
    02B9C B18E      IN	R24,0x0E
    02B9D 7F8F      ANDI	R24,0xFF
    02B9E B98E      OUT	0x0E,R24
(0050) 
(0051) 	SD_CS_DIS();  //关闭片选 
    02B9F 9AC0      SBI	0x18,0
(0052) 	for(time=0;time<10;time++) //初始时，首先要发送最少74个时钟信号，这是必须的！！！
    02BA0 2744      CLR	R20
    02BA1 C003      RJMP	0x2BA5
(0053) 	{
(0054)   		SPI_Read(); 
    02BA2 940E 38D0 CALL	_SPI_Read
    02BA4 9543      INC	R20
    02BA5 304A      CPI	R20,0xA
    02BA6 F3D8      BCS	0x2BA2
(0055) 	}
(0056) 	SD_CS_EN(); //打开片选
    02BA7 98C0      CBI	0x18,0
(0057) 	time = 0;
    02BA8 2744      CLR	R20
(0058) 	do
(0059) 	{ 
(0060) 		temp=SD_Write_cmd(pcmd);//写入CMD0
    02BA9 018E      MOVW	R16,R28
    02BAA DF95      RCALL	_SD_Write_cmd
    02BAB 2F60      MOV	R22,R16
(0061) 	 	time++;
    02BAC 9543      INC	R20
(0062) 	 	if(time==TRY_TIME) 
    02BAD 3144      CPI	R20,0x14
    02BAE F419      BNE	0x2BB2
(0063) 	 	{ 
(0064) 	  		SD_CS_DIS(); //关闭片选
    02BAF 9AC0      SBI	0x18,0
(0065) 	  		return(INIT_CMD0_ERROR);//CMD0写入失败
    02BB0 E001      LDI	R16,1
    02BB1 C01D      RJMP	0x2BCF
(0066) 	 	}
(0067) 	 }while(temp!=0x01);
    02BB2 3061      CPI	R22,1
    02BB3 F7A9      BNE	0x2BA9
(0068) 
(0069) 	SD_CS_DIS(); //关闭片选
    02BB4 9AC0      SBI	0x18,0
(0070) 	SPI_Read(); //按照SD卡的操作时序在这里补8个时钟 
    02BB5 940E 38D0 CALL	_SPI_Read
(0071) 	SD_CS_EN(); //打开片选
    02BB7 98C0      CBI	0x18,0
(0072) 
(0073) 	pcmd[0]=0x41,pcmd[5]=0xff;
    02BB8 E481      LDI	R24,0x41
    02BB9 8388      ST	Y,R24
    02BBA EF8F      LDI	R24,0xFF
    02BBB 838D      STD	Y+5,R24
(0074) 	time = 0;
    02BBC 2744      CLR	R20
(0075) 	do
(0076) 	{ 
(0077) 		temp=SD_Write_cmd(pcmd);
    02BBD 018E      MOVW	R16,R28
    02BBE DF81      RCALL	_SD_Write_cmd
    02BBF 2F60      MOV	R22,R16
(0078) 		time++;
    02BC0 9543      INC	R20
(0079) 		if(time==TRY_TIME) 
    02BC1 3144      CPI	R20,0x14
    02BC2 F419      BNE	0x2BC6
(0080) 		{ 
(0081) 		 	SD_CS_DIS(); //关闭片选
    02BC3 9AC0      SBI	0x18,0
(0082) 			 return(INIT_CMD1_ERROR);//CMD1写入失败
    02BC4 E002      LDI	R16,2
    02BC5 C009      RJMP	0x2BCF
(0083) 		 }
(0084) 	 }while(temp!=0);
    02BC6 2366      TST	R22
    02BC7 F7A9      BNE	0x2BBD
(0085)   
(0086) 	 SPI_High();  
    02BC8 E580      LDI	R24,0x50
    02BC9 B98D      OUT	0x0D,R24
    02BCA 9A70      SBI	0x0E,0
(0087) 	 SD_CS_DIS();  //关闭片选 
    02BCB 9AC0      SBI	0x18,0
(0088) 	 SPI_Read(); //按照SD卡的操作时序在这里补8个时钟
    02BCC 940E 38D0 CALL	_SPI_Read
(0089) 	 return SD_TURE; //返回0,说明初始化操作成功
    02BCE 2700      CLR	R16
    02BCF 9626      ADIW	R28,6
    02BD0 940C 40CD JMP	pop_xgsetF00C
_SD_Write_Sector:
  pcmd                 --> Y,+0
  time                 --> R12
  temp                 --> R20
  i                    --> R22
  buffer               --> R10
  addr                 --> Y,+14
    02BD2 940E 3F62 CALL	push_arg4
    02BD4 940E 40E2 CALL	push_xgsetF03C
    02BD6 9726      SBIW	R28,6
    02BD7 88AA      LDD	R10,Y+18
    02BD8 88BB      LDD	R11,Y+19
(0090) } 
(0091) //****************************************************************
(0092) //*隶属模块：SD卡控制
(0093) //*函数功能：写512字节数据（一扇区字节）
(0094) //****************************************************************
(0095) UINT16 SD_Write_Sector(UINT32 addr,UINT8 *buffer)
(0096) {  
(0097) 	UINT8 temp=0,time=0;
    02BD9 2744      CLR	R20
    02BDA 24CC      CLR	R12
(0098) 	UINT16 i=0;
    02BDB 2766      CLR	R22
    02BDC 2777      CLR	R23
(0099) 	UINT8 pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //向SD卡中单个块（512字节，一个扇区）写入数据，用CMD24
    02BDD E580      LDI	R24,0x50
    02BDE E092      LDI	R25,2
    02BDF 01FE      MOVW	R30,R28
    02BE0 E006      LDI	R16,6
    02BE1 E010      LDI	R17,0
    02BE2 93FA      ST	-Y,R31
    02BE3 93EA      ST	-Y,R30
    02BE4 939A      ST	-Y,R25
    02BE5 938A      ST	-Y,R24
    02BE6 940E 414E CALL	asgnblk
(0100) 
(0101) 	 addr<<=9; //将块地址（扇区地址）转为字节地址 ［这里就限制了SD卡的最大容量为4G］
    02BE8 E089      LDI	R24,0x9
    02BE9 E090      LDI	R25,0
    02BEA 850E      LDD	R16,Y+14
    02BEB 851F      LDD	R17,Y+15
    02BEC 8928      LDD	R18,Y+16
    02BED 8939      LDD	R19,Y+17
    02BEE 938A      ST	-Y,R24
    02BEF 940E 4129 CALL	lsl32
    02BF1 870E      STD	Y+14,R16
    02BF2 871F      STD	Y+15,R17
    02BF3 8B28      STD	Y+16,R18
    02BF4 8B39      STD	Y+17,R19
(0102) 
(0103) 	 pcmd[1]=(addr>>24); //将字节地址写入到CMD24字节序列中
    02BF5 E188      LDI	R24,0x18
    02BF6 E090      LDI	R25,0
    02BF7 850E      LDD	R16,Y+14
    02BF8 851F      LDD	R17,Y+15
    02BF9 8928      LDD	R18,Y+16
    02BFA 8939      LDD	R19,Y+17
    02BFB 938A      ST	-Y,R24
    02BFC 940E 4142 CALL	lsr32
    02BFE 8309      STD	Y+1,R16
(0104) 	 pcmd[2]=(addr>>16);
    02BFF 842E      LDD	R2,Y+14
    02C00 843F      LDD	R3,Y+15
    02C01 8848      LDD	R4,Y+16
    02C02 8859      LDD	R5,Y+17
    02C03 0112      MOVW	R2,R4
    02C04 2444      CLR	R4
    02C05 2455      CLR	R5
    02C06 822A      STD	Y+2,R2
(0105) 	 pcmd[3]=(addr>>8);
    02C07 E088      LDI	R24,0x8
    02C08 E090      LDI	R25,0
    02C09 850E      LDD	R16,Y+14
    02C0A 851F      LDD	R17,Y+15
    02C0B 8928      LDD	R18,Y+16
    02C0C 8939      LDD	R19,Y+17
    02C0D 938A      ST	-Y,R24
    02C0E 940E 4142 CALL	lsr32
    02C10 830B      STD	Y+3,R16
(0106) 	// pcmd[4]=offset;	
(0107) 	 SD_CS_EN();//打开SD卡片选
    02C11 98C0      CBI	0x18,0
(0108) 
(0109) 	 do
(0110) 	 {  
(0111) 		temp=SD_Write_cmd(pcmd);
    02C12 018E      MOVW	R16,R28
    02C13 DF2C      RCALL	_SD_Write_cmd
    02C14 2F40      MOV	R20,R16
(0112)   		time++;
    02C15 94C3      INC	R12
(0113)   		if(time==TRY_TIME) 
    02C16 2D8C      MOV	R24,R12
    02C17 3184      CPI	R24,0x14
    02C18 F419      BNE	0x2C1C
(0114)   		{ 
(0115)    			SD_CS_DIS(); //关闭片选
    02C19 9AC0      SBI	0x18,0
(0116)    			return(temp); //命令写入失败
    02C1A 2711      CLR	R17
    02C1B C037      RJMP	0x2C53
(0117)   		}
(0118) 	}while(temp!=0); 
    02C1C 2344      TST	R20
    02C1D F7A1      BNE	0x2C12
(0119) 
(0120) 	for(i=0;i<100;i++) //这里要插入若干时钟信号
    02C1E 2766      CLR	R22
    02C1F 2777      CLR	R23
    02C20 C004      RJMP	0x2C25
(0121)   		SPI_Read();
    02C21 940E 38D0 CALL	_SPI_Read
    02C23 5F6F      SUBI	R22,0xFF
    02C24 4F7F      SBCI	R23,0xFF
    02C25 3664      CPI	R22,0x64
    02C26 E0E0      LDI	R30,0
    02C27 077E      CPC	R23,R30
    02C28 F3C0      BCS	0x2C21
(0122) 	
(0123) 	SPI_Write(0xfe);//写入开始字节 0xfe，后面就是要写入的512个字节的数据	
    02C29 EF0E      LDI	R16,0xFE
    02C2A 940E 38CC CALL	_SPI_Write
(0124) 	
(0125) 	for(i=0;i<512;i++) //将缓冲区中要写入的512个字节写入SD卡
    02C2C 2766      CLR	R22
    02C2D 2777      CLR	R23
    02C2E C007      RJMP	0x2C36
(0126) 		SPI_Write(*buffer++);
    02C2F 01F5      MOVW	R30,R10
    02C30 9101      LD	R16,Z+
    02C31 015F      MOVW	R10,R30
    02C32 940E 38CC CALL	_SPI_Write
    02C34 5F6F      SUBI	R22,0xFF
    02C35 4F7F      SBCI	R23,0xFF
    02C36 3060      CPI	R22,0
    02C37 E0E2      LDI	R30,2
    02C38 077E      CPC	R23,R30
    02C39 F3A8      BCS	0x2C2F
(0127)   
(0128) 	SPI_Read(); 
    02C3A 940E 38D0 CALL	_SPI_Read
(0129) 	SPI_Read(); //两个字节的CRC校验码，不用关心
    02C3C 940E 38D0 CALL	_SPI_Read
(0130)    
(0131)     
(0132) 	temp=SPI_Read();   //读取返回值
    02C3E 940E 38D0 CALL	_SPI_Read
    02C40 2F40      MOV	R20,R16
(0133) 	if((temp&0x1F)!=0x05) //如果返回值是 XXX00101说明数据已经被SD卡接受了
    02C41 2F84      MOV	R24,R20
    02C42 718F      ANDI	R24,0x1F
    02C43 3085      CPI	R24,5
    02C44 F021      BEQ	0x2C49
(0134) 	{
(0135)  		SD_CS_DIS();
    02C45 9AC0      SBI	0x18,0
(0136)  		return(WRITE_BLOCK_ERROR); //写块数据失败
    02C46 E003      LDI	R16,3
    02C47 E010      LDI	R17,0
    02C48 C00A      RJMP	0x2C53
(0137) 	}
(0138)  
(0139) 	while(SPI_Read()!=0xff);//等到SD卡不忙（数据被接受以后，SD卡要将这些数据写入到自身的FLASH中，需要一个时间）
    02C49 940E 38D0 CALL	_SPI_Read
    02C4B 2F40      MOV	R20,R16
    02C4C 3F0F      CPI	R16,0xFF
    02C4D F7D9      BNE	0x2C49
(0140) 						    //忙时，读回来的值为0x00,不忙时，为0xff
(0141) 
(0142) 	SD_CS_DIS(); //关闭片选
    02C4E 9AC0      SBI	0x18,0
(0143) 
(0144) 	SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02C4F 940E 38D0 CALL	_SPI_Read
(0145) 	return SD_TURE;		 //返回0,说明写扇区操作成功
    02C51 2700      CLR	R16
    02C52 2711      CLR	R17
    02C53 9626      ADIW	R28,6
    02C54 940E 40EB CALL	pop_xgsetF03C
    02C56 9624      ADIW	R28,4
    02C57 9508      RET
_SD_Read_Sector:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  buffer               --> R10
  addr                 --> Y,+14
    02C58 940E 3F62 CALL	push_arg4
    02C5A 940E 40E2 CALL	push_xgsetF03C
    02C5C 9726      SBIW	R28,6
    02C5D 88AA      LDD	R10,Y+18
    02C5E 88BB      LDD	R11,Y+19
(0146) } 
(0147) //****************************************************************
(0148) //*隶属模块：SD卡控制
(0149) //*函数功能：读512字节数据（一扇区字节）
(0150) //****************************************************************
(0151) UINT16 SD_Read_Sector(UINT32 addr,UINT8 *buffer)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0152) {
(0153) 
(0154) 	 UINT16 j=0;
    02C5F 2744      CLR	R20
    02C60 2755      CLR	R21
(0155) 	 UINT8 time=0,temp=0;
    02C61 2766      CLR	R22
    02C62 24CC      CLR	R12
(0156) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02C63 E586      LDI	R24,0x56
    02C64 E092      LDI	R25,2
    02C65 01FE      MOVW	R30,R28
    02C66 E006      LDI	R16,6
    02C67 E010      LDI	R17,0
    02C68 93FA      ST	-Y,R31
    02C69 93EA      ST	-Y,R30
    02C6A 939A      ST	-Y,R25
    02C6B 938A      ST	-Y,R24
    02C6C 940E 414E CALL	asgnblk
(0157) 
(0158) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02C6E E089      LDI	R24,0x9
    02C6F E090      LDI	R25,0
    02C70 850E      LDD	R16,Y+14
    02C71 851F      LDD	R17,Y+15
    02C72 8928      LDD	R18,Y+16
    02C73 8939      LDD	R19,Y+17
    02C74 938A      ST	-Y,R24
    02C75 940E 4129 CALL	lsl32
    02C77 870E      STD	Y+14,R16
    02C78 871F      STD	Y+15,R17
    02C79 8B28      STD	Y+16,R18
    02C7A 8B39      STD	Y+17,R19
(0159) 
(0160) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02C7B E188      LDI	R24,0x18
    02C7C E090      LDI	R25,0
    02C7D 850E      LDD	R16,Y+14
    02C7E 851F      LDD	R17,Y+15
    02C7F 8928      LDD	R18,Y+16
    02C80 8939      LDD	R19,Y+17
    02C81 938A      ST	-Y,R24
    02C82 940E 4142 CALL	lsr32
    02C84 8309      STD	Y+1,R16
(0161) 	 pcmd[2] = (addr>>16);
    02C85 842E      LDD	R2,Y+14
    02C86 843F      LDD	R3,Y+15
    02C87 8848      LDD	R4,Y+16
    02C88 8859      LDD	R5,Y+17
    02C89 0112      MOVW	R2,R4
    02C8A 2444      CLR	R4
    02C8B 2455      CLR	R5
    02C8C 822A      STD	Y+2,R2
(0162) 	 pcmd[3] =(addr>>8);
    02C8D E088      LDI	R24,0x8
    02C8E E090      LDI	R25,0
    02C8F 850E      LDD	R16,Y+14
    02C90 851F      LDD	R17,Y+15
    02C91 8928      LDD	R18,Y+16
    02C92 8939      LDD	R19,Y+17
    02C93 938A      ST	-Y,R24
    02C94 940E 4142 CALL	lsr32
    02C96 830B      STD	Y+3,R16
(0163) 	// pcmd[4] = offset;
(0164) 
(0165) 	 SD_CS_EN();//打开片选 
    02C97 98C0      CBI	0x18,0
(0166) 
(0167) 	 do
(0168) 	 {  
(0169) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02C98 018E      MOVW	R16,R28
    02C99 DEA6      RCALL	_SD_Write_cmd
    02C9A 2EC0      MOV	R12,R16
(0170) 		  time++;
    02C9B 9563      INC	R22
(0171) 		  if(time==TRY_TIME) 
    02C9C 3164      CPI	R22,0x14
    02C9D F421      BNE	0x2CA2
(0172) 		  {
(0173) 		   SD_CS_DIS();
    02C9E 9AC0      SBI	0x18,0
(0174) 		   return(READ_BLOCK_ERROR); //读块失败
    02C9F E004      LDI	R16,4
    02CA0 E010      LDI	R17,0
    02CA1 C01F      RJMP	0x2CC1
(0175) 		  }
(0176) 	 }while(temp!=0); 
    02CA2 20CC      TST	R12
    02CA3 F7A1      BNE	0x2C98
(0177)    			
(0178) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02CA4 940E 38D0 CALL	_SPI_Read
    02CA6 3F0E      CPI	R16,0xFE
    02CA7 F7E1      BNE	0x2CA4
(0179)  		   	   	
(0180) 	 for(j=0;j<512;j++)	 //将数据写入到数据缓冲区中
    02CA8 2744      CLR	R20
    02CA9 2755      CLR	R21
    02CAA C009      RJMP	0x2CB4
(0181) 	 {	
(0182) 	    buffer[j]=SPI_Read();
    02CAB 940E 38D0 CALL	_SPI_Read
    02CAD 2EC0      MOV	R12,R16
    02CAE 01FA      MOVW	R30,R20
    02CAF 0DEA      ADD	R30,R10
    02CB0 1DFB      ADC	R31,R11
    02CB1 82C0      ST	Z,R12
    02CB2 5F4F      SUBI	R20,0xFF
    02CB3 4F5F      SBCI	R21,0xFF
    02CB4 3040      CPI	R20,0
    02CB5 E0E2      LDI	R30,2
    02CB6 075E      CPC	R21,R30
    02CB7 F398      BCS	0x2CAB
(0183) 	 }
(0184) 
(0185) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02CB8 940E 38D0 CALL	_SPI_Read
(0186) 	 SPI_Read();
    02CBA 940E 38D0 CALL	_SPI_Read
(0187) 
(0188) 	 SD_CS_DIS();  //SD卡关闭片选 
    02CBC 9AC0      SBI	0x18,0
(0189) 
(0190) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02CBD 940E 38D0 CALL	_SPI_Read
(0191) 
(0192) 	 return SD_TURE;
    02CBF 2700      CLR	R16
    02CC0 2711      CLR	R17
    02CC1 9626      ADIW	R28,6
    02CC2 940E 40EB CALL	pop_xgsetF03C
    02CC4 9624      ADIW	R28,4
    02CC5 9508      RET
_SD_Read_Sector_ndata:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  len                  --> R14
  offset               --> R10
  buffer               --> Y,+20
  addr                 --> Y,+16
    02CC6 940E 3F62 CALL	push_arg4
    02CC8 940E 40A7 CALL	push_xgsetF0FC
    02CCA 9726      SBIW	R28,6
    02CCB 88AE      LDD	R10,Y+22
    02CCC 88BF      LDD	R11,Y+23
    02CCD 8CE8      LDD	R14,Y+24
    02CCE 8CF9      LDD	R15,Y+25
(0193) }
(0194) //****************************************************************
(0195) //*隶属模块：SD卡控制
(0196) //*函数功能：写多扇区数据（多扇区字节）
(0197) //****************************************************************
(0198) UINT16 SD_Read_Sector_ndata(UINT32 addr,UINT8 *buffer,UINT16 offset,UINT16 len)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0199) {
(0200) 
(0201) 	 UINT16 j=0;
    02CCF 2744      CLR	R20
    02CD0 2755      CLR	R21
(0202) 	 UINT8 time=0,temp=0;
    02CD1 2766      CLR	R22
    02CD2 24CC      CLR	R12
(0203) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02CD3 E58C      LDI	R24,0x5C
    02CD4 E092      LDI	R25,2
    02CD5 01FE      MOVW	R30,R28
    02CD6 E006      LDI	R16,6
    02CD7 E010      LDI	R17,0
    02CD8 93FA      ST	-Y,R31
    02CD9 93EA      ST	-Y,R30
    02CDA 939A      ST	-Y,R25
    02CDB 938A      ST	-Y,R24
    02CDC 940E 414E CALL	asgnblk
(0204) 
(0205) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02CDE E089      LDI	R24,0x9
    02CDF E090      LDI	R25,0
    02CE0 8908      LDD	R16,Y+16
    02CE1 8919      LDD	R17,Y+17
    02CE2 892A      LDD	R18,Y+18
    02CE3 893B      LDD	R19,Y+19
    02CE4 938A      ST	-Y,R24
    02CE5 940E 4129 CALL	lsl32
    02CE7 8B08      STD	Y+16,R16
    02CE8 8B19      STD	Y+17,R17
    02CE9 8B2A      STD	Y+18,R18
    02CEA 8B3B      STD	Y+19,R19
(0206) 
(0207) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02CEB E188      LDI	R24,0x18
    02CEC E090      LDI	R25,0
    02CED 8908      LDD	R16,Y+16
    02CEE 8919      LDD	R17,Y+17
    02CEF 892A      LDD	R18,Y+18
    02CF0 893B      LDD	R19,Y+19
    02CF1 938A      ST	-Y,R24
    02CF2 940E 4142 CALL	lsr32
    02CF4 8309      STD	Y+1,R16
(0208) 	 pcmd[2] = (addr>>16);
    02CF5 8828      LDD	R2,Y+16
    02CF6 8839      LDD	R3,Y+17
    02CF7 884A      LDD	R4,Y+18
    02CF8 885B      LDD	R5,Y+19
    02CF9 0112      MOVW	R2,R4
    02CFA 2444      CLR	R4
    02CFB 2455      CLR	R5
    02CFC 822A      STD	Y+2,R2
(0209) 	 pcmd[3] =(addr>>8);
    02CFD E088      LDI	R24,0x8
    02CFE E090      LDI	R25,0
    02CFF 8908      LDD	R16,Y+16
    02D00 8919      LDD	R17,Y+17
    02D01 892A      LDD	R18,Y+18
    02D02 893B      LDD	R19,Y+19
    02D03 938A      ST	-Y,R24
    02D04 940E 4142 CALL	lsr32
    02D06 830B      STD	Y+3,R16
(0210) 	// pcmd[4] = offset;
(0211) 
(0212) 	 SD_CS_EN();//打开片选 
    02D07 98C0      CBI	0x18,0
(0213) 
(0214) 	 do
(0215) 	 {  
(0216) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02D08 018E      MOVW	R16,R28
    02D09 DE36      RCALL	_SD_Write_cmd
    02D0A 2EC0      MOV	R12,R16
(0217) 		  time++;
    02D0B 9563      INC	R22
(0218) 		  if(time==TRY_TIME) 
    02D0C 3164      CPI	R22,0x14
    02D0D F421      BNE	0x2D12
(0219) 		  {
(0220) 		   SD_CS_DIS();
    02D0E 9AC0      SBI	0x18,0
(0221) 		   return(READ_BLOCK_ERROR); //读块失败
    02D0F E004      LDI	R16,4
    02D10 E010      LDI	R17,0
    02D11 C034      RJMP	0x2D46
(0222) 		  }
(0223) 	 }while(temp!=0); 
    02D12 20CC      TST	R12
    02D13 F7A1      BNE	0x2D08
(0224)    			
(0225) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02D14 940E 38D0 CALL	_SPI_Read
    02D16 3F0E      CPI	R16,0xFE
    02D17 F7E1      BNE	0x2D14
(0226)  		   	   	
(0227) 	 for(j=0;j<offset;j++)	 //将数据写入到数据缓冲区中
    02D18 2744      CLR	R20
    02D19 2755      CLR	R21
    02D1A C004      RJMP	0x2D1F
(0228) 	    SPI_Read();
    02D1B 940E 38D0 CALL	_SPI_Read
    02D1D 5F4F      SUBI	R20,0xFF
    02D1E 4F5F      SBCI	R21,0xFF
    02D1F 154A      CP	R20,R10
    02D20 055B      CPC	R21,R11
    02D21 F3C8      BCS	0x2D1B
(0229) 	 for(;j<offset+len;j++)	 
    02D22 C00B      RJMP	0x2D2E
(0230) 		buffer[j]=SPI_Read();
    02D23 940E 38D0 CALL	_SPI_Read
    02D25 2F60      MOV	R22,R16
    02D26 01FA      MOVW	R30,R20
    02D27 880C      LDD	R0,Y+20
    02D28 881D      LDD	R1,Y+21
    02D29 0DE0      ADD	R30,R0
    02D2A 1DF1      ADC	R31,R1
    02D2B 8360      ST	Z,R22
    02D2C 5F4F      SUBI	R20,0xFF
    02D2D 4F5F      SBCI	R21,0xFF
    02D2E 0115      MOVW	R2,R10
    02D2F 0C2E      ADD	R2,R14
    02D30 1C3F      ADC	R3,R15
    02D31 1542      CP	R20,R2
    02D32 0553      CPC	R21,R3
    02D33 F378      BCS	0x2D23
(0231) 	 for(;j<512;j++)	 
    02D34 C004      RJMP	0x2D39
(0232) 		SPI_Read();
    02D35 940E 38D0 CALL	_SPI_Read
    02D37 5F4F      SUBI	R20,0xFF
    02D38 4F5F      SBCI	R21,0xFF
    02D39 3040      CPI	R20,0
    02D3A E0E2      LDI	R30,2
    02D3B 075E      CPC	R21,R30
    02D3C F3C0      BCS	0x2D35
(0233) 
(0234) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02D3D 940E 38D0 CALL	_SPI_Read
(0235) 	 SPI_Read();
    02D3F 940E 38D0 CALL	_SPI_Read
(0236) 
(0237) 	 SD_CS_DIS();  //SD卡关闭片选 
    02D41 9AC0      SBI	0x18,0
(0238) 
(0239) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02D42 940E 38D0 CALL	_SPI_Read
(0240) 
(0241) 	 return SD_TURE;
    02D44 2700      CLR	R16
    02D45 2711      CLR	R17
    02D46 9626      ADIW	R28,6
    02D47 940E 409C CALL	pop_xgsetF0FC
    02D49 9624      ADIW	R28,4
    02D4A 9508      RET
_GUI_mainmeu:
  key                  --> R22
  select               --> R20
    02D4B 934A      ST	-Y,R20
    02D4C 936A      ST	-Y,R22
    02D4D 9723      SBIW	R28,3
FILE: D:\LQD\software\master\software_src\gui.c
(0001) #include "config.h"
(0002) const char labelH[]="高强度作业：\0";
(0003) const char labelM[]="中等强度作业：\0";
(0004) const char labelL[]="低强度作业：\0";
(0005) const char H01[]="加强劳动监督；\0";
(0006) const char H02[]="增加饮水;\0" ;
(0007) const char H03[]="保持干燥禁裸露。\0";
(0008) #define M01 H01
(0009) #define M02 H03
(0010) const char M03[]="戴面罩。\0";
(0011) const char M04[]="禁油彩。\0";
(0012) #define L01 M03
(0013) #define L02 M04
(0014) const char L03[]="缩短作业时间。";
(0015) //-----//
(0016) #define H11 M04
(0017) #define H12 H03
(0018) const char H13[]="休息注意保暖。\0";
(0019) #define M11 H01
(0020) const char M12[]="减少非必须作业；\0";
(0021) const char M13[]="劳动时间<30min。\0";
(0022) const char L11[]="取消非必须的作业\0";
(0023) const char L12[]="劳动时间<15min；\0";
(0024) #define L13 H03
(0025) //-----//
(0026) #define H21 L11
(0027) #define H22 L12
(0028) #define H23 H03
(0029) const char M21[]="取消户外作业。"; 
(0030) #define L21 M21
(0031) 
(0032) //#define LEDON   PORTC&=~(1<<7)					   
(0033) //#define LEDOFF  PINC|=(1<<7)
(0034) char GUI_date[17]="09月19日18:00:00\0";
(0035) 
(0036) // 主菜单
(0037) unsigned char GUI_mainmeu( void ){
(0038)  	unsigned char key=0; //init= nokey
    02D4E 2766      CLR	R22
(0039) 	unsigned char select=3;
    02D4F E043      LDI	R20,3
(0040) 	LCD_CLR();
    02D50 940E 39B0 CALL	_LCD_CLR
(0041)  	Set_White(1,1,8,1);
    02D52 E081      LDI	R24,1
    02D53 838A      STD	Y+2,R24
    02D54 E088      LDI	R24,0x8
    02D55 8388      ST	Y,R24
    02D56 E021      LDI	R18,1
    02D57 E001      LDI	R16,1
    02D58 940E 3A3A CALL	_Set_White
(0042) 	Set_White(1,2,8,1);
    02D5A E081      LDI	R24,1
    02D5B 838A      STD	Y+2,R24
    02D5C E088      LDI	R24,0x8
    02D5D 8388      ST	Y,R24
    02D5E E022      LDI	R18,2
    02D5F E001      LDI	R16,1
    02D60 940E 3A3A CALL	_Set_White
(0043) 	Set_White(1,3,8,1);
    02D62 E081      LDI	R24,1
    02D63 838A      STD	Y+2,R24
    02D64 E088      LDI	R24,0x8
    02D65 8388      ST	Y,R24
    02D66 E023      LDI	R18,3
    02D67 E001      LDI	R16,1
    02D68 940E 3A3A CALL	_Set_White
(0044) 	Set_White(1,4,8,1);
    02D6A E081      LDI	R24,1
    02D6B 838A      STD	Y+2,R24
    02D6C E088      LDI	R24,0x8
    02D6D 8388      ST	Y,R24
    02D6E E024      LDI	R18,4
    02D6F E001      LDI	R16,1
    02D70 940E 3A3A CALL	_Set_White
(0045) 	LCD_const_disp(2,1,"  检测  时钟调整");
    02D72 EC8F      LDI	R24,0xCF
    02D73 E094      LDI	R25,4
    02D74 8399      STD	Y+1,R25
    02D75 8388      ST	Y,R24
    02D76 E021      LDI	R18,1
    02D77 E002      LDI	R16,2
    02D78 940E 390A CALL	_LCD_const_disp
(0046) 	LCD_const_disp(3,1,"  查询  数据传输");
    02D7A EB8E      LDI	R24,0xBE
    02D7B E094      LDI	R25,4
    02D7C 8399      STD	Y+1,R25
    02D7D 8388      ST	Y,R24
    02D7E E021      LDI	R18,1
    02D7F E003      LDI	R16,3
    02D80 940E 390A CALL	_LCD_const_disp
(0047) 	LCD_const_disp(4,1,"  初始化");
    02D82 EB85      LDI	R24,0xB5
    02D83 E094      LDI	R25,4
    02D84 8399      STD	Y+1,R25
    02D85 8388      ST	Y,R24
    02D86 E021      LDI	R18,1
    02D87 E004      LDI	R16,4
    02D88 940E 390A CALL	_LCD_const_disp
(0048) 	Set_White(1,1,8,1);
    02D8A E081      LDI	R24,1
    02D8B 838A      STD	Y+2,R24
    02D8C E088      LDI	R24,0x8
    02D8D 8388      ST	Y,R24
    02D8E E021      LDI	R18,1
    02D8F E001      LDI	R16,1
    02D90 940E 3A3A CALL	_Set_White
(0049) 	Set_White(1,2,8,1);
    02D92 E081      LDI	R24,1
    02D93 838A      STD	Y+2,R24
    02D94 E088      LDI	R24,0x8
    02D95 8388      ST	Y,R24
    02D96 E022      LDI	R18,2
    02D97 E001      LDI	R16,1
    02D98 940E 3A3A CALL	_Set_White
(0050) 	Set_White(1,3,8,1);
    02D9A E081      LDI	R24,1
    02D9B 838A      STD	Y+2,R24
    02D9C E088      LDI	R24,0x8
    02D9D 8388      ST	Y,R24
    02D9E E023      LDI	R18,3
    02D9F E001      LDI	R16,1
    02DA0 940E 3A3A CALL	_Set_White
(0051) 	Set_White(1,4,8,1);
    02DA2 E081      LDI	R24,1
    02DA3 838A      STD	Y+2,R24
    02DA4 E088      LDI	R24,0x8
    02DA5 8388      ST	Y,R24
    02DA6 E024      LDI	R18,4
    02DA7 E001      LDI	R16,1
    02DA8 940E 3A3A CALL	_Set_White
(0052) 	set_white_n(select,0);
    02DAA 2722      CLR	R18
    02DAB 2F04      MOV	R16,R20
    02DAC 940E 3ACC CALL	_set_white_n
    02DAE C07B      RJMP	0x2E2A
(0053) 	while(1)
(0054) 	{
(0055) 	 	key=kbscan();
    02DAF 940E 3EF9 CALL	_kbscan
    02DB1 2F60      MOV	R22,R16
(0056) 		dateRefresh(1); //更新系统时间
    02DB2 E001      LDI	R16,1
    02DB3 D7EB      RCALL	_dateRefresh
(0057) 		LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02DB4 D43B      RCALL	_GUI_get_date
    02DB5 8319      STD	Y+1,R17
    02DB6 8308      ST	Y,R16
    02DB7 E021      LDI	R18,1
    02DB8 E001      LDI	R16,1
    02DB9 940E 390A CALL	_LCD_const_disp
(0058) 		if((select>3) && ( key==up ) ){
    02DBB E083      LDI	R24,3
    02DBC 1784      CP	R24,R20
    02DBD F4F8      BCC	0x2DDD
    02DBE 316E      CPI	R22,0x1E
    02DBF F4E9      BNE	0x2DDD
(0059) 		 Set_White(1,2,8,1);
    02DC0 E081      LDI	R24,1
    02DC1 838A      STD	Y+2,R24
    02DC2 E088      LDI	R24,0x8
    02DC3 8388      ST	Y,R24
    02DC4 E022      LDI	R18,2
    02DC5 E001      LDI	R16,1
    02DC6 940E 3A3A CALL	_Set_White
(0060) 		 Set_White(1,3,8,1);
    02DC8 E081      LDI	R24,1
    02DC9 838A      STD	Y+2,R24
    02DCA E088      LDI	R24,0x8
    02DCB 8388      ST	Y,R24
    02DCC E023      LDI	R18,3
    02DCD E001      LDI	R16,1
    02DCE 940E 3A3A CALL	_Set_White
(0061) 		 Set_White(1,4,8,1);
    02DD0 E081      LDI	R24,1
    02DD1 838A      STD	Y+2,R24
    02DD2 E088      LDI	R24,0x8
    02DD3 8388      ST	Y,R24
    02DD4 E024      LDI	R18,4
    02DD5 E001      LDI	R16,1
    02DD6 940E 3A3A CALL	_Set_White
(0062) 		 select--;
    02DD8 954A      DEC	R20
(0063) 		 set_white_n(select,0);
    02DD9 2722      CLR	R18
    02DDA 2F04      MOV	R16,R20
    02DDB 940E 3ACC CALL	_set_white_n
(0064) 		}
(0065) 		if((select<7) && ( key==down ) ){
    02DDD 3047      CPI	R20,7
    02DDE F538      BCC	0x2E06
    02DDF 316D      CPI	R22,0x1D
    02DE0 F529      BNE	0x2E06
(0066) 		 Set_White(1,1,8,1);
    02DE1 E081      LDI	R24,1
    02DE2 838A      STD	Y+2,R24
    02DE3 E088      LDI	R24,0x8
    02DE4 8388      ST	Y,R24
    02DE5 E021      LDI	R18,1
    02DE6 E001      LDI	R16,1
    02DE7 940E 3A3A CALL	_Set_White
(0067) 		 Set_White(1,2,8,1);
    02DE9 E081      LDI	R24,1
    02DEA 838A      STD	Y+2,R24
    02DEB E088      LDI	R24,0x8
    02DEC 8388      ST	Y,R24
    02DED E022      LDI	R18,2
    02DEE E001      LDI	R16,1
    02DEF 940E 3A3A CALL	_Set_White
(0068) 		 Set_White(1,3,8,1);
    02DF1 E081      LDI	R24,1
    02DF2 838A      STD	Y+2,R24
    02DF3 E088      LDI	R24,0x8
    02DF4 8388      ST	Y,R24
    02DF5 E023      LDI	R18,3
    02DF6 E001      LDI	R16,1
    02DF7 940E 3A3A CALL	_Set_White
(0069) 		 Set_White(1,4,8,1);
    02DF9 E081      LDI	R24,1
    02DFA 838A      STD	Y+2,R24
    02DFB E088      LDI	R24,0x8
    02DFC 8388      ST	Y,R24
    02DFD E024      LDI	R18,4
    02DFE E001      LDI	R16,1
    02DFF 940E 3A3A CALL	_Set_White
(0070) 		 select++;
    02E01 9543      INC	R20
(0071) 		 set_white_n(select,0);
    02E02 2722      CLR	R18
    02E03 2F04      MOV	R16,R20
    02E04 940E 3ACC CALL	_set_white_n
(0072) 		}
(0073) 		if(key == left ){
    02E06 316B      CPI	R22,0x1B
    02E07 F511      BNE	0x2E2A
(0074) 		 Set_White(1,1,8,1);
    02E08 E081      LDI	R24,1
    02E09 838A      STD	Y+2,R24
    02E0A E088      LDI	R24,0x8
    02E0B 8388      ST	Y,R24
    02E0C E021      LDI	R18,1
    02E0D E001      LDI	R16,1
    02E0E 940E 3A3A CALL	_Set_White
(0075) 		 Set_White(1,2,8,1);
    02E10 E081      LDI	R24,1
    02E11 838A      STD	Y+2,R24
    02E12 E088      LDI	R24,0x8
    02E13 8388      ST	Y,R24
    02E14 E022      LDI	R18,2
    02E15 E001      LDI	R16,1
    02E16 940E 3A3A CALL	_Set_White
(0076) 		 Set_White(1,3,8,1);
    02E18 E081      LDI	R24,1
    02E19 838A      STD	Y+2,R24
    02E1A E088      LDI	R24,0x8
    02E1B 8388      ST	Y,R24
    02E1C E023      LDI	R18,3
    02E1D E001      LDI	R16,1
    02E1E 940E 3A3A CALL	_Set_White
(0077) 		 Set_White(1,4,8,1);
    02E20 E081      LDI	R24,1
    02E21 838A      STD	Y+2,R24
    02E22 E088      LDI	R24,0x8
    02E23 8388      ST	Y,R24
    02E24 E024      LDI	R18,4
    02E25 E001      LDI	R16,1
    02E26 940E 3A3A CALL	_Set_White
(0078) 		 //beep(3,select);
(0079) 		 return select;
    02E28 2F04      MOV	R16,R20
    02E29 C001      RJMP	0x2E2B
    02E2A CF84      RJMP	0x2DAF
    02E2B 9623      ADIW	R28,3
    02E2C 9169      LD	R22,Y+
    02E2D 9149      LD	R20,Y+
    02E2E 9508      RET
_GUI_check:
  next_step_time       --> Y,+3
  windcounter          --> R10
  selectCheckMode      --> R14
  is_on                --> Y,+8
  page                 --> Y,+7
  key                  --> R12
    02E2F 940E 40A7 CALL	push_xgsetF0FC
    02E31 9729      SBIW	R28,0x9
(0080) 		}
(0081)     }
(0082) 	return 0xff; //error
(0083) 	
(0084) }
(0085) 
(0086) //”检测 “菜单
(0087) void GUI_check(void){
(0088)     char key;
(0089) 	char page=0,is_on=0;
    02E32 2400      CLR	R0
    02E33 820F      STD	Y+7,R0
    02E34 8608      STD	Y+8,R0
(0090) 	char windcounter=0;
    02E35 24AA      CLR	R10
(0091) 	long next_step_time=0;
    02E36 E080      LDI	R24,0
    02E37 838B      STD	Y+3,R24
    02E38 838C      STD	Y+4,R24
    02E39 838D      STD	Y+5,R24
    02E3A 838E      STD	Y+6,R24
(0092) 	char selectCheckMode=config.autocheck; //自动检测开关
    02E3B 90E0 07D8 LDS	R14,config+16
(0093) RE_IN:
(0094) 	LCD_CLR();
    02E3D 940E 39B0 CALL	_LCD_CLR
(0095) 	LCD_const_disp(1,1,"菜单/ 检测");
    02E3F EA8A      LDI	R24,0xAA
    02E40 E094      LDI	R25,4
    02E41 8399      STD	Y+1,R25
    02E42 8388      ST	Y,R24
    02E43 E021      LDI	R18,1
    02E44 E001      LDI	R16,1
    02E45 940E 390A CALL	_LCD_const_disp
(0096) 	LCD_const_disp(2,3,"自动");		 
    02E47 EA85      LDI	R24,0xA5
    02E48 E094      LDI	R25,4
    02E49 8399      STD	Y+1,R25
    02E4A 8388      ST	Y,R24
    02E4B E023      LDI	R18,3
    02E4C E002      LDI	R16,2
    02E4D 940E 390A CALL	_LCD_const_disp
(0097) 	LCD_const_disp(3,3,"手动");
    02E4F EA80      LDI	R24,0xA0
    02E50 E094      LDI	R25,4
    02E51 8399      STD	Y+1,R25
    02E52 8388      ST	Y,R24
    02E53 E023      LDI	R18,3
    02E54 E003      LDI	R16,3
    02E55 940E 390A CALL	_LCD_const_disp
(0098) 	if(selectCheckMode==1) {
    02E57 2D8E      MOV	R24,R14
    02E58 3081      CPI	R24,1
    02E59 F489      BNE	0x2E6B
(0099) 	    Set_White(1,2,8,0);
    02E5A 2422      CLR	R2
    02E5B 822A      STD	Y+2,R2
    02E5C E088      LDI	R24,0x8
    02E5D 8388      ST	Y,R24
    02E5E E022      LDI	R18,2
    02E5F E001      LDI	R16,1
    02E60 940E 3A3A CALL	_Set_White
(0100) 		Set_White(1,3,8,1);
    02E62 E081      LDI	R24,1
    02E63 838A      STD	Y+2,R24
    02E64 E088      LDI	R24,0x8
    02E65 8388      ST	Y,R24
    02E66 E023      LDI	R18,3
    02E67 E001      LDI	R16,1
    02E68 940E 3A3A CALL	_Set_White
(0101) 	}
    02E6A C05B      RJMP	0x2EC6
(0102) 	else {
(0103) 		 Set_White(1,2,8,1);
    02E6B E081      LDI	R24,1
    02E6C 838A      STD	Y+2,R24
    02E6D E088      LDI	R24,0x8
    02E6E 8388      ST	Y,R24
    02E6F E022      LDI	R18,2
    02E70 E001      LDI	R16,1
    02E71 940E 3A3A CALL	_Set_White
(0104) 		 Set_White(1,3,8,0);
    02E73 2422      CLR	R2
    02E74 822A      STD	Y+2,R2
    02E75 E088      LDI	R24,0x8
    02E76 8388      ST	Y,R24
    02E77 E023      LDI	R18,3
    02E78 E001      LDI	R16,1
    02E79 940E 3A3A CALL	_Set_White
(0105) 	}
    02E7B C04A      RJMP	0x2EC6
(0106) 	
(0107) //<<菜单/检测/手（自）动>>
(0108) 	while(1){
(0109) 	 	key=kbscan();
    02E7C 940E 3EF9 CALL	_kbscan
    02E7E 2EC0      MOV	R12,R16
(0110) 		//上键短按 选择
(0111) 		if(key==up || key ==down){
    02E7F 2D8C      MOV	R24,R12
    02E80 310E      CPI	R16,0x1E
    02E81 F011      BEQ	0x2E84
    02E82 310D      CPI	R16,0x1D
    02E83 F539      BNE	0x2EAB
(0112) 		    if(selectCheckMode >0){
    02E84 E080      LDI	R24,0
    02E85 158E      CP	R24,R14
    02E86 F490      BCC	0x2E99
(0113) 			    selectCheckMode=0;
    02E87 24EE      CLR	R14
(0114) 				Set_White(1,2,8,0);
    02E88 2422      CLR	R2
    02E89 822A      STD	Y+2,R2
    02E8A E088      LDI	R24,0x8
    02E8B 8388      ST	Y,R24
    02E8C E022      LDI	R18,2
    02E8D E001      LDI	R16,1
    02E8E 940E 3A3A CALL	_Set_White
(0115) 	 			Set_White(1,3,8,1);
    02E90 E081      LDI	R24,1
    02E91 838A      STD	Y+2,R24
    02E92 E088      LDI	R24,0x8
    02E93 8388      ST	Y,R24
    02E94 E023      LDI	R18,3
    02E95 E001      LDI	R16,1
    02E96 940E 3A3A CALL	_Set_White
(0116) 			}
    02E98 C012      RJMP	0x2EAB
(0117) 			else {
(0118) 			    selectCheckMode=1;
    02E99 24EE      CLR	R14
    02E9A 94E3      INC	R14
(0119) 				Set_White(1,2,8,1);
    02E9B E081      LDI	R24,1
    02E9C 838A      STD	Y+2,R24
    02E9D E088      LDI	R24,0x8
    02E9E 8388      ST	Y,R24
    02E9F E022      LDI	R18,2
    02EA0 E001      LDI	R16,1
    02EA1 940E 3A3A CALL	_Set_White
(0120) 	 			Set_White(1,3,8,0);
    02EA3 2422      CLR	R2
    02EA4 822A      STD	Y+2,R2
    02EA5 E088      LDI	R24,0x8
    02EA6 8388      ST	Y,R24
    02EA7 E023      LDI	R18,3
    02EA8 E001      LDI	R16,1
    02EA9 940E 3A3A CALL	_Set_White
(0121) 			}
(0122) 			
(0123) 		}
(0124) 		//左键短按  进入
(0125) 		if(key == left) {
    02EAB 2D8C      MOV	R24,R12
    02EAC 318B      CPI	R24,0x1B
    02EAD F499      BNE	0x2EC1
(0126) 			config.autocheck=selectCheckMode; 
    02EAE 92E0 07D8 STS	config+16,R14
(0127) 			Set_White(1,2,8,1);
    02EB0 E081      LDI	R24,1
    02EB1 838A      STD	Y+2,R24
    02EB2 E088      LDI	R24,0x8
    02EB3 8388      ST	Y,R24
    02EB4 E022      LDI	R18,2
    02EB5 E001      LDI	R16,1
    02EB6 940E 3A3A CALL	_Set_White
(0128) 	 		Set_White(1,3,8,1); 
    02EB8 E081      LDI	R24,1
    02EB9 838A      STD	Y+2,R24
    02EBA E088      LDI	R24,0x8
    02EBB 8388      ST	Y,R24
    02EBC E023      LDI	R18,3
    02EBD E001      LDI	R16,1
    02EBE 940E 3A3A CALL	_Set_White
(0129) 			break ;		
    02EC0 C006      RJMP	0x2EC7
(0130) 		}
(0131) 		//右键短按  返回
(0132) 		if(key == right) {
    02EC1 2D8C      MOV	R24,R12
    02EC2 3187      CPI	R24,0x17
    02EC3 F409      BNE	0x2EC5
(0133) 			return ;		
    02EC4 C117      RJMP	0x2FDC
(0134) 		}
(0135) 		key=0;
    02EC5 24CC      CLR	R12
    02EC6 CFB5      RJMP	0x2E7C
(0136) 	} //end of while
(0137) 
(0138)     //自动开启检测
(0139) 	is_on =1 ;
    02EC7 2400      CLR	R0
    02EC8 9403      INC	R0
    02EC9 8608      STD	Y+8,R0
    02ECA C110      RJMP	0x2FDB
(0140)     //----完成检测和存储------
(0141) 	while(1){
(0142) 		key=kbscan();
    02ECB 940E 3EF9 CALL	_kbscan
    02ECD 2EC0      MOV	R12,R16
(0143) 		if(key != 0) beep(0,1);
    02ECE 2300      TST	R16
    02ECF F021      BEQ	0x2ED4
    02ED0 E021      LDI	R18,1
    02ED1 2700      CLR	R16
    02ED2 940E 3C85 CALL	_beep
(0144) 		if(key==right){	//右键 退出
    02ED4 2D8C      MOV	R24,R12
    02ED5 3187      CPI	R24,0x17
    02ED6 F569      BNE	0x2F04
(0145) 		    is_on=0;
    02ED7 2400      CLR	R0
    02ED8 8608      STD	Y+8,R0
(0146) 			LCD_CLR();
    02ED9 940E 39B0 CALL	_LCD_CLR
(0147) 		 	LCD_Init();	  
    02EDB 940E 397E CALL	_LCD_Init
(0148) 	 	 	LCD_const_disp(4,5,"退出    "); 
    02EDD E987      LDI	R24,0x97
    02EDE E094      LDI	R25,4
    02EDF 8399      STD	Y+1,R25
    02EE0 8388      ST	Y,R24
    02EE1 E025      LDI	R18,5
    02EE2 E004      LDI	R16,4
    02EE3 940E 390A CALL	_LCD_const_disp
(0149) 		 	delayms(200);
    02EE5 EC08      LDI	R16,0xC8
    02EE6 E010      LDI	R17,0
    02EE7 940E 2407 CALL	_delayms
(0150) 		 	LCD_const_disp(4,7,".."); 
    02EE9 E984      LDI	R24,0x94
    02EEA E094      LDI	R25,4
    02EEB 8399      STD	Y+1,R25
    02EEC 8388      ST	Y,R24
    02EED E027      LDI	R18,7
    02EEE E004      LDI	R16,4
    02EEF 940E 390A CALL	_LCD_const_disp
(0151) 		 	delayms(200);
    02EF1 EC08      LDI	R16,0xC8
    02EF2 E010      LDI	R17,0
    02EF3 940E 2407 CALL	_delayms
(0152) 		 	LCD_const_disp(4,8,".."); 	
    02EF5 E984      LDI	R24,0x94
    02EF6 E094      LDI	R25,4
    02EF7 8399      STD	Y+1,R25
    02EF8 8388      ST	Y,R24
    02EF9 E028      LDI	R18,0x8
    02EFA E004      LDI	R16,4
    02EFB 940E 390A CALL	_LCD_const_disp
(0153) 		 	delayms(500);
    02EFD EF04      LDI	R16,0xF4
    02EFE E011      LDI	R17,1
    02EFF 940E 2407 CALL	_delayms
(0154) 		 	LCD_CLR();
    02F01 940E 39B0 CALL	_LCD_CLR
(0155) 		 	goto RE_IN;
    02F03 CF39      RJMP	0x2E3D
(0156) 		}
(0157) 		if(is_on==1){ 
    02F04 8588      LDD	R24,Y+8
    02F05 3081      CPI	R24,1
    02F06 F009      BEQ	0x2F08
    02F07 C07A      RJMP	0x2F82
(0158) 		    _GUI_datashow(1,page); //更新时间
    02F08 812F      LDD	R18,Y+7
    02F09 E001      LDI	R16,1
    02F0A D0D4      RCALL	__GUI_datashow
(0159) 		    if(config.now < config.time1) {
    02F0B 9040 07D2 LDS	R4,config+10
    02F0D 9050 07D3 LDS	R5,config+11
    02F0F 9020 07D0 LDS	R2,config+8
    02F11 9030 07D1 LDS	R3,config+9
    02F13 9080 07D6 LDS	R8,config+14
    02F15 9090 07D7 LDS	R9,config+15
    02F17 9060 07D4 LDS	R6,config+12
    02F19 9070 07D5 LDS	R7,config+13
    02F1B 1462      CP	R6,R2
    02F1C 0473      CPC	R7,R3
    02F1D 0484      CPC	R8,R4
    02F1E 0495      CPC	R9,R5
    02F1F F51C      BGE	0x2F43
(0160) 				//时间更新 开启风速检测 等待检测 不支持翻页
(0161) 				if(windcounter==0){
    02F20 20AA      TST	R10
    02F21 F421      BNE	0x2F26
(0162) 				    windcounter=1; //清零开启风速计数器
    02F22 24AA      CLR	R10
    02F23 94A3      INC	R10
(0163) 					timer1_init(); //开启风速传感器技术
    02F24 940E 2455 CALL	_timer1_init
(0164) 				}
(0165) 				if(page == 0 ){
    02F26 800F      LDD	R0,Y+7
    02F27 2000      TST	R0
    02F28 F009      BEQ	0x2F2A
    02F29 C0AD      RJMP	0x2FD7
(0166) 				    LCD_const_disp(4,1,"正在检测");
    02F2A E88B      LDI	R24,0x8B
    02F2B E094      LDI	R25,4
    02F2C 8399      STD	Y+1,R25
    02F2D 8388      ST	Y,R24
    02F2E E021      LDI	R18,1
    02F2F E004      LDI	R16,4
    02F30 940E 390A CALL	_LCD_const_disp
(0167) 					LCD_print4num(4,5,config.time1-config.now);
    02F32 9020 07D4 LDS	R2,config+12
    02F34 9030 07D5 LDS	R3,config+13
    02F36 9040 07D0 LDS	R4,config+8
    02F38 9050 07D1 LDS	R5,config+9
    02F3A 1842      SUB	R4,R2
    02F3B 0853      SBC	R5,R3
    02F3C 8259      STD	Y+1,R5
    02F3D 8248      ST	Y,R4
    02F3E E025      LDI	R18,5
    02F3F E004      LDI	R16,4
    02F40 940E 3BCC CALL	_LCD_print4num
(0168) 				}
(0169) 			} 
    02F42 C094      RJMP	0x2FD7
(0170) 			else {
(0171) 			   //检测完成 获得数据 转换数据 存储数据 切换到非检测状态
(0172) 			    windcounter =0 ; //关闭风速传感器计数器
    02F43 24AA      CLR	R10
(0173) 				check();
    02F44 940E 2820 CALL	_check
(0174) 				StructToChar(); //转成字符串
    02F46 940E 299F CALL	_StructToChar
(0175) 				WriteFileHead();//重写文件头
    02F48 940E 257D CALL	_WriteFileHead
(0176) 				WriteSDFile();  //写入sd卡
    02F4A 940E 25F9 CALL	_WriteSDFile
(0177) 				//zigbee_send(); //发送
(0178) 				Result.Index++; //索引自增一
    02F4C E041      LDI	R20,1
    02F4D E050      LDI	R21,0
    02F4E E060      LDI	R22,0
    02F4F E070      LDI	R23,0
    02F50 9040 0564 LDS	R4,Result+12
    02F52 9050 0565 LDS	R5,Result+13
    02F54 9020 0562 LDS	R2,Result+10
    02F56 9030 0563 LDS	R3,Result+11
    02F58 0E24      ADD	R2,R20
    02F59 1E35      ADC	R3,R21
    02F5A 1E46      ADC	R4,R22
    02F5B 1E57      ADC	R5,R23
    02F5C 9230 0563 STS	Result+11,R3
    02F5E 9220 0562 STS	Result+10,R2
    02F60 9250 0565 STS	Result+13,R5
    02F62 9240 0564 STS	Result+12,R4
(0179) 				is_on=0; //切换到非检测状态
    02F64 2400      CLR	R0
    02F65 8608      STD	Y+8,R0
(0180) 				next_step_time=config.now+config.checkDeltaTime;//自动翻页时间更新
    02F66 9020 07D9 LDS	R2,config+17
    02F68 9030 07DA LDS	R3,config+18
    02F6A 2444      CLR	R4
    02F6B FC37      SBRC	R3,7
    02F6C 9440      COM	R4
    02F6D 2455      CLR	R5
    02F6E FC47      SBRC	R4,7
    02F6F 9450      COM	R5
    02F70 9080 07D6 LDS	R8,config+14
    02F72 9090 07D7 LDS	R9,config+15
    02F74 9060 07D4 LDS	R6,config+12
    02F76 9070 07D5 LDS	R7,config+13
    02F78 0C62      ADD	R6,R2
    02F79 1C73      ADC	R7,R3
    02F7A 1C84      ADC	R8,R4
    02F7B 1C95      ADC	R9,R5
    02F7C 826B      STD	Y+3,R6
    02F7D 827C      STD	Y+4,R7
    02F7E 828D      STD	Y+5,R8
    02F7F 829E      STD	Y+6,R9
(0181) 				page=0;
    02F80 820F      STD	Y+7,R0
(0182) 		   }
(0183) 		}
    02F81 C055      RJMP	0x2FD7
(0184) 		else { //is_on == 0 非检测状态 手动翻页/自动翻页
(0185) 		    _GUI_datashow(0,page); //不更新时间
    02F82 812F      LDD	R18,Y+7
    02F83 2700      CLR	R16
    02F84 D05A      RCALL	__GUI_datashow
(0186) 			//手动翻页 
(0187) 			if(key==up){ //上键 : 页面减 
    02F85 2D8C      MOV	R24,R12
    02F86 318E      CPI	R24,0x1E
    02F87 F469      BNE	0x2F95
(0188) 		        if(page>0) page--;
    02F88 E080      LDI	R24,0
    02F89 800F      LDD	R0,Y+7
    02F8A 1580      CP	R24,R0
    02F8B F418      BCC	0x2F8F
    02F8C 940A      DEC	R0
    02F8D 820F      STD	Y+7,R0
    02F8E C002      RJMP	0x2F91
(0189) 				else page =5;
    02F8F E085      LDI	R24,5
    02F90 838F      STD	Y+7,R24
(0190) 		    	LCD_CLR();
    02F91 940E 39B0 CALL	_LCD_CLR
(0191) 		    	LCD_Init();
    02F93 940E 397E CALL	_LCD_Init
(0192) 			}
(0193) 			if(key==down){ //下键 ： 页面加
    02F95 2D8C      MOV	R24,R12
    02F96 318D      CPI	R24,0x1D
    02F97 F469      BNE	0x2FA5
(0194) 		        if(page<5) 
    02F98 818F      LDD	R24,Y+7
    02F99 3085      CPI	R24,5
    02F9A F420      BCC	0x2F9F
(0195) 				    page++;
    02F9B 2E08      MOV	R0,R24
    02F9C 9403      INC	R0
    02F9D 820F      STD	Y+7,R0
    02F9E C002      RJMP	0x2FA1
(0196) 		  		else 
(0197) 				    page = 0;
    02F9F 2400      CLR	R0
    02FA0 820F      STD	Y+7,R0
(0198) 		    	LCD_CLR();
    02FA1 940E 39B0 CALL	_LCD_CLR
(0199) 		    	LCD_Init();
    02FA3 940E 397E CALL	_LCD_Init
(0200) 		    }
(0201) 			if( config.autocheck == 1){  //如果开启自动翻页
    02FA5 9180 07D8 LDS	R24,config+16
    02FA7 3081      CPI	R24,1
    02FA8 F571      BNE	0x2FD7
(0202) 			      if(config.now >= next_step_time )	{
    02FA9 802B      LDD	R2,Y+3
    02FAA 803C      LDD	R3,Y+4
    02FAB 804D      LDD	R4,Y+5
    02FAC 805E      LDD	R5,Y+6
    02FAD 9080 07D6 LDS	R8,config+14
    02FAF 9090 07D7 LDS	R9,config+15
    02FB1 9060 07D4 LDS	R6,config+12
    02FB3 9070 07D5 LDS	R7,config+13
    02FB5 1462      CP	R6,R2
    02FB6 0473      CPC	R7,R3
    02FB7 0484      CPC	R8,R4
    02FB8 0495      CPC	R9,R5
    02FB9 F0EC      BLT	0x2FD7
(0203) 				      next_step_time = config.now + config.checkDeltaTime;
    02FBA 9020 07D9 LDS	R2,config+17
    02FBC 9030 07DA LDS	R3,config+18
    02FBE 2444      CLR	R4
    02FBF FC37      SBRC	R3,7
    02FC0 9440      COM	R4
    02FC1 2455      CLR	R5
    02FC2 FC47      SBRC	R4,7
    02FC3 9450      COM	R5
    02FC4 0C62      ADD	R6,R2
    02FC5 1C73      ADC	R7,R3
    02FC6 1C84      ADC	R8,R4
    02FC7 1C95      ADC	R9,R5
    02FC8 826B      STD	Y+3,R6
    02FC9 827C      STD	Y+4,R7
    02FCA 828D      STD	Y+5,R8
    02FCB 829E      STD	Y+6,R9
(0204) 					  page++;
    02FCC 800F      LDD	R0,Y+7
    02FCD 9403      INC	R0
    02FCE 820F      STD	Y+7,R0
(0205) 					  if( page==6 ){
    02FCF 2D80      MOV	R24,R0
    02FD0 3086      CPI	R24,6
    02FD1 F429      BNE	0x2FD7
(0206) 					      //自动翻到最后页，页面清零开启下次检测
(0207) 					      page = 0;
    02FD2 2400      CLR	R0
    02FD3 820F      STD	Y+7,R0
(0208) 						  is_on = 1;
    02FD4 2400      CLR	R0
    02FD5 9403      INC	R0
    02FD6 8608      STD	Y+8,R0
(0209) 					  }    
(0210) 				  }  
(0211) 			}
(0212) 			 
(0213) 		} 
(0214) 	    delayms(10); 
    02FD7 E00A      LDI	R16,0xA
    02FD8 E010      LDI	R17,0
    02FD9 940E 2407 CALL	_delayms
    02FDB CEEF      RJMP	0x2ECB
    02FDC 9629      ADIW	R28,0x9
    02FDD 940C 409C JMP	pop_xgsetF0FC
__GUI_datashow:
  page                 --> R20
  clockfresh           --> R10
    02FDF 940E 40C6 CALL	push_xgsetF00C
    02FE1 2F42      MOV	R20,R18
    02FE2 2EA0      MOV	R10,R16
    02FE3 9722      SBIW	R28,2
(0215) 	}//end while
(0216) }//end function
(0217) void _GUI_datashow(unsigned char clockfresh,char page){
(0218) 	if( clockfresh ) dateRefresh(clockfresh); //时钟刷新
    02FE4 20AA      TST	R10
    02FE5 F011      BEQ	0x2FE8
    02FE6 2D0A      MOV	R16,R10
    02FE7 D5B7      RCALL	_dateRefresh
(0219) 	if(page == 0){
    02FE8 2344      TST	R20
    02FE9 F539      BNE	0x3011
(0220)  	//显示日期时间
(0221) 	    LCD_var_disp(1,1,GUI_get_date());
    02FEA D205      RCALL	_GUI_get_date
    02FEB 8319      STD	Y+1,R17
    02FEC 8308      ST	Y,R16
    02FED E021      LDI	R18,1
    02FEE E001      LDI	R16,1
    02FEF 940E 3937 CALL	_LCD_var_disp
(0222) 	//显示温度
(0223) 	 	LCD_const_disp(2,1,"温度 (℃):");
    02FF1 E880      LDI	R24,0x80
    02FF2 E094      LDI	R25,4
    02FF3 8399      STD	Y+1,R25
    02FF4 8388      ST	Y,R24
    02FF5 E021      LDI	R18,1
    02FF6 E002      LDI	R16,2
    02FF7 940E 390A CALL	_LCD_const_disp
(0224) 	 	LCD_var_disp(2,6,Result.TempChar);
    02FF9 E885      LDI	R24,0x85
    02FFA E095      LDI	R25,5
    02FFB 8399      STD	Y+1,R25
    02FFC 8388      ST	Y,R24
    02FFD E026      LDI	R18,6
    02FFE E002      LDI	R16,2
    02FFF 940E 3937 CALL	_LCD_var_disp
(0225) 	//显示风速
(0226) 	    LCD_const_disp(3,1,"风速(m/s): ");
    03001 E784      LDI	R24,0x74
    03002 E094      LDI	R25,4
    03003 8399      STD	Y+1,R25
    03004 8388      ST	Y,R24
    03005 E021      LDI	R18,1
    03006 E003      LDI	R16,3
    03007 940E 390A CALL	_LCD_const_disp
(0227) 	 	LCD_const_disp(3,6,Result.WSChar);
    03009 E88F      LDI	R24,0x8F
    0300A E095      LDI	R25,5
    0300B 8399      STD	Y+1,R25
    0300C 8388      ST	Y,R24
    0300D E026      LDI	R18,6
    0300E E003      LDI	R16,3
    0300F 940E 390A CALL	_LCD_const_disp
(0228) 
(0229) 	 } 
(0230) 	 if(page == 1){
    03011 3041      CPI	R20,1
    03012 F5B9      BNE	0x304A
(0231) 	     LCD_var_disp(1,1,GUI_get_date());
    03013 D1DC      RCALL	_GUI_get_date
    03014 8319      STD	Y+1,R17
    03015 8308      ST	Y,R16
    03016 E021      LDI	R18,1
    03017 E001      LDI	R16,1
    03018 940E 3937 CALL	_LCD_var_disp
(0232) 		 LCD_const_disp(2,1,"风冷指数: ");
    0301A E689      LDI	R24,0x69
    0301B E094      LDI	R25,4
    0301C 8399      STD	Y+1,R25
    0301D 8388      ST	Y,R24
    0301E E021      LDI	R18,1
    0301F E002      LDI	R16,2
    03020 940E 390A CALL	_LCD_const_disp
(0233) 		 LCD_var_disp(2,6,Result.WCIChar);						
    03022 E988      LDI	R24,0x98
    03023 E095      LDI	R25,5
    03024 8399      STD	Y+1,R25
    03025 8388      ST	Y,R24
    03026 E026      LDI	R18,6
    03027 E002      LDI	R16,2
    03028 940E 3937 CALL	_LCD_var_disp
(0234) 		 LCD_const_disp(3,1,"等价温度: ");
    0302A E58E      LDI	R24,0x5E
    0302B E094      LDI	R25,4
    0302C 8399      STD	Y+1,R25
    0302D 8388      ST	Y,R24
    0302E E021      LDI	R18,1
    0302F E003      LDI	R16,3
    03030 940E 390A CALL	_LCD_const_disp
(0235) 		 LCD_var_disp(3,6,Result.ECTChar);	 
    03032 EA82      LDI	R24,0xA2
    03033 E095      LDI	R25,5
    03034 8399      STD	Y+1,R25
    03035 8388      ST	Y,R24
    03036 E026      LDI	R18,6
    03037 E003      LDI	R16,3
    03038 940E 3937 CALL	_LCD_var_disp
(0236) 		 LCD_const_disp(4,1,"相当温度: ");
    0303A E583      LDI	R24,0x53
    0303B E094      LDI	R25,4
    0303C 8399      STD	Y+1,R25
    0303D 8388      ST	Y,R24
    0303E E021      LDI	R18,1
    0303F E004      LDI	R16,4
    03040 940E 390A CALL	_LCD_const_disp
(0237) 		 LCD_var_disp(4,6,Result.TeqChar);	
    03042 EA8C      LDI	R24,0xAC
    03043 E095      LDI	R25,5
    03044 8399      STD	Y+1,R25
    03045 8388      ST	Y,R24
    03046 E026      LDI	R18,6
    03047 E004      LDI	R16,4
    03048 940E 3937 CALL	_LCD_var_disp
(0238) 	 }
(0239) 	 if(page == 2){
    0304A 3042      CPI	R20,2
    0304B F009      BEQ	0x304D
    0304C C03F      RJMP	0x308C
(0240) 	     LCD_var_disp(1,1,GUI_get_date());
    0304D D1A2      RCALL	_GUI_get_date
    0304E 0158      MOVW	R10,R16
    0304F 82B9      STD	Y+1,R11
    03050 82A8      ST	Y,R10
    03051 E021      LDI	R18,1
    03052 E001      LDI	R16,1
    03053 940E 3937 CALL	_LCD_var_disp
(0241) 		 LCD_const_disp(2,1,"冻伤危害性:");
    03055 E487      LDI	R24,0x47
    03056 E094      LDI	R25,4
    03057 8399      STD	Y+1,R25
    03058 8388      ST	Y,R24
    03059 E021      LDI	R18,1
    0305A E002      LDI	R16,2
    0305B 940E 390A CALL	_LCD_const_disp
(0242) 	 if(Result.WeiHai==0){LCD_const_disp(3,1,"  冻伤危害性小");			 }
    0305D 9020 05B2 LDS	R2,Result+90
    0305F 2022      TST	R2
    03060 F449      BNE	0x306A
    03061 E388      LDI	R24,0x38
    03062 E094      LDI	R25,4
    03063 8399      STD	Y+1,R25
    03064 8388      ST	Y,R24
    03065 E021      LDI	R18,1
    03066 E003      LDI	R16,3
    03067 940E 390A CALL	_LCD_const_disp
    03069 C022      RJMP	0x308C
(0243) 	 else if(Result.WeiHai==1){	LCD_const_disp(3,1,"  冻伤危害性较大");	 }
    0306A 9180 05B2 LDS	R24,Result+90
    0306C 3081      CPI	R24,1
    0306D F449      BNE	0x3077
    0306E E287      LDI	R24,0x27
    0306F E094      LDI	R25,4
    03070 8399      STD	Y+1,R25
    03071 8388      ST	Y,R24
    03072 E021      LDI	R18,1
    03073 E003      LDI	R16,3
    03074 940E 390A CALL	_LCD_const_disp
    03076 C015      RJMP	0x308C
(0244) 	 else if(Result.WeiHai==2){	LCD_const_disp(3,1,"  冻伤危害性很大");	 }
    03077 9180 05B2 LDS	R24,Result+90
    03079 3082      CPI	R24,2
    0307A F449      BNE	0x3084
    0307B E186      LDI	R24,0x16
    0307C E094      LDI	R25,4
    0307D 8399      STD	Y+1,R25
    0307E 8388      ST	Y,R24
    0307F E021      LDI	R18,1
    03080 E003      LDI	R16,3
    03081 940E 390A CALL	_LCD_const_disp
    03083 C008      RJMP	0x308C
(0245) 	 else LCD_const_disp(3,1,"冻伤危害性小。");
    03084 E087      LDI	R24,7
    03085 E094      LDI	R25,4
    03086 8399      STD	Y+1,R25
    03087 8388      ST	Y,R24
    03088 E021      LDI	R18,1
    03089 E003      LDI	R16,3
    0308A 940E 390A CALL	_LCD_const_disp
(0246) 	 }	  
(0247) 	 if(page==3){
    0308C 3043      CPI	R20,3
    0308D F009      BEQ	0x308F
    0308E C061      RJMP	0x30F0
(0248) 	     LCD_const_disp(1,1,labelH);		
    0308F E682      LDI	R24,0x62
    03090 E092      LDI	R25,2
    03091 8399      STD	Y+1,R25
    03092 8388      ST	Y,R24
    03093 E021      LDI	R18,1
    03094 E001      LDI	R16,1
    03095 940E 390A CALL	_LCD_const_disp
(0249) 	 	 switch( Result.WeiHai ){
    03097 9160 05B2 LDS	R22,Result+90
    03099 2777      CLR	R23
    0309A 3060      CPI	R22,0
    0309B 0767      CPC	R22,R23
    0309C F049      BEQ	0x30A6
    0309D 3061      CPI	R22,1
    0309E E0E0      LDI	R30,0
    0309F 077E      CPC	R23,R30
    030A0 F0F1      BEQ	0x30BF
    030A1 3062      CPI	R22,2
    030A2 E0E0      LDI	R30,0
    030A3 077E      CPC	R23,R30
    030A4 F199      BEQ	0x30D8
    030A5 C04A      RJMP	0x30F0
(0250) 			case 0 :
(0251) 			LCD_const_disp(2,1,H01);
    030A6 E88E      LDI	R24,0x8E
    030A7 E092      LDI	R25,2
    030A8 8399      STD	Y+1,R25
    030A9 8388      ST	Y,R24
    030AA E021      LDI	R18,1
    030AB E002      LDI	R16,2
    030AC 940E 390A CALL	_LCD_const_disp
(0252) 			LCD_const_disp(3,1,H02);
    030AE E98E      LDI	R24,0x9E
    030AF E092      LDI	R25,2
    030B0 8399      STD	Y+1,R25
    030B1 8388      ST	Y,R24
    030B2 E021      LDI	R18,1
    030B3 E003      LDI	R16,3
    030B4 940E 390A CALL	_LCD_const_disp
(0253) 			LCD_const_disp(4,1,H03);
    030B6 EA89      LDI	R24,0xA9
    030B7 E092      LDI	R25,2
    030B8 8399      STD	Y+1,R25
    030B9 8388      ST	Y,R24
    030BA E021      LDI	R18,1
    030BB E004      LDI	R16,4
    030BC 940E 390A CALL	_LCD_const_disp
(0254) 			break;
    030BE C031      RJMP	0x30F0
(0255) 			case 1 : 
(0256) 			LCD_const_disp(2,1,H11);
    030BF EC85      LDI	R24,0xC5
    030C0 E092      LDI	R25,2
    030C1 8399      STD	Y+1,R25
    030C2 8388      ST	Y,R24
    030C3 E021      LDI	R18,1
    030C4 E002      LDI	R16,2
    030C5 940E 390A CALL	_LCD_const_disp
(0257) 			LCD_const_disp(3,1,H12);
    030C7 EA89      LDI	R24,0xA9
    030C8 E092      LDI	R25,2
    030C9 8399      STD	Y+1,R25
    030CA 8388      ST	Y,R24
    030CB E021      LDI	R18,1
    030CC E003      LDI	R16,3
    030CD 940E 390A CALL	_LCD_const_disp
(0258) 			LCD_const_disp(4,1,H13);
    030CF ED8E      LDI	R24,0xDE
    030D0 E092      LDI	R25,2
    030D1 8399      STD	Y+1,R25
    030D2 8388      ST	Y,R24
    030D3 E021      LDI	R18,1
    030D4 E004      LDI	R16,4
    030D5 940E 390A CALL	_LCD_const_disp
(0259) 			break ;	
    030D7 C018      RJMP	0x30F0
(0260) 			case 2 :
(0261) 			LCD_const_disp(2,1,H21);
    030D8 E182      LDI	R24,0x12
    030D9 E093      LDI	R25,3
    030DA 8399      STD	Y+1,R25
    030DB 8388      ST	Y,R24
    030DC E021      LDI	R18,1
    030DD E002      LDI	R16,2
    030DE 940E 390A CALL	_LCD_const_disp
(0262) 			LCD_const_disp(3,1,H22);
    030E0 E284      LDI	R24,0x24
    030E1 E093      LDI	R25,3
    030E2 8399      STD	Y+1,R25
    030E3 8388      ST	Y,R24
    030E4 E021      LDI	R18,1
    030E5 E003      LDI	R16,3
    030E6 940E 390A CALL	_LCD_const_disp
(0263) 			LCD_const_disp(4,1,H23);
    030E8 EA89      LDI	R24,0xA9
    030E9 E092      LDI	R25,2
    030EA 8399      STD	Y+1,R25
    030EB 8388      ST	Y,R24
    030EC E021      LDI	R18,1
    030ED E004      LDI	R16,4
    030EE 940E 390A CALL	_LCD_const_disp
(0264) 			break;
(0265) 			default : ;
(0266) 		}
(0267) 	 } 
(0268) 	 if(page==4){
    030F0 3044      CPI	R20,4
    030F1 F009      BEQ	0x30F3
    030F2 C086      RJMP	0x3179
(0269) 	 		LCD_const_disp(1,1,labelM);		
    030F3 E780      LDI	R24,0x70
    030F4 E092      LDI	R25,2
    030F5 8399      STD	Y+1,R25
    030F6 8388      ST	Y,R24
    030F7 E021      LDI	R18,1
    030F8 E001      LDI	R16,1
    030F9 940E 390A CALL	_LCD_const_disp
(0270) 	 		switch( Result.WeiHai ){
    030FB 9160 05B2 LDS	R22,Result+90
    030FD 2777      CLR	R23
    030FE 3060      CPI	R22,0
    030FF 0767      CPC	R22,R23
    03100 F059      BEQ	0x310C
    03101 3061      CPI	R22,1
    03102 E0E0      LDI	R30,0
    03103 077E      CPC	R23,R30
    03104 F409      BNE	0x3106
    03105 C052      RJMP	0x3158
    03106 3062      CPI	R22,2
    03107 E0E0      LDI	R30,0
    03108 077E      CPC	R23,R30
    03109 F409      BNE	0x310B
    0310A C066      RJMP	0x3171
    0310B C06D      RJMP	0x3179
(0271) 	 			case 0 :
(0272) 				LCD_const_disp(2,1,M01);
    0310C E88E      LDI	R24,0x8E
    0310D E092      LDI	R25,2
    0310E 8399      STD	Y+1,R25
    0310F 8388      ST	Y,R24
    03110 E021      LDI	R18,1
    03111 E002      LDI	R16,2
    03112 940E 390A CALL	_LCD_const_disp
(0273) 				LCD_const_disp(3,1,M02);
    03114 EA89      LDI	R24,0xA9
    03115 E092      LDI	R25,2
    03116 8399      STD	Y+1,R25
    03117 8388      ST	Y,R24
    03118 E021      LDI	R18,1
    03119 E003      LDI	R16,3
    0311A 940E 390A CALL	_LCD_const_disp
(0274) 				if(Result.Temperature < 17.7){
    0311C 9040 0583 LDS	R4,Result+43
    0311E 9050 0584 LDS	R5,Result+44
    03120 9020 0581 LDS	R2,Result+41
    03122 9030 0582 LDS	R3,Result+42
    03124 EC00      LDI	R16,0xC0
    03125 E010      LDI	R17,0
    03126 940E 402F CALL	elpm32
    03128 933A      ST	-Y,R19
    03129 932A      ST	-Y,R18
    0312A 931A      ST	-Y,R17
    0312B 930A      ST	-Y,R16
    0312C 0181      MOVW	R16,R2
    0312D 0192      MOVW	R18,R4
    0312E 940E 43CD CALL	fpcmp2
    03130 F44C      BGE	0x313A
(0275) 				    LCD_const_disp(4,1,"戴面罩；禁油彩。");
    03131 EF86      LDI	R24,0xF6
    03132 E093      LDI	R25,3
    03133 8399      STD	Y+1,R25
    03134 8388      ST	Y,R24
    03135 E021      LDI	R18,1
    03136 E004      LDI	R16,4
    03137 940E 390A CALL	_LCD_const_disp
(0276) 				}
    03139 C03F      RJMP	0x3179
(0277) 				else if(Result.Temperature < 12){
    0313A 9040 0583 LDS	R4,Result+43
    0313C 9050 0584 LDS	R5,Result+44
    0313E 9020 0581 LDS	R2,Result+41
    03140 9030 0582 LDS	R3,Result+42
    03142 EB0C      LDI	R16,0xBC
    03143 E010      LDI	R17,0
    03144 940E 402F CALL	elpm32
    03146 933A      ST	-Y,R19
    03147 932A      ST	-Y,R18
    03148 931A      ST	-Y,R17
    03149 930A      ST	-Y,R16
    0314A 0181      MOVW	R16,R2
    0314B 0192      MOVW	R18,R4
    0314C 940E 43CD CALL	fpcmp2
    0314E F554      BGE	0x3179
(0278) 				    LCD_const_disp(4,1,"禁油彩。        \0");
    0314F EE84      LDI	R24,0xE4
    03150 E093      LDI	R25,3
    03151 8399      STD	Y+1,R25
    03152 8388      ST	Y,R24
    03153 E021      LDI	R18,1
    03154 E004      LDI	R16,4
    03155 940E 390A CALL	_LCD_const_disp
(0279) 				}
(0280) 				break;
    03157 C021      RJMP	0x3179
(0281) 				case 1 : 
(0282) 			    LCD_const_disp(2,1,M11);
    03158 E88E      LDI	R24,0x8E
    03159 E092      LDI	R25,2
    0315A 8399      STD	Y+1,R25
    0315B 8388      ST	Y,R24
    0315C E021      LDI	R18,1
    0315D E002      LDI	R16,2
    0315E 940E 390A CALL	_LCD_const_disp
(0283) 				LCD_const_disp(3,1,M12);
    03160 EE8E      LDI	R24,0xEE
    03161 E092      LDI	R25,2
    03162 8399      STD	Y+1,R25
    03163 8388      ST	Y,R24
    03164 E021      LDI	R18,1
    03165 E003      LDI	R16,3
    03166 940E 390A CALL	_LCD_const_disp
(0284) 				LCD_const_disp(4,1,M13);
    03168 E080      LDI	R24,0
    03169 E093      LDI	R25,3
    0316A 8399      STD	Y+1,R25
    0316B 8388      ST	Y,R24
    0316C E021      LDI	R18,1
    0316D E004      LDI	R16,4
    0316E 940E 390A CALL	_LCD_const_disp
(0285) 				break ;
    03170 C008      RJMP	0x3179
(0286) 				case 2 :
(0287) 				LCD_const_disp(2,1,M21);
    03171 E386      LDI	R24,0x36
    03172 E093      LDI	R25,3
    03173 8399      STD	Y+1,R25
    03174 8388      ST	Y,R24
    03175 E021      LDI	R18,1
    03176 E002      LDI	R16,2
    03177 940E 390A CALL	_LCD_const_disp
(0288) 				break ;
(0289) 				default :;
(0290) 	 		}
(0291) 	 }
(0292) 	 if(page==5){
    03179 3045      CPI	R20,5
    0317A F009      BEQ	0x317C
    0317B C071      RJMP	0x31ED
(0293) 	     LCD_const_disp(1,1,labelL);		
    0317C E880      LDI	R24,0x80
    0317D E092      LDI	R25,2
    0317E 8399      STD	Y+1,R25
    0317F 8388      ST	Y,R24
    03180 E021      LDI	R18,1
    03181 E001      LDI	R16,1
    03182 940E 390A CALL	_LCD_const_disp
(0294) 	 	 switch( Result.WeiHai ){	
    03184 9140 05B2 LDS	R20,Result+90
    03186 2755      CLR	R21
    03187 3040      CPI	R20,0
    03188 0745      CPC	R20,R21
    03189 F059      BEQ	0x3195
    0318A 3041      CPI	R20,1
    0318B E0E0      LDI	R30,0
    0318C 075E      CPC	R21,R30
    0318D F409      BNE	0x318F
    0318E C03D      RJMP	0x31CC
    0318F 3042      CPI	R20,2
    03190 E0E0      LDI	R30,0
    03191 075E      CPC	R21,R30
    03192 F409      BNE	0x3194
    03193 C051      RJMP	0x31E5
    03194 C058      RJMP	0x31ED
(0295) 		     case 0 :
(0296) 			 LCD_const_disp(2,1,L01);
    03195 EB8B      LDI	R24,0xBB
    03196 E092      LDI	R25,2
    03197 8399      STD	Y+1,R25
    03198 8388      ST	Y,R24
    03199 E021      LDI	R18,1
    0319A E002      LDI	R16,2
    0319B 940E 390A CALL	_LCD_const_disp
(0297) 			 if(Result.Temperature < -12) {
    0319D 9040 0583 LDS	R4,Result+43
    0319F 9050 0584 LDS	R5,Result+44
    031A1 9020 0581 LDS	R2,Result+41
    031A3 9030 0582 LDS	R3,Result+42
    031A5 EB08      LDI	R16,0xB8
    031A6 E010      LDI	R17,0
    031A7 940E 402F CALL	elpm32
    031A9 933A      ST	-Y,R19
    031AA 932A      ST	-Y,R18
    031AB 931A      ST	-Y,R17
    031AC 930A      ST	-Y,R16
    031AD 0181      MOVW	R16,R2
    031AE 0192      MOVW	R18,R4
    031AF 940E 43CD CALL	fpcmp2
    031B1 F48C      BGE	0x31C3
(0298) 			 LCD_const_disp(3,1,L02);
    031B2 EC85      LDI	R24,0xC5
    031B3 E092      LDI	R25,2
    031B4 8399      STD	Y+1,R25
    031B5 8388      ST	Y,R24
    031B6 E021      LDI	R18,1
    031B7 E003      LDI	R16,3
    031B8 940E 390A CALL	_LCD_const_disp
(0299) 			 LCD_const_disp(4,1,L03);
    031BA EC8F      LDI	R24,0xCF
    031BB E092      LDI	R25,2
    031BC 8399      STD	Y+1,R25
    031BD 8388      ST	Y,R24
    031BE E021      LDI	R18,1
    031BF E004      LDI	R16,4
    031C0 940E 390A CALL	_LCD_const_disp
(0300) 			 } 
    031C2 C02A      RJMP	0x31ED
(0301) 			 else {
(0302) 			 LCD_const_disp(3,1,L03);
    031C3 EC8F      LDI	R24,0xCF
    031C4 E092      LDI	R25,2
    031C5 8399      STD	Y+1,R25
    031C6 8388      ST	Y,R24
    031C7 E021      LDI	R18,1
    031C8 E003      LDI	R16,3
    031C9 940E 390A CALL	_LCD_const_disp
(0303) 			 }
(0304) 			 break;
    031CB C021      RJMP	0x31ED
(0305) 			 case 1: 
(0306) 			 LCD_const_disp(2,1,L11);
    031CC E182      LDI	R24,0x12
    031CD E093      LDI	R25,3
    031CE 8399      STD	Y+1,R25
    031CF 8388      ST	Y,R24
    031D0 E021      LDI	R18,1
    031D1 E002      LDI	R16,2
    031D2 940E 390A CALL	_LCD_const_disp
(0307) 			 LCD_const_disp(3,1,L12);
    031D4 E284      LDI	R24,0x24
    031D5 E093      LDI	R25,3
    031D6 8399      STD	Y+1,R25
    031D7 8388      ST	Y,R24
    031D8 E021      LDI	R18,1
    031D9 E003      LDI	R16,3
    031DA 940E 390A CALL	_LCD_const_disp
(0308) 			 LCD_const_disp(3,1,L13);
    031DC EA89      LDI	R24,0xA9
    031DD E092      LDI	R25,2
    031DE 8399      STD	Y+1,R25
    031DF 8388      ST	Y,R24
    031E0 E021      LDI	R18,1
    031E1 E003      LDI	R16,3
    031E2 940E 390A CALL	_LCD_const_disp
(0309) 			 break ;
    031E4 C008      RJMP	0x31ED
(0310) 			 case 2 :
(0311) 			 LCD_const_disp(2,1,L21);
    031E5 E386      LDI	R24,0x36
    031E6 E093      LDI	R25,3
    031E7 8399      STD	Y+1,R25
    031E8 8388      ST	Y,R24
    031E9 E021      LDI	R18,1
    031EA E002      LDI	R16,2
    031EB 940E 390A CALL	_LCD_const_disp
(0312) 			 break;
(0313) 			 default : ;
(0314) 		} //end switch
(0315) 	}  //end if
    031ED 9622      ADIW	R28,2
    031EE 940C 40CD JMP	pop_xgsetF00C
(0316) }
(0317) char * GUI_get_date(void) {  
(0318)   //格式：2012年12月11日19:00:00
(0319)     GUI_date[0]=Result.Date[4]; 
_GUI_get_date:
    031F0 9020 0572 LDS	R2,Result+26
    031F2 9220 0345 STS	GUI_date,R2
(0320)     GUI_date[1]=Result.Date[5];
    031F4 9020 0573 LDS	R2,Result+27
    031F6 9220 0346 STS	GUI_date+1,R2
(0321)     GUI_date[4]=Result.Date[6];
    031F8 9020 0574 LDS	R2,Result+28
    031FA 9220 0349 STS	GUI_date+4,R2
(0322)     GUI_date[5]=Result.Date[7];
    031FC 9020 0575 LDS	R2,Result+29
    031FE 9220 034A STS	GUI_date+5,R2
(0323)     GUI_date[8]=Result.Time[0];
    03200 9020 0577 LDS	R2,Result+31
    03202 9220 034D STS	GUI_date+8,R2
(0324)     GUI_date[9]=Result.Time[1];
    03204 9020 0578 LDS	R2,Result+32
    03206 9220 034E STS	GUI_date+9,R2
(0325)     GUI_date[11]=Result.Time[4];
    03208 9020 057B LDS	R2,Result+35
    0320A 9220 0350 STS	GUI_date+11,R2
(0326)     GUI_date[12]=Result.Time[5];
    0320C 9020 057C LDS	R2,Result+36
    0320E 9220 0351 STS	GUI_date+12,R2
(0327)     GUI_date[14]=Result.Time[8];
    03210 9020 057F LDS	R2,Result+39
    03212 9220 0353 STS	GUI_date+14,R2
(0328)     GUI_date[15]=Result.Time[9];
    03214 9020 0580 LDS	R2,Result+40
    03216 9220 0354 STS	GUI_date+15,R2
(0329)     GUI_date[16]='\0';
    03218 2422      CLR	R2
    03219 9220 0355 STS	GUI_date+16,R2
(0330)     return GUI_date;
    0321B E405      LDI	R16,0x45
    0321C E013      LDI	R17,3
    0321D 9508      RET
_GUI_set_time:
  GUI_down             --> Y,+5
  GUI_up               --> Y,+2
  pT                   --> R14
  ary                  --> R12
  p                    --> Y,+10
  i                    --> R20
  keyc                 --> R22
  pD                   --> Y,+8
    0321E 940E 40A7 CALL	push_xgsetF0FC
    03220 972B      SBIW	R28,0xB
(0331) }
(0332) //设置时间 菜单 
(0333) void GUI_set_time(void){
(0334)     unsigned char p=2;
    03221 E082      LDI	R24,2
    03222 878A      STD	Y+10,R24
(0335) 	char GUI_up[]= "↑";
    03223 E586      LDI	R24,0x56
    03224 E093      LDI	R25,3
    03225 01FE      MOVW	R30,R28
    03226 9632      ADIW	R30,2
    03227 E003      LDI	R16,3
    03228 E010      LDI	R17,0
    03229 93FA      ST	-Y,R31
    0322A 93EA      ST	-Y,R30
    0322B 939A      ST	-Y,R25
    0322C 938A      ST	-Y,R24
    0322D 940E 414E CALL	asgnblk
(0336) 	char GUI_down[]= "↓";
    0322F E589      LDI	R24,0x59
    03230 E093      LDI	R25,3
    03231 01FE      MOVW	R30,R28
    03232 9635      ADIW	R30,5
    03233 E003      LDI	R16,3
    03234 E010      LDI	R17,0
    03235 93FA      ST	-Y,R31
    03236 93EA      ST	-Y,R30
    03237 939A      ST	-Y,R25
    03238 938A      ST	-Y,R24
    03239 940E 414E CALL	asgnblk
(0337) 	char *pD=NULL,*pT=NULL;
    0323B 2400      CLR	R0
    0323C 2411      CLR	R1
    0323D 8619      STD	Y+9,R1
    0323E 8608      STD	Y+8,R0
(0338) 	char *ary=GUI_up;
    0323F 01CE      MOVW	R24,R28
    03240 9602      ADIW	R24,2
    03241 016C      MOVW	R12,R24
(0339) 	unsigned char i=0,keyc=NO_KEY;
    03242 2744      CLR	R20
    03243 2766      CLR	R22
(0340) 	LCD_CLR(); //清屏
    03244 940E 39B0 CALL	_LCD_CLR
(0341) 	pD="2012年12月31日\0";
    03246 ED84      LDI	R24,0xD4
    03247 E093      LDI	R25,3
    03248 8799      STD	Y+9,R25
    03249 8788      STD	Y+8,R24
(0342) 	pT=Result.Time;
    0324A E787      LDI	R24,0x77
    0324B E095      LDI	R25,5
    0324C 017C      MOVW	R14,R24
(0343) 	LCD_const_disp(1,1,"时间设置:       ");
    0324D EC83      LDI	R24,0xC3
    0324E E093      LDI	R25,3
    0324F 8399      STD	Y+1,R25
    03250 8388      ST	Y,R24
    03251 E021      LDI	R18,1
    03252 E001      LDI	R16,1
    03253 940E 390A CALL	_LCD_const_disp
(0344) 	LCD_const_disp(4,7,"保存");
    03255 EB8E      LDI	R24,0xBE
    03256 E093      LDI	R25,3
    03257 8399      STD	Y+1,R25
    03258 8388      ST	Y,R24
    03259 E027      LDI	R18,7
    0325A E004      LDI	R16,4
    0325B 940E 390A CALL	_LCD_const_disp
(0345) 	LCD_var_disp(3,p,ary);
    0325D 82D9      STD	Y+1,R13
    0325E 82C8      ST	Y,R12
    0325F 852A      LDD	R18,Y+10
    03260 E003      LDI	R16,3
    03261 940E 3937 CALL	_LCD_var_disp
(0346) 	LCD_var_disp(2,1,pD);
    03263 8408      LDD	R0,Y+8
    03264 8419      LDD	R1,Y+9
    03265 8219      STD	Y+1,R1
    03266 8208      ST	Y,R0
    03267 E021      LDI	R18,1
    03268 E002      LDI	R16,2
    03269 940E 3937 CALL	_LCD_var_disp
(0347) 	LCD_var_disp(4,1,pT);
    0326B 82F9      STD	Y+1,R15
    0326C 82E8      ST	Y,R14
    0326D E021      LDI	R18,1
    0326E E004      LDI	R16,4
    0326F 940E 3937 CALL	_LCD_var_disp
(0348) 	delayms(250);
    03271 EF0A      LDI	R16,0xFA
    03272 E010      LDI	R17,0
    03273 940E 2407 CALL	_delayms
    03275 C1EC      RJMP	0x3462
(0349) 	while(1){
(0350) 	    keyc=kbscan();
    03276 940E 3EF9 CALL	_kbscan
    03278 2F60      MOV	R22,R16
(0351) 		pD[2]=Result.Date[2];
    03279 9020 0570 LDS	R2,Result+24
    0327B 85E8      LDD	R30,Y+8
    0327C 85F9      LDD	R31,Y+9
    0327D 8222      STD	Z+2,R2
(0352) 		pD[3]=Result.Date[3];
    0327E 9020 0571 LDS	R2,Result+25
    03280 8223      STD	Z+3,R2
(0353) 		pD[6]=Result.Date[4];
    03281 9020 0572 LDS	R2,Result+26
    03283 8226      STD	Z+6,R2
(0354) 		pD[7]=Result.Date[5];
    03284 9020 0573 LDS	R2,Result+27
    03286 8227      STD	Z+7,R2
(0355) 		pD[10]=Result.Date[6];
    03287 9020 0574 LDS	R2,Result+28
    03289 8622      STD	Z+10,R2
(0356) 		pD[11]=Result.Date[7];  
    0328A 9020 0575 LDS	R2,Result+29
    0328C 8623      STD	Z+11,R2
(0357) 
(0358) 		switch(i){
    0328D 2EA4      MOV	R10,R20
    0328E 24BB      CLR	R11
    0328F 20AA      TST	R10
    03290 F411      BNE	0x3293
    03291 20BB      TST	R11
    03292 F0D9      BEQ	0x32AE
    03293 01C5      MOVW	R24,R10
    03294 3081      CPI	R24,1
    03295 E0E0      LDI	R30,0
    03296 079E      CPC	R25,R30
    03297 F409      BNE	0x3299
    03298 C049      RJMP	0x32E2
    03299 3082      CPI	R24,2
    0329A E0E0      LDI	R30,0
    0329B 079E      CPC	R25,R30
    0329C F409      BNE	0x329E
    0329D C07D      RJMP	0x331B
    0329E 3083      CPI	R24,3
    0329F E0E0      LDI	R30,0
    032A0 079E      CPC	R25,R30
    032A1 F409      BNE	0x32A3
    032A2 C0C1      RJMP	0x3364
    032A3 3084      CPI	R24,4
    032A4 E0E0      LDI	R30,0
    032A5 079E      CPC	R25,R30
    032A6 F409      BNE	0x32A8
    032A7 C0F6      RJMP	0x339E
    032A8 3085      CPI	R24,5
    032A9 E0E0      LDI	R30,0
    032AA 079E      CPC	R25,R30
    032AB F409      BNE	0x32AD
    032AC C12A      RJMP	0x33D7
    032AD C165      RJMP	0x3413
(0359)             case 0: p=2;ary=GUI_up;  //年
    032AE E082      LDI	R24,2
    032AF 878A      STD	Y+10,R24
    032B0 01CE      MOVW	R24,R28
    032B1 9602      ADIW	R24,2
    032B2 016C      MOVW	R12,R24
(0360) 		 	  	 if(keyc==up){
    032B3 316E      CPI	R22,0x1E
    032B4 F491      BNE	0x32C7
(0361) 				     if(time_buf[1]<0x99){ 
    032B5 9180 04FD LDS	R24,time_buf+1
    032B7 3989      CPI	R24,0x99
    032B8 F008      BCS	0x32BA
    032B9 C159      RJMP	0x3413
(0362) 					     time_buf[1]++;
    032BA 5F8F      SUBI	R24,0xFF
    032BB 9380 04FD STS	time_buf+1,R24
(0363) 						 if((time_buf[1]&0x0f)==0x0a) 
    032BD 708F      ANDI	R24,0xF
    032BE 308A      CPI	R24,0xA
    032BF F009      BEQ	0x32C1
    032C0 C152      RJMP	0x3413
(0364) 						     time_buf[1]=time_buf[1]+6;
    032C1 9180 04FD LDS	R24,time_buf+1
    032C3 5F8A      SUBI	R24,0xFA
    032C4 9380 04FD STS	time_buf+1,R24
(0365) 					 }
(0366) 												     
(0367) 				}				  
    032C6 C14C      RJMP	0x3413
(0368)  					        
(0369) 			    else if(keyc==down){ 
    032C7 316D      CPI	R22,0x1D
    032C8 F4A1      BNE	0x32DD
(0370) 				    if(time_buf[1]>0x00){
    032C9 E080      LDI	R24,0
    032CA 9020 04FD LDS	R2,time_buf+1
    032CC 1582      CP	R24,R2
    032CD F008      BCS	0x32CF
    032CE C144      RJMP	0x3413
(0371) 				        time_buf[1]--;
    032CF 2D82      MOV	R24,R2
    032D0 5081      SUBI	R24,1
    032D1 9380 04FD STS	time_buf+1,R24
(0372) 						if((time_buf[1]&0x0f)==0x0f) 
    032D3 708F      ANDI	R24,0xF
    032D4 308F      CPI	R24,0xF
    032D5 F009      BEQ	0x32D7
    032D6 C13C      RJMP	0x3413
(0373) 						    time_buf[1]=time_buf[1]-6;
    032D7 9180 04FD LDS	R24,time_buf+1
    032D9 5086      SUBI	R24,6
    032DA 9380 04FD STS	time_buf+1,R24
(0374) 		 	  	 		 }
(0375) 												   
(0376) 					}			   		
    032DC C136      RJMP	0x3413
(0377) 				else if(keyc==right) {i=1;}
    032DD 3167      CPI	R22,0x17
    032DE F009      BEQ	0x32E0
    032DF C133      RJMP	0x3413
    032E0 E041      LDI	R20,1
(0378) 				break;
    032E1 C131      RJMP	0x3413
(0379) 		 case 1:p=4;ary=GUI_up;  //月
    032E2 E084      LDI	R24,4
    032E3 878A      STD	Y+10,R24
    032E4 01CE      MOVW	R24,R28
    032E5 9602      ADIW	R24,2
    032E6 016C      MOVW	R12,R24
(0380) 		  	  	if(keyc==up){
    032E7 316E      CPI	R22,0x1E
    032E8 F499      BNE	0x32FC
(0381) 				    if(time_buf[2]<0x12){  
    032E9 9180 04FE LDS	R24,time_buf+2
    032EB 3182      CPI	R24,0x12
    032EC F460      BCC	0x32F9
(0382) 					    time_buf[2]++;	
    032ED 5F8F      SUBI	R24,0xFF
    032EE 9380 04FE STS	time_buf+2,R24
(0383) 						if((time_buf[2]&0x0f)==0x0a) time_buf[2]+=6;
    032F0 708F      ANDI	R24,0xF
    032F1 308A      CPI	R24,0xA
    032F2 F449      BNE	0x32FC
    032F3 9180 04FE LDS	R24,time_buf+2
    032F5 5F8A      SUBI	R24,0xFA
    032F6 9380 04FE STS	time_buf+2,R24
(0384) 					}
    032F8 C003      RJMP	0x32FC
(0385) 					else 
(0386) 					    time_buf[2]=0x01;
    032F9 E081      LDI	R24,1
    032FA 9380 04FE STS	time_buf+2,R24
(0387) 				}						 
(0388) 				if(keyc==down){ 
    032FC 316D      CPI	R22,0x1D
    032FD F4A9      BNE	0x3313
(0389) 				    if(time_buf[2]>0x01){  
    032FE E081      LDI	R24,1
    032FF 9020 04FE LDS	R2,time_buf+2
    03301 1582      CP	R24,R2
    03302 F468      BCC	0x3310
(0390) 					    time_buf[2]--;	
    03303 2D82      MOV	R24,R2
    03304 5081      SUBI	R24,1
    03305 9380 04FE STS	time_buf+2,R24
(0391) 						if((time_buf[2]&0x0f)==0x0f) 
    03307 708F      ANDI	R24,0xF
    03308 308F      CPI	R24,0xF
    03309 F449      BNE	0x3313
(0392) 						    time_buf[2]-=6;
    0330A 9180 04FE LDS	R24,time_buf+2
    0330C 5086      SUBI	R24,6
    0330D 9380 04FE STS	time_buf+2,R24
(0393) 			  		}
    0330F C003      RJMP	0x3313
(0394) 				    else 
(0395) 					    time_buf[2]=0x12;						
    03310 E182      LDI	R24,0x12
    03311 9380 04FE STS	time_buf+2,R24
(0396) 				}						 							
(0397) 				if(keyc==left){
    03313 316B      CPI	R22,0x1B
    03314 F409      BNE	0x3316
(0398) 				    i=0;   
    03315 2744      CLR	R20
(0399) 				}									
(0400) 				if(keyc==right){
    03316 3167      CPI	R22,0x17
    03317 F009      BEQ	0x3319
    03318 C0FA      RJMP	0x3413
(0401) 				    i=2;   
    03319 E042      LDI	R20,2
(0402) 				}  
(0403) 				break;
    0331A C0F8      RJMP	0x3413
(0404) 	 	 case 2: p=6;ary=GUI_up;
    0331B E086      LDI	R24,6
    0331C 878A      STD	Y+10,R24
    0331D 01CE      MOVW	R24,R28
    0331E 9602      ADIW	R24,2
    0331F 016C      MOVW	R12,R24
(0405) 		 	  	 if(keyc==up){ 
    03320 316E      CPI	R22,0x1E
    03321 F519      BNE	0x3345
(0406) 				     if(time_buf[3]<0x31){ 
    03322 9180 04FF LDS	R24,time_buf+3
    03324 3381      CPI	R24,0x31
    03325 F5B0      BCC	0x335C
(0407) 				         time_buf[3]++;
    03326 5F8F      SUBI	R24,0xFF
    03327 9380 04FF STS	time_buf+3,R24
(0408) 						 if ((time_buf[3]&0x0f)==0x0a) time_buf[3]=time_buf[3]+6;
    03329 708F      ANDI	R24,0xF
    0332A 308A      CPI	R24,0xA
    0332B F429      BNE	0x3331
    0332C 9180 04FF LDS	R24,time_buf+3
    0332E 5F8A      SUBI	R24,0xFA
    0332F 9380 04FF STS	time_buf+3,R24
(0409) 						 if(  //2 4 6 9 11 月最大30天
(0410) 						  ( ((time_buf[2]==0x02) || (time_buf[2]==0x04)|| (time_buf[2]==0x06)||
    03331 9180 04FE LDS	R24,time_buf+2
    03333 3082      CPI	R24,2
    03334 F041      BEQ	0x333D
    03335 3084      CPI	R24,4
    03336 F031      BEQ	0x333D
    03337 3086      CPI	R24,6
    03338 F021      BEQ	0x333D
    03339 3089      CPI	R24,0x9
    0333A F011      BEQ	0x333D
    0333B 3181      CPI	R24,0x11
    0333C F4F9      BNE	0x335C
    0333D 9180 04FF LDS	R24,time_buf+3
    0333F 3381      CPI	R24,0x31
    03340 F4D9      BNE	0x335C
(0411) 						  (time_buf[2]==0x09)||(time_buf[2]==0x11))&&(time_buf[3]==0x31))){
(0412) 						      time_buf[3]=0x30;
    03341 E380      LDI	R24,0x30
    03342 9380 04FF STS	time_buf+3,R24
(0413) 						}
(0414) 				     }
(0415)  									  
(0416)  				 }
    03344 C017      RJMP	0x335C
(0417) 			     else if(keyc==down){ 
    03345 316D      CPI	R22,0x1D
    03346 F4A9      BNE	0x335C
(0418) 				      if(time_buf[3]>0x01){  
    03347 E081      LDI	R24,1
    03348 9020 04FF LDS	R2,time_buf+3
    0334A 1582      CP	R24,R2
    0334B F468      BCC	0x3359
(0419) 					     time_buf[3]--;
    0334C 2D82      MOV	R24,R2
    0334D 5081      SUBI	R24,1
    0334E 9380 04FF STS	time_buf+3,R24
(0420) 				 	  	 if((time_buf[3]&0x0f)==0x0f) time_buf[3]=time_buf[3]-6;
    03350 708F      ANDI	R24,0xF
    03351 308F      CPI	R24,0xF
    03352 F449      BNE	0x335C
    03353 9180 04FF LDS	R24,time_buf+3
    03355 5086      SUBI	R24,6
    03356 9380 04FF STS	time_buf+3,R24
(0421) 		 	  	 	 }
    03358 C003      RJMP	0x335C
(0422) 					 else time_buf[3]=0x31;						
    03359 E381      LDI	R24,0x31
    0335A 9380 04FF STS	time_buf+3,R24
(0423) 											   
(0424) 				}
(0425) 				if(keyc==left) {i=1;  }						 			   		
    0335C 316B      CPI	R22,0x1B
    0335D F409      BNE	0x335F
    0335E E041      LDI	R20,1
(0426) 				if(keyc==right) {i=3;    }  	
    0335F 3167      CPI	R22,0x17
    03360 F009      BEQ	0x3362
    03361 C0B1      RJMP	0x3413
    03362 E043      LDI	R20,3
(0427) 				break;
    03363 C0AF      RJMP	0x3413
(0428) 		case 3:p=1;ary=GUI_down;
    03364 2400      CLR	R0
    03365 9403      INC	R0
    03366 860A      STD	Y+10,R0
    03367 01CE      MOVW	R24,R28
    03368 9605      ADIW	R24,5
    03369 016C      MOVW	R12,R24
(0429)  	  	if(keyc==up){ if(time_buf[4]<0x23){  time_buf[4]++;	
    0336A 316E      CPI	R22,0x1E
    0336B F499      BNE	0x337F
    0336C 9180 0500 LDS	R24,time_buf+4
    0336E 3283      CPI	R24,0x23
    0336F F460      BCC	0x337C
    03370 5F8F      SUBI	R24,0xFF
    03371 9380 0500 STS	time_buf+4,R24
(0430) 													if((time_buf[4]&0x0f)==0x0a) time_buf[4]+=6;
    03373 708F      ANDI	R24,0xF
    03374 308A      CPI	R24,0xA
    03375 F449      BNE	0x337F
    03376 9180 0500 LDS	R24,time_buf+4
    03378 5F8A      SUBI	R24,0xFA
    03379 9380 0500 STS	time_buf+4,R24
(0431) 													 
(0432) 													
(0433) 												 }
    0337B C003      RJMP	0x337F
(0434) 							else time_buf[4]=0x00;
    0337C 2422      CLR	R2
    0337D 9220 0500 STS	time_buf+4,R2
(0435) 						  }						 
(0436) 				if(keyc==down){ if(time_buf[4]>0x00){  time_buf[4]--;	
    0337F 316D      CPI	R22,0x1D
    03380 F4A9      BNE	0x3396
    03381 E080      LDI	R24,0
    03382 9020 0500 LDS	R2,time_buf+4
    03384 1582      CP	R24,R2
    03385 F468      BCC	0x3393
    03386 2D82      MOV	R24,R2
    03387 5081      SUBI	R24,1
    03388 9380 0500 STS	time_buf+4,R24
(0437) 													if((time_buf[4]&0x0f)==0x0f) time_buf[4]-=6;
    0338A 708F      ANDI	R24,0xF
    0338B 308F      CPI	R24,0xF
    0338C F449      BNE	0x3396
    0338D 9180 0500 LDS	R24,time_buf+4
    0338F 5086      SUBI	R24,6
    03390 9380 0500 STS	time_buf+4,R24
(0438) 													
(0439) 												 }
    03392 C003      RJMP	0x3396
(0440) 							 else time_buf[4]=0x23;						
    03393 E283      LDI	R24,0x23
    03394 9380 0500 STS	time_buf+4,R24
(0441) 						  }	
(0442) 		if(keyc==left ) {i=2;   } 				  
    03396 316B      CPI	R22,0x1B
    03397 F409      BNE	0x3399
    03398 E042      LDI	R20,2
(0443) 		if(keyc==right) {i=4;    } 
    03399 3167      CPI	R22,0x17
    0339A F009      BEQ	0x339C
    0339B C077      RJMP	0x3413
    0339C E044      LDI	R20,4
(0444) 		break;						  					 			
    0339D C075      RJMP	0x3413
(0445)  case 4:p=3;ary=GUI_down;
    0339E E083      LDI	R24,3
    0339F 878A      STD	Y+10,R24
    033A0 01CE      MOVW	R24,R28
    033A1 9605      ADIW	R24,5
    033A2 016C      MOVW	R12,R24
(0446)  	  	if(keyc==up){ if(time_buf[5]<0x59){  time_buf[5]++;	
    033A3 316E      CPI	R22,0x1E
    033A4 F499      BNE	0x33B8
    033A5 9180 0501 LDS	R24,time_buf+5
    033A7 3589      CPI	R24,0x59
    033A8 F460      BCC	0x33B5
    033A9 5F8F      SUBI	R24,0xFF
    033AA 9380 0501 STS	time_buf+5,R24
(0447) 											 if((time_buf[5]&0x0f)==0x0a) time_buf[5]+=6;
    033AC 708F      ANDI	R24,0xF
    033AD 308A      CPI	R24,0xA
    033AE F449      BNE	0x33B8
    033AF 9180 0501 LDS	R24,time_buf+5
    033B1 5F8A      SUBI	R24,0xFA
    033B2 9380 0501 STS	time_buf+5,R24
(0448) 										  }
    033B4 C003      RJMP	0x33B8
(0449) 					  else time_buf[5]=0x00;
    033B5 2422      CLR	R2
    033B6 9220 0501 STS	time_buf+5,R2
(0450) 					}						 
(0451) 		if(keyc==down){ if(time_buf[5]>0x00){  time_buf[5]--;	
    033B8 316D      CPI	R22,0x1D
    033B9 F4A9      BNE	0x33CF
    033BA E080      LDI	R24,0
    033BB 9020 0501 LDS	R2,time_buf+5
    033BD 1582      CP	R24,R2
    033BE F468      BCC	0x33CC
    033BF 2D82      MOV	R24,R2
    033C0 5081      SUBI	R24,1
    033C1 9380 0501 STS	time_buf+5,R24
(0452) 												if((time_buf[5]&0x0f)==0x0f) time_buf[5]-=6;
    033C3 708F      ANDI	R24,0xF
    033C4 308F      CPI	R24,0xF
    033C5 F449      BNE	0x33CF
    033C6 9180 0501 LDS	R24,time_buf+5
    033C8 5086      SUBI	R24,6
    033C9 9380 0501 STS	time_buf+5,R24
(0453) 											}
    033CB C003      RJMP	0x33CF
(0454) 						else time_buf[5]=0x59;						
    033CC E589      LDI	R24,0x59
    033CD 9380 0501 STS	time_buf+5,R24
(0455) 					  }
(0456) 		if(keyc==left ) {i=3;    } 		  						 								  			
    033CF 316B      CPI	R22,0x1B
    033D0 F409      BNE	0x33D2
    033D1 E043      LDI	R20,3
(0457)  		if(keyc==right) {i=5;   }	
    033D2 3167      CPI	R22,0x17
    033D3 F009      BEQ	0x33D5
    033D4 C03E      RJMP	0x3413
    033D5 E045      LDI	R20,5
(0458) 		break;			   
    033D6 C03C      RJMP	0x3413
(0459)  case 5:p=5;ary=GUI_down;
    033D7 E085      LDI	R24,5
    033D8 878A      STD	Y+10,R24
    033D9 01CE      MOVW	R24,R28
    033DA 9605      ADIW	R24,5
    033DB 016C      MOVW	R12,R24
(0460)  	  	if(keyc==up){ if(time_buf[6]<0x59){  time_buf[6]++;	
    033DC 316E      CPI	R22,0x1E
    033DD F499      BNE	0x33F1
    033DE 9180 0502 LDS	R24,time_buf+6
    033E0 3589      CPI	R24,0x59
    033E1 F460      BCC	0x33EE
    033E2 5F8F      SUBI	R24,0xFF
    033E3 9380 0502 STS	time_buf+6,R24
(0461) 											 if((time_buf[6]&0x0f)==0x0a) time_buf[6]+=6;
    033E5 708F      ANDI	R24,0xF
    033E6 308A      CPI	R24,0xA
    033E7 F449      BNE	0x33F1
    033E8 9180 0502 LDS	R24,time_buf+6
    033EA 5F8A      SUBI	R24,0xFA
    033EB 9380 0502 STS	time_buf+6,R24
(0462) 										 }
    033ED C003      RJMP	0x33F1
(0463) 					  else time_buf[6]=0x00;
    033EE 2422      CLR	R2
    033EF 9220 0502 STS	time_buf+6,R2
(0464) 					}						 
(0465) 		if(keyc==down){ if(time_buf[6]>0x00){  time_buf[6]--;	
    033F1 316D      CPI	R22,0x1D
    033F2 F4A9      BNE	0x3408
    033F3 E080      LDI	R24,0
    033F4 9020 0502 LDS	R2,time_buf+6
    033F6 1582      CP	R24,R2
    033F7 F468      BCC	0x3405
    033F8 2D82      MOV	R24,R2
    033F9 5081      SUBI	R24,1
    033FA 9380 0502 STS	time_buf+6,R24
(0466) 						if((time_buf[6]&0x0f)==0x0f) time_buf[6]-=6;
    033FC 708F      ANDI	R24,0xF
    033FD 308F      CPI	R24,0xF
    033FE F449      BNE	0x3408
    033FF 9180 0502 LDS	R24,time_buf+6
    03401 5086      SUBI	R24,6
    03402 9380 0502 STS	time_buf+6,R24
(0467) 					  }
    03404 C003      RJMP	0x3408
(0468) 		else time_buf[6]=0x59;		}				
    03405 E589      LDI	R24,0x59
    03406 9380 0502 STS	time_buf+6,R24
(0469) 		if(keyc==left ) {i=4;    } 		  				 														   
    03408 316B      CPI	R22,0x1B
    03409 F409      BNE	0x340B
    0340A E044      LDI	R20,4
(0470) 		if(keyc==right) {i=6;p=1;ary=NULL;}  
    0340B 3167      CPI	R22,0x17
    0340C F431      BNE	0x3413
    0340D E046      LDI	R20,6
    0340E 2400      CLR	R0
    0340F 9403      INC	R0
    03410 860A      STD	Y+10,R0
    03411 24CC      CLR	R12
    03412 24DD      CLR	R13
(0471) 		break;           
(0472) 							 
(0473) 		 }//endcase
(0474)  		 dateRefresh(0);
    03413 2700      CLR	R16
    03414 D18A      RCALL	_dateRefresh
(0475) 		 
(0476) 		 LCD_const_disp(3,1,"                "); //清空箭头 
    03415 EA8D      LDI	R24,0xAD
    03416 E093      LDI	R25,3
    03417 8399      STD	Y+1,R25
    03418 8388      ST	Y,R24
    03419 E021      LDI	R18,1
    0341A E003      LDI	R16,3
    0341B 940E 390A CALL	_LCD_const_disp
(0477)  		 LCD_var_disp(3,p,ary); //显示箭头 
    0341D 82D9      STD	Y+1,R13
    0341E 82C8      ST	Y,R12
    0341F 852A      LDD	R18,Y+10
    03420 E003      LDI	R16,3
    03421 940E 3937 CALL	_LCD_var_disp
(0478)  		 LCD_var_disp(2,1,pD);  //显示日期
    03423 8408      LDD	R0,Y+8
    03424 8419      LDD	R1,Y+9
    03425 8219      STD	Y+1,R1
    03426 8208      ST	Y,R0
    03427 E021      LDI	R18,1
    03428 E002      LDI	R16,2
    03429 940E 3937 CALL	_LCD_var_disp
(0479)  		 LCD_var_disp(4,1,pT);  //显示时间
    0342B 82F9      STD	Y+1,R15
    0342C 82E8      ST	Y,R14
    0342D E021      LDI	R18,1
    0342E E004      LDI	R16,4
    0342F 940E 3937 CALL	_LCD_var_disp
(0480)  if(keyc==lright) {		  
    03431 3967      CPI	R22,0x97
    03432 F479      BNE	0x3442
(0481)  		  LCD_const_disp(3,1,"        放弃修改"); 
    03433 E98C      LDI	R24,0x9C
    03434 E093      LDI	R25,3
    03435 8399      STD	Y+1,R25
    03436 8388      ST	Y,R24
    03437 E021      LDI	R18,1
    03438 E003      LDI	R16,3
    03439 940E 390A CALL	_LCD_const_disp
(0482) 		  delayms(500);
    0343B EF04      LDI	R16,0xF4
    0343C E011      LDI	R17,1
    0343D 940E 2407 CALL	_delayms
(0483) 		  LCD_CLR(); //清屏
    0343F 940E 39B0 CALL	_LCD_CLR
(0484) 		  return ;} 
    03441 C021      RJMP	0x3463
(0485)  keyc=NO_KEY;
    03442 2766      CLR	R22
(0486)  if(i==6){    //各值改变完成后 显示已保存 清屏 返回
    03443 3046      CPI	R20,6
    03444 F4C9      BNE	0x345E
(0487) 		  ds1302_write_time(); 
    03445 940E 3EAC CALL	_ds1302_write_time
(0488)           LCD_const_disp(4,7,"    ");		  
    03447 E987      LDI	R24,0x97
    03448 E093      LDI	R25,3
    03449 8399      STD	Y+1,R25
    0344A 8388      ST	Y,R24
    0344B E027      LDI	R18,7
    0344C E004      LDI	R16,4
    0344D 940E 390A CALL	_LCD_const_disp
(0489) 		  LCD_const_disp(3,1,"          已保存"); 
    0344F E886      LDI	R24,0x86
    03450 E093      LDI	R25,3
    03451 8399      STD	Y+1,R25
    03452 8388      ST	Y,R24
    03453 E021      LDI	R18,1
    03454 E003      LDI	R16,3
    03455 940E 390A CALL	_LCD_const_disp
(0490) 		  delayms(300);
    03457 E20C      LDI	R16,0x2C
    03458 E011      LDI	R17,1
    03459 940E 2407 CALL	_delayms
(0491) 		  LCD_CLR(); //清屏
    0345B 940E 39B0 CALL	_LCD_CLR
(0492) 		  return ;
    0345D C005      RJMP	0x3463
(0493) 		  }
(0494)  delayms(2);	  
    0345E E002      LDI	R16,2
    0345F E010      LDI	R17,0
    03460 940E 2407 CALL	_delayms
    03462 CE13      RJMP	0x3276
    03463 962B      ADIW	R28,0xB
    03464 940C 409C JMP	pop_xgsetF0FC
_GUI_readback:
  index                --> Y,+3
  page                 --> R10
  key                  --> R14
  buf                  --> R12
    03466 940E 40A7 CALL	push_xgsetF0FC
    03468 0168      MOVW	R12,R16
    03469 9727      SBIW	R28,7
(0495) }//endwhile(1)
(0496) }
(0497) void GUI_readback(char *buf){
(0498)     char key=0;
    0346A 24EE      CLR	R14
(0499) 	char page=0;
    0346B 24AA      CLR	R10
(0500) 	long index=Result.Index;
    0346C 9040 0564 LDS	R4,Result+12
    0346E 9050 0565 LDS	R5,Result+13
    03470 9020 0562 LDS	R2,Result+10
    03472 9030 0563 LDS	R3,Result+11
    03474 822B      STD	Y+3,R2
    03475 823C      STD	Y+4,R3
    03476 824D      STD	Y+5,R4
    03477 825E      STD	Y+6,R5
(0501) 	LCD_CLR(); //清屏
    03478 940E 39B0 CALL	_LCD_CLR
(0502) 	LCD_const_disp(1,1,"菜单/ 检测");
    0347A EA8A      LDI	R24,0xAA
    0347B E094      LDI	R25,4
    0347C 8399      STD	Y+1,R25
    0347D 8388      ST	Y,R24
    0347E E021      LDI	R18,1
    0347F E001      LDI	R16,1
    03480 940E 390A CALL	_LCD_const_disp
(0503)     LCD_const_disp(2,3,"最后一次");		 
    03482 E78D      LDI	R24,0x7D
    03483 E093      LDI	R25,3
    03484 8399      STD	Y+1,R25
    03485 8388      ST	Y,R24
    03486 E023      LDI	R18,3
    03487 E002      LDI	R16,2
    03488 940E 390A CALL	_LCD_const_disp
(0504) 	LCD_const_disp(3,3,"按顺序");
    0348A E786      LDI	R24,0x76
    0348B E093      LDI	R25,3
    0348C 8399      STD	Y+1,R25
    0348D 8388      ST	Y,R24
    0348E E023      LDI	R18,3
    0348F E003      LDI	R16,3
    03490 940E 390A CALL	_LCD_const_disp
    03492 C061      RJMP	0x34F4
(0505) 	//<<菜单/检测/手（自）动>>
(0506) while(1){
(0507)  	key=kbscan();
    03493 940E 3EF9 CALL	_kbscan
    03495 2EE0      MOV	R14,R16
(0508) 	//上键短按 选择
(0509) 	if(key==up || key ==down){
    03496 2D8E      MOV	R24,R14
    03497 310E      CPI	R16,0x1E
    03498 F011      BEQ	0x349B
    03499 310D      CPI	R16,0x1D
    0349A F5E1      BNE	0x34D7
(0510) 	    if(config.readMode == 0){
    0349B 9020 07DB LDS	R2,config+19
    0349D 2022      TST	R2
    0349E F501      BNE	0x34BF
(0511) 		    config.readMode=1;
    0349F E081      LDI	R24,1
    034A0 9380 07DB STS	config+19,R24
(0512) 			Set_White(1,2,8,0);
    034A2 2422      CLR	R2
    034A3 822A      STD	Y+2,R2
    034A4 E088      LDI	R24,0x8
    034A5 8388      ST	Y,R24
    034A6 E022      LDI	R18,2
    034A7 E001      LDI	R16,1
    034A8 940E 3A3A CALL	_Set_White
(0513)  			Set_White(1,3,8,1);
    034AA E081      LDI	R24,1
    034AB 838A      STD	Y+2,R24
    034AC E088      LDI	R24,0x8
    034AD 8388      ST	Y,R24
    034AE E023      LDI	R18,3
    034AF E001      LDI	R16,1
    034B0 940E 3A3A CALL	_Set_White
(0514) 			index=Result.Index;	
    034B2 9040 0564 LDS	R4,Result+12
    034B4 9050 0565 LDS	R5,Result+13
    034B6 9020 0562 LDS	R2,Result+10
    034B8 9030 0563 LDS	R3,Result+11
    034BA 822B      STD	Y+3,R2
    034BB 823C      STD	Y+4,R3
    034BC 824D      STD	Y+5,R4
    034BD 825E      STD	Y+6,R5
(0515) 		}
    034BE C018      RJMP	0x34D7
(0516) 		else {
(0517) 		    config.readMode=0;
    034BF 2422      CLR	R2
    034C0 9220 07DB STS	config+19,R2
(0518) 			Set_White(1,2,8,1);
    034C2 E081      LDI	R24,1
    034C3 838A      STD	Y+2,R24
    034C4 E088      LDI	R24,0x8
    034C5 8388      ST	Y,R24
    034C6 E022      LDI	R18,2
    034C7 E001      LDI	R16,1
    034C8 940E 3A3A CALL	_Set_White
(0519)  			Set_White(1,3,8,0);
    034CA 2422      CLR	R2
    034CB 822A      STD	Y+2,R2
    034CC E088      LDI	R24,0x8
    034CD 8388      ST	Y,R24
    034CE E023      LDI	R18,3
    034CF E001      LDI	R16,1
    034D0 940E 3A3A CALL	_Set_White
(0520) 			index=0;
    034D2 E080      LDI	R24,0
    034D3 838B      STD	Y+3,R24
    034D4 838C      STD	Y+4,R24
    034D5 838D      STD	Y+5,R24
    034D6 838E      STD	Y+6,R24
(0521) 		}
(0522) 		
(0523) 	}
(0524) 	//左键短按  进入
(0525) 	if(key == left) {
    034D7 2D8E      MOV	R24,R14
    034D8 318B      CPI	R24,0x1B
    034D9 F4A9      BNE	0x34EF
(0526) 		Set_White(1,2,8,1);
    034DA E081      LDI	R24,1
    034DB 838A      STD	Y+2,R24
    034DC E088      LDI	R24,0x8
    034DD 8388      ST	Y,R24
    034DE E022      LDI	R18,2
    034DF E001      LDI	R16,1
    034E0 940E 3A3A CALL	_Set_White
(0527)  		Set_White(1,3,8,1);
    034E2 E081      LDI	R24,1
    034E3 838A      STD	Y+2,R24
    034E4 E088      LDI	R24,0x8
    034E5 8388      ST	Y,R24
    034E6 E023      LDI	R18,3
    034E7 E001      LDI	R16,1
    034E8 940E 3A3A CALL	_Set_White
(0528) 		delayms(100);
    034EA E604      LDI	R16,0x64
    034EB E010      LDI	R17,0
    034EC 940E 2407 CALL	_delayms
(0529) 		break ;		
    034EE C006      RJMP	0x34F5
(0530) 	}
(0531) 	//右键短按  返回
(0532) 	if(key == right) {
    034EF 2D8E      MOV	R24,R14
    034F0 3187      CPI	R24,0x17
    034F1 F409      BNE	0x34F3
(0533) 		return ;		
    034F2 C08C      RJMP	0x357F
(0534) 	}
(0535) 	key=0;
    034F3 24EE      CLR	R14
    034F4 CF9E      RJMP	0x3493
(0536) } //end of while
(0537) ReadSDFile(index,buf);
    034F5 0196      MOVW	R18,R12
    034F6 810B      LDD	R16,Y+3
    034F7 811C      LDD	R17,Y+4
    034F8 940E 265B CALL	_ReadSDFile
(0538) CharToStruct();
    034FA 940E 2A08 CALL	_CharToStruct
    034FC C081      RJMP	0x357E
(0539) while(1){
(0540) 	key=kbscan();
    034FD 940E 3EF9 CALL	_kbscan
    034FF 2EE0      MOV	R14,R16
(0541) 	if(key != 0) beep(0,1);
    03500 2300      TST	R16
    03501 F021      BEQ	0x3506
    03502 E021      LDI	R18,1
    03503 2700      CLR	R16
    03504 940E 3C85 CALL	_beep
(0542) 	_GUI_datashow(0,page);
    03506 2D2A      MOV	R18,R10
    03507 2700      CLR	R16
    03508 DAD6      RCALL	__GUI_datashow
(0543) 	if( key==left ){ //按left键下一条
    03509 2D8E      MOV	R24,R14
    0350A 318B      CPI	R24,0x1B
    0350B F541      BNE	0x3534
(0544) pre_item:
(0545) 		if(index < Result.Index){
    0350C 9040 0564 LDS	R4,Result+12
    0350E 9050 0565 LDS	R5,Result+13
    03510 9020 0562 LDS	R2,Result+10
    03512 9030 0563 LDS	R3,Result+11
    03514 806B      LDD	R6,Y+3
    03515 807C      LDD	R7,Y+4
    03516 808D      LDD	R8,Y+5
    03517 809E      LDD	R9,Y+6
    03518 1462      CP	R6,R2
    03519 0473      CPC	R7,R3
    0351A 0484      CPC	R8,R4
    0351B 0495      CPC	R9,R5
    0351C F4B0      BCC	0x3533
(0546) 		    index++;
    0351D E041      LDI	R20,1
    0351E E050      LDI	R21,0
    0351F E060      LDI	R22,0
    03520 E070      LDI	R23,0
    03521 0113      MOVW	R2,R6
    03522 0124      MOVW	R4,R8
    03523 0E24      ADD	R2,R20
    03524 1E35      ADC	R3,R21
    03525 1E46      ADC	R4,R22
    03526 1E57      ADC	R5,R23
    03527 822B      STD	Y+3,R2
    03528 823C      STD	Y+4,R3
    03529 824D      STD	Y+5,R4
    0352A 825E      STD	Y+6,R5
(0547) 			ReadSDFile(index,buf);
    0352B 0196      MOVW	R18,R12
    0352C 810B      LDD	R16,Y+3
    0352D 811C      LDD	R17,Y+4
    0352E 940E 265B CALL	_ReadSDFile
(0548) 			CharToStruct();
    03530 940E 2A08 CALL	_CharToStruct
(0549) 			page = 0;
    03532 24AA      CLR	R10
(0550) 		}
(0551) 		key=0;
    03533 24EE      CLR	R14
(0552) 	}
(0553) 	if( key==lleft ){ //长按按left键上一条
    03534 2D8E      MOV	R24,R14
    03535 398B      CPI	R24,0x9B
    03536 F511      BNE	0x3559
(0554) next_item:
(0555) 		if(index > 0){
    03537 E040      LDI	R20,0
    03538 E050      LDI	R21,0
    03539 E060      LDI	R22,0
    0353A E070      LDI	R23,0
    0353B 802B      LDD	R2,Y+3
    0353C 803C      LDD	R3,Y+4
    0353D 804D      LDD	R4,Y+5
    0353E 805E      LDD	R5,Y+6
    0353F 1542      CP	R20,R2
    03540 0553      CPC	R21,R3
    03541 0564      CPC	R22,R4
    03542 0575      CPC	R23,R5
    03543 F4A4      BGE	0x3558
(0556) 		    index--;
    03544 E041      LDI	R20,1
    03545 E050      LDI	R21,0
    03546 E060      LDI	R22,0
    03547 E070      LDI	R23,0
    03548 1A24      SUB	R2,R20
    03549 0A35      SBC	R3,R21
    0354A 0A46      SBC	R4,R22
    0354B 0A57      SBC	R5,R23
    0354C 822B      STD	Y+3,R2
    0354D 823C      STD	Y+4,R3
    0354E 824D      STD	Y+5,R4
    0354F 825E      STD	Y+6,R5
(0557) 			ReadSDFile(index,buf);
    03550 0196      MOVW	R18,R12
    03551 810B      LDD	R16,Y+3
    03552 811C      LDD	R17,Y+4
    03553 940E 265B CALL	_ReadSDFile
(0558) 			CharToStruct();
    03555 940E 2A08 CALL	_CharToStruct
(0559) 			page = 0;
    03557 24AA      CLR	R10
(0560) 		}
(0561) 		key=0;
    03558 24EE      CLR	R14
(0562) 	}
(0563) 	
(0564) 	if(key==up){ //上键 : 页面减 
    03559 2D8E      MOV	R24,R14
    0355A 318E      CPI	R24,0x1E
    0355B F449      BNE	0x3565
(0565) 	    if(page>0) page--;
    0355C E080      LDI	R24,0
    0355D 158A      CP	R24,R10
    0355E F008      BCS	0x3560
    0355F CFAC      RJMP	0x350C
    03560 94AA      DEC	R10
(0566) 	    else goto pre_item;
(0567) 		LCD_CLR();
    03561 940E 39B0 CALL	_LCD_CLR
(0568) 	    LCD_Init();
    03563 940E 397E CALL	_LCD_Init
(0569) 		
(0570) 	}
(0571) 	if(key==down){ //下键 ： 页面加
    03565 2D8E      MOV	R24,R14
    03566 318D      CPI	R24,0x1D
    03567 F441      BNE	0x3570
(0572) 	    if(page<5) page++;
    03568 2D8A      MOV	R24,R10
    03569 3085      CPI	R24,5
    0356A F660      BCC	0x3537
    0356B 94A3      INC	R10
(0573) 	  	else goto next_item;
(0574) 	    LCD_CLR();
    0356C 940E 39B0 CALL	_LCD_CLR
(0575) 	    LCD_Init();
    0356E 940E 397E CALL	_LCD_Init
(0576) 	}
(0577) 	if(key==right){	//右键 退出
    03570 2D8E      MOV	R24,R14
    03571 3187      CPI	R24,0x17
    03572 F439      BNE	0x357A
(0578) 	    beep(0,1); 
    03573 E021      LDI	R18,1
    03574 2700      CLR	R16
    03575 940E 3C85 CALL	_beep
(0579) 	 	LCD_CLR();
    03577 940E 39B0 CALL	_LCD_CLR
(0580) 	 	return ;
    03579 C005      RJMP	0x357F
(0581) 	}
(0582) 	
(0583)     delayms(30); 
    0357A E10E      LDI	R16,0x1E
    0357B E010      LDI	R17,0
    0357C 940E 2407 CALL	_delayms
    0357E CF7E      RJMP	0x34FD
    0357F 9627      ADIW	R28,7
    03580 940C 409C JMP	pop_xgsetF0FC
_GUI_welcome:
    03582 9722      SBIW	R28,2
(0584) }//end while
(0585) }
(0586) void GUI_welcome(void){
(0587)     LCD_CLR(); //清屏
    03583 940E 39B0 CALL	_LCD_CLR
(0588) 	LCD_const_disp(2,3,"欢迎使用");
    03585 E68D      LDI	R24,0x6D
    03586 E093      LDI	R25,3
    03587 8399      STD	Y+1,R25
    03588 8388      ST	Y,R24
    03589 E023      LDI	R18,3
    0358A E002      LDI	R16,2
    0358B 940E 390A CALL	_LCD_const_disp
(0589) 	LCD_const_disp(3,1,"环境冷强度检测仪");
    0358D E58C      LDI	R24,0x5C
    0358E E093      LDI	R25,3
    0358F 8399      STD	Y+1,R25
    03590 8388      ST	Y,R24
    03591 E021      LDI	R18,1
    03592 E003      LDI	R16,3
    03593 940E 390A CALL	_LCD_const_disp
(0590) 	delayms(800);
    03595 E200      LDI	R16,0x20
    03596 E013      LDI	R17,3
    03597 940E 2407 CALL	_delayms
(0591) 	beep(0,1);
    03599 E021      LDI	R18,1
    0359A 2700      CLR	R16
    0359B 940E 3C85 CALL	_beep
    0359D 9622      ADIW	R28,2
    0359E 9508      RET
_dateRefresh:
  readhardware         --> R20
    0359F 934A      ST	-Y,R20
    035A0 2F40      MOV	R20,R16
(0592) 	
(0593) }
(0594) 
(0595) ////////////////////////////////////
(0596) //  函数作用
(0597) //   将ds1302中缓存的时钟数据转换进结构体中
(0598) ////////////////////////////////////
(0599) void dateRefresh(unsigned char readhardware)
(0600) {	//readhardware = 0 not refresh, =1 refresh
(0601) 	ds1302_read_time();
    035A1 940E 3ED1 CALL	_ds1302_read_time
(0602) 	config.now =t.tm_hour*3600 + t.tm_min*60 + t.tm_sec; //更新系统心跳
    035A3 9120 07B8 LDS	R18,t+2
    035A5 9130 07B9 LDS	R19,t+3
    035A7 E30C      LDI	R16,0x3C
    035A8 E010      LDI	R17,0
    035A9 940E 4043 CALL	empy16s
    035AB 0118      MOVW	R2,R16
    035AC 9120 07BA LDS	R18,t+4
    035AE 9130 07BB LDS	R19,t+5
    035B0 E100      LDI	R16,0x10
    035B1 E01E      LDI	R17,0xE
    035B2 940E 4043 CALL	empy16s
    035B4 0128      MOVW	R4,R16
    035B5 0C42      ADD	R4,R2
    035B6 1C53      ADC	R5,R3
    035B7 9020 07B6 LDS	R2,t
    035B9 9030 07B7 LDS	R3,t+1
    035BB 0C42      ADD	R4,R2
    035BC 1C53      ADC	R5,R3
    035BD 0112      MOVW	R2,R4
    035BE 2444      CLR	R4
    035BF FC37      SBRC	R3,7
    035C0 9440      COM	R4
    035C1 2455      CLR	R5
    035C2 FC47      SBRC	R4,7
    035C3 9450      COM	R5
    035C4 9230 07D5 STS	config+13,R3
    035C6 9220 07D4 STS	config+12,R2
    035C8 9250 07D7 STS	config+15,R5
    035CA 9240 07D6 STS	config+14,R4
(0603) 	if( readhardware >=1 ){  
    035CC 3041      CPI	R20,1
    035CD F408      BCC	0x35CF
    035CE C11B      RJMP	0x36EA
(0604) 	t.tm_sec=(((time_buf[6]&0x70)>>4)*10)+(time_buf[6]&0x0f);
    035CF 9110 0502 LDS	R17,time_buf+6
    035D1 7710      ANDI	R17,0x70
    035D2 9512      SWAP	R17
    035D3 701F      ANDI	R17,0xF
    035D4 E00A      LDI	R16,0xA
    035D5 0301      MULSU	R16,R17
    035D6 0110      MOVW	R2,R0
    035D7 9180 0502 LDS	R24,time_buf+6
    035D9 2799      CLR	R25
    035DA 708F      ANDI	R24,0xF
    035DB 7090      ANDI	R25,0
    035DC 0E28      ADD	R2,R24
    035DD 1E39      ADC	R3,R25
    035DE 9230 07B7 STS	t+1,R3
    035E0 9220 07B6 STS	t,R2
(0605) 	t.tm_min=  (((time_buf[5]&0x70)>>4)*10)+(time_buf[5]&0x0f);
    035E2 9110 0501 LDS	R17,time_buf+5
    035E4 7710      ANDI	R17,0x70
    035E5 9512      SWAP	R17
    035E6 701F      ANDI	R17,0xF
    035E7 0301      MULSU	R16,R17
    035E8 0110      MOVW	R2,R0
    035E9 9180 0501 LDS	R24,time_buf+5
    035EB 2799      CLR	R25
    035EC 708F      ANDI	R24,0xF
    035ED 7090      ANDI	R25,0
    035EE 0E28      ADD	R2,R24
    035EF 1E39      ADC	R3,R25
    035F0 9230 07B9 STS	t+3,R3
    035F2 9220 07B8 STS	t+2,R2
(0606) 	t.tm_hour=  (((time_buf[4]&0x70)>>4)*10)+(time_buf[4]&0x0f);
    035F4 9110 0500 LDS	R17,time_buf+4
    035F6 7710      ANDI	R17,0x70
    035F7 9512      SWAP	R17
    035F8 701F      ANDI	R17,0xF
    035F9 0301      MULSU	R16,R17
    035FA 0110      MOVW	R2,R0
    035FB 9180 0500 LDS	R24,time_buf+4
    035FD 2799      CLR	R25
    035FE 708F      ANDI	R24,0xF
    035FF 7090      ANDI	R25,0
    03600 0E28      ADD	R2,R24
    03601 1E39      ADC	R3,R25
    03602 9230 07BB STS	t+5,R3
    03604 9220 07BA STS	t+4,R2
(0607) 	t.tm_mday=	(((time_buf[3]&0x70)>>4)*10)+(time_buf[3]&0x0f);
    03606 9110 04FF LDS	R17,time_buf+3
    03608 7710      ANDI	R17,0x70
    03609 9512      SWAP	R17
    0360A 701F      ANDI	R17,0xF
    0360B 0301      MULSU	R16,R17
    0360C 0110      MOVW	R2,R0
    0360D 9180 04FF LDS	R24,time_buf+3
    0360F 2799      CLR	R25
    03610 708F      ANDI	R24,0xF
    03611 7090      ANDI	R25,0
    03612 0E28      ADD	R2,R24
    03613 1E39      ADC	R3,R25
    03614 9230 07BD STS	t+7,R3
    03616 9220 07BC STS	t+6,R2
(0608) 	t.tm_mon= (((time_buf[2]&0x70)>>4)*10)+(time_buf[2]&0x0f);
    03618 9110 04FE LDS	R17,time_buf+2
    0361A 7710      ANDI	R17,0x70
    0361B 9512      SWAP	R17
    0361C 701F      ANDI	R17,0xF
    0361D 0301      MULSU	R16,R17
    0361E 0110      MOVW	R2,R0
    0361F 9180 04FE LDS	R24,time_buf+2
    03621 2799      CLR	R25
    03622 708F      ANDI	R24,0xF
    03623 7090      ANDI	R25,0
    03624 0E28      ADD	R2,R24
    03625 1E39      ADC	R3,R25
    03626 9230 07BF STS	t+9,R3
    03628 9220 07BE STS	t+8,R2
(0609) 	t.tm_wday=	(time_buf[7]&0x0f);
    0362A 9180 0503 LDS	R24,time_buf+7
    0362C 2799      CLR	R25
    0362D 708F      ANDI	R24,0xF
    0362E 7090      ANDI	R25,0
    0362F 9390 07C3 STS	t+13,R25
    03631 9380 07C2 STS	t+12,R24
(0610)     t.tm_year=	(((time_buf[1]&0x70)>>4)*10)+(time_buf[1]&0x0f);
    03633 9110 04FD LDS	R17,time_buf+1
    03635 7710      ANDI	R17,0x70
    03636 9512      SWAP	R17
    03637 701F      ANDI	R17,0xF
    03638 0301      MULSU	R16,R17
    03639 0110      MOVW	R2,R0
    0363A 9180 04FD LDS	R24,time_buf+1
    0363C 2799      CLR	R25
    0363D 708F      ANDI	R24,0xF
    0363E 7090      ANDI	R25,0
    0363F 0E28      ADD	R2,R24
    03640 1E39      ADC	R3,R25
    03641 9230 07C1 STS	t+11,R3
    03643 9220 07C0 STS	t+10,R2
(0611) 	Result.Date[0]='2';
    03645 E382      LDI	R24,0x32
    03646 9380 056E STS	Result+22,R24
(0612) 	Result.Date[1]='0';
    03648 E380      LDI	R24,0x30
    03649 9380 056F STS	Result+23,R24
(0613) 	Result.Date[2]=t.tm_year/10+'0';
    0364B E02A      LDI	R18,0xA
    0364C E030      LDI	R19,0
    0364D 0181      MOVW	R16,R2
    0364E 940E 3F77 CALL	div16s
    03650 01C8      MOVW	R24,R16
    03651 96C0      ADIW	R24,0x30
    03652 9380 0570 STS	Result+24,R24
(0614) 	Result.Date[3]=t.tm_year%10+'0';
    03654 E02A      LDI	R18,0xA
    03655 E030      LDI	R19,0
    03656 9100 07C0 LDS	R16,t+10
    03658 9110 07C1 LDS	R17,t+11
    0365A 940E 3F73 CALL	mod16s
    0365C 01C8      MOVW	R24,R16
    0365D 96C0      ADIW	R24,0x30
    0365E 9380 0571 STS	Result+25,R24
(0615) 	Result.Date[4]=t.tm_mon/10+'0';
    03660 E02A      LDI	R18,0xA
    03661 E030      LDI	R19,0
    03662 9100 07BE LDS	R16,t+8
    03664 9110 07BF LDS	R17,t+9
    03666 940E 3F77 CALL	div16s
    03668 01C8      MOVW	R24,R16
    03669 96C0      ADIW	R24,0x30
    0366A 9380 0572 STS	Result+26,R24
(0616) 	Result.Date[5]=t.tm_mon%10+'0';
    0366C E02A      LDI	R18,0xA
    0366D E030      LDI	R19,0
    0366E 9100 07BE LDS	R16,t+8
    03670 9110 07BF LDS	R17,t+9
    03672 940E 3F73 CALL	mod16s
    03674 01C8      MOVW	R24,R16
    03675 96C0      ADIW	R24,0x30
    03676 9380 0573 STS	Result+27,R24
(0617) 	Result.Date[6]=t.tm_mday/10+'0';
    03678 E02A      LDI	R18,0xA
    03679 E030      LDI	R19,0
    0367A 9100 07BC LDS	R16,t+6
    0367C 9110 07BD LDS	R17,t+7
    0367E 940E 3F77 CALL	div16s
    03680 01C8      MOVW	R24,R16
    03681 96C0      ADIW	R24,0x30
    03682 9380 0574 STS	Result+28,R24
(0618) 	Result.Date[7]=t.tm_mday%10+'0';
    03684 E02A      LDI	R18,0xA
    03685 E030      LDI	R19,0
    03686 9100 07BC LDS	R16,t+6
    03688 9110 07BD LDS	R17,t+7
    0368A 940E 3F73 CALL	mod16s
    0368C 01C8      MOVW	R24,R16
    0368D 96C0      ADIW	R24,0x30
    0368E 9380 0575 STS	Result+29,R24
(0619)     Result.Date[8]='\0';
    03690 2422      CLR	R2
    03691 9220 0576 STS	Result+30,R2
(0620) 	Result.Time[0]=t.tm_hour/10+'0';
    03693 E02A      LDI	R18,0xA
    03694 E030      LDI	R19,0
    03695 9100 07BA LDS	R16,t+4
    03697 9110 07BB LDS	R17,t+5
    03699 940E 3F77 CALL	div16s
    0369B 01C8      MOVW	R24,R16
    0369C 96C0      ADIW	R24,0x30
    0369D 9380 0577 STS	Result+31,R24
(0621) 	Result.Time[1]=t.tm_hour%10+'0';
    0369F E02A      LDI	R18,0xA
    036A0 E030      LDI	R19,0
    036A1 9100 07BA LDS	R16,t+4
    036A3 9110 07BB LDS	R17,t+5
    036A5 940E 3F73 CALL	mod16s
    036A7 01C8      MOVW	R24,R16
    036A8 96C0      ADIW	R24,0x30
    036A9 9380 0578 STS	Result+32,R24
(0622) 	Result.Time[2]=':';
    036AB E38A      LDI	R24,0x3A
    036AC 9380 0579 STS	Result+33,R24
(0623) 	Result.Time[3]=' ';
    036AE E280      LDI	R24,0x20
    036AF 9380 057A STS	Result+34,R24
(0624) 	Result.Time[4]=t.tm_min/10+'0';
    036B1 E02A      LDI	R18,0xA
    036B2 E030      LDI	R19,0
    036B3 9100 07B8 LDS	R16,t+2
    036B5 9110 07B9 LDS	R17,t+3
    036B7 940E 3F77 CALL	div16s
    036B9 01C8      MOVW	R24,R16
    036BA 96C0      ADIW	R24,0x30
    036BB 9380 057B STS	Result+35,R24
(0625) 	Result.Time[5]=t.tm_min%10+'0';
    036BD E02A      LDI	R18,0xA
    036BE E030      LDI	R19,0
    036BF 9100 07B8 LDS	R16,t+2
    036C1 9110 07B9 LDS	R17,t+3
    036C3 940E 3F73 CALL	mod16s
    036C5 01C8      MOVW	R24,R16
    036C6 96C0      ADIW	R24,0x30
    036C7 9380 057C STS	Result+36,R24
(0626) 	Result.Time[6]=':';
    036C9 E38A      LDI	R24,0x3A
    036CA 9380 057D STS	Result+37,R24
(0627) 	Result.Time[7]=' ';
    036CC E280      LDI	R24,0x20
    036CD 9380 057E STS	Result+38,R24
(0628) 	Result.Time[8]=t.tm_sec/10+'0';
    036CF E02A      LDI	R18,0xA
    036D0 E030      LDI	R19,0
    036D1 9100 07B6 LDS	R16,t
    036D3 9110 07B7 LDS	R17,t+1
    036D5 940E 3F77 CALL	div16s
    036D7 01C8      MOVW	R24,R16
    036D8 96C0      ADIW	R24,0x30
    036D9 9380 057F STS	Result+39,R24
(0629) 	Result.Time[9]=t.tm_sec%10+'0';
    036DB E02A      LDI	R18,0xA
    036DC E030      LDI	R19,0
    036DD 9100 07B6 LDS	R16,t
    036DF 9110 07B7 LDS	R17,t+1
    036E1 940E 3F73 CALL	mod16s
    036E3 01C8      MOVW	R24,R16
    036E4 96C0      ADIW	R24,0x30
    036E5 9380 0580 STS	Result+40,R24
(0630) 	Result.Time[10]='\0'; 
    036E7 2422      CLR	R2
    036E8 9220 0581 STS	Result+41,R2
(0631) 	}
    036EA 9149      LD	R20,Y+
    036EB 9508      RET
FILE: D:\LQD\software\master\software_src\usart.c
(0001) #include "config.h"
(0002) 
(0003) 
(0004) #define fosc 7372800UL //晶振7.3728MHZ
(0005) #define baud 38400  //波特率
(0006) //串口通信初始化  MEGA128
(0007) //UART1 initialize
(0008) // desired baud rate:38400
(0009) // actual baud rate:38400 (0.0%)
(0010) // char size: 8 bit
(0011) // parity: Disabled
(0012) void uart1_init(void)
(0013) {
(0014)  	 UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    036EC 2422      CLR	R2
    036ED 9220 009A STS	0x9A,R2
(0015)      UCSR1A = 0x00;
    036EF 9220 009B STS	0x9B,R2
(0016)      UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//8bit+1bit stop
    036F1 E086      LDI	R24,6
    036F2 9380 009D STS	0x9D,R24
(0017)      UBRR1L=(fosc/16/(baud+1))%256;
    036F4 E08B      LDI	R24,0xB
    036F5 9380 0099 STS	0x99,R24
(0018)      UBRR1H=(fosc/16/(baud+1))/256;
    036F7 9220 0098 STS	0x98,R2
(0019)      UCSR1B =(1<<RXEN1)|(1<<TXEN1);//RXCEN TXCEN
    036F9 E188      LDI	R24,0x18
    036FA 9380 009A STS	0x9A,R24
    036FC 9508      RET
_uart1_rx_isr:
  tmp                  --> R16
    036FD 930A      ST	-Y,R16
    036FE B70F      IN	R16,0x3F
    036FF 930A      ST	-Y,R16
(0020) }
(0021) 
(0022) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0023) void uart1_rx_isr(void){   
(0024) 	 char tmp;
(0025) 	 tmp=UDR1;
    03700 9100 009C LDS	R16,0x9C
    03702 9109      LD	R16,Y+
    03703 BF0F      OUT	0x3F,R16
    03704 9109      LD	R16,Y+
    03705 9518      RETI
(0026) }
(0027) 
(0028) void Usart_Transmit(char c)
(0029) {
(0030)  	 while (!(UCSR1A&(1<<UDRE1)));//表明发送器一准备就绪
_Usart_Transmit:
  c                    --> R16
    03706 9020 009B LDS	R2,0x9B
    03708 FE25      SBRS	R2,5
    03709 CFFC      RJMP	_Usart_Transmit
(0031) 	 UDR1=c;
    0370A 9300 009C STS	0x9C,R16
    0370C 9508      RET
_Puts:
  s                    --> R20
    0370D 934A      ST	-Y,R20
    0370E 935A      ST	-Y,R21
    0370F 01A8      MOVW	R20,R16
(0032) }
(0033) 
(0034) //串口输出字符串
(0035) void Puts( unsigned char *s)
(0036) { 
    03710 C00B      RJMP	0x371C
(0037) 	 while (*s) 
(0038)       { 
(0039) 	  //为数据间的隔断创造一个串口能显示的隔断字符 即'/t'  ->  ' '
(0040) 	  if(*s==0x09)  
    03711 01FA      MOVW	R30,R20
    03712 8180      LD	R24,Z
    03713 3089      CPI	R24,0x9
    03714 F411      BNE	0x3717
(0041) 	  {   Usart_Transmit(' ');    }
    03715 E200      LDI	R16,0x20
    03716 DFEF      RCALL	_Usart_Transmit
(0042) 	 Usart_Transmit(*s);
    03717 01FA      MOVW	R30,R20
    03718 8100      LD	R16,Z
    03719 DFEC      RCALL	_Usart_Transmit
(0043) 	 s++;
    0371A 5F4F      SUBI	R20,0xFF
    0371B 4F5F      SBCI	R21,0xFF
    0371C 01FA      MOVW	R30,R20
    0371D 8020      LD	R2,Z
    0371E 2022      TST	R2
    0371F F789      BNE	0x3711
    03720 9159      LD	R21,Y+
    03721 9149      LD	R20,Y+
    03722 9508      RET
_Send_nByte:
  i                    --> R20
  len                  --> R10
  p                    --> R12
    03723 940E 40D4 CALL	push_xgset303C
    03725 2EA2      MOV	R10,R18
    03726 0168      MOVW	R12,R16
(0044) 	
(0045) 	
(0046)       }
(0047) }
(0048) 
(0049) 
(0050) 
(0051) void Send_nByte(unsigned char *p, unsigned char len)
(0052) { 
(0053)   int i = 0;
(0054)   for(i=0;i<len;i++)
    03727 2744      CLR	R20
    03728 2755      CLR	R21
    03729 C007      RJMP	0x3731
(0055)   {
(0056)    	Usart_Transmit(*(p+i));
    0372A 01FA      MOVW	R30,R20
    0372B 0DEC      ADD	R30,R12
    0372C 1DFD      ADC	R31,R13
    0372D 8100      LD	R16,Z
    0372E DFD7      RCALL	_Usart_Transmit
    0372F 5F4F      SUBI	R20,0xFF
    03730 4F5F      SBCI	R21,0xFF
    03731 2C2A      MOV	R2,R10
    03732 2433      CLR	R3
    03733 1542      CP	R20,R2
    03734 0553      CPC	R21,R3
    03735 F3A4      BLT	0x372A
    03736 940C 40DB JMP	pop_xgset303C
_PrintString:
  str                  --> R10
    03738 92AA      ST	-Y,R10
    03739 92BA      ST	-Y,R11
    0373A 0158      MOVW	R10,R16
(0057)   }
(0058) }
(0059) 
(0060) void  PrintString(const unsigned char *str)
(0061) {    
    0373B C004      RJMP	0x3740
(0062) 	while(*str!=0)	Usart_Transmit(*str++);
    0373C 01F5      MOVW	R30,R10
    0373D 9101      LD	R16,Z+
    0373E 015F      MOVW	R10,R30
    0373F DFC6      RCALL	_Usart_Transmit
    03740 01F5      MOVW	R30,R10
    03741 8020      LD	R2,Z
    03742 2022      TST	R2
    03743 F7C1      BNE	0x373C
    03744 90B9      LD	R11,Y+
    03745 90A9      LD	R10,Y+
    03746 9508      RET
_PrintString_n:
  str                  --> R10
    03747 92AA      ST	-Y,R10
    03748 92BA      ST	-Y,R11
    03749 0158      MOVW	R10,R16
(0063) }
(0064) void  PrintString_n(const unsigned char *str)
(0065) {   
(0066) 	Usart_Transmit('\r');
    0374A E00D      LDI	R16,0xD
    0374B DFBA      RCALL	_Usart_Transmit
(0067) 	Usart_Transmit('\n'); 
    0374C E00A      LDI	R16,0xA
    0374D DFB8      RCALL	_Usart_Transmit
    0374E C004      RJMP	0x3753
(0068) 	while(*str!=0)	Usart_Transmit(*str++);
    0374F 01F5      MOVW	R30,R10
    03750 9101      LD	R16,Z+
    03751 015F      MOVW	R10,R30
    03752 DFB3      RCALL	_Usart_Transmit
    03753 01F5      MOVW	R30,R10
    03754 8020      LD	R2,Z
    03755 2022      TST	R2
    03756 F7C1      BNE	0x374F
    03757 90B9      LD	R11,Y+
    03758 90A9      LD	R10,Y+
    03759 9508      RET
_PrintLong:
  i                    --> R20
  da                   --> Y,+0
  data                 --> Y,+9
    0375A 940E 3F62 CALL	push_arg4
    0375C 934A      ST	-Y,R20
    0375D 9728      SBIW	R28,0x8
(0069) 
(0070) } 
(0071)  
(0072) void PrintLong(unsigned long data)
(0073) {
(0074)  
(0075) 	unsigned char da[8];
(0076) 	unsigned char i;
(0077) 	for(i=0;i<8;i++)	da[i]=0;
    0375E 2744      CLR	R20
    0375F C008      RJMP	0x3768
    03760 01CE      MOVW	R24,R28
    03761 2FE4      MOV	R30,R20
    03762 27FF      CLR	R31
    03763 0FE8      ADD	R30,R24
    03764 1FF9      ADC	R31,R25
    03765 2422      CLR	R2
    03766 8220      ST	Z,R2
    03767 9543      INC	R20
    03768 3048      CPI	R20,0x8
    03769 F3B0      BCS	0x3760
    0376A C013      RJMP	0x377E
(0078) 	while(data>=10000000L){ ++da[7];data-=10000000L;}
    0376B 818F      LDD	R24,Y+7
    0376C 5F8F      SUBI	R24,0xFF
    0376D 838F      STD	Y+7,R24
    0376E E880      LDI	R24,0x80
    0376F E996      LDI	R25,0x96
    03770 E9A8      LDI	R26,0x98
    03771 E0B0      LDI	R27,0
    03772 8429      LDD	R2,Y+9
    03773 843A      LDD	R3,Y+10
    03774 844B      LDD	R4,Y+11
    03775 845C      LDD	R5,Y+12
    03776 1A28      SUB	R2,R24
    03777 0A39      SBC	R3,R25
    03778 0A4A      SBC	R4,R26
    03779 0A5B      SBC	R5,R27
    0377A 8629      STD	Y+9,R2
    0377B 863A      STD	Y+10,R3
    0377C 864B      STD	Y+11,R4
    0377D 865C      STD	Y+12,R5
    0377E E880      LDI	R24,0x80
    0377F E996      LDI	R25,0x96
    03780 E9A8      LDI	R26,0x98
    03781 E0B0      LDI	R27,0
    03782 8429      LDD	R2,Y+9
    03783 843A      LDD	R3,Y+10
    03784 844B      LDD	R4,Y+11
    03785 845C      LDD	R5,Y+12
    03786 1628      CP	R2,R24
    03787 0639      CPC	R3,R25
    03788 064A      CPC	R4,R26
    03789 065B      CPC	R5,R27
    0378A F700      BCC	0x376B
(0079) 	if(da[7])	i=0;
    0378B 802F      LDD	R2,Y+7
    0378C 2022      TST	R2
    0378D F009      BEQ	0x378F
    0378E 2744      CLR	R20
(0080) 	if(i==0)	Usart_Transmit('0'+da[7]);
    0378F 2344      TST	R20
    03790 F4B9      BNE	0x37A8
    03791 810F      LDD	R16,Y+7
    03792 5D00      SUBI	R16,0xD0
    03793 DF72      RCALL	_Usart_Transmit
    03794 C013      RJMP	0x37A8
(0081) 	while(data>=1000000L) { ++da[6];data-=1000000L;}
    03795 818E      LDD	R24,Y+6
    03796 5F8F      SUBI	R24,0xFF
    03797 838E      STD	Y+6,R24
    03798 E480      LDI	R24,0x40
    03799 E492      LDI	R25,0x42
    0379A E0AF      LDI	R26,0xF
    0379B E0B0      LDI	R27,0
    0379C 8429      LDD	R2,Y+9
    0379D 843A      LDD	R3,Y+10
    0379E 844B      LDD	R4,Y+11
    0379F 845C      LDD	R5,Y+12
    037A0 1A28      SUB	R2,R24
    037A1 0A39      SBC	R3,R25
    037A2 0A4A      SBC	R4,R26
    037A3 0A5B      SBC	R5,R27
    037A4 8629      STD	Y+9,R2
    037A5 863A      STD	Y+10,R3
    037A6 864B      STD	Y+11,R4
    037A7 865C      STD	Y+12,R5
    037A8 E480      LDI	R24,0x40
    037A9 E492      LDI	R25,0x42
    037AA E0AF      LDI	R26,0xF
    037AB E0B0      LDI	R27,0
    037AC 8429      LDD	R2,Y+9
    037AD 843A      LDD	R3,Y+10
    037AE 844B      LDD	R4,Y+11
    037AF 845C      LDD	R5,Y+12
    037B0 1628      CP	R2,R24
    037B1 0639      CPC	R3,R25
    037B2 064A      CPC	R4,R26
    037B3 065B      CPC	R5,R27
    037B4 F700      BCC	0x3795
(0082) 	if(da[6])	i=0;
    037B5 802E      LDD	R2,Y+6
    037B6 2022      TST	R2
    037B7 F009      BEQ	0x37B9
    037B8 2744      CLR	R20
(0083) 	if(i==0)	Usart_Transmit('0'+da[6]);
    037B9 2344      TST	R20
    037BA F4B9      BNE	0x37D2
    037BB 810E      LDD	R16,Y+6
    037BC 5D00      SUBI	R16,0xD0
    037BD DF48      RCALL	_Usart_Transmit
    037BE C013      RJMP	0x37D2
(0084) 	while(data>=100000L)  { ++da[5];data-=100000L;}
    037BF 818D      LDD	R24,Y+5
    037C0 5F8F      SUBI	R24,0xFF
    037C1 838D      STD	Y+5,R24
    037C2 EA80      LDI	R24,0xA0
    037C3 E896      LDI	R25,0x86
    037C4 E0A1      LDI	R26,1
    037C5 E0B0      LDI	R27,0
    037C6 8429      LDD	R2,Y+9
    037C7 843A      LDD	R3,Y+10
    037C8 844B      LDD	R4,Y+11
    037C9 845C      LDD	R5,Y+12
    037CA 1A28      SUB	R2,R24
    037CB 0A39      SBC	R3,R25
    037CC 0A4A      SBC	R4,R26
    037CD 0A5B      SBC	R5,R27
    037CE 8629      STD	Y+9,R2
    037CF 863A      STD	Y+10,R3
    037D0 864B      STD	Y+11,R4
    037D1 865C      STD	Y+12,R5
    037D2 EA80      LDI	R24,0xA0
    037D3 E896      LDI	R25,0x86
    037D4 E0A1      LDI	R26,1
    037D5 E0B0      LDI	R27,0
    037D6 8429      LDD	R2,Y+9
    037D7 843A      LDD	R3,Y+10
    037D8 844B      LDD	R4,Y+11
    037D9 845C      LDD	R5,Y+12
    037DA 1628      CP	R2,R24
    037DB 0639      CPC	R3,R25
    037DC 064A      CPC	R4,R26
    037DD 065B      CPC	R5,R27
    037DE F700      BCC	0x37BF
(0085) 	if(da[5])	i=0;
    037DF 802D      LDD	R2,Y+5
    037E0 2022      TST	R2
    037E1 F009      BEQ	0x37E3
    037E2 2744      CLR	R20
(0086) 	if(i==0)	Usart_Transmit('0'+da[5]);
    037E3 2344      TST	R20
    037E4 F4B9      BNE	0x37FC
    037E5 810D      LDD	R16,Y+5
    037E6 5D00      SUBI	R16,0xD0
    037E7 DF1E      RCALL	_Usart_Transmit
    037E8 C013      RJMP	0x37FC
(0087) 	while(data>=10000L)   { ++da[4];data-=10000L;}
    037E9 818C      LDD	R24,Y+4
    037EA 5F8F      SUBI	R24,0xFF
    037EB 838C      STD	Y+4,R24
    037EC E180      LDI	R24,0x10
    037ED E297      LDI	R25,0x27
    037EE E0A0      LDI	R26,0
    037EF E0B0      LDI	R27,0
    037F0 8429      LDD	R2,Y+9
    037F1 843A      LDD	R3,Y+10
    037F2 844B      LDD	R4,Y+11
    037F3 845C      LDD	R5,Y+12
    037F4 1A28      SUB	R2,R24
    037F5 0A39      SBC	R3,R25
    037F6 0A4A      SBC	R4,R26
    037F7 0A5B      SBC	R5,R27
    037F8 8629      STD	Y+9,R2
    037F9 863A      STD	Y+10,R3
    037FA 864B      STD	Y+11,R4
    037FB 865C      STD	Y+12,R5
    037FC E180      LDI	R24,0x10
    037FD E297      LDI	R25,0x27
    037FE E0A0      LDI	R26,0
    037FF E0B0      LDI	R27,0
    03800 8429      LDD	R2,Y+9
    03801 843A      LDD	R3,Y+10
    03802 844B      LDD	R4,Y+11
    03803 845C      LDD	R5,Y+12
    03804 1628      CP	R2,R24
    03805 0639      CPC	R3,R25
    03806 064A      CPC	R4,R26
    03807 065B      CPC	R5,R27
    03808 F700      BCC	0x37E9
(0088) 	if(da[4])	i=0;
    03809 802C      LDD	R2,Y+4
    0380A 2022      TST	R2
    0380B F009      BEQ	0x380D
    0380C 2744      CLR	R20
(0089) 	if(i==0)	Usart_Transmit('0'+da[4]);
    0380D 2344      TST	R20
    0380E F4B9      BNE	0x3826
    0380F 810C      LDD	R16,Y+4
    03810 5D00      SUBI	R16,0xD0
    03811 DEF4      RCALL	_Usart_Transmit
    03812 C013      RJMP	0x3826
(0090) 	while(data>=1000L)    { ++da[3];data-=1000L;}
    03813 818B      LDD	R24,Y+3
    03814 5F8F      SUBI	R24,0xFF
    03815 838B      STD	Y+3,R24
    03816 EE88      LDI	R24,0xE8
    03817 E093      LDI	R25,3
    03818 E0A0      LDI	R26,0
    03819 E0B0      LDI	R27,0
    0381A 8429      LDD	R2,Y+9
    0381B 843A      LDD	R3,Y+10
    0381C 844B      LDD	R4,Y+11
    0381D 845C      LDD	R5,Y+12
    0381E 1A28      SUB	R2,R24
    0381F 0A39      SBC	R3,R25
    03820 0A4A      SBC	R4,R26
    03821 0A5B      SBC	R5,R27
    03822 8629      STD	Y+9,R2
    03823 863A      STD	Y+10,R3
    03824 864B      STD	Y+11,R4
    03825 865C      STD	Y+12,R5
    03826 EE88      LDI	R24,0xE8
    03827 E093      LDI	R25,3
    03828 E0A0      LDI	R26,0
    03829 E0B0      LDI	R27,0
    0382A 8429      LDD	R2,Y+9
    0382B 843A      LDD	R3,Y+10
    0382C 844B      LDD	R4,Y+11
    0382D 845C      LDD	R5,Y+12
    0382E 1628      CP	R2,R24
    0382F 0639      CPC	R3,R25
    03830 064A      CPC	R4,R26
    03831 065B      CPC	R5,R27
    03832 F700      BCC	0x3813
(0091) 	if(da[3])	i=0;
    03833 802B      LDD	R2,Y+3
    03834 2022      TST	R2
    03835 F009      BEQ	0x3837
    03836 2744      CLR	R20
(0092) 	if(i==0)	Usart_Transmit('0'+da[3]);
    03837 2344      TST	R20
    03838 F4B9      BNE	0x3850
    03839 810B      LDD	R16,Y+3
    0383A 5D00      SUBI	R16,0xD0
    0383B DECA      RCALL	_Usart_Transmit
    0383C C013      RJMP	0x3850
(0093) 	while(data>=100L)     { ++da[2];data-=100L;}
    0383D 818A      LDD	R24,Y+2
    0383E 5F8F      SUBI	R24,0xFF
    0383F 838A      STD	Y+2,R24
    03840 E684      LDI	R24,0x64
    03841 E090      LDI	R25,0
    03842 E0A0      LDI	R26,0
    03843 E0B0      LDI	R27,0
    03844 8429      LDD	R2,Y+9
    03845 843A      LDD	R3,Y+10
    03846 844B      LDD	R4,Y+11
    03847 845C      LDD	R5,Y+12
    03848 1A28      SUB	R2,R24
    03849 0A39      SBC	R3,R25
    0384A 0A4A      SBC	R4,R26
    0384B 0A5B      SBC	R5,R27
    0384C 8629      STD	Y+9,R2
    0384D 863A      STD	Y+10,R3
    0384E 864B      STD	Y+11,R4
    0384F 865C      STD	Y+12,R5
    03850 E684      LDI	R24,0x64
    03851 E090      LDI	R25,0
    03852 E0A0      LDI	R26,0
    03853 E0B0      LDI	R27,0
    03854 8429      LDD	R2,Y+9
    03855 843A      LDD	R3,Y+10
    03856 844B      LDD	R4,Y+11
    03857 845C      LDD	R5,Y+12
    03858 1628      CP	R2,R24
    03859 0639      CPC	R3,R25
    0385A 064A      CPC	R4,R26
    0385B 065B      CPC	R5,R27
    0385C F700      BCC	0x383D
(0094) 	if(da[2])	i=0;
    0385D 802A      LDD	R2,Y+2
    0385E 2022      TST	R2
    0385F F009      BEQ	0x3861
    03860 2744      CLR	R20
(0095) 	if(i==0)	Usart_Transmit('0'+da[2]);
    03861 2344      TST	R20
    03862 F4B9      BNE	0x387A
    03863 810A      LDD	R16,Y+2
    03864 5D00      SUBI	R16,0xD0
    03865 DEA0      RCALL	_Usart_Transmit
    03866 C013      RJMP	0x387A
(0096) 	while(data>=10L)      { ++da[1];data-=10L;}
    03867 8189      LDD	R24,Y+1
    03868 5F8F      SUBI	R24,0xFF
    03869 8389      STD	Y+1,R24
    0386A E08A      LDI	R24,0xA
    0386B E090      LDI	R25,0
    0386C E0A0      LDI	R26,0
    0386D E0B0      LDI	R27,0
    0386E 8429      LDD	R2,Y+9
    0386F 843A      LDD	R3,Y+10
    03870 844B      LDD	R4,Y+11
    03871 845C      LDD	R5,Y+12
    03872 1A28      SUB	R2,R24
    03873 0A39      SBC	R3,R25
    03874 0A4A      SBC	R4,R26
    03875 0A5B      SBC	R5,R27
    03876 8629      STD	Y+9,R2
    03877 863A      STD	Y+10,R3
    03878 864B      STD	Y+11,R4
    03879 865C      STD	Y+12,R5
    0387A E08A      LDI	R24,0xA
    0387B E090      LDI	R25,0
    0387C E0A0      LDI	R26,0
    0387D E0B0      LDI	R27,0
    0387E 8429      LDD	R2,Y+9
    0387F 843A      LDD	R3,Y+10
    03880 844B      LDD	R4,Y+11
    03881 845C      LDD	R5,Y+12
    03882 1628      CP	R2,R24
    03883 0639      CPC	R3,R25
    03884 064A      CPC	R4,R26
    03885 065B      CPC	R5,R27
    03886 F700      BCC	0x3867
(0097) 	if(da[1])	i=0;
    03887 8029      LDD	R2,Y+1
    03888 2022      TST	R2
    03889 F009      BEQ	0x388B
    0388A 2744      CLR	R20
(0098) 	if(i==0)	Usart_Transmit('0'+da[1]);
    0388B 2344      TST	R20
    0388C F419      BNE	0x3890
    0388D 8109      LDD	R16,Y+1
    0388E 5D00      SUBI	R16,0xD0
    0388F DE76      RCALL	_Usart_Transmit
(0099) 	Usart_Transmit('0'+data);
    03890 E380      LDI	R24,0x30
    03891 E090      LDI	R25,0
    03892 E0A0      LDI	R26,0
    03893 E0B0      LDI	R27,0
    03894 8429      LDD	R2,Y+9
    03895 843A      LDD	R3,Y+10
    03896 844B      LDD	R4,Y+11
    03897 845C      LDD	R5,Y+12
    03898 0E28      ADD	R2,R24
    03899 1E39      ADC	R3,R25
    0389A 1E4A      ADC	R4,R26
    0389B 1E5B      ADC	R5,R27
    0389C 2D02      MOV	R16,R2
    0389D DE68      RCALL	_Usart_Transmit
    0389E 9628      ADIW	R28,0x8
    0389F 9149      LD	R20,Y+
    038A0 9624      ADIW	R28,4
    038A1 9508      RET
_PrintChar:
  h                    --> R20
  d                    --> R22
    038A2 934A      ST	-Y,R20
    038A3 936A      ST	-Y,R22
    038A4 2F60      MOV	R22,R16
(0100)  
(0101) }
(0102)  
(0103) void PrintChar(unsigned char d)
(0104) {
(0105) 	unsigned char h=(d&0xF0)>>4;
    038A5 2F46      MOV	R20,R22
    038A6 7F40      ANDI	R20,0xF0
    038A7 9542      SWAP	R20
    038A8 704F      ANDI	R20,0xF
(0106) 	if(h<10)	Usart_Transmit('0'+h);
    038A9 304A      CPI	R20,0xA
    038AA F420      BCC	0x38AF
    038AB 2F04      MOV	R16,R20
    038AC 5D00      SUBI	R16,0xD0
    038AD DE58      RCALL	_Usart_Transmit
    038AE C003      RJMP	0x38B2
(0107) 	else		Usart_Transmit('A'-10+h);
    038AF 2F04      MOV	R16,R20
    038B0 5C09      SUBI	R16,0xC9
    038B1 DE54      RCALL	_Usart_Transmit
(0108) 	h=d&0x0f;
    038B2 2F46      MOV	R20,R22
    038B3 704F      ANDI	R20,0xF
(0109) 	if(h<10)	Usart_Transmit('0'+h);
    038B4 304A      CPI	R20,0xA
    038B5 F420      BCC	0x38BA
    038B6 2F04      MOV	R16,R20
    038B7 5D00      SUBI	R16,0xD0
    038B8 DE4D      RCALL	_Usart_Transmit
    038B9 C003      RJMP	0x38BD
(0110) 	else		Usart_Transmit('A'-10+h);
    038BA 2F04      MOV	R16,R20
    038BB 5C09      SUBI	R16,0xC9
    038BC DE49      RCALL	_Usart_Transmit
(0111) 	Usart_Transmit(' ');
    038BD E200      LDI	R16,0x20
    038BE DE47      RCALL	_Usart_Transmit
    038BF 9169      LD	R22,Y+
    038C0 9149      LD	R20,Y+
    038C1 9508      RET
FILE: D:\LQD\software\master\software_src\SPI.c
(0001) //*****************************************************************************//
(0002) //*								 
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SPI接口控制
(0006) //*****************************************************************************//
(0007) #include "SPI.h"
(0008) 
(0009) /******************************************************************
(0010) SPI接口函数初始化
(0011) ******************************************************************/
(0012) void SPI_IO_Init(void)
(0013) {
(0014) 	SPI_PORT |= (1<<SS);////拉高CS
_SPI_IO_Init:
    038C2 9AC0      SBI	0x18,0
(0015) 	SPI_DDR |= (1<<SCLK)|(1<<MOSI)|(1<<SS);////CS,CLK,MOSI设为输出
    038C3 B387      IN	R24,0x17
    038C4 6087      ORI	R24,7
    038C5 BB87      OUT	0x17,R24
(0016) 	SPI_DDR &=~(1<<MISO);//MISO设为输入
    038C6 98BB      CBI	0x17,3
(0017) 	SPI_PORT |= (1<<SCLK);//拉高CLK
    038C7 9AC1      SBI	0x18,1
(0018) 	SPI_High();//SPI高通
    038C8 E580      LDI	R24,0x50
    038C9 B98D      OUT	0x0D,R24
    038CA 9A70      SBI	0x0E,0
    038CB 9508      RET
(0019) }
(0020) /******************************************************************
(0021) SPI写一个字节
(0022) ******************************************************************/
(0023) void SPI_Write(UINT8 data)
(0024) {
(0025) 	SPDR = data;
_SPI_Write:
  data                 --> R16
    038CC B90F      OUT	0x0F,R16
(0026) 	while ((SPSR&(1<<SPIF))==0);
    038CD 9B77      SBIS	0x0E,7
    038CE CFFE      RJMP	0x38CD
    038CF 9508      RET
(0027) 	//loop_until_bit_is_set(SPSR,SPIF);
(0028) }
(0029) /******************************************************************
(0030) SPI读一个字节
(0031) ******************************************************************/
(0032) unsigned char SPI_Read(void)
(0033) {
(0034) 	SPDR = 0xFF;//写0xFF启动SPI
_SPI_Read:
    038D0 EF8F      LDI	R24,0xFF
    038D1 B98F      OUT	0x0F,R24
(0035) 	while ((SPSR&(1<<SPIF))==0);
    038D2 9B77      SBIS	0x0E,7
    038D3 CFFE      RJMP	0x38D2
(0036) 	//loop_until_bit_is_set(SPSR,SPIF);//等待SPIF为高电平
(0037) 	return  SPDR;//返回读取值
    038D4 B10F      IN	R16,0x0F
    038D5 9508      RET
FILE: D:\LQD\software\master\software_src\lcd.c
(0001) #include "config.h"
(0002) 
(0003) //此硬件引脚适合冷强度检测仪第2版电路  mega128
(0004) #define LCD_PIN_CS   4
(0005) #define LCD_PIN_SID  3
(0006) #define LCD_PIN_SCLK 2
(0007) #define LCD_PIN_RST  1
(0008) #define LCD_BACKLIGHT_SW		0
(0009) #define LCD_PORT PORTC
(0010) #define LCD_PIN_DDR DDRC
(0011) #define Set_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT |= (1<<LCD_PIN_CS) 
(0012) #define Set_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT |= (1<<LCD_PIN_SID) 
(0013) #define Set_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT |= (1<<LCD_PIN_SCLK) 
(0014) #define LCD_LIGHT_ON()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT |= (1<<LCD_BACKLIGHT_SW) 
(0015) #define Set_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT |= (1<<LCD_PIN_RST) 
(0016) 
(0017) #define Clr_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT &=~(1<<LCD_PIN_CS) 
(0018) #define Clr_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT &=~(1<<LCD_PIN_SID) 
(0019) #define Clr_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT &=~(1<<LCD_PIN_SCLK) 
(0020) #define LCD_LIGHT_OFF()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT &=~(1<<LCD_BACKLIGHT_SW) 
(0021) #define Clr_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT &=~(1<<LCD_PIN_RST) 
(0022)  
(0023) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data); 
(0024) void Write_8bits(unsigned int W_bits); 
(0025) void LCD_Init(void); 
(0026) unsigned char LCD_INT(void); 
(0027) 
(0028) unsigned char LCD_SW(unsigned char i)
(0029) {
(0030)  if(i==0){
_LCD_SW:
  i                    --> R16
    038D6 2300      TST	R16
    038D7 F421      BNE	0x38DC
(0031)  LCD_LIGHT_OFF();
    038D8 9AA0      SBI	0x14,0
    038D9 98A8      CBI	0x15,0
(0032)  return 0;
    038DA 2700      CLR	R16
    038DB C003      RJMP	0x38DF
(0033)  }
(0034)  else{
(0035)  LCD_LIGHT_ON();
    038DC 9AA0      SBI	0x14,0
    038DD 9AA8      SBI	0x15,0
(0036)  return 1;
    038DE E001      LDI	R16,1
    038DF 9508      RET
(0037)  }
(0038)  
(0039) }
(0040)  
(0041) unsigned char LCD_INT(void) 
(0042) { 
(0043)   Clr_CS(); 
_LCD_INT:
    038E0 9AA4      SBI	0x14,4
    038E1 98AC      CBI	0x15,4
(0044)   Clr_SID(); 
    038E2 9AA3      SBI	0x14,3
    038E3 98AB      CBI	0x15,3
(0045)   Clr_SCLK(); 
    038E4 9AA2      SBI	0x14,2
    038E5 98AA      CBI	0x15,2
(0046)   LCD_Init(); 
    038E6 D097      RCALL	_LCD_Init
(0047)   return (0);
    038E7 2700      CLR	R16
    038E8 9508      RET
_address:
  a                    --> R20
  y                    --> R18
  x                    --> R16
    038E9 940E 40BC CALL	push_xgsetF000
(0048) } 
(0049)   
(0050) /******************************************************************** 
(0051) 函数 名：address
(0052) 入口参数：地址转换
(0053) 出口参数：无 
(0054) 函数作用： 
(0055) 说        明： 
(0056) ********************************************************************/ 
(0057) unsigned char address(unsigned char x,unsigned char y)
(0058) {  
(0059)  unsigned char a;
(0060) 
(0061) switch(x) 
    038EB 2F60      MOV	R22,R16
    038EC 2777      CLR	R23
    038ED 3061      CPI	R22,1
    038EE E0E0      LDI	R30,0
    038EF 077E      CPC	R23,R30
    038F0 F069      BEQ	0x38FE
    038F1 3062      CPI	R22,2
    038F2 E0E0      LDI	R30,0
    038F3 077E      CPC	R23,R30
    038F4 F059      BEQ	0x3900
    038F5 3063      CPI	R22,3
    038F6 E0E0      LDI	R30,0
    038F7 077E      CPC	R23,R30
    038F8 F049      BEQ	0x3902
    038F9 3064      CPI	R22,4
    038FA E0E0      LDI	R30,0
    038FB 077E      CPC	R23,R30
    038FC F039      BEQ	0x3904
    038FD C007      RJMP	0x3905
(0062) { 
(0063) case 1: 
(0064) {a=0x80;break;} 
    038FE E840      LDI	R20,0x80
    038FF C005      RJMP	0x3905
(0065) case 2: 
(0066) {a=0x90;break;} 
    03900 E940      LDI	R20,0x90
    03901 C003      RJMP	0x3905
(0067)   case 3: 
(0068) {a=0x88;break;} 
    03902 E848      LDI	R20,0x88
    03903 C001      RJMP	0x3905
(0069)   case 4: 
(0070) {a=0x98;break;} 
    03904 E948      LDI	R20,0x98
(0071) } 
(0072) a=a+y-1;
    03905 0F42      ADD	R20,R18
    03906 5041      SUBI	R20,1
(0073) 
(0074) return a;
    03907 2F04      MOV	R16,R20
    03908 940C 40C1 JMP	pop_xgsetF000
_LCD_const_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    0390A 940E 40A9 CALL	push_xgset30FC
    0390C 2EE2      MOV	R14,R18
    0390D 2EC0      MOV	R12,R16
    0390E 9721      SBIW	R28,1
    0390F 84A9      LDD	R10,Y+9
    03910 84BA      LDD	R11,Y+10
(0075) }
(0076)  
(0077) //////////////////////////////////////////////////////////////
(0078) 
(0079) /******************************************************************** 
(0080) 函数 名：LCD_const_disp
(0081) 入口参数：x y  *single_data
(0082) 出口参数：无 
(0083) 函数作用：负责 显示一串常量
(0084) 说        明： 
(0085) ********************************************************************/ 
(0086) void LCD_const_disp(unsigned char x, unsigned char y, const unsigned char *single_data) 
(0087) { 
(0088) unsigned char  a,i; 
(0089) a=address(x,y);
    03911 2D2E      MOV	R18,R14
    03912 2D0C      MOV	R16,R12
    03913 DFD5      RCALL	_address
    03914 2EC0      MOV	R12,R16
(0090) W_1byte(0,0,a);     //显示的地址 
    03915 82C8      ST	Y,R12
    03916 2722      CLR	R18
    03917 2700      CLR	R16
    03918 D0B7      RCALL	_W_1byte
(0091)    for(i=0; single_data[i]!='\0';i++) 
    03919 2744      CLR	R20
    0391A C00D      RJMP	0x3928
(0092)    {
(0093)     if(i>=16) break; 
    0391B 3140      CPI	R20,0x10
    0391C F008      BCS	0x391E
    0391D C011      RJMP	0x392F
(0094)     W_1byte(0,1,single_data[i]); 
    0391E 2FE4      MOV	R30,R20
    0391F 27FF      CLR	R31
    03920 0DEA      ADD	R30,R10
    03921 1DFB      ADC	R31,R11
    03922 8020      LD	R2,Z
    03923 8228      ST	Y,R2
    03924 E021      LDI	R18,1
    03925 2700      CLR	R16
    03926 D0A9      RCALL	_W_1byte
    03927 9543      INC	R20
    03928 2FE4      MOV	R30,R20
    03929 27FF      CLR	R31
    0392A 0DEA      ADD	R30,R10
    0392B 1DFB      ADC	R31,R11
    0392C 8020      LD	R2,Z
    0392D 2022      TST	R2
    0392E F761      BNE	0x391B
(0095)     
(0096)    } 
(0097)    W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    0392F EF8F      LDI	R24,0xFF
    03930 8388      ST	Y,R24
    03931 2722      CLR	R18
    03932 2700      CLR	R16
    03933 D09C      RCALL	_W_1byte
    03934 9621      ADIW	R28,1
    03935 940C 4093 JMP	pop_xgset30FC
_LCD_var_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    03937 940E 40A9 CALL	push_xgset30FC
    03939 2EE2      MOV	R14,R18
    0393A 2EC0      MOV	R12,R16
    0393B 9721      SBIW	R28,1
    0393C 84A9      LDD	R10,Y+9
    0393D 84BA      LDD	R11,Y+10
(0098)  
(0099) } 
(0100) 
(0101) /******************************************************************** 
(0102) 函数 名：LCD_var_disp
(0103) 入口参数：single_row single_line  *single_data
(0104) 出口参数：无 
(0105) 函数作用：负责 显示一串变量
(0106) 说        明： 
(0107) ********************************************************************/ 
(0108) 
(0109) void LCD_var_disp(unsigned char x, unsigned char y, unsigned char *single_data) 
(0110) { 
(0111) unsigned char  a,i; 
(0112) 
(0113) #if _debug == 1 
(0114) 	PrintString_n(single_data);
(0115) #endif 
(0116) 
(0117) a=address( x,y);
    0393E 2D2E      MOV	R18,R14
    0393F 2D0C      MOV	R16,R12
    03940 DFA8      RCALL	_address
    03941 2EC0      MOV	R12,R16
(0118) W_1byte(0,0,a);     //显示的地址0x88 
    03942 82C8      ST	Y,R12
    03943 2722      CLR	R18
    03944 2700      CLR	R16
    03945 D08A      RCALL	_W_1byte
(0119) 
(0120) for(i=0; single_data[i]!='\0';i++) 
    03946 2744      CLR	R20
    03947 C00D      RJMP	0x3955
(0121)    { 
(0122)     if(i>=16) break;
    03948 3140      CPI	R20,0x10
    03949 F008      BCS	0x394B
    0394A C011      RJMP	0x395C
(0123)     W_1byte(0,1,single_data[i]); 
    0394B 2FE4      MOV	R30,R20
    0394C 27FF      CLR	R31
    0394D 0DEA      ADD	R30,R10
    0394E 1DFB      ADC	R31,R11
    0394F 8020      LD	R2,Z
    03950 8228      ST	Y,R2
    03951 E021      LDI	R18,1
    03952 2700      CLR	R16
    03953 D07C      RCALL	_W_1byte
    03954 9543      INC	R20
    03955 2FE4      MOV	R30,R20
    03956 27FF      CLR	R31
    03957 0DEA      ADD	R30,R10
    03958 1DFB      ADC	R31,R11
    03959 8020      LD	R2,Z
    0395A 2022      TST	R2
    0395B F761      BNE	0x3948
(0124) 	} 
(0125)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    0395C EF8F      LDI	R24,0xFF
    0395D 8388      ST	Y,R24
    0395E 2722      CLR	R18
    0395F 2700      CLR	R16
    03960 D06F      RCALL	_W_1byte
    03961 9621      ADIW	R28,1
    03962 940C 4093 JMP	pop_xgset30FC
_LCD_char_disp:
  a                    --> R12
  data                 --> R10
  y                    --> R14
  x                    --> R12
    03964 940E 40AB CALL	push_xgset00FC
    03966 2EE2      MOV	R14,R18
    03967 2EC0      MOV	R12,R16
    03968 9721      SBIW	R28,1
    03969 80AF      LDD	R10,Y+7
(0126) } 
(0127) /******************************************************************** 
(0128) 函数 名：LCD_char_disp
(0129) 入口参数：single_row single_line  data
(0130) 出口参数：无 
(0131) 函数作用：负责 显示一个 变量
(0132) 说        明： 
(0133) ********************************************************************/ 
(0134) 
(0135) void LCD_char_disp(unsigned char x, unsigned char y, unsigned char data) 
(0136) { 
(0137) unsigned char a; 
(0138) a=address(x,y);
    0396A 2D2E      MOV	R18,R14
    0396B 2D0C      MOV	R16,R12
    0396C DF7C      RCALL	_address
    0396D 2EC0      MOV	R12,R16
(0139) W_1byte(0,0,a);     //显示的地址 
    0396E 82C8      ST	Y,R12
    0396F 2722      CLR	R18
    03970 2700      CLR	R16
    03971 D05E      RCALL	_W_1byte
(0140) W_1byte(0,1,data);  //显示内容
    03972 82A8      ST	Y,R10
    03973 E021      LDI	R18,1
    03974 2700      CLR	R16
    03975 D05A      RCALL	_W_1byte
(0141)  
(0142)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03976 EF8F      LDI	R24,0xFF
    03977 8388      ST	Y,R24
    03978 2722      CLR	R18
    03979 2700      CLR	R16
    0397A D055      RCALL	_W_1byte
    0397B 9621      ADIW	R28,1
    0397C 940C 408C JMP	pop_xgset00FC
_LCD_Init:
  cmd                  --> R20
    0397E 934A      ST	-Y,R20
    0397F 9721      SBIW	R28,1
(0143) } 
(0144) 
(0145) /******************************************************************** 
(0146) 函数 名：LCD_Init
(0147) 入口参数：无
(0148) 出口参数：unsigned char  0/1
(0149) 函数作用：负责 清空液晶显示
(0150) 说        明： 
(0151) ********************************************************************/ 
(0152) void LCD_Init(void) 
(0153) { 
(0154)    unsigned char cmd; 
(0155)    cmd=0x30;      //功能设置 8 位数据，基本指令 
    03980 E340      LDI	R20,0x30
(0156)   W_1byte(0,0,cmd); 
    03981 8348      ST	Y,R20
    03982 2722      CLR	R18
    03983 2700      CLR	R16
    03984 D04B      RCALL	_W_1byte
(0157)   delayms(2); 
    03985 E002      LDI	R16,2
    03986 E010      LDI	R17,0
    03987 940E 2407 CALL	_delayms
(0158)   cmd=0x0C;      //显示状态 ON，游标OFF，反白OFF 
    03989 E04C      LDI	R20,0xC
(0159)   W_1byte(0,0,cmd); //写指令 
    0398A 8348      ST	Y,R20
    0398B 2722      CLR	R18
    0398C 2700      CLR	R16
    0398D D042      RCALL	_W_1byte
(0160)   delayms(2); 
    0398E E002      LDI	R16,2
    0398F E010      LDI	R17,0
    03990 940E 2407 CALL	_delayms
(0161)   cmd=0x01;      //清除显示 
    03992 E041      LDI	R20,1
(0162)   W_1byte(0,0,cmd); //写指令 
    03993 8348      ST	Y,R20
    03994 2722      CLR	R18
    03995 2700      CLR	R16
    03996 D039      RCALL	_W_1byte
(0163)   delayms(2); 
    03997 E002      LDI	R16,2
    03998 E010      LDI	R17,0
    03999 940E 2407 CALL	_delayms
(0164)   cmd=0x02;      //地址归位 
    0399B E042      LDI	R20,2
(0165)   W_1byte(0,0,cmd); //写指令 
    0399C 8348      ST	Y,R20
    0399D 2722      CLR	R18
    0399E 2700      CLR	R16
    0399F D030      RCALL	_W_1byte
(0166)   delayms(2); 
    039A0 E002      LDI	R16,2
    039A1 E010      LDI	R17,0
    039A2 940E 2407 CALL	_delayms
(0167)   cmd=0x80;      //设置DDRAM 地址 
    039A4 E840      LDI	R20,0x80
(0168)   W_1byte(0,0,cmd); //写指令 
    039A5 8348      ST	Y,R20
    039A6 2722      CLR	R18
    039A7 2700      CLR	R16
    039A8 D027      RCALL	_W_1byte
(0169)   delayms(2);     //延时 
    039A9 E002      LDI	R16,2
    039AA E010      LDI	R17,0
    039AB 940E 2407 CALL	_delayms
    039AD 9621      ADIW	R28,1
    039AE 9149      LD	R20,Y+
    039AF 9508      RET
_LCD_CLR:
  cmd                  --> R20
    039B0 934A      ST	-Y,R20
    039B1 9721      SBIW	R28,1
(0170) } 
(0171) 
(0172) void LCD_CLR(void)
(0173) {
(0174) unsigned char cmd;
(0175)   cmd=0x01;      //清除显示 
    039B2 E041      LDI	R20,1
(0176)   W_1byte(0,0,cmd); //写指令 
    039B3 8348      ST	Y,R20
    039B4 2722      CLR	R18
    039B5 2700      CLR	R16
    039B6 D019      RCALL	_W_1byte
(0177)   delayms(1); 
    039B7 E001      LDI	R16,1
    039B8 E010      LDI	R17,0
    039B9 940E 2407 CALL	_delayms
(0178)   cmd=0x02;      //地址归位 
    039BB E042      LDI	R20,2
(0179)   W_1byte(0,0,cmd); //写指令 
    039BC 8348      ST	Y,R20
    039BD 2722      CLR	R18
    039BE 2700      CLR	R16
    039BF D010      RCALL	_W_1byte
(0180)   delayms(1); 
    039C0 E001      LDI	R16,1
    039C1 E010      LDI	R17,0
    039C2 940E 2407 CALL	_delayms
(0181)   cmd=0x80;      //设置DDRAM 地址 
    039C4 E840      LDI	R20,0x80
(0182)   W_1byte(0,0,cmd); //写指令 
    039C5 8348      ST	Y,R20
    039C6 2722      CLR	R18
    039C7 2700      CLR	R16
    039C8 D007      RCALL	_W_1byte
(0183)   delayms(1);     //延时
    039C9 E001      LDI	R16,1
    039CA E010      LDI	R17,0
    039CB 940E 2407 CALL	_delayms
    039CD 9621      ADIW	R28,1
    039CE 9149      LD	R20,Y+
    039CF 9508      RET
_W_1byte:
  H_data               --> R22
  S_ID                 --> R10
  L_data               --> R20
  W_data               --> R12
  RS                   --> R14
  RW                   --> R20
    039D0 940E 40A7 CALL	push_xgsetF0FC
    039D2 2EE2      MOV	R14,R18
    039D3 2F40      MOV	R20,R16
    039D4 84CA      LDD	R12,Y+10
(0184) 
(0185) }
(0186)  
(0187) /*******************************************************************
(0188) 函 数 名：W_1byte
(0189) 入口参数：RW、RS、W_data
(0190) 出口参数：无
(0191) 建立日期：2007年3月3日
(0192) 修改日期：
(0193) 函数作用：写一个字节的数据到12864液晶，包括指令和数据
(0194) 说    明：RW=1，从液晶读数据到MCU；RW=0，写一个数据到液晶；
(0195) 		 （一般RW都设为0，即只向液晶写数据，不读数据）
(0196)           RS=1，写入的是数据；RS=0，写入的是指令；
(0197) 		  一般模式：RW=0，RS=1;写数据
(0198) 		  			RW=0，RS=0;写指令
(0199) ********************************************************************/
(0200) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data)
(0201) {
(0202) 	unsigned int H_data,L_data,S_ID = 0xf8;	 //11111RWRS0
    039D5 EF88      LDI	R24,0xF8
    039D6 E090      LDI	R25,0
    039D7 015C      MOVW	R10,R24
(0203) 	if(RW == 0)
    039D8 2344      TST	R20
    039D9 F419      BNE	0x39DD
(0204) 	{
(0205) 	 	S_ID &=~ 0x04;
    039DA 7F8B      ANDI	R24,0xFB
    039DB 015C      MOVW	R10,R24
(0206) 	}
    039DC C003      RJMP	0x39E0
(0207) 	else					//if(RW==1)
(0208) 	{
(0209) 	 	S_ID |= 0X04;
    039DD 01C5      MOVW	R24,R10
    039DE 6084      ORI	R24,4
    039DF 015C      MOVW	R10,R24
(0210) 	}
(0211) 	if(RS == 0)
    039E0 20EE      TST	R14
    039E1 F421      BNE	0x39E6
(0212) 	{
(0213) 	 	S_ID &=~ 0x02;
    039E2 01C5      MOVW	R24,R10
    039E3 7F8D      ANDI	R24,0xFD
    039E4 015C      MOVW	R10,R24
(0214) 	}
    039E5 C003      RJMP	0x39E9
(0215) 	else					//if(RS==1)
(0216) 	{
(0217) 	 	S_ID |= 0X02;
    039E6 01C5      MOVW	R24,R10
    039E7 6082      ORI	R24,2
    039E8 015C      MOVW	R10,R24
(0218) 	}
(0219) 	H_data = W_data;
    039E9 2D6C      MOV	R22,R12
    039EA 2777      CLR	R23
(0220) 	H_data &= 0xf0;			//屏蔽低4位的数据
    039EB 7F60      ANDI	R22,0xF0
    039EC 7070      ANDI	R23,0
(0221) 	L_data = W_data;	   	//xxxx0000格式
    039ED 2D4C      MOV	R20,R12
    039EE 2755      CLR	R21
(0222) 	L_data &= 0x0f;			//屏蔽高4位的数据
    039EF 704F      ANDI	R20,0xF
    039F0 7050      ANDI	R21,0
(0223) 	L_data <<= 4;			//xxxx0000格式
    039F1 0F44      LSL	R20
    039F2 1F55      ROL	R21
    039F3 0F44      LSL	R20
    039F4 1F55      ROL	R21
    039F5 0F44      LSL	R20
    039F6 1F55      ROL	R21
    039F7 0F44      LSL	R20
    039F8 1F55      ROL	R21
(0224) 	Set_CS();
    039F9 9AA4      SBI	0x14,4
    039FA 9AAC      SBI	0x15,4
(0225) 	Write_8bits(S_ID); 		//发送S_ID
    039FB 0185      MOVW	R16,R10
    039FC D00C      RCALL	_Write_8bits
(0226) 	Write_8bits(H_data);	//发送H_data
    039FD 018B      MOVW	R16,R22
    039FE D00A      RCALL	_Write_8bits
(0227) 	Write_8bits(L_data);	//发送L_data
    039FF 018A      MOVW	R16,R20
    03A00 D008      RCALL	_Write_8bits
(0228) 	Clr_CS();	Clr_CS();	Clr_CS();	
    03A01 9AA4      SBI	0x14,4
    03A02 98AC      CBI	0x15,4
    03A03 9AA4      SBI	0x14,4
    03A04 98AC      CBI	0x15,4
    03A05 9AA4      SBI	0x14,4
    03A06 98AC      CBI	0x15,4
    03A07 940C 409C JMP	pop_xgsetF0FC
_Write_8bits:
  Temp_data            --> R12
  i                    --> R20
  W_bits               --> R10
    03A09 940E 40D4 CALL	push_xgset303C
    03A0B 0158      MOVW	R10,R16
(0229) 	 
(0230) 
(0231) }
(0232) /********************************************************************
(0233) 函 数 名：Write_8bits
(0234) 入口参数：W_bits
(0235) 出口参数：无
(0236) 建立日期：2007年3月3日
(0237) 修改日期：
(0238) 函数作用：负责串行输出8个bit位
(0239) 说    明：
(0240) ********************************************************************/
(0241) void Write_8bits(unsigned int W_bits)
(0242) {
(0243) 	unsigned int i,Temp_data;
(0244) 	for(i=0; i<8; i++)
    03A0C 2744      CLR	R20
    03A0D 2755      CLR	R21
    03A0E C019      RJMP	0x3A28
(0245) 	{
(0246) 		Temp_data = W_bits;
    03A0F 0165      MOVW	R12,R10
(0247) 		Temp_data <<= i;
    03A10 019A      MOVW	R18,R20
    03A11 0186      MOVW	R16,R12
    03A12 940E 4122 CALL	lsl16
    03A14 0168      MOVW	R12,R16
(0248) 		if((Temp_data&0x80)==0) 
    03A15 FD07      SBRC	R16,7
    03A16 C003      RJMP	0x3A1A
(0249) 		{
(0250) 		 	Clr_SID();
    03A17 9AA3      SBI	0x14,3
    03A18 98AB      CBI	0x15,3
(0251) 		}
    03A19 C002      RJMP	0x3A1C
(0252) 		else
(0253) 		{
(0254) 		 	Set_SID();
    03A1A 9AA3      SBI	0x14,3
    03A1B 9AAB      SBI	0x15,3
(0255) 		} 
(0256) 		NOP();
    03A1C 0000      NOP
(0257) 		Set_SCLK();
    03A1D 9AA2      SBI	0x14,2
    03A1E 9AAA      SBI	0x15,2
(0258) 		NOP();
    03A1F 0000      NOP
(0259) 		NOP();
    03A20 0000      NOP
(0260) 		Clr_SCLK();
    03A21 9AA2      SBI	0x14,2
    03A22 98AA      CBI	0x15,2
(0261) 		NOP();
    03A23 0000      NOP
(0262) 		Clr_SID();
    03A24 9AA3      SBI	0x14,3
    03A25 98AB      CBI	0x15,3
    03A26 5F4F      SUBI	R20,0xFF
    03A27 4F5F      SBCI	R21,0xFF
    03A28 3048      CPI	R20,0x8
    03A29 E0E0      LDI	R30,0
    03A2A 075E      CPC	R21,R30
    03A2B F318      BCS	0x3A0F
    03A2C 940C 40DB JMP	pop_xgset303C
_Set_Draw:
    03A2E 9721      SBIW	R28,1
(0263) 	}
(0264) }
(0265)  
(0266) /********************************************************************
(0267) 函 数 名：Set_Draw(
(0268) 入口参数：无
(0269) 出口参数：无
(0270) 函数作用：设置为绘图模式
(0271) 说    明：
(0272) ********************************************************************/
(0273) void Set_Draw(void)
(0274) {  	
(0275) 	//W_1byte(0,0,0x34);			//8BIT控制界面，扩充指令集,，绘图显示OFF
(0276) 	W_1byte(0,0,0x36);
    03A2F E386      LDI	R24,0x36
    03A30 8388      ST	Y,R24
    03A31 2722      CLR	R18
    03A32 2700      CLR	R16
    03A33 DF9C      RCALL	_W_1byte
(0277) 	delayms(1);					//延时
    03A34 E001      LDI	R16,1
    03A35 E010      LDI	R17,0
    03A36 940E 2407 CALL	_delayms
    03A38 9621      ADIW	R28,1
    03A39 9508      RET
_Set_White:
  clr_y                --> R10
  clr_x                --> R20
  white_y              --> Y,+2
  white_x              --> Y,+1
  i                    --> R22
  white_end_x          --> R12
  j                    --> R14
  clear                --> Y,+15
  end_x                --> R12
  y                    --> R14
  x                    --> R22
    03A3A 940E 40A7 CALL	push_xgsetF0FC
    03A3C 2EE2      MOV	R14,R18
    03A3D 2F60      MOV	R22,R16
    03A3E 9723      SBIW	R28,3
    03A3F 84CD      LDD	R12,Y+13
(0278) } 
(0279)  
(0280) 
(0281) /******************************************************************** 
(0282) 函数 名：Set_White 
(0283) 入口参数：  x,   y,  end_x,  clear
(0284) 出口参数：无 
(0285) 函数作用： 设置反显
(0286) 说        明： 
(0287) ********************************************************************/ 
(0288) void Set_White(unsigned char x,unsigned char y,unsigned char end_x,unsigned char clear)
(0289) {
(0290)  
(0291) 	unsigned char i, j, white_x, white_y,white_end_x,clr_x,clr_y ;		//
(0292)   
(0293) 	W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03A40 E386      LDI	R24,0x36
    03A41 8388      ST	Y,R24
    03A42 2722      CLR	R18
    03A43 2700      CLR	R16
    03A44 DF8B      RCALL	_W_1byte
(0294) 	delayus(20);					//延时
    03A45 E104      LDI	R16,0x14
    03A46 E010      LDI	R17,0
    03A47 940E 23FF CALL	_delayus
(0295)  
(0296) 	white_end_x = (end_x-x+1);
    03A49 2D8C      MOV	R24,R12
    03A4A 1B86      SUB	R24,R22
    03A4B 5F8F      SUBI	R24,0xFF
    03A4C 2EC8      MOV	R12,R24
(0297) 	white_end_x <<= 1;
    03A4D 0CCC      LSL	R12
(0298) 	if(y==1)   //x,1  a=80+x-1                   
    03A4E 2D8E      MOV	R24,R14
    03A4F 3081      CPI	R24,1
    03A50 F449      BNE	0x3A5A
(0299) 	{
(0300) 	 	white_x = (0x80+x-1); 
    03A51 2F86      MOV	R24,R22
    03A52 5880      SUBI	R24,0x80
    03A53 5081      SUBI	R24,1
    03A54 8389      STD	Y+1,R24
(0301) 		white_y = 0x80;
    03A55 E880      LDI	R24,0x80
    03A56 838A      STD	Y+2,R24
(0302) 		clr_x = 0x80;
    03A57 E840      LDI	R20,0x80
(0303) 		clr_y = 0x80;
    03A58 2EA8      MOV	R10,R24
(0304) 	}
    03A59 C023      RJMP	0x3A7D
(0305) 	else if(y==2)
    03A5A 2D8E      MOV	R24,R14
    03A5B 3082      CPI	R24,2
    03A5C F449      BNE	0x3A66
(0306) 	{
(0307) 	 	white_x = (0x80+x-1);
    03A5D 2F86      MOV	R24,R22
    03A5E 5880      SUBI	R24,0x80
    03A5F 5081      SUBI	R24,1
    03A60 8389      STD	Y+1,R24
(0308) 		white_y = 0x90;
    03A61 E980      LDI	R24,0x90
    03A62 838A      STD	Y+2,R24
(0309) 		clr_x = 0x80;
    03A63 E840      LDI	R20,0x80
(0310) 		clr_y = 0x90;
    03A64 2EA8      MOV	R10,R24
(0311) 	}
    03A65 C017      RJMP	0x3A7D
(0312) 	else if(y==3)
    03A66 2D8E      MOV	R24,R14
    03A67 3083      CPI	R24,3
    03A68 F449      BNE	0x3A72
(0313) 	{
(0314) 	 	white_x = (0x88+x-1);
    03A69 2F86      MOV	R24,R22
    03A6A 5788      SUBI	R24,0x78
    03A6B 5081      SUBI	R24,1
    03A6C 8389      STD	Y+1,R24
(0315) 		white_y = 0x80;
    03A6D E880      LDI	R24,0x80
    03A6E 838A      STD	Y+2,R24
(0316) 		clr_x = 0x88;
    03A6F E848      LDI	R20,0x88
(0317) 		clr_y = 0x80;
    03A70 2EA8      MOV	R10,R24
(0318) 	}
    03A71 C00B      RJMP	0x3A7D
(0319) 	else if(y==4)
    03A72 2D8E      MOV	R24,R14
    03A73 3084      CPI	R24,4
    03A74 F441      BNE	0x3A7D
(0320) 	{
(0321) 	 	white_x = (0x88+x-1);
    03A75 2F86      MOV	R24,R22
    03A76 5788      SUBI	R24,0x78
    03A77 5081      SUBI	R24,1
    03A78 8389      STD	Y+1,R24
(0322) 		white_y = 0x90;
    03A79 E980      LDI	R24,0x90
    03A7A 838A      STD	Y+2,R24
(0323) 		clr_x = 0x88;
    03A7B E848      LDI	R20,0x88
(0324) 		clr_y = 0x90;
    03A7C 2EA8      MOV	R10,R24
(0325) 	}
(0326)   if(clear==0)//要反白时，先将整行的液晶全部清成不反白（此处行指y）
    03A7D 840F      LDD	R0,Y+15
    03A7E 2000      TST	R0
    03A7F F4E9      BNE	0x3A9D
(0327) 	{
(0328) 	 	for(i=0;i<16;i++ )			//16行
    03A80 2766      CLR	R22
    03A81 C019      RJMP	0x3A9B
(0329) 		{
(0330) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03A82 2C2A      MOV	R2,R10
    03A83 2D82      MOV	R24,R2
    03A84 5F8F      SUBI	R24,0xFF
    03A85 2EA8      MOV	R10,R24
    03A86 8228      ST	Y,R2
    03A87 2722      CLR	R18
    03A88 2700      CLR	R16
    03A89 DF46      RCALL	_W_1byte
(0331) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03A8A 8348      ST	Y,R20
    03A8B 2722      CLR	R18
    03A8C 2700      CLR	R16
    03A8D DF42      RCALL	_W_1byte
(0332) 			for(j=0;j<16;j++)		//
    03A8E 24EE      CLR	R14
    03A8F C007      RJMP	0x3A97
(0333) 			{
(0334) 			 	W_1byte(0,1,0x00);	//清成不反白
    03A90 2422      CLR	R2
    03A91 8228      ST	Y,R2
    03A92 E021      LDI	R18,1
    03A93 2700      CLR	R16
    03A94 DF3B      RCALL	_W_1byte
(0335) 			 	nop();
    03A95 0000      NOP
    03A96 94E3      INC	R14
    03A97 2D8E      MOV	R24,R14
    03A98 3180      CPI	R24,0x10
    03A99 F3B0      BCS	0x3A90
    03A9A 9563      INC	R22
    03A9B 3160      CPI	R22,0x10
    03A9C F328      BCS	0x3A82
(0336) 			}
(0337) 		}
(0338) 	}
(0339) 	nop();
    03A9D 0000      NOP
(0340) //	
(0341) 	for(i=0;i<16;i++ )				//16行，因为是16*16汉字
    03A9E 2766      CLR	R22
    03A9F C022      RJMP	0x3AC2
(0342) 	{
(0343) 		W_1byte(0,0,white_y++);		//设置绘图区的Y地址坐标0
    03AA0 802A      LDD	R2,Y+2
    03AA1 2D82      MOV	R24,R2
    03AA2 5F8F      SUBI	R24,0xFF
    03AA3 838A      STD	Y+2,R24
    03AA4 8228      ST	Y,R2
    03AA5 2722      CLR	R18
    03AA6 2700      CLR	R16
    03AA7 DF28      RCALL	_W_1byte
(0344) 		W_1byte(0,0,white_x);		//设置绘图区的X地址坐标0
    03AA8 8009      LDD	R0,Y+1
    03AA9 8208      ST	Y,R0
    03AAA 2722      CLR	R18
    03AAB 2700      CLR	R16
    03AAC DF23      RCALL	_W_1byte
(0345) 		for(j=0;j<white_end_x;j++)	//
    03AAD 24EE      CLR	R14
    03AAE C010      RJMP	0x3ABF
(0346) 		{
(0347) 			 if(clear==1)
    03AAF 858F      LDD	R24,Y+15
    03AB0 3081      CPI	R24,1
    03AB1 F431      BNE	0x3AB8
(0348) 			 {
(0349) 			  	W_1byte(0,1,0x00); //取消这一行的8个点的反白，液晶地址自动加1
    03AB2 2422      CLR	R2
    03AB3 8228      ST	Y,R2
    03AB4 E021      LDI	R18,1
    03AB5 2700      CLR	R16
    03AB6 DF19      RCALL	_W_1byte
(0350) 								   //（此处行指一个一个液晶点所组成的行）
(0351) 			 }
    03AB7 C005      RJMP	0x3ABD
(0352) 			 else
(0353) 			 {
(0354) 				W_1byte(0,1,0xff); //反白这一行的8个点，液晶地址自动加1
    03AB8 EF8F      LDI	R24,0xFF
    03AB9 8388      ST	Y,R24
    03ABA E021      LDI	R18,1
    03ABB 2700      CLR	R16
    03ABC DF13      RCALL	_W_1byte
(0355) 								   //（此处行指一个一个液晶点所组成的行）
(0356) 			 }
(0357) 			nop();
    03ABD 0000      NOP
    03ABE 94E3      INC	R14
    03ABF 14EC      CP	R14,R12
    03AC0 F370      BCS	0x3AAF
    03AC1 9563      INC	R22
    03AC2 3160      CPI	R22,0x10
    03AC3 F2E0      BCS	0x3AA0
(0358) 		}
(0359) 	}
(0360) 	W_1byte(0,0,0x30);		//基本指令集,，绘图显示OFF
    03AC4 E380      LDI	R24,0x30
    03AC5 8388      ST	Y,R24
    03AC6 2722      CLR	R18
    03AC7 2700      CLR	R16
    03AC8 DF07      RCALL	_W_1byte
    03AC9 9623      ADIW	R28,3
    03ACA 940C 409C JMP	pop_xgsetF0FC
_set_white_n:
  tempendx             --> R10
  tempy                --> R22
  tempx                --> R20
  clear                --> R12
  n                    --> R14
    03ACC 940E 40A7 CALL	push_xgsetF0FC
    03ACE 2EC2      MOV	R12,R18
    03ACF 2EE0      MOV	R14,R16
    03AD0 9723      SBIW	R28,3
(0361)  }
(0362) 
(0363) /******************************************************************** 
(0364) 函数 名：set_white_n
(0365) 入口参数： n ,  clear
(0366) 出口参数：无 
(0367) 函数作用：   将四行分成八个位置。n代表位置1-8。本函数用于反显或取消反显
(0368)           某一位置的文字。
(0369) 说        明： 例如 set_white_n(1,0); 表示反显第一行前四个字
(0370) ********************************************************************/ 
(0371) void set_white_n(unsigned char n,unsigned char clear)
(0372) {
(0373) unsigned char tempx,tempy,tempendx;
(0374) if(n==1) {tempx=1;tempy=1;tempendx=4;}
    03AD1 2D8E      MOV	R24,R14
    03AD2 3081      CPI	R24,1
    03AD3 F429      BNE	0x3AD9
    03AD4 E041      LDI	R20,1
    03AD5 E061      LDI	R22,1
    03AD6 E084      LDI	R24,4
    03AD7 2EA8      MOV	R10,R24
    03AD8 C037      RJMP	0x3B10
(0375) else if(n==2) {tempx=5;tempy=1;tempendx=8;}
    03AD9 2D8E      MOV	R24,R14
    03ADA 3082      CPI	R24,2
    03ADB F429      BNE	0x3AE1
    03ADC E045      LDI	R20,5
    03ADD E061      LDI	R22,1
    03ADE E088      LDI	R24,0x8
    03ADF 2EA8      MOV	R10,R24
    03AE0 C02F      RJMP	0x3B10
(0376) else if(n==3) {tempx=1;tempy=2;tempendx=4;}
    03AE1 2D8E      MOV	R24,R14
    03AE2 3083      CPI	R24,3
    03AE3 F429      BNE	0x3AE9
    03AE4 E041      LDI	R20,1
    03AE5 E062      LDI	R22,2
    03AE6 E084      LDI	R24,4
    03AE7 2EA8      MOV	R10,R24
    03AE8 C027      RJMP	0x3B10
(0377) else if(n==4) {tempx=5;tempy=2;tempendx=8;}
    03AE9 2D8E      MOV	R24,R14
    03AEA 3084      CPI	R24,4
    03AEB F429      BNE	0x3AF1
    03AEC E045      LDI	R20,5
    03AED E062      LDI	R22,2
    03AEE E088      LDI	R24,0x8
    03AEF 2EA8      MOV	R10,R24
    03AF0 C01F      RJMP	0x3B10
(0378) else if(n==5) {tempx=1;tempy=3;tempendx=4;}
    03AF1 2D8E      MOV	R24,R14
    03AF2 3085      CPI	R24,5
    03AF3 F429      BNE	0x3AF9
    03AF4 E041      LDI	R20,1
    03AF5 E063      LDI	R22,3
    03AF6 E084      LDI	R24,4
    03AF7 2EA8      MOV	R10,R24
    03AF8 C017      RJMP	0x3B10
(0379) else if(n==6) {tempx=5;tempy=3;tempendx=8;}
    03AF9 2D8E      MOV	R24,R14
    03AFA 3086      CPI	R24,6
    03AFB F429      BNE	0x3B01
    03AFC E045      LDI	R20,5
    03AFD E063      LDI	R22,3
    03AFE E088      LDI	R24,0x8
    03AFF 2EA8      MOV	R10,R24
    03B00 C00F      RJMP	0x3B10
(0380) else if(n==7) {tempx=1;tempy=4;tempendx=4;}
    03B01 2D8E      MOV	R24,R14
    03B02 3087      CPI	R24,7
    03B03 F429      BNE	0x3B09
    03B04 E041      LDI	R20,1
    03B05 E064      LDI	R22,4
    03B06 E084      LDI	R24,4
    03B07 2EA8      MOV	R10,R24
    03B08 C007      RJMP	0x3B10
(0381) else if(n==8) {tempx=5;tempy=4;tempendx=8;}
    03B09 2D8E      MOV	R24,R14
    03B0A 3088      CPI	R24,0x8
    03B0B F421      BNE	0x3B10
    03B0C E045      LDI	R20,5
    03B0D E064      LDI	R22,4
    03B0E E088      LDI	R24,0x8
    03B0F 2EA8      MOV	R10,R24
(0382) Set_White(tempx,tempy,tempendx,clear);
    03B10 82CA      STD	Y+2,R12
    03B11 82A8      ST	Y,R10
    03B12 2F26      MOV	R18,R22
    03B13 2F04      MOV	R16,R20
    03B14 DF25      RCALL	_Set_White
    03B15 9623      ADIW	R28,3
    03B16 940C 409C JMP	pop_xgsetF0FC
_clr_white:
  clr_x                --> R10
  clr_y                --> R20
  i                    --> R22
  j                    --> R12
    03B18 940E 40A7 CALL	push_xgsetF0FC
    03B1A 9721      SBIW	R28,1
(0383) 
(0384) }
(0385)  
(0386) /******************************************************************** 
(0387) 函数 名：clr_white
(0388) 入口参数： 清所有 反白
(0389) 出口参数：无 
(0390) 函数作用： 
(0391) 说        明： 
(0392) ********************************************************************/ 
(0393) void clr_white(void)
(0394) {      unsigned char i,j;
(0395) 
(0396)        unsigned char  clr_y=0x80;
    03B1B E840      LDI	R20,0x80
(0397) 	   unsigned char  clr_x=0x80;
    03B1C E880      LDI	R24,0x80
    03B1D 2EA8      MOV	R10,R24
(0398) 	   W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03B1E E386      LDI	R24,0x36
    03B1F 8388      ST	Y,R24
    03B20 2722      CLR	R18
    03B21 2700      CLR	R16
    03B22 DEAD      RCALL	_W_1byte
(0399) 	 	for(i=0;i<16;i++ )			//16行
    03B23 2766      CLR	R22
    03B24 C017      RJMP	0x3B3C
(0400) 		{
(0401) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03B25 2E24      MOV	R2,R20
    03B26 5F4F      SUBI	R20,0xFF
    03B27 8228      ST	Y,R2
    03B28 2722      CLR	R18
    03B29 2700      CLR	R16
    03B2A DEA5      RCALL	_W_1byte
(0402) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03B2B 82A8      ST	Y,R10
    03B2C 2722      CLR	R18
    03B2D 2700      CLR	R16
    03B2E DEA1      RCALL	_W_1byte
(0403) 			for(j=0;j<16;j++)		//
    03B2F 24CC      CLR	R12
    03B30 C007      RJMP	0x3B38
(0404) 			{
(0405) 			 	W_1byte(0,1,0x00);	//清成不反白
    03B31 2422      CLR	R2
    03B32 8228      ST	Y,R2
    03B33 E021      LDI	R18,1
    03B34 2700      CLR	R16
    03B35 DE9A      RCALL	_W_1byte
(0406) 			 	nop();
    03B36 0000      NOP
    03B37 94C3      INC	R12
    03B38 2D8C      MOV	R24,R12
    03B39 3180      CPI	R24,0x10
    03B3A F3B0      BCS	0x3B31
    03B3B 9563      INC	R22
    03B3C 3160      CPI	R22,0x10
    03B3D F338      BCS	0x3B25
(0407) 			}
(0408) 		}
(0409) 	
(0410) 	    clr_y=0x80;
    03B3E E840      LDI	R20,0x80
(0411) 	    clr_x=0x90;
    03B3F E980      LDI	R24,0x90
    03B40 2EA8      MOV	R10,R24
(0412) 		 	for(i=0;i<16;i++ )			//16行
    03B41 2766      CLR	R22
    03B42 C017      RJMP	0x3B5A
(0413) 		{
(0414) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03B43 2E24      MOV	R2,R20
    03B44 5F4F      SUBI	R20,0xFF
    03B45 8228      ST	Y,R2
    03B46 2722      CLR	R18
    03B47 2700      CLR	R16
    03B48 DE87      RCALL	_W_1byte
(0415) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03B49 82A8      ST	Y,R10
    03B4A 2722      CLR	R18
    03B4B 2700      CLR	R16
    03B4C DE83      RCALL	_W_1byte
(0416) 			for(j=0;j<16;j++)		//
    03B4D 24CC      CLR	R12
    03B4E C007      RJMP	0x3B56
(0417) 			{
(0418) 			 	W_1byte(0,1,0x00);	//清成不反白
    03B4F 2422      CLR	R2
    03B50 8228      ST	Y,R2
    03B51 E021      LDI	R18,1
    03B52 2700      CLR	R16
    03B53 DE7C      RCALL	_W_1byte
(0419) 			 	nop();
    03B54 0000      NOP
    03B55 94C3      INC	R12
    03B56 2D8C      MOV	R24,R12
    03B57 3180      CPI	R24,0x10
    03B58 F3B0      BCS	0x3B4F
    03B59 9563      INC	R22
    03B5A 3160      CPI	R22,0x10
    03B5B F338      BCS	0x3B43
(0420) 			}
(0421) 		}   
(0422) 	   
(0423) 	     clr_y=0x88;
    03B5C E848      LDI	R20,0x88
(0424) 	     clr_x=0x80;
    03B5D E880      LDI	R24,0x80
    03B5E 2EA8      MOV	R10,R24
(0425) 		 	for(i=0;i<16;i++ )			//16行
    03B5F 2766      CLR	R22
    03B60 C017      RJMP	0x3B78
(0426) 		{
(0427) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03B61 2EE4      MOV	R14,R20
    03B62 5F4F      SUBI	R20,0xFF
    03B63 82E8      ST	Y,R14
    03B64 2722      CLR	R18
    03B65 2700      CLR	R16
    03B66 DE69      RCALL	_W_1byte
(0428) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03B67 82A8      ST	Y,R10
    03B68 2722      CLR	R18
    03B69 2700      CLR	R16
    03B6A DE65      RCALL	_W_1byte
(0429) 			for(j=0;j<16;j++)		//
    03B6B 24CC      CLR	R12
    03B6C C007      RJMP	0x3B74
(0430) 			{
(0431) 			 	W_1byte(0,1,0x00);	//清成不反白
    03B6D 2422      CLR	R2
    03B6E 8228      ST	Y,R2
    03B6F E021      LDI	R18,1
    03B70 2700      CLR	R16
    03B71 DE5E      RCALL	_W_1byte
(0432) 			 	nop();
    03B72 0000      NOP
    03B73 94C3      INC	R12
    03B74 2D8C      MOV	R24,R12
    03B75 3180      CPI	R24,0x10
    03B76 F3B0      BCS	0x3B6D
    03B77 9563      INC	R22
    03B78 3160      CPI	R22,0x10
    03B79 F338      BCS	0x3B61
(0433) 			}
(0434) 		} 
(0435) 	     clr_y=0x88;
    03B7A E848      LDI	R20,0x88
(0436) 	     clr_x=0x90;
    03B7B E980      LDI	R24,0x90
    03B7C 2EA8      MOV	R10,R24
(0437) 		 	for(i=0;i<16;i++ )			//16行
    03B7D 2766      CLR	R22
    03B7E C017      RJMP	0x3B96
(0438) 		{
(0439) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03B7F 2EE4      MOV	R14,R20
    03B80 5F4F      SUBI	R20,0xFF
    03B81 82E8      ST	Y,R14
    03B82 2722      CLR	R18
    03B83 2700      CLR	R16
    03B84 DE4B      RCALL	_W_1byte
(0440) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03B85 82A8      ST	Y,R10
    03B86 2722      CLR	R18
    03B87 2700      CLR	R16
    03B88 DE47      RCALL	_W_1byte
(0441) 			for(j=0;j<16;j++)		//
    03B89 24CC      CLR	R12
    03B8A C007      RJMP	0x3B92
(0442) 			{
(0443) 			 	W_1byte(0,1,0x00);	//清成不反白
    03B8B 2422      CLR	R2
    03B8C 8228      ST	Y,R2
    03B8D E021      LDI	R18,1
    03B8E 2700      CLR	R16
    03B8F DE40      RCALL	_W_1byte
(0444) 			 	nop();
    03B90 0000      NOP
    03B91 94C3      INC	R12
    03B92 2D8C      MOV	R24,R12
    03B93 3180      CPI	R24,0x10
    03B94 F3B0      BCS	0x3B8B
    03B95 9563      INC	R22
    03B96 3160      CPI	R22,0x10
    03B97 F338      BCS	0x3B7F
(0445) 			}
(0446) 		} 		
(0447)   W_1byte(0,0,0x30);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03B98 E380      LDI	R24,0x30
    03B99 8388      ST	Y,R24
    03B9A 2722      CLR	R18
    03B9B 2700      CLR	R16
    03B9C DE33      RCALL	_W_1byte
    03B9D 9621      ADIW	R28,1
    03B9E 940C 409C JMP	pop_xgsetF0FC
_LCD_print2num:
  a                    --> R12
  tem                  --> R20
  num                  --> R10
  y                    --> R14
  x                    --> R12
    03BA0 940E 40A9 CALL	push_xgset30FC
    03BA2 2EE2      MOV	R14,R18
    03BA3 2EC0      MOV	R12,R16
    03BA4 9721      SBIW	R28,1
    03BA5 84A9      LDD	R10,Y+9
(0448) 	}
(0449) /******************************************************************** 
(0450) 函数 名：LCD_print2num
(0451) 入口参数： 显示2数字
(0452) 出口参数：无 
(0453) 函数作用： 
(0454) 说        明： 
(0455) ********************************************************************/ 
(0456) void LCD_print2num(unsigned char x,unsigned char y,unsigned char num){
(0457) unsigned char tem;
(0458) unsigned char a; 
(0459) 
(0460) a=address(x,y);
    03BA6 2D2E      MOV	R18,R14
    03BA7 2D0C      MOV	R16,R12
    03BA8 DD40      RCALL	_address
    03BA9 2EC0      MOV	R12,R16
(0461) W_1byte(0,0,a);     //显示的地址 
    03BAA 82C8      ST	Y,R12
    03BAB 2722      CLR	R18
    03BAC 2700      CLR	R16
    03BAD DE22      RCALL	_W_1byte
(0462) tem=num/10;
    03BAE E01A      LDI	R17,0xA
    03BAF 2D0A      MOV	R16,R10
    03BB0 940E 4019 CALL	div8u
    03BB2 2F40      MOV	R20,R16
(0463) W_1byte(0,1,tem+0x30);
    03BB3 2F84      MOV	R24,R20
    03BB4 5D80      SUBI	R24,0xD0
    03BB5 8388      ST	Y,R24
    03BB6 E021      LDI	R18,1
    03BB7 2700      CLR	R16
    03BB8 DE17      RCALL	_W_1byte
(0464) tem=num%10;
    03BB9 E01A      LDI	R17,0xA
    03BBA 2D0A      MOV	R16,R10
    03BBB 940E 4017 CALL	mod8u
    03BBD 2F40      MOV	R20,R16
(0465) W_1byte(0,1,tem+0x30); 
    03BBE 2F84      MOV	R24,R20
    03BBF 5D80      SUBI	R24,0xD0
    03BC0 8388      ST	Y,R24
    03BC1 E021      LDI	R18,1
    03BC2 2700      CLR	R16
    03BC3 DE0C      RCALL	_W_1byte
(0466) W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03BC4 EF8F      LDI	R24,0xFF
    03BC5 8388      ST	Y,R24
    03BC6 2722      CLR	R18
    03BC7 2700      CLR	R16
    03BC8 DE07      RCALL	_W_1byte
    03BC9 9621      ADIW	R28,1
    03BCA 940C 4093 JMP	pop_xgset30FC
_LCD_print4num:
  tem                  --> R12
  num                  --> R14
  y                    --> R20
  x                    --> R10
    03BCC 940E 40A9 CALL	push_xgset30FC
    03BCE 2F42      MOV	R20,R18
    03BCF 2EA0      MOV	R10,R16
    03BD0 9721      SBIW	R28,1
    03BD1 84E9      LDD	R14,Y+9
    03BD2 84FA      LDD	R15,Y+10
(0467) }
(0468)  
(0469) /******************************************************************** 
(0470) 函数 名：LCD_print4num
(0471) 入口参数： 显示4数字
(0472) 出口参数：无 
(0473) 函数作用： 
(0474) 说        明： 
(0475) ********************************************************************/ 
(0476) void LCD_print4num(unsigned char x,unsigned char y,unsigned int num){
(0477) unsigned char tem;
(0478) tem=num/100;
    03BD3 E624      LDI	R18,0x64
    03BD4 E030      LDI	R19,0
    03BD5 0187      MOVW	R16,R14
    03BD6 940E 3F93 CALL	div16u
    03BD8 2EC0      MOV	R12,R16
(0479) LCD_print2num(x,y,tem);
    03BD9 82C8      ST	Y,R12
    03BDA 2F24      MOV	R18,R20
    03BDB 2D0A      MOV	R16,R10
    03BDC DFC3      RCALL	_LCD_print2num
(0480) 
(0481) tem=num%100;   
    03BDD E624      LDI	R18,0x64
    03BDE E030      LDI	R19,0
    03BDF 0187      MOVW	R16,R14
    03BE0 940E 3F91 CALL	mod16u
    03BE2 2EC0      MOV	R12,R16
(0482) LCD_print2num(x,y+1,tem);
    03BE3 82C8      ST	Y,R12
    03BE4 2F24      MOV	R18,R20
    03BE5 5F2F      SUBI	R18,0xFF
    03BE6 2D0A      MOV	R16,R10
    03BE7 DFB8      RCALL	_LCD_print2num
(0483) 
(0484) 
(0485)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03BE8 EF8F      LDI	R24,0xFF
    03BE9 8388      ST	Y,R24
    03BEA 2722      CLR	R18
    03BEB 2700      CLR	R16
    03BEC DDE3      RCALL	_W_1byte
    03BED 9621      ADIW	R28,1
    03BEE 940C 4093 JMP	pop_xgset30FC
_LCD_print:
  a                    --> R12
  ch                   --> R10
  y                    --> R14
  x                    --> R12
    03BF0 940E 40AB CALL	push_xgset00FC
    03BF2 2EE2      MOV	R14,R18
    03BF3 2EC0      MOV	R12,R16
    03BF4 9721      SBIW	R28,1
    03BF5 80AF      LDD	R10,Y+7
(0486) }
(0487)  
(0488) //////////////////////////////////////////////////////////////
(0489) 
(0490) /******************************************************************** 
(0491) 函数 名：LCD_print 
(0492) 入口参数： 显示1 ascii
(0493) 出口参数：无 
(0494) 函数作用： 
(0495) 说        明： 
(0496) ********************************************************************/ 
(0497) void LCD_print(unsigned char x,unsigned char y,unsigned char ch)
(0498) {  
(0499) unsigned char a; 
(0500) a=address(x,y);
    03BF6 2D2E      MOV	R18,R14
    03BF7 2D0C      MOV	R16,R12
    03BF8 DCF0      RCALL	_address
    03BF9 2EC0      MOV	R12,R16
(0501) W_1byte(0,0,a);     //显示的地址 
    03BFA 82C8      ST	Y,R12
    03BFB 2722      CLR	R18
    03BFC 2700      CLR	R16
    03BFD DDD2      RCALL	_W_1byte
(0502) W_1byte(0,1,ch); 
    03BFE 82A8      ST	Y,R10
    03BFF E021      LDI	R18,1
    03C00 2700      CLR	R16
    03C01 DDCE      RCALL	_W_1byte
    03C02 9621      ADIW	R28,1
    03C03 940C 408C JMP	pop_xgset00FC
_LCD_print1:
  ch                   --> R10
    03C05 92AA      ST	-Y,R10
    03C06 2EA0      MOV	R10,R16
    03C07 9721      SBIW	R28,1
(0503) 
(0504) 
(0505) 
(0506) }
(0507) /******************************************************************** 
(0508) 函数 名：LCD_print1 
(0509) 入口参数： 显示1 ascii
(0510) 出口参数：无 
(0511) 函数作用：接着上文地址显示，不重设地址 
(0512) 说        明： 
(0513) ********************************************************************/ 
(0514) void LCD_print1(char ch)
(0515) {  
(0516) W_1byte(0,1,ch); 
    03C08 82A8      ST	Y,R10
    03C09 E021      LDI	R18,1
    03C0A 2700      CLR	R16
    03C0B DDC4      RCALL	_W_1byte
    03C0C 9621      ADIW	R28,1
    03C0D 90A9      LD	R10,Y+
    03C0E 9508      RET
_lp:
  p                    --> R10
    03C0F 92AA      ST	-Y,R10
    03C10 92BA      ST	-Y,R11
    03C11 0158      MOVW	R10,R16
    03C12 9722      SBIW	R28,2
(0517) }
(0518) //////////////////////////////////////////////////////////////
(0519) 
(0520) 
(0521) 
(0522)  void lp(unsigned char *p)
(0523)  {
(0524)  static unsigned char *p1=" ",*p2=" ",*p3=" ",*p4=" ";
(0525)  p4=p3;
    03C13 9020 04E4 LDS	R2,lcd.c:p3
    03C15 9030 04E5 LDS	R3,lcd.c:p3+1
    03C17 9230 04E7 STS	lcd.c:p4+1,R3
    03C19 9220 04E6 STS	lcd.c:p4,R2
(0526)  p3=p2;
    03C1B 9020 04E2 LDS	R2,lcd.c:p2
    03C1D 9030 04E3 LDS	R3,lcd.c:p2+1
    03C1F 9230 04E5 STS	lcd.c:p3+1,R3
    03C21 9220 04E4 STS	lcd.c:p3,R2
(0527)  p2=p1;
    03C23 9020 04E0 LDS	R2,lcd.c:p1
    03C25 9030 04E1 LDS	R3,lcd.c:p1+1
    03C27 9230 04E3 STS	lcd.c:p2+1,R3
    03C29 9220 04E2 STS	lcd.c:p2,R2
(0528)  p1=p;
    03C2B 92B0 04E1 STS	lcd.c:p1+1,R11
    03C2D 92A0 04E0 STS	lcd.c:p1,R10
(0529)   LCD_const_disp(1,1,"                ");
    03C2F EE88      LDI	R24,0xE8
    03C30 E094      LDI	R25,4
    03C31 8399      STD	Y+1,R25
    03C32 8388      ST	Y,R24
    03C33 E021      LDI	R18,1
    03C34 E001      LDI	R16,1
    03C35 DCD4      RCALL	_LCD_const_disp
(0530)   LCD_const_disp(2,1,"                ");
    03C36 EE88      LDI	R24,0xE8
    03C37 E094      LDI	R25,4
    03C38 8399      STD	Y+1,R25
    03C39 8388      ST	Y,R24
    03C3A E021      LDI	R18,1
    03C3B E002      LDI	R16,2
    03C3C DCCD      RCALL	_LCD_const_disp
(0531)   LCD_const_disp(3,1,"                ");
    03C3D EE88      LDI	R24,0xE8
    03C3E E094      LDI	R25,4
    03C3F 8399      STD	Y+1,R25
    03C40 8388      ST	Y,R24
    03C41 E021      LDI	R18,1
    03C42 E003      LDI	R16,3
    03C43 DCC6      RCALL	_LCD_const_disp
(0532)   LCD_const_disp(4,1,"                ");
    03C44 EE88      LDI	R24,0xE8
    03C45 E094      LDI	R25,4
    03C46 8399      STD	Y+1,R25
    03C47 8388      ST	Y,R24
    03C48 E021      LDI	R18,1
    03C49 E004      LDI	R16,4
    03C4A DCBF      RCALL	_LCD_const_disp
(0533)   LCD_var_disp(1,1,p4);
    03C4B 9020 04E6 LDS	R2,lcd.c:p4
    03C4D 9030 04E7 LDS	R3,lcd.c:p4+1
    03C4F 8239      STD	Y+1,R3
    03C50 8228      ST	Y,R2
    03C51 E021      LDI	R18,1
    03C52 E001      LDI	R16,1
    03C53 DCE3      RCALL	_LCD_var_disp
(0534)   LCD_var_disp(2,1,p3);
    03C54 9020 04E4 LDS	R2,lcd.c:p3
    03C56 9030 04E5 LDS	R3,lcd.c:p3+1
    03C58 8239      STD	Y+1,R3
    03C59 8228      ST	Y,R2
    03C5A E021      LDI	R18,1
    03C5B E002      LDI	R16,2
    03C5C DCDA      RCALL	_LCD_var_disp
(0535)   LCD_var_disp(3,1,p2);
    03C5D 9020 04E2 LDS	R2,lcd.c:p2
    03C5F 9030 04E3 LDS	R3,lcd.c:p2+1
    03C61 8239      STD	Y+1,R3
    03C62 8228      ST	Y,R2
    03C63 E021      LDI	R18,1
    03C64 E003      LDI	R16,3
    03C65 DCD1      RCALL	_LCD_var_disp
(0536)   LCD_var_disp(4,1,p1);
    03C66 9020 04E0 LDS	R2,lcd.c:p1
    03C68 9030 04E1 LDS	R3,lcd.c:p1+1
    03C6A 8239      STD	Y+1,R3
    03C6B 8228      ST	Y,R2
    03C6C E021      LDI	R18,1
    03C6D E004      LDI	R16,4
    03C6E DCC8      RCALL	_LCD_var_disp
(0537)   delayms(300);
    03C6F E20C      LDI	R16,0x2C
    03C70 E011      LDI	R17,1
    03C71 940E 2407 CALL	_delayms
    03C73 9622      ADIW	R28,2
    03C74 90B9      LD	R11,Y+
    03C75 90A9      LD	R10,Y+
    03C76 9508      RET
FILE: D:\LQD\software\master\software_src\relay.c
(0001) #include "config.h"
(0002) /*继电器初始化
(0003) *设置端口
(0004) *初始化关闭
(0005) */
(0006) void relay_init(void){
(0007) 	
(0008) 		RELAY_DDR_SET() ;
_relay_init:
    03C77 9AA5      SBI	0x14,5
(0009) 		RELAY_OFF();
    03C78 98AD      CBI	0x15,5
    03C79 9508      RET
(0010) 		//state.Relay = 0;
(0011) 	}	
(0012) 
(0013) /*继电器控制
(0014) *传入 ： 温度
(0015) *传出 ： 当前继电器状态
(0016) *
(0017) */
(0018) unsigned char  relay(int temp)
(0019) {
(0020) 	if(temp<HEAT_THRESHOLD)
_relay:
  temp                 --> R16
    03C7A 3005      CPI	R16,5
    03C7B E0E0      LDI	R30,0
    03C7C 071E      CPC	R17,R30
    03C7D F41C      BGE	0x3C81
(0021) 	{
(0022) 	 		RELAY_DDR_SET();
    03C7E 9AA5      SBI	0x14,5
(0023) 			RELAY_ON();
    03C7F 9AAD      SBI	0x15,5
(0024) 			//state.Relay = 1 ;
(0025) 	}
    03C80 C002      RJMP	0x3C83
(0026) 	else
(0027) 	{
(0028) 	 	RELAY_DDR_SET();
    03C81 9AA5      SBI	0x14,5
(0029) 		RELAY_OFF();
    03C82 98AD      CBI	0x15,5
(0030) 		//state.Relay = 0 ;
(0031) 	}		
(0032) 	//return state.Relay;
(0033) 	return 0;
    03C83 2700      CLR	R16
    03C84 9508      RET
_beep:
  i                    --> R10
  short_beep           --> R12
  long_beep            --> R14
    03C85 940E 40AB CALL	push_xgset00FC
    03C87 2EC2      MOV	R12,R18
    03C88 2EE0      MOV	R14,R16
FILE: D:\LQD\software\master\software_src\beep.c
(0001) #include "config.h"
(0002) 
(0003) #define BEEP_PORT	PORTC
(0004) #define BEEP_PIN	6
(0005) #define BEEP_OFF() BEEP_PORT|=(1<<BEEP_PIN)
(0006) #define BEEP_ON()  BEEP_PORT&=~(1<<BEEP_PIN)
(0007) //楦ｅ
(0008) void beep(unsigned char long_beep,unsigned char short_beep)
(0009) { 
(0010) unsigned char i;
(0011) DDRB|=(1<<0);
    03C89 9AB8      SBI	0x17,0
(0012) for(i=0;i<long_beep;i++)
    03C8A 24AA      CLR	R10
    03C8B C00B      RJMP	0x3C97
(0013) {
(0014) BEEP_ON();  delayms(200);
    03C8C 98AE      CBI	0x15,6
    03C8D EC08      LDI	R16,0xC8
    03C8E E010      LDI	R17,0
    03C8F 940E 2407 CALL	_delayms
(0015) BEEP_OFF(); delayms(50);
    03C91 9AAE      SBI	0x15,6
    03C92 E302      LDI	R16,0x32
    03C93 E010      LDI	R17,0
    03C94 940E 2407 CALL	_delayms
    03C96 94A3      INC	R10
    03C97 14AE      CP	R10,R14
    03C98 F398      BCS	0x3C8C
(0016) }
(0017) delayms(100);
    03C99 E604      LDI	R16,0x64
    03C9A E010      LDI	R17,0
    03C9B 940E 2407 CALL	_delayms
(0018) for(i=0;i<short_beep;i++)
    03C9D 24AA      CLR	R10
    03C9E C00B      RJMP	0x3CAA
(0019) {
(0020) BEEP_ON();  delayms(80);
    03C9F 98AE      CBI	0x15,6
    03CA0 E500      LDI	R16,0x50
    03CA1 E010      LDI	R17,0
    03CA2 940E 2407 CALL	_delayms
(0021) BEEP_OFF(); delayms(50);
    03CA4 9AAE      SBI	0x15,6
    03CA5 E302      LDI	R16,0x32
    03CA6 E010      LDI	R17,0
    03CA7 940E 2407 CALL	_delayms
    03CA9 94A3      INC	R10
    03CAA 14AC      CP	R10,R12
    03CAB F398      BCS	0x3C9F
    03CAC 940C 408C JMP	pop_xgset00FC
_Delay_nus:
  i                    --> R20
  n                    --> R16
    03CAE 934A      ST	-Y,R20
    03CAF 935A      ST	-Y,R21
FILE: D:\LQD\software\master\software_src\DS18B20_driver.c
(0001) //------------------------------------------------------------------------------
(0002) // 文件名：DS18B20_driver.c
(0003) // 说明：  DS18B20驱动头文件
(0004) // 功能：  实现1-wire器件的读写
(0005) // 使用方法：   void Delay_nus(unsigned int n);             //延时n微秒函数
(0006) //              unsigned char reset_18B20(void);            //18B20复位
(0007) //              void write_bit_18B20(char bitval);          //写一位到18B20
(0008) //              unsigned char read_bit_18B20(void);         //读一位从18B20
(0009) //              void write_byte_18B20(unsigned char data);  //写一字节到18B20
(0010) //              unsigned char read_18B20(void);             //读一字节到18B20
(0011) //
(0012) // 运行平台：   AVR 8bit (M16已验证)
(0013) // 依存关系：   DS18B20_driver.h    DS18B20基本驱动头文件（函数声明）
(0014) // 移植人：     
(0015) // 最后修改：   
(0016) //------------------------------------------------------------------------------
(0017) 
(0018) #include "config.h"
(0019) #define DS18B20_PORT PORTG
(0020) #define DS18B20_PIN  PING
(0021) #define DS18B20_DDR  DDRG
(0022) #define CL_DQ   DS18B20_PORT&=~(1<<T_NUM)					   
(0023) #define SET_DQ  DS18B20_PORT|=(1<<T_NUM)			   
(0024) #define SET_OUT DS18B20_DDR|=(1<<T_NUM)				   
(0025) #define SET_IN  DS18B20_DDR&=~(1<<T_NUM)			   
(0026) #define IN_DQ   DS18B20_PIN&(1<<T_NUM)				  
(0027) unsigned char T_NUM=0;
(0028) 
(0029) 
(0030) //------------------------------------------------------------------------------
(0031) // 延时N微秒程序 供控制读写DS18B20时序使用
(0032) //------------------------------------------------------------------------------
(0033) void Delay_nus(unsigned int n)   
(0034) {  unsigned int i;
(0035) 	  for (i=0;i<n;i++) 
    03CB0 2744      CLR	R20
    03CB1 2755      CLR	R21
    03CB2 C005      RJMP	0x3CB8
(0036) 	  		{NOP();
    03CB3 0000      NOP
(0037) 						NOP();
    03CB4 0000      NOP
(0038) 						NOP();				        //20--300//比较接近
    03CB5 0000      NOP
    03CB6 5F4F      SUBI	R20,0xFF
    03CB7 4F5F      SBCI	R21,0xFF
    03CB8 1740      CP	R20,R16
    03CB9 0751      CPC	R21,R17
    03CBA F3C0      BCS	0x3CB3
    03CBB 9159      LD	R21,Y+
    03CBC 9149      LD	R20,Y+
    03CBD 9508      RET
_reset_18B20:
  bus_flag             --> R10
    03CBE 92AA      ST	-Y,R10
(0039) 					}
(0040) }
(0041) 
(0042) 
(0043) //------------------------------------------------------------------------------
(0044) // 1-wire总线复位
(0045) //------------------------------------------------------------------------------
(0046) unsigned char reset_18B20(void)
(0047) {
(0048) 	char bus_flag;
(0049) 	CLI();
    03CBF 94F8      BCLR	7
(0050) 	SET_DQ;
    03CC0 9110 04FB LDS	R17,T_NUM
    03CC2 E001      LDI	R16,1
    03CC3 940E 4135 CALL	lsl8
    03CC5 9020 0065 LDS	R2,0x65
    03CC7 2A20      OR	R2,R16
    03CC8 9220 0065 STS	0x65,R2
(0051) 	SET_OUT;
    03CCA 9110 04FB LDS	R17,T_NUM
    03CCC E001      LDI	R16,1
    03CCD 940E 4135 CALL	lsl8
    03CCF 9020 0064 LDS	R2,0x64
    03CD1 2A20      OR	R2,R16
    03CD2 9220 0064 STS	0x64,R2
(0052)  	
(0053)   	Delay_nus(1);
    03CD4 E001      LDI	R16,1
    03CD5 E010      LDI	R17,0
    03CD6 DFD7      RCALL	_Delay_nus
(0054)   	CL_DQ;
    03CD7 9110 04FB LDS	R17,T_NUM
    03CD9 E001      LDI	R16,1
    03CDA 940E 4135 CALL	lsl8
    03CDC 2E20      MOV	R2,R16
    03CDD 9420      COM	R2
    03CDE 9030 0065 LDS	R3,0x65
    03CE0 2032      AND	R3,R2
    03CE1 9230 0065 STS	0x65,R3
(0055)   	Delay_nus(550);		//拉低至少480us时间
    03CE3 E206      LDI	R16,0x26
    03CE4 E012      LDI	R17,2
    03CE5 DFC8      RCALL	_Delay_nus
(0056)   	SET_DQ;				//释放
    03CE6 9110 04FB LDS	R17,T_NUM
    03CE8 E001      LDI	R16,1
    03CE9 940E 4135 CALL	lsl8
    03CEB 9020 0065 LDS	R2,0x65
    03CED 2A20      OR	R2,R16
    03CEE 9220 0065 STS	0x65,R2
(0057) 					NOP();
    03CF0 0000      NOP
(0058) 					NOP();
    03CF1 0000      NOP
(0059)   	SET_IN;				//输入
    03CF2 9110 04FB LDS	R17,T_NUM
    03CF4 E001      LDI	R16,1
    03CF5 940E 4135 CALL	lsl8
    03CF7 2E20      MOV	R2,R16
    03CF8 9420      COM	R2
    03CF9 9030 0064 LDS	R3,0x64
    03CFB 2032      AND	R3,R2
    03CFC 9230 0064 STS	0x64,R3
(0060)   	Delay_nus(60);
    03CFE E30C      LDI	R16,0x3C
    03CFF E010      LDI	R17,0
    03D00 DFAD      RCALL	_Delay_nus
(0061)   	
(0062) 						//等待回复
(0063)   	bus_flag = IN_DQ;
    03D01 9110 04FB LDS	R17,T_NUM
    03D03 E001      LDI	R16,1
    03D04 940E 4135 CALL	lsl8
    03D06 90A0 0063 LDS	R10,0x63
    03D08 22A0      AND	R10,R16
(0064)   	
(0065)   	Delay_nus(240);		//回复的低电平在60到240US
    03D09 EF00      LDI	R16,0xF0
    03D0A E010      LDI	R17,0
    03D0B DFA2      RCALL	_Delay_nus
(0066)   	SET_OUT;
    03D0C 9110 04FB LDS	R17,T_NUM
    03D0E E001      LDI	R16,1
    03D0F 940E 4135 CALL	lsl8
    03D11 9020 0064 LDS	R2,0x64
    03D13 2A20      OR	R2,R16
    03D14 9220 0064 STS	0x64,R2
(0067) 					NOP();
    03D16 0000      NOP
(0068) 					NOP();
    03D17 0000      NOP
(0069)   	SET_DQ;				//回到初始DQ=1；
    03D18 9110 04FB LDS	R17,T_NUM
    03D1A E001      LDI	R16,1
    03D1B 940E 4135 CALL	lsl8
    03D1D 9020 0065 LDS	R2,0x65
    03D1F 2A20      OR	R2,R16
    03D20 9220 0065 STS	0x65,R2
(0070) 
(0071)   	SEI();
    03D22 9478      BSET	7
(0072) 	if(bus_flag){
    03D23 20AA      TST	R10
    03D24 F011      BEQ	0x3D27
(0073) 		return FALSE;
    03D25 2700      CLR	R16
    03D26 C001      RJMP	0x3D28
(0074) 	}else{
(0075) 		return TRUE;
    03D27 E001      LDI	R16,1
    03D28 90A9      LD	R10,Y+
    03D29 9508      RET
_write_bit_18B20:
  bitval               --> R10
    03D2A 92AA      ST	-Y,R10
    03D2B 2EA0      MOV	R10,R16
(0076) 	}
(0077) 
(0078) }
(0079) 
(0080) //------------------------------------------------------------------------------
(0081) // 写一位到总线
(0082) //------------------------------------------------------------------------------
(0083) void write_bit_18B20(char bitval)
(0084) {
(0085)     SET_OUT;
    03D2C 9110 04FB LDS	R17,T_NUM
    03D2E E001      LDI	R16,1
    03D2F 940E 4135 CALL	lsl8
    03D31 9020 0064 LDS	R2,0x64
    03D33 2A20      OR	R2,R16
    03D34 9220 0064 STS	0x64,R2
(0086) 					NOP();
    03D36 0000      NOP
(0087) 					NOP();
    03D37 0000      NOP
(0088) 			 CL_DQ;
    03D38 9110 04FB LDS	R17,T_NUM
    03D3A E001      LDI	R16,1
    03D3B 940E 4135 CALL	lsl8
    03D3D 2E20      MOV	R2,R16
    03D3E 9420      COM	R2
    03D3F 9030 0065 LDS	R3,0x65
    03D41 2032      AND	R3,R2
    03D42 9230 0065 STS	0x65,R3
(0089) 	   Delay_nus(1);
    03D44 E001      LDI	R16,1
    03D45 E010      LDI	R17,0
    03D46 DF67      RCALL	_Delay_nus
(0090) 	   if(bitval){    //写数据，从低位开始
    03D47 20AA      TST	R10
    03D48 F059      BEQ	0x3D54
(0091) 		     SET_DQ;
    03D49 9110 04FB LDS	R17,T_NUM
    03D4B E001      LDI	R16,1
    03D4C 940E 4135 CALL	lsl8
    03D4E 9020 0065 LDS	R2,0x65
    03D50 2A20      OR	R2,R16
    03D51 9220 0065 STS	0x65,R2
(0092) 	  }else{
    03D53 C00C      RJMP	0x3D60
(0093) 		     CL_DQ;
    03D54 9110 04FB LDS	R17,T_NUM
    03D56 E001      LDI	R16,1
    03D57 940E 4135 CALL	lsl8
    03D59 2E20      MOV	R2,R16
    03D5A 9420      COM	R2
    03D5B 9030 0065 LDS	R3,0x65
    03D5D 2032      AND	R3,R2
    03D5E 9230 0065 STS	0x65,R3
(0094) 	  }
(0095) 	Delay_nus(40);		//15~60us
    03D60 E208      LDI	R16,0x28
    03D61 E010      LDI	R17,0
    03D62 DF4B      RCALL	_Delay_nus
(0096) 	SET_DQ;
    03D63 9110 04FB LDS	R17,T_NUM
    03D65 E001      LDI	R16,1
    03D66 940E 4135 CALL	lsl8
    03D68 9020 0065 LDS	R2,0x65
    03D6A 2A20      OR	R2,R16
    03D6B 9220 0065 STS	0x65,R2
(0097) 	Delay_nus(10);
    03D6D E00A      LDI	R16,0xA
    03D6E E010      LDI	R17,0
    03D6F DF3E      RCALL	_Delay_nus
    03D70 90A9      LD	R10,Y+
    03D71 9508      RET
_read_bit_18B20:
  k                    --> R10
    03D72 92AA      ST	-Y,R10
(0098) }
(0099) 
(0100) //------------------------------------------------------------------------------
(0101) // 读一位从总线
(0102) //------------------------------------------------------------------------------
(0103) unsigned char read_bit_18B20(void)
(0104) {
(0105) 	unsigned char k;
(0106) 	SET_OUT;
    03D73 9110 04FB LDS	R17,T_NUM
    03D75 E001      LDI	R16,1
    03D76 940E 4135 CALL	lsl8
    03D78 9020 0064 LDS	R2,0x64
    03D7A 2A20      OR	R2,R16
    03D7B 9220 0064 STS	0x64,R2
(0107) 	CL_DQ;			//读时间片开始，拉低总线至少1us
    03D7D 9110 04FB LDS	R17,T_NUM
    03D7F E001      LDI	R16,1
    03D80 940E 4135 CALL	lsl8
    03D82 2E20      MOV	R2,R16
    03D83 9420      COM	R2
    03D84 9030 0065 LDS	R3,0x65
    03D86 2032      AND	R3,R2
    03D87 9230 0065 STS	0x65,R3
(0108) 	Delay_nus(1);
    03D89 E001      LDI	R16,1
    03D8A E010      LDI	R17,0
    03D8B DF22      RCALL	_Delay_nus
(0109) 	
(0110) 					//SET_DQ;	
(0111) 	SET_IN;
    03D8C 9110 04FB LDS	R17,T_NUM
    03D8E E001      LDI	R16,1
    03D8F 940E 4135 CALL	lsl8
    03D91 2E20      MOV	R2,R16
    03D92 9420      COM	R2
    03D93 9030 0064 LDS	R3,0x64
    03D95 2032      AND	R3,R2
    03D96 9230 0064 STS	0x64,R3
(0112) 	Delay_nus(4);
    03D98 E004      LDI	R16,4
    03D99 E010      LDI	R17,0
    03D9A DF13      RCALL	_Delay_nus
(0113) 	k=IN_DQ;    	//读数据,从低位开始
    03D9B 9110 04FB LDS	R17,T_NUM
    03D9D E001      LDI	R16,1
    03D9E 940E 4135 CALL	lsl8
    03DA0 90A0 0063 LDS	R10,0x63
    03DA2 22A0      AND	R10,R16
(0114) 	Delay_nus(10);
    03DA3 E00A      LDI	R16,0xA
    03DA4 E010      LDI	R17,0
    03DA5 DF08      RCALL	_Delay_nus
(0115) 	SET_DQ;	
    03DA6 9110 04FB LDS	R17,T_NUM
    03DA8 E001      LDI	R16,1
    03DA9 940E 4135 CALL	lsl8
    03DAB 9020 0065 LDS	R2,0x65
    03DAD 2A20      OR	R2,R16
    03DAE 9220 0065 STS	0x65,R2
(0116) 				NOP();
    03DB0 0000      NOP
(0117) 				NOP();
    03DB1 0000      NOP
(0118) 	SET_OUT;
    03DB2 9110 04FB LDS	R17,T_NUM
    03DB4 E001      LDI	R16,1
    03DB5 940E 4135 CALL	lsl8
    03DB7 9020 0064 LDS	R2,0x64
    03DB9 2A20      OR	R2,R16
    03DBA 9220 0064 STS	0x64,R2
(0119) 	    NOP();
    03DBC 0000      NOP
(0120) 					NOP();
    03DBD 0000      NOP
(0121) 	if(k){
    03DBE 20AA      TST	R10
    03DBF F011      BEQ	0x3DC2
(0122) 	    return 1;
    03DC0 E001      LDI	R16,1
    03DC1 C001      RJMP	0x3DC3
(0123) 	}else{
(0124) 	    return 0;
    03DC2 2700      CLR	R16
    03DC3 90A9      LD	R10,Y+
    03DC4 9508      RET
_write_byte_18B20:
  i                    --> R20
  data                 --> R10
    03DC5 92AA      ST	-Y,R10
    03DC6 934A      ST	-Y,R20
    03DC7 2EA0      MOV	R10,R16
(0125) 	}
(0126) 	
(0127) }
(0128) 
(0129) //------------------------------------------------------------------------------
(0130) // 写一个字节到总线
(0131) //------------------------------------------------------------------------------
(0132) void write_byte_18B20(unsigned char data)
(0133) {
(0134) 	unsigned char i;
(0135)    CLI();
    03DC8 94F8      BCLR	7
(0136)     for(i=0;i<8;i++)
    03DC9 2744      CLR	R20
    03DCA C009      RJMP	0x3DD4
(0137)     {
(0138)         write_bit_18B20(data&(1<<i));
    03DCB E001      LDI	R16,1
    03DCC 2F14      MOV	R17,R20
    03DCD 940E 4135 CALL	lsl8
    03DCF 2E20      MOV	R2,R16
    03DD0 2D0A      MOV	R16,R10
    03DD1 2102      AND	R16,R2
    03DD2 DF57      RCALL	_write_bit_18B20
    03DD3 9543      INC	R20
    03DD4 3048      CPI	R20,0x8
    03DD5 F3A8      BCS	0x3DCB
(0139)         
(0140)     }
(0141)     SET_DQ;
    03DD6 9110 04FB LDS	R17,T_NUM
    03DD8 E001      LDI	R16,1
    03DD9 940E 4135 CALL	lsl8
    03DDB 9020 0065 LDS	R2,0x65
    03DDD 2A20      OR	R2,R16
    03DDE 9220 0065 STS	0x65,R2
(0142) 				  NOP();
    03DE0 0000      NOP
(0143) 					 NOP();
    03DE1 0000      NOP
(0144)     SEI();
    03DE2 9478      BSET	7
    03DE3 9149      LD	R20,Y+
    03DE4 90A9      LD	R10,Y+
    03DE5 9508      RET
_read_byte_18B20:
  temp                 --> R10
  n                    --> R20
    03DE6 92AA      ST	-Y,R10
    03DE7 934A      ST	-Y,R20
(0145)     
(0146)     //return;
(0147) }
(0148) 
(0149) //------------------------------------------------------------------------------
(0150) // 读一个字节
(0151) //------------------------------------------------------------------------------
(0152) unsigned char read_byte_18B20(void)
(0153) {
(0154) 	unsigned char temp,n;
(0155)     CLI();
    03DE8 94F8      BCLR	7
(0156)   	temp=0;
    03DE9 24AA      CLR	R10
(0157)     for(n=0;n<8;n++)
    03DEA 2744      CLR	R20
    03DEB C014      RJMP	0x3E00
(0158)     {
(0159)       	if(read_bit_18B20()){
    03DEC DF85      RCALL	_read_bit_18B20
    03DED 2300      TST	R16
    03DEE F031      BEQ	0x3DF5
(0160)       		temp|=(1<<n);
    03DEF E001      LDI	R16,1
    03DF0 2F14      MOV	R17,R20
    03DF1 940E 4135 CALL	lsl8
    03DF3 2AA0      OR	R10,R16
(0161)       	}else{
    03DF4 C007      RJMP	0x3DFC
(0162)       		temp&=~(1<<n);
    03DF5 E001      LDI	R16,1
    03DF6 2F14      MOV	R17,R20
    03DF7 940E 4135 CALL	lsl8
    03DF9 2E20      MOV	R2,R16
    03DFA 9420      COM	R2
    03DFB 20A2      AND	R10,R2
(0163)       	}
(0164)       	Delay_nus(70); //60~120us
    03DFC E406      LDI	R16,0x46
    03DFD E010      LDI	R17,0
    03DFE DEAF      RCALL	_Delay_nus
    03DFF 9543      INC	R20
    03E00 3048      CPI	R20,0x8
    03E01 F350      BCS	0x3DEC
(0165)       	
(0166)    }
(0167)    SEI();
    03E02 9478      BSET	7
(0168) 
(0169)    return temp;
    03E03 2D0A      MOV	R16,R10
    03E04 9149      LD	R20,Y+
    03E05 90A9      LD	R10,Y+
    03E06 9508      RET
(0170) }
(0171) 
(0172) 
(0173) 
(0174) //------------------------------------------------------------------------------
(0175) // 应用函数部分！ 供外部调用
(0176) //------------------------------------------------------------------------------
(0177) //------------------------------------------------------------------------------
(0178) // 单器件/多器件：开始转换
(0179) //------------------------------------------------------------------------------
(0180) void convert_T(void)
(0181) {
(0182) 					if(reset_18B20()){
_convert_T:
    03E07 DEB6      RCALL	_reset_18B20
    03E08 2300      TST	R16
    03E09 F021      BEQ	0x3E0E
(0183) 					write_byte_18B20(0xcc);
    03E0A EC0C      LDI	R16,0xCC
    03E0B DFB9      RCALL	_write_byte_18B20
(0184) 					write_byte_18B20(0x44);
    03E0C E404      LDI	R16,0x44
    03E0D DFB7      RCALL	_write_byte_18B20
(0185) 					}
    03E0E 9508      RET
_read_T:
  sign                 --> Y,+1
  tmp                  --> Y,+0
  value                --> R10
    03E0F 940E 40AD CALL	push_xgset003C
    03E11 9724      SBIW	R28,4
(0186) }
(0187) 
(0188) //------------------------------------------------------------------------------
(0189) // 单器件：读温度，返回INIT8U型温度数据（原始数据）
(0190) //------------------------------------------------------------------------------
(0191) float read_T(void)
(0192) {
(0193)     unsigned int value=0;
    03E12 24AA      CLR	R10
    03E13 24BB      CLR	R11
(0194) 	unsigned char sign;
(0195) 	
(0196) 	float tmp;
(0197)     
(0198)     if(reset_18B20()){
    03E14 DEA9      RCALL	_reset_18B20
    03E15 2300      TST	R16
    03E16 F021      BEQ	0x3E1B
(0199)     	write_byte_18B20(0xcc);
    03E17 EC0C      LDI	R16,0xCC
    03E18 DFAC      RCALL	_write_byte_18B20
(0200)     	write_byte_18B20(0xbe);
    03E19 EB0E      LDI	R16,0xBE
    03E1A DFAA      RCALL	_write_byte_18B20
(0201)     }
(0202)     
(0203)     value = (unsigned int)read_byte_18B20();
    03E1B DFCA      RCALL	_read_byte_18B20
    03E1C 2EA0      MOV	R10,R16
    03E1D 24BB      CLR	R11
(0204)     value += ((unsigned int)(read_byte_18B20()))<<8;
    03E1E DFC7      RCALL	_read_byte_18B20
    03E1F 2EC0      MOV	R12,R16
    03E20 2C2C      MOV	R2,R12
    03E21 2433      CLR	R3
    03E22 2C32      MOV	R3,R2
    03E23 2422      CLR	R2
    03E24 0CA2      ADD	R10,R2
    03E25 1CB3      ADC	R11,R3
(0205) 	/*   if((value&0x8000)==0x8000) //负温度
(0206) 					{
(0207) 					 sign=0;
(0208) 					 data=(~data)+1;       //补码形式，取反加一
(0209) 					}
(0210) 		elae 
(0211) 					{
(0212) 					 sign=1;
(0213) 					}
(0214) 		 xiaoshu1=(unsigned char) ((data&0x000f)*10/16);
(0215) 		 zhengshu=(unsigned char) (data>>4); 
(0216) 		*/
(0217) 	tmp= ((float)value)*0.0625;
    03E26 EC08      LDI	R16,0xC8
    03E27 E010      LDI	R17,0
    03E28 940E 402F CALL	elpm32
    03E2A 0118      MOVW	R2,R16
    03E2B 0129      MOVW	R4,R18
    03E2C 0185      MOVW	R16,R10
    03E2D 940E 4201 CALL	uint2fp
    03E2F 933A      ST	-Y,R19
    03E30 932A      ST	-Y,R18
    03E31 931A      ST	-Y,R17
    03E32 930A      ST	-Y,R16
    03E33 0181      MOVW	R16,R2
    03E34 0192      MOVW	R18,R4
    03E35 940E 43A8 CALL	fpmule2
    03E37 8308      ST	Y,R16
    03E38 8319      STD	Y+1,R17
    03E39 832A      STD	Y+2,R18
    03E3A 833B      STD	Y+3,R19
(0218) 	
(0219)     return( tmp);
    03E3B 8108      LD	R16,Y
    03E3C 8119      LDD	R17,Y+1
    03E3D 812A      LDD	R18,Y+2
    03E3E 813B      LDD	R19,Y+3
    03E3F 9624      ADIW	R28,4
    03E40 940C 4087 JMP	pop_xgset003C
_read_T_NUM:
  ttemp                --> Y,+0
  NUM                  --> R10
    03E42 92AA      ST	-Y,R10
    03E43 2EA0      MOV	R10,R16
    03E44 9724      SBIW	R28,4
(0220) }
(0221) 
(0222) float read_T_NUM(unsigned char NUM){
(0223) float ttemp;
(0224) if ( NUM >1) return 123.45;
    03E45 E081      LDI	R24,1
    03E46 158A      CP	R24,R10
    03E47 F428      BCC	0x3E4D
    03E48 EC04      LDI	R16,0xC4
    03E49 E010      LDI	R17,0
    03E4A 940E 402F CALL	elpm32
    03E4C C010      RJMP	0x3E5D
(0225) T_NUM=NUM;//设置访问器件
    03E4D 92A0 04FB STS	T_NUM,R10
(0226) convert_T();//温度转换
    03E4F DFB7      RCALL	_convert_T
(0227) delayms(800);
    03E50 E200      LDI	R16,0x20
    03E51 E013      LDI	R17,3
    03E52 940E 2407 CALL	_delayms
(0228) ttemp=read_T();
    03E54 DFBA      RCALL	_read_T
    03E55 8308      ST	Y,R16
    03E56 8319      STD	Y+1,R17
    03E57 832A      STD	Y+2,R18
    03E58 833B      STD	Y+3,R19
(0229) return ttemp;
    03E59 8108      LD	R16,Y
    03E5A 8119      LDD	R17,Y+1
    03E5B 812A      LDD	R18,Y+2
    03E5C 813B      LDD	R19,Y+3
    03E5D 9624      ADIW	R28,4
    03E5E 90A9      LD	R10,Y+
    03E5F 9508      RET
FILE: D:\LQD\software\master\software_src\ds1302.c
(0001) #include "config.h"
(0002) 
(0003) #define TPORT PORTB
(0004) #define TDDR DDRB
(0005) #define TPIN PINB
(0006) #define PIN_RST	 4
(0007) #define PIN_IO	 5
(0008) #define PIN_SCK	 6
(0009) /******************复位脚*********************/
(0010) #define RST_CLR	TPORT &= ~(1 << PIN_RST)   /*电平置低*/
(0011) #define RST_SET	TPORT |= (1 << PIN_RST)    /*电平置高*/
(0012) #define RST_IN	TDDR &= ~(1 << PIN_RST)    /*方向输入*/
(0013) #define RST_OUT	TDDR |= (1 << PIN_RST)     /*方向输出*/
(0014) 
(0015) /*****************双向数据********************/
(0016) #define IO_CLR	TPORT &= ~(1 << PIN_IO)  /*电平置低*/
(0017) #define IO_SET	TPORT |= (1 << PIN_IO)   /*电平置高*/
(0018) #define IO_R	TPIN & (1 << PIN_IO)     /*电平读取*/
(0019) #define IO_IN	TDDR &= ~(1 << PIN_IO)   /*方向输入*/
(0020) #define IO_OUT	TDDR |= (1 << PIN_IO)    /*方向输出*/
(0021) 
(0022) /*****************时钟信号*******************/
(0023) #define SCK_CLR	TPORT &= ~(1 << PIN_SCK)  /*时钟信号*/
(0024) #define SCK_SET	TPORT |= (1 << PIN_SCK)   /*电平置高*/
(0025) #define SCK_IN	TDDR &= ~(1 << PIN_SCK)   /*方向输入*/
(0026) #define SCK_OUT	TDDR |= (1 << PIN_SCK)    /*方向输出*/
(0027) 
(0028) #define ds1302_sec_add			0x80		//秒数据地址
(0029) #define ds1302_min_add			0x82		//分数据地址
(0030) #define ds1302_hr_add			0x84		//时数据地址
(0031) #define ds1302_date_add			0x86		//日数据地址
(0032) #define ds1302_month_add		0x88		//月数据地址
(0033) #define ds1302_day_add			0x8a		//星期数据地址
(0034) #define ds1302_year_add			0x8c		//年数据地址
(0035) #define ds1302_control_add		0x8e		//控制数据地址
(0036) #define ds1302_charger_add		0x90 					 
(0037) #define ds1302_clkburst_add		0xbe
(0038) 
(0039) unsigned char time_buf[8] = {0x20,0x0c,0x0A,0x1c,0x22,0x46,0x00,0x06};
(0040) /*
(0041)  struct tm {
(0042)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0043)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0044) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0045) 	int tm_mday;  // 日 day of the month, 1 to 31
(0046) 	int tm_mon;   // 月 months since January, 0 to 11
(0047) 	int tm_year;  // 年 years since 1900
(0048) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0049) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0050)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0051)  	};	
(0052) 	*/
(0053) 
(0054) //DS1302初始化函数
(0055) void ds1302_init(void) 
(0056) {
(0057) 	RST_CLR;			/*RST脚置低*/
_ds1302_init:
    03E60 98C4      CBI	0x18,4
(0058) 	SCK_CLR;			/*SCK脚置低*/
    03E61 98C6      CBI	0x18,6
(0059) 	RST_OUT;			/*RST脚设置为输出*/
    03E62 9ABC      SBI	0x17,4
(0060) 	SCK_OUT;			/*SCK脚设置为输出*/
    03E63 9ABE      SBI	0x17,6
    03E64 9508      RET
_ds1302_write_byte:
  i                    --> R20
  d                    --> R18
  addr                 --> R16
    03E65 934A      ST	-Y,R20
(0061) }
(0062) 
(0063) //向DS1302写入一字节数据
(0064) void ds1302_write_byte(unsigned char addr, unsigned char d) {
(0065) 
(0066) 	unsigned char i;
(0067) 	RST_SET;					/*启动DS1302总线*/
    03E66 9AC4      SBI	0x18,4
(0068) 	
(0069) 	/*写入目标地址：addr*/
(0070) 	IO_OUT;
    03E67 9ABD      SBI	0x17,5
(0071) 	addr = addr & 0xFE;   //最低位置零，寄存器0位为0时写，为1时读
    03E68 7F0E      ANDI	R16,0xFE
(0072) 	for (i = 0; i < 8; i ++) {
    03E69 2744      CLR	R20
    03E6A C009      RJMP	0x3E74
(0073) 		if (addr & 0x01) {
    03E6B FF00      SBRS	R16,0
    03E6C C002      RJMP	0x3E6F
(0074) 			IO_SET;
    03E6D 9AC5      SBI	0x18,5
(0075) 			}
    03E6E C001      RJMP	0x3E70
(0076) 		else {
(0077) 			IO_CLR;
    03E6F 98C5      CBI	0x18,5
(0078) 			}
(0079) 		SCK_SET;      //产生时钟
    03E70 9AC6      SBI	0x18,6
(0080) 		SCK_CLR;
    03E71 98C6      CBI	0x18,6
(0081) 		addr = addr >> 1;
    03E72 9506      LSR	R16
    03E73 9543      INC	R20
    03E74 3048      CPI	R20,0x8
    03E75 F3A8      BCS	0x3E6B
(0082) 		}
(0083) 	
(0084) 	/*写入数据：d*/
(0085) 	IO_OUT;
    03E76 9ABD      SBI	0x17,5
(0086) 	for (i = 0; i < 8; i ++) {
    03E77 2744      CLR	R20
    03E78 C009      RJMP	0x3E82
(0087) 		if (d & 0x01) {
    03E79 FF20      SBRS	R18,0
    03E7A C002      RJMP	0x3E7D
(0088) 			IO_SET;
    03E7B 9AC5      SBI	0x18,5
(0089) 			}
    03E7C C001      RJMP	0x3E7E
(0090) 		else {
(0091) 			IO_CLR;
    03E7D 98C5      CBI	0x18,5
(0092) 			}
(0093) 		SCK_SET;    //产生时钟
    03E7E 9AC6      SBI	0x18,6
(0094) 		SCK_CLR;
    03E7F 98C6      CBI	0x18,6
(0095) 		d = d >> 1;
    03E80 9526      LSR	R18
    03E81 9543      INC	R20
    03E82 3048      CPI	R20,0x8
    03E83 F3A8      BCS	0x3E79
(0096) 		}
(0097) 	RST_CLR;		//停止DS1302总线
    03E84 98C4      CBI	0x18,4
    03E85 9149      LD	R20,Y+
    03E86 9508      RET
_ds1302_read_byte:
  temp                 --> R20
  i                    --> R22
  addr                 --> R16
    03E87 934A      ST	-Y,R20
    03E88 936A      ST	-Y,R22
(0098) 	
(0099) }
(0100) 
(0101) //从DS1302读出一字节数据
(0102) unsigned char ds1302_read_byte(unsigned char addr) {
(0103) 
(0104) 	unsigned char i;
(0105) 	unsigned char temp;
(0106) 	RST_SET;					/*启动DS1302总线*/
    03E89 9AC4      SBI	0x18,4
(0107) 
(0108) 	/*写入目标地址：addr*/
(0109) 	IO_OUT;
    03E8A 9ABD      SBI	0x17,5
(0110) 	addr = addr | 0x01;    //最低位置高，寄存器0位为0时写，为1时读
    03E8B 6001      ORI	R16,1
(0111) 	for (i = 0; i < 8; i ++) {
    03E8C 2766      CLR	R22
    03E8D C009      RJMP	0x3E97
(0112) 		if (addr & 0x01) {
    03E8E FF00      SBRS	R16,0
    03E8F C002      RJMP	0x3E92
(0113) 			IO_SET;
    03E90 9AC5      SBI	0x18,5
(0114) 			}
    03E91 C001      RJMP	0x3E93
(0115) 		else {
(0116) 			IO_CLR;
    03E92 98C5      CBI	0x18,5
(0117) 			}
(0118) 		SCK_SET;
    03E93 9AC6      SBI	0x18,6
(0119) 		SCK_CLR;
    03E94 98C6      CBI	0x18,6
(0120) 		addr = addr >> 1;
    03E95 9506      LSR	R16
    03E96 9563      INC	R22
    03E97 3068      CPI	R22,0x8
    03E98 F3A8      BCS	0x3E8E
(0121) 		}
(0122) 	
(0123) 	/*输出数据：temp*/
(0124) 	IO_IN;
    03E99 98BD      CBI	0x17,5
(0125) 	for (i = 0; i < 8; i ++) {
    03E9A 2766      CLR	R22
    03E9B C009      RJMP	0x3EA5
(0126) 		temp = temp >> 1;
    03E9C 9546      LSR	R20
(0127) 		if (IO_R) {
    03E9D 9BB5      SBIS	0x16,5
    03E9E C002      RJMP	0x3EA1
(0128) 			temp |= 0x80;
    03E9F 6840      ORI	R20,0x80
(0129) 			}
    03EA0 C001      RJMP	0x3EA2
(0130) 		else {
(0131) 			temp &= 0x7F;
    03EA1 774F      ANDI	R20,0x7F
(0132) 			}
(0133) 		SCK_SET;
    03EA2 9AC6      SBI	0x18,6
(0134) 		SCK_CLR;
    03EA3 98C6      CBI	0x18,6
    03EA4 9563      INC	R22
    03EA5 3068      CPI	R22,0x8
    03EA6 F3A8      BCS	0x3E9C
(0135) 		}
(0136) 	
(0137) 	RST_CLR;					/*停止DS1302总线*/
    03EA7 98C4      CBI	0x18,4
(0138) 	return temp;
    03EA8 2F04      MOV	R16,R20
    03EA9 9169      LD	R22,Y+
    03EAA 9149      LD	R20,Y+
    03EAB 9508      RET
(0139) }
(0140) 
(0141) //向DS302写入时钟数据
(0142) void ds1302_write_time(void) {
(0143) 
(0144) 	ds1302_write_byte(ds1302_control_add,0x00);			//关闭写保护 
_ds1302_write_time:
    03EAC 2722      CLR	R18
    03EAD E80E      LDI	R16,0x8E
    03EAE DFB6      RCALL	_ds1302_write_byte
(0145) 	ds1302_write_byte(ds1302_sec_add,0x80);				//暂停时钟 
    03EAF E820      LDI	R18,0x80
    03EB0 E800      LDI	R16,0x80
    03EB1 DFB3      RCALL	_ds1302_write_byte
(0146) 	//ds1302_write_byte(ds1302_charger_add,0xa9);	    //涓流充电 
(0147) 	ds1302_write_byte(ds1302_year_add,time_buf[1]);		//年 
    03EB2 9120 04FD LDS	R18,time_buf+1
    03EB4 E80C      LDI	R16,0x8C
    03EB5 DFAF      RCALL	_ds1302_write_byte
(0148) 	ds1302_write_byte(ds1302_month_add,time_buf[2]);	//月 
    03EB6 9120 04FE LDS	R18,time_buf+2
    03EB8 E808      LDI	R16,0x88
    03EB9 DFAB      RCALL	_ds1302_write_byte
(0149) 	ds1302_write_byte(ds1302_date_add,time_buf[3]);		//日 
    03EBA 9120 04FF LDS	R18,time_buf+3
    03EBC E806      LDI	R16,0x86
    03EBD DFA7      RCALL	_ds1302_write_byte
(0150) 	ds1302_write_byte(ds1302_hr_add,time_buf[4]);		//时 
    03EBE 9120 0500 LDS	R18,time_buf+4
    03EC0 E804      LDI	R16,0x84
    03EC1 DFA3      RCALL	_ds1302_write_byte
(0151) 	ds1302_write_byte(ds1302_min_add,time_buf[5]);		//分
    03EC2 9120 0501 LDS	R18,time_buf+5
    03EC4 E802      LDI	R16,0x82
    03EC5 DF9F      RCALL	_ds1302_write_byte
(0152) 	ds1302_write_byte(ds1302_sec_add,time_buf[6]);		//秒
    03EC6 9120 0502 LDS	R18,time_buf+6
    03EC8 E800      LDI	R16,0x80
    03EC9 DF9B      RCALL	_ds1302_write_byte
(0153) 	ds1302_write_byte(ds1302_day_add,time_buf[7]);		//周 
    03ECA 9120 0503 LDS	R18,time_buf+7
    03ECC E80A      LDI	R16,0x8A
    03ECD DF97      RCALL	_ds1302_write_byte
(0154) 	ds1302_write_byte(ds1302_control_add,0x80);			//打开写保护 
    03ECE E820      LDI	R18,0x80
    03ECF E80E      LDI	R16,0x8E
    03ED0 CF94      RJMP	_ds1302_write_byte
_ds1302_read_time:
    03ED1 92AA      ST	-Y,R10
    03ED2 934A      ST	-Y,R20
(0155) }
(0156) 
(0157) //从DS302读出时钟数据
(0158) void ds1302_read_time(void)  { 
(0159) 	time_buf[1]=ds1302_read_byte(ds1302_year_add);		//年 
    03ED3 E80C      LDI	R16,0x8C
    03ED4 DFB2      RCALL	_ds1302_read_byte
    03ED5 9300 04FD STS	time_buf+1,R16
(0160) 	time_buf[2]=ds1302_read_byte(ds1302_month_add);		//月 
    03ED7 E808      LDI	R16,0x88
    03ED8 DFAE      RCALL	_ds1302_read_byte
    03ED9 9300 04FE STS	time_buf+2,R16
(0161) 	time_buf[3]=ds1302_read_byte(ds1302_date_add);		//日 
    03EDB E806      LDI	R16,0x86
    03EDC DFAA      RCALL	_ds1302_read_byte
    03EDD 2EA0      MOV	R10,R16
    03EDE 92A0 04FF STS	time_buf+3,R10
(0162) 	time_buf[4]=ds1302_read_byte(ds1302_hr_add);		//时 
    03EE0 E804      LDI	R16,0x84
    03EE1 DFA5      RCALL	_ds1302_read_byte
    03EE2 2EA0      MOV	R10,R16
    03EE3 92A0 0500 STS	time_buf+4,R10
(0163) 	time_buf[5]=ds1302_read_byte(ds1302_min_add);		//分 
    03EE5 E802      LDI	R16,0x82
    03EE6 DFA0      RCALL	_ds1302_read_byte
    03EE7 2EA0      MOV	R10,R16
    03EE8 92A0 0501 STS	time_buf+5,R10
(0164) 	time_buf[6]=(ds1302_read_byte(ds1302_sec_add))&0x7F;//秒，屏蔽秒的第7位，避免超出59
    03EEA E800      LDI	R16,0x80
    03EEB DF9B      RCALL	_ds1302_read_byte
    03EEC 2F40      MOV	R20,R16
    03EED 2F84      MOV	R24,R20
    03EEE 778F      ANDI	R24,0x7F
    03EEF 9380 0502 STS	time_buf+6,R24
(0165) 	time_buf[7]=ds1302_read_byte(ds1302_day_add);		//周 
    03EF1 E80A      LDI	R16,0x8A
    03EF2 DF94      RCALL	_ds1302_read_byte
    03EF3 2EA0      MOV	R10,R16
    03EF4 92A0 0503 STS	time_buf+7,R10
    03EF6 9149      LD	R20,Y+
    03EF7 90A9      LD	R10,Y+
    03EF8 9508      RET
_kbscan:
  key                  --> R20
  temp                 --> Y,+0
    03EF9 934A      ST	-Y,R20
    03EFA 9724      SBIW	R28,4
FILE: D:\LQD\software\master\software_src\key.c
(0001) #include "config.h"
(0002) //键盘扫描函数
(0003) unsigned char kbscan(void)
(0004)   {
(0005)    unsigned char key;
(0006)    unsigned long temp=0;
    03EFB E080      LDI	R24,0
    03EFC 8388      ST	Y,R24
    03EFD 8389      STD	Y+1,R24
    03EFE 838A      STD	Y+2,R24
    03EFF 838B      STD	Y+3,R24
(0007)    DDR_SET;
    03F00 B38A      IN	R24,0x1A
    03F01 7087      ANDI	R24,7
    03F02 BB8A      OUT	0x1A,R24
(0008)    
(0009)    if((KEY_PIN) != KEY_MASK)         //检测A口按键引脚电平，如果全是高电平则退出
    03F03 B389      IN	R24,0x19
    03F04 718F      ANDI	R24,0x1F
    03F05 318F      CPI	R24,0x1F
    03F06 F189      BEQ	0x3F38
(0010)     {
(0011)      delayms(20);           //防抖
    03F07 E104      LDI	R16,0x14
    03F08 E010      LDI	R17,0
    03F09 940E 2407 CALL	_delayms
(0012)      if((KEY_PIN) != KEY_MASK )      //再次检测A口电平，如果不全是高电平则继续执行程序
    03F0B B389      IN	R24,0x19
    03F0C 718F      ANDI	R24,0x1F
    03F0D 318F      CPI	R24,0x1F
    03F0E F159      BEQ	0x3F3A
(0013)       {
(0014)        key = KEY_PIN ;          //读取PINA，将其存放在key中
    03F0F B349      IN	R20,0x19
    03F10 714F      ANDI	R20,0x1F
    03F11 C020      RJMP	0x3F32
(0015)         while((KEY_PIN) != KEY_MASK)
(0016) 		{
(0017) 		 temp++ ;
    03F12 E081      LDI	R24,1
    03F13 E090      LDI	R25,0
    03F14 E0A0      LDI	R26,0
    03F15 E0B0      LDI	R27,0
    03F16 8028      LD	R2,Y
    03F17 8039      LDD	R3,Y+1
    03F18 804A      LDD	R4,Y+2
    03F19 805B      LDD	R5,Y+3
    03F1A 0E28      ADD	R2,R24
    03F1B 1E39      ADC	R3,R25
    03F1C 1E4A      ADC	R4,R26
    03F1D 1E5B      ADC	R5,R27
    03F1E 8228      ST	Y,R2
    03F1F 8239      STD	Y+1,R3
    03F20 824A      STD	Y+2,R4
    03F21 825B      STD	Y+3,R5
(0018) 		 if(temp>LONGKEY) 
    03F22 E880      LDI	R24,0x80
    03F23 E398      LDI	R25,0x38
    03F24 E0A1      LDI	R26,1
    03F25 E0B0      LDI	R27,0
    03F26 8028      LD	R2,Y
    03F27 8039      LDD	R3,Y+1
    03F28 804A      LDD	R4,Y+2
    03F29 805B      LDD	R5,Y+3
    03F2A 1582      CP	R24,R2
    03F2B 0593      CPC	R25,R3
    03F2C 05A4      CPC	R26,R4
    03F2D 05B5      CPC	R27,R5
    03F2E F418      BCC	0x3F32
(0019) 		 {  return key+0x80;  };
    03F2F 2F04      MOV	R16,R20
    03F30 5800      SUBI	R16,0x80
    03F31 C009      RJMP	0x3F3B
    03F32 B389      IN	R24,0x19
    03F33 718F      ANDI	R24,0x1F
    03F34 318F      CPI	R24,0x1F
    03F35 F6E1      BNE	0x3F12
(0020) 		}
(0021) 		; //当前有按键处于按下状态，再按其他按键时程序维持当前状态 
(0022)       	
(0023) 		return key;
    03F36 2F04      MOV	R16,R20
    03F37 C003      RJMP	0x3F3B
(0024) 	  
(0025) 	  }
(0026)     }
(0027) 	else return NO_KEY;
    03F38 2700      CLR	R16
    03F39 C001      RJMP	0x3F3B
(0028) 	
(0029) 	return NO_KEY;
FILE: <library>
    03F3A 2700      CLR	R16
    03F3B 9624      ADIW	R28,4
    03F3C 9149      LD	R20,Y+
    03F3D 9508      RET
_memset:
    03F3E 8188      LD	R24,Y
    03F3F 8199      LDD	R25,Y+1
    03F40 3080      CPI	R24,0
    03F41 0789      CPC	R24,R25
    03F42 F029      BEQ	0x3F48
    03F43 2FE0      MOV	R30,R16
    03F44 2FF1      MOV	R31,R17
    03F45 9321      ST	Z+,R18
    03F46 9701      SBIW	R24,1
    03F47 F7E9      BNE	0x3F45
    03F48 9508      RET
_strcat:
    03F49 2FA0      MOV	R26,R16
    03F4A 2FB1      MOV	R27,R17
    03F4B 2FE2      MOV	R30,R18
    03F4C 2FF3      MOV	R31,R19
    03F4D 912D      LD	R18,X+
    03F4E 2322      TST	R18
    03F4F F7E9      BNE	0x3F4D
    03F50 9711      SBIW	R26,1
    03F51 9121      LD	R18,Z+
    03F52 932D      ST	X+,R18
    03F53 2322      TST	R18
    03F54 F7E1      BNE	0x3F51
    03F55 9508      RET
_strlen:
    03F56 2FE0      MOV	R30,R16
    03F57 2FF1      MOV	R31,R17
    03F58 27AA      CLR	R26
    03F59 27BB      CLR	R27
    03F5A 9001      LD	R0,Z+
    03F5B 2000      TST	R0
    03F5C F011      BEQ	0x3F5F
    03F5D 9611      ADIW	R26,1
    03F5E CFFB      RJMP	0x3F5A
    03F5F 2F0A      MOV	R16,R26
    03F60 2F1B      MOV	R17,R27
    03F61 9508      RET
push_arg4:
    03F62 933A      ST	-Y,R19
    03F63 932A      ST	-Y,R18
push_arg2:
    03F64 931A      ST	-Y,R17
    03F65 930A      ST	-Y,R16
    03F66 9508      RET
asr32:
    03F67 920F      PUSH	R0
    03F68 9009      LD	R0,Y+
    03F69 2000      TST	R0
    03F6A F031      BEQ	0x3F71
    03F6B 9535      ASR	R19
    03F6C 9527      ROR	R18
    03F6D 9517      ROR	R17
    03F6E 9507      ROR	R16
    03F6F 940A      DEC	R0
    03F70 CFF8      RJMP	0x3F69
    03F71 900F      POP	R0
    03F72 9508      RET
mod16s:
    03F73 9468      BSET	6
    03F74 92DA      ST	-Y,R13
    03F75 2ED1      MOV	R13,R17
    03F76 C004      RJMP	0x3F7B
div16s:
    03F77 94E8      BCLR	6
    03F78 92DA      ST	-Y,R13
    03F79 2ED1      MOV	R13,R17
    03F7A 26D3      EOR	R13,R19
    03F7B FF17      SBRS	R17,7
    03F7C C004      RJMP	0x3F81
    03F7D 9510      COM	R17
    03F7E 9500      COM	R16
    03F7F 5F0F      SUBI	R16,0xFF
    03F80 4F1F      SBCI	R17,0xFF
    03F81 FF37      SBRS	R19,7
    03F82 C004      RJMP	0x3F87
    03F83 9530      COM	R19
    03F84 9520      COM	R18
    03F85 5F2F      SUBI	R18,0xFF
    03F86 4F3F      SBCI	R19,0xFF
    03F87 940E 3F94 CALL	xdiv16u
    03F89 FED7      SBRS	R13,7
    03F8A C004      RJMP	0x3F8F
    03F8B 9510      COM	R17
    03F8C 9500      COM	R16
    03F8D 5F0F      SUBI	R16,0xFF
    03F8E 4F1F      SBCI	R17,0xFF
    03F8F 90D9      LD	R13,Y+
    03F90 9508      RET
mod16u:
    03F91 9468      BSET	6
    03F92 C001      RJMP	xdiv16u
div16u:
    03F93 94E8      BCLR	6
xdiv16u:
    03F94 92EA      ST	-Y,R14
    03F95 92FA      ST	-Y,R15
    03F96 938A      ST	-Y,R24
    03F97 24EE      CLR	R14
    03F98 24FF      CLR	R15
    03F99 E180      LDI	R24,0x10
    03F9A 0F00      LSL	R16
    03F9B 1F11      ROL	R17
    03F9C 1CEE      ROL	R14
    03F9D 1CFF      ROL	R15
    03F9E 16E2      CP	R14,R18
    03F9F 06F3      CPC	R15,R19
    03FA0 F018      BCS	0x3FA4
    03FA1 1AE2      SUB	R14,R18
    03FA2 0AF3      SBC	R15,R19
    03FA3 9503      INC	R16
    03FA4 958A      DEC	R24
    03FA5 F7A1      BNE	0x3F9A
    03FA6 F416      BRTC	0x3FA9
    03FA7 2D0E      MOV	R16,R14
    03FA8 2D1F      MOV	R17,R15
    03FA9 9189      LD	R24,Y+
    03FAA 90F9      LD	R15,Y+
    03FAB 90E9      LD	R14,Y+
    03FAC 9508      RET
div32u:
    03FAD 94E8      BCLR	6
    03FAE C001      RJMP	0x3FB0
mod32u:
    03FAF 9468      BSET	6
    03FB0 D030      RCALL	long_div_prolog
    03FB1 24CC      CLR	R12
    03FB2 C009      RJMP	0x3FBC
div32s:
    03FB3 94E8      BCLR	6
    03FB4 C001      RJMP	0x3FB6
mod32s:
    03FB5 9468      BSET	6
    03FB6 D02A      RCALL	long_div_prolog
    03FB7 FD37      SBRC	R19,7
    03FB8 940E 40F4 CALL	neg32
    03FBA FDB7      SBRC	R27,7
    03FBB D052      RCALL	neg_R24_R27
    03FBC 2477      CLR	R7
    03FBD 2488      CLR	R8
    03FBE 2499      CLR	R9
    03FBF 24AA      CLR	R10
    03FC0 24BB      CLR	R11
    03FC1 D042      RCALL	tst_R16_R19
    03FC2 F0C1      BEQ	0x3FDB
    03FC3 D045      RCALL	tst_R24_R27
    03FC4 F0B1      BEQ	0x3FDB
    03FC5 E2E8      LDI	R30,0x28
    03FC6 0F00      LSL	R16
    03FC7 1F11      ROL	R17
    03FC8 1F22      ROL	R18
    03FC9 1F33      ROL	R19
    03FCA 1C77      ROL	R7
    03FCB 1C88      ROL	R8
    03FCC 1C99      ROL	R9
    03FCD 1CAA      ROL	R10
    03FCE 1CBB      ROL	R11
    03FCF 1688      CP	R8,R24
    03FD0 0699      CPC	R9,R25
    03FD1 06AA      CPC	R10,R26
    03FD2 06BB      CPC	R11,R27
    03FD3 F028      BCS	0x3FD9
    03FD4 1A88      SUB	R8,R24
    03FD5 0A99      SBC	R9,R25
    03FD6 0AAA      SBC	R10,R26
    03FD7 0ABB      SBC	R11,R27
    03FD8 9503      INC	R16
    03FD9 95EA      DEC	R30
    03FDA F759      BNE	0x3FC6
    03FDB F426      BRTC	0x3FE0
    03FDC 2D08      MOV	R16,R8
    03FDD 2D19      MOV	R17,R9
    03FDE 2D2A      MOV	R18,R10
    03FDF 2D3B      MOV	R19,R11
    03FE0 C013      RJMP	long_div_epilog
long_div_prolog:
    03FE1 927A      ST	-Y,R7
    03FE2 928A      ST	-Y,R8
    03FE3 929A      ST	-Y,R9
    03FE4 92AA      ST	-Y,R10
    03FE5 92BA      ST	-Y,R11
    03FE6 92CA      ST	-Y,R12
    03FE7 93EA      ST	-Y,R30
    03FE8 938A      ST	-Y,R24
    03FE9 939A      ST	-Y,R25
    03FEA 93AA      ST	-Y,R26
    03FEB 93BA      ST	-Y,R27
    03FEC 858B      LDD	R24,Y+11
    03FED 859C      LDD	R25,Y+12
    03FEE 85AD      LDD	R26,Y+13
    03FEF 85BE      LDD	R27,Y+14
    03FF0 2EC3      MOV	R12,R19
    03FF1 F00E      BRTS	0x3FF3
    03FF2 26CB      EOR	R12,R27
    03FF3 9508      RET
long_div_epilog:
    03FF4 FCC7      SBRC	R12,7
    03FF5 940E 40F4 CALL	neg32
    03FF7 91B9      LD	R27,Y+
    03FF8 91A9      LD	R26,Y+
    03FF9 9199      LD	R25,Y+
    03FFA 9189      LD	R24,Y+
    03FFB 91E9      LD	R30,Y+
    03FFC 90C9      LD	R12,Y+
    03FFD 90B9      LD	R11,Y+
    03FFE 90A9      LD	R10,Y+
    03FFF 9099      LD	R9,Y+
    04000 9089      LD	R8,Y+
    04001 9079      LD	R7,Y+
    04002 9624      ADIW	R28,4
    04003 9508      RET
tst_R16_R19:
    04004 2FE0      MOV	R30,R16
    04005 2BE1      OR	R30,R17
    04006 2BE2      OR	R30,R18
    04007 2BE3      OR	R30,R19
    04008 9508      RET
tst_R24_R27:
    04009 2FE8      MOV	R30,R24
    0400A 2BE9      OR	R30,R25
    0400B 2BEA      OR	R30,R26
    0400C 2BEB      OR	R30,R27
    0400D 9508      RET
neg_R24_R27:
    0400E 9580      COM	R24
    0400F 9590      COM	R25
    04010 95A0      COM	R26
    04011 95B0      COM	R27
    04012 5F8F      SUBI	R24,0xFF
    04013 4F9F      SBCI	R25,0xFF
    04014 4FAF      SBCI	R26,0xFF
    04015 4FBF      SBCI	R27,0xFF
    04016 9508      RET
mod8u:
    04017 9468      BSET	6
    04018 C001      RJMP	xdiv8u
div8u:
    04019 94E8      BCLR	6
xdiv8u:
    0401A 932A      ST	-Y,R18
    0401B 92FA      ST	-Y,R15
    0401C 92EA      ST	-Y,R14
    0401D 24FF      CLR	R15
    0401E 24EE      CLR	R14
    0401F E120      LDI	R18,0x10
    04020 0F00      LSL	R16
    04021 1CFF      ROL	R15
    04022 1CEE      ROL	R14
    04023 16E1      CP	R14,R17
    04024 F010      BCS	0x4027
    04025 1AE1      SUB	R14,R17
    04026 9503      INC	R16
    04027 952A      DEC	R18
    04028 F7B9      BNE	0x4020
    04029 F40E      BRTC	0x402B
    0402A 2D0E      MOV	R16,R14
    0402B 90E9      LD	R14,Y+
    0402C 90F9      LD	R15,Y+
    0402D 9129      LD	R18,Y+
    0402E 9508      RET
elpm32:
    0402F 93EA      ST	-Y,R30
    04030 93FA      ST	-Y,R31
    04031 920A      ST	-Y,R0
    04032 2FE0      MOV	R30,R16
    04033 2FF1      MOV	R31,R17
    04034 95D8      ELPM
    04035 2D00      MOV	R16,R0
    04036 9631      ADIW	R30,1
    04037 95D8      ELPM
    04038 2D10      MOV	R17,R0
    04039 9631      ADIW	R30,1
    0403A 95D8      ELPM
    0403B 2D20      MOV	R18,R0
    0403C 9631      ADIW	R30,1
    0403D 95D8      ELPM
    0403E 2D30      MOV	R19,R0
    0403F 9009      LD	R0,Y+
    04040 91F9      LD	R31,Y+
    04041 91E9      LD	R30,Y+
    04042 9508      RET
empy16s:
    04043 920A      ST	-Y,R0
    04044 921A      ST	-Y,R1
    04045 938A      ST	-Y,R24
    04046 939A      ST	-Y,R25
    04047 9F02      MUL	R16,R18
    04048 01C0      MOVW	R24,R0
    04049 9F12      MUL	R17,R18
    0404A 0D90      ADD	R25,R0
    0404B 9F03      MUL	R16,R19
    0404C 0D90      ADD	R25,R0
    0404D 018C      MOVW	R16,R24
    0404E 9199      LD	R25,Y+
    0404F 9189      LD	R24,Y+
    04050 9019      LD	R1,Y+
    04051 9009      LD	R0,Y+
    04052 9508      RET
empy32u|empy32s:
    04053 940E 40FD CALL	long_prolog
    04055 927A      ST	-Y,R7
    04056 940E 4116 CALL	tstzero1
    04058 F159      BEQ	0x4084
    04059 2477      CLR	R7
    0405A 940E 411C CALL	tstzero2
    0405C F419      BNE	0x4060
    0405D 018C      MOVW	R16,R24
    0405E 019D      MOVW	R18,R26
    0405F C024      RJMP	0x4084
    04060 920A      ST	-Y,R0
    04061 921A      ST	-Y,R1
    04062 9F08      MUL	R16,R24
    04063 2CB0      MOV	R11,R0
    04064 2CA1      MOV	R10,R1
    04065 9F28      MUL	R18,R24
    04066 2C90      MOV	R9,R0
    04067 2C81      MOV	R8,R1
    04068 9F18      MUL	R17,R24
    04069 0CA0      ADD	R10,R0
    0406A 1C91      ADC	R9,R1
    0406B 1C87      ADC	R8,R7
    0406C 9F09      MUL	R16,R25
    0406D 0CA0      ADD	R10,R0
    0406E 1C91      ADC	R9,R1
    0406F 1C87      ADC	R8,R7
    04070 9F19      MUL	R17,R25
    04071 0C90      ADD	R9,R0
    04072 1C81      ADC	R8,R1
    04073 9F0A      MUL	R16,R26
    04074 0C90      ADD	R9,R0
    04075 1C81      ADC	R8,R1
    04076 9F38      MUL	R19,R24
    04077 0C80      ADD	R8,R0
    04078 9F29      MUL	R18,R25
    04079 0C80      ADD	R8,R0
    0407A 9F1A      MUL	R17,R26
    0407B 0C80      ADD	R8,R0
    0407C 9F0B      MUL	R16,R27
    0407D 0C80      ADD	R8,R0
    0407E 9019      LD	R1,Y+
    0407F 9009      LD	R0,Y+
    04080 2D0B      MOV	R16,R11
    04081 2D1A      MOV	R17,R10
    04082 2D29      MOV	R18,R9
    04083 2D38      MOV	R19,R8
    04084 9079      LD	R7,Y+
    04085 940C 410B JMP	long_epilog
pop_xgset003C:
    04087 90A9      LD	R10,Y+
    04088 90B9      LD	R11,Y+
    04089 90C9      LD	R12,Y+
    0408A 90D9      LD	R13,Y+
    0408B 9508      RET
pop_xgset00FC:
    0408C 90A9      LD	R10,Y+
    0408D 90B9      LD	R11,Y+
    0408E 90C9      LD	R12,Y+
    0408F 90D9      LD	R13,Y+
    04090 90E9      LD	R14,Y+
    04091 90F9      LD	R15,Y+
    04092 9508      RET
pop_xgset30FC:
    04093 90A9      LD	R10,Y+
    04094 90B9      LD	R11,Y+
    04095 90C9      LD	R12,Y+
    04096 90D9      LD	R13,Y+
    04097 90E9      LD	R14,Y+
    04098 90F9      LD	R15,Y+
    04099 9149      LD	R20,Y+
    0409A 9159      LD	R21,Y+
    0409B 9508      RET
pop_xgsetF0FC:
    0409C 90A9      LD	R10,Y+
    0409D 90B9      LD	R11,Y+
    0409E 90C9      LD	R12,Y+
    0409F 90D9      LD	R13,Y+
    040A0 90E9      LD	R14,Y+
    040A1 90F9      LD	R15,Y+
    040A2 9149      LD	R20,Y+
    040A3 9159      LD	R21,Y+
    040A4 9169      LD	R22,Y+
    040A5 9179      LD	R23,Y+
    040A6 9508      RET
push_xgsetF0FC:
    040A7 937A      ST	-Y,R23
    040A8 936A      ST	-Y,R22
push_xgset30FC:
    040A9 935A      ST	-Y,R21
    040AA 934A      ST	-Y,R20
push_xgset00FC:
    040AB 92FA      ST	-Y,R15
    040AC 92EA      ST	-Y,R14
push_xgset003C:
    040AD 92DA      ST	-Y,R13
    040AE 92CA      ST	-Y,R12
    040AF 92BA      ST	-Y,R11
    040B0 92AA      ST	-Y,R10
    040B1 9508      RET
push_xgset300C:
    040B2 935A      ST	-Y,R21
    040B3 934A      ST	-Y,R20
    040B4 92BA      ST	-Y,R11
    040B5 92AA      ST	-Y,R10
    040B6 9508      RET
pop_xgset300C:
    040B7 90A9      LD	R10,Y+
    040B8 90B9      LD	R11,Y+
    040B9 9149      LD	R20,Y+
    040BA 9159      LD	R21,Y+
    040BB 9508      RET
push_xgsetF000:
    040BC 937A      ST	-Y,R23
    040BD 936A      ST	-Y,R22
    040BE 935A      ST	-Y,R21
    040BF 934A      ST	-Y,R20
    040C0 9508      RET
pop_xgsetF000:
    040C1 9149      LD	R20,Y+
    040C2 9159      LD	R21,Y+
    040C3 9169      LD	R22,Y+
    040C4 9179      LD	R23,Y+
    040C5 9508      RET
push_xgsetF00C:
    040C6 937A      ST	-Y,R23
    040C7 936A      ST	-Y,R22
    040C8 935A      ST	-Y,R21
    040C9 934A      ST	-Y,R20
    040CA 92BA      ST	-Y,R11
    040CB 92AA      ST	-Y,R10
    040CC 9508      RET
pop_xgsetF00C:
    040CD 90A9      LD	R10,Y+
    040CE 90B9      LD	R11,Y+
    040CF 9149      LD	R20,Y+
    040D0 9159      LD	R21,Y+
    040D1 9169      LD	R22,Y+
    040D2 9179      LD	R23,Y+
    040D3 9508      RET
push_xgset303C:
    040D4 935A      ST	-Y,R21
    040D5 934A      ST	-Y,R20
    040D6 92DA      ST	-Y,R13
    040D7 92CA      ST	-Y,R12
    040D8 92BA      ST	-Y,R11
    040D9 92AA      ST	-Y,R10
    040DA 9508      RET
pop_xgset303C:
    040DB 90A9      LD	R10,Y+
    040DC 90B9      LD	R11,Y+
    040DD 90C9      LD	R12,Y+
    040DE 90D9      LD	R13,Y+
    040DF 9149      LD	R20,Y+
    040E0 9159      LD	R21,Y+
    040E1 9508      RET
push_xgsetF03C:
    040E2 937A      ST	-Y,R23
    040E3 936A      ST	-Y,R22
    040E4 935A      ST	-Y,R21
    040E5 934A      ST	-Y,R20
    040E6 92DA      ST	-Y,R13
    040E7 92CA      ST	-Y,R12
    040E8 92BA      ST	-Y,R11
    040E9 92AA      ST	-Y,R10
    040EA 9508      RET
pop_xgsetF03C:
    040EB 90A9      LD	R10,Y+
    040EC 90B9      LD	R11,Y+
    040ED 90C9      LD	R12,Y+
    040EE 90D9      LD	R13,Y+
    040EF 9149      LD	R20,Y+
    040F0 9159      LD	R21,Y+
    040F1 9169      LD	R22,Y+
    040F2 9179      LD	R23,Y+
    040F3 9508      RET
neg32:
    040F4 9500      COM	R16
    040F5 9510      COM	R17
    040F6 9520      COM	R18
    040F7 9530      COM	R19
    040F8 5F0F      SUBI	R16,0xFF
    040F9 4F1F      SBCI	R17,0xFF
    040FA 4F2F      SBCI	R18,0xFF
    040FB 4F3F      SBCI	R19,0xFF
    040FC 9508      RET
long_prolog:
    040FD 928A      ST	-Y,R8
    040FE 929A      ST	-Y,R9
    040FF 92AA      ST	-Y,R10
    04100 92BA      ST	-Y,R11
    04101 93EA      ST	-Y,R30
    04102 938A      ST	-Y,R24
    04103 939A      ST	-Y,R25
    04104 93AA      ST	-Y,R26
    04105 93BA      ST	-Y,R27
    04106 8589      LDD	R24,Y+9
    04107 859A      LDD	R25,Y+10
    04108 85AB      LDD	R26,Y+11
    04109 85BC      LDD	R27,Y+12
    0410A 9508      RET
long_epilog:
    0410B 91B9      LD	R27,Y+
    0410C 91A9      LD	R26,Y+
    0410D 9199      LD	R25,Y+
    0410E 9189      LD	R24,Y+
    0410F 91E9      LD	R30,Y+
    04110 90B9      LD	R11,Y+
    04111 90A9      LD	R10,Y+
    04112 9099      LD	R9,Y+
    04113 9089      LD	R8,Y+
    04114 9624      ADIW	R28,4
    04115 9508      RET
tstzero1:
    04116 27EE      CLR	R30
    04117 2BE0      OR	R30,R16
    04118 2BE1      OR	R30,R17
    04119 2BE2      OR	R30,R18
    0411A 2BE3      OR	R30,R19
    0411B 9508      RET
tstzero2:
    0411C 27EE      CLR	R30
    0411D 2BE8      OR	R30,R24
    0411E 2BE9      OR	R30,R25
    0411F 2BEA      OR	R30,R26
    04120 2BEB      OR	R30,R27
    04121 9508      RET
lsl16:
    04122 2322      TST	R18
    04123 F021      BEQ	0x4128
    04124 0F00      LSL	R16
    04125 1F11      ROL	R17
    04126 952A      DEC	R18
    04127 CFFA      RJMP	lsl16
    04128 9508      RET
lsl32:
    04129 920F      PUSH	R0
    0412A 9009      LD	R0,Y+
    0412B 2000      TST	R0
    0412C F031      BEQ	0x4133
    0412D 0F00      LSL	R16
    0412E 1F11      ROL	R17
    0412F 1F22      ROL	R18
    04130 1F33      ROL	R19
    04131 940A      DEC	R0
    04132 CFF8      RJMP	0x412B
    04133 900F      POP	R0
    04134 9508      RET
lsl8:
    04135 2311      TST	R17
    04136 F019      BEQ	0x413A
    04137 0F00      LSL	R16
    04138 951A      DEC	R17
    04139 CFFB      RJMP	lsl8
    0413A 9508      RET
lsr16:
    0413B 2322      TST	R18
    0413C F021      BEQ	0x4141
    0413D 9516      LSR	R17
    0413E 9507      ROR	R16
    0413F 952A      DEC	R18
    04140 CFFA      RJMP	lsr16
    04141 9508      RET
lsr32:
    04142 920F      PUSH	R0
    04143 9009      LD	R0,Y+
    04144 2000      TST	R0
    04145 F031      BEQ	0x414C
    04146 9536      LSR	R19
    04147 9527      ROR	R18
    04148 9517      ROR	R17
    04149 9507      ROR	R16
    0414A 940A      DEC	R0
    0414B CFF8      RJMP	0x4144
    0414C 900F      POP	R0
    0414D 9508      RET
asgnblk:
    0414E 93AA      ST	-Y,R26
    0414F 93BA      ST	-Y,R27
    04150 93EA      ST	-Y,R30
    04151 93FA      ST	-Y,R31
    04152 920A      ST	-Y,R0
    04153 81AF      LDD	R26,Y+7
    04154 85B8      LDD	R27,Y+8
    04155 81ED      LDD	R30,Y+5
    04156 81FE      LDD	R31,Y+6
    04157 3000      CPI	R16,0
    04158 0701      CPC	R16,R17
    04159 F029      BEQ	0x415F
    0415A 9001      LD	R0,Z+
    0415B 920D      ST	X+,R0
    0415C 5001      SUBI	R16,1
    0415D 4010      SBCI	R17,0
    0415E CFF8      RJMP	0x4157
    0415F 9009      LD	R0,Y+
    04160 91F9      LD	R31,Y+
    04161 91E9      LD	R30,Y+
    04162 91B9      LD	R27,Y+
    04163 91A9      LD	R26,Y+
    04164 9624      ADIW	R28,4
    04165 9508      RET
fpsub:
    04166 9468      BSET	6
    04167 C001      RJMP	fpadd_alt
fpadd:
    04168 94E8      BCLR	6
fpadd_alt:
    04169 940E 432D CALL	saveFPRegs
    0416B 940E 42BF CALL	unpacks
    0416D F409      BNE	0x416F
    0416E C048      RJMP	0x41B7
    0416F 2CE6      MOV	R14,R6
    04170 2CD5      MOV	R13,R5
    04171 2CC4      MOV	R12,R4
    04172 2EB3      MOV	R11,R19
    04173 2EA2      MOV	R10,R18
    04174 2E91      MOV	R9,R17
    04175 2E80      MOV	R8,R16
    04176 8100      LD	R16,Z
    04177 8111      LDD	R17,Z+1
    04178 8122      LDD	R18,Z+2
    04179 8133      LDD	R19,Z+3
    0417A 940E 42BF CALL	unpacks
    0417C F409      BNE	0x417E
    0417D C044      RJMP	0x41C2
    0417E 2D84      MOV	R24,R4
    0417F 2D95      MOV	R25,R5
    04180 198C      SUB	R24,R12
    04181 099D      SBC	R25,R13
    04182 F0B9      BEQ	0x419A
    04183 F472      BPL	0x4192
    04184 9590      COM	R25
    04185 9580      COM	R24
    04186 9601      ADIW	R24,1
    04187 2C4C      MOV	R4,R12
    04188 2C5D      MOV	R5,R13
    04189 3188      CPI	R24,0x18
    0418A F5B8      BCC	0x41C2
    0418B 9535      ASR	R19
    0418C 9527      ROR	R18
    0418D 9517      ROR	R17
    0418E 9507      ROR	R16
    0418F 9701      SBIW	R24,1
    04190 F7D1      BNE	0x418B
    04191 C008      RJMP	0x419A
    04192 3188      CPI	R24,0x18
    04193 F518      BCC	0x41B7
    04194 94B5      ASR	R11
    04195 94A7      ROR	R10
    04196 9497      ROR	R9
    04197 9487      ROR	R8
    04198 9701      SBIW	R24,1
    04199 F7D1      BNE	0x4194
    0419A 2466      CLR	R6
    0419B F02E      BRTS	0x41A1
    0419C 0D08      ADD	R16,R8
    0419D 1D19      ADC	R17,R9
    0419E 1D2A      ADC	R18,R10
    0419F 1D3B      ADC	R19,R11
    041A0 C009      RJMP	0x41AA
    041A1 1A80      SUB	R8,R16
    041A2 0A91      SBC	R9,R17
    041A3 0AA2      SBC	R10,R18
    041A4 0AB3      SBC	R11,R19
    041A5 2D08      MOV	R16,R8
    041A6 2D19      MOV	R17,R9
    041A7 2D2A      MOV	R18,R10
    041A8 2D3B      MOV	R19,R11
    041A9 2333      TST	R19
    041AA F422      BPL	0x41AF
    041AB 940E 40F4 CALL	neg32
    041AD E880      LDI	R24,0x80
    041AE 2E68      MOV	R6,R24
    041AF 940E 42E8 CALL	normalize_and_pack
    041B1 C002      RJMP	0x41B4
    041B2 940E 431D CALL	pack
    041B4 940E 433C CALL	restoreFPRegs
    041B6 9508      RET
    041B7 8100      LD	R16,Z
    041B8 8111      LDD	R17,Z+1
    041B9 8122      LDD	R18,Z+2
    041BA 8133      LDD	R19,Z+3
    041BB F7C6      BRTC	0x41B4
    041BC 940E 42C7 CALL	tstR16_R19
    041BE F3A9      BEQ	0x41B4
    041BF E880      LDI	R24,0x80
    041C0 2738      EOR	R19,R24
    041C1 CFF2      RJMP	0x41B4
    041C2 2D08      MOV	R16,R8
    041C3 2D19      MOV	R17,R9
    041C4 2D2A      MOV	R18,R10
    041C5 2D3B      MOV	R19,R11
    041C6 2C4C      MOV	R4,R12
    041C7 2C5D      MOV	R5,R13
    041C8 2C6E      MOV	R6,R14
    041C9 2333      TST	R19
    041CA F73A      BPL	0x41B2
    041CB 940E 40F4 CALL	neg32
    041CD E880      LDI	R24,0x80
    041CE 2E68      MOV	R6,R24
    041CF CFE2      RJMP	0x41B2
fpadd2:
    041D0 93FA      ST	-Y,R31
    041D1 93EA      ST	-Y,R30
    041D2 2FEC      MOV	R30,R28
    041D3 2FFD      MOV	R31,R29
    041D4 9632      ADIW	R30,2
    041D5 940E 4168 CALL	fpadd
    041D7 91E9      LD	R30,Y+
    041D8 91F9      LD	R31,Y+
    041D9 9624      ADIW	R28,4
    041DA 9508      RET
fpsub2:
    041DB 93FA      ST	-Y,R31
    041DC 93EA      ST	-Y,R30
    041DD 2FEC      MOV	R30,R28
    041DE 2FFD      MOV	R31,R29
    041DF 9632      ADIW	R30,2
    041E0 940E 4166 CALL	fpsub
    041E2 91E9      LD	R30,Y+
    041E3 91F9      LD	R31,Y+
    041E4 9624      ADIW	R28,4
    041E5 9508      RET
fpsub1x:
    041E6 93FA      ST	-Y,R31
    041E7 93EA      ST	-Y,R30
    041E8 81EA      LDD	R30,Y+2
    041E9 81FB      LDD	R31,Y+3
    041EA 940E 4166 CALL	fpsub
    041EC 91E9      LD	R30,Y+
    041ED 91F9      LD	R31,Y+
    041EE 8339      STD	Y+1,R19
    041EF 8328      ST	Y,R18
    041F0 931A      ST	-Y,R17
    041F1 930A      ST	-Y,R16
    041F2 9508      RET
fpsub2x:
    041F3 93FA      ST	-Y,R31
    041F4 93EA      ST	-Y,R30
    041F5 2FEC      MOV	R30,R28
    041F6 2FFD      MOV	R31,R29
    041F7 9632      ADIW	R30,2
    041F8 940E 4166 CALL	fpsub
    041FA 91E9      LD	R30,Y+
    041FB 91F9      LD	R31,Y+
    041FC 833B      STD	Y+3,R19
    041FD 832A      STD	Y+2,R18
    041FE 8319      STD	Y+1,R17
    041FF 8308      ST	Y,R16
    04200 9508      RET
uint2fp:
    04201 9468      BSET	6
    04202 C001      RJMP	0x4204
int2fp:
    04203 94E8      BCLR	6
    04204 2722      CLR	R18
    04205 2733      CLR	R19
    04206 F046      BRTS	0x420F
    04207 FD17      SBRC	R17,7
    04208 9520      COM	R18
    04209 FD17      SBRC	R17,7
    0420A 9530      COM	R19
    0420B C003      RJMP	0x420F
ulong2fp:
    0420C 9468      BSET	6
    0420D C001      RJMP	0x420F
long2fp:
    0420E 94E8      BCLR	6
    0420F 924A      ST	-Y,R4
    04210 925A      ST	-Y,R5
    04211 926A      ST	-Y,R6
    04212 938A      ST	-Y,R24
    04213 E187      LDI	R24,0x17
    04214 2E48      MOV	R4,R24
    04215 2455      CLR	R5
    04216 2466      CLR	R6
    04217 F036      BRTS	0x421E
    04218 2333      TST	R19
    04219 F422      BPL	0x421E
    0421A 940E 40F4 CALL	neg32
    0421C E880      LDI	R24,0x80
    0421D 2E68      MOV	R6,R24
    0421E 940E 42E8 CALL	normalize_and_pack
    04220 9189      LD	R24,Y+
    04221 9069      LD	R6,Y+
    04222 9059      LD	R5,Y+
    04223 9049      LD	R4,Y+
    04224 9508      RET
fpdiv1:
    04225 93FA      ST	-Y,R31
    04226 93EA      ST	-Y,R30
    04227 81EA      LDD	R30,Y+2
    04228 81FB      LDD	R31,Y+3
    04229 D027      RCALL	0x4251
    0422A 91E9      LD	R30,Y+
    0422B 91F9      LD	R31,Y+
    0422C 9622      ADIW	R28,2
    0422D 9508      RET
fpdiv2:
    0422E 93FA      ST	-Y,R31
    0422F 93EA      ST	-Y,R30
    04230 2FEC      MOV	R30,R28
    04231 2FFD      MOV	R31,R29
    04232 9632      ADIW	R30,2
    04233 D01D      RCALL	0x4251
    04234 91E9      LD	R30,Y+
    04235 91F9      LD	R31,Y+
    04236 9624      ADIW	R28,4
    04237 9508      RET
fpdiv1x:
    04238 93FA      ST	-Y,R31
    04239 93EA      ST	-Y,R30
    0423A 81EA      LDD	R30,Y+2
    0423B 81FB      LDD	R31,Y+3
    0423C D014      RCALL	0x4251
    0423D 91E9      LD	R30,Y+
    0423E 91F9      LD	R31,Y+
    0423F 8339      STD	Y+1,R19
    04240 8328      ST	Y,R18
    04241 931A      ST	-Y,R17
    04242 930A      ST	-Y,R16
    04243 9508      RET
fpdiv2x:
    04244 93FA      ST	-Y,R31
    04245 93EA      ST	-Y,R30
    04246 2FEC      MOV	R30,R28
    04247 2FFD      MOV	R31,R29
    04248 9632      ADIW	R30,2
    04249 D007      RCALL	0x4251
    0424A 91E9      LD	R30,Y+
    0424B 91F9      LD	R31,Y+
    0424C 833B      STD	Y+3,R19
    0424D 832A      STD	Y+2,R18
    0424E 8319      STD	Y+1,R17
    0424F 8308      ST	Y,R16
    04250 9508      RET
    04251 920A      ST	-Y,R0
    04252 921A      ST	-Y,R1
    04253 922A      ST	-Y,R2
    04254 923A      ST	-Y,R3
    04255 940E 432D CALL	saveFPRegs
    04257 933A      ST	-Y,R19
    04258 932A      ST	-Y,R18
    04259 931A      ST	-Y,R17
    0425A 930A      ST	-Y,R16
    0425B 8100      LD	R16,Z
    0425C 8111      LDD	R17,Z+1
    0425D 8122      LDD	R18,Z+2
    0425E 8133      LDD	R19,Z+3
    0425F 940E 42CF CALL	unpacku
    04261 F409      BNE	0x4263
    04262 C057      RJMP	0x42BA
    04263 2CE6      MOV	R14,R6
    04264 2CD5      MOV	R13,R5
    04265 2CC4      MOV	R12,R4
    04266 2EB3      MOV	R11,R19
    04267 2EA2      MOV	R10,R18
    04268 2E91      MOV	R9,R17
    04269 2E80      MOV	R8,R16
    0426A 9109      LD	R16,Y+
    0426B 9119      LD	R17,Y+
    0426C 9129      LD	R18,Y+
    0426D 9139      LD	R19,Y+
    0426E 940E 42CF CALL	unpacku
    04270 F1A1      BEQ	0x42A5
    04271 246E      EOR	R6,R14
    04272 184C      SUB	R4,R12
    04273 085D      SBC	R5,R13
    04274 E880      LDI	R24,0x80
    04275 1648      CP	R4,R24
    04276 0653      CPC	R5,R19
    04277 F00C      BLT	0x4279
    04278 C033      RJMP	0x42AC
    04279 E881      LDI	R24,0x81
    0427A 1648      CP	R4,R24
    0427B EF8F      LDI	R24,0xFF
    0427C 0658      CPC	R5,R24
    0427D F40C      BGE	0x427F
    0427E C036      RJMP	0x42B5
    0427F E280      LDI	R24,0x20
    04280 2433      CLR	R3
    04281 2E23      MOV	R2,R19
    04282 2E12      MOV	R1,R18
    04283 2E01      MOV	R0,R17
    04284 2F30      MOV	R19,R16
    04285 2722      CLR	R18
    04286 2711      CLR	R17
    04287 2700      CLR	R16
    04288 9426      LSR	R2
    04289 9417      ROR	R1
    0428A 9407      ROR	R0
    0428B 9537      ROR	R19
    0428C 9527      ROR	R18
    0428D 0F00      LSL	R16
    0428E 1F11      ROL	R17
    0428F 1F22      ROL	R18
    04290 1F33      ROL	R19
    04291 1C00      ROL	R0
    04292 1C11      ROL	R1
    04293 1C22      ROL	R2
    04294 1C33      ROL	R3
    04295 F028      BCS	0x429B
    04296 1808      SUB	R0,R8
    04297 0819      SBC	R1,R9
    04298 082A      SBC	R2,R10
    04299 083B      SBC	R3,R11
    0429A C004      RJMP	0x429F
    0429B 0C08      ADD	R0,R8
    0429C 1C19      ADC	R1,R9
    0429D 1C2A      ADC	R2,R10
    0429E 1C3B      ADC	R3,R11
    0429F F00A      BMI	0x42A1
    042A0 6001      ORI	R16,1
    042A1 958A      DEC	R24
    042A2 F751      BNE	0x428D
    042A3 940E 42E8 CALL	normalize_and_pack
    042A5 940E 433C CALL	restoreFPRegs
    042A7 9039      LD	R3,Y+
    042A8 9029      LD	R2,Y+
    042A9 9019      LD	R1,Y+
    042AA 9009      LD	R0,Y+
    042AB 9508      RET
    042AC EF0F      LDI	R16,0xFF
    042AD 2F10      MOV	R17,R16
    042AE E72F      LDI	R18,0x7F
    042AF E73F      LDI	R19,0x7F
    042B0 2066      TST	R6
    042B1 F399      BEQ	0x42A5
    042B2 940E 40F4 CALL	neg32
    042B4 CFF0      RJMP	0x42A5
    042B5 2700      CLR	R16
    042B6 2F10      MOV	R17,R16
    042B7 2F20      MOV	R18,R16
    042B8 2F30      MOV	R19,R16
    042B9 CFEB      RJMP	0x42A5
    042BA 9109      LD	R16,Y+
    042BB 9119      LD	R17,Y+
    042BC 9129      LD	R18,Y+
    042BD 9139      LD	R19,Y+
    042BE CFED      RJMP	0x42AC
unpacks:
    042BF D00F      RCALL	unpacku
    042C0 F029      BEQ	0x42C6
    042C1 2066      TST	R6
    042C2 F011      BEQ	0x42C5
    042C3 940E 40F4 CALL	neg32
    042C5 9498      BCLR	1
    042C6 9508      RET
tstR16_R19:
    042C7 2300      TST	R16
    042C8 F429      BNE	0x42CE
    042C9 2311      TST	R17
    042CA F419      BNE	0x42CE
    042CB 2322      TST	R18
    042CC F409      BNE	0x42CE
    042CD 2333      TST	R19
    042CE 9508      RET
unpacku:
    042CF DFF7      RCALL	tstR16_R19
    042D0 F099      BEQ	0x42E4
    042D1 938A      ST	-Y,R24
    042D2 2E63      MOV	R6,R19
    042D3 E880      LDI	R24,0x80
    042D4 2268      AND	R6,R24
    042D5 0F22      LSL	R18
    042D6 1F33      ROL	R19
    042D7 2E43      MOV	R4,R19
    042D8 E78F      LDI	R24,0x7F
    042D9 1A48      SUB	R4,R24
    042DA 2455      CLR	R5
    042DB 2788      CLR	R24
    042DC 0A58      SBC	R5,R24
    042DD 9526      LSR	R18
    042DE E830      LDI	R19,0x80
    042DF 2B23      OR	R18,R19
    042E0 2733      CLR	R19
    042E1 9189      LD	R24,Y+
    042E2 9498      BCLR	1
    042E3 9508      RET
    042E4 2444      CLR	R4
    042E5 2455      CLR	R5
    042E6 2466      CLR	R6
    042E7 9508      RET
normalize_and_pack:
    042E8 DFDE      RCALL	tstR16_R19
    042E9 F409      BNE	0x42EB
    042EA 9508      RET
    042EB 93AA      ST	-Y,R26
    042EC 93BA      ST	-Y,R27
    042ED 01D2      MOVW	R26,R4
    042EE 939A      ST	-Y,R25
    042EF 938A      ST	-Y,R24
    042F0 E78E      LDI	R24,0x7E
    042F1 E090      LDI	R25,0
    042F2 2333      TST	R19
    042F3 F049      BEQ	0x42FD
    042F4 9536      LSR	R19
    042F5 9527      ROR	R18
    042F6 9517      ROR	R17
    042F7 9507      ROR	R16
    042F8 17A8      CP	R26,R24
    042F9 07B9      CPC	R27,R25
    042FA F4CC      BGE	0x4314
    042FB 9611      ADIW	R26,1
    042FC CFF5      RJMP	0x42F2
    042FD 9580      COM	R24
    042FE 9590      COM	R25
    042FF 9601      ADIW	R24,1
    04300 2322      TST	R18
    04301 F0BA      BMI	0x4319
    04302 0F00      LSL	R16
    04303 1F11      ROL	R17
    04304 1F22      ROL	R18
    04305 17A8      CP	R26,R24
    04306 07B9      CPC	R27,R25
    04307 F014      BLT	0x430A
    04308 9711      SBIW	R26,1
    04309 CFF6      RJMP	0x4300
    0430A 2700      CLR	R16
    0430B 2711      CLR	R17
    0430C 2722      CLR	R18
    0430D 2733      CLR	R19
    0430E 9189      LD	R24,Y+
    0430F 9199      LD	R25,Y+
    04310 012D      MOVW	R4,R26
    04311 91B9      LD	R27,Y+
    04312 91A9      LD	R26,Y+
    04313 9508      RET
    04314 2733      CLR	R19
    04315 EF0F      LDI	R16,0xFF
    04316 2F10      MOV	R17,R16
    04317 E72F      LDI	R18,0x7F
    04318 2F32      MOV	R19,R18
    04319 9189      LD	R24,Y+
    0431A 9199      LD	R25,Y+
    0431B 012D      MOVW	R4,R26
    0431C C002      RJMP	0x431F
pack:
    0431D 93AA      ST	-Y,R26
    0431E 93BA      ST	-Y,R27
    0431F DFA7      RCALL	tstR16_R19
    04320 F049      BEQ	0x432A
    04321 01D2      MOVW	R26,R4
    04322 58A1      SUBI	R26,0x81
    04323 4FBF      SBCI	R27,0xFF
    04324 012D      MOVW	R4,R26
    04325 2D34      MOV	R19,R4
    04326 0F22      LSL	R18
    04327 9536      LSR	R19
    04328 9527      ROR	R18
    04329 2936      OR	R19,R6
    0432A 91B9      LD	R27,Y+
    0432B 91A9      LD	R26,Y+
    0432C 9508      RET
saveFPRegs:
    0432D 924A      ST	-Y,R4
    0432E 925A      ST	-Y,R5
    0432F 926A      ST	-Y,R6
    04330 927A      ST	-Y,R7
    04331 928A      ST	-Y,R8
    04332 929A      ST	-Y,R9
    04333 92AA      ST	-Y,R10
    04334 92BA      ST	-Y,R11
    04335 92CA      ST	-Y,R12
    04336 92DA      ST	-Y,R13
    04337 92EA      ST	-Y,R14
    04338 92FA      ST	-Y,R15
    04339 938A      ST	-Y,R24
    0433A 939A      ST	-Y,R25
    0433B 9508      RET
restoreFPRegs:
    0433C 9199      LD	R25,Y+
    0433D 9189      LD	R24,Y+
    0433E 90F9      LD	R15,Y+
    0433F 90E9      LD	R14,Y+
    04340 90D9      LD	R13,Y+
    04341 90C9      LD	R12,Y+
    04342 90B9      LD	R11,Y+
    04343 90A9      LD	R10,Y+
    04344 9099      LD	R9,Y+
    04345 9089      LD	R8,Y+
    04346 9079      LD	R7,Y+
    04347 9069      LD	R6,Y+
    04348 9059      LD	R5,Y+
    04349 9049      LD	R4,Y+
    0434A 9508      RET
fpmule:
    0434B 940E 432D CALL	saveFPRegs
    0434D 93AA      ST	-Y,R26
    0434E 93BA      ST	-Y,R27
    0434F 940E 42CF CALL	unpacku
    04351 F1E1      BEQ	0x438E
    04352 2CE6      MOV	R14,R6
    04353 2CD5      MOV	R13,R5
    04354 2CC4      MOV	R12,R4
    04355 2EB3      MOV	R11,R19
    04356 2EA2      MOV	R10,R18
    04357 2E91      MOV	R9,R17
    04358 2E80      MOV	R8,R16
    04359 8100      LD	R16,Z
    0435A 8111      LDD	R17,Z+1
    0435B 8122      LDD	R18,Z+2
    0435C 8133      LDD	R19,Z+3
    0435D 940E 42CF CALL	unpacku
    0435F F171      BEQ	0x438E
    04360 246E      EOR	R6,R14
    04361 0C4C      ADD	R4,R12
    04362 1C5D      ADC	R5,R13
    04363 E880      LDI	R24,0x80
    04364 1648      CP	R4,R24
    04365 0653      CPC	R5,R19
    04366 F564      BGE	0x4393
    04367 E881      LDI	R24,0x81
    04368 1648      CP	R4,R24
    04369 EF8F      LDI	R24,0xFF
    0436A 0658      CPC	R5,R24
    0436B F16C      BLT	0x4399
    0436C 9EA2      MUL	R10,R18
    0436D 2DB1      MOV	R27,R1
    0436E 2DA0      MOV	R26,R0
    0436F 9E91      MUL	R9,R17
    04370 2D91      MOV	R25,R1
    04371 2D80      MOV	R24,R0
    04372 9EA0      MUL	R10,R16
    04373 0D80      ADD	R24,R0
    04374 1D91      ADC	R25,R1
    04375 1FA3      ADC	R26,R19
    04376 1FB3      ADC	R27,R19
    04377 9E82      MUL	R8,R18
    04378 0D80      ADD	R24,R0
    04379 1D91      ADC	R25,R1
    0437A 1FA3      ADC	R26,R19
    0437B 1FB3      ADC	R27,R19
    0437C 9E92      MUL	R9,R18
    0437D 0D90      ADD	R25,R0
    0437E 1DA1      ADC	R26,R1
    0437F 1FB3      ADC	R27,R19
    04380 9EA1      MUL	R10,R17
    04381 0D90      ADD	R25,R0
    04382 1DA1      ADC	R26,R1
    04383 1FB3      ADC	R27,R19
    04384 2F2B      MOV	R18,R27
    04385 2F1A      MOV	R17,R26
    04386 2F09      MOV	R16,R25
    04387 0F88      LSL	R24
    04388 1F00      ROL	R16
    04389 1F11      ROL	R17
    0438A 1F22      ROL	R18
    0438B 1F33      ROL	R19
    0438C 940E 42E8 CALL	normalize_and_pack
    0438E 91B9      LD	R27,Y+
    0438F 91A9      LD	R26,Y+
    04390 940E 433C CALL	restoreFPRegs
    04392 9508      RET
    04393 EF0F      LDI	R16,0xFF
    04394 2F10      MOV	R17,R16
    04395 E72F      LDI	R18,0x7F
    04396 E78F      LDI	R24,0x7F
    04397 2E48      MOV	R4,R24
    04398 CFF5      RJMP	0x438E
    04399 2700      CLR	R16
    0439A 2F10      MOV	R17,R16
    0439B 2F20      MOV	R18,R16
    0439C 2F30      MOV	R19,R16
    0439D CFF0      RJMP	0x438E
fpmule1:
    0439E 93FA      ST	-Y,R31
    0439F 93EA      ST	-Y,R30
    043A0 81EA      LDD	R30,Y+2
    043A1 81FB      LDD	R31,Y+3
    043A2 940E 434B CALL	fpmule
    043A4 91E9      LD	R30,Y+
    043A5 91F9      LD	R31,Y+
    043A6 9622      ADIW	R28,2
    043A7 9508      RET
fpmule2:
    043A8 93FA      ST	-Y,R31
    043A9 93EA      ST	-Y,R30
    043AA 2FEC      MOV	R30,R28
    043AB 2FFD      MOV	R31,R29
    043AC 9632      ADIW	R30,2
    043AD 940E 434B CALL	fpmule
    043AF 91E9      LD	R30,Y+
    043B0 91F9      LD	R31,Y+
    043B1 9624      ADIW	R28,4
    043B2 9508      RET
fpmule1x:
    043B3 93FA      ST	-Y,R31
    043B4 93EA      ST	-Y,R30
    043B5 81EA      LDD	R30,Y+2
    043B6 81FB      LDD	R31,Y+3
    043B7 940E 434B CALL	fpmule
    043B9 91E9      LD	R30,Y+
    043BA 91F9      LD	R31,Y+
    043BB 8339      STD	Y+1,R19
    043BC 8328      ST	Y,R18
    043BD 931A      ST	-Y,R17
    043BE 930A      ST	-Y,R16
    043BF 9508      RET
fpcmp:
    043C0 940E 4166 CALL	fpsub
    043C2 2333      TST	R19
    043C3 F03A      BMI	0x43CB
    043C4 940E 42C7 CALL	tstR16_R19
    043C6 F011      BEQ	0x43C9
    043C7 E001      LDI	R16,1
    043C8 9508      RET
    043C9 2700      CLR	R16
    043CA 9508      RET
    043CB EF0F      LDI	R16,0xFF
    043CC 9508      RET
fpcmp2:
    043CD 93FA      ST	-Y,R31
    043CE 93EA      ST	-Y,R30
    043CF 2FEC      MOV	R30,R28
    043D0 2FFD      MOV	R31,R29
    043D1 9632      ADIW	R30,2
    043D2 940E 43C0 CALL	fpcmp
    043D4 91E9      LD	R30,Y+
    043D5 91F9      LD	R31,Y+
    043D6 9624      ADIW	R28,4
    043D7 2300      TST	R16
    043D8 9508      RET
_itoa:
    043D9 940E 3F62 CALL	push_arg4
    043DB 940E 40A7 CALL	push_xgsetF0FC
    043DD 01A9      MOVW	R20,R18
    043DE 84EE      LDD	R14,Y+14
    043DF 84FF      LDD	R15,Y+15
    043E0 015A      MOVW	R10,R20
    043E1 20AA      TST	R10
    043E2 F451      BNE	0x43ED
    043E3 20BB      TST	R11
    043E4 F441      BNE	0x43ED
    043E5 E380      LDI	R24,0x30
    043E6 85EA      LDD	R30,Y+10
    043E7 85FB      LDD	R31,Y+11
    043E8 8380      ST	Z,R24
    043E9 2422      CLR	R2
    043EA 8221      STD	Z+1,R2
    043EB 018F      MOVW	R16,R30
    043EC C053      RJMP	0x4440
    043ED 3040      CPI	R20,0
    043EE E0E0      LDI	R30,0
    043EF 075E      CPC	R21,R30
    043F0 F46C      BGE	0x43FE
    043F1 01C7      MOVW	R24,R14
    043F2 308A      CPI	R24,0xA
    043F3 E0E0      LDI	R30,0
    043F4 079E      CPC	R25,R30
    043F5 F441      BNE	0x43FE
    043F6 24CC      CLR	R12
    043F7 94C3      INC	R12
    043F8 01C5      MOVW	R24,R10
    043F9 9580      COM	R24
    043FA 9590      COM	R25
    043FB 9601      ADIW	R24,1
    043FC 015C      MOVW	R10,R24
    043FD C001      RJMP	0x43FF
    043FE 24CC      CLR	R12
    043FF 856A      LDD	R22,Y+10
    04400 857B      LDD	R23,Y+11
    04401 0197      MOVW	R18,R14
    04402 0185      MOVW	R16,R10
    04403 940E 3F91 CALL	mod16u
    04405 01A8      MOVW	R20,R16
    04406 E089      LDI	R24,0x9
    04407 E090      LDI	R25,0
    04408 1780      CP	R24,R16
    04409 0791      CPC	R25,R17
    0440A F034      BLT	0x4411
    0440B 01CA      MOVW	R24,R20
    0440C 96C0      ADIW	R24,0x30
    0440D 01FB      MOVW	R30,R22
    0440E 9381      ST	Z+,R24
    0440F 01BF      MOVW	R22,R30
    04410 C006      RJMP	0x4417
    04411 01CA      MOVW	R24,R20
    04412 5A89      SUBI	R24,0xA9
    04413 4F9F      SBCI	R25,0xFF
    04414 01FB      MOVW	R30,R22
    04415 9381      ST	Z+,R24
    04416 01BF      MOVW	R22,R30
    04417 0197      MOVW	R18,R14
    04418 0185      MOVW	R16,R10
    04419 940E 3F93 CALL	div16u
    0441B 0158      MOVW	R10,R16
    0441C 20AA      TST	R10
    0441D F719      BNE	0x4401
    0441E 20BB      TST	R11
    0441F F709      BNE	0x4401
    04420 20CC      TST	R12
    04421 F021      BEQ	0x4426
    04422 E28D      LDI	R24,0x2D
    04423 01FB      MOVW	R30,R22
    04424 9381      ST	Z+,R24
    04425 01BF      MOVW	R22,R30
    04426 012B      MOVW	R4,R22
    04427 5061      SUBI	R22,1
    04428 4070      SBCI	R23,0
    04429 2422      CLR	R2
    0442A 01F2      MOVW	R30,R4
    0442B 8220      ST	Z,R2
    0442C 84AA      LDD	R10,Y+10
    0442D 84BB      LDD	R11,Y+11
    0442E C00C      RJMP	0x443B
    0442F 01F5      MOVW	R30,R10
    04430 80C0      LD	R12,Z
    04431 01FB      MOVW	R30,R22
    04432 8020      LD	R2,Z
    04433 01F5      MOVW	R30,R10
    04434 9221      ST	Z+,R2
    04435 015F      MOVW	R10,R30
    04436 011B      MOVW	R2,R22
    04437 5061      SUBI	R22,1
    04438 4070      SBCI	R23,0
    04439 01F1      MOVW	R30,R2
    0443A 82C0      ST	Z,R12
    0443B 16A6      CP	R10,R22
    0443C 06B7      CPC	R11,R23
    0443D F388      BCS	0x442F
    0443E 850A      LDD	R16,Y+10
    0443F 851B      LDD	R17,Y+11
    04440 940E 409C CALL	pop_xgsetF0FC
    04442 9624      ADIW	R28,4
    04443 9508      RET
_ltoa:
    04444 940E 3F62 CALL	push_arg4
    04446 940E 40A7 CALL	push_xgsetF0FC
    04448 9724      SBIW	R28,4
    04449 8828      LDD	R2,Y+16
    0444A 8839      LDD	R3,Y+17
    0444B 884A      LDD	R4,Y+18
    0444C 885B      LDD	R5,Y+19
    0444D 8228      ST	Y,R2
    0444E 8239      STD	Y+1,R3
    0444F 824A      STD	Y+2,R4
    04450 825B      STD	Y+3,R5
    04451 8828      LDD	R2,Y+16
    04452 8839      LDD	R3,Y+17
    04453 884A      LDD	R4,Y+18
    04454 885B      LDD	R5,Y+19
    04455 9488      BCLR	0
    04456 2022      TST	R2
    04457 0432      CPC	R3,R2
    04458 0442      CPC	R4,R2
    04459 0452      CPC	R5,R2
    0445A F441      BNE	0x4463
    0445B E380      LDI	R24,0x30
    0445C 85EE      LDD	R30,Y+14
    0445D 85FF      LDD	R31,Y+15
    0445E 8380      ST	Z,R24
    0445F 2422      CLR	R2
    04460 8221      STD	Z+1,R2
    04461 018F      MOVW	R16,R30
    04462 C094      RJMP	0x44F7
    04463 E040      LDI	R20,0
    04464 E050      LDI	R21,0
    04465 E060      LDI	R22,0
    04466 E070      LDI	R23,0
    04467 8828      LDD	R2,Y+16
    04468 8839      LDD	R3,Y+17
    04469 884A      LDD	R4,Y+18
    0446A 885B      LDD	R5,Y+19
    0446B 1624      CP	R2,R20
    0446C 0635      CPC	R3,R21
    0446D 0646      CPC	R4,R22
    0446E 0657      CPC	R5,R23
    0446F F4EC      BGE	0x448D
    04470 898C      LDD	R24,Y+20
    04471 899D      LDD	R25,Y+21
    04472 308A      CPI	R24,0xA
    04473 E0A0      LDI	R26,0
    04474 079A      CPC	R25,R26
    04475 F4B9      BNE	0x448D
    04476 24AA      CLR	R10
    04477 94A3      INC	R10
    04478 E041      LDI	R20,1
    04479 E050      LDI	R21,0
    0447A E060      LDI	R22,0
    0447B E070      LDI	R23,0
    0447C 8028      LD	R2,Y
    0447D 8039      LDD	R3,Y+1
    0447E 804A      LDD	R4,Y+2
    0447F 805B      LDD	R5,Y+3
    04480 9420      COM	R2
    04481 9430      COM	R3
    04482 9440      COM	R4
    04483 9450      COM	R5
    04484 0E24      ADD	R2,R20
    04485 1E35      ADC	R3,R21
    04486 1E46      ADC	R4,R22
    04487 1E57      ADC	R5,R23
    04488 8228      ST	Y,R2
    04489 8239      STD	Y+1,R3
    0448A 824A      STD	Y+2,R4
    0448B 825B      STD	Y+3,R5
    0448C C001      RJMP	0x448E
    0448D 24AA      CLR	R10
    0448E 84CE      LDD	R12,Y+14
    0448F 84DF      LDD	R13,Y+15
    04490 882C      LDD	R2,Y+20
    04491 883D      LDD	R3,Y+21
    04492 2444      CLR	R4
    04493 FC37      SBRC	R3,7
    04494 9440      COM	R4
    04495 2455      CLR	R5
    04496 FC47      SBRC	R4,7
    04497 9450      COM	R5
    04498 8108      LD	R16,Y
    04499 8119      LDD	R17,Y+1
    0449A 812A      LDD	R18,Y+2
    0449B 813B      LDD	R19,Y+3
    0449C 925A      ST	-Y,R5
    0449D 924A      ST	-Y,R4
    0449E 923A      ST	-Y,R3
    0449F 922A      ST	-Y,R2
    044A0 940E 3FAF CALL	mod32u
    044A2 0178      MOVW	R14,R16
    044A3 E089      LDI	R24,0x9
    044A4 E090      LDI	R25,0
    044A5 1780      CP	R24,R16
    044A6 0791      CPC	R25,R17
    044A7 F034      BLT	0x44AE
    044A8 01C7      MOVW	R24,R14
    044A9 96C0      ADIW	R24,0x30
    044AA 01F6      MOVW	R30,R12
    044AB 9381      ST	Z+,R24
    044AC 016F      MOVW	R12,R30
    044AD C006      RJMP	0x44B4
    044AE 01C7      MOVW	R24,R14
    044AF 5A89      SUBI	R24,0xA9
    044B0 4F9F      SBCI	R25,0xFF
    044B1 01F6      MOVW	R30,R12
    044B2 9381      ST	Z+,R24
    044B3 016F      MOVW	R12,R30
    044B4 882C      LDD	R2,Y+20
    044B5 883D      LDD	R3,Y+21
    044B6 2444      CLR	R4
    044B7 FC37      SBRC	R3,7
    044B8 9440      COM	R4
    044B9 2455      CLR	R5
    044BA FC47      SBRC	R4,7
    044BB 9450      COM	R5
    044BC 8108      LD	R16,Y
    044BD 8119      LDD	R17,Y+1
    044BE 812A      LDD	R18,Y+2
    044BF 813B      LDD	R19,Y+3
    044C0 925A      ST	-Y,R5
    044C1 924A      ST	-Y,R4
    044C2 923A      ST	-Y,R3
    044C3 922A      ST	-Y,R2
    044C4 940E 3FAD CALL	div32u
    044C6 8308      ST	Y,R16
    044C7 8319      STD	Y+1,R17
    044C8 832A      STD	Y+2,R18
    044C9 833B      STD	Y+3,R19
    044CA 8028      LD	R2,Y
    044CB 8039      LDD	R3,Y+1
    044CC 804A      LDD	R4,Y+2
    044CD 805B      LDD	R5,Y+3
    044CE 9488      BCLR	0
    044CF 2022      TST	R2
    044D0 0432      CPC	R3,R2
    044D1 0442      CPC	R4,R2
    044D2 0452      CPC	R5,R2
    044D3 F009      BEQ	0x44D5
    044D4 CFBB      RJMP	0x4490
    044D5 20AA      TST	R10
    044D6 F021      BEQ	0x44DB
    044D7 E28D      LDI	R24,0x2D
    044D8 01F6      MOVW	R30,R12
    044D9 9381      ST	Z+,R24
    044DA 016F      MOVW	R12,R30
    044DB 0126      MOVW	R4,R12
    044DC 01C2      MOVW	R24,R4
    044DD 9701      SBIW	R24,1
    044DE 016C      MOVW	R12,R24
    044DF 2422      CLR	R2
    044E0 01F2      MOVW	R30,R4
    044E1 8220      ST	Z,R2
    044E2 84EE      LDD	R14,Y+14
    044E3 84FF      LDD	R15,Y+15
    044E4 C00D      RJMP	0x44F2
    044E5 01F7      MOVW	R30,R14
    044E6 80A0      LD	R10,Z
    044E7 01F6      MOVW	R30,R12
    044E8 8020      LD	R2,Z
    044E9 01F7      MOVW	R30,R14
    044EA 9221      ST	Z+,R2
    044EB 017F      MOVW	R14,R30
    044EC 0116      MOVW	R2,R12
    044ED 01C1      MOVW	R24,R2
    044EE 9701      SBIW	R24,1
    044EF 016C      MOVW	R12,R24
    044F0 01F1      MOVW	R30,R2
    044F1 82A0      ST	Z,R10
    044F2 14EC      CP	R14,R12
    044F3 04FD      CPC	R15,R13
    044F4 F380      BCS	0x44E5
    044F5 850E      LDD	R16,Y+14
    044F6 851F      LDD	R17,Y+15
    044F7 9624      ADIW	R28,4
    044F8 940E 409C CALL	pop_xgsetF0FC
    044FA 9624      ADIW	R28,4
    044FB 9508      RET
_ftoa:
    044FC 940E 3F62 CALL	push_arg4
    044FE 940E 40A7 CALL	push_xgsetF0FC
    04500 9764      SBIW	R28,0x14
    04501 A0CA      LDD	R12,Y+34
    04502 A0DB      LDD	R13,Y+35
    04503 2422      CLR	R2
    04504 2433      CLR	R3
    04505 01F6      MOVW	R30,R12
    04506 8231      STD	Z+1,R3
    04507 8220      ST	Z,R2
    04508 8C2E      LDD	R2,Y+30
    04509 8C3F      LDD	R3,Y+31
    0450A A048      LDD	R4,Y+32
    0450B A059      LDD	R5,Y+33
    0450C EC0C      LDI	R16,0xCC
    0450D E010      LDI	R17,0
    0450E 940E 402F CALL	elpm32
    04510 933A      ST	-Y,R19
    04511 932A      ST	-Y,R18
    04512 931A      ST	-Y,R17
    04513 930A      ST	-Y,R16
    04514 0181      MOVW	R16,R2
    04515 0192      MOVW	R18,R4
    04516 940E 43CD CALL	fpcmp2
    04518 F479      BNE	0x4528
    04519 E380      LDI	R24,0x30
    0451A 9380 07DC STS	config+20,R24
    0451C E28E      LDI	R24,0x2E
    0451D 9380 07DD STS	config+21,R24
    0451F E380      LDI	R24,0x30
    04520 9380 07DE STS	config+22,R24
    04522 2422      CLR	R2
    04523 9220 07DF STS	config+23,R2
    04525 ED0C      LDI	R16,0xDC
    04526 E017      LDI	R17,7
    04527 C15E      RJMP	0x4686
    04528 8C2E      LDD	R2,Y+30
    04529 8C3F      LDD	R3,Y+31
    0452A A048      LDD	R4,Y+32
    0452B A059      LDD	R5,Y+33
    0452C 8628      STD	Y+8,R2
    0452D 8639      STD	Y+9,R3
    0452E 864A      STD	Y+10,R4
    0452F 865B      STD	Y+11,R5
    04530 E187      LDI	R24,0x17
    04531 E090      LDI	R25,0
    04532 8508      LDD	R16,Y+8
    04533 8519      LDD	R17,Y+9
    04534 852A      LDD	R18,Y+10
    04535 853B      LDD	R19,Y+11
    04536 938A      ST	-Y,R24
    04537 940E 3F67 CALL	asr32
    04539 2F80      MOV	R24,R16
    0453A 2799      CLR	R25
    0453B 578F      SUBI	R24,0x7F
    0453C 4090      SBCI	R25,0
    0453D 015C      MOVW	R10,R24
    0453E EF4F      LDI	R20,0xFF
    0453F EF5F      LDI	R21,0xFF
    04540 EF6F      LDI	R22,0xFF
    04541 E070      LDI	R23,0
    04542 8428      LDD	R2,Y+8
    04543 8439      LDD	R3,Y+9
    04544 844A      LDD	R4,Y+10
    04545 845B      LDD	R5,Y+11
    04546 2224      AND	R2,R20
    04547 2235      AND	R3,R21
    04548 2246      AND	R4,R22
    04549 2257      AND	R5,R23
    0454A 93EF      PUSH	R30
    0454B 2DE4      MOV	R30,R4
    0454C 68E0      ORI	R30,0x80
    0454D 2E4E      MOV	R4,R30
    0454E 91EF      POP	R30
    0454F 8A28      STD	Y+16,R2
    04550 8A39      STD	Y+17,R3
    04551 8A4A      STD	Y+18,R4
    04552 8A5B      STD	Y+19,R5
    04553 E080      LDI	R24,0
    04554 838C      STD	Y+4,R24
    04555 838D      STD	Y+5,R24
    04556 838E      STD	Y+6,R24
    04557 838F      STD	Y+7,R24
    04558 E080      LDI	R24,0
    04559 878C      STD	Y+12,R24
    0455A 878D      STD	Y+13,R24
    0455B 878E      STD	Y+14,R24
    0455C 878F      STD	Y+15,R24
    0455D 01C5      MOVW	R24,R10
    0455E 318F      CPI	R24,0x1F
    0455F E0E0      LDI	R30,0
    04560 079E      CPC	R25,R30
    04561 F044      BLT	0x456A
    04562 EF8E      LDI	R24,0xFE
    04563 EF9F      LDI	R25,0xFF
    04564 01F6      MOVW	R30,R12
    04565 8391      STD	Z+1,R25
    04566 8380      ST	Z,R24
    04567 2700      CLR	R16
    04568 2711      CLR	R17
    04569 C11C      RJMP	0x4686
    0456A 01C5      MOVW	R24,R10
    0456B 3E89      CPI	R24,0xE9
    0456C EFEF      LDI	R30,0xFF
    0456D 079E      CPC	R25,R30
    0456E F444      BGE	0x4577
    0456F EF8F      LDI	R24,0xFF
    04570 EF9F      LDI	R25,0xFF
    04571 01F6      MOVW	R30,R12
    04572 8391      STD	Z+1,R25
    04573 8380      ST	Z,R24
    04574 2700      CLR	R16
    04575 2711      CLR	R17
    04576 C10F      RJMP	0x4686
    04577 01C5      MOVW	R24,R10
    04578 3187      CPI	R24,0x17
    04579 E0A0      LDI	R26,0
    0457A 079A      CPC	R25,R26
    0457B F06C      BLT	0x4589
    0457C 9747      SBIW	R24,0x17
    0457D 8908      LDD	R16,Y+16
    0457E 8919      LDD	R17,Y+17
    0457F 892A      LDD	R18,Y+18
    04580 893B      LDD	R19,Y+19
    04581 938A      ST	-Y,R24
    04582 940E 4129 CALL	lsl32
    04584 870C      STD	Y+12,R16
    04585 871D      STD	Y+13,R17
    04586 872E      STD	Y+14,R18
    04587 873F      STD	Y+15,R19
    04588 C045      RJMP	0x45CE
    04589 01C5      MOVW	R24,R10
    0458A 3080      CPI	R24,0
    0458B E0A0      LDI	R26,0
    0458C 079A      CPC	R25,R26
    0458D F13C      BLT	0x45B5
    0458E E187      LDI	R24,0x17
    0458F E090      LDI	R25,0
    04590 198A      SUB	R24,R10
    04591 099B      SBC	R25,R11
    04592 8908      LDD	R16,Y+16
    04593 8919      LDD	R17,Y+17
    04594 892A      LDD	R18,Y+18
    04595 893B      LDD	R19,Y+19
    04596 938A      ST	-Y,R24
    04597 940E 3F67 CALL	asr32
    04599 870C      STD	Y+12,R16
    0459A 871D      STD	Y+13,R17
    0459B 872E      STD	Y+14,R18
    0459C 873F      STD	Y+15,R19
    0459D 01C5      MOVW	R24,R10
    0459E 9601      ADIW	R24,1
    0459F 8908      LDD	R16,Y+16
    045A0 8919      LDD	R17,Y+17
    045A1 892A      LDD	R18,Y+18
    045A2 893B      LDD	R19,Y+19
    045A3 938A      ST	-Y,R24
    045A4 940E 4129 CALL	lsl32
    045A6 0118      MOVW	R2,R16
    045A7 0129      MOVW	R4,R18
    045A8 EF4F      LDI	R20,0xFF
    045A9 EF5F      LDI	R21,0xFF
    045AA EF6F      LDI	R22,0xFF
    045AB E070      LDI	R23,0
    045AC 2224      AND	R2,R20
    045AD 2235      AND	R3,R21
    045AE 2246      AND	R4,R22
    045AF 2257      AND	R5,R23
    045B0 822C      STD	Y+4,R2
    045B1 823D      STD	Y+5,R3
    045B2 824E      STD	Y+6,R4
    045B3 825F      STD	Y+7,R5
    045B4 C019      RJMP	0x45CE
    045B5 EF4F      LDI	R20,0xFF
    045B6 EF5F      LDI	R21,0xFF
    045B7 EF6F      LDI	R22,0xFF
    045B8 E070      LDI	R23,0
    045B9 8908      LDD	R16,Y+16
    045BA 8919      LDD	R17,Y+17
    045BB 892A      LDD	R18,Y+18
    045BC 893B      LDD	R19,Y+19
    045BD 2304      AND	R16,R20
    045BE 2315      AND	R17,R21
    045BF 2326      AND	R18,R22
    045C0 2337      AND	R19,R23
    045C1 01C5      MOVW	R24,R10
    045C2 9601      ADIW	R24,1
    045C3 9580      COM	R24
    045C4 9590      COM	R25
    045C5 5F8F      SUBI	R24,0xFF
    045C6 4F9F      SBCI	R25,0xFF
    045C7 938A      ST	-Y,R24
    045C8 940E 3F67 CALL	asr32
    045CA 830C      STD	Y+4,R16
    045CB 831D      STD	Y+5,R17
    045CC 832E      STD	Y+6,R18
    045CD 833F      STD	Y+7,R19
    045CE ED8C      LDI	R24,0xDC
    045CF E097      LDI	R25,7
    045D0 015C      MOVW	R10,R24
    045D1 E040      LDI	R20,0
    045D2 E050      LDI	R21,0
    045D3 E060      LDI	R22,0
    045D4 E070      LDI	R23,0
    045D5 8428      LDD	R2,Y+8
    045D6 8439      LDD	R3,Y+9
    045D7 844A      LDD	R4,Y+10
    045D8 845B      LDD	R5,Y+11
    045D9 1624      CP	R2,R20
    045DA 0635      CPC	R3,R21
    045DB 0646      CPC	R4,R22
    045DC 0657      CPC	R5,R23
    045DD F424      BGE	0x45E2
    045DE E28D      LDI	R24,0x2D
    045DF 01F5      MOVW	R30,R10
    045E0 9381      ST	Z+,R24
    045E1 015F      MOVW	R10,R30
    045E2 842C      LDD	R2,Y+12
    045E3 843D      LDD	R3,Y+13
    045E4 844E      LDD	R4,Y+14
    045E5 845F      LDD	R5,Y+15
    045E6 9488      BCLR	0
    045E7 2022      TST	R2
    045E8 0432      CPC	R3,R2
    045E9 0442      CPC	R4,R2
    045EA 0452      CPC	R5,R2
    045EB F429      BNE	0x45F1
    045EC E380      LDI	R24,0x30
    045ED 01F5      MOVW	R30,R10
    045EE 9381      ST	Z+,R24
    045EF 015F      MOVW	R10,R30
    045F0 C016      RJMP	0x4607
    045F1 E08A      LDI	R24,0xA
    045F2 E090      LDI	R25,0
    045F3 839B      STD	Y+3,R25
    045F4 838A      STD	Y+2,R24
    045F5 842C      LDD	R2,Y+12
    045F6 843D      LDD	R3,Y+13
    045F7 844E      LDD	R4,Y+14
    045F8 845F      LDD	R5,Y+15
    045F9 8248      ST	Y,R4
    045FA 8259      STD	Y+1,R5
    045FB 0191      MOVW	R18,R2
    045FC 0185      MOVW	R16,R10
    045FD 940E 4444 CALL	_ltoa
    045FF C003      RJMP	0x4603
    04600 01C5      MOVW	R24,R10
    04601 9601      ADIW	R24,1
    04602 015C      MOVW	R10,R24
    04603 01F5      MOVW	R30,R10
    04604 8020      LD	R2,Z
    04605 2022      TST	R2
    04606 F7C9      BNE	0x4600
    04607 E28E      LDI	R24,0x2E
    04608 01F5      MOVW	R30,R10
    04609 9381      ST	Z+,R24
    0460A 015F      MOVW	R10,R30
    0460B 802C      LDD	R2,Y+4
    0460C 803D      LDD	R3,Y+5
    0460D 804E      LDD	R4,Y+6
    0460E 805F      LDD	R5,Y+7
    0460F 9488      BCLR	0
    04610 2022      TST	R2
    04611 0432      CPC	R3,R2
    04612 0442      CPC	R4,R2
    04613 0452      CPC	R5,R2
    04614 F421      BNE	0x4619
    04615 E380      LDI	R24,0x30
    04616 9381      ST	Z+,R24
    04617 015F      MOVW	R10,R30
    04618 C068      RJMP	0x4681
    04619 ED8C      LDI	R24,0xDC
    0461A E097      LDI	R25,7
    0461B 0115      MOVW	R2,R10
    0461C 1A28      SUB	R2,R24
    0461D 0A39      SBC	R3,R25
    0461E E08F      LDI	R24,0xF
    0461F E090      LDI	R25,0
    04620 1982      SUB	R24,R2
    04621 0993      SBC	R25,R3
    04622 9701      SBIW	R24,1
    04623 2EC8      MOV	R12,R24
    04624 E087      LDI	R24,7
    04625 158C      CP	R24,R12
    04626 F408      BCC	0x4628
    04627 2EC8      MOV	R12,R24
    04628 24EE      CLR	R14
    04629 C042      RJMP	0x466C
    0462A E083      LDI	R24,3
    0462B E090      LDI	R25,0
    0462C 810C      LDD	R16,Y+4
    0462D 811D      LDD	R17,Y+5
    0462E 812E      LDD	R18,Y+6
    0462F 813F      LDD	R19,Y+7
    04630 938A      ST	-Y,R24
    04631 940E 4129 CALL	lsl32
    04633 0118      MOVW	R2,R16
    04634 0129      MOVW	R4,R18
    04635 806C      LDD	R6,Y+4
    04636 807D      LDD	R7,Y+5
    04637 808E      LDD	R8,Y+6
    04638 809F      LDD	R9,Y+7
    04639 0C66      LSL	R6
    0463A 1C77      ROL	R7
    0463B 1C88      ROL	R8
    0463C 1C99      ROL	R9
    0463D 0C26      ADD	R2,R6
    0463E 1C37      ADC	R3,R7
    0463F 1C48      ADC	R4,R8
    04640 1C59      ADC	R5,R9
    04641 822C      STD	Y+4,R2
    04642 823D      STD	Y+5,R3
    04643 824E      STD	Y+6,R4
    04644 825F      STD	Y+7,R5
    04645 E188      LDI	R24,0x18
    04646 E090      LDI	R25,0
    04647 810C      LDD	R16,Y+4
    04648 811D      LDD	R17,Y+5
    04649 812E      LDD	R18,Y+6
    0464A 813F      LDD	R19,Y+7
    0464B 938A      ST	-Y,R24
    0464C 940E 3F67 CALL	asr32
    0464E 0118      MOVW	R2,R16
    0464F 0129      MOVW	R4,R18
    04650 E340      LDI	R20,0x30
    04651 E050      LDI	R21,0
    04652 E060      LDI	R22,0
    04653 E070      LDI	R23,0
    04654 0E24      ADD	R2,R20
    04655 1E35      ADC	R3,R21
    04656 1E46      ADC	R4,R22
    04657 1E57      ADC	R5,R23
    04658 01F5      MOVW	R30,R10
    04659 9221      ST	Z+,R2
    0465A 015F      MOVW	R10,R30
    0465B EF4F      LDI	R20,0xFF
    0465C EF5F      LDI	R21,0xFF
    0465D EF6F      LDI	R22,0xFF
    0465E E070      LDI	R23,0
    0465F 802C      LDD	R2,Y+4
    04660 803D      LDD	R3,Y+5
    04661 804E      LDD	R4,Y+6
    04662 805F      LDD	R5,Y+7
    04663 2224      AND	R2,R20
    04664 2235      AND	R3,R21
    04665 2246      AND	R4,R22
    04666 2257      AND	R5,R23
    04667 822C      STD	Y+4,R2
    04668 823D      STD	Y+5,R3
    04669 824E      STD	Y+6,R4
    0466A 825F      STD	Y+7,R5
    0466B 94E3      INC	R14
    0466C 14EC      CP	R14,R12
    0466D F408      BCC	0x466F
    0466E CFBB      RJMP	0x462A
    0466F 01C5      MOVW	R24,R10
    04670 9701      SBIW	R24,1
    04671 015C      MOVW	R10,R24
    04672 C003      RJMP	0x4676
    04673 01C5      MOVW	R24,R10
    04674 9701      SBIW	R24,1
    04675 015C      MOVW	R10,R24
    04676 01F5      MOVW	R30,R10
    04677 8180      LD	R24,Z
    04678 3380      CPI	R24,0x30
    04679 F421      BNE	0x467E
    0467A 9731      SBIW	R30,1
    0467B 8180      LD	R24,Z
    0467C 328E      CPI	R24,0x2E
    0467D F7A9      BNE	0x4673
    0467E 01C5      MOVW	R24,R10
    0467F 9601      ADIW	R24,1
    04680 015C      MOVW	R10,R24
    04681 2422      CLR	R2
    04682 01F5      MOVW	R30,R10
    04683 8220      ST	Z,R2
    04684 ED0C      LDI	R16,0xDC
    04685 E017      LDI	R17,7
    04686 9664      ADIW	R28,0x14
    04687 940E 409C CALL	pop_xgsetF0FC
    04689 9624      ADIW	R28,4
    0468A 9508      RET
