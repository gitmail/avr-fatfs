Interrupt Vectors
    00000 940C 0262 JMP	__start|__text_start
    0003C 940C 35CA JMP	_uart1_rx_isr

Program Code (text area)
__start|__text_start:
    00262 EFCF      LDI	R28,0xFF
    00263 E1D0      LDI	R29,0x10
    00264 BFCD      OUT	0x3D,R28
    00265 BFDE      OUT	0x3E,R29
    00266 51CE      SUBI	R28,0x1E
    00267 40D0      SBCI	R29,0
    00268 EA0A      LDI	R16,0xAA
    00269 8308      ST	Y,R16
    0026A 2400      CLR	R0
    0026B EFE4      LDI	R30,0xF4
    0026C E0F4      LDI	R31,4
    0026D E017      LDI	R17,7
    0026E 3DEA      CPI	R30,0xDA
    0026F 07F1      CPC	R31,R17
    00270 F011      BEQ	0x0273
    00271 9201      ST	Z+,R0
    00272 CFFB      RJMP	0x026E
    00273 8300      ST	Z,R16
    00274 EDE0      LDI	R30,0xD0
    00275 E0F0      LDI	R31,0
    00276 E0A0      LDI	R26,0
    00277 E0B1      LDI	R27,1
    00278 E014      LDI	R17,4
    00279 E000      LDI	R16,0
    0027A BF0B      OUT	0x3B,R16
    0027B 3CE4      CPI	R30,0xC4
    0027C 07F1      CPC	R31,R17
    0027D F021      BEQ	0x0282
    0027E 95C8      LPM
    0027F 9631      ADIW	R30,1
    00280 920D      ST	X+,R0
    00281 CFF9      RJMP	0x027B
    00282 940E 244B CALL	_main
_exit:
    00284 CFFF      RJMP	_exit
_disk_initialize:
  state                --> R20
  drv                  --> R10
    00285 92AA      ST	-Y,R10
    00286 934A      ST	-Y,R20
    00287 2EA0      MOV	R10,R16
FILE: D:\LQD\software\master\software_src\diskio.c
(0001) 
(0002) 
(0003) /*-----------------------------------------------------------------------*/
(0004) /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2007        */
(0005) /*-----------------------------------------------------------------------*/
(0006) /* This is a stub disk I/O module that acts as front end of the existing */
(0007) /* disk I/O modules and attach it to FatFs module with common interface. */
(0008) /*-----------------------------------------------------------------------*/
(0009) 
(0010) #include "diskio.h"
(0011) #include "sd.h"
(0012) 
(0013) 
(0014) /*-----------------------------------------------------------------------*/
(0015) /* Correspondence between physical drive number and physical drive.      */
(0016) /* Note that Tiny-FatFs supports only single drive and always            */
(0017)                                       
(0018) 
(0019) ////////////////////////////
(0020) /*
(0021)    struct tm {
(0022)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0023)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0024) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0025) 	int tm_mday;  // 日 day of the month, 1 to 31
(0026) 	int tm_mon;   // 月 months since January, 0 to 11
(0027) 	int tm_year;  // 年 years since 1900
(0028) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0029) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0030)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0031)  	};
(0032) */
(0033) /*-----------------------------------------------------------------------*/
(0034) /* Inidialize a Drive                                                    */
(0035) 
(0036) DSTATUS disk_initialize ( 
(0037) BYTE drv				/* Physical drive nmuber (0..) */
(0038) )
(0039) {
(0040)     unsigned char state;
(0041) 
(0042)     if(drv)
    00288 20AA      TST	R10
    00289 F011      BEQ	0x028C
(0043)     {
(0044)         return STA_NOINIT;  //仅支持磁盘0的操作
    0028A E001      LDI	R16,1
    0028B C00C      RJMP	0x0298
(0045)     }
(0046) 
(0047)     state = SD_Init();
    0028C 940E 2B50 CALL	_SD_Init
    0028E 2F40      MOV	R20,R16
(0048)     if(state == STA_NODISK)
    0028F 3002      CPI	R16,2
    00290 F411      BNE	0x0293
(0049)     {
(0050)         return STA_NODISK;
    00291 E002      LDI	R16,2
    00292 C005      RJMP	0x0298
(0051)     }
(0052)     else if(state != 0)
    00293 2344      TST	R20
    00294 F011      BEQ	0x0297
(0053)     {
(0054)         return STA_NOINIT;  //其他错误：初始化失败
    00295 E001      LDI	R16,1
    00296 C001      RJMP	0x0298
(0055)     }
(0056)     else
(0057)     {
(0058)         return 0;           //初始化成功
    00297 2700      CLR	R16
    00298 9149      LD	R20,Y+
    00299 90A9      LD	R10,Y+
    0029A 9508      RET
(0059)     }
(0060) }
(0061) 
(0062) 
(0063) 
(0064) /*-----------------------------------------------------------------------*/
(0065) /* Return Disk Status                                                    */
(0066) 
(0067) DSTATUS disk_status (
(0068) 	BYTE drv		/* Physical drive nmuber (0..) */
(0069) )
(0070) {
(0071)     if(drv)
_disk_status:
  drv                  --> R16
    0029B 2300      TST	R16
    0029C F011      BEQ	0x029F
(0072)     {
(0073)         return STA_NOINIT;  //仅支持磁盘0操作
    0029D E001      LDI	R16,1
    0029E C001      RJMP	0x02A0
(0074)     }
(0075)     return 0;
    0029F 2700      CLR	R16
    002A0 9508      RET
_disk_read:
  res                  --> R10
  count                --> R20
  sector               --> Y,+10
  buff                 --> R12
  drv                  --> R14
    002A1 940E 3F76 CALL	push_xgset30FC
    002A3 0169      MOVW	R12,R18
    002A4 2EE0      MOV	R14,R16
    002A5 9722      SBIW	R28,2
    002A6 854E      LDD	R20,Y+14
(0076) }
(0077) 
(0078) 
(0079) 
(0080) /*-----------------------------------------------------------------------*/
(0081) /* Read Sector(s)                                                        */
(0082) 
(0083) DRESULT disk_read (
(0084) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0085) 	BYTE *buff,		/* Data buffer to store read data */
(0086) 	DWORD sector,	/* Sector address (LBA) */
(0087) 	BYTE count		/* Number of sectors to read (1..255) */
(0088) )
(0089) {
(0090) 	unsigned char res=0;
    002A7 24AA      CLR	R10
(0091)     if (drv || !count)
    002A8 20EE      TST	R14
    002A9 F411      BNE	0x02AC
    002AA 2344      TST	R20
    002AB F411      BNE	0x02AE
(0092)     {    
(0093)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002AC E004      LDI	R16,4
    002AD C010      RJMP	0x02BE
(0094)     }
(0095) 
(0096)     if(count==1)            //1个sector的读操作      
    002AE 3041      CPI	R20,1
    002AF F449      BNE	0x02B9
(0097)     {                                                
(0098)         res = SD_Read_Sector(sector, buff);      
    002B0 82D9      STD	Y+1,R13
    002B1 82C8      ST	Y,R12
    002B2 850A      LDD	R16,Y+10
    002B3 851B      LDD	R17,Y+11
    002B4 852C      LDD	R18,Y+12
    002B5 853D      LDD	R19,Y+13
    002B6 940E 2C36 CALL	_SD_Read_Sector
    002B8 2EA0      MOV	R10,R16
(0099)     }                                                                                                 
(0100) 
(0101)     //处理返回值，将SD_driver.c的返回值转成ff.c的返回值
(0102)     if(res == 0x00)
    002B9 20AA      TST	R10
    002BA F411      BNE	0x02BD
(0103)     {
(0104)         return RES_OK;
    002BB 2700      CLR	R16
    002BC C001      RJMP	0x02BE
(0105)     }
(0106)     else
(0107)     {
(0108)         return RES_ERROR;
    002BD E001      LDI	R16,1
    002BE 9622      ADIW	R28,2
    002BF 940C 3F60 JMP	pop_xgset30FC
_disk_write:
  count                --> R12
  sector               --> Y,+8
  buff                 --> R10
  drv                  --> R14
    002C1 940E 3F78 CALL	push_xgset00FC
    002C3 0159      MOVW	R10,R18
    002C4 2EE0      MOV	R14,R16
    002C5 9722      SBIW	R28,2
    002C6 84CC      LDD	R12,Y+12
(0109)     }
(0110) }
(0111) 
(0112) 
(0113) 
(0114) /*-----------------------------------------------------------------------*/
(0115) /* Write Sector(s)                                                       */
(0116) 
(0117) #if _READONLY == 0
(0118) DRESULT disk_write (
(0119) 	BYTE drv,			/* Physical drive nmuber (0..) */
(0120) 	BYTE *buff,	        /* Data to be written */
(0121) 	DWORD sector,		/* Sector address (LBA) */
(0122) 	BYTE count			/* Number of sectors to write (1..255) */
(0123) )
(0124) {
(0125)     if (drv || !count)
    002C7 20EE      TST	R14
    002C8 F411      BNE	0x02CB
    002C9 20CC      TST	R12
    002CA F411      BNE	0x02CD
(0126)     {    
(0127)         return RES_PARERR;  //仅支持单磁盘操作，count不能等于0，否则返回参数错误
    002CB E004      LDI	R16,4
    002CC C009      RJMP	0x02D6
(0128)     }   
(0129)    // 读写操作
(0130)     SD_Write_Sector(sector,buff);
    002CD 82B9      STD	Y+1,R11
    002CE 82A8      ST	Y,R10
    002CF 8508      LDD	R16,Y+8
    002D0 8519      LDD	R17,Y+9
    002D1 852A      LDD	R18,Y+10
    002D2 853B      LDD	R19,Y+11
    002D3 940E 2BB0 CALL	_SD_Write_Sector
(0131) 	  
(0132)     return RES_OK;
    002D5 2700      CLR	R16
    002D6 9622      ADIW	R28,2
    002D7 940C 3F59 JMP	pop_xgset00FC
_disk_ioctl:
  buff                 --> Y,+4
  ctrl                 --> Y,+2
  drv                  --> Y,+0
    002D9 940E 3E2F CALL	push_arg4
(0133) }
(0134) #endif /* _READONLY */
(0135) 
(0136) 
(0137) 
(0138) /*-----------------------------------------------------------------------*/
(0139) /* Miscellaneous Functions                                               */
(0140) DRESULT disk_ioctl (
(0141) 	BYTE drv,		/* Physical drive nmuber (0..) */
(0142) 	BYTE ctrl,		/* Control code */
(0143) 	void *buff		/* Buffer to send/receive control data */
(0144) )
(0145) {
(0146)  	drv=drv;
(0147) 	ctrl=ctrl;
(0148) 	buff=buff;
(0149) 	return 0;
    002DB 2700      CLR	R16
    002DC 9624      ADIW	R28,4
    002DD 9508      RET
(0150) }
(0151) DWORD get_fattime (void)
(0152) {
(0153) 
(0154)   return 1950466005;
_get_fattime:
    002DE ED05      LDI	R16,0xD5
    002DF EB1F      LDI	R17,0xBF
    002E0 E421      LDI	R18,0x41
    002E1 E734      LDI	R19,0x74
    002E2 9508      RET
ff.c:mem_cpy:
  s                    --> R12
  d                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    002E3 940E 3FA1 CALL	push_xgset303C
    002E5 814E      LDD	R20,Y+6
    002E6 815F      LDD	R21,Y+7
FILE: D:\LQD\software\master\software_src\ff.c
(0001) /*----------------------------------------------------------------------------/
(0002) /  FatFs - FAT file system module  R0.09                  (C)ChaN, 2011
(0003) /-----------------------------------------------------------------------------/
(0004) / FatFs module is a generic FAT file system module for small embedded systems.
(0005) / This is a free software that opened for education, research and commercial
(0006) / developments under license policy of following terms.
(0007) /
(0008) /  Copyright (C) 2011, ChaN, all right reserved.
(0009) /
(0010) / * The FatFs module is a free software and there is NO WARRANTY.
(0011) / * No restriction on use. You can use, modify and redistribute it for
(0012) /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
(0013) / * Redistributions of source code must retain the above copyright notice.
(0014) /
(0015) /-----------------------------------------------------------------------------/
(0016) / Feb 26,'06 R0.00  Prototype.
(0017) /
(0018) / Apr 29,'06 R0.01  First stable version.
(0019) /
(0020) / Jun 01,'06 R0.02  Added FAT12 support.
(0021) /                   Removed unbuffered mode.
(0022) /                   Fixed a problem on small (<32M) partition.
(0023) / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
(0024) /
(0025) / Sep 22,'06 R0.03  Added f_rename().
(0026) /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
(0027) / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
(0028) /                   Fixed f_mkdir() creates incorrect directory on FAT32.
(0029) /
(0030) / Feb 04,'07 R0.04  Supported multiple drive system.
(0031) /                   Changed some interfaces for multiple drive system.
(0032) /                   Changed f_mountdrv() to f_mount().
(0033) /                   Added f_mkfs().
(0034) / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
(0035) /                   Added a capability of extending file size to f_lseek().
(0036) /                   Added minimization level 3.
(0037) /                   Fixed an endian sensitive code in f_mkfs().
(0038) / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
(0039) /                   Added FSInfo support.
(0040) /                   Fixed DBCS name can result FR_INVALID_NAME.
(0041) /                   Fixed short seek (<= csize) collapses the file object.
(0042) /
(0043) / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
(0044) /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
(0045) /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
(0046) / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
(0047) /                   Fixed off by one error at FAT sub-type determination.
(0048) /                   Fixed btr in f_read() can be mistruncated.
(0049) /                   Fixed cached sector is not flushed when create and close without write.
(0050) /
(0051) / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
(0052) /                   Improved performance of f_lseek() on moving to the same or following cluster.
(0053) /
(0054) / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
(0055) /                   Added long file name feature.
(0056) /                   Added multiple code page feature.
(0057) /                   Added re-entrancy for multitask operation.
(0058) /                   Added auto cluster size selection to f_mkfs().
(0059) /                   Added rewind option to f_readdir().
(0060) /                   Changed result code of critical errors.
(0061) /                   Renamed string functions to avoid name collision.
(0062) / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
(0063) /                   Added multiple sector size feature.
(0064) / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
(0065) /                   Fixed wrong cache control in f_lseek().
(0066) /                   Added relative path feature.
(0067) /                   Added f_chdir() and f_chdrive().
(0068) /                   Added proper case conversion to extended char.
(0069) / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
(0070) /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
(0071) /                   Fixed name matching error on the 13 char boundary.
(0072) /                   Added a configuration option, _LFN_UNICODE.
(0073) /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
(0074) /
(0075) / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
(0076) /                   Added file lock feature. (_FS_SHARE)
(0077) /                   Added fast seek feature. (_USE_FASTSEEK)
(0078) /                   Changed some types on the API, XCHAR->TCHAR.
(0079) /                   Changed fname member in the FILINFO structure on Unicode cfg.
(0080) /                   String functions support UTF-8 encoding files on Unicode cfg.
(0081) / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
(0082) /                   Added sector erase feature. (_USE_ERASE)
(0083) /                   Moved file lock semaphore table from fs object to the bss.
(0084) /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
(0085) /                   Fixed f_mkfs() creates wrong FAT32 volume.
(0086) / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
(0087) /                   f_lseek() reports required table size on creating CLMP.
(0088) /                   Extended format syntax of f_printf function.
(0089) /                   Ignores duplicated directory separators in given path names.
(0090) /
(0091) / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
(0092) /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
(0093) /---------------------------------------------------------------------------*/
(0094) 
(0095) #include "ff.h"			/* FatFs configurations and declarations */
(0096) #include "diskio.h"		/* Declarations of low level disk I/O functions */
(0097) #include <string.h>
(0098) 
(0099) /*--------------------------------------------------------------------------
(0100) 
(0101)    Module Private Definitions
(0102) 
(0103) ---------------------------------------------------------------------------*/
(0104) 
(0105) #if _FATFS != 6502	/* Revision ID */
(0106) #error Wrong include file (ff.h).
(0107) #endif
(0108) 
(0109) 
(0110) /* Definitions on sector size */
(0111) #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
(0112) #error Wrong sector size.
(0113) #endif
(0114) #if _MAX_SS != 512
(0115) #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
(0116) #else
(0117) #define	SS(fs)	512U			/* Fixed sector size */
(0118) #endif
(0119) 
(0120) 
(0121) /* Reentrancy related */
(0122) #if _FS_REENTRANT
(0123) #if _USE_LFN == 1
(0124) #error Static LFN work area must not be used in re-entrant configuration.
(0125) #endif
(0126) #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
(0127) #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
(0128) #else
(0129) #define	ENTER_FF(fs)
(0130) #define LEAVE_FF(fs, res)	return res
(0131) #endif
(0132) 
(0133) #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
(0134) 
(0135) 
(0136) /* File shareing feature */
(0137) #if _FS_SHARE
(0138) #if _FS_READONLY
(0139) #error _FS_SHARE must be 0 on read-only cfg.
(0140) #endif
(0141) typedef struct {
(0142) 	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
(0143) 	DWORD clu;				/* File ID 2, directory */
(0144) 	WORD idx;				/* File ID 3, directory index */
(0145) 	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
(0146) } FILESEM;
(0147) #endif
(0148) 
(0149) 
(0150) /* Misc definitions */
(0151) #define LD_CLUST(dir)	(((DWORD)LD_WORD(dir+DIR_FstClusHI)<<16) | LD_WORD(dir+DIR_FstClusLO))
(0152) #define ST_CLUST(dir,cl) {ST_WORD(dir+DIR_FstClusLO, cl); ST_WORD(dir+DIR_FstClusHI, (DWORD)cl>>16);}
(0153) 
(0154) 
(0155) /* DBCS code ranges and SBCS extend char conversion table */
(0156) 
(0157) #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
(0158) #define _DF1S	0x81	/* DBC 1st byte range 1 start */
(0159) #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
(0160) #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
(0161) #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
(0162) #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
(0163) #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
(0164) #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
(0165) #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
(0166) 
(0167) #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
(0168) #define _DF1S	0x81
(0169) #define _DF1E	0xFE
(0170) #define _DS1S	0x40
(0171) #define _DS1E	0x7E
(0172) #define _DS2S	0x80
(0173) #define _DS2E	0xFE
(0174) 
(0175) #elif _CODE_PAGE == 949	/* Korean */
(0176) #define _DF1S	0x81
(0177) #define _DF1E	0xFE
(0178) #define _DS1S	0x41
(0179) #define _DS1E	0x5A
(0180) #define _DS2S	0x61
(0181) #define _DS2E	0x7A
(0182) #define _DS3S	0x81
(0183) #define _DS3E	0xFE
(0184) 
(0185) #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
(0186) #define _DF1S	0x81
(0187) #define _DF1E	0xFE
(0188) #define _DS1S	0x40
(0189) #define _DS1E	0x7E
(0190) #define _DS2S	0xA1
(0191) #define _DS2E	0xFE
(0192) 
(0193) #elif _CODE_PAGE == 437	/* U.S. (OEM) */
(0194) #define _DF1S	0
(0195) #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0196) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0197) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0198) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0199) 
(0200) #elif _CODE_PAGE == 720	/* Arabic (OEM) */
(0201) #define _DF1S	0
(0202) #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0203) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0204) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0205) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0206) 
(0207) #elif _CODE_PAGE == 737	/* Greek (OEM) */
(0208) #define _DF1S	0
(0209) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
(0210) 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0211) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0212) 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0213) 
(0214) #elif _CODE_PAGE == 775	/* Baltic (OEM) */
(0215) #define _DF1S	0
(0216) #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0217) 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0218) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0219) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0220) 
(0221) #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
(0222) #define _DF1S	0
(0223) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0224) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0225) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0226) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0227) 
(0228) #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
(0229) #define _DF1S	0
(0230) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
(0231) 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
(0232) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0233) 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
(0234) 
(0235) #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
(0236) #define _DF1S	0
(0237) #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
(0238) 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
(0239) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
(0240) 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
(0241) 
(0242) #elif _CODE_PAGE == 857	/* Turkish (OEM) */
(0243) #define _DF1S	0
(0244) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
(0245) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0246) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0247) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0248) 
(0249) #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
(0250) #define _DF1S	0
(0251) #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
(0252) 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0253) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0254) 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0255) 
(0256) #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
(0257) #define _DF1S	0
(0258) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0259) 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0260) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0261) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0262) 
(0263) #elif _CODE_PAGE == 866	/* Russian (OEM) */
(0264) #define _DF1S	0
(0265) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0266) 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0267) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0268) 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0269) 
(0270) #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
(0271) #define _DF1S	0
(0272) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0273) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0274) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0275) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0276) 
(0277) #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
(0278) #define _DF1S	0
(0279) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0280) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
(0281) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0282) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0283) 
(0284) #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
(0285) #define _DF1S	0
(0286) #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
(0287) 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
(0288) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0289) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
(0290) 
(0291) #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
(0292) #define _DF1S	0
(0293) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
(0294) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0295) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0296) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0297) 
(0298) #elif _CODE_PAGE == 1253 /* Greek (Windows) */
(0299) #define _DF1S	0
(0300) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0301) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0302) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
(0303) 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
(0304) 
(0305) #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
(0306) #define _DF1S	0
(0307) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0308) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0309) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0310) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
(0311) 
(0312) #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
(0313) #define _DF1S	0
(0314) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0315) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0316) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0317) 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
(0318) 
(0319) #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
(0320) #define _DF1S	0
(0321) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
(0322) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0323) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0324) 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
(0325) 
(0326) #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
(0327) #define _DF1S	0
(0328) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
(0329) 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
(0330) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0331) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
(0332) 
(0333) #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
(0334) #define _DF1S	0
(0335) #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
(0336) 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
(0337) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
(0338) 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
(0339) 
(0340) #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
(0341) #if _USE_LFN
(0342) #error Cannot use LFN feature without valid code page.
(0343) #endif
(0344) #define _DF1S	0
(0345) 
(0346) #else
(0347) #error Unknown code page
(0348) 
(0349) #endif
(0350) 
(0351) 
(0352) /* Character code support macros */
(0353) #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
(0354) #define IsLower(c)	(((c)>='a')&&((c)<='z'))
(0355) #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
(0356) 
(0357) #if _DF1S		/* Code page is DBCS */
(0358) 
(0359) #ifdef _DF2S	/* Two 1st byte areas */
(0360) #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
(0361) #else			/* One 1st byte area */
(0362) #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
(0363) #endif
(0364) 
(0365) #ifdef _DS3S	/* Three 2nd byte areas */
(0366) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
(0367) #else			/* Two 2nd byte areas */
(0368) #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
(0369) #endif
(0370) 
(0371) #else			/* Code page is SBCS */
(0372) 
(0373) #define IsDBCS1(c)	0
(0374) #define IsDBCS2(c)	0
(0375) 
(0376) #endif /* _DF1S */
(0377) 
(0378) 
(0379) /* Name status flags */
(0380) #define NS			11		/* Index of name status byte in fn[] */
(0381) #define NS_LOSS		0x01	/* Out of 8.3 format */
(0382) #define NS_LFN		0x02	/* Force to create LFN entry */
(0383) #define NS_LAST		0x04	/* Last segment */
(0384) #define NS_BODY		0x08	/* Lower case flag (body) */
(0385) #define NS_EXT		0x10	/* Lower case flag (ext) */
(0386) #define NS_DOT		0x20	/* Dot entry */
(0387) 
(0388) 
(0389) /* FAT sub-type boundaries */
(0390) /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
(0391) #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
(0392) #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
(0393) 
(0394) 
(0395) /* FatFs refers the members in the FAT structures as byte array instead of
(0396) / structure member because the structure is not binary compatible between
(0397) / different platforms */
(0398) 
(0399) #define BS_jmpBoot			0	/* Jump instruction (3) */
(0400) #define BS_OEMName			3	/* OEM name (8) */
(0401) #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
(0402) #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
(0403) #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
(0404) #define BPB_NumFATs			16	/* Number of FAT copies (1) */
(0405) #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
(0406) #define BPB_TotSec16		19	/* Volume size [sector] (2) */
(0407) #define BPB_Media			21	/* Media descriptor (1) */
(0408) #define BPB_FATSz16			22	/* FAT size [sector] (2) */
(0409) #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
(0410) #define BPB_NumHeads		26	/* Number of heads (2) */
(0411) #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
(0412) #define BPB_TotSec32		32	/* Volume size [sector] (4) */
(0413) #define BS_DrvNum			36	/* Physical drive number (2) */
(0414) #define BS_BootSig			38	/* Extended boot signature (1) */
(0415) #define BS_VolID			39	/* Volume serial number (4) */
(0416) #define BS_VolLab			43	/* Volume label (8) */
(0417) #define BS_FilSysType		54	/* File system type (1) */
(0418) #define BPB_FATSz32			36	/* FAT size [sector] (4) */
(0419) #define BPB_ExtFlags		40	/* Extended flags (2) */
(0420) #define BPB_FSVer			42	/* File system version (2) */
(0421) #define BPB_RootClus		44	/* Root dir first cluster (4) */
(0422) #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
(0423) #define BPB_BkBootSec		50	/* Offset of backup boot sectot (2) */
(0424) #define BS_DrvNum32			64	/* Physical drive number (2) */
(0425) #define BS_BootSig32		66	/* Extended boot signature (1) */
(0426) #define BS_VolID32			67	/* Volume serial number (4) */
(0427) #define BS_VolLab32			71	/* Volume label (8) */
(0428) #define BS_FilSysType32		82	/* File system type (1) */
(0429) #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
(0430) #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
(0431) #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
(0432) #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
(0433) #define MBR_Table			446	/* MBR: Partition table offset (2) */
(0434) #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
(0435) #define BS_55AA				510	/* Boot sector signature (2) */
(0436) 
(0437) #define	DIR_Name			0	/* Short file name (11) */
(0438) #define	DIR_Attr			11	/* Attribute (1) */
(0439) #define	DIR_NTres			12	/* NT flag (1) */
(0440) #define	DIR_CrtTime			14	/* Created time (2) */
(0441) #define	DIR_CrtDate			16	/* Created date (2) */
(0442) #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
(0443) #define	DIR_WrtTime			22	/* Modified time (2) */
(0444) #define	DIR_WrtDate			24	/* Modified date (2) */
(0445) #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
(0446) #define	DIR_FileSize		28	/* File size (4) */
(0447) #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
(0448) #define	LDIR_Attr			11	/* LFN attribute (1) */
(0449) #define	LDIR_Type			12	/* LFN type (1) */
(0450) #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
(0451) #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
(0452) #define	SZ_DIR				32		/* Size of a directory entry */
(0453) #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
(0454) #define	DDE					0xE5	/* Deleted directory enrty mark in DIR_Name[0] */
(0455) #define	NDDE				0x05	/* Replacement of a character collides with DDE */
(0456) 
(0457) 
(0458) /*------------------------------------------------------------*/
(0459) /* Module private work area                                   */
(0460) /*------------------------------------------------------------*/
(0461) /* Note that uninitialized variables with static duration are
(0462) /  zeroed/nulled at start-up. If not, the compiler or start-up
(0463) /  routine is out of ANSI-C standard.
(0464) */
(0465) 
(0466) #if _VOLUMES
(0467) static
(0468) FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
(0469) #else
(0470) #error Number of volumes must not be 0.
(0471) #endif
(0472) 
(0473) static
(0474) WORD Fsid;				/* File system mount ID */
(0475) 
(0476) #if _FS_RPATH
(0477) static
(0478) BYTE CurrVol;			/* Current drive */
(0479) #endif
(0480) 
(0481) #if _FS_SHARE
(0482) static
(0483) FILESEM	Files[_FS_SHARE];	/* File lock semaphores */
(0484) #endif
(0485) 
(0486) #if _USE_LFN == 0			/* No LFN feature */
(0487) #define	DEF_NAMEBUF			BYTE sfn[12]
(0488) #define INIT_BUF(dobj)		(dobj).fn = sfn
(0489) #define	FREE_BUF()
(0490) 
(0491) #elif _USE_LFN == 1			/* LFN feature with static working buffer */
(0492) static WCHAR LfnBuf[_MAX_LFN+1];
(0493) #define	DEF_NAMEBUF			BYTE sfn[12]
(0494) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
(0495) #define	FREE_BUF()
(0496) 
(0497) #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
(0498) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
(0499) #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
(0500) #define	FREE_BUF()
(0501) 
(0502) #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
(0503) #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
(0504) #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
(0505) 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
(0506) 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
(0507) #define	FREE_BUF()			ff_memfree(lfn)
(0508) 
(0509) #else
(0510) #error Wrong LFN configuration.
(0511) #endif
(0512) 
(0513) 
(0514) 
(0515) 
(0516) /*--------------------------------------------------------------------------
(0517) 
(0518)    Module Private Functions
(0519) 
(0520) ---------------------------------------------------------------------------*/
(0521) 
(0522) 
(0523) /*-----------------------------------------------------------------------*/
(0524) /* String functions                                                      */
(0525) /*-----------------------------------------------------------------------*/
(0526) 
(0527) /* Copy memory to memory */
(0528) static
(0529) void mem_cpy (void* dst, const void* src, UINT cnt) {
(0530) 	BYTE *d = (BYTE*)dst;
    002E7 0158      MOVW	R10,R16
(0531) 	const BYTE *s = (const BYTE*)src;
    002E8 0169      MOVW	R12,R18
    002E9 C006      RJMP	0x02F0
(0532) 
(0533) #if _WORD_ACCESS == 1
(0534) 	while (cnt >= sizeof(int)) {
(0535) 		*(int*)d = *(int*)s;
(0536) 		d += sizeof(int); s += sizeof(int);
(0537) 		cnt -= sizeof(int);
(0538) 	}
(0539) #endif
(0540) 	while (cnt--)
(0541) 		*d++ = *s++;
    002EA 01F6      MOVW	R30,R12
    002EB 01D5      MOVW	R26,R10
    002EC 9001      LD	R0,Z+
    002ED 016F      MOVW	R12,R30
    002EE 920D      ST	X+,R0
    002EF 015D      MOVW	R10,R26
    002F0 011A      MOVW	R2,R20
    002F1 5041      SUBI	R20,1
    002F2 4050      SBCI	R21,0
    002F3 2022      TST	R2
    002F4 F7A9      BNE	0x02EA
    002F5 2033      TST	R3
    002F6 F799      BNE	0x02EA
    002F7 940C 3FA8 JMP	pop_xgset303C
ff.c:mem_set:
  d                    --> R10
  cnt                  --> R20
  val                  --> R18
  dst                  --> R16
    002F9 940E 3F7F CALL	push_xgset300C
    002FB 814C      LDD	R20,Y+4
    002FC 815D      LDD	R21,Y+5
(0542) }
(0543) 
(0544) /* Fill memory */
(0545) static
(0546) void mem_set (void* dst, int val, UINT cnt) {
(0547) 	BYTE *d = (BYTE*)dst;
    002FD 0158      MOVW	R10,R16
    002FE C003      RJMP	0x0302
(0548) 
(0549) 	while (cnt--)
(0550) 		*d++ = (BYTE)val;
    002FF 01F5      MOVW	R30,R10
    00300 9321      ST	Z+,R18
    00301 015F      MOVW	R10,R30
    00302 011A      MOVW	R2,R20
    00303 5041      SUBI	R20,1
    00304 4050      SBCI	R21,0
    00305 2022      TST	R2
    00306 F7C1      BNE	0x02FF
    00307 2033      TST	R3
    00308 F7B1      BNE	0x02FF
    00309 940C 3F84 JMP	pop_xgset300C
ff.c:mem_cmp:
  s                    --> R14
  d                    --> R12
  r                    --> R10
  cnt                  --> R20
  src                  --> R18
  dst                  --> R16
    0030B 940E 3F76 CALL	push_xgset30FC
    0030D 8548      LDD	R20,Y+8
    0030E 8559      LDD	R21,Y+9
(0551) }
(0552) 
(0553) /* Compare memory to memory */
(0554) static
(0555) int mem_cmp (const void* dst, const void* src, UINT cnt) {
(0556) 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    0030F 0168      MOVW	R12,R16
    00310 0179      MOVW	R14,R18
(0557) 	int r = 0;
    00311 24AA      CLR	R10
    00312 24BB      CLR	R11
(0558) 
(0559) 	while (cnt-- && (r = *d++ - *s++) == 0) ;
    00313 011A      MOVW	R2,R20
    00314 5041      SUBI	R20,1
    00315 4050      SBCI	R21,0
    00316 2022      TST	R2
    00317 F411      BNE	0x031A
    00318 2033      TST	R3
    00319 F079      BEQ	0x0329
    0031A 01F7      MOVW	R30,R14
    0031B 9021      LD	R2,Z+
    0031C 017F      MOVW	R14,R30
    0031D 2433      CLR	R3
    0031E 01F6      MOVW	R30,R12
    0031F 9041      LD	R4,Z+
    00320 016F      MOVW	R12,R30
    00321 2455      CLR	R5
    00322 1842      SUB	R4,R2
    00323 0853      SBC	R5,R3
    00324 0152      MOVW	R10,R4
    00325 20AA      TST	R10
    00326 F411      BNE	0x0329
    00327 20BB      TST	R11
    00328 F351      BEQ	0x0313
(0560) 	return r;
    00329 0185      MOVW	R16,R10
    0032A 940C 3F60 JMP	pop_xgset30FC
(0561) }
(0562) 
(0563) /* Check if chr is contained in the string */
(0564) static
(0565) int chk_chr (const char* str, int chr) {
ff.c:chk_chr:
  chr                  --> R18
  str                  --> R16
    0032C C002      RJMP	0x032F
(0566) 	while (*str && *str != chr) str++;
    0032D 5F0F      SUBI	R16,0xFF
    0032E 4F1F      SBCI	R17,0xFF
    0032F 01F8      MOVW	R30,R16
    00330 8020      LD	R2,Z
    00331 2433      CLR	R3
    00332 2022      TST	R2
    00333 F021      BEQ	0x0338
    00334 2433      CLR	R3
    00335 1622      CP	R2,R18
    00336 0633      CPC	R3,R19
    00337 F7A9      BNE	0x032D
(0567) 	return *str;
    00338 01F8      MOVW	R30,R16
    00339 8100      LD	R16,Z
    0033A 2711      CLR	R17
    0033B 9508      RET
ff.c:move_window:
  nf                   --> R10
  wsect                --> Y,+5
  sector               --> Y,+13
  fs                   --> R20
    0033C 933A      ST	-Y,R19
    0033D 932A      ST	-Y,R18
    0033E 940E 3F7F CALL	push_xgset300C
    00340 01A8      MOVW	R20,R16
    00341 9729      SBIW	R28,0x9
(0568) }
(0569) 
(0570) 
(0571) 
(0572) /*-----------------------------------------------------------------------*/
(0573) /* Request/Release grant to access the volume                            */
(0574) /*-----------------------------------------------------------------------*/
(0575) #if _FS_REENTRANT
(0576) 
(0577) static
(0578) int lock_fs (
(0579) 	FATFS *fs		/* File system object */
(0580) )
(0581) {
(0582) 	return ff_req_grant(fs->sobj);
(0583) }
(0584) 
(0585) 
(0586) static
(0587) void unlock_fs (
(0588) 	FATFS *fs,		/* File system object */
(0589) 	FRESULT res		/* Result code to be returned */
(0590) )
(0591) {
(0592) 	if (res != FR_NOT_ENABLED &&
(0593) 		res != FR_INVALID_DRIVE &&
(0594) 		res != FR_INVALID_OBJECT &&
(0595) 		res != FR_TIMEOUT) {
(0596) 		ff_rel_grant(fs->sobj);
(0597) 	}
(0598) }
(0599) #endif
(0600) 
(0601) 
(0602) 
(0603) /*-----------------------------------------------------------------------*/
(0604) /* File shareing control functions                                       */
(0605) /*-----------------------------------------------------------------------*/
(0606) #if _FS_SHARE
(0607) 
(0608) static
(0609) FRESULT chk_lock (	/* Check if the file can be accessed */
(0610) 	DIR* dj,		/* Directory object pointing the file to be checked */
(0611) 	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
(0612) )
(0613) {
(0614) 	UINT i, be;
(0615) 
(0616) 	/* Search file semaphore table */
(0617) 	for (i = be = 0; i < _FS_SHARE; i++) {
(0618) 		if (Files[i].fs) {	/* Existing entry */
(0619) 			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
(0620) 				Files[i].clu == dj->sclust &&
(0621) 				Files[i].idx == dj->index) break;
(0622) 		} else {			/* Blank entry */
(0623) 			be++;
(0624) 		}
(0625) 	}
(0626) 	if (i == _FS_SHARE)	/* The file is not opened */
(0627) 		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
(0628) 
(0629) 	/* The file has been opened. Reject any open against writing file and all write mode open */
(0630) 	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
(0631) }
(0632) 
(0633) 
(0634) static
(0635) int enq_lock (void)	/* Check if an entry is available for a new file */
(0636) {
(0637) 	UINT i;
(0638) 
(0639) 	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0640) 	return (i == _FS_SHARE) ? 0 : 1;
(0641) }
(0642) 
(0643) 
(0644) static
(0645) UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
(0646) 	DIR* dj,	/* Directory object pointing the file to register or increment */
(0647) 	int acc		/* Desired access mode (0:Read, !0:Write) */
(0648) )
(0649) {
(0650) 	UINT i;
(0651) 
(0652) 
(0653) 	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
(0654) 		if (Files[i].fs == dj->fs &&
(0655) 			Files[i].clu == dj->sclust &&
(0656) 			Files[i].idx == dj->index) break;
(0657) 	}
(0658) 
(0659) 	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
(0660) 		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
(0661) 		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
(0662) 		Files[i].fs = dj->fs;
(0663) 		Files[i].clu = dj->sclust;
(0664) 		Files[i].idx = dj->index;
(0665) 		Files[i].ctr = 0;
(0666) 	}
(0667) 
(0668) 	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
(0669) 
(0670) 	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
(0671) 
(0672) 	return i + 1;
(0673) }
(0674) 
(0675) 
(0676) static
(0677) FRESULT dec_lock (	/* Decrement file open counter */
(0678) 	UINT i			/* Semaphore index */
(0679) )
(0680) {
(0681) 	WORD n;
(0682) 	FRESULT res;
(0683) 
(0684) 
(0685) 	if (--i < _FS_SHARE) {
(0686) 		n = Files[i].ctr;
(0687) 		if (n == 0x100) n = 0;
(0688) 		if (n) n--;
(0689) 		Files[i].ctr = n;
(0690) 		if (!n) Files[i].fs = 0;
(0691) 		res = FR_OK;
(0692) 	} else {
(0693) 		res = FR_INT_ERR;
(0694) 	}
(0695) 	return res;
(0696) }
(0697) 
(0698) 
(0699) static
(0700) void clear_lock (	/* Clear lock entries of the volume */
(0701) 	FATFS *fs
(0702) )
(0703) {
(0704) 	UINT i;
(0705) 
(0706) 	for (i = 0; i < _FS_SHARE; i++) {
(0707) 		if (Files[i].fs == fs) Files[i].fs = 0;
(0708) 	}
(0709) }
(0710) #endif
(0711) 
(0712) 
(0713) 
(0714) /*-----------------------------------------------------------------------*/
(0715) /* Change window offset                                                  */
(0716) /*-----------------------------------------------------------------------*/
(0717) 
(0718) static
(0719) FRESULT move_window (
(0720) 	FATFS *fs,		/* File system object */
(0721) 	DWORD sector	/* Sector number to make appearance in the fs->win[] */
(0722) )					/* Move to zero only writes back dirty window */
(0723) {
(0724) 	DWORD wsect;
(0725) 
(0726) 
(0727) 	wsect = fs->winsect;
    00342 01FA      MOVW	R30,R20
    00343 96BA      ADIW	R30,0x2A
    00344 8020      LD	R2,Z
    00345 8031      LDD	R3,Z+1
    00346 8042      LDD	R4,Z+2
    00347 8053      LDD	R5,Z+3
    00348 822D      STD	Y+5,R2
    00349 823E      STD	Y+6,R3
    0034A 824F      STD	Y+7,R4
    0034B 8658      STD	Y+8,R5
(0728) 	if (wsect != sector) {	/* Changed current window */
    0034C 842D      LDD	R2,Y+13
    0034D 843E      LDD	R3,Y+14
    0034E 844F      LDD	R4,Y+15
    0034F 8858      LDD	R5,Y+16
    00350 806D      LDD	R6,Y+5
    00351 807E      LDD	R7,Y+6
    00352 808F      LDD	R8,Y+7
    00353 8498      LDD	R9,Y+8
    00354 1462      CP	R6,R2
    00355 0473      CPC	R7,R3
    00356 0484      CPC	R8,R4
    00357 0495      CPC	R9,R5
    00358 F409      BNE	0x035A
    00359 C07E      RJMP	0x03D8
(0729) #if !_FS_READONLY
(0730) 		if (fs->wflag) {	/* Write back dirty window if needed */
    0035A 01FA      MOVW	R30,R20
    0035B 8024      LDD	R2,Z+4
    0035C 2022      TST	R2
    0035D F409      BNE	0x035F
    0035E C055      RJMP	0x03B4
(0731) 			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
    0035F E081      LDI	R24,1
    00360 838C      STD	Y+4,R24
    00361 0113      MOVW	R2,R6
    00362 0124      MOVW	R4,R8
    00363 8228      ST	Y,R2
    00364 8239      STD	Y+1,R3
    00365 824A      STD	Y+2,R4
    00366 825B      STD	Y+3,R5
    00367 019A      MOVW	R18,R20
    00368 5D22      SUBI	R18,0xD2
    00369 4F3F      SBCI	R19,0xFF
    0036A 8101      LDD	R16,Z+1
    0036B 940E 02C1 CALL	_disk_write
    0036D 2300      TST	R16
    0036E F011      BEQ	0x0371
(0732) 				return FR_DISK_ERR;
    0036F E001      LDI	R16,1
    00370 C068      RJMP	0x03D9
(0733) 			fs->wflag = 0;
    00371 2422      CLR	R2
    00372 01FA      MOVW	R30,R20
    00373 8224      STD	Z+4,R2
(0734) 			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
    00374 8C22      LDD	R2,Z+26
    00375 8C33      LDD	R3,Z+27
    00376 8C44      LDD	R4,Z+28
    00377 8C55      LDD	R5,Z+29
    00378 967E      ADIW	R30,0x1E
    00379 8060      LD	R6,Z
    0037A 8071      LDD	R7,Z+1
    0037B 8082      LDD	R8,Z+2
    0037C 8093      LDD	R9,Z+3
    0037D 0C62      ADD	R6,R2
    0037E 1C73      ADC	R7,R3
    0037F 1C84      ADC	R8,R4
    00380 1C95      ADC	R9,R5
    00381 802D      LDD	R2,Y+5
    00382 803E      LDD	R3,Y+6
    00383 804F      LDD	R4,Y+7
    00384 8458      LDD	R5,Y+8
    00385 1426      CP	R2,R6
    00386 0437      CPC	R3,R7
    00387 0448      CPC	R4,R8
    00388 0459      CPC	R5,R9
    00389 F550      BCC	0x03B4
(0735) 				BYTE nf;
(0736) 				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
    0038A 01FA      MOVW	R30,R20
    0038B 80A3      LDD	R10,Z+3
    0038C C024      RJMP	0x03B1
(0737) 					wsect += fs->fsize;
    0038D 01FA      MOVW	R30,R20
    0038E 967A      ADIW	R30,0x1A
    0038F 8020      LD	R2,Z
    00390 8031      LDD	R3,Z+1
    00391 8042      LDD	R4,Z+2
    00392 8053      LDD	R5,Z+3
    00393 806D      LDD	R6,Y+5
    00394 807E      LDD	R7,Y+6
    00395 808F      LDD	R8,Y+7
    00396 8498      LDD	R9,Y+8
    00397 0C62      ADD	R6,R2
    00398 1C73      ADC	R7,R3
    00399 1C84      ADC	R8,R4
    0039A 1C95      ADC	R9,R5
    0039B 826D      STD	Y+5,R6
    0039C 827E      STD	Y+6,R7
    0039D 828F      STD	Y+7,R8
    0039E 8698      STD	Y+8,R9
(0738) 					disk_write(fs->drv, fs->win, wsect, 1);
    0039F E081      LDI	R24,1
    003A0 838C      STD	Y+4,R24
    003A1 802D      LDD	R2,Y+5
    003A2 803E      LDD	R3,Y+6
    003A3 804F      LDD	R4,Y+7
    003A4 8458      LDD	R5,Y+8
    003A5 8228      ST	Y,R2
    003A6 8239      STD	Y+1,R3
    003A7 824A      STD	Y+2,R4
    003A8 825B      STD	Y+3,R5
    003A9 019A      MOVW	R18,R20
    003AA 5D22      SUBI	R18,0xD2
    003AB 4F3F      SBCI	R19,0xFF
    003AC 01FA      MOVW	R30,R20
    003AD 8101      LDD	R16,Z+1
    003AE 940E 02C1 CALL	_disk_write
    003B0 94AA      DEC	R10
    003B1 E081      LDI	R24,1
    003B2 158A      CP	R24,R10
    003B3 F2C8      BCS	0x038D
(0739) 				}
(0740) 			}
(0741) 		}
(0742) #endif
(0743) 		if (sector) {
    003B4 842D      LDD	R2,Y+13
    003B5 843E      LDD	R3,Y+14
    003B6 844F      LDD	R4,Y+15
    003B7 8858      LDD	R5,Y+16
    003B8 9488      BCLR	0
    003B9 2022      TST	R2
    003BA 0432      CPC	R3,R2
    003BB 0442      CPC	R4,R2
    003BC 0452      CPC	R5,R2
    003BD F0D1      BEQ	0x03D8
(0744) 			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    003BE E081      LDI	R24,1
    003BF 838C      STD	Y+4,R24
    003C0 8228      ST	Y,R2
    003C1 8239      STD	Y+1,R3
    003C2 824A      STD	Y+2,R4
    003C3 825B      STD	Y+3,R5
    003C4 019A      MOVW	R18,R20
    003C5 5D22      SUBI	R18,0xD2
    003C6 4F3F      SBCI	R19,0xFF
    003C7 01FA      MOVW	R30,R20
    003C8 8101      LDD	R16,Z+1
    003C9 940E 02A1 CALL	_disk_read
    003CB 2300      TST	R16
    003CC F011      BEQ	0x03CF
(0745) 				return FR_DISK_ERR;
    003CD E001      LDI	R16,1
    003CE C00A      RJMP	0x03D9
(0746) 			fs->winsect = sector;
    003CF 842D      LDD	R2,Y+13
    003D0 843E      LDD	R3,Y+14
    003D1 844F      LDD	R4,Y+15
    003D2 8858      LDD	R5,Y+16
    003D3 01FA      MOVW	R30,R20
    003D4 A622      STD	Z+42,R2
    003D5 A633      STD	Z+43,R3
    003D6 A644      STD	Z+44,R4
    003D7 A655      STD	Z+45,R5
(0747) 		}
(0748) 	}
(0749) 
(0750) 	return FR_OK;
    003D8 2700      CLR	R16
    003D9 9629      ADIW	R28,0x9
    003DA 940E 3F84 CALL	pop_xgset300C
    003DC 9622      ADIW	R28,2
    003DD 9508      RET
ff.c:sync:
  res                  --> R20
  fs                   --> R22
    003DE 940E 3F89 CALL	push_xgsetF000
    003E0 01B8      MOVW	R22,R16
    003E1 9725      SBIW	R28,5
(0751) }
(0752) 
(0753) 
(0754) 
(0755) 
(0756) /*-----------------------------------------------------------------------*/
(0757) /* Clean-up cached data                                                  */
(0758) /*-----------------------------------------------------------------------*/
(0759) #if !_FS_READONLY
(0760) static
(0761) FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
(0762) 	FATFS *fs	/* File system object */
(0763) )
(0764) {
(0765) 	FRESULT res;
(0766) 
(0767) 
(0768) 	res = move_window(fs, 0);
    003E2 E080      LDI	R24,0
    003E3 E090      LDI	R25,0
    003E4 E0A0      LDI	R26,0
    003E5 E0B0      LDI	R27,0
    003E6 83A8      ST	Y,R26
    003E7 83B9      STD	Y+1,R27
    003E8 019C      MOVW	R18,R24
    003E9 018B      MOVW	R16,R22
    003EA DF51      RCALL	ff.c:move_window
    003EB 2F40      MOV	R20,R16
(0769) 	if (res == FR_OK) {
    003EC 2300      TST	R16
    003ED F009      BEQ	0x03EF
    003EE C0C0      RJMP	0x04AF
(0770) 		/* Update FSInfo sector if needed */
(0771) 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
    003EF 01FB      MOVW	R30,R22
    003F0 8180      LD	R24,Z
    003F1 3083      CPI	R24,3
    003F2 F009      BEQ	0x03F4
    003F3 C0AC      RJMP	0x04A0
    003F4 8025      LDD	R2,Z+5
    003F5 2022      TST	R2
    003F6 F409      BNE	0x03F8
    003F7 C0A8      RJMP	0x04A0
(0772) 			fs->winsect = 0;
    003F8 96BA      ADIW	R30,0x2A
    003F9 E080      LDI	R24,0
    003FA 8380      ST	Z,R24
    003FB 8381      STD	Z+1,R24
    003FC 8382      STD	Z+2,R24
    003FD 8383      STD	Z+3,R24
(0773) 			/* Create FSInfo structure */
(0774) 			mem_set(fs->win, 0, 512);
    003FE E080      LDI	R24,0
    003FF E092      LDI	R25,2
    00400 8399      STD	Y+1,R25
    00401 8388      ST	Y,R24
    00402 2722      CLR	R18
    00403 2733      CLR	R19
    00404 018B      MOVW	R16,R22
    00405 5D02      SUBI	R16,0xD2
    00406 4F1F      SBCI	R17,0xFF
    00407 DEF1      RCALL	ff.c:mem_set
(0775) 			ST_WORD(fs->win+BS_55AA, 0xAA55);
    00408 E585      LDI	R24,0x55
    00409 01FB      MOVW	R30,R22
    0040A 5DE4      SUBI	R30,0xD4
    0040B 4FFD      SBCI	R31,0xFD
    0040C 8380      ST	Z,R24
    0040D 52EC      SUBI	R30,0x2C
    0040E 40F2      SBCI	R31,2
    0040F EA8A      LDI	R24,0xAA
    00410 5DE3      SUBI	R30,0xD3
    00411 4FFD      SBCI	R31,0xFD
    00412 8380      ST	Z,R24
    00413 52ED      SUBI	R30,0x2D
    00414 40F2      SBCI	R31,2
(0776) 			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
    00415 E582      LDI	R24,0x52
    00416 A786      STD	Z+46,R24
    00417 A787      STD	Z+47,R24
    00418 E681      LDI	R24,0x61
    00419 AB80      STD	Z+48,R24
    0041A E481      LDI	R24,0x41
    0041B AB81      STD	Z+49,R24
(0777) 			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
    0041C E782      LDI	R24,0x72
    0041D 5EEE      SUBI	R30,0xEE
    0041E 4FFD      SBCI	R31,0xFD
    0041F 8380      ST	Z,R24
    00420 51E2      SUBI	R30,0x12
    00421 40F2      SBCI	R31,2
    00422 5EED      SUBI	R30,0xED
    00423 4FFD      SBCI	R31,0xFD
    00424 8380      ST	Z,R24
    00425 51E3      SUBI	R30,0x13
    00426 40F2      SBCI	R31,2
    00427 E481      LDI	R24,0x41
    00428 5EEC      SUBI	R30,0xEC
    00429 4FFD      SBCI	R31,0xFD
    0042A 8380      ST	Z,R24
    0042B 51E4      SUBI	R30,0x14
    0042C 40F2      SBCI	R31,2
    0042D E681      LDI	R24,0x61
    0042E 5EEB      SUBI	R30,0xEB
    0042F 4FFD      SBCI	R31,0xFD
    00430 8380      ST	Z,R24
    00431 51E5      SUBI	R30,0x15
    00432 40F2      SBCI	R31,2
(0778) 			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
    00433 8426      LDD	R2,Z+14
    00434 8437      LDD	R3,Z+15
    00435 8840      LDD	R4,Z+16
    00436 8851      LDD	R5,Z+17
    00437 5EEA      SUBI	R30,0xEA
    00438 4FFD      SBCI	R31,0xFD
    00439 8220      ST	Z,R2
    0043A 51E6      SUBI	R30,0x16
    0043B 40F2      SBCI	R31,2
    0043C 8426      LDD	R2,Z+14
    0043D 8437      LDD	R3,Z+15
    0043E 2C23      MOV	R2,R3
    0043F 2433      CLR	R3
    00440 5EE9      SUBI	R30,0xE9
    00441 4FFD      SBCI	R31,0xFD
    00442 8220      ST	Z,R2
    00443 51E7      SUBI	R30,0x17
    00444 40F2      SBCI	R31,2
    00445 8426      LDD	R2,Z+14
    00446 8437      LDD	R3,Z+15
    00447 8840      LDD	R4,Z+16
    00448 8851      LDD	R5,Z+17
    00449 0112      MOVW	R2,R4
    0044A 2444      CLR	R4
    0044B 2455      CLR	R5
    0044C 5EE8      SUBI	R30,0xE8
    0044D 4FFD      SBCI	R31,0xFD
    0044E 8220      ST	Z,R2
    0044F 51E8      SUBI	R30,0x18
    00450 40F2      SBCI	R31,2
    00451 E188      LDI	R24,0x18
    00452 E090      LDI	R25,0
    00453 8506      LDD	R16,Z+14
    00454 8517      LDD	R17,Z+15
    00455 8920      LDD	R18,Z+16
    00456 8931      LDD	R19,Z+17
    00457 938A      ST	-Y,R24
    00458 940E 400F CALL	lsr32
    0045A 01FB      MOVW	R30,R22
    0045B 5EE7      SUBI	R30,0xE7
    0045C 4FFD      SBCI	R31,0xFD
    0045D 8300      ST	Z,R16
    0045E 51E9      SUBI	R30,0x19
    0045F 40F2      SBCI	R31,2
(0779) 			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
    00460 8422      LDD	R2,Z+10
    00461 8433      LDD	R3,Z+11
    00462 8444      LDD	R4,Z+12
    00463 8455      LDD	R5,Z+13
    00464 5EE6      SUBI	R30,0xE6
    00465 4FFD      SBCI	R31,0xFD
    00466 8220      ST	Z,R2
    00467 51EA      SUBI	R30,0x1A
    00468 40F2      SBCI	R31,2
    00469 8422      LDD	R2,Z+10
    0046A 8433      LDD	R3,Z+11
    0046B 2C23      MOV	R2,R3
    0046C 2433      CLR	R3
    0046D 5EE5      SUBI	R30,0xE5
    0046E 4FFD      SBCI	R31,0xFD
    0046F 8220      ST	Z,R2
    00470 51EB      SUBI	R30,0x1B
    00471 40F2      SBCI	R31,2
    00472 8422      LDD	R2,Z+10
    00473 8433      LDD	R3,Z+11
    00474 8444      LDD	R4,Z+12
    00475 8455      LDD	R5,Z+13
    00476 0112      MOVW	R2,R4
    00477 2444      CLR	R4
    00478 2455      CLR	R5
    00479 5EE4      SUBI	R30,0xE4
    0047A 4FFD      SBCI	R31,0xFD
    0047B 8220      ST	Z,R2
    0047C 51EC      SUBI	R30,0x1C
    0047D 40F2      SBCI	R31,2
    0047E E188      LDI	R24,0x18
    0047F E090      LDI	R25,0
    00480 8502      LDD	R16,Z+10
    00481 8513      LDD	R17,Z+11
    00482 8524      LDD	R18,Z+12
    00483 8535      LDD	R19,Z+13
    00484 938A      ST	-Y,R24
    00485 940E 400F CALL	lsr32
    00487 01FB      MOVW	R30,R22
    00488 5EE3      SUBI	R30,0xE3
    00489 4FFD      SBCI	R31,0xFD
    0048A 8300      ST	Z,R16
    0048B 51ED      SUBI	R30,0x1D
    0048C 40F2      SBCI	R31,2
(0780) 			/* Write it into the FSInfo sector */
(0781) 			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
    0048D E081      LDI	R24,1
    0048E 838C      STD	Y+4,R24
    0048F 8822      LDD	R2,Z+18
    00490 8833      LDD	R3,Z+19
    00491 8844      LDD	R4,Z+20
    00492 8855      LDD	R5,Z+21
    00493 8228      ST	Y,R2
    00494 8239      STD	Y+1,R3
    00495 824A      STD	Y+2,R4
    00496 825B      STD	Y+3,R5
    00497 019F      MOVW	R18,R30
    00498 5D22      SUBI	R18,0xD2
    00499 4F3F      SBCI	R19,0xFF
    0049A 8101      LDD	R16,Z+1
    0049B 940E 02C1 CALL	_disk_write
(0782) 			fs->fsi_flag = 0;
    0049D 2422      CLR	R2
    0049E 01FB      MOVW	R30,R22
    0049F 8225      STD	Z+5,R2
(0783) 		}
(0784) 		/* Make sure that no pending write process in the physical drive */
(0785) 		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
    004A0 2422      CLR	R2
    004A1 2433      CLR	R3
    004A2 8239      STD	Y+1,R3
    004A3 8228      ST	Y,R2
    004A4 2722      CLR	R18
    004A5 2733      CLR	R19
    004A6 01FB      MOVW	R30,R22
    004A7 8101      LDD	R16,Z+1
    004A8 2711      CLR	R17
    004A9 940E 02D9 CALL	_disk_ioctl
    004AB 3000      CPI	R16,0
    004AC 0701      CPC	R16,R17
    004AD F009      BEQ	0x04AF
(0786) 			res = FR_DISK_ERR;
    004AE E041      LDI	R20,1
(0787) 	}
(0788) 
(0789) 	return res;
    004AF 2F04      MOV	R16,R20
    004B0 9625      ADIW	R28,5
    004B1 940C 3F8E JMP	pop_xgsetF000
_clust2sect:
  clst                 --> Y,+6
  fs                   --> R10
    004B3 933A      ST	-Y,R19
    004B4 932A      ST	-Y,R18
    004B5 940E 3F93 CALL	push_xgsetF00C
    004B7 0158      MOVW	R10,R16
(0790) }
(0791) #endif
(0792) 
(0793) 
(0794) 
(0795) 
(0796) /*-----------------------------------------------------------------------*/
(0797) /* Get sector# from cluster#                                             */
(0798) /*-----------------------------------------------------------------------*/
(0799) 
(0800) 
(0801) DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
(0802) 	FATFS *fs,		/* File system object */
(0803) 	DWORD clst		/* Cluster# to be converted */
(0804) )
(0805) {
(0806) 	clst -= 2;
    004B8 E042      LDI	R20,2
    004B9 E050      LDI	R21,0
    004BA E060      LDI	R22,0
    004BB E070      LDI	R23,0
    004BC 802E      LDD	R2,Y+6
    004BD 803F      LDD	R3,Y+7
    004BE 8448      LDD	R4,Y+8
    004BF 8459      LDD	R5,Y+9
    004C0 1A24      SUB	R2,R20
    004C1 0A35      SBC	R3,R21
    004C2 0A46      SBC	R4,R22
    004C3 0A57      SBC	R5,R23
    004C4 822E      STD	Y+6,R2
    004C5 823F      STD	Y+7,R3
    004C6 8648      STD	Y+8,R4
    004C7 8659      STD	Y+9,R5
(0807) 	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    004C8 E042      LDI	R20,2
    004C9 E050      LDI	R21,0
    004CA E060      LDI	R22,0
    004CB E070      LDI	R23,0
    004CC 01F5      MOVW	R30,R10
    004CD 9676      ADIW	R30,0x16
    004CE 8020      LD	R2,Z
    004CF 8031      LDD	R3,Z+1
    004D0 8042      LDD	R4,Z+2
    004D1 8053      LDD	R5,Z+3
    004D2 1A24      SUB	R2,R20
    004D3 0A35      SBC	R3,R21
    004D4 0A46      SBC	R4,R22
    004D5 0A57      SBC	R5,R23
    004D6 806E      LDD	R6,Y+6
    004D7 807F      LDD	R7,Y+7
    004D8 8488      LDD	R8,Y+8
    004D9 8499      LDD	R9,Y+9
    004DA 1462      CP	R6,R2
    004DB 0473      CPC	R7,R3
    004DC 0484      CPC	R8,R4
    004DD 0495      CPC	R9,R5
    004DE F028      BCS	0x04E4
    004DF E000      LDI	R16,0
    004E0 E010      LDI	R17,0
    004E1 E020      LDI	R18,0
    004E2 E030      LDI	R19,0
    004E3 C01D      RJMP	0x0501
(0808) 	return clst * fs->csize + fs->database;
    004E4 01F5      MOVW	R30,R10
    004E5 9632      ADIW	R30,2
    004E6 8020      LD	R2,Z
    004E7 2433      CLR	R3
    004E8 2444      CLR	R4
    004E9 2455      CLR	R5
    004EA 810E      LDD	R16,Y+6
    004EB 811F      LDD	R17,Y+7
    004EC 8528      LDD	R18,Y+8
    004ED 8539      LDD	R19,Y+9
    004EE 925A      ST	-Y,R5
    004EF 924A      ST	-Y,R4
    004F0 923A      ST	-Y,R3
    004F1 922A      ST	-Y,R2
    004F2 940E 3F20 CALL	empy32u|empy32s
    004F4 0118      MOVW	R2,R16
    004F5 0129      MOVW	R4,R18
    004F6 01F5      MOVW	R30,R10
    004F7 A066      LDD	R6,Z+38
    004F8 A077      LDD	R7,Z+39
    004F9 A480      LDD	R8,Z+40
    004FA A491      LDD	R9,Z+41
    004FB 0C26      ADD	R2,R6
    004FC 1C37      ADC	R3,R7
    004FD 1C48      ADC	R4,R8
    004FE 1C59      ADC	R5,R9
    004FF 0181      MOVW	R16,R2
    00500 0192      MOVW	R18,R4
    00501 940E 3F9A CALL	pop_xgsetF00C
    00503 9622      ADIW	R28,2
    00504 9508      RET
_get_fat:
  wc                   --> R14
  p                    --> R10
  bc                   --> R10
  clst                 --> Y,+12
  fs                   --> R12
    00505 933A      ST	-Y,R19
    00506 932A      ST	-Y,R18
    00507 940E 3F74 CALL	push_xgsetF0FC
    00509 0168      MOVW	R12,R16
    0050A 9722      SBIW	R28,2
(0809) }
(0810) 
(0811) 
(0812) 
(0813) 
(0814) /*-----------------------------------------------------------------------*/
(0815) /* FAT access - Read value of a FAT entry                                */
(0816) /*-----------------------------------------------------------------------*/
(0817) 
(0818) 
(0819) DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
(0820) 	FATFS *fs,	/* File system object */
(0821) 	DWORD clst	/* Cluster# to get the link information */
(0822) )
(0823) {
(0824) 	UINT wc, bc;
(0825) 	BYTE *p;
(0826) 
(0827) 
(0828) 	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
    0050B E042      LDI	R20,2
    0050C E050      LDI	R21,0
    0050D E060      LDI	R22,0
    0050E E070      LDI	R23,0
    0050F 842C      LDD	R2,Y+12
    00510 843D      LDD	R3,Y+13
    00511 844E      LDD	R4,Y+14
    00512 845F      LDD	R5,Y+15
    00513 1624      CP	R2,R20
    00514 0635      CPC	R3,R21
    00515 0646      CPC	R4,R22
    00516 0657      CPC	R5,R23
    00517 F078      BCS	0x0527
    00518 01F6      MOVW	R30,R12
    00519 9676      ADIW	R30,0x16
    0051A 8020      LD	R2,Z
    0051B 8031      LDD	R3,Z+1
    0051C 8042      LDD	R4,Z+2
    0051D 8053      LDD	R5,Z+3
    0051E 846C      LDD	R6,Y+12
    0051F 847D      LDD	R7,Y+13
    00520 848E      LDD	R8,Y+14
    00521 849F      LDD	R9,Y+15
    00522 1462      CP	R6,R2
    00523 0473      CPC	R7,R3
    00524 0484      CPC	R8,R4
    00525 0495      CPC	R9,R5
    00526 F028      BCS	0x052C
(0829) 		return 1;
    00527 E001      LDI	R16,1
    00528 E010      LDI	R17,0
    00529 E020      LDI	R18,0
    0052A E030      LDI	R19,0
    0052B C124      RJMP	0x0650
(0830) 
(0831) 	switch (fs->fs_type) {
    0052C 01F6      MOVW	R30,R12
    0052D 80A0      LD	R10,Z
    0052E 24BB      CLR	R11
    0052F 01C5      MOVW	R24,R10
    00530 3081      CPI	R24,1
    00531 E0E0      LDI	R30,0
    00532 079E      CPC	R25,R30
    00533 F059      BEQ	0x053F
    00534 3082      CPI	R24,2
    00535 E0E0      LDI	R30,0
    00536 079E      CPC	R25,R30
    00537 F409      BNE	0x0539
    00538 C06F      RJMP	0x05A8
    00539 3083      CPI	R24,3
    0053A E0E0      LDI	R30,0
    0053B 079E      CPC	R25,R30
    0053C F409      BNE	0x053E
    0053D C0A6      RJMP	0x05E4
    0053E C10D      RJMP	0x064C
(0832) 	case FS_FAT12 :
(0833) 		bc = (UINT)clst; bc += bc / 2;
    0053F 84AC      LDD	R10,Y+12
    00540 84BD      LDD	R11,Y+13
    00541 0115      MOVW	R2,R10
    00542 9436      LSR	R3
    00543 9427      ROR	R2
    00544 0CA2      ADD	R10,R2
    00545 1CB3      ADC	R11,R3
(0834) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    00546 E029      LDI	R18,0x9
    00547 E030      LDI	R19,0
    00548 0185      MOVW	R16,R10
    00549 940E 4008 CALL	lsr16
    0054B 0118      MOVW	R2,R16
    0054C 2444      CLR	R4
    0054D 2455      CLR	R5
    0054E 01F6      MOVW	R30,R12
    0054F 8C66      LDD	R6,Z+30
    00550 8C77      LDD	R7,Z+31
    00551 A080      LDD	R8,Z+32
    00552 A091      LDD	R9,Z+33
    00553 0C62      ADD	R6,R2
    00554 1C73      ADC	R7,R3
    00555 1C84      ADC	R8,R4
    00556 1C95      ADC	R9,R5
    00557 8288      ST	Y,R8
    00558 8299      STD	Y+1,R9
    00559 0193      MOVW	R18,R6
    0055A 018F      MOVW	R16,R30
    0055B DDE0      RCALL	ff.c:move_window
    0055C 2300      TST	R16
    0055D F009      BEQ	0x055F
    0055E C0ED      RJMP	0x064C
(0835) 		wc = fs->win[bc % SS(fs)]; bc++;
    0055F 01C6      MOVW	R24,R12
    00560 968E      ADIW	R24,0x2E
    00561 01F5      MOVW	R30,R10
    00562 70F1      ANDI	R31,1
    00563 0FE8      ADD	R30,R24
    00564 1FF9      ADC	R31,R25
    00565 80E0      LD	R14,Z
    00566 24FF      CLR	R15
    00567 01C5      MOVW	R24,R10
    00568 9601      ADIW	R24,1
    00569 015C      MOVW	R10,R24
(0836) 		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    0056A E029      LDI	R18,0x9
    0056B E030      LDI	R19,0
    0056C 018C      MOVW	R16,R24
    0056D 940E 4008 CALL	lsr16
    0056F 0118      MOVW	R2,R16
    00570 2444      CLR	R4
    00571 2455      CLR	R5
    00572 01F6      MOVW	R30,R12
    00573 8C66      LDD	R6,Z+30
    00574 8C77      LDD	R7,Z+31
    00575 A080      LDD	R8,Z+32
    00576 A091      LDD	R9,Z+33
    00577 0C62      ADD	R6,R2
    00578 1C73      ADC	R7,R3
    00579 1C84      ADC	R8,R4
    0057A 1C95      ADC	R9,R5
    0057B 8288      ST	Y,R8
    0057C 8299      STD	Y+1,R9
    0057D 0193      MOVW	R18,R6
    0057E 018F      MOVW	R16,R30
    0057F DDBC      RCALL	ff.c:move_window
    00580 2300      TST	R16
    00581 F009      BEQ	0x0583
    00582 C0C9      RJMP	0x064C
(0837) 		wc |= fs->win[bc % SS(fs)] << 8;
    00583 01C6      MOVW	R24,R12
    00584 968E      ADIW	R24,0x2E
    00585 01F5      MOVW	R30,R10
    00586 70F1      ANDI	R31,1
    00587 0FE8      ADD	R30,R24
    00588 1FF9      ADC	R31,R25
    00589 8020      LD	R2,Z
    0058A 2433      CLR	R3
    0058B 2C32      MOV	R3,R2
    0058C 2422      CLR	R2
    0058D 28E2      OR	R14,R2
    0058E 28F3      OR	R15,R3
(0838) 		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    0058F 842C      LDD	R2,Y+12
    00590 843D      LDD	R3,Y+13
    00591 844E      LDD	R4,Y+14
    00592 845F      LDD	R5,Y+15
    00593 2DE2      MOV	R30,R2
    00594 70E1      ANDI	R30,1
    00595 F051      BEQ	0x05A0
    00596 0157      MOVW	R10,R14
    00597 94B6      LSR	R11
    00598 94A7      ROR	R10
    00599 94B6      LSR	R11
    0059A 94A7      ROR	R10
    0059B 94B6      LSR	R11
    0059C 94A7      ROR	R10
    0059D 94B6      LSR	R11
    0059E 94A7      ROR	R10
    0059F C003      RJMP	0x05A3
    005A0 01C7      MOVW	R24,R14
    005A1 709F      ANDI	R25,0xF
    005A2 015C      MOVW	R10,R24
    005A3 0185      MOVW	R16,R10
    005A4 0196      MOVW	R18,R12
    005A5 2722      CLR	R18
    005A6 2733      CLR	R19
    005A7 C0A8      RJMP	0x0650
(0839) 
(0840) 	case FS_FAT16 :
(0841) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    005A8 E088      LDI	R24,0x8
    005A9 E090      LDI	R25,0
    005AA 850C      LDD	R16,Y+12
    005AB 851D      LDD	R17,Y+13
    005AC 852E      LDD	R18,Y+14
    005AD 853F      LDD	R19,Y+15
    005AE 938A      ST	-Y,R24
    005AF 940E 400F CALL	lsr32
    005B1 01F6      MOVW	R30,R12
    005B2 8C26      LDD	R2,Z+30
    005B3 8C37      LDD	R3,Z+31
    005B4 A040      LDD	R4,Z+32
    005B5 A051      LDD	R5,Z+33
    005B6 0E20      ADD	R2,R16
    005B7 1E31      ADC	R3,R17
    005B8 1E42      ADC	R4,R18
    005B9 1E53      ADC	R5,R19
    005BA 8248      ST	Y,R4
    005BB 8259      STD	Y+1,R5
    005BC 0191      MOVW	R18,R2
    005BD 018F      MOVW	R16,R30
    005BE DD7D      RCALL	ff.c:move_window
    005BF 2EA0      MOV	R10,R16
    005C0 2300      TST	R16
    005C1 F009      BEQ	0x05C3
    005C2 C089      RJMP	0x064C
(0842) 		p = &fs->win[clst * 2 % SS(fs)];
    005C3 EF4F      LDI	R20,0xFF
    005C4 E051      LDI	R21,1
    005C5 E060      LDI	R22,0
    005C6 E070      LDI	R23,0
    005C7 842C      LDD	R2,Y+12
    005C8 843D      LDD	R3,Y+13
    005C9 844E      LDD	R4,Y+14
    005CA 845F      LDD	R5,Y+15
    005CB 0C22      LSL	R2
    005CC 1C33      ROL	R3
    005CD 1C44      ROL	R4
    005CE 1C55      ROL	R5
    005CF 2224      AND	R2,R20
    005D0 2235      AND	R3,R21
    005D1 2246      AND	R4,R22
    005D2 2257      AND	R5,R23
    005D3 0151      MOVW	R10,R2
    005D4 01C6      MOVW	R24,R12
    005D5 968E      ADIW	R24,0x2E
    005D6 0EA8      ADD	R10,R24
    005D7 1EB9      ADC	R11,R25
(0843) 		return LD_WORD(p);
    005D8 01F5      MOVW	R30,R10
    005D9 8020      LD	R2,Z
    005DA 2433      CLR	R3
    005DB 8101      LDD	R16,Z+1
    005DC 2711      CLR	R17
    005DD 2F10      MOV	R17,R16
    005DE 2700      CLR	R16
    005DF 2902      OR	R16,R2
    005E0 2913      OR	R17,R3
    005E1 2722      CLR	R18
    005E2 2733      CLR	R19
    005E3 C06C      RJMP	0x0650
(0844) 
(0845) 	case FS_FAT32 :
(0846) 		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    005E4 E087      LDI	R24,7
    005E5 E090      LDI	R25,0
    005E6 850C      LDD	R16,Y+12
    005E7 851D      LDD	R17,Y+13
    005E8 852E      LDD	R18,Y+14
    005E9 853F      LDD	R19,Y+15
    005EA 938A      ST	-Y,R24
    005EB 940E 400F CALL	lsr32
    005ED 01F6      MOVW	R30,R12
    005EE 8C26      LDD	R2,Z+30
    005EF 8C37      LDD	R3,Z+31
    005F0 A040      LDD	R4,Z+32
    005F1 A051      LDD	R5,Z+33
    005F2 0E20      ADD	R2,R16
    005F3 1E31      ADC	R3,R17
    005F4 1E42      ADC	R4,R18
    005F5 1E53      ADC	R5,R19
    005F6 8248      ST	Y,R4
    005F7 8259      STD	Y+1,R5
    005F8 0191      MOVW	R18,R2
    005F9 018F      MOVW	R16,R30
    005FA DD41      RCALL	ff.c:move_window
    005FB 2EE0      MOV	R14,R16
    005FC 2300      TST	R16
    005FD F009      BEQ	0x05FF
    005FE C04D      RJMP	0x064C
(0847) 		p = &fs->win[clst * 4 % SS(fs)];
    005FF E082      LDI	R24,2
    00600 E090      LDI	R25,0
    00601 850C      LDD	R16,Y+12
    00602 851D      LDD	R17,Y+13
    00603 852E      LDD	R18,Y+14
    00604 853F      LDD	R19,Y+15
    00605 938A      ST	-Y,R24
    00606 940E 3FF6 CALL	lsl32
    00608 0118      MOVW	R2,R16
    00609 0129      MOVW	R4,R18
    0060A EF4F      LDI	R20,0xFF
    0060B E051      LDI	R21,1
    0060C E060      LDI	R22,0
    0060D E070      LDI	R23,0
    0060E 2224      AND	R2,R20
    0060F 2235      AND	R3,R21
    00610 2246      AND	R4,R22
    00611 2257      AND	R5,R23
    00612 0151      MOVW	R10,R2
    00613 01C6      MOVW	R24,R12
    00614 968E      ADIW	R24,0x2E
    00615 0EA8      ADD	R10,R24
    00616 1EB9      ADC	R11,R25
(0848) 		return LD_DWORD(p) & 0x0FFFFFFF;
    00617 E188      LDI	R24,0x18
    00618 E090      LDI	R25,0
    00619 01F5      MOVW	R30,R10
    0061A 8103      LDD	R16,Z+3
    0061B 2711      CLR	R17
    0061C 2722      CLR	R18
    0061D 2733      CLR	R19
    0061E 938A      ST	-Y,R24
    0061F 940E 3FF6 CALL	lsl32
    00621 0118      MOVW	R2,R16
    00622 0129      MOVW	R4,R18
    00623 01F5      MOVW	R30,R10
    00624 8062      LDD	R6,Z+2
    00625 2477      CLR	R7
    00626 2488      CLR	R8
    00627 2499      CLR	R9
    00628 0143      MOVW	R8,R6
    00629 2466      CLR	R6
    0062A 2477      CLR	R7
    0062B 2826      OR	R2,R6
    0062C 2837      OR	R3,R7
    0062D 2848      OR	R4,R8
    0062E 2859      OR	R5,R9
    0062F 8061      LDD	R6,Z+1
    00630 2477      CLR	R7
    00631 2C76      MOV	R7,R6
    00632 2466      CLR	R6
    00633 2488      CLR	R8
    00634 2499      CLR	R9
    00635 2826      OR	R2,R6
    00636 2837      OR	R3,R7
    00637 2848      OR	R4,R8
    00638 2859      OR	R5,R9
    00639 8060      LD	R6,Z
    0063A 2477      CLR	R7
    0063B 2488      CLR	R8
    0063C 2499      CLR	R9
    0063D 2826      OR	R2,R6
    0063E 2837      OR	R3,R7
    0063F 2848      OR	R4,R8
    00640 2859      OR	R5,R9
    00641 EF4F      LDI	R20,0xFF
    00642 EF5F      LDI	R21,0xFF
    00643 EF6F      LDI	R22,0xFF
    00644 E07F      LDI	R23,0xF
    00645 2224      AND	R2,R20
    00646 2235      AND	R3,R21
    00647 2246      AND	R4,R22
    00648 2257      AND	R5,R23
    00649 0181      MOVW	R16,R2
    0064A 0192      MOVW	R18,R4
    0064B C004      RJMP	0x0650
(0849) 	}
(0850) 
(0851) 	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    0064C EF0F      LDI	R16,0xFF
    0064D EF1F      LDI	R17,0xFF
    0064E EF2F      LDI	R18,0xFF
    0064F EF3F      LDI	R19,0xFF
    00650 9622      ADIW	R28,2
    00651 940E 3F69 CALL	pop_xgsetF0FC
    00653 9622      ADIW	R28,2
    00654 9508      RET
_put_fat:
  bc                   --> R12
  p                    --> R14
  res                  --> Y,+2
  val                  --> Y,+19
  clst                 --> Y,+15
  fs                   --> Y,+13
    00655 940E 3E2F CALL	push_arg4
    00657 940E 3F74 CALL	push_xgsetF0FC
    00659 9723      SBIW	R28,3
(0852) }
(0853) 
(0854) 
(0855) 
(0856) 
(0857) /*-----------------------------------------------------------------------*/
(0858) /* FAT access - Change value of a FAT entry                              */
(0859) /*-----------------------------------------------------------------------*/
(0860) #if !_FS_READONLY
(0861) 
(0862) FRESULT put_fat (
(0863) 	FATFS *fs,	/* File system object */
(0864) 	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
(0865) 	DWORD val	/* New value to mark the cluster */
(0866) )
(0867) {
(0868) 	UINT bc;
(0869) 	BYTE *p;
(0870) 	FRESULT res;
(0871) 
(0872) 
(0873) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    0065A E042      LDI	R20,2
    0065B E050      LDI	R21,0
    0065C E060      LDI	R22,0
    0065D E070      LDI	R23,0
    0065E 842F      LDD	R2,Y+15
    0065F 8838      LDD	R3,Y+16
    00660 8849      LDD	R4,Y+17
    00661 885A      LDD	R5,Y+18
    00662 1624      CP	R2,R20
    00663 0635      CPC	R3,R21
    00664 0646      CPC	R4,R22
    00665 0657      CPC	R5,R23
    00666 F080      BCS	0x0677
    00667 85ED      LDD	R30,Y+13
    00668 85FE      LDD	R31,Y+14
    00669 9676      ADIW	R30,0x16
    0066A 8020      LD	R2,Z
    0066B 8031      LDD	R3,Z+1
    0066C 8042      LDD	R4,Z+2
    0066D 8053      LDD	R5,Z+3
    0066E 846F      LDD	R6,Y+15
    0066F 8878      LDD	R7,Y+16
    00670 8889      LDD	R8,Y+17
    00671 889A      LDD	R9,Y+18
    00672 1462      CP	R6,R2
    00673 0473      CPC	R7,R3
    00674 0484      CPC	R8,R4
    00675 0495      CPC	R9,R5
    00676 F018      BCS	0x067A
(0874) 		res = FR_INT_ERR;
    00677 E082      LDI	R24,2
    00678 838A      STD	Y+2,R24
(0875) 
(0876) 	} else {
    00679 C194      RJMP	0x080E
(0877) 		switch (fs->fs_type) {
    0067A 85ED      LDD	R30,Y+13
    0067B 85FE      LDD	R31,Y+14
    0067C 80A0      LD	R10,Z
    0067D 24BB      CLR	R11
    0067E 01C5      MOVW	R24,R10
    0067F 3081      CPI	R24,1
    00680 E0E0      LDI	R30,0
    00681 079E      CPC	R25,R30
    00682 F059      BEQ	0x068E
    00683 3082      CPI	R24,2
    00684 E0E0      LDI	R30,0
    00685 079E      CPC	R25,R30
    00686 F409      BNE	0x0688
    00687 C0B0      RJMP	0x0738
    00688 3083      CPI	R24,3
    00689 E0E0      LDI	R30,0
    0068A 079E      CPC	R25,R30
    0068B F409      BNE	0x068D
    0068C C0E7      RJMP	0x0774
    0068D C17A      RJMP	0x0808
(0878) 		case FS_FAT12 :
(0879) 			bc = clst; bc += bc / 2;
    0068E 84CF      LDD	R12,Y+15
    0068F 88D8      LDD	R13,Y+16
    00690 0116      MOVW	R2,R12
    00691 9436      LSR	R3
    00692 9427      ROR	R2
    00693 0CC2      ADD	R12,R2
    00694 1CD3      ADC	R13,R3
(0880) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    00695 E029      LDI	R18,0x9
    00696 E030      LDI	R19,0
    00697 0186      MOVW	R16,R12
    00698 940E 4008 CALL	lsr16
    0069A 0118      MOVW	R2,R16
    0069B 2444      CLR	R4
    0069C 2455      CLR	R5
    0069D 85ED      LDD	R30,Y+13
    0069E 85FE      LDD	R31,Y+14
    0069F 8C66      LDD	R6,Z+30
    006A0 8C77      LDD	R7,Z+31
    006A1 A080      LDD	R8,Z+32
    006A2 A091      LDD	R9,Z+33
    006A3 0C62      ADD	R6,R2
    006A4 1C73      ADC	R7,R3
    006A5 1C84      ADC	R8,R4
    006A6 1C95      ADC	R9,R5
    006A7 8288      ST	Y,R8
    006A8 8299      STD	Y+1,R9
    006A9 0193      MOVW	R18,R6
    006AA 018F      MOVW	R16,R30
    006AB DC90      RCALL	ff.c:move_window
    006AC 830A      STD	Y+2,R16
(0881) 			if (res != FR_OK) break;
    006AD 2E00      MOV	R0,R16
    006AE 2300      TST	R16
    006AF F009      BEQ	0x06B1
    006B0 C159      RJMP	0x080A
(0882) 			p = &fs->win[bc % SS(fs)];
    006B1 858D      LDD	R24,Y+13
    006B2 859E      LDD	R25,Y+14
    006B3 968E      ADIW	R24,0x2E
    006B4 01F6      MOVW	R30,R12
    006B5 70F1      ANDI	R31,1
    006B6 017F      MOVW	R14,R30
    006B7 0EE8      ADD	R14,R24
    006B8 1EF9      ADC	R15,R25
(0883) 			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
    006B9 842F      LDD	R2,Y+15
    006BA 8838      LDD	R3,Y+16
    006BB 8849      LDD	R4,Y+17
    006BC 885A      LDD	R5,Y+18
    006BD 93EF      PUSH	R30
    006BE 2DE2      MOV	R30,R2
    006BF 70E1      ANDI	R30,1
    006C0 91EF      POP	R30
    006C1 F0B1      BEQ	0x06D8
    006C2 882B      LDD	R2,Y+19
    006C3 883C      LDD	R3,Y+20
    006C4 884D      LDD	R4,Y+21
    006C5 885E      LDD	R5,Y+22
    006C6 2433      CLR	R3
    006C7 0C22      LSL	R2
    006C8 1C33      ROL	R3
    006C9 0C22      LSL	R2
    006CA 1C33      ROL	R3
    006CB 0C22      LSL	R2
    006CC 1C33      ROL	R3
    006CD 0C22      LSL	R2
    006CE 1C33      ROL	R3
    006CF 01F7      MOVW	R30,R14
    006D0 8180      LD	R24,Z
    006D1 2799      CLR	R25
    006D2 708F      ANDI	R24,0xF
    006D3 7090      ANDI	R25,0
    006D4 015C      MOVW	R10,R24
    006D5 28A2      OR	R10,R2
    006D6 28B3      OR	R11,R3
    006D7 C006      RJMP	0x06DE
    006D8 882B      LDD	R2,Y+19
    006D9 883C      LDD	R3,Y+20
    006DA 884D      LDD	R4,Y+21
    006DB 885E      LDD	R5,Y+22
    006DC 2CA2      MOV	R10,R2
    006DD 24BB      CLR	R11
    006DE 01F7      MOVW	R30,R14
    006DF 82A0      ST	Z,R10
(0884) 			bc++;
    006E0 01C6      MOVW	R24,R12
    006E1 9601      ADIW	R24,1
    006E2 016C      MOVW	R12,R24
(0885) 			fs->wflag = 1;
    006E3 E081      LDI	R24,1
    006E4 85ED      LDD	R30,Y+13
    006E5 85FE      LDD	R31,Y+14
    006E6 8384      STD	Z+4,R24
(0886) 			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
    006E7 E029      LDI	R18,0x9
    006E8 E030      LDI	R19,0
    006E9 0186      MOVW	R16,R12
    006EA 940E 4008 CALL	lsr16
    006EC 0118      MOVW	R2,R16
    006ED 2444      CLR	R4
    006EE 2455      CLR	R5
    006EF 85ED      LDD	R30,Y+13
    006F0 85FE      LDD	R31,Y+14
    006F1 8C66      LDD	R6,Z+30
    006F2 8C77      LDD	R7,Z+31
    006F3 A080      LDD	R8,Z+32
    006F4 A091      LDD	R9,Z+33
    006F5 0C62      ADD	R6,R2
    006F6 1C73      ADC	R7,R3
    006F7 1C84      ADC	R8,R4
    006F8 1C95      ADC	R9,R5
    006F9 8288      ST	Y,R8
    006FA 8299      STD	Y+1,R9
    006FB 0193      MOVW	R18,R6
    006FC 018F      MOVW	R16,R30
    006FD DC3E      RCALL	ff.c:move_window
    006FE 830A      STD	Y+2,R16
(0887) 			if (res != FR_OK) break;
    006FF 2E00      MOV	R0,R16
    00700 2300      TST	R16
    00701 F009      BEQ	0x0703
    00702 C107      RJMP	0x080A
(0888) 			p = &fs->win[bc % SS(fs)];
    00703 858D      LDD	R24,Y+13
    00704 859E      LDD	R25,Y+14
    00705 968E      ADIW	R24,0x2E
    00706 01F6      MOVW	R30,R12
    00707 70F1      ANDI	R31,1
    00708 017F      MOVW	R14,R30
    00709 0EE8      ADD	R14,R24
    0070A 1EF9      ADC	R15,R25
(0889) 			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
    0070B 842F      LDD	R2,Y+15
    0070C 8838      LDD	R3,Y+16
    0070D 8849      LDD	R4,Y+17
    0070E 885A      LDD	R5,Y+18
    0070F 93EF      PUSH	R30
    00710 2DE2      MOV	R30,R2
    00711 70E1      ANDI	R30,1
    00712 91EF      POP	R30
    00713 F061      BEQ	0x0720
    00714 E084      LDI	R24,4
    00715 E090      LDI	R25,0
    00716 890B      LDD	R16,Y+19
    00717 891C      LDD	R17,Y+20
    00718 892D      LDD	R18,Y+21
    00719 893E      LDD	R19,Y+22
    0071A 938A      ST	-Y,R24
    0071B 940E 400F CALL	lsr32
    0071D 2EC0      MOV	R12,R16
    0071E 24DD      CLR	R13
    0071F C015      RJMP	0x0735
    00720 E088      LDI	R24,0x8
    00721 E090      LDI	R25,0
    00722 890B      LDD	R16,Y+19
    00723 891C      LDD	R17,Y+20
    00724 892D      LDD	R18,Y+21
    00725 893E      LDD	R19,Y+22
    00726 938A      ST	-Y,R24
    00727 940E 400F CALL	lsr32
    00729 2F80      MOV	R24,R16
    0072A 2799      CLR	R25
    0072B 708F      ANDI	R24,0xF
    0072C 7090      ANDI	R25,0
    0072D 01F7      MOVW	R30,R14
    0072E 81E0      LD	R30,Z
    0072F 27FF      CLR	R31
    00730 7FE0      ANDI	R30,0xF0
    00731 70F0      ANDI	R31,0
    00732 016F      MOVW	R12,R30
    00733 2AC8      OR	R12,R24
    00734 2AD9      OR	R13,R25
    00735 01F7      MOVW	R30,R14
    00736 82C0      ST	Z,R12
(0890) 			break;
    00737 C0D2      RJMP	0x080A
(0891) 
(0892) 		case FS_FAT16 :
(0893) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
    00738 E088      LDI	R24,0x8
    00739 E090      LDI	R25,0
    0073A 850F      LDD	R16,Y+15
    0073B 8918      LDD	R17,Y+16
    0073C 8929      LDD	R18,Y+17
    0073D 893A      LDD	R19,Y+18
    0073E 938A      ST	-Y,R24
    0073F 940E 400F CALL	lsr32
    00741 85ED      LDD	R30,Y+13
    00742 85FE      LDD	R31,Y+14
    00743 8C26      LDD	R2,Z+30
    00744 8C37      LDD	R3,Z+31
    00745 A040      LDD	R4,Z+32
    00746 A051      LDD	R5,Z+33
    00747 0E20      ADD	R2,R16
    00748 1E31      ADC	R3,R17
    00749 1E42      ADC	R4,R18
    0074A 1E53      ADC	R5,R19
    0074B 8248      ST	Y,R4
    0074C 8259      STD	Y+1,R5
    0074D 0191      MOVW	R18,R2
    0074E 018F      MOVW	R16,R30
    0074F DBEC      RCALL	ff.c:move_window
    00750 2EC0      MOV	R12,R16
    00751 82CA      STD	Y+2,R12
(0894) 			if (res != FR_OK) break;
    00752 2C0C      MOV	R0,R12
    00753 2300      TST	R16
    00754 F009      BEQ	0x0756
    00755 C0B4      RJMP	0x080A
(0895) 			p = &fs->win[clst * 2 % SS(fs)];
    00756 EF4F      LDI	R20,0xFF
    00757 E051      LDI	R21,1
    00758 E060      LDI	R22,0
    00759 E070      LDI	R23,0
    0075A 842F      LDD	R2,Y+15
    0075B 8838      LDD	R3,Y+16
    0075C 8849      LDD	R4,Y+17
    0075D 885A      LDD	R5,Y+18
    0075E 0C22      LSL	R2
    0075F 1C33      ROL	R3
    00760 1C44      ROL	R4
    00761 1C55      ROL	R5
    00762 2224      AND	R2,R20
    00763 2235      AND	R3,R21
    00764 2246      AND	R4,R22
    00765 2257      AND	R5,R23
    00766 0171      MOVW	R14,R2
    00767 858D      LDD	R24,Y+13
    00768 859E      LDD	R25,Y+14
    00769 968E      ADIW	R24,0x2E
    0076A 0EE8      ADD	R14,R24
    0076B 1EF9      ADC	R15,R25
(0896) 			ST_WORD(p, (WORD)val);
    0076C 882B      LDD	R2,Y+19
    0076D 883C      LDD	R3,Y+20
    0076E 01F7      MOVW	R30,R14
    0076F 8220      ST	Z,R2
    00770 2C23      MOV	R2,R3
    00771 2433      CLR	R3
    00772 8221      STD	Z+1,R2
(0897) 			break;
    00773 C096      RJMP	0x080A
(0898) 
(0899) 		case FS_FAT32 :
(0900) 			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
    00774 E087      LDI	R24,7
    00775 E090      LDI	R25,0
    00776 850F      LDD	R16,Y+15
    00777 8918      LDD	R17,Y+16
    00778 8929      LDD	R18,Y+17
    00779 893A      LDD	R19,Y+18
    0077A 938A      ST	-Y,R24
    0077B 940E 400F CALL	lsr32
    0077D 85ED      LDD	R30,Y+13
    0077E 85FE      LDD	R31,Y+14
    0077F 8C26      LDD	R2,Z+30
    00780 8C37      LDD	R3,Z+31
    00781 A040      LDD	R4,Z+32
    00782 A051      LDD	R5,Z+33
    00783 0E20      ADD	R2,R16
    00784 1E31      ADC	R3,R17
    00785 1E42      ADC	R4,R18
    00786 1E53      ADC	R5,R19
    00787 8248      ST	Y,R4
    00788 8259      STD	Y+1,R5
    00789 0191      MOVW	R18,R2
    0078A 018F      MOVW	R16,R30
    0078B DBB0      RCALL	ff.c:move_window
    0078C 2EC0      MOV	R12,R16
    0078D 82CA      STD	Y+2,R12
(0901) 			if (res != FR_OK) break;
    0078E 2C0C      MOV	R0,R12
    0078F 2300      TST	R16
    00790 F009      BEQ	0x0792
    00791 C078      RJMP	0x080A
(0902) 			p = &fs->win[clst * 4 % SS(fs)];
    00792 E082      LDI	R24,2
    00793 E090      LDI	R25,0
    00794 850F      LDD	R16,Y+15
    00795 8918      LDD	R17,Y+16
    00796 8929      LDD	R18,Y+17
    00797 893A      LDD	R19,Y+18
    00798 938A      ST	-Y,R24
    00799 940E 3FF6 CALL	lsl32
    0079B 0118      MOVW	R2,R16
    0079C 0129      MOVW	R4,R18
    0079D EF4F      LDI	R20,0xFF
    0079E E051      LDI	R21,1
    0079F E060      LDI	R22,0
    007A0 E070      LDI	R23,0
    007A1 2224      AND	R2,R20
    007A2 2235      AND	R3,R21
    007A3 2246      AND	R4,R22
    007A4 2257      AND	R5,R23
    007A5 0171      MOVW	R14,R2
    007A6 858D      LDD	R24,Y+13
    007A7 859E      LDD	R25,Y+14
    007A8 968E      ADIW	R24,0x2E
    007A9 0EE8      ADD	R14,R24
    007AA 1EF9      ADC	R15,R25
(0903) 			val |= LD_DWORD(p) & 0xF0000000;
    007AB E188      LDI	R24,0x18
    007AC E090      LDI	R25,0
    007AD 01F7      MOVW	R30,R14
    007AE 8103      LDD	R16,Z+3
    007AF 2711      CLR	R17
    007B0 2722      CLR	R18
    007B1 2733      CLR	R19
    007B2 938A      ST	-Y,R24
    007B3 940E 3FF6 CALL	lsl32
    007B5 0118      MOVW	R2,R16
    007B6 0129      MOVW	R4,R18
    007B7 01F7      MOVW	R30,R14
    007B8 8062      LDD	R6,Z+2
    007B9 2477      CLR	R7
    007BA 2488      CLR	R8
    007BB 2499      CLR	R9
    007BC 0143      MOVW	R8,R6
    007BD 2466      CLR	R6
    007BE 2477      CLR	R7
    007BF 2826      OR	R2,R6
    007C0 2837      OR	R3,R7
    007C1 2848      OR	R4,R8
    007C2 2859      OR	R5,R9
    007C3 8061      LDD	R6,Z+1
    007C4 2477      CLR	R7
    007C5 2C76      MOV	R7,R6
    007C6 2466      CLR	R6
    007C7 2488      CLR	R8
    007C8 2499      CLR	R9
    007C9 2826      OR	R2,R6
    007CA 2837      OR	R3,R7
    007CB 2848      OR	R4,R8
    007CC 2859      OR	R5,R9
    007CD 8060      LD	R6,Z
    007CE 2477      CLR	R7
    007CF 2488      CLR	R8
    007D0 2499      CLR	R9
    007D1 2826      OR	R2,R6
    007D2 2837      OR	R3,R7
    007D3 2848      OR	R4,R8
    007D4 2859      OR	R5,R9
    007D5 E040      LDI	R20,0
    007D6 E050      LDI	R21,0
    007D7 E060      LDI	R22,0
    007D8 EF70      LDI	R23,0xF0
    007D9 2224      AND	R2,R20
    007DA 2235      AND	R3,R21
    007DB 2246      AND	R4,R22
    007DC 2257      AND	R5,R23
    007DD 886B      LDD	R6,Y+19
    007DE 887C      LDD	R7,Y+20
    007DF 888D      LDD	R8,Y+21
    007E0 889E      LDD	R9,Y+22
    007E1 2862      OR	R6,R2
    007E2 2873      OR	R7,R3
    007E3 2884      OR	R8,R4
    007E4 2895      OR	R9,R5
    007E5 8A6B      STD	Y+19,R6
    007E6 8A7C      STD	Y+20,R7
    007E7 8A8D      STD	Y+21,R8
    007E8 8A9E      STD	Y+22,R9
(0904) 			ST_DWORD(p, val);
    007E9 882B      LDD	R2,Y+19
    007EA 883C      LDD	R3,Y+20
    007EB 884D      LDD	R4,Y+21
    007EC 885E      LDD	R5,Y+22
    007ED 8220      ST	Z,R2
    007EE 2C23      MOV	R2,R3
    007EF 2433      CLR	R3
    007F0 9631      ADIW	R30,1
    007F1 8220      ST	Z,R2
    007F2 882B      LDD	R2,Y+19
    007F3 883C      LDD	R3,Y+20
    007F4 884D      LDD	R4,Y+21
    007F5 885E      LDD	R5,Y+22
    007F6 0112      MOVW	R2,R4
    007F7 2444      CLR	R4
    007F8 2455      CLR	R5
    007F9 01F7      MOVW	R30,R14
    007FA 9632      ADIW	R30,2
    007FB 8220      ST	Z,R2
    007FC E188      LDI	R24,0x18
    007FD E090      LDI	R25,0
    007FE 890B      LDD	R16,Y+19
    007FF 891C      LDD	R17,Y+20
    00800 892D      LDD	R18,Y+21
    00801 893E      LDD	R19,Y+22
    00802 938A      ST	-Y,R24
    00803 940E 400F CALL	lsr32
    00805 01F7      MOVW	R30,R14
    00806 8303      STD	Z+3,R16
(0905) 			break;
    00807 C002      RJMP	0x080A
(0906) 
(0907) 		default :
(0908) 			res = FR_INT_ERR;
    00808 E082      LDI	R24,2
    00809 838A      STD	Y+2,R24
(0909) 		}
(0910) 		fs->wflag = 1;
    0080A E081      LDI	R24,1
    0080B 85ED      LDD	R30,Y+13
    0080C 85FE      LDD	R31,Y+14
    0080D 8384      STD	Z+4,R24
(0911) 	}
(0912) 
(0913) 	return res;
    0080E 810A      LDD	R16,Y+2
    0080F 9623      ADIW	R28,3
    00810 940E 3F69 CALL	pop_xgsetF0FC
    00812 9624      ADIW	R28,4
    00813 9508      RET
ff.c:remove_chain:
  res                  --> R10
  nxt                  --> Y,+6
  clst                 --> Y,+18
  fs                   --> R12
    00814 933A      ST	-Y,R19
    00815 932A      ST	-Y,R18
    00816 940E 3FAF CALL	push_xgsetF03C
    00818 0168      MOVW	R12,R16
    00819 972A      SBIW	R28,0xA
(0914) }
(0915) #endif /* !_FS_READONLY */
(0916) 
(0917) 
(0918) 
(0919) 
(0920) /*-----------------------------------------------------------------------*/
(0921) /* FAT handling - Remove a cluster chain                                 */
(0922) /*-----------------------------------------------------------------------*/
(0923) #if !_FS_READONLY
(0924) static
(0925) FRESULT remove_chain (
(0926) 	FATFS *fs,			/* File system object */
(0927) 	DWORD clst			/* Cluster# to remove a chain from */
(0928) )
(0929) {
(0930) 	FRESULT res;
(0931) 	DWORD nxt;
(0932) #if _USE_ERASE
(0933) 	DWORD scl = clst, ecl = clst, resion[2];
(0934) #endif
(0935) 
(0936) 	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
    0081A E042      LDI	R20,2
    0081B E050      LDI	R21,0
    0081C E060      LDI	R22,0
    0081D E070      LDI	R23,0
    0081E 882A      LDD	R2,Y+18
    0081F 883B      LDD	R3,Y+19
    00820 884C      LDD	R4,Y+20
    00821 885D      LDD	R5,Y+21
    00822 1624      CP	R2,R20
    00823 0635      CPC	R3,R21
    00824 0646      CPC	R4,R22
    00825 0657      CPC	R5,R23
    00826 F078      BCS	0x0836
    00827 01F6      MOVW	R30,R12
    00828 9676      ADIW	R30,0x16
    00829 8020      LD	R2,Z
    0082A 8031      LDD	R3,Z+1
    0082B 8042      LDD	R4,Z+2
    0082C 8053      LDD	R5,Z+3
    0082D 886A      LDD	R6,Y+18
    0082E 887B      LDD	R7,Y+19
    0082F 888C      LDD	R8,Y+20
    00830 889D      LDD	R9,Y+21
    00831 1462      CP	R6,R2
    00832 0473      CPC	R7,R3
    00833 0484      CPC	R8,R4
    00834 0495      CPC	R9,R5
    00835 F018      BCS	0x0839
(0937) 		res = FR_INT_ERR;
    00836 E082      LDI	R24,2
    00837 2EA8      MOV	R10,R24
(0938) 
(0939) 	} else {
    00838 C088      RJMP	0x08C1
(0940) 		res = FR_OK;
    00839 24AA      CLR	R10
    0083A C076      RJMP	0x08B1
(0941) 		while (clst < fs->n_fatent) {			/* Not a last link? */
(0942) 			nxt = get_fat(fs, clst);			/* Get cluster status */
    0083B 882A      LDD	R2,Y+18
    0083C 883B      LDD	R3,Y+19
    0083D 884C      LDD	R4,Y+20
    0083E 885D      LDD	R5,Y+21
    0083F 8248      ST	Y,R4
    00840 8259      STD	Y+1,R5
    00841 0191      MOVW	R18,R2
    00842 0186      MOVW	R16,R12
    00843 DCC1      RCALL	_get_fat
    00844 830E      STD	Y+6,R16
    00845 831F      STD	Y+7,R17
    00846 8728      STD	Y+8,R18
    00847 8739      STD	Y+9,R19
(0943) 			if (nxt == 0) break;				/* Empty cluster? */
    00848 802E      LDD	R2,Y+6
    00849 803F      LDD	R3,Y+7
    0084A 8448      LDD	R4,Y+8
    0084B 8459      LDD	R5,Y+9
    0084C 9488      BCLR	0
    0084D 2022      TST	R2
    0084E 0432      CPC	R3,R2
    0084F 0442      CPC	R4,R2
    00850 0452      CPC	R5,R2
    00851 F409      BNE	0x0853
    00852 C06E      RJMP	0x08C1
(0944) 			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    00853 E041      LDI	R20,1
    00854 E050      LDI	R21,0
    00855 E060      LDI	R22,0
    00856 E070      LDI	R23,0
    00857 802E      LDD	R2,Y+6
    00858 803F      LDD	R3,Y+7
    00859 8448      LDD	R4,Y+8
    0085A 8459      LDD	R5,Y+9
    0085B 1624      CP	R2,R20
    0085C 0635      CPC	R3,R21
    0085D 0646      CPC	R4,R22
    0085E 0657      CPC	R5,R23
    0085F F419      BNE	0x0863
    00860 E082      LDI	R24,2
    00861 2EA8      MOV	R10,R24
    00862 C05E      RJMP	0x08C1
(0945) 			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    00863 EF4F      LDI	R20,0xFF
    00864 EF5F      LDI	R21,0xFF
    00865 EF6F      LDI	R22,0xFF
    00866 EF7F      LDI	R23,0xFF
    00867 802E      LDD	R2,Y+6
    00868 803F      LDD	R3,Y+7
    00869 8448      LDD	R4,Y+8
    0086A 8459      LDD	R5,Y+9
    0086B 1624      CP	R2,R20
    0086C 0635      CPC	R3,R21
    0086D 0646      CPC	R4,R22
    0086E 0657      CPC	R5,R23
    0086F F419      BNE	0x0873
    00870 24AA      CLR	R10
    00871 94A3      INC	R10
    00872 C04E      RJMP	0x08C1
(0946) 			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    00873 E080      LDI	R24,0
    00874 838A      STD	Y+2,R24
    00875 838B      STD	Y+3,R24
    00876 838C      STD	Y+4,R24
    00877 838D      STD	Y+5,R24
    00878 882A      LDD	R2,Y+18
    00879 883B      LDD	R3,Y+19
    0087A 884C      LDD	R4,Y+20
    0087B 885D      LDD	R5,Y+21
    0087C 8248      ST	Y,R4
    0087D 8259      STD	Y+1,R5
    0087E 0191      MOVW	R18,R2
    0087F 0186      MOVW	R16,R12
    00880 DDD4      RCALL	_put_fat
    00881 2EA0      MOV	R10,R16
(0947) 			if (res != FR_OK) break;
    00882 2300      TST	R16
    00883 F009      BEQ	0x0885
    00884 C03C      RJMP	0x08C1
(0948) 			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
    00885 EF4F      LDI	R20,0xFF
    00886 EF5F      LDI	R21,0xFF
    00887 EF6F      LDI	R22,0xFF
    00888 EF7F      LDI	R23,0xFF
    00889 01F6      MOVW	R30,R12
    0088A 8426      LDD	R2,Z+14
    0088B 8437      LDD	R3,Z+15
    0088C 8840      LDD	R4,Z+16
    0088D 8851      LDD	R5,Z+17
    0088E 1624      CP	R2,R20
    0088F 0635      CPC	R3,R21
    00890 0646      CPC	R4,R22
    00891 0657      CPC	R5,R23
    00892 F0B1      BEQ	0x08A9
(0949) 				fs->free_clust++;
    00893 01CF      MOVW	R24,R30
    00894 960E      ADIW	R24,0xE
    00895 E041      LDI	R20,1
    00896 E050      LDI	R21,0
    00897 E060      LDI	R22,0
    00898 E070      LDI	R23,0
    00899 01FC      MOVW	R30,R24
    0089A 8020      LD	R2,Z
    0089B 8031      LDD	R3,Z+1
    0089C 8042      LDD	R4,Z+2
    0089D 8053      LDD	R5,Z+3
    0089E 0E24      ADD	R2,R20
    0089F 1E35      ADC	R3,R21
    008A0 1E46      ADC	R4,R22
    008A1 1E57      ADC	R5,R23
    008A2 8220      ST	Z,R2
    008A3 8231      STD	Z+1,R3
    008A4 8242      STD	Z+2,R4
    008A5 8253      STD	Z+3,R5
(0950) 				fs->fsi_flag = 1;
    008A6 E081      LDI	R24,1
    008A7 01F6      MOVW	R30,R12
    008A8 8385      STD	Z+5,R24
(0951) 			}
(0952) #if _USE_ERASE
(0953) 			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
(0954) 				ecl = nxt;
(0955) 			} else {				/* End of contiguous clusters */ 
(0956) 				resion[0] = clust2sect(fs, scl);					/* Start sector */
(0957) 				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
(0958) 				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
(0959) 				scl = ecl = nxt;
(0960) 			}
(0961) #endif
(0962) 			clst = nxt;	/* Next cluster */
    008A9 802E      LDD	R2,Y+6
    008AA 803F      LDD	R3,Y+7
    008AB 8448      LDD	R4,Y+8
    008AC 8459      LDD	R5,Y+9
    008AD 8A2A      STD	Y+18,R2
    008AE 8A3B      STD	Y+19,R3
    008AF 8A4C      STD	Y+20,R4
    008B0 8A5D      STD	Y+21,R5
    008B1 01F6      MOVW	R30,R12
    008B2 9676      ADIW	R30,0x16
    008B3 8020      LD	R2,Z
    008B4 8031      LDD	R3,Z+1
    008B5 8042      LDD	R4,Z+2
    008B6 8053      LDD	R5,Z+3
    008B7 886A      LDD	R6,Y+18
    008B8 887B      LDD	R7,Y+19
    008B9 888C      LDD	R8,Y+20
    008BA 889D      LDD	R9,Y+21
    008BB 1462      CP	R6,R2
    008BC 0473      CPC	R7,R3
    008BD 0484      CPC	R8,R4
    008BE 0495      CPC	R9,R5
    008BF F408      BCC	0x08C1
    008C0 CF7A      RJMP	0x083B
(0963) 		}
(0964) 	}
(0965) 
(0966) 	return res;
    008C1 2D0A      MOV	R16,R10
    008C2 962A      ADIW	R28,0xA
    008C3 940E 3FB8 CALL	pop_xgsetF03C
    008C5 9622      ADIW	R28,2
    008C6 9508      RET
ff.c:create_chain:
  res                  --> R10
  scl                  --> Y,+14
  cs                   --> Y,+10
  ncl                  --> Y,+6
  clst                 --> Y,+32
  fs                   --> R12
    008C7 933A      ST	-Y,R19
    008C8 932A      ST	-Y,R18
    008C9 940E 3F74 CALL	push_xgsetF0FC
    008CB 0168      MOVW	R12,R16
    008CC 9766      SBIW	R28,0x16
(0967) }
(0968) #endif
(0969) 
(0970) 
(0971) 
(0972) 
(0973) /*-----------------------------------------------------------------------*/
(0974) /* FAT handling - Stretch or Create a cluster chain                      */
(0975) /*-----------------------------------------------------------------------*/
(0976) #if !_FS_READONLY
(0977) static
(0978) DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
(0979) 	FATFS *fs,			/* File system object */
(0980) 	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
(0981) )
(0982) {
(0983) 	DWORD cs, ncl, scl;
(0984) 	FRESULT res;
(0985) 
(0986) 
(0987) 	if (clst == 0) {		/* Create a new chain */
    008CD A028      LDD	R2,Y+32
    008CE A039      LDD	R3,Y+33
    008CF A04A      LDD	R4,Y+34
    008D0 A05B      LDD	R5,Y+35
    008D1 9488      BCLR	0
    008D2 2022      TST	R2
    008D3 0432      CPC	R3,R2
    008D4 0442      CPC	R4,R2
    008D5 0452      CPC	R5,R2
    008D6 F559      BNE	0x0902
(0988) 		scl = fs->last_clust;			/* Get suggested start point */
    008D7 01F6      MOVW	R30,R12
    008D8 963A      ADIW	R30,0xA
    008D9 8020      LD	R2,Z
    008DA 8031      LDD	R3,Z+1
    008DB 8042      LDD	R4,Z+2
    008DC 8053      LDD	R5,Z+3
    008DD 862E      STD	Y+14,R2
    008DE 863F      STD	Y+15,R3
    008DF 8A48      STD	Y+16,R4
    008E0 8A59      STD	Y+17,R5
(0989) 		if (!scl || scl >= fs->n_fatent) scl = 1;
    008E1 842E      LDD	R2,Y+14
    008E2 843F      LDD	R3,Y+15
    008E3 8848      LDD	R4,Y+16
    008E4 8859      LDD	R5,Y+17
    008E5 9488      BCLR	0
    008E6 2022      TST	R2
    008E7 0432      CPC	R3,R2
    008E8 0442      CPC	R4,R2
    008E9 0452      CPC	R5,R2
    008EA F081      BEQ	0x08FB
    008EB 01F6      MOVW	R30,R12
    008EC 9676      ADIW	R30,0x16
    008ED 8020      LD	R2,Z
    008EE 8031      LDD	R3,Z+1
    008EF 8042      LDD	R4,Z+2
    008F0 8053      LDD	R5,Z+3
    008F1 846E      LDD	R6,Y+14
    008F2 847F      LDD	R7,Y+15
    008F3 8888      LDD	R8,Y+16
    008F4 8899      LDD	R9,Y+17
    008F5 1462      CP	R6,R2
    008F6 0473      CPC	R7,R3
    008F7 0484      CPC	R8,R4
    008F8 0495      CPC	R9,R5
    008F9 F408      BCC	0x08FB
    008FA C040      RJMP	0x093B
    008FB E081      LDI	R24,1
    008FC 878E      STD	Y+14,R24
    008FD E080      LDI	R24,0
    008FE 878F      STD	Y+15,R24
    008FF 8B88      STD	Y+16,R24
    00900 8B89      STD	Y+17,R24
(0990) 	}
    00901 C039      RJMP	0x093B
(0991) 	else {					/* Stretch the current chain */
(0992) 		cs = get_fat(fs, clst);			/* Check the cluster status */
    00902 A028      LDD	R2,Y+32
    00903 A039      LDD	R3,Y+33
    00904 A04A      LDD	R4,Y+34
    00905 A05B      LDD	R5,Y+35
    00906 8248      ST	Y,R4
    00907 8259      STD	Y+1,R5
    00908 0191      MOVW	R18,R2
    00909 0186      MOVW	R16,R12
    0090A DBFA      RCALL	_get_fat
    0090B 870A      STD	Y+10,R16
    0090C 871B      STD	Y+11,R17
    0090D 872C      STD	Y+12,R18
    0090E 873D      STD	Y+13,R19
(0993) 		if (cs < 2) return 1;			/* It is an invalid cluster */
    0090F E042      LDI	R20,2
    00910 E050      LDI	R21,0
    00911 E060      LDI	R22,0
    00912 E070      LDI	R23,0
    00913 842A      LDD	R2,Y+10
    00914 843B      LDD	R3,Y+11
    00915 844C      LDD	R4,Y+12
    00916 845D      LDD	R5,Y+13
    00917 1624      CP	R2,R20
    00918 0635      CPC	R3,R21
    00919 0646      CPC	R4,R22
    0091A 0657      CPC	R5,R23
    0091B F428      BCC	0x0921
    0091C E001      LDI	R16,1
    0091D E010      LDI	R17,0
    0091E E020      LDI	R18,0
    0091F E030      LDI	R19,0
    00920 C119      RJMP	0x0A3A
(0994) 		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
    00921 01F6      MOVW	R30,R12
    00922 9676      ADIW	R30,0x16
    00923 8020      LD	R2,Z
    00924 8031      LDD	R3,Z+1
    00925 8042      LDD	R4,Z+2
    00926 8053      LDD	R5,Z+3
    00927 846A      LDD	R6,Y+10
    00928 847B      LDD	R7,Y+11
    00929 848C      LDD	R8,Y+12
    0092A 849D      LDD	R9,Y+13
    0092B 1462      CP	R6,R2
    0092C 0473      CPC	R7,R3
    0092D 0484      CPC	R8,R4
    0092E 0495      CPC	R9,R5
    0092F F418      BCC	0x0933
    00930 0183      MOVW	R16,R6
    00931 0194      MOVW	R18,R8
    00932 C107      RJMP	0x0A3A
(0995) 		scl = clst;
    00933 A028      LDD	R2,Y+32
    00934 A039      LDD	R3,Y+33
    00935 A04A      LDD	R4,Y+34
    00936 A05B      LDD	R5,Y+35
    00937 862E      STD	Y+14,R2
    00938 863F      STD	Y+15,R3
    00939 8A48      STD	Y+16,R4
    0093A 8A59      STD	Y+17,R5
(0996) 	}
(0997) 
(0998) 	ncl = scl;				/* Start cluster */
    0093B 842E      LDD	R2,Y+14
    0093C 843F      LDD	R3,Y+15
    0093D 8848      LDD	R4,Y+16
    0093E 8859      LDD	R5,Y+17
    0093F 822E      STD	Y+6,R2
    00940 823F      STD	Y+7,R3
    00941 8648      STD	Y+8,R4
    00942 8659      STD	Y+9,R5
(0999) 	for (;;) {
(1000) 		ncl++;							/* Next cluster */
    00943 E041      LDI	R20,1
    00944 E050      LDI	R21,0
    00945 E060      LDI	R22,0
    00946 E070      LDI	R23,0
    00947 802E      LDD	R2,Y+6
    00948 803F      LDD	R3,Y+7
    00949 8448      LDD	R4,Y+8
    0094A 8459      LDD	R5,Y+9
    0094B 0E24      ADD	R2,R20
    0094C 1E35      ADC	R3,R21
    0094D 1E46      ADC	R4,R22
    0094E 1E57      ADC	R5,R23
    0094F 822E      STD	Y+6,R2
    00950 823F      STD	Y+7,R3
    00951 8648      STD	Y+8,R4
    00952 8659      STD	Y+9,R5
(1001) 		if (ncl >= fs->n_fatent) {		/* Wrap around */
    00953 01F6      MOVW	R30,R12
    00954 9676      ADIW	R30,0x16
    00955 8020      LD	R2,Z
    00956 8031      LDD	R3,Z+1
    00957 8042      LDD	R4,Z+2
    00958 8053      LDD	R5,Z+3
    00959 806E      LDD	R6,Y+6
    0095A 807F      LDD	R7,Y+7
    0095B 8488      LDD	R8,Y+8
    0095C 8499      LDD	R9,Y+9
    0095D 1462      CP	R6,R2
    0095E 0473      CPC	R7,R3
    0095F 0484      CPC	R8,R4
    00960 0495      CPC	R9,R5
    00961 F0C0      BCS	0x097A
(1002) 			ncl = 2;
    00962 E082      LDI	R24,2
    00963 838E      STD	Y+6,R24
    00964 E080      LDI	R24,0
    00965 838F      STD	Y+7,R24
    00966 8788      STD	Y+8,R24
    00967 8789      STD	Y+9,R24
(1003) 			if (ncl > scl) return 0;	/* No free cluster */
    00968 842E      LDD	R2,Y+14
    00969 843F      LDD	R3,Y+15
    0096A 8848      LDD	R4,Y+16
    0096B 8859      LDD	R5,Y+17
    0096C 806E      LDD	R6,Y+6
    0096D 807F      LDD	R7,Y+7
    0096E 8488      LDD	R8,Y+8
    0096F 8499      LDD	R9,Y+9
    00970 1426      CP	R2,R6
    00971 0437      CPC	R3,R7
    00972 0448      CPC	R4,R8
    00973 0459      CPC	R5,R9
    00974 F428      BCC	0x097A
    00975 E000      LDI	R16,0
    00976 E010      LDI	R17,0
    00977 E020      LDI	R18,0
    00978 E030      LDI	R19,0
    00979 C0C0      RJMP	0x0A3A
(1004) 		}
(1005) 		cs = get_fat(fs, ncl);			/* Get the cluster status */
    0097A 802E      LDD	R2,Y+6
    0097B 803F      LDD	R3,Y+7
    0097C 8448      LDD	R4,Y+8
    0097D 8459      LDD	R5,Y+9
    0097E 8248      ST	Y,R4
    0097F 8259      STD	Y+1,R5
    00980 0191      MOVW	R18,R2
    00981 0186      MOVW	R16,R12
    00982 DB82      RCALL	_get_fat
    00983 870A      STD	Y+10,R16
    00984 871B      STD	Y+11,R17
    00985 872C      STD	Y+12,R18
    00986 873D      STD	Y+13,R19
(1006) 		if (cs == 0) break;				/* Found a free cluster */
    00987 842A      LDD	R2,Y+10
    00988 843B      LDD	R3,Y+11
    00989 844C      LDD	R4,Y+12
    0098A 845D      LDD	R5,Y+13
    0098B 9488      BCLR	0
    0098C 2022      TST	R2
    0098D 0432      CPC	R3,R2
    0098E 0442      CPC	R4,R2
    0098F 0452      CPC	R5,R2
    00990 F409      BNE	0x0992
    00991 C02E      RJMP	0x09C0
(1007) 		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
    00992 EF4F      LDI	R20,0xFF
    00993 EF5F      LDI	R21,0xFF
    00994 EF6F      LDI	R22,0xFF
    00995 EF7F      LDI	R23,0xFF
    00996 842A      LDD	R2,Y+10
    00997 843B      LDD	R3,Y+11
    00998 844C      LDD	R4,Y+12
    00999 845D      LDD	R5,Y+13
    0099A 1624      CP	R2,R20
    0099B 0635      CPC	R3,R21
    0099C 0646      CPC	R4,R22
    0099D 0657      CPC	R5,R23
    0099E F049      BEQ	0x09A8
    0099F E041      LDI	R20,1
    009A0 E050      LDI	R21,0
    009A1 E060      LDI	R22,0
    009A2 E070      LDI	R23,0
    009A3 1624      CP	R2,R20
    009A4 0635      CPC	R3,R21
    009A5 0646      CPC	R4,R22
    009A6 0657      CPC	R5,R23
    009A7 F429      BNE	0x09AD
(1008) 			return cs;
    009A8 850A      LDD	R16,Y+10
    009A9 851B      LDD	R17,Y+11
    009AA 852C      LDD	R18,Y+12
    009AB 853D      LDD	R19,Y+13
    009AC C08D      RJMP	0x0A3A
(1009) 		if (ncl == scl) return 0;		/* No free cluster */
    009AD 842E      LDD	R2,Y+14
    009AE 843F      LDD	R3,Y+15
    009AF 8848      LDD	R4,Y+16
    009B0 8859      LDD	R5,Y+17
    009B1 806E      LDD	R6,Y+6
    009B2 807F      LDD	R7,Y+7
    009B3 8488      LDD	R8,Y+8
    009B4 8499      LDD	R9,Y+9
    009B5 1462      CP	R6,R2
    009B6 0473      CPC	R7,R3
    009B7 0484      CPC	R8,R4
    009B8 0495      CPC	R9,R5
    009B9 F009      BEQ	0x09BB
    009BA CF88      RJMP	0x0943
    009BB E000      LDI	R16,0
    009BC E010      LDI	R17,0
    009BD E020      LDI	R18,0
    009BE E030      LDI	R19,0
    009BF C07A      RJMP	0x0A3A
(1010) 	}
(1011) 
(1012) 	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
    009C0 EF8F      LDI	R24,0xFF
    009C1 838A      STD	Y+2,R24
    009C2 838B      STD	Y+3,R24
    009C3 838C      STD	Y+4,R24
    009C4 E08F      LDI	R24,0xF
    009C5 838D      STD	Y+5,R24
    009C6 802E      LDD	R2,Y+6
    009C7 803F      LDD	R3,Y+7
    009C8 8448      LDD	R4,Y+8
    009C9 8459      LDD	R5,Y+9
    009CA 8248      ST	Y,R4
    009CB 8259      STD	Y+1,R5
    009CC 0191      MOVW	R18,R2
    009CD 0186      MOVW	R16,R12
    009CE DC86      RCALL	_put_fat
    009CF 2EA0      MOV	R10,R16
(1013) 	if (res == FR_OK && clst != 0) {
    009D0 2300      TST	R16
    009D1 F4E1      BNE	0x09EE
    009D2 A028      LDD	R2,Y+32
    009D3 A039      LDD	R3,Y+33
    009D4 A04A      LDD	R4,Y+34
    009D5 A05B      LDD	R5,Y+35
    009D6 9488      BCLR	0
    009D7 2022      TST	R2
    009D8 0432      CPC	R3,R2
    009D9 0442      CPC	R4,R2
    009DA 0452      CPC	R5,R2
    009DB F091      BEQ	0x09EE
(1014) 		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
    009DC 802E      LDD	R2,Y+6
    009DD 803F      LDD	R3,Y+7
    009DE 8448      LDD	R4,Y+8
    009DF 8459      LDD	R5,Y+9
    009E0 822A      STD	Y+2,R2
    009E1 823B      STD	Y+3,R3
    009E2 824C      STD	Y+4,R4
    009E3 825D      STD	Y+5,R5
    009E4 A028      LDD	R2,Y+32
    009E5 A039      LDD	R3,Y+33
    009E6 A04A      LDD	R4,Y+34
    009E7 A05B      LDD	R5,Y+35
    009E8 8248      ST	Y,R4
    009E9 8259      STD	Y+1,R5
    009EA 0191      MOVW	R18,R2
    009EB 0186      MOVW	R16,R12
    009EC DC68      RCALL	_put_fat
    009ED 2EA0      MOV	R10,R16
(1015) 	}
(1016) 	if (res == FR_OK) {
    009EE 20AA      TST	R10
    009EF F009      BEQ	0x09F1
    009F0 C02E      RJMP	0x0A1F
(1017) 		fs->last_clust = ncl;			/* Update FSINFO */
    009F1 802E      LDD	R2,Y+6
    009F2 803F      LDD	R3,Y+7
    009F3 8448      LDD	R4,Y+8
    009F4 8459      LDD	R5,Y+9
    009F5 01F6      MOVW	R30,R12
    009F6 8622      STD	Z+10,R2
    009F7 8633      STD	Z+11,R3
    009F8 8644      STD	Z+12,R4
    009F9 8655      STD	Z+13,R5
(1018) 		if (fs->free_clust != 0xFFFFFFFF) {
    009FA EF4F      LDI	R20,0xFF
    009FB EF5F      LDI	R21,0xFF
    009FC EF6F      LDI	R22,0xFF
    009FD EF7F      LDI	R23,0xFF
    009FE 8426      LDD	R2,Z+14
    009FF 8437      LDD	R3,Z+15
    00A00 8840      LDD	R4,Z+16
    00A01 8851      LDD	R5,Z+17
    00A02 1624      CP	R2,R20
    00A03 0635      CPC	R3,R21
    00A04 0646      CPC	R4,R22
    00A05 0657      CPC	R5,R23
    00A06 F179      BEQ	0x0A36
(1019) 			fs->free_clust--;
    00A07 01CF      MOVW	R24,R30
    00A08 960E      ADIW	R24,0xE
    00A09 017C      MOVW	R14,R24
    00A0A E041      LDI	R20,1
    00A0B E050      LDI	R21,0
    00A0C E060      LDI	R22,0
    00A0D E070      LDI	R23,0
    00A0E 01FC      MOVW	R30,R24
    00A0F 8020      LD	R2,Z
    00A10 8031      LDD	R3,Z+1
    00A11 8042      LDD	R4,Z+2
    00A12 8053      LDD	R5,Z+3
    00A13 1A24      SUB	R2,R20
    00A14 0A35      SBC	R3,R21
    00A15 0A46      SBC	R4,R22
    00A16 0A57      SBC	R5,R23
    00A17 8220      ST	Z,R2
    00A18 8231      STD	Z+1,R3
    00A19 8242      STD	Z+2,R4
    00A1A 8253      STD	Z+3,R5
(1020) 			fs->fsi_flag = 1;
    00A1B E081      LDI	R24,1
    00A1C 01F6      MOVW	R30,R12
    00A1D 8385      STD	Z+5,R24
(1021) 		}
(1022) 	} else {
    00A1E C017      RJMP	0x0A36
(1023) 		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
    00A1F 2D8A      MOV	R24,R10
    00A20 3081      CPI	R24,1
    00A21 F431      BNE	0x0A28
    00A22 EF8F      LDI	R24,0xFF
    00A23 8B8A      STD	Y+18,R24
    00A24 8B8B      STD	Y+19,R24
    00A25 8B8C      STD	Y+20,R24
    00A26 8B8D      STD	Y+21,R24
    00A27 C006      RJMP	0x0A2E
    00A28 E081      LDI	R24,1
    00A29 8B8A      STD	Y+18,R24
    00A2A E080      LDI	R24,0
    00A2B 8B8B      STD	Y+19,R24
    00A2C 8B8C      STD	Y+20,R24
    00A2D 8B8D      STD	Y+21,R24
    00A2E 882A      LDD	R2,Y+18
    00A2F 883B      LDD	R3,Y+19
    00A30 884C      LDD	R4,Y+20
    00A31 885D      LDD	R5,Y+21
    00A32 822E      STD	Y+6,R2
    00A33 823F      STD	Y+7,R3
    00A34 8648      STD	Y+8,R4
    00A35 8659      STD	Y+9,R5
(1024) 	}
(1025) 
(1026) 	return ncl;		/* Return new cluster number or error code */
    00A36 810E      LDD	R16,Y+6
    00A37 811F      LDD	R17,Y+7
    00A38 8528      LDD	R18,Y+8
    00A39 8539      LDD	R19,Y+9
    00A3A 9666      ADIW	R28,0x16
    00A3B 940E 3F69 CALL	pop_xgsetF0FC
    00A3D 9622      ADIW	R28,2
    00A3E 9508      RET
ff.c:clmt_clust:
  tbl                  --> R10
  cl                   --> Y,+4
  ncl                  --> Y,+0
  ofs                  --> Y,+12
  fp                   --> R12
    00A3F 933A      ST	-Y,R19
    00A40 932A      ST	-Y,R18
    00A41 940E 3F7A CALL	push_xgset003C
    00A43 0168      MOVW	R12,R16
    00A44 9728      SBIW	R28,0x8
(1027) }
(1028) #endif /* !_FS_READONLY */
(1029) 
(1030) 
(1031) 
(1032) /*-----------------------------------------------------------------------*/
(1033) /* FAT handling - Convert offset into cluster with link map table        */
(1034) /*-----------------------------------------------------------------------*/
(1035) 
(1036) #if _USE_FASTSEEK
(1037) static
(1038) DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
(1039) 	FIL* fp,		/* Pointer to the file object */
(1040) 	DWORD ofs		/* File offset to be converted to cluster# */
(1041) )
(1042) {
(1043) 	DWORD cl, ncl, *tbl;
(1044) 
(1045) 
(1046) 	tbl = fp->cltbl + 1;	/* Top of CLMT */
    00A45 01F6      MOVW	R30,R12
    00A46 96B0      ADIW	R30,0x20
    00A47 8180      LD	R24,Z
    00A48 8191      LDD	R25,Z+1
    00A49 9604      ADIW	R24,4
    00A4A 015C      MOVW	R10,R24
(1047) 	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
    00A4B E089      LDI	R24,0x9
    00A4C E090      LDI	R25,0
    00A4D 850C      LDD	R16,Y+12
    00A4E 851D      LDD	R17,Y+13
    00A4F 852E      LDD	R18,Y+14
    00A50 853F      LDD	R19,Y+15
    00A51 938A      ST	-Y,R24
    00A52 940E 400F CALL	lsr32
    00A54 01F6      MOVW	R30,R12
    00A55 93AF      PUSH	R26
    00A56 93BF      PUSH	R27
    00A57 81A0      LD	R26,Z
    00A58 81B1      LDD	R27,Z+1
    00A59 01FD      MOVW	R30,R26
    00A5A 91BF      POP	R27
    00A5B 91AF      POP	R26
    00A5C 9632      ADIW	R30,2
    00A5D 8020      LD	R2,Z
    00A5E 2433      CLR	R3
    00A5F 2444      CLR	R4
    00A60 2455      CLR	R5
    00A61 925A      ST	-Y,R5
    00A62 924A      ST	-Y,R4
    00A63 923A      ST	-Y,R3
    00A64 922A      ST	-Y,R2
    00A65 940E 3E7A CALL	div32u
    00A67 830C      STD	Y+4,R16
    00A68 831D      STD	Y+5,R17
    00A69 832E      STD	Y+6,R18
    00A6A 833F      STD	Y+7,R19
(1048) 	for (;;) {
(1049) 		ncl = *tbl++;			/* Number of cluters in the fragment */
    00A6B 01F5      MOVW	R30,R10
    00A6C 9021      LD	R2,Z+
    00A6D 9031      LD	R3,Z+
    00A6E 9041      LD	R4,Z+
    00A6F 9051      LD	R5,Z+
    00A70 015F      MOVW	R10,R30
    00A71 8228      ST	Y,R2
    00A72 8239      STD	Y+1,R3
    00A73 824A      STD	Y+2,R4
    00A74 825B      STD	Y+3,R5
(1050) 		if (!ncl) return 0;		/* End of table? (error) */
    00A75 8028      LD	R2,Y
    00A76 8039      LDD	R3,Y+1
    00A77 804A      LDD	R4,Y+2
    00A78 805B      LDD	R5,Y+3
    00A79 9488      BCLR	0
    00A7A 2022      TST	R2
    00A7B 0432      CPC	R3,R2
    00A7C 0442      CPC	R4,R2
    00A7D 0452      CPC	R5,R2
    00A7E F429      BNE	0x0A84
    00A7F E000      LDI	R16,0
    00A80 E010      LDI	R17,0
    00A81 E020      LDI	R18,0
    00A82 E030      LDI	R19,0
    00A83 C02F      RJMP	0x0AB3
(1051) 		if (cl < ncl) break;	/* In this fragment? */
    00A84 8028      LD	R2,Y
    00A85 8039      LDD	R3,Y+1
    00A86 804A      LDD	R4,Y+2
    00A87 805B      LDD	R5,Y+3
    00A88 806C      LDD	R6,Y+4
    00A89 807D      LDD	R7,Y+5
    00A8A 808E      LDD	R8,Y+6
    00A8B 809F      LDD	R9,Y+7
    00A8C 1462      CP	R6,R2
    00A8D 0473      CPC	R7,R3
    00A8E 0484      CPC	R8,R4
    00A8F 0495      CPC	R9,R5
    00A90 F408      BCC	0x0A92
    00A91 C014      RJMP	0x0AA6
(1052) 		cl -= ncl; tbl++;		/* Next fragment */
    00A92 8028      LD	R2,Y
    00A93 8039      LDD	R3,Y+1
    00A94 804A      LDD	R4,Y+2
    00A95 805B      LDD	R5,Y+3
    00A96 806C      LDD	R6,Y+4
    00A97 807D      LDD	R7,Y+5
    00A98 808E      LDD	R8,Y+6
    00A99 809F      LDD	R9,Y+7
    00A9A 1862      SUB	R6,R2
    00A9B 0873      SBC	R7,R3
    00A9C 0884      SBC	R8,R4
    00A9D 0895      SBC	R9,R5
    00A9E 826C      STD	Y+4,R6
    00A9F 827D      STD	Y+5,R7
    00AA0 828E      STD	Y+6,R8
    00AA1 829F      STD	Y+7,R9
    00AA2 01C5      MOVW	R24,R10
    00AA3 9604      ADIW	R24,4
    00AA4 015C      MOVW	R10,R24
    00AA5 CFC5      RJMP	0x0A6B
(1053) 	}
(1054) 	return cl + *tbl;	/* Return the cluster number */
    00AA6 01F5      MOVW	R30,R10
    00AA7 8020      LD	R2,Z
    00AA8 8031      LDD	R3,Z+1
    00AA9 8042      LDD	R4,Z+2
    00AAA 8053      LDD	R5,Z+3
    00AAB 810C      LDD	R16,Y+4
    00AAC 811D      LDD	R17,Y+5
    00AAD 812E      LDD	R18,Y+6
    00AAE 813F      LDD	R19,Y+7
    00AAF 0D02      ADD	R16,R2
    00AB0 1D13      ADC	R17,R3
    00AB1 1D24      ADC	R18,R4
    00AB2 1D35      ADC	R19,R5
    00AB3 9628      ADIW	R28,0x8
    00AB4 940E 3F54 CALL	pop_xgset003C
    00AB6 9622      ADIW	R28,2
    00AB7 9508      RET
ff.c:dir_sdi:
  ic                   --> R14
  clst                 --> Y,+2
  idx                  --> R12
  dj                   --> R10
    00AB8 940E 3F74 CALL	push_xgsetF0FC
    00ABA 0169      MOVW	R12,R18
    00ABB 0158      MOVW	R10,R16
    00ABC 9726      SBIW	R28,6
(1055) }
(1056) #endif	/* _USE_FASTSEEK */
(1057) 
(1058) 
(1059) 
(1060) /*-----------------------------------------------------------------------*/
(1061) /* Directory handling - Set directory index                              */
(1062) /*-----------------------------------------------------------------------*/
(1063) 
(1064) static
(1065) FRESULT dir_sdi (
(1066) 	DIR *dj,		/* Pointer to directory object */
(1067) 	WORD idx		/* Directory index number */
(1068) )
(1069) {
(1070) 	DWORD clst;
(1071) 	WORD ic;
(1072) 
(1073) 
(1074) 	dj->index = idx;
    00ABD 01F5      MOVW	R30,R10
    00ABE 82D5      STD	Z+5,R13
    00ABF 82C4      STD	Z+4,R12
(1075) 	clst = dj->sclust;
    00AC0 9636      ADIW	R30,6
    00AC1 8020      LD	R2,Z
    00AC2 8031      LDD	R3,Z+1
    00AC3 8042      LDD	R4,Z+2
    00AC4 8053      LDD	R5,Z+3
    00AC5 822A      STD	Y+2,R2
    00AC6 823B      STD	Y+3,R3
    00AC7 824C      STD	Y+4,R4
    00AC8 825D      STD	Y+5,R5
(1076) 	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    00AC9 E041      LDI	R20,1
    00ACA E050      LDI	R21,0
    00ACB E060      LDI	R22,0
    00ACC E070      LDI	R23,0
    00ACD 802A      LDD	R2,Y+2
    00ACE 803B      LDD	R3,Y+3
    00ACF 804C      LDD	R4,Y+4
    00AD0 805D      LDD	R5,Y+5
    00AD1 1624      CP	R2,R20
    00AD2 0635      CPC	R3,R21
    00AD3 0646      CPC	R4,R22
    00AD4 0657      CPC	R5,R23
    00AD5 F089      BEQ	0x0AE7
    00AD6 01F5      MOVW	R30,R10
    00AD7 81A0      LD	R26,Z
    00AD8 81B1      LDD	R27,Z+1
    00AD9 9656      ADIW	R26,0x16
    00ADA 902D      LD	R2,X+
    00ADB 903D      LD	R3,X+
    00ADC 904D      LD	R4,X+
    00ADD 905C      LD	R5,X
    00ADE 806A      LDD	R6,Y+2
    00ADF 807B      LDD	R7,Y+3
    00AE0 808C      LDD	R8,Y+4
    00AE1 809D      LDD	R9,Y+5
    00AE2 1462      CP	R6,R2
    00AE3 0473      CPC	R7,R3
    00AE4 0484      CPC	R8,R4
    00AE5 0495      CPC	R9,R5
    00AE6 F010      BCS	0x0AE9
(1077) 		return FR_INT_ERR;
    00AE7 E002      LDI	R16,2
    00AE8 C0D6      RJMP	0x0BBF
(1078) 	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    00AE9 802A      LDD	R2,Y+2
    00AEA 803B      LDD	R3,Y+3
    00AEB 804C      LDD	R4,Y+4
    00AEC 805D      LDD	R5,Y+5
    00AED 9488      BCLR	0
    00AEE 2022      TST	R2
    00AEF 0432      CPC	R3,R2
    00AF0 0442      CPC	R4,R2
    00AF1 0452      CPC	R5,R2
    00AF2 F479      BNE	0x0B02
    00AF3 01F5      MOVW	R30,R10
    00AF4 81A0      LD	R26,Z
    00AF5 81B1      LDD	R27,Z+1
    00AF6 918C      LD	R24,X
    00AF7 3083      CPI	R24,3
    00AF8 F449      BNE	0x0B02
(1079) 		clst = dj->fs->dirbase;
    00AF9 9692      ADIW	R26,0x22
    00AFA 902D      LD	R2,X+
    00AFB 903D      LD	R3,X+
    00AFC 904D      LD	R4,X+
    00AFD 905C      LD	R5,X
    00AFE 822A      STD	Y+2,R2
    00AFF 823B      STD	Y+3,R3
    00B00 824C      STD	Y+4,R4
    00B01 825D      STD	Y+5,R5
(1080) 
(1081) 	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    00B02 802A      LDD	R2,Y+2
    00B03 803B      LDD	R3,Y+3
    00B04 804C      LDD	R4,Y+4
    00B05 805D      LDD	R5,Y+5
    00B06 9488      BCLR	0
    00B07 2022      TST	R2
    00B08 0432      CPC	R3,R2
    00B09 0442      CPC	R4,R2
    00B0A 0452      CPC	R5,R2
    00B0B F009      BEQ	0x0B0D
    00B0C C02B      RJMP	0x0B38
(1082) 		dj->clust = clst;
    00B0D 01F5      MOVW	R30,R10
    00B0E 8622      STD	Z+10,R2
    00B0F 8633      STD	Z+11,R3
    00B10 8644      STD	Z+12,R4
    00B11 8655      STD	Z+13,R5
(1083) 		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    00B12 81A0      LD	R26,Z
    00B13 81B1      LDD	R27,Z+1
    00B14 9618      ADIW	R26,0x8
    00B15 902D      LD	R2,X+
    00B16 903C      LD	R3,X
    00B17 14C2      CP	R12,R2
    00B18 04D3      CPC	R13,R3
    00B19 F010      BCS	0x0B1C
(1084) 			return FR_INT_ERR;
    00B1A E002      LDI	R16,2
    00B1B C0A3      RJMP	0x0BBF
(1085) 		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B1C 0116      MOVW	R2,R12
    00B1D 9436      LSR	R3
    00B1E 9427      ROR	R2
    00B1F 9436      LSR	R3
    00B20 9427      ROR	R2
    00B21 9436      LSR	R3
    00B22 9427      ROR	R2
    00B23 9436      LSR	R3
    00B24 9427      ROR	R2
    00B25 2444      CLR	R4
    00B26 2455      CLR	R5
    00B27 01F5      MOVW	R30,R10
    00B28 81A0      LD	R26,Z
    00B29 81B1      LDD	R27,Z+1
    00B2A 9692      ADIW	R26,0x22
    00B2B 906D      LD	R6,X+
    00B2C 907D      LD	R7,X+
    00B2D 908D      LD	R8,X+
    00B2E 909C      LD	R9,X
    00B2F 0C62      ADD	R6,R2
    00B30 1C73      ADC	R7,R3
    00B31 1C84      ADC	R8,R4
    00B32 1C95      ADC	R9,R5
    00B33 8666      STD	Z+14,R6
    00B34 8677      STD	Z+15,R7
    00B35 8A80      STD	Z+16,R8
    00B36 8A91      STD	Z+17,R9
(1086) 	}
    00B37 C076      RJMP	0x0BAE
(1087) 	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
(1088) 		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    00B38 01F5      MOVW	R30,R10
    00B39 93AF      PUSH	R26
    00B3A 93BF      PUSH	R27
    00B3B 81A0      LD	R26,Z
    00B3C 81B1      LDD	R27,Z+1
    00B3D 01FD      MOVW	R30,R26
    00B3E 91BF      POP	R27
    00B3F 91AF      POP	R26
    00B40 8022      LDD	R2,Z+2
    00B41 E180      LDI	R24,0x10
    00B42 9D82      MUL	R24,R2
    00B43 0170      MOVW	R14,R0
    00B44 C040      RJMP	0x0B85
(1089) 		while (idx >= ic) {	/* Follow cluster chain */
(1090) 			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    00B45 802A      LDD	R2,Y+2
    00B46 803B      LDD	R3,Y+3
    00B47 804C      LDD	R4,Y+4
    00B48 805D      LDD	R5,Y+5
    00B49 8248      ST	Y,R4
    00B4A 8259      STD	Y+1,R5
    00B4B 0191      MOVW	R18,R2
    00B4C 01F5      MOVW	R30,R10
    00B4D 8100      LD	R16,Z
    00B4E 8111      LDD	R17,Z+1
    00B4F D9B5      RCALL	_get_fat
    00B50 830A      STD	Y+2,R16
    00B51 831B      STD	Y+3,R17
    00B52 832C      STD	Y+4,R18
    00B53 833D      STD	Y+5,R19
(1091) 			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    00B54 EF4F      LDI	R20,0xFF
    00B55 EF5F      LDI	R21,0xFF
    00B56 EF6F      LDI	R22,0xFF
    00B57 EF7F      LDI	R23,0xFF
    00B58 802A      LDD	R2,Y+2
    00B59 803B      LDD	R3,Y+3
    00B5A 804C      LDD	R4,Y+4
    00B5B 805D      LDD	R5,Y+5
    00B5C 1624      CP	R2,R20
    00B5D 0635      CPC	R3,R21
    00B5E 0646      CPC	R4,R22
    00B5F 0657      CPC	R5,R23
    00B60 F411      BNE	0x0B63
    00B61 E001      LDI	R16,1
    00B62 C05C      RJMP	0x0BBF
(1092) 			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    00B63 E042      LDI	R20,2
    00B64 E050      LDI	R21,0
    00B65 E060      LDI	R22,0
    00B66 E070      LDI	R23,0
    00B67 802A      LDD	R2,Y+2
    00B68 803B      LDD	R3,Y+3
    00B69 804C      LDD	R4,Y+4
    00B6A 805D      LDD	R5,Y+5
    00B6B 1624      CP	R2,R20
    00B6C 0635      CPC	R3,R21
    00B6D 0646      CPC	R4,R22
    00B6E 0657      CPC	R5,R23
    00B6F F088      BCS	0x0B81
    00B70 01F5      MOVW	R30,R10
    00B71 81A0      LD	R26,Z
    00B72 81B1      LDD	R27,Z+1
    00B73 9656      ADIW	R26,0x16
    00B74 902D      LD	R2,X+
    00B75 903D      LD	R3,X+
    00B76 904D      LD	R4,X+
    00B77 905C      LD	R5,X
    00B78 806A      LDD	R6,Y+2
    00B79 807B      LDD	R7,Y+3
    00B7A 808C      LDD	R8,Y+4
    00B7B 809D      LDD	R9,Y+5
    00B7C 1462      CP	R6,R2
    00B7D 0473      CPC	R7,R3
    00B7E 0484      CPC	R8,R4
    00B7F 0495      CPC	R9,R5
    00B80 F010      BCS	0x0B83
(1093) 				return FR_INT_ERR;
    00B81 E002      LDI	R16,2
    00B82 C03C      RJMP	0x0BBF
(1094) 			idx -= ic;
    00B83 18CE      SUB	R12,R14
    00B84 08DF      SBC	R13,R15
    00B85 14CE      CP	R12,R14
    00B86 04DF      CPC	R13,R15
    00B87 F008      BCS	0x0B89
    00B88 CFBC      RJMP	0x0B45
(1095) 		}
(1096) 		dj->clust = clst;
    00B89 802A      LDD	R2,Y+2
    00B8A 803B      LDD	R3,Y+3
    00B8B 804C      LDD	R4,Y+4
    00B8C 805D      LDD	R5,Y+5
    00B8D 01F5      MOVW	R30,R10
    00B8E 8622      STD	Z+10,R2
    00B8F 8633      STD	Z+11,R3
    00B90 8644      STD	Z+12,R4
    00B91 8655      STD	Z+13,R5
(1097) 		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    00B92 8248      ST	Y,R4
    00B93 8259      STD	Y+1,R5
    00B94 0191      MOVW	R18,R2
    00B95 8100      LD	R16,Z
    00B96 8111      LDD	R17,Z+1
    00B97 D91B      RCALL	_clust2sect
    00B98 0116      MOVW	R2,R12
    00B99 9436      LSR	R3
    00B9A 9427      ROR	R2
    00B9B 9436      LSR	R3
    00B9C 9427      ROR	R2
    00B9D 9436      LSR	R3
    00B9E 9427      ROR	R2
    00B9F 9436      LSR	R3
    00BA0 9427      ROR	R2
    00BA1 2444      CLR	R4
    00BA2 2455      CLR	R5
    00BA3 0138      MOVW	R6,R16
    00BA4 0149      MOVW	R8,R18
    00BA5 0C62      ADD	R6,R2
    00BA6 1C73      ADC	R7,R3
    00BA7 1C84      ADC	R8,R4
    00BA8 1C95      ADC	R9,R5
    00BA9 01F5      MOVW	R30,R10
    00BAA 8666      STD	Z+14,R6
    00BAB 8677      STD	Z+15,R7
    00BAC 8A80      STD	Z+16,R8
    00BAD 8A91      STD	Z+17,R9
(1098) 	}
(1099) 
(1100) 	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    00BAE 0196      MOVW	R18,R12
    00BAF 702F      ANDI	R18,0xF
    00BB0 7030      ANDI	R19,0
    00BB1 E200      LDI	R16,0x20
    00BB2 E010      LDI	R17,0
    00BB3 940E 3F10 CALL	empy16s
    00BB5 0118      MOVW	R2,R16
    00BB6 01F5      MOVW	R30,R10
    00BB7 8180      LD	R24,Z
    00BB8 8191      LDD	R25,Z+1
    00BB9 968E      ADIW	R24,0x2E
    00BBA 0E28      ADD	R2,R24
    00BBB 1E39      ADC	R3,R25
    00BBC 8A33      STD	Z+19,R3
    00BBD 8A22      STD	Z+18,R2
(1101) 
(1102) 	return FR_OK;	/* Seek succeeded */
    00BBE 2700      CLR	R16
    00BBF 9626      ADIW	R28,6
    00BC0 940C 3F69 JMP	pop_xgsetF0FC
ff.c:dir_next:
  c                    --> R10
  clst                 --> Y,+2
  i                    --> R12
  stretch              --> R10
  dj                   --> Y,+16
    00BC2 940E 3E2F CALL	push_arg4
    00BC4 940E 3F74 CALL	push_xgsetF0FC
    00BC6 0159      MOVW	R10,R18
    00BC7 9726      SBIW	R28,6
(1103) }
(1104) 
(1105) 
(1106) 
(1107) 
(1108) /*-----------------------------------------------------------------------*/
(1109) /* Directory handling - Move directory index next                        */
(1110) /*-----------------------------------------------------------------------*/
(1111) 
(1112) static
(1113) FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
(1114) 	DIR *dj,		/* Pointer to directory object */
(1115) 	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
(1116) )
(1117) {
(1118) 	DWORD clst;
(1119) 	WORD i;
(1120) 
(1121) 
(1122) 	stretch = stretch;		/* To suppress warning on read-only cfg. */
(1123) 	i = dj->index + 1;
    00BC8 89E8      LDD	R30,Y+16
    00BC9 89F9      LDD	R31,Y+17
    00BCA 8184      LDD	R24,Z+4
    00BCB 8195      LDD	R25,Z+5
    00BCC 9601      ADIW	R24,1
    00BCD 016C      MOVW	R12,R24
(1124) 	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    00BCE 3080      CPI	R24,0
    00BCF 0789      CPC	R24,R25
    00BD0 F059      BEQ	0x0BDC
    00BD1 963E      ADIW	R30,0xE
    00BD2 8020      LD	R2,Z
    00BD3 8031      LDD	R3,Z+1
    00BD4 8042      LDD	R4,Z+2
    00BD5 8053      LDD	R5,Z+3
    00BD6 9488      BCLR	0
    00BD7 2022      TST	R2
    00BD8 0432      CPC	R3,R2
    00BD9 0442      CPC	R4,R2
    00BDA 0452      CPC	R5,R2
    00BDB F411      BNE	0x0BDE
(1125) 		return FR_NO_FILE;
    00BDC E004      LDI	R16,4
    00BDD C18D      RJMP	0x0D6B
(1126) 
(1127) 	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    00BDE 01C6      MOVW	R24,R12
    00BDF 708F      ANDI	R24,0xF
    00BE0 7090      ANDI	R25,0
    00BE1 3080      CPI	R24,0
    00BE2 0789      CPC	R24,R25
    00BE3 F009      BEQ	0x0BE5
    00BE4 C170      RJMP	0x0D55
(1128) 		dj->sect++;					/* Next sector */
    00BE5 8988      LDD	R24,Y+16
    00BE6 8999      LDD	R25,Y+17
    00BE7 960E      ADIW	R24,0xE
    00BE8 E041      LDI	R20,1
    00BE9 E050      LDI	R21,0
    00BEA E060      LDI	R22,0
    00BEB E070      LDI	R23,0
    00BEC 01FC      MOVW	R30,R24
    00BED 8020      LD	R2,Z
    00BEE 8031      LDD	R3,Z+1
    00BEF 8042      LDD	R4,Z+2
    00BF0 8053      LDD	R5,Z+3
    00BF1 0E24      ADD	R2,R20
    00BF2 1E35      ADC	R3,R21
    00BF3 1E46      ADC	R4,R22
    00BF4 1E57      ADC	R5,R23
    00BF5 8220      ST	Z,R2
    00BF6 8231      STD	Z+1,R3
    00BF7 8242      STD	Z+2,R4
    00BF8 8253      STD	Z+3,R5
(1129) 
(1130) 		if (dj->clust == 0) {	/* Static table */
    00BF9 89E8      LDD	R30,Y+16
    00BFA 89F9      LDD	R31,Y+17
    00BFB 963A      ADIW	R30,0xA
    00BFC 8020      LD	R2,Z
    00BFD 8031      LDD	R3,Z+1
    00BFE 8042      LDD	R4,Z+2
    00BFF 8053      LDD	R5,Z+3
    00C00 9488      BCLR	0
    00C01 2022      TST	R2
    00C02 0432      CPC	R3,R2
    00C03 0442      CPC	R4,R2
    00C04 0452      CPC	R5,R2
    00C05 F469      BNE	0x0C13
(1131) 			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    00C06 89E8      LDD	R30,Y+16
    00C07 89F9      LDD	R31,Y+17
    00C08 81A0      LD	R26,Z
    00C09 81B1      LDD	R27,Z+1
    00C0A 9618      ADIW	R26,0x8
    00C0B 902D      LD	R2,X+
    00C0C 903C      LD	R3,X
    00C0D 14C2      CP	R12,R2
    00C0E 04D3      CPC	R13,R3
    00C0F F408      BCC	0x0C11
    00C10 C144      RJMP	0x0D55
(1132) 				return FR_NO_FILE;
    00C11 E004      LDI	R16,4
    00C12 C158      RJMP	0x0D6B
(1133) 		}
(1134) 		else {					/* Dynamic table */
(1135) 			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    00C13 89E8      LDD	R30,Y+16
    00C14 89F9      LDD	R31,Y+17
    00C15 93AF      PUSH	R26
    00C16 93BF      PUSH	R27
    00C17 81A0      LD	R26,Z
    00C18 81B1      LDD	R27,Z+1
    00C19 01FD      MOVW	R30,R26
    00C1A 91BF      POP	R27
    00C1B 91AF      POP	R26
    00C1C 8182      LDD	R24,Z+2
    00C1D 2799      CLR	R25
    00C1E 9701      SBIW	R24,1
    00C1F 0116      MOVW	R2,R12
    00C20 9436      LSR	R3
    00C21 9427      ROR	R2
    00C22 9436      LSR	R3
    00C23 9427      ROR	R2
    00C24 9436      LSR	R3
    00C25 9427      ROR	R2
    00C26 9436      LSR	R3
    00C27 9427      ROR	R2
    00C28 2228      AND	R2,R24
    00C29 2239      AND	R3,R25
    00C2A 2022      TST	R2
    00C2B F009      BEQ	0x0C2D
    00C2C C128      RJMP	0x0D55
    00C2D 2033      TST	R3
    00C2E F009      BEQ	0x0C30
    00C2F C125      RJMP	0x0D55
(1136) 				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    00C30 89E8      LDD	R30,Y+16
    00C31 89F9      LDD	R31,Y+17
    00C32 8422      LDD	R2,Z+10
    00C33 8433      LDD	R3,Z+11
    00C34 8444      LDD	R4,Z+12
    00C35 8455      LDD	R5,Z+13
    00C36 8248      ST	Y,R4
    00C37 8259      STD	Y+1,R5
    00C38 0191      MOVW	R18,R2
    00C39 8100      LD	R16,Z
    00C3A 8111      LDD	R17,Z+1
    00C3B D8C9      RCALL	_get_fat
    00C3C 830A      STD	Y+2,R16
    00C3D 831B      STD	Y+3,R17
    00C3E 832C      STD	Y+4,R18
    00C3F 833D      STD	Y+5,R19
(1137) 				if (clst <= 1) return FR_INT_ERR;
    00C40 E041      LDI	R20,1
    00C41 E050      LDI	R21,0
    00C42 E060      LDI	R22,0
    00C43 E070      LDI	R23,0
    00C44 802A      LDD	R2,Y+2
    00C45 803B      LDD	R3,Y+3
    00C46 804C      LDD	R4,Y+4
    00C47 805D      LDD	R5,Y+5
    00C48 1542      CP	R20,R2
    00C49 0553      CPC	R21,R3
    00C4A 0564      CPC	R22,R4
    00C4B 0575      CPC	R23,R5
    00C4C F010      BCS	0x0C4F
    00C4D E002      LDI	R16,2
    00C4E C11C      RJMP	0x0D6B
(1138) 				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00C4F EF4F      LDI	R20,0xFF
    00C50 EF5F      LDI	R21,0xFF
    00C51 EF6F      LDI	R22,0xFF
    00C52 EF7F      LDI	R23,0xFF
    00C53 802A      LDD	R2,Y+2
    00C54 803B      LDD	R3,Y+3
    00C55 804C      LDD	R4,Y+4
    00C56 805D      LDD	R5,Y+5
    00C57 1624      CP	R2,R20
    00C58 0635      CPC	R3,R21
    00C59 0646      CPC	R4,R22
    00C5A 0657      CPC	R5,R23
    00C5B F411      BNE	0x0C5E
    00C5C E001      LDI	R16,1
    00C5D C10D      RJMP	0x0D6B
(1139) 				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    00C5E 89E8      LDD	R30,Y+16
    00C5F 89F9      LDD	R31,Y+17
    00C60 81A0      LD	R26,Z
    00C61 81B1      LDD	R27,Z+1
    00C62 9656      ADIW	R26,0x16
    00C63 902D      LD	R2,X+
    00C64 903D      LD	R3,X+
    00C65 904D      LD	R4,X+
    00C66 905C      LD	R5,X
    00C67 806A      LDD	R6,Y+2
    00C68 807B      LDD	R7,Y+3
    00C69 808C      LDD	R8,Y+4
    00C6A 809D      LDD	R9,Y+5
    00C6B 1462      CP	R6,R2
    00C6C 0473      CPC	R7,R3
    00C6D 0484      CPC	R8,R4
    00C6E 0495      CPC	R9,R5
    00C6F F408      BCC	0x0C71
    00C70 C0CD      RJMP	0x0D3E
(1140) #if !_FS_READONLY
(1141) 					BYTE c;
(1142) 					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
    00C71 20AA      TST	R10
    00C72 F421      BNE	0x0C77
    00C73 20BB      TST	R11
    00C74 F411      BNE	0x0C77
    00C75 E004      LDI	R16,4
    00C76 C0F4      RJMP	0x0D6B
(1143) 					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
    00C77 89E8      LDD	R30,Y+16
    00C78 89F9      LDD	R31,Y+17
    00C79 8422      LDD	R2,Z+10
    00C7A 8433      LDD	R3,Z+11
    00C7B 8444      LDD	R4,Z+12
    00C7C 8455      LDD	R5,Z+13
    00C7D 8248      ST	Y,R4
    00C7E 8259      STD	Y+1,R5
    00C7F 0191      MOVW	R18,R2
    00C80 8100      LD	R16,Z
    00C81 8111      LDD	R17,Z+1
    00C82 DC44      RCALL	ff.c:create_chain
    00C83 830A      STD	Y+2,R16
    00C84 831B      STD	Y+3,R17
    00C85 832C      STD	Y+4,R18
    00C86 833D      STD	Y+5,R19
(1144) 					if (clst == 0) return FR_DENIED;			/* No free cluster */
    00C87 802A      LDD	R2,Y+2
    00C88 803B      LDD	R3,Y+3
    00C89 804C      LDD	R4,Y+4
    00C8A 805D      LDD	R5,Y+5
    00C8B 9488      BCLR	0
    00C8C 2022      TST	R2
    00C8D 0432      CPC	R3,R2
    00C8E 0442      CPC	R4,R2
    00C8F 0452      CPC	R5,R2
    00C90 F411      BNE	0x0C93
    00C91 E007      LDI	R16,7
    00C92 C0D8      RJMP	0x0D6B
(1145) 					if (clst == 1) return FR_INT_ERR;
    00C93 E041      LDI	R20,1
    00C94 E050      LDI	R21,0
    00C95 E060      LDI	R22,0
    00C96 E070      LDI	R23,0
    00C97 802A      LDD	R2,Y+2
    00C98 803B      LDD	R3,Y+3
    00C99 804C      LDD	R4,Y+4
    00C9A 805D      LDD	R5,Y+5
    00C9B 1624      CP	R2,R20
    00C9C 0635      CPC	R3,R21
    00C9D 0646      CPC	R4,R22
    00C9E 0657      CPC	R5,R23
    00C9F F411      BNE	0x0CA2
    00CA0 E002      LDI	R16,2
    00CA1 C0C9      RJMP	0x0D6B
(1146) 					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    00CA2 EF4F      LDI	R20,0xFF
    00CA3 EF5F      LDI	R21,0xFF
    00CA4 EF6F      LDI	R22,0xFF
    00CA5 EF7F      LDI	R23,0xFF
    00CA6 802A      LDD	R2,Y+2
    00CA7 803B      LDD	R3,Y+3
    00CA8 804C      LDD	R4,Y+4
    00CA9 805D      LDD	R5,Y+5
    00CAA 1624      CP	R2,R20
    00CAB 0635      CPC	R3,R21
    00CAC 0646      CPC	R4,R22
    00CAD 0657      CPC	R5,R23
    00CAE F411      BNE	0x0CB1
    00CAF E001      LDI	R16,1
    00CB0 C0BA      RJMP	0x0D6B
(1147) 					/* Clean-up stretched table */
(1148) 					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
    00CB1 E040      LDI	R20,0
    00CB2 E050      LDI	R21,0
    00CB3 E060      LDI	R22,0
    00CB4 E070      LDI	R23,0
    00CB5 8368      ST	Y,R22
    00CB6 8379      STD	Y+1,R23
    00CB7 019A      MOVW	R18,R20
    00CB8 89E8      LDD	R30,Y+16
    00CB9 89F9      LDD	R31,Y+17
    00CBA 8100      LD	R16,Z
    00CBB 8111      LDD	R17,Z+1
    00CBC 940E 033C CALL	ff.c:move_window
    00CBE 2300      TST	R16
    00CBF F011      BEQ	0x0CC2
    00CC0 E001      LDI	R16,1
    00CC1 C0A9      RJMP	0x0D6B
(1149) 					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
    00CC2 E080      LDI	R24,0
    00CC3 E092      LDI	R25,2
    00CC4 8399      STD	Y+1,R25
    00CC5 8388      ST	Y,R24
    00CC6 2722      CLR	R18
    00CC7 2733      CLR	R19
    00CC8 89E8      LDD	R30,Y+16
    00CC9 89F9      LDD	R31,Y+17
    00CCA 8100      LD	R16,Z
    00CCB 8111      LDD	R17,Z+1
    00CCC 5D02      SUBI	R16,0xD2
    00CCD 4F1F      SBCI	R17,0xFF
    00CCE 940E 02F9 CALL	ff.c:mem_set
(1150) 					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
    00CD0 802A      LDD	R2,Y+2
    00CD1 803B      LDD	R3,Y+3
    00CD2 804C      LDD	R4,Y+4
    00CD3 805D      LDD	R5,Y+5
    00CD4 8248      ST	Y,R4
    00CD5 8259      STD	Y+1,R5
    00CD6 0191      MOVW	R18,R2
    00CD7 89E8      LDD	R30,Y+16
    00CD8 89F9      LDD	R31,Y+17
    00CD9 80A0      LD	R10,Z
    00CDA 80B1      LDD	R11,Z+1
    00CDB 0185      MOVW	R16,R10
    00CDC 940E 04B3 CALL	_clust2sect
    00CDE 01F5      MOVW	R30,R10
    00CDF A702      STD	Z+42,R16
    00CE0 A713      STD	Z+43,R17
    00CE1 A724      STD	Z+44,R18
    00CE2 A735      STD	Z+45,R19
(1151) 					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
    00CE3 24AA      CLR	R10
    00CE4 C035      RJMP	0x0D1A
(1152) 						dj->fs->wflag = 1;
    00CE5 E081      LDI	R24,1
    00CE6 89E8      LDD	R30,Y+16
    00CE7 89F9      LDD	R31,Y+17
    00CE8 93AF      PUSH	R26
    00CE9 93BF      PUSH	R27
    00CEA 81A0      LD	R26,Z
    00CEB 81B1      LDD	R27,Z+1
    00CEC 01FD      MOVW	R30,R26
    00CED 91BF      POP	R27
    00CEE 91AF      POP	R26
    00CEF 8384      STD	Z+4,R24
(1153) 						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
    00CF0 E040      LDI	R20,0
    00CF1 E050      LDI	R21,0
    00CF2 E060      LDI	R22,0
    00CF3 E070      LDI	R23,0
    00CF4 8368      ST	Y,R22
    00CF5 8379      STD	Y+1,R23
    00CF6 019A      MOVW	R18,R20
    00CF7 89E8      LDD	R30,Y+16
    00CF8 89F9      LDD	R31,Y+17
    00CF9 8100      LD	R16,Z
    00CFA 8111      LDD	R17,Z+1
    00CFB 940E 033C CALL	ff.c:move_window
    00CFD 2EE0      MOV	R14,R16
    00CFE 2300      TST	R16
    00CFF F011      BEQ	0x0D02
    00D00 E001      LDI	R16,1
    00D01 C069      RJMP	0x0D6B
(1154) 						dj->fs->winsect++;
    00D02 89E8      LDD	R30,Y+16
    00D03 89F9      LDD	R31,Y+17
    00D04 8180      LD	R24,Z
    00D05 8191      LDD	R25,Z+1
    00D06 968A      ADIW	R24,0x2A
    00D07 017C      MOVW	R14,R24
    00D08 E041      LDI	R20,1
    00D09 E050      LDI	R21,0
    00D0A E060      LDI	R22,0
    00D0B E070      LDI	R23,0
    00D0C 01FC      MOVW	R30,R24
    00D0D 8020      LD	R2,Z
    00D0E 8031      LDD	R3,Z+1
    00D0F 8042      LDD	R4,Z+2
    00D10 8053      LDD	R5,Z+3
    00D11 0E24      ADD	R2,R20
    00D12 1E35      ADC	R3,R21
    00D13 1E46      ADC	R4,R22
    00D14 1E57      ADC	R5,R23
    00D15 8220      ST	Z,R2
    00D16 8231      STD	Z+1,R3
    00D17 8242      STD	Z+2,R4
    00D18 8253      STD	Z+3,R5
    00D19 94A3      INC	R10
    00D1A 89E8      LDD	R30,Y+16
    00D1B 89F9      LDD	R31,Y+17
    00D1C 93AF      PUSH	R26
    00D1D 93BF      PUSH	R27
    00D1E 81A0      LD	R26,Z
    00D1F 81B1      LDD	R27,Z+1
    00D20 01FD      MOVW	R30,R26
    00D21 91BF      POP	R27
    00D22 91AF      POP	R26
    00D23 8022      LDD	R2,Z+2
    00D24 14A2      CP	R10,R2
    00D25 F408      BCC	0x0D27
    00D26 CFBE      RJMP	0x0CE5
(1155) 					}
(1156) 					dj->fs->winsect -= c;						/* Rewind window address */
    00D27 89E8      LDD	R30,Y+16
    00D28 89F9      LDD	R31,Y+17
    00D29 8180      LD	R24,Z
    00D2A 8191      LDD	R25,Z+1
    00D2B 968A      ADIW	R24,0x2A
    00D2C 017C      MOVW	R14,R24
    00D2D 2C2A      MOV	R2,R10
    00D2E 2433      CLR	R3
    00D2F 2444      CLR	R4
    00D30 2455      CLR	R5
    00D31 01FC      MOVW	R30,R24
    00D32 8060      LD	R6,Z
    00D33 8071      LDD	R7,Z+1
    00D34 8082      LDD	R8,Z+2
    00D35 8093      LDD	R9,Z+3
    00D36 1862      SUB	R6,R2
    00D37 0873      SBC	R7,R3
    00D38 0884      SBC	R8,R4
    00D39 0895      SBC	R9,R5
    00D3A 8260      ST	Z,R6
    00D3B 8271      STD	Z+1,R7
    00D3C 8282      STD	Z+2,R8
    00D3D 8293      STD	Z+3,R9
(1157) #else
(1158) 					return FR_NO_FILE;			/* Report EOT */
(1159) #endif
(1160) 				}
(1161) 				dj->clust = clst;				/* Initialize data for new cluster */
    00D3E 802A      LDD	R2,Y+2
    00D3F 803B      LDD	R3,Y+3
    00D40 804C      LDD	R4,Y+4
    00D41 805D      LDD	R5,Y+5
    00D42 89E8      LDD	R30,Y+16
    00D43 89F9      LDD	R31,Y+17
    00D44 8622      STD	Z+10,R2
    00D45 8633      STD	Z+11,R3
    00D46 8644      STD	Z+12,R4
    00D47 8655      STD	Z+13,R5
(1162) 				dj->sect = clust2sect(dj->fs, clst);
    00D48 8248      ST	Y,R4
    00D49 8259      STD	Y+1,R5
    00D4A 0191      MOVW	R18,R2
    00D4B 8100      LD	R16,Z
    00D4C 8111      LDD	R17,Z+1
    00D4D 940E 04B3 CALL	_clust2sect
    00D4F 89E8      LDD	R30,Y+16
    00D50 89F9      LDD	R31,Y+17
    00D51 8706      STD	Z+14,R16
    00D52 8717      STD	Z+15,R17
    00D53 8B20      STD	Z+16,R18
    00D54 8B31      STD	Z+17,R19
(1163) 			}
(1164) 		}
(1165) 	}
(1166) 
(1167) 	dj->index = i;
    00D55 89E8      LDD	R30,Y+16
    00D56 89F9      LDD	R31,Y+17
    00D57 82D5      STD	Z+5,R13
    00D58 82C4      STD	Z+4,R12
(1168) 	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    00D59 0196      MOVW	R18,R12
    00D5A 702F      ANDI	R18,0xF
    00D5B 7030      ANDI	R19,0
    00D5C E200      LDI	R16,0x20
    00D5D E010      LDI	R17,0
    00D5E 940E 3F10 CALL	empy16s
    00D60 0118      MOVW	R2,R16
    00D61 89E8      LDD	R30,Y+16
    00D62 89F9      LDD	R31,Y+17
    00D63 8180      LD	R24,Z
    00D64 8191      LDD	R25,Z+1
    00D65 968E      ADIW	R24,0x2E
    00D66 0E28      ADD	R2,R24
    00D67 1E39      ADC	R3,R25
    00D68 8A33      STD	Z+19,R3
    00D69 8A22      STD	Z+18,R2
(1169) 
(1170) 	return FR_OK;
    00D6A 2700      CLR	R16
    00D6B 9626      ADIW	R28,6
    00D6C 940E 3F69 CALL	pop_xgsetF0FC
    00D6E 9624      ADIW	R28,4
    00D6F 9508      RET
ff.c:dir_find:
  c                    --> R12
  dir                  --> R10
  res                  --> R20
  dj                   --> R22
    00D70 940E 3FAF CALL	push_xgsetF03C
    00D72 01B8      MOVW	R22,R16
    00D73 9722      SBIW	R28,2
(1171) }
(1172) 
(1173) 
(1174) 
(1175) 
(1176) /*-----------------------------------------------------------------------*/
(1177) /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
(1178) /*-----------------------------------------------------------------------*/
(1179) #if _USE_LFN
(1180) static
(1181) const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
(1182) 
(1183) 
(1184) static
(1185) int cmp_lfn (			/* 1:Matched, 0:Not matched */
(1186) 	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
(1187) 	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
(1188) )
(1189) {
(1190) 	UINT i, s;
(1191) 	WCHAR wc, uc;
(1192) 
(1193) 
(1194) 	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
(1195) 	s = 0; wc = 1;
(1196) 	do {
(1197) 		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
(1198) 		if (wc) {	/* Last char has not been processed */
(1199) 			wc = ff_wtoupper(uc);		/* Convert it to upper case */
(1200) 			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
(1201) 				return 0;				/* Not matched */
(1202) 		} else {
(1203) 			if (uc != 0xFFFF) return 0;	/* Check filler */
(1204) 		}
(1205) 	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
(1206) 
(1207) 	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
(1208) 		return 0;
(1209) 
(1210) 	return 1;						/* The part of LFN matched */
(1211) }
(1212) 
(1213) 
(1214) 
(1215) static
(1216) int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
(1217) 	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
(1218) 	BYTE *dir			/* Pointer to the directory entry */
(1219) )
(1220) {
(1221) 	UINT i, s;
(1222) 	WCHAR wc, uc;
(1223) 
(1224) 
(1225) 	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
(1226) 
(1227) 	s = 0; wc = 1;
(1228) 	do {
(1229) 		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
(1230) 		if (wc) {	/* Last char has not been processed */
(1231) 			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
(1232) 			lfnbuf[i++] = wc = uc;			/* Store it */
(1233) 		} else {
(1234) 			if (uc != 0xFFFF) return 0;		/* Check filler */
(1235) 		}
(1236) 	} while (++s < 13);						/* Read all character in the entry */
(1237) 
(1238) 	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
(1239) 		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
(1240) 		lfnbuf[i] = 0;
(1241) 	}
(1242) 
(1243) 	return 1;
(1244) }
(1245) 
(1246) 
(1247) #if !_FS_READONLY
(1248) static
(1249) void fit_lfn (
(1250) 	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
(1251) 	BYTE *dir,				/* Pointer to the directory entry */
(1252) 	BYTE ord,				/* LFN order (1-20) */
(1253) 	BYTE sum				/* SFN sum */
(1254) )
(1255) {
(1256) 	UINT i, s;
(1257) 	WCHAR wc;
(1258) 
(1259) 
(1260) 	dir[LDIR_Chksum] = sum;			/* Set check sum */
(1261) 	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
(1262) 	dir[LDIR_Type] = 0;
(1263) 	ST_WORD(dir+LDIR_FstClusLO, 0);
(1264) 
(1265) 	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
(1266) 	s = wc = 0;
(1267) 	do {
(1268) 		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
(1269) 		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
(1270) 		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
(1271) 	} while (++s < 13);
(1272) 	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
(1273) 	dir[LDIR_Ord] = ord;			/* Set the LFN order */
(1274) }
(1275) 
(1276) #endif
(1277) #endif
(1278) 
(1279) 
(1280) 
(1281) /*-----------------------------------------------------------------------*/
(1282) /* Create numbered name                                                  */
(1283) /*-----------------------------------------------------------------------*/
(1284) #if _USE_LFN
(1285) void gen_numname (
(1286) 	BYTE *dst,			/* Pointer to generated SFN */
(1287) 	const BYTE *src,	/* Pointer to source SFN to be modified */
(1288) 	const WCHAR *lfn,	/* Pointer to LFN */
(1289) 	WORD seq			/* Sequence number */
(1290) )
(1291) {
(1292) 	BYTE ns[8], c;
(1293) 	UINT i, j;
(1294) 
(1295) 
(1296) 	mem_cpy(dst, src, 11);
(1297) 
(1298) 	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
(1299) 		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
(1300) 	}
(1301) 
(1302) 	/* itoa (hexdecimal) */
(1303) 	i = 7;
(1304) 	do {
(1305) 		c = (seq % 16) + '0';
(1306) 		if (c > '9') c += 7;
(1307) 		ns[i--] = c;
(1308) 		seq /= 16;
(1309) 	} while (seq);
(1310) 	ns[i] = '~';
(1311) 
(1312) 	/* Append the number */
(1313) 	for (j = 0; j < i && dst[j] != ' '; j++) {
(1314) 		if (IsDBCS1(dst[j])) {
(1315) 			if (j == i - 1) break;
(1316) 			j++;
(1317) 		}
(1318) 	}
(1319) 	do {
(1320) 		dst[j++] = (i < 8) ? ns[i++] : ' ';
(1321) 	} while (j < 8);
(1322) }
(1323) #endif
(1324) 
(1325) 
(1326) 
(1327) 
(1328) /*-----------------------------------------------------------------------*/
(1329) /* Calculate sum of an SFN                                               */
(1330) /*-----------------------------------------------------------------------*/
(1331) #if _USE_LFN
(1332) static
(1333) BYTE sum_sfn (
(1334) 	const BYTE *dir		/* Ptr to directory entry */
(1335) )
(1336) {
(1337) 	BYTE sum = 0;
(1338) 	UINT n = 11;
(1339) 
(1340) 	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
(1341) 	return sum;
(1342) }
(1343) #endif
(1344) 
(1345) 
(1346) 
(1347) 
(1348) /*-----------------------------------------------------------------------*/
(1349) /* Directory handling - Find an object in the directory                  */
(1350) /*-----------------------------------------------------------------------*/
(1351) 
(1352) static
(1353) FRESULT dir_find (
(1354) 	DIR *dj			/* Pointer to the directory object linked to the file name */
(1355) )
(1356) {
(1357) 	FRESULT res;
(1358) 	BYTE c, *dir;
(1359) #if _USE_LFN
(1360) 	BYTE a, ord, sum;
(1361) #endif
(1362) 
(1363) 	res = dir_sdi(dj, 0);			/* Rewind directory object */
    00D74 2722      CLR	R18
    00D75 2733      CLR	R19
    00D76 018B      MOVW	R16,R22
    00D77 DD40      RCALL	ff.c:dir_sdi
    00D78 2F40      MOV	R20,R16
(1364) 	if (res != FR_OK) return res;
    00D79 2300      TST	R16
    00D7A F009      BEQ	0x0D7C
    00D7B C036      RJMP	0x0DB2
(1365) 
(1366) #if _USE_LFN
(1367) 	ord = sum = 0xFF;
(1368) #endif
(1369) 	do {
(1370) 		res = move_window(dj->fs, dj->sect);
    00D7C 01FB      MOVW	R30,R22
    00D7D 8426      LDD	R2,Z+14
    00D7E 8437      LDD	R3,Z+15
    00D7F 8840      LDD	R4,Z+16
    00D80 8851      LDD	R5,Z+17
    00D81 8248      ST	Y,R4
    00D82 8259      STD	Y+1,R5
    00D83 0191      MOVW	R18,R2
    00D84 8100      LD	R16,Z
    00D85 8111      LDD	R17,Z+1
    00D86 940E 033C CALL	ff.c:move_window
    00D88 2F40      MOV	R20,R16
(1371) 		if (res != FR_OK) break;
    00D89 2300      TST	R16
    00D8A F009      BEQ	0x0D8C
    00D8B C025      RJMP	0x0DB1
(1372) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00D8C 01FB      MOVW	R30,R22
    00D8D 88A2      LDD	R10,Z+18
    00D8E 88B3      LDD	R11,Z+19
(1373) 		c = dir[DIR_Name];
    00D8F 01F5      MOVW	R30,R10
    00D90 80C0      LD	R12,Z
(1374) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00D91 20CC      TST	R12
    00D92 F411      BNE	0x0D95
    00D93 E044      LDI	R20,4
    00D94 C01C      RJMP	0x0DB1
(1375) #if _USE_LFN	/* LFN configuration */
(1376) 		a = dir[DIR_Attr] & AM_MASK;
(1377) 		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1378) 			ord = 0xFF;
(1379) 		} else {
(1380) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1381) 				if (dj->lfn) {
(1382) 					if (c & LLE) {		/* Is it start of LFN sequence? */
(1383) 						sum = dir[LDIR_Chksum];
(1384) 						c &= ~LLE; ord = c;	/* LFN start order */
(1385) 						dj->lfn_idx = dj->index;
(1386) 					}
(1387) 					/* Check validity of the LFN entry and compare it with given name */
(1388) 					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1389) 				}
(1390) 			} else {					/* An SFN entry is found */
(1391) 				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
(1392) 				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
(1393) 				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
(1394) 			}
(1395) 		}
(1396) #else		/* Non LFN configuration */
(1397) 		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    00D95 01F5      MOVW	R30,R10
    00D96 8423      LDD	R2,Z+11
    00D97 FC23      SBRC	R2,3
    00D98 C00F      RJMP	0x0DA8
    00D99 E08B      LDI	R24,0xB
    00D9A E090      LDI	R25,0
    00D9B 8399      STD	Y+1,R25
    00D9C 8388      ST	Y,R24
    00D9D 01FB      MOVW	R30,R22
    00D9E 8924      LDD	R18,Z+20
    00D9F 8935      LDD	R19,Z+21
    00DA0 0185      MOVW	R16,R10
    00DA1 940E 030B CALL	ff.c:mem_cmp
    00DA3 0158      MOVW	R10,R16
    00DA4 3000      CPI	R16,0
    00DA5 0701      CPC	R16,R17
    00DA6 F409      BNE	0x0DA8
(1398) 			break;
    00DA7 C009      RJMP	0x0DB1
(1399) #endif
(1400) 		res = dir_next(dj, 0);		/* Next entry */
    00DA8 2722      CLR	R18
    00DA9 2733      CLR	R19
    00DAA 018B      MOVW	R16,R22
    00DAB DE16      RCALL	ff.c:dir_next
    00DAC 2EA0      MOV	R10,R16
    00DAD 2D4A      MOV	R20,R10
(1401) 	} while (res == FR_OK);
    00DAE 2344      TST	R20
    00DAF F409      BNE	0x0DB1
    00DB0 CFCB      RJMP	0x0D7C
(1402) 
(1403) 	return res;
    00DB1 2F04      MOV	R16,R20
    00DB2 9622      ADIW	R28,2
    00DB3 940C 3FB8 JMP	pop_xgsetF03C
ff.c:dir_read:
  dir                  --> R10
  c                    --> R12
  res                  --> R20
  dj                   --> R22
    00DB5 940E 3FAF CALL	push_xgsetF03C
    00DB7 01B8      MOVW	R22,R16
    00DB8 9722      SBIW	R28,2
(1404) }
(1405) 
(1406) 
(1407) 
(1408) 
(1409) /*-----------------------------------------------------------------------*/
(1410) /* Read an object from the directory                                     */
(1411) /*-----------------------------------------------------------------------*/
(1412) #if _FS_MINIMIZE <= 1
(1413) static
(1414) FRESULT dir_read (
(1415) 	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
(1416) )
(1417) {
(1418) 	FRESULT res;
(1419) 	BYTE c, *dir;
(1420) #if _USE_LFN
(1421) 	BYTE a, ord = 0xFF, sum = 0xFF;
(1422) #endif
(1423) 
(1424) 	res = FR_NO_FILE;
    00DB9 E044      LDI	R20,4
    00DBA C02B      RJMP	0x0DE6
(1425) 	while (dj->sect) {
(1426) 		res = move_window(dj->fs, dj->sect);
    00DBB 01FB      MOVW	R30,R22
    00DBC 8426      LDD	R2,Z+14
    00DBD 8437      LDD	R3,Z+15
    00DBE 8840      LDD	R4,Z+16
    00DBF 8851      LDD	R5,Z+17
    00DC0 8248      ST	Y,R4
    00DC1 8259      STD	Y+1,R5
    00DC2 0191      MOVW	R18,R2
    00DC3 8100      LD	R16,Z
    00DC4 8111      LDD	R17,Z+1
    00DC5 940E 033C CALL	ff.c:move_window
    00DC7 2F40      MOV	R20,R16
(1427) 		if (res != FR_OK) break;
    00DC8 2300      TST	R16
    00DC9 F009      BEQ	0x0DCB
    00DCA C028      RJMP	0x0DF3
(1428) 		dir = dj->dir;					/* Ptr to the directory entry of current index */
    00DCB 01FB      MOVW	R30,R22
    00DCC 88A2      LDD	R10,Z+18
    00DCD 88B3      LDD	R11,Z+19
(1429) 		c = dir[DIR_Name];
    00DCE 01F5      MOVW	R30,R10
    00DCF 80C0      LD	R12,Z
(1430) 		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    00DD0 20CC      TST	R12
    00DD1 F411      BNE	0x0DD4
    00DD2 E044      LDI	R20,4
    00DD3 C01F      RJMP	0x0DF3
(1431) #if _USE_LFN	/* LFN configuration */
(1432) 		a = dir[DIR_Attr] & AM_MASK;
(1433) 		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
(1434) 			ord = 0xFF;
(1435) 		} else {
(1436) 			if (a == AM_LFN) {			/* An LFN entry is found */
(1437) 				if (c & LLE) {			/* Is it start of LFN sequence? */
(1438) 					sum = dir[LDIR_Chksum];
(1439) 					c &= ~LLE; ord = c;
(1440) 					dj->lfn_idx = dj->index;
(1441) 				}
(1442) 				/* Check LFN validity and capture it */
(1443) 				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
(1444) 			} else {					/* An SFN entry is found */
(1445) 				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
(1446) 					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
(1447) 				break;
(1448) 			}
(1449) 		}
(1450) #else		/* Non LFN configuration */
(1451) 		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
    00DD4 2D8C      MOV	R24,R12
    00DD5 3E85      CPI	R24,0xE5
    00DD6 F039      BEQ	0x0DDE
    00DD7 328E      CPI	R24,0x2E
    00DD8 F029      BEQ	0x0DDE
    00DD9 01F5      MOVW	R30,R10
    00DDA 8423      LDD	R2,Z+11
    00DDB FC23      SBRC	R2,3
    00DDC C001      RJMP	0x0DDE
(1452) 			break;
    00DDD C015      RJMP	0x0DF3
(1453) #endif
(1454) 		res = dir_next(dj, 0);				/* Next entry */
    00DDE 2722      CLR	R18
    00DDF 2733      CLR	R19
    00DE0 018B      MOVW	R16,R22
    00DE1 DDE0      RCALL	ff.c:dir_next
    00DE2 2F40      MOV	R20,R16
(1455) 		if (res != FR_OK) break;
    00DE3 2300      TST	R16
    00DE4 F009      BEQ	0x0DE6
    00DE5 C00D      RJMP	0x0DF3
    00DE6 01FB      MOVW	R30,R22
    00DE7 963E      ADIW	R30,0xE
    00DE8 8020      LD	R2,Z
    00DE9 8031      LDD	R3,Z+1
    00DEA 8042      LDD	R4,Z+2
    00DEB 8053      LDD	R5,Z+3
    00DEC 9488      BCLR	0
    00DED 2022      TST	R2
    00DEE 0432      CPC	R3,R2
    00DEF 0442      CPC	R4,R2
    00DF0 0452      CPC	R5,R2
    00DF1 F009      BEQ	0x0DF3
    00DF2 CFC8      RJMP	0x0DBB
(1456) 	}
(1457) 
(1458) 	if (res != FR_OK) dj->sect = 0;
    00DF3 2344      TST	R20
    00DF4 F039      BEQ	0x0DFC
    00DF5 01FB      MOVW	R30,R22
    00DF6 963E      ADIW	R30,0xE
    00DF7 E080      LDI	R24,0
    00DF8 8380      ST	Z,R24
    00DF9 8381      STD	Z+1,R24
    00DFA 8382      STD	Z+2,R24
    00DFB 8383      STD	Z+3,R24
(1459) 
(1460) 	return res;
    00DFC 2F04      MOV	R16,R20
    00DFD 9622      ADIW	R28,2
    00DFE 940C 3FB8 JMP	pop_xgsetF03C
ff.c:dir_register:
  dir                  --> R12
  c                    --> R22
  res                  --> R10
  dj                   --> R20
    00E00 940E 3FAF CALL	push_xgsetF03C
    00E02 01A8      MOVW	R20,R16
    00E03 9722      SBIW	R28,2
(1461) }
(1462) #endif
(1463) 
(1464) 
(1465) 
(1466) /*-----------------------------------------------------------------------*/
(1467) /* Register an object to the directory                                   */
(1468) /*-----------------------------------------------------------------------*/
(1469) #if !_FS_READONLY
(1470) static
(1471) FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
(1472) 	DIR *dj				/* Target directory with object name to be created */
(1473) )
(1474) {
(1475) 	FRESULT res;
(1476) 	BYTE c, *dir;
(1477) #if _USE_LFN	/* LFN configuration */
(1478) 	WORD n, ne, is;
(1479) 	BYTE sn[12], *fn, sum;
(1480) 	WCHAR *lfn;
(1481) 
(1482) 
(1483) 	fn = dj->fn; lfn = dj->lfn;
(1484) 	mem_cpy(sn, fn, 12);
(1485) 
(1486) 	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
(1487) 		return FR_INVALID_NAME;
(1488) 
(1489) 	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
(1490) 		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
(1491) 		for (n = 1; n < 100; n++) {
(1492) 			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
(1493) 			res = dir_find(dj);				/* Check if the name collides with existing SFN */
(1494) 			if (res != FR_OK) break;
(1495) 		}
(1496) 		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
(1497) 		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
(1498) 		fn[NS] = sn[NS]; dj->lfn = lfn;
(1499) 	}
(1500) 
(1501) 	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
(1502) 		for (ne = 0; lfn[ne]; ne++) ;
(1503) 		ne = (ne + 25) / 13;
(1504) 	} else {						/* Otherwise reserve only an SFN entry. */
(1505) 		ne = 1;
(1506) 	}
(1507) 
(1508) 	/* Reserve contiguous entries */
(1509) 	res = dir_sdi(dj, 0);
(1510) 	if (res != FR_OK) return res;
(1511) 	n = is = 0;
(1512) 	do {
(1513) 		res = move_window(dj->fs, dj->sect);
(1514) 		if (res != FR_OK) break;
(1515) 		c = *dj->dir;				/* Check the entry status */
(1516) 		if (c == DDE || c == 0) {	/* Is it a blank entry? */
(1517) 			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
(1518) 			if (++n == ne) break;	/* A contiguous entry that required count is found */
(1519) 		} else {
(1520) 			n = 0;					/* Not a blank entry. Restart to search */
(1521) 		}
(1522) 		res = dir_next(dj, 1);		/* Next entry with table stretch */
(1523) 	} while (res == FR_OK);
(1524) 
(1525) 	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
(1526) 		res = dir_sdi(dj, is);
(1527) 		if (res == FR_OK) {
(1528) 			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
(1529) 			ne--;
(1530) 			do {					/* Store LFN entries in bottom first */
(1531) 				res = move_window(dj->fs, dj->sect);
(1532) 				if (res != FR_OK) break;
(1533) 				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
(1534) 				dj->fs->wflag = 1;
(1535) 				res = dir_next(dj, 0);	/* Next entry */
(1536) 			} while (res == FR_OK && --ne);
(1537) 		}
(1538) 	}
(1539) 
(1540) #else	/* Non LFN configuration */
(1541) 	res = dir_sdi(dj, 0);
    00E04 2722      CLR	R18
    00E05 2733      CLR	R19
    00E06 018A      MOVW	R16,R20
    00E07 DCB0      RCALL	ff.c:dir_sdi
    00E08 2EA0      MOV	R10,R16
(1542) 	if (res == FR_OK) {
    00E09 2300      TST	R16
    00E0A F509      BNE	0x0E2C
(1543) 		do {	/* Find a blank entry for the SFN */
(1544) 			res = move_window(dj->fs, dj->sect);
    00E0B 01FA      MOVW	R30,R20
    00E0C 8426      LDD	R2,Z+14
    00E0D 8437      LDD	R3,Z+15
    00E0E 8840      LDD	R4,Z+16
    00E0F 8851      LDD	R5,Z+17
    00E10 8248      ST	Y,R4
    00E11 8259      STD	Y+1,R5
    00E12 0191      MOVW	R18,R2
    00E13 8100      LD	R16,Z
    00E14 8111      LDD	R17,Z+1
    00E15 940E 033C CALL	ff.c:move_window
    00E17 2EA0      MOV	R10,R16
(1545) 			if (res != FR_OK) break;
    00E18 2300      TST	R16
    00E19 F009      BEQ	0x0E1B
    00E1A C011      RJMP	0x0E2C
(1546) 			c = *dj->dir;
    00E1B 01FA      MOVW	R30,R20
    00E1C 89A2      LDD	R26,Z+18
    00E1D 89B3      LDD	R27,Z+19
    00E1E 916C      LD	R22,X
(1547) 			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
    00E1F 3E65      CPI	R22,0xE5
    00E20 F011      BEQ	0x0E23
    00E21 2366      TST	R22
    00E22 F409      BNE	0x0E24
    00E23 C008      RJMP	0x0E2C
(1548) 			res = dir_next(dj, 1);			/* Next entry with table stretch */
    00E24 E021      LDI	R18,1
    00E25 E030      LDI	R19,0
    00E26 018A      MOVW	R16,R20
    00E27 DD9A      RCALL	ff.c:dir_next
    00E28 2EC0      MOV	R12,R16
    00E29 2CAC      MOV	R10,R12
(1549) 		} while (res == FR_OK);
    00E2A 20AA      TST	R10
    00E2B F2F9      BEQ	0x0E0B
(1550) 	}
(1551) #endif
(1552) 
(1553) 	if (res == FR_OK) {		/* Initialize the SFN entry */
    00E2C 20AA      TST	R10
    00E2D F009      BEQ	0x0E2F
    00E2E C030      RJMP	0x0E5F
(1554) 		res = move_window(dj->fs, dj->sect);
    00E2F 01FA      MOVW	R30,R20
    00E30 8426      LDD	R2,Z+14
    00E31 8437      LDD	R3,Z+15
    00E32 8840      LDD	R4,Z+16
    00E33 8851      LDD	R5,Z+17
    00E34 8248      ST	Y,R4
    00E35 8259      STD	Y+1,R5
    00E36 0191      MOVW	R18,R2
    00E37 8100      LD	R16,Z
    00E38 8111      LDD	R17,Z+1
    00E39 940E 033C CALL	ff.c:move_window
    00E3B 2EC0      MOV	R12,R16
    00E3C 2CAC      MOV	R10,R12
(1555) 		if (res == FR_OK) {
    00E3D 2300      TST	R16
    00E3E F501      BNE	0x0E5F
(1556) 			dir = dj->dir;
    00E3F 01FA      MOVW	R30,R20
    00E40 88C2      LDD	R12,Z+18
    00E41 88D3      LDD	R13,Z+19
(1557) 			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
    00E42 E280      LDI	R24,0x20
    00E43 E090      LDI	R25,0
    00E44 8399      STD	Y+1,R25
    00E45 8388      ST	Y,R24
    00E46 2722      CLR	R18
    00E47 2733      CLR	R19
    00E48 0186      MOVW	R16,R12
    00E49 940E 02F9 CALL	ff.c:mem_set
(1558) 			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
    00E4B E08B      LDI	R24,0xB
    00E4C E090      LDI	R25,0
    00E4D 8399      STD	Y+1,R25
    00E4E 8388      ST	Y,R24
    00E4F 01FA      MOVW	R30,R20
    00E50 8924      LDD	R18,Z+20
    00E51 8935      LDD	R19,Z+21
    00E52 0186      MOVW	R16,R12
    00E53 940E 02E3 CALL	ff.c:mem_cpy
(1559) #if _USE_LFN
(1560) 			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
(1561) #endif
(1562) 			dj->fs->wflag = 1;
    00E55 E081      LDI	R24,1
    00E56 01FA      MOVW	R30,R20
    00E57 93AF      PUSH	R26
    00E58 93BF      PUSH	R27
    00E59 81A0      LD	R26,Z
    00E5A 81B1      LDD	R27,Z+1
    00E5B 01FD      MOVW	R30,R26
    00E5C 91BF      POP	R27
    00E5D 91AF      POP	R26
    00E5E 8384      STD	Z+4,R24
(1563) 		}
(1564) 	}
(1565) 
(1566) 	return res;
    00E5F 2D0A      MOV	R16,R10
    00E60 9622      ADIW	R28,2
    00E61 940C 3FB8 JMP	pop_xgsetF03C
ff.c:create_name:
  si                   --> R22
  b                    --> Y,+8
  sfn                  --> Y,+6
  ni                   --> R12
  d                    --> R10
  i                    --> Y,+4
  p                    --> Y,+2
  c                    --> R20
  path                 --> Y,+19
  dj                   --> R20
    00E63 933A      ST	-Y,R19
    00E64 932A      ST	-Y,R18
    00E65 940E 3F74 CALL	push_xgsetF0FC
    00E67 01A8      MOVW	R20,R16
    00E68 9729      SBIW	R28,0x9
(1567) }
(1568) #endif /* !_FS_READONLY */
(1569) 
(1570) 
(1571) 
(1572) 
(1573) /*-----------------------------------------------------------------------*/
(1574) /* Remove an object from the directory                                   */
(1575) /*-----------------------------------------------------------------------*/
(1576) #if !_FS_READONLY && !_FS_MINIMIZE
(1577) static
(1578) FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
(1579) 	DIR *dj				/* Directory object pointing the entry to be removed */
(1580) )
(1581) {
(1582) 	FRESULT res;
(1583) #if _USE_LFN	/* LFN configuration */
(1584) 	WORD i;
(1585) 
(1586) 	i = dj->index;	/* SFN index */
(1587) 	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
(1588) 	if (res == FR_OK) {
(1589) 		do {
(1590) 			res = move_window(dj->fs, dj->sect);
(1591) 			if (res != FR_OK) break;
(1592) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1593) 			dj->fs->wflag = 1;
(1594) 			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
(1595) 			res = dir_next(dj, 0);		/* Next entry */
(1596) 		} while (res == FR_OK);
(1597) 		if (res == FR_NO_FILE) res = FR_INT_ERR;
(1598) 	}
(1599) 
(1600) #else			/* Non LFN configuration */
(1601) 	res = dir_sdi(dj, dj->index);
(1602) 	if (res == FR_OK) {
(1603) 		res = move_window(dj->fs, dj->sect);
(1604) 		if (res == FR_OK) {
(1605) 			*dj->dir = DDE;			/* Mark the entry "deleted" */
(1606) 			dj->fs->wflag = 1;
(1607) 		}
(1608) 	}
(1609) #endif
(1610) 
(1611) 	return res;
(1612) }
(1613) #endif /* !_FS_READONLY */
(1614) 
(1615) 
(1616) 
(1617) 
(1618) /*-----------------------------------------------------------------------*/
(1619) /* Pick a segment and create the object name in directory form           */
(1620) /*-----------------------------------------------------------------------*/
(1621) 
(1622) static
(1623) FRESULT create_name (
(1624) 	DIR *dj,			/* Pointer to the directory object */
(1625) 	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
(1626) )
(1627) {
(1628) #ifdef _EXCVT
(1629) 	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
(1630) #endif
(1631) 
(1632) #if _USE_LFN	/* LFN configuration */
(1633) 	BYTE b, cf;
(1634) 	WCHAR w, *lfn;
(1635) 	UINT i, ni, si, di;
(1636) 	const TCHAR *p;
(1637) 
(1638) 	/* Create LFN in Unicode */
(1639) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
(1640) 	lfn = dj->lfn;
(1641) 	si = di = 0;
(1642) 	for (;;) {
(1643) 		w = p[si++];					/* Get a character */
(1644) 		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
(1645) 		if (di >= _MAX_LFN)				/* Reject too long name */
(1646) 			return FR_INVALID_NAME;
(1647) #if !_LFN_UNICODE
(1648) 		w &= 0xFF;
(1649) 		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
(1650) 			b = (BYTE)p[si++];			/* Get 2nd byte */
(1651) 			if (!IsDBCS2(b))
(1652) 				return FR_INVALID_NAME;	/* Reject invalid sequence */
(1653) 			w = (w << 8) + b;			/* Create a DBC */
(1654) 		}
(1655) 		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
(1656) 		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
(1657) #endif
(1658) 		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
(1659) 			return FR_INVALID_NAME;
(1660) 		lfn[di++] = w;					/* Store the Unicode char */
(1661) 	}
(1662) 	*path = &p[si];						/* Return pointer to the next segment */
(1663) 	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
(1664) #if _FS_RPATH
(1665) 	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
(1666) 		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
(1667) 		lfn[di] = 0;
(1668) 		for (i = 0; i < 11; i++)
(1669) 			dj->fn[i] = (i < di) ? '.' : ' ';
(1670) 		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
(1671) 		return FR_OK;
(1672) 	}
(1673) #endif
(1674) 	while (di) {						/* Strip trailing spaces and dots */
(1675) 		w = lfn[di-1];
(1676) 		if (w != ' ' && w != '.') break;
(1677) 		di--;
(1678) 	}
(1679) 	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
(1680) 
(1681) 	lfn[di] = 0;						/* LFN is created */
(1682) 
(1683) 	/* Create SFN in directory form */
(1684) 	mem_set(dj->fn, ' ', 11);
(1685) 	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
(1686) 	if (si) cf |= NS_LOSS | NS_LFN;
(1687) 	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
(1688) 
(1689) 	b = i = 0; ni = 8;
(1690) 	for (;;) {
(1691) 		w = lfn[si++];					/* Get an LFN char */
(1692) 		if (!w) break;					/* Break on end of the LFN */
(1693) 		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
(1694) 			cf |= NS_LOSS | NS_LFN; continue;
(1695) 		}
(1696) 
(1697) 		if (i >= ni || si == di) {		/* Extension or end of SFN */
(1698) 			if (ni == 11) {				/* Long extension */
(1699) 				cf |= NS_LOSS | NS_LFN; break;
(1700) 			}
(1701) 			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
(1702) 			if (si > di) break;			/* No extension */
(1703) 			si = di; i = 8; ni = 11;	/* Enter extension section */
(1704) 			b <<= 2; continue;
(1705) 		}
(1706) 
(1707) 		if (w >= 0x80) {				/* Non ASCII char */
(1708) #ifdef _EXCVT
(1709) 			w = ff_convert(w, 0);		/* Unicode -> OEM code */
(1710) 			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
(1711) #else
(1712) 			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
(1713) #endif
(1714) 			cf |= NS_LFN;				/* Force create LFN entry */
(1715) 		}
(1716) 
(1717) 		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
(1718) 			if (i >= ni - 1) {
(1719) 				cf |= NS_LOSS | NS_LFN; i = ni; continue;
(1720) 			}
(1721) 			dj->fn[i++] = (BYTE)(w >> 8);
(1722) 		} else {						/* Single byte char */
(1723) 			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
(1724) 				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
(1725) 			} else {
(1726) 				if (IsUpper(w)) {		/* ASCII large capital */
(1727) 					b |= 2;
(1728) 				} else {
(1729) 					if (IsLower(w)) {	/* ASCII small capital */
(1730) 						b |= 1; w -= 0x20;
(1731) 					}
(1732) 				}
(1733) 			}
(1734) 		}
(1735) 		dj->fn[i++] = (BYTE)w;
(1736) 	}
(1737) 
(1738) 	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
(1739) 
(1740) 	if (ni == 8) b <<= 2;
(1741) 	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
(1742) 		cf |= NS_LFN;
(1743) 	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
(1744) 		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
(1745) 		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
(1746) 	}
(1747) 
(1748) 	dj->fn[NS] = cf;	/* SFN is created */
(1749) 
(1750) 	return FR_OK;
(1751) 
(1752) 
(1753) #else	/* Non-LFN configuration */
(1754) 	BYTE b, c, d, *sfn;
(1755) 	UINT ni, si, i;
(1756) 	const char *p;
(1757) 
(1758) 	/* Create file name in directory form */
(1759) 	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    00E69 89EB      LDD	R30,Y+19
    00E6A 89FC      LDD	R31,Y+20
    00E6B 8020      LD	R2,Z
    00E6C 8031      LDD	R3,Z+1
    00E6D 823B      STD	Y+3,R3
    00E6E 822A      STD	Y+2,R2
    00E6F C005      RJMP	0x0E75
    00E70 818A      LDD	R24,Y+2
    00E71 819B      LDD	R25,Y+3
    00E72 9601      ADIW	R24,1
    00E73 839B      STD	Y+3,R25
    00E74 838A      STD	Y+2,R24
    00E75 81EA      LDD	R30,Y+2
    00E76 81FB      LDD	R31,Y+3
    00E77 8020      LD	R2,Z
    00E78 2433      CLR	R3
    00E79 2D82      MOV	R24,R2
    00E7A 328F      CPI	R24,0x2F
    00E7B F3A1      BEQ	0x0E70
    00E7C 358C      CPI	R24,0x5C
    00E7D F391      BEQ	0x0E70
(1760) 	sfn = dj->fn;
    00E7E 01FA      MOVW	R30,R20
    00E7F 8824      LDD	R2,Z+20
    00E80 8835      LDD	R3,Z+21
    00E81 823F      STD	Y+7,R3
    00E82 822E      STD	Y+6,R2
(1761) 	mem_set(sfn, ' ', 11);
    00E83 E08B      LDI	R24,0xB
    00E84 E090      LDI	R25,0
    00E85 8399      STD	Y+1,R25
    00E86 8388      ST	Y,R24
    00E87 E220      LDI	R18,0x20
    00E88 E030      LDI	R19,0
    00E89 0181      MOVW	R16,R2
    00E8A 940E 02F9 CALL	ff.c:mem_set
(1762) 	si = i = b = 0; ni = 8;
    00E8C 2400      CLR	R0
    00E8D 8608      STD	Y+8,R0
    00E8E 2422      CLR	R2
    00E8F 2433      CLR	R3
    00E90 823D      STD	Y+5,R3
    00E91 822C      STD	Y+4,R2
    00E92 01B1      MOVW	R22,R2
    00E93 E088      LDI	R24,0x8
    00E94 E090      LDI	R25,0
    00E95 016C      MOVW	R12,R24
(1763) #if _FS_RPATH
(1764) 	if (p[si] == '.') { /* Is this a dot entry? */
(1765) 		for (;;) {
(1766) 			c = (BYTE)p[si++];
(1767) 			if (c != '.' || si >= 3) break;
(1768) 			sfn[i++] = c;
(1769) 		}
(1770) 		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
(1771) 		*path = &p[si];									/* Return pointer to the next segment */
(1772) 		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
(1773) 		return FR_OK;
(1774) 	}
(1775) #endif
(1776) 	for (;;) {
(1777) 		c = (BYTE)p[si++];
    00E96 01AB      MOVW	R20,R22
    00E97 5F6F      SUBI	R22,0xFF
    00E98 4F7F      SBCI	R23,0xFF
    00E99 01FA      MOVW	R30,R20
    00E9A 800A      LDD	R0,Y+2
    00E9B 801B      LDD	R1,Y+3
    00E9C 0DE0      ADD	R30,R0
    00E9D 1DF1      ADC	R31,R1
    00E9E 8140      LD	R20,Z
(1778) 		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    00E9F E280      LDI	R24,0x20
    00EA0 1784      CP	R24,R20
    00EA1 F420      BCC	0x0EA6
    00EA2 324F      CPI	R20,0x2F
    00EA3 F011      BEQ	0x0EA6
    00EA4 354C      CPI	R20,0x5C
    00EA5 F409      BNE	0x0EA7
    00EA6 C087      RJMP	0x0F2E
(1779) 		if (c == '.' || i >= ni) {
    00EA7 324E      CPI	R20,0x2E
    00EA8 F029      BEQ	0x0EAE
    00EA9 800C      LDD	R0,Y+4
    00EAA 801D      LDD	R1,Y+5
    00EAB 140C      CP	R0,R12
    00EAC 041D      CPC	R1,R13
    00EAD F0A0      BCS	0x0EC2
(1780) 			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    00EAE 01C6      MOVW	R24,R12
    00EAF 3088      CPI	R24,0x8
    00EB0 E0E0      LDI	R30,0
    00EB1 079E      CPC	R25,R30
    00EB2 F411      BNE	0x0EB5
    00EB3 324E      CPI	R20,0x2E
    00EB4 F011      BEQ	0x0EB7
    00EB5 E006      LDI	R16,6
    00EB6 C0AF      RJMP	0x0F66
(1781) 			i = 8; ni = 11;
    00EB7 E088      LDI	R24,0x8
    00EB8 E090      LDI	R25,0
    00EB9 839D      STD	Y+5,R25
    00EBA 838C      STD	Y+4,R24
    00EBB E08B      LDI	R24,0xB
    00EBC 016C      MOVW	R12,R24
(1782) 			b <<= 2; continue;
    00EBD 8408      LDD	R0,Y+8
    00EBE 0C00      LSL	R0
    00EBF 0C00      LSL	R0
    00EC0 8608      STD	Y+8,R0
    00EC1 CFD4      RJMP	0x0E96
(1783) 		}
(1784) 		if (c >= 0x80) {				/* Extended char? */
    00EC2 3840      CPI	R20,0x80
    00EC3 F018      BCS	0x0EC7
(1785) 			b |= 3;						/* Eliminate NT flag */
    00EC4 8588      LDD	R24,Y+8
    00EC5 6083      ORI	R24,3
    00EC6 8788      STD	Y+8,R24
(1786) #ifdef _EXCVT
(1787) 			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
(1788) #else
(1789) #if !_DF1S	/* ASCII only cfg */
(1790) 			return FR_INVALID_NAME;
(1791) #endif
(1792) #endif
(1793) 		}
(1794) 		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    00EC7 3841      CPI	R20,0x81
    00EC8 F408      BCC	0x0ECA
    00EC9 C039      RJMP	0x0F03
    00ECA EF8E      LDI	R24,0xFE
    00ECB 1784      CP	R24,R20
    00ECC F408      BCC	0x0ECE
    00ECD C035      RJMP	0x0F03
(1795) 			d = (BYTE)p[si++];			/* Get 2nd byte */
    00ECE 015B      MOVW	R10,R22
    00ECF 5F6F      SUBI	R22,0xFF
    00ED0 4F7F      SBCI	R23,0xFF
    00ED1 01F5      MOVW	R30,R10
    00ED2 800A      LDD	R0,Y+2
    00ED3 801B      LDD	R1,Y+3
    00ED4 0DE0      ADD	R30,R0
    00ED5 1DF1      ADC	R31,R1
    00ED6 80A0      LD	R10,Z
(1796) 			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    00ED7 2D8A      MOV	R24,R10
    00ED8 3480      CPI	R24,0x40
    00ED9 F018      BCS	0x0EDD
    00EDA E78E      LDI	R24,0x7E
    00EDB 158A      CP	R24,R10
    00EDC F430      BCC	0x0EE3
    00EDD 2D8A      MOV	R24,R10
    00EDE 3880      CPI	R24,0x80
    00EDF F050      BCS	0x0EEA
    00EE0 EF8E      LDI	R24,0xFE
    00EE1 158A      CP	R24,R10
    00EE2 F038      BCS	0x0EEA
    00EE3 01C6      MOVW	R24,R12
    00EE4 9701      SBIW	R24,1
    00EE5 800C      LDD	R0,Y+4
    00EE6 801D      LDD	R1,Y+5
    00EE7 1608      CP	R0,R24
    00EE8 0619      CPC	R1,R25
    00EE9 F010      BCS	0x0EEC
(1797) 				return FR_INVALID_NAME;
    00EEA E006      LDI	R16,6
    00EEB C07A      RJMP	0x0F66
(1798) 			sfn[i++] = c;
    00EEC 80EC      LDD	R14,Y+4
    00EED 80FD      LDD	R15,Y+5
    00EEE 01C7      MOVW	R24,R14
    00EEF 9601      ADIW	R24,1
    00EF0 839D      STD	Y+5,R25
    00EF1 838C      STD	Y+4,R24
    00EF2 01F7      MOVW	R30,R14
    00EF3 800E      LDD	R0,Y+6
    00EF4 801F      LDD	R1,Y+7
    00EF5 0DE0      ADD	R30,R0
    00EF6 1DF1      ADC	R31,R1
    00EF7 8340      ST	Z,R20
(1799) 			sfn[i++] = d;
    00EF8 017C      MOVW	R14,R24
    00EF9 9601      ADIW	R24,1
    00EFA 839D      STD	Y+5,R25
    00EFB 838C      STD	Y+4,R24
    00EFC 01F7      MOVW	R30,R14
    00EFD 800E      LDD	R0,Y+6
    00EFE 801F      LDD	R1,Y+7
    00EFF 0DE0      ADD	R30,R0
    00F00 1DF1      ADC	R31,R1
    00F01 82A0      ST	Z,R10
(1800) 		} else {						/* Single byte code */
    00F02 CF93      RJMP	0x0E96
(1801) 			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    00F03 2F24      MOV	R18,R20
    00F04 2733      CLR	R19
    00F05 E000      LDI	R16,0
    00F06 E011      LDI	R17,1
    00F07 940E 032C CALL	ff.c:chk_chr
    00F09 0158      MOVW	R10,R16
    00F0A 3000      CPI	R16,0
    00F0B 0701      CPC	R16,R17
    00F0C F011      BEQ	0x0F0F
(1802) 				return FR_INVALID_NAME;
    00F0D E006      LDI	R16,6
    00F0E C057      RJMP	0x0F66
(1803) 			if (IsUpper(c)) {			/* ASCII large capital? */
    00F0F 3441      CPI	R20,0x41
    00F10 F038      BCS	0x0F18
    00F11 E58A      LDI	R24,0x5A
    00F12 1784      CP	R24,R20
    00F13 F020      BCS	0x0F18
(1804) 				b |= 2;
    00F14 8588      LDD	R24,Y+8
    00F15 6082      ORI	R24,2
    00F16 8788      STD	Y+8,R24
(1805) 			} else {
    00F17 C009      RJMP	0x0F21
(1806) 				if (IsLower(c)) {		/* ASCII small capital? */
    00F18 3641      CPI	R20,0x61
    00F19 F038      BCS	0x0F21
    00F1A E78A      LDI	R24,0x7A
    00F1B 1784      CP	R24,R20
    00F1C F020      BCS	0x0F21
(1807) 					b |= 1; c -= 0x20;
    00F1D 8588      LDD	R24,Y+8
    00F1E 6081      ORI	R24,1
    00F1F 8788      STD	Y+8,R24
    00F20 5240      SUBI	R20,0x20
(1808) 				}
(1809) 			}
(1810) 			sfn[i++] = c;
    00F21 80AC      LDD	R10,Y+4
    00F22 80BD      LDD	R11,Y+5
    00F23 01C5      MOVW	R24,R10
    00F24 9601      ADIW	R24,1
    00F25 839D      STD	Y+5,R25
    00F26 838C      STD	Y+4,R24
    00F27 01F5      MOVW	R30,R10
    00F28 800E      LDD	R0,Y+6
    00F29 801F      LDD	R1,Y+7
    00F2A 0DE0      ADD	R30,R0
    00F2B 1DF1      ADC	R31,R1
    00F2C 8340      ST	Z,R20
    00F2D CF68      RJMP	0x0E96
(1811) 		}
(1812) 	}
(1813) 	*path = &p[si];						/* Return pointer to the next segment */
    00F2E 011B      MOVW	R2,R22
    00F2F 800A      LDD	R0,Y+2
    00F30 801B      LDD	R1,Y+3
    00F31 0C20      ADD	R2,R0
    00F32 1C31      ADC	R3,R1
    00F33 89EB      LDD	R30,Y+19
    00F34 89FC      LDD	R31,Y+20
    00F35 8231      STD	Z+1,R3
    00F36 8220      ST	Z,R2
(1814) 	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    00F37 E280      LDI	R24,0x20
    00F38 1784      CP	R24,R20
    00F39 F018      BCS	0x0F3D
    00F3A E064      LDI	R22,4
    00F3B E070      LDI	R23,0
    00F3C C002      RJMP	0x0F3F
    00F3D 2766      CLR	R22
    00F3E 2777      CLR	R23
    00F3F 2F46      MOV	R20,R22
(1815) 
(1816) 	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    00F40 800C      LDD	R0,Y+4
    00F41 801D      LDD	R1,Y+5
    00F42 2000      TST	R0
    00F43 F421      BNE	0x0F48
    00F44 2011      TST	R1
    00F45 F411      BNE	0x0F48
    00F46 E006      LDI	R16,6
    00F47 C01E      RJMP	0x0F66
(1817) 	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    00F48 81EE      LDD	R30,Y+6
    00F49 81FF      LDD	R31,Y+7
    00F4A 8180      LD	R24,Z
    00F4B 3E85      CPI	R24,0xE5
    00F4C F411      BNE	0x0F4F
    00F4D E085      LDI	R24,5
    00F4E 8380      ST	Z,R24
(1818) 
(1819) 	if (ni == 8) b <<= 2;
    00F4F 01C6      MOVW	R24,R12
    00F50 3088      CPI	R24,0x8
    00F51 E0E0      LDI	R30,0
    00F52 079E      CPC	R25,R30
    00F53 F421      BNE	0x0F58
    00F54 8408      LDD	R0,Y+8
    00F55 0C00      LSL	R0
    00F56 0C00      LSL	R0
    00F57 8608      STD	Y+8,R0
(1820) 	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    00F58 8588      LDD	R24,Y+8
    00F59 7083      ANDI	R24,3
    00F5A 3081      CPI	R24,1
    00F5B F409      BNE	0x0F5D
    00F5C 6140      ORI	R20,0x10
(1821) 	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    00F5D 8588      LDD	R24,Y+8
    00F5E 708C      ANDI	R24,0xC
    00F5F 3084      CPI	R24,4
    00F60 F409      BNE	0x0F62
    00F61 6048      ORI	R20,0x8
(1822) 
(1823) 	sfn[NS] = c;		/* Store NT flag, File name is created */
    00F62 81EE      LDD	R30,Y+6
    00F63 81FF      LDD	R31,Y+7
    00F64 8743      STD	Z+11,R20
(1824) 
(1825) 	return FR_OK;
    00F65 2700      CLR	R16
    00F66 9629      ADIW	R28,0x9
    00F67 940E 3F69 CALL	pop_xgsetF0FC
    00F69 9622      ADIW	R28,2
    00F6A 9508      RET
ff.c:get_fileinfo:
  nt                   --> R12
  p                    --> R20
  dir                  --> R10
  i                    --> R12
  c                    --> R14
  fno                  --> R22
  dj                   --> R10
    00F6B 940E 3F74 CALL	push_xgsetF0FC
    00F6D 01B9      MOVW	R22,R18
    00F6E 0158      MOVW	R10,R16
(1826) #endif
(1827) }
(1828) 
(1829) 
(1830) 
(1831) 
(1832) /*-----------------------------------------------------------------------*/
(1833) /* Get file information from directory entry                             */
(1834) /*-----------------------------------------------------------------------*/
(1835) #if _FS_MINIMIZE <= 1
(1836) static
(1837) void get_fileinfo (		/* No return code */
(1838) 	DIR *dj,			/* Pointer to the directory object */
(1839) 	FILINFO *fno	 	/* Pointer to the file information to be filled */
(1840) )
(1841) {
(1842) 	UINT i;
(1843) 	BYTE nt, *dir;
(1844) 	TCHAR *p, c;
(1845) 
(1846) 
(1847) 	p = fno->fname;
    00F6F 01AB      MOVW	R20,R22
    00F70 5F47      SUBI	R20,0xF7
    00F71 4F5F      SBCI	R21,0xFF
(1848) 	if (dj->sect) {
    00F72 01F5      MOVW	R30,R10
    00F73 963E      ADIW	R30,0xE
    00F74 8020      LD	R2,Z
    00F75 8031      LDD	R3,Z+1
    00F76 8042      LDD	R4,Z+2
    00F77 8053      LDD	R5,Z+3
    00F78 9488      BCLR	0
    00F79 2022      TST	R2
    00F7A 0432      CPC	R3,R2
    00F7B 0442      CPC	R4,R2
    00F7C 0452      CPC	R5,R2
    00F7D F409      BNE	0x0F7F
    00F7E C08A      RJMP	0x1009
(1849) 		dir = dj->dir;
    00F7F 01F5      MOVW	R30,R10
    00F80 88A2      LDD	R10,Z+18
    00F81 88B3      LDD	R11,Z+19
(1850) 		nt = dir[DIR_NTres];		/* NT flag */
(1851) 		for (i = 0; i < 8; i++) {	/* Copy name body */
    00F82 24CC      CLR	R12
    00F83 24DD      CLR	R13
    00F84 C014      RJMP	0x0F99
(1852) 			c = dir[i];
    00F85 01F6      MOVW	R30,R12
    00F86 0DEA      ADD	R30,R10
    00F87 1DFB      ADC	R31,R11
    00F88 80E0      LD	R14,Z
(1853) 			if (c == ' ') break;
    00F89 2D8E      MOV	R24,R14
    00F8A 3280      CPI	R24,0x20
    00F8B F409      BNE	0x0F8D
    00F8C C011      RJMP	0x0F9E
(1854) 			if (c == NDDE) c = (TCHAR)DDE;
    00F8D 2D8E      MOV	R24,R14
    00F8E 3085      CPI	R24,5
    00F8F F411      BNE	0x0F92
    00F90 EE85      LDI	R24,0xE5
    00F91 2EE8      MOV	R14,R24
(1855) 			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
    00F92 C000      RJMP	0x0F93
(1856) #if _LFN_UNICODE
(1857) 			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
(1858) 				c = (c << 8) | dir[++i];
(1859) 			c = ff_convert(c, 1);
(1860) 			if (!c) c = '?';
(1861) #endif
(1862) 			*p++ = c;
    00F93 01FA      MOVW	R30,R20
    00F94 92E1      ST	Z+,R14
    00F95 01AF      MOVW	R20,R30
    00F96 01C6      MOVW	R24,R12
    00F97 9601      ADIW	R24,1
    00F98 016C      MOVW	R12,R24
    00F99 01C6      MOVW	R24,R12
    00F9A 3088      CPI	R24,0x8
    00F9B E0E0      LDI	R30,0
    00F9C 079E      CPC	R25,R30
    00F9D F338      BCS	0x0F85
(1863) 		}
(1864) 		if (dir[8] != ' ') {		/* Copy name extension */
    00F9E 01F5      MOVW	R30,R10
    00F9F 8580      LDD	R24,Z+8
    00FA0 3280      CPI	R24,0x20
    00FA1 F0E1      BEQ	0x0FBE
(1865) 			*p++ = '.';
    00FA2 E28E      LDI	R24,0x2E
    00FA3 01FA      MOVW	R30,R20
    00FA4 9381      ST	Z+,R24
    00FA5 01AF      MOVW	R20,R30
(1866) 			for (i = 8; i < 11; i++) {
    00FA6 E088      LDI	R24,0x8
    00FA7 E090      LDI	R25,0
    00FA8 016C      MOVW	R12,R24
    00FA9 C00F      RJMP	0x0FB9
(1867) 				c = dir[i];
    00FAA 01F6      MOVW	R30,R12
    00FAB 0DEA      ADD	R30,R10
    00FAC 1DFB      ADC	R31,R11
    00FAD 80E0      LD	R14,Z
(1868) 				if (c == ' ') break;
    00FAE 2D8E      MOV	R24,R14
    00FAF 3280      CPI	R24,0x20
    00FB0 F409      BNE	0x0FB2
    00FB1 C00C      RJMP	0x0FBE
(1869) 				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
    00FB2 C000      RJMP	0x0FB3
(1870) #if _LFN_UNICODE
(1871) 				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
(1872) 					c = (c << 8) | dir[++i];
(1873) 				c = ff_convert(c, 1);
(1874) 				if (!c) c = '?';
(1875) #endif
(1876) 				*p++ = c;
    00FB3 01FA      MOVW	R30,R20
    00FB4 92E1      ST	Z+,R14
    00FB5 01AF      MOVW	R20,R30
    00FB6 01C6      MOVW	R24,R12
    00FB7 9601      ADIW	R24,1
    00FB8 016C      MOVW	R12,R24
    00FB9 01C6      MOVW	R24,R12
    00FBA 308B      CPI	R24,0xB
    00FBB E0E0      LDI	R30,0
    00FBC 079E      CPC	R25,R30
    00FBD F360      BCS	0x0FAA
(1877) 			}
(1878) 		}
(1879) 		fno->fattrib = dir[DIR_Attr];				/* Attribute */
    00FBE 01F5      MOVW	R30,R10
    00FBF 8423      LDD	R2,Z+11
    00FC0 01FB      MOVW	R30,R22
    00FC1 8620      STD	Z+8,R2
(1880) 		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
    00FC2 E188      LDI	R24,0x18
    00FC3 E090      LDI	R25,0
    00FC4 01F5      MOVW	R30,R10
    00FC5 8D07      LDD	R16,Z+31
    00FC6 2711      CLR	R17
    00FC7 2722      CLR	R18
    00FC8 2733      CLR	R19
    00FC9 938A      ST	-Y,R24
    00FCA 940E 3FF6 CALL	lsl32
    00FCC 0118      MOVW	R2,R16
    00FCD 0129      MOVW	R4,R18
    00FCE 01F5      MOVW	R30,R10
    00FCF 8C66      LDD	R6,Z+30
    00FD0 2477      CLR	R7
    00FD1 2488      CLR	R8
    00FD2 2499      CLR	R9
    00FD3 0143      MOVW	R8,R6
    00FD4 2466      CLR	R6
    00FD5 2477      CLR	R7
    00FD6 2826      OR	R2,R6
    00FD7 2837      OR	R3,R7
    00FD8 2848      OR	R4,R8
    00FD9 2859      OR	R5,R9
    00FDA 8C65      LDD	R6,Z+29
    00FDB 2477      CLR	R7
    00FDC 2C76      MOV	R7,R6
    00FDD 2466      CLR	R6
    00FDE 2488      CLR	R8
    00FDF 2499      CLR	R9
    00FE0 2826      OR	R2,R6
    00FE1 2837      OR	R3,R7
    00FE2 2848      OR	R4,R8
    00FE3 2859      OR	R5,R9
    00FE4 8C64      LDD	R6,Z+28
    00FE5 2477      CLR	R7
    00FE6 2488      CLR	R8
    00FE7 2499      CLR	R9
    00FE8 2826      OR	R2,R6
    00FE9 2837      OR	R3,R7
    00FEA 2848      OR	R4,R8
    00FEB 2859      OR	R5,R9
    00FEC 01FB      MOVW	R30,R22
    00FED 8220      ST	Z,R2
    00FEE 8231      STD	Z+1,R3
    00FEF 8242      STD	Z+2,R4
    00FF0 8253      STD	Z+3,R5
(1881) 		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
    00FF1 01F5      MOVW	R30,R10
    00FF2 8C20      LDD	R2,Z+24
    00FF3 2433      CLR	R3
    00FF4 8C41      LDD	R4,Z+25
    00FF5 2455      CLR	R5
    00FF6 2C54      MOV	R5,R4
    00FF7 2444      CLR	R4
    00FF8 2842      OR	R4,R2
    00FF9 2853      OR	R5,R3
    00FFA 01FB      MOVW	R30,R22
    00FFB 8255      STD	Z+5,R5
    00FFC 8244      STD	Z+4,R4
(1882) 		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
    00FFD 01F5      MOVW	R30,R10
    00FFE 8826      LDD	R2,Z+22
    00FFF 2433      CLR	R3
    01000 8847      LDD	R4,Z+23
    01001 2455      CLR	R5
    01002 2C54      MOV	R5,R4
    01003 2444      CLR	R4
    01004 2842      OR	R4,R2
    01005 2853      OR	R5,R3
    01006 01FB      MOVW	R30,R22
    01007 8257      STD	Z+7,R5
    01008 8246      STD	Z+6,R4
(1883) 	}
(1884) 	*p = 0;		/* Terminate SFN str by a \0 */
    01009 2422      CLR	R2
    0100A 01FA      MOVW	R30,R20
    0100B 8220      ST	Z,R2
    0100C 940C 3F69 JMP	pop_xgsetF0FC
ff.c:follow_path:
  ns                   --> R10
  res                  --> R20
  dir                  --> R10
  path                 --> Y,+6
  dj                   --> R22
    0100E 933A      ST	-Y,R19
    0100F 932A      ST	-Y,R18
    01010 940E 3F93 CALL	push_xgsetF00C
    01012 01B8      MOVW	R22,R16
(1885) 
(1886) #if _USE_LFN
(1887) 	if (fno->lfname && fno->lfsize) {
(1888) 		TCHAR *tp = fno->lfname;
(1889) 		WCHAR w, *lfn;
(1890) 
(1891) 		i = 0;
(1892) 		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
(1893) 			lfn = dj->lfn;
(1894) 			while ((w = *lfn++) != 0) {			/* Get an LFN char */
(1895) #if !_LFN_UNICODE
(1896) 				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
(1897) 				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
(1898) 				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
(1899) 					tp[i++] = (TCHAR)(w >> 8);
(1900) #endif
(1901) 				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
(1902) 				tp[i++] = (TCHAR)w;
(1903) 			}
(1904) 		}
(1905) 		tp[i] = 0;	/* Terminate the LFN str by a \0 */
(1906) 	}
(1907) #endif
(1908) }
(1909) #endif /* _FS_MINIMIZE <= 1 */
(1910) 
(1911) 
(1912) 
(1913) 
(1914) /*-----------------------------------------------------------------------*/
(1915) /* Follow a file path                                                    */
(1916) /*-----------------------------------------------------------------------*/
(1917) 
(1918) static
(1919) FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
(1920) 	DIR *dj,			/* Directory object to return last directory and found object */
(1921) 	const TCHAR *path	/* Full-path string to find a file or directory */
(1922) )
(1923) {
(1924) 	FRESULT res;
(1925) 	BYTE *dir, ns;
(1926) 
(1927) 
(1928) #if _FS_RPATH
(1929) 	if (*path == '/' || *path == '\\') { /* There is a heading separator */
(1930) 		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
(1931) 	} else {							/* No heading separator */
(1932) 		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
(1933) 	}
(1934) #else
(1935) 	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    01013 81EE      LDD	R30,Y+6
    01014 81FF      LDD	R31,Y+7
    01015 8020      LD	R2,Z
    01016 2433      CLR	R3
    01017 2D82      MOV	R24,R2
    01018 328F      CPI	R24,0x2F
    01019 F011      BEQ	0x101C
    0101A 358C      CPI	R24,0x5C
    0101B F429      BNE	0x1021
(1936) 		path++;
    0101C 818E      LDD	R24,Y+6
    0101D 819F      LDD	R25,Y+7
    0101E 9601      ADIW	R24,1
    0101F 839F      STD	Y+7,R25
    01020 838E      STD	Y+6,R24
(1937) 	dj->sclust = 0;						/* Start from the root dir */
    01021 01FB      MOVW	R30,R22
    01022 9636      ADIW	R30,6
    01023 E080      LDI	R24,0
    01024 8380      ST	Z,R24
    01025 8381      STD	Z+1,R24
    01026 8382      STD	Z+2,R24
    01027 8383      STD	Z+3,R24
(1938) #endif
(1939) 
(1940) 	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    01028 81EE      LDD	R30,Y+6
    01029 81FF      LDD	R31,Y+7
    0102A 8180      LD	R24,Z
    0102B 2799      CLR	R25
    0102C 3280      CPI	R24,0x20
    0102D E0E0      LDI	R30,0
    0102E 079E      CPC	R25,R30
    0102F F458      BCC	0x103B
(1941) 		res = dir_sdi(dj, 0);
    01030 2722      CLR	R18
    01031 2733      CLR	R19
    01032 018B      MOVW	R16,R22
    01033 DA84      RCALL	ff.c:dir_sdi
    01034 2F40      MOV	R20,R16
(1942) 		dj->dir = 0;
    01035 2422      CLR	R2
    01036 2433      CLR	R3
    01037 01FB      MOVW	R30,R22
    01038 8A33      STD	Z+19,R3
    01039 8A22      STD	Z+18,R2
(1943) 
(1944) 	} else {							/* Follow path */
    0103A C052      RJMP	0x108D
(1945) 		for (;;) {
(1946) 			res = create_name(dj, &path);	/* Get a segment */
    0103B 019E      MOVW	R18,R28
    0103C 5F2A      SUBI	R18,0xFA
    0103D 4F3F      SBCI	R19,0xFF
    0103E 018B      MOVW	R16,R22
    0103F DE23      RCALL	ff.c:create_name
    01040 2EA0      MOV	R10,R16
    01041 2D4A      MOV	R20,R10
(1947) 			if (res != FR_OK) break;
    01042 2300      TST	R16
    01043 F009      BEQ	0x1045
    01044 C048      RJMP	0x108D
(1948) 			res = dir_find(dj);				/* Find it */
    01045 018B      MOVW	R16,R22
    01046 DD29      RCALL	ff.c:dir_find
    01047 2EA0      MOV	R10,R16
    01048 2D4A      MOV	R20,R10
(1949) 			ns = *(dj->fn+NS);
    01049 01FB      MOVW	R30,R22
    0104A 93AF      PUSH	R26
    0104B 93BF      PUSH	R27
    0104C 89A4      LDD	R26,Z+20
    0104D 89B5      LDD	R27,Z+21
    0104E 01FD      MOVW	R30,R26
    0104F 91BF      POP	R27
    01050 91AF      POP	R26
    01051 84A3      LDD	R10,Z+11
(1950) 			if (res != FR_OK) {				/* Failed to find the object */
    01052 2300      TST	R16
    01053 F049      BEQ	0x105D
(1951) 				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
    01054 3004      CPI	R16,4
    01055 F009      BEQ	0x1057
    01056 C036      RJMP	0x108D
(1952) 				/* Object not found */
(1953) 				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
    01057 C001      RJMP	0x1059
(1954) 					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
(1955) 					res = FR_OK;
(1956) 					if (!(ns & NS_LAST)) continue;
    01058 CFE2      RJMP	0x103B
(1957) 				} else {							/* Could not find the object */
(1958) 					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    01059 FCA2      SBRC	R10,2
    0105A C032      RJMP	0x108D
    0105B E045      LDI	R20,5
(1959) 				}
(1960) 				break;
    0105C C030      RJMP	0x108D
(1961) 			}
(1962) 			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    0105D FEA2      SBRS	R10,2
    0105E C001      RJMP	0x1060
    0105F C02D      RJMP	0x108D
(1963) 			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    01060 01FB      MOVW	R30,R22
    01061 88A2      LDD	R10,Z+18
    01062 88B3      LDD	R11,Z+19
(1964) 			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    01063 01F5      MOVW	R30,R10
    01064 8423      LDD	R2,Z+11
    01065 FC24      SBRC	R2,4
    01066 C002      RJMP	0x1069
(1965) 				res = FR_NO_PATH; break;
    01067 E045      LDI	R20,5
    01068 C024      RJMP	0x108D
(1966) 			}
(1967) 			dj->sclust = LD_CLUST(dir);
    01069 01F5      MOVW	R30,R10
    0106A 8C22      LDD	R2,Z+26
    0106B 2433      CLR	R3
    0106C 8C43      LDD	R4,Z+27
    0106D 2455      CLR	R5
    0106E 2C54      MOV	R5,R4
    0106F 2444      CLR	R4
    01070 2842      OR	R4,R2
    01071 2853      OR	R5,R3
    01072 0112      MOVW	R2,R4
    01073 2444      CLR	R4
    01074 2455      CLR	R5
    01075 8864      LDD	R6,Z+20
    01076 2477      CLR	R7
    01077 8885      LDD	R8,Z+21
    01078 2499      CLR	R9
    01079 2C98      MOV	R9,R8
    0107A 2488      CLR	R8
    0107B 2886      OR	R8,R6
    0107C 2897      OR	R9,R7
    0107D 0134      MOVW	R6,R8
    0107E 2488      CLR	R8
    0107F 2499      CLR	R9
    01080 0143      MOVW	R8,R6
    01081 2466      CLR	R6
    01082 2477      CLR	R7
    01083 2862      OR	R6,R2
    01084 2873      OR	R7,R3
    01085 2884      OR	R8,R4
    01086 2895      OR	R9,R5
    01087 01FB      MOVW	R30,R22
    01088 8266      STD	Z+6,R6
    01089 8277      STD	Z+7,R7
    0108A 8680      STD	Z+8,R8
    0108B 8691      STD	Z+9,R9
    0108C CFAE      RJMP	0x103B
(1968) 		}
(1969) 	}
(1970) 
(1971) 	return res;
    0108D 2F04      MOV	R16,R20
    0108E 940E 3F9A CALL	pop_xgsetF00C
    01090 9622      ADIW	R28,2
    01091 9508      RET
ff.c:check_fs:
  sect                 --> Y,+11
  fs                   --> R10
    01092 933A      ST	-Y,R19
    01093 932A      ST	-Y,R18
    01094 940E 3F93 CALL	push_xgsetF00C
    01096 0158      MOVW	R10,R16
    01097 9725      SBIW	R28,5
(1972) }
(1973) 
(1974) 
(1975) 
(1976) 
(1977) /*-----------------------------------------------------------------------*/
(1978) /* Load a sector and check if it is an FAT Volume Boot Record            */
(1979) /*-----------------------------------------------------------------------*/
(1980) 
(1981) static
(1982) BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
(1983) 	FATFS *fs,	/* File system object */
(1984) 	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
(1985) )
(1986) {
(1987) 	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    01098 E081      LDI	R24,1
    01099 838C      STD	Y+4,R24
    0109A 842B      LDD	R2,Y+11
    0109B 843C      LDD	R3,Y+12
    0109C 844D      LDD	R4,Y+13
    0109D 845E      LDD	R5,Y+14
    0109E 8228      ST	Y,R2
    0109F 8239      STD	Y+1,R3
    010A0 824A      STD	Y+2,R4
    010A1 825B      STD	Y+3,R5
    010A2 0195      MOVW	R18,R10
    010A3 5D22      SUBI	R18,0xD2
    010A4 4F3F      SBCI	R19,0xFF
    010A5 01F5      MOVW	R30,R10
    010A6 8101      LDD	R16,Z+1
    010A7 940E 02A1 CALL	_disk_read
    010A9 2300      TST	R16
    010AA F011      BEQ	0x10AD
(1988) 		return 3;
    010AB E003      LDI	R16,3
    010AC C0A8      RJMP	0x1155
(1989) 	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    010AD 01F5      MOVW	R30,R10
    010AE 5DE4      SUBI	R30,0xD4
    010AF 4FFD      SBCI	R31,0xFD
    010B0 8020      LD	R2,Z
    010B1 52EC      SUBI	R30,0x2C
    010B2 40F2      SBCI	R31,2
    010B3 2433      CLR	R3
    010B4 5DE3      SUBI	R30,0xD3
    010B5 4FFD      SBCI	R31,0xFD
    010B6 8180      LD	R24,Z
    010B7 2799      CLR	R25
    010B8 2F98      MOV	R25,R24
    010B9 2788      CLR	R24
    010BA 2982      OR	R24,R2
    010BB 2993      OR	R25,R3
    010BC 3585      CPI	R24,0x55
    010BD EAEA      LDI	R30,0xAA
    010BE 079E      CPC	R25,R30
    010BF F011      BEQ	0x10C2
(1990) 		return 2;
    010C0 E002      LDI	R16,2
    010C1 C093      RJMP	0x1155
(1991) 
(1992) 	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    010C2 E188      LDI	R24,0x18
    010C3 E090      LDI	R25,0
    010C4 01F5      MOVW	R30,R10
    010C5 59E9      SUBI	R30,0x99
    010C6 4FFF      SBCI	R31,0xFF
    010C7 8100      LD	R16,Z
    010C8 2711      CLR	R17
    010C9 2722      CLR	R18
    010CA 2733      CLR	R19
    010CB 938A      ST	-Y,R24
    010CC 940E 3FF6 CALL	lsl32
    010CE 0118      MOVW	R2,R16
    010CF 0129      MOVW	R4,R18
    010D0 01F5      MOVW	R30,R10
    010D1 59EA      SUBI	R30,0x9A
    010D2 4FFF      SBCI	R31,0xFF
    010D3 8060      LD	R6,Z
    010D4 56E6      SUBI	R30,0x66
    010D5 40F0      SBCI	R31,0
    010D6 2477      CLR	R7
    010D7 2488      CLR	R8
    010D8 2499      CLR	R9
    010D9 0143      MOVW	R8,R6
    010DA 2466      CLR	R6
    010DB 2477      CLR	R7
    010DC 2826      OR	R2,R6
    010DD 2837      OR	R3,R7
    010DE 2848      OR	R4,R8
    010DF 2859      OR	R5,R9
    010E0 59EB      SUBI	R30,0x9B
    010E1 4FFF      SBCI	R31,0xFF
    010E2 8060      LD	R6,Z
    010E3 56E5      SUBI	R30,0x65
    010E4 40F0      SBCI	R31,0
    010E5 2477      CLR	R7
    010E6 2C76      MOV	R7,R6
    010E7 2466      CLR	R6
    010E8 2488      CLR	R8
    010E9 2499      CLR	R9
    010EA 2826      OR	R2,R6
    010EB 2837      OR	R3,R7
    010EC 2848      OR	R4,R8
    010ED 2859      OR	R5,R9
    010EE 59EC      SUBI	R30,0x9C
    010EF 4FFF      SBCI	R31,0xFF
    010F0 8060      LD	R6,Z
    010F1 2477      CLR	R7
    010F2 2488      CLR	R8
    010F3 2499      CLR	R9
    010F4 2826      OR	R2,R6
    010F5 2837      OR	R3,R7
    010F6 2848      OR	R4,R8
    010F7 2859      OR	R5,R9
    010F8 EF4F      LDI	R20,0xFF
    010F9 EF5F      LDI	R21,0xFF
    010FA EF6F      LDI	R22,0xFF
    010FB E070      LDI	R23,0
    010FC 2224      AND	R2,R20
    010FD 2235      AND	R3,R21
    010FE 2246      AND	R4,R22
    010FF 2257      AND	R5,R23
    01100 E446      LDI	R20,0x46
    01101 E451      LDI	R21,0x41
    01102 E564      LDI	R22,0x54
    01103 E070      LDI	R23,0
    01104 1624      CP	R2,R20
    01105 0635      CPC	R3,R21
    01106 0646      CPC	R4,R22
    01107 0657      CPC	R5,R23
    01108 F411      BNE	0x110B
(1993) 		return 0;
    01109 2700      CLR	R16
    0110A C04A      RJMP	0x1155
(1994) 	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    0110B E188      LDI	R24,0x18
    0110C E090      LDI	R25,0
    0110D 01F5      MOVW	R30,R10
    0110E 57ED      SUBI	R30,0x7D
    0110F 4FFF      SBCI	R31,0xFF
    01110 8100      LD	R16,Z
    01111 2711      CLR	R17
    01112 2722      CLR	R18
    01113 2733      CLR	R19
    01114 938A      ST	-Y,R24
    01115 940E 3FF6 CALL	lsl32
    01117 0118      MOVW	R2,R16
    01118 0129      MOVW	R4,R18
    01119 01F5      MOVW	R30,R10
    0111A 57EE      SUBI	R30,0x7E
    0111B 4FFF      SBCI	R31,0xFF
    0111C 8060      LD	R6,Z
    0111D 58E2      SUBI	R30,0x82
    0111E 40F0      SBCI	R31,0
    0111F 2477      CLR	R7
    01120 2488      CLR	R8
    01121 2499      CLR	R9
    01122 0143      MOVW	R8,R6
    01123 2466      CLR	R6
    01124 2477      CLR	R7
    01125 2826      OR	R2,R6
    01126 2837      OR	R3,R7
    01127 2848      OR	R4,R8
    01128 2859      OR	R5,R9
    01129 57EF      SUBI	R30,0x7F
    0112A 4FFF      SBCI	R31,0xFF
    0112B 8060      LD	R6,Z
    0112C 58E1      SUBI	R30,0x81
    0112D 40F0      SBCI	R31,0
    0112E 2477      CLR	R7
    0112F 2C76      MOV	R7,R6
    01130 2466      CLR	R6
    01131 2488      CLR	R8
    01132 2499      CLR	R9
    01133 2826      OR	R2,R6
    01134 2837      OR	R3,R7
    01135 2848      OR	R4,R8
    01136 2859      OR	R5,R9
    01137 58E0      SUBI	R30,0x80
    01138 4FFF      SBCI	R31,0xFF
    01139 8060      LD	R6,Z
    0113A 2477      CLR	R7
    0113B 2488      CLR	R8
    0113C 2499      CLR	R9
    0113D 2826      OR	R2,R6
    0113E 2837      OR	R3,R7
    0113F 2848      OR	R4,R8
    01140 2859      OR	R5,R9
    01141 EF4F      LDI	R20,0xFF
    01142 EF5F      LDI	R21,0xFF
    01143 EF6F      LDI	R22,0xFF
    01144 E070      LDI	R23,0
    01145 2224      AND	R2,R20
    01146 2235      AND	R3,R21
    01147 2246      AND	R4,R22
    01148 2257      AND	R5,R23
    01149 E446      LDI	R20,0x46
    0114A E451      LDI	R21,0x41
    0114B E564      LDI	R22,0x54
    0114C E070      LDI	R23,0
    0114D 1624      CP	R2,R20
    0114E 0635      CPC	R3,R21
    0114F 0646      CPC	R4,R22
    01150 0657      CPC	R5,R23
    01151 F411      BNE	0x1154
(1995) 		return 0;
    01152 2700      CLR	R16
    01153 C001      RJMP	0x1155
(1996) 
(1997) 	return 1;
    01154 E001      LDI	R16,1
    01155 9625      ADIW	R28,5
    01156 940E 3F9A CALL	pop_xgsetF00C
    01158 9622      ADIW	R28,2
    01159 9508      RET
ff.c:chk_mounted:
  pi                   --> R10
  szbfat               --> Y,+25
  tbl                  --> R10
  p                    --> R10
  nrsv                 --> R14
  sysect               --> Y,+21
  bsect                --> Y,+17
  stat                 --> R10
  tsect                --> Y,+13
  nclst                --> Y,+9
  vol                  --> R14
  fasize               --> Y,+5
  b                    --> R14
  fmt                  --> R12
  fs                   --> Y,+37
  chk_wp               --> Y,+51
  rfs                  --> Y,+49
  path                 --> R12
    0115A 933A      ST	-Y,R19
    0115B 932A      ST	-Y,R18
    0115C 940E 3F74 CALL	push_xgsetF0FC
    0115E 0168      MOVW	R12,R16
    0115F 97A7      SBIW	R28,0x27
(1998) }
(1999) 
(2000) 
(2001) 
(2002) 
(2003) /*-----------------------------------------------------------------------*/
(2004) /* Check if the file system object is valid or not                       */
(2005) /*-----------------------------------------------------------------------*/
(2006) 
(2007) static
(2008) FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
(2009) 	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
(2010) 	FATFS **rfs,		/* Pointer to pointer to the found file system object */
(2011) 	BYTE chk_wp			/* !=0: Check media write protection for write access */
(2012) )
(2013) {
(2014) 	BYTE fmt, b, pi, *tbl;
(2015) 	UINT vol;
(2016) 	DSTATUS stat;
(2017) 	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
(2018) 	WORD nrsv;
(2019) 	const TCHAR *p = *path;
    01160 01F6      MOVW	R30,R12
    01161 80A0      LD	R10,Z
    01162 80B1      LDD	R11,Z+1
(2020) 	FATFS *fs;
(2021) 
(2022) 	/* Get logical drive number from the path name */
(2023) 	vol = p[0] - '0';					/* Is there a drive number? */
    01163 01F5      MOVW	R30,R10
    01164 8180      LD	R24,Z
    01165 2799      CLR	R25
    01166 97C0      SBIW	R24,0x30
    01167 017C      MOVW	R14,R24
(2024) 	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    01168 E089      LDI	R24,0x9
    01169 E090      LDI	R25,0
    0116A 158E      CP	R24,R14
    0116B 059F      CPC	R25,R15
    0116C F050      BCS	0x1177
    0116D 8181      LDD	R24,Z+1
    0116E 338A      CPI	R24,0x3A
    0116F F439      BNE	0x1177
(2025) 		p += 2; *path = p;				/* Return pointer to the path name */
    01170 01CF      MOVW	R24,R30
    01171 9602      ADIW	R24,2
    01172 015C      MOVW	R10,R24
    01173 01F6      MOVW	R30,R12
    01174 82B1      STD	Z+1,R11
    01175 82A0      ST	Z,R10
(2026) 	} else {							/* No drive number is given */
    01176 C002      RJMP	0x1179
(2027) #if _FS_RPATH
(2028) 		vol = CurrVol;					/* Use current drive */
(2029) #else
(2030) 		vol = 0;						/* Use drive 0 */
    01177 24EE      CLR	R14
    01178 24FF      CLR	R15
(2031) #endif
(2032) 	}
(2033) 
(2034) 	/* Check if the file system object is valid or not */
(2035) 	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    01179 01C7      MOVW	R24,R14
    0117A 3081      CPI	R24,1
    0117B E0E0      LDI	R30,0
    0117C 079E      CPC	R25,R30
    0117D F010      BCS	0x1180
(2036) 		return FR_INVALID_DRIVE;
    0117E E00B      LDI	R16,0xB
    0117F C4CF      RJMP	0x164F
(2037) 	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
    01180 EF86      LDI	R24,0xF6
    01181 E094      LDI	R25,4
    01182 01F7      MOVW	R30,R14
    01183 0FEE      LSL	R30
    01184 1FFF      ROL	R31
    01185 0FE8      ADD	R30,R24
    01186 1FF9      ADC	R31,R25
    01187 8020      LD	R2,Z
    01188 8031      LDD	R3,Z+1
    01189 A23E      STD	Y+38,R3
    0118A A22D      STD	Y+37,R2
    0118B A9E9      LDD	R30,Y+49
    0118C A9FA      LDD	R31,Y+50
    0118D 8231      STD	Z+1,R3
    0118E 8220      ST	Z,R2
(2038) 	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    0118F 0101      MOVW	R0,R2
    01190 2022      TST	R2
    01191 F421      BNE	0x1196
    01192 2033      TST	R3
    01193 F411      BNE	0x1196
    01194 E00C      LDI	R16,0xC
    01195 C4B9      RJMP	0x164F
(2039) 
(2040) 	ENTER_FF(fs);						/* Lock file system */
(2041) 
(2042) 	if (fs->fs_type) {					/* If the logical drive has been mounted */
    01196 A1ED      LDD	R30,Y+37
    01197 A1FE      LDD	R31,Y+38
    01198 8020      LD	R2,Z
    01199 2022      TST	R2
    0119A F079      BEQ	0x11AA
(2043) 		stat = disk_status(fs->drv);
    0119B 8101      LDD	R16,Z+1
    0119C 940E 029B CALL	_disk_status
    0119E 2EA0      MOV	R10,R16
(2044) 		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    0119F FD00      SBRC	R16,0
    011A0 C009      RJMP	0x11AA
(2045) 			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
    011A1 A80B      LDD	R0,Y+51
    011A2 2000      TST	R0
    011A3 F021      BEQ	0x11A8
    011A4 FF02      SBRS	R16,2
    011A5 C002      RJMP	0x11A8
(2046) 				return FR_WRITE_PROTECTED;
    011A6 E00A      LDI	R16,0xA
    011A7 C4A7      RJMP	0x164F
(2047) 			return FR_OK;				/* The file system object is valid */
    011A8 2700      CLR	R16
    011A9 C4A5      RJMP	0x164F
(2048) 		}
(2049) 	}
(2050) 
(2051) 	/* The file system object is not valid. */
(2052) 	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
(2053) 
(2054) 	fs->fs_type = 0;					/* Clear the file system object */
    011AA 2422      CLR	R2
    011AB A1ED      LDD	R30,Y+37
    011AC A1FE      LDD	R31,Y+38
    011AD 8220      ST	Z,R2
(2055) 	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    011AE 82E1      STD	Z+1,R14
(2056) 	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
    011AF 8101      LDD	R16,Z+1
    011B0 940E 0285 CALL	_disk_initialize
    011B2 2EE0      MOV	R14,R16
    011B3 2CAE      MOV	R10,R14
(2057) 	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    011B4 FF00      SBRS	R16,0
    011B5 C002      RJMP	0x11B8
(2058) 		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
    011B6 E003      LDI	R16,3
    011B7 C497      RJMP	0x164F
(2059) 	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
    011B8 A80B      LDD	R0,Y+51
    011B9 2000      TST	R0
    011BA F021      BEQ	0x11BF
    011BB FEA2      SBRS	R10,2
    011BC C002      RJMP	0x11BF
(2060) 		return FR_WRITE_PROTECTED;
    011BD E00A      LDI	R16,0xA
    011BE C490      RJMP	0x164F
(2061) #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
(2062) 	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
(2063) 		return FR_DISK_ERR;
(2064) #endif
(2065) 	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
(2066) 	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    011BF E080      LDI	R24,0
    011C0 8B89      STD	Y+17,R24
    011C1 8B8A      STD	Y+18,R24
    011C2 8B8B      STD	Y+19,R24
    011C3 8B8C      STD	Y+20,R24
    011C4 E040      LDI	R20,0
    011C5 E050      LDI	R21,0
    011C6 E060      LDI	R22,0
    011C7 E070      LDI	R23,0
    011C8 8368      ST	Y,R22
    011C9 8379      STD	Y+1,R23
    011CA 019A      MOVW	R18,R20
    011CB A10D      LDD	R16,Y+37
    011CC A11E      LDD	R17,Y+38
    011CD DEC4      RCALL	ff.c:check_fs
    011CE 2EA0      MOV	R10,R16
    011CF 2CCA      MOV	R12,R10
(2067) 	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
    011D0 C000      RJMP	0x11D1
(2068) 	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    011D1 2D8C      MOV	R24,R12
    011D2 3081      CPI	R24,1
    011D3 F009      BEQ	0x11D5
    011D4 C04C      RJMP	0x1221
(2069) 		/* Check the partition listed in the partition table */
(2070) 		pi = LD2PT(vol);
    011D5 24AA      CLR	R10
(2071) 		if (pi) pi--;
    011D6 F009      BEQ	0x11D8
    011D7 94AA      DEC	R10
(2072) 		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
    011D8 E100      LDI	R16,0x10
    011D9 2D1A      MOV	R17,R10
    011DA 0301      MULSU	R16,R17
    011DB 0150      MOVW	R10,R0
    011DC A18D      LDD	R24,Y+37
    011DD A19E      LDD	R25,Y+38
    011DE 5184      SUBI	R24,0x14
    011DF 4F9E      SBCI	R25,0xFE
    011E0 0EA8      ADD	R10,R24
    011E1 1EB9      ADC	R11,R25
(2073) 		if (tbl[4]) {						/* Is the partition existing? */
    011E2 01F5      MOVW	R30,R10
    011E3 8024      LDD	R2,Z+4
    011E4 2022      TST	R2
    011E5 F409      BNE	0x11E7
    011E6 C03A      RJMP	0x1221
(2074) 			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    011E7 E188      LDI	R24,0x18
    011E8 E090      LDI	R25,0
    011E9 8503      LDD	R16,Z+11
    011EA 2711      CLR	R17
    011EB 2722      CLR	R18
    011EC 2733      CLR	R19
    011ED 938A      ST	-Y,R24
    011EE 940E 3FF6 CALL	lsl32
    011F0 0118      MOVW	R2,R16
    011F1 0129      MOVW	R4,R18
    011F2 01F5      MOVW	R30,R10
    011F3 8462      LDD	R6,Z+10
    011F4 2477      CLR	R7
    011F5 2488      CLR	R8
    011F6 2499      CLR	R9
    011F7 0143      MOVW	R8,R6
    011F8 2466      CLR	R6
    011F9 2477      CLR	R7
    011FA 2826      OR	R2,R6
    011FB 2837      OR	R3,R7
    011FC 2848      OR	R4,R8
    011FD 2859      OR	R5,R9
    011FE 8461      LDD	R6,Z+9
    011FF 2477      CLR	R7
    01200 2C76      MOV	R7,R6
    01201 2466      CLR	R6
    01202 2488      CLR	R8
    01203 2499      CLR	R9
    01204 2826      OR	R2,R6
    01205 2837      OR	R3,R7
    01206 2848      OR	R4,R8
    01207 2859      OR	R5,R9
    01208 9638      ADIW	R30,0x8
    01209 8060      LD	R6,Z
    0120A 2477      CLR	R7
    0120B 2488      CLR	R8
    0120C 2499      CLR	R9
    0120D 2826      OR	R2,R6
    0120E 2837      OR	R3,R7
    0120F 2848      OR	R4,R8
    01210 2859      OR	R5,R9
    01211 8A29      STD	Y+17,R2
    01212 8A3A      STD	Y+18,R3
    01213 8A4B      STD	Y+19,R4
    01214 8A5C      STD	Y+20,R5
(2075) 			fmt = check_fs(fs, bsect);		/* Check the partition */
    01215 8829      LDD	R2,Y+17
    01216 883A      LDD	R3,Y+18
    01217 884B      LDD	R4,Y+19
    01218 885C      LDD	R5,Y+20
    01219 8248      ST	Y,R4
    0121A 8259      STD	Y+1,R5
    0121B 0191      MOVW	R18,R2
    0121C A10D      LDD	R16,Y+37
    0121D A11E      LDD	R17,Y+38
    0121E DE73      RCALL	ff.c:check_fs
    0121F 2EA0      MOV	R10,R16
    01220 2CCA      MOV	R12,R10
(2076) 		}
(2077) 	}
(2078) 	if (fmt == 3) return FR_DISK_ERR;
    01221 2D8C      MOV	R24,R12
    01222 3083      CPI	R24,3
    01223 F411      BNE	0x1226
    01224 E001      LDI	R16,1
    01225 C429      RJMP	0x164F
(2079) 	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    01226 20CC      TST	R12
    01227 F011      BEQ	0x122A
    01228 E00D      LDI	R16,0xD
    01229 C425      RJMP	0x164F
(2080) 
(2081) 	/* An FAT volume is found. Following code initializes the file system object */
(2082) 
(2083) 	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    0122A A1ED      LDD	R30,Y+37
    0122B A1FE      LDD	R31,Y+38
    0122C AC21      LDD	R2,Z+57
    0122D 2433      CLR	R3
    0122E AD82      LDD	R24,Z+58
    0122F 2799      CLR	R25
    01230 2F98      MOV	R25,R24
    01231 2788      CLR	R24
    01232 2982      OR	R24,R2
    01233 2993      OR	R25,R3
    01234 3080      CPI	R24,0
    01235 E0E2      LDI	R30,2
    01236 079E      CPC	R25,R30
    01237 F011      BEQ	0x123A
(2084) 		return FR_NO_FILESYSTEM;
    01238 E00D      LDI	R16,0xD
    01239 C415      RJMP	0x164F
(2085) 
(2086) 	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    0123A A1ED      LDD	R30,Y+37
    0123B A1FE      LDD	R31,Y+38
    0123C 5BEC      SUBI	R30,0xBC
    0123D 4FFF      SBCI	R31,0xFF
    0123E 8020      LD	R2,Z
    0123F 54E4      SUBI	R30,0x44
    01240 40F0      SBCI	R31,0
    01241 2433      CLR	R3
    01242 5BEB      SUBI	R30,0xBB
    01243 4FFF      SBCI	R31,0xFF
    01244 8040      LD	R4,Z
    01245 2455      CLR	R5
    01246 2C54      MOV	R5,R4
    01247 2444      CLR	R4
    01248 2842      OR	R4,R2
    01249 2853      OR	R5,R3
    0124A 0112      MOVW	R2,R4
    0124B 2444      CLR	R4
    0124C 2455      CLR	R5
    0124D 822D      STD	Y+5,R2
    0124E 823E      STD	Y+6,R3
    0124F 824F      STD	Y+7,R4
    01250 8658      STD	Y+8,R5
(2087) 	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    01251 802D      LDD	R2,Y+5
    01252 803E      LDD	R3,Y+6
    01253 804F      LDD	R4,Y+7
    01254 8458      LDD	R5,Y+8
    01255 9488      BCLR	0
    01256 2022      TST	R2
    01257 0432      CPC	R3,R2
    01258 0442      CPC	R4,R2
    01259 0452      CPC	R5,R2
    0125A F009      BEQ	0x125C
    0125B C03C      RJMP	0x1298
    0125C E188      LDI	R24,0x18
    0125D E090      LDI	R25,0
    0125E A1ED      LDD	R30,Y+37
    0125F A1FE      LDD	R31,Y+38
    01260 5AEB      SUBI	R30,0xAB
    01261 4FFF      SBCI	R31,0xFF
    01262 8100      LD	R16,Z
    01263 2711      CLR	R17
    01264 2722      CLR	R18
    01265 2733      CLR	R19
    01266 938A      ST	-Y,R24
    01267 940E 3FF6 CALL	lsl32
    01269 0118      MOVW	R2,R16
    0126A 0129      MOVW	R4,R18
    0126B A1ED      LDD	R30,Y+37
    0126C A1FE      LDD	R31,Y+38
    0126D 5AEC      SUBI	R30,0xAC
    0126E 4FFF      SBCI	R31,0xFF
    0126F 8060      LD	R6,Z
    01270 55E4      SUBI	R30,0x54
    01271 40F0      SBCI	R31,0
    01272 2477      CLR	R7
    01273 2488      CLR	R8
    01274 2499      CLR	R9
    01275 0143      MOVW	R8,R6
    01276 2466      CLR	R6
    01277 2477      CLR	R7
    01278 2826      OR	R2,R6
    01279 2837      OR	R3,R7
    0127A 2848      OR	R4,R8
    0127B 2859      OR	R5,R9
    0127C 5AED      SUBI	R30,0xAD
    0127D 4FFF      SBCI	R31,0xFF
    0127E 8060      LD	R6,Z
    0127F 55E3      SUBI	R30,0x53
    01280 40F0      SBCI	R31,0
    01281 2477      CLR	R7
    01282 2C76      MOV	R7,R6
    01283 2466      CLR	R6
    01284 2488      CLR	R8
    01285 2499      CLR	R9
    01286 2826      OR	R2,R6
    01287 2837      OR	R3,R7
    01288 2848      OR	R4,R8
    01289 2859      OR	R5,R9
    0128A 5AEE      SUBI	R30,0xAE
    0128B 4FFF      SBCI	R31,0xFF
    0128C 8060      LD	R6,Z
    0128D 2477      CLR	R7
    0128E 2488      CLR	R8
    0128F 2499      CLR	R9
    01290 2826      OR	R2,R6
    01291 2837      OR	R3,R7
    01292 2848      OR	R4,R8
    01293 2859      OR	R5,R9
    01294 822D      STD	Y+5,R2
    01295 823E      STD	Y+6,R3
    01296 824F      STD	Y+7,R4
    01297 8658      STD	Y+8,R5
(2088) 	fs->fsize = fasize;
    01298 802D      LDD	R2,Y+5
    01299 803E      LDD	R3,Y+6
    0129A 804F      LDD	R4,Y+7
    0129B 8458      LDD	R5,Y+8
    0129C A1ED      LDD	R30,Y+37
    0129D A1FE      LDD	R31,Y+38
    0129E 8E22      STD	Z+26,R2
    0129F 8E33      STD	Z+27,R3
    012A0 8E44      STD	Z+28,R4
    012A1 8E55      STD	Z+29,R5
(2089) 
(2090) 	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    012A2 ACA6      LDD	R10,Z+62
    012A3 2CEA      MOV	R14,R10
    012A4 82A3      STD	Z+3,R10
(2091) 	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    012A5 2D8E      MOV	R24,R14
    012A6 3081      CPI	R24,1
    012A7 F021      BEQ	0x12AC
    012A8 3082      CPI	R24,2
    012A9 F011      BEQ	0x12AC
    012AA E00D      LDI	R16,0xD
    012AB C3A3      RJMP	0x164F
(2092) 	fasize *= b;										/* Number of sectors for FAT area */
    012AC 2C2E      MOV	R2,R14
    012AD 2433      CLR	R3
    012AE 2444      CLR	R4
    012AF 2455      CLR	R5
    012B0 810D      LDD	R16,Y+5
    012B1 811E      LDD	R17,Y+6
    012B2 812F      LDD	R18,Y+7
    012B3 8538      LDD	R19,Y+8
    012B4 925A      ST	-Y,R5
    012B5 924A      ST	-Y,R4
    012B6 923A      ST	-Y,R3
    012B7 922A      ST	-Y,R2
    012B8 940E 3F20 CALL	empy32u|empy32s
    012BA 830D      STD	Y+5,R16
    012BB 831E      STD	Y+6,R17
    012BC 832F      STD	Y+7,R18
    012BD 8738      STD	Y+8,R19
(2093) 
(2094) 	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    012BE A1ED      LDD	R30,Y+37
    012BF A1FE      LDD	R31,Y+38
    012C0 ACA3      LDD	R10,Z+59
    012C1 2CEA      MOV	R14,R10
    012C2 82A2      STD	Z+2,R10
(2095) 	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    012C3 20AA      TST	R10
    012C4 F029      BEQ	0x12CA
    012C5 2D8E      MOV	R24,R14
    012C6 5081      SUBI	R24,1
    012C7 2C2E      MOV	R2,R14
    012C8 2228      AND	R2,R24
    012C9 F011      BEQ	0x12CC
    012CA E00D      LDI	R16,0xD
    012CB C383      RJMP	0x164F
(2096) 
(2097) 	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    012CC A1ED      LDD	R30,Y+37
    012CD A1FE      LDD	R31,Y+38
    012CE AC27      LDD	R2,Z+63
    012CF 2433      CLR	R3
    012D0 5CE0      SUBI	R30,0xC0
    012D1 4FFF      SBCI	R31,0xFF
    012D2 8040      LD	R4,Z
    012D3 54E0      SUBI	R30,0x40
    012D4 40F0      SBCI	R31,0
    012D5 2455      CLR	R5
    012D6 2C54      MOV	R5,R4
    012D7 2444      CLR	R4
    012D8 2842      OR	R4,R2
    012D9 2853      OR	R5,R3
    012DA 8651      STD	Z+9,R5
    012DB 8640      STD	Z+8,R4
(2098) 	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    012DC 8580      LDD	R24,Z+8
    012DD 8591      LDD	R25,Z+9
    012DE 708F      ANDI	R24,0xF
    012DF 7090      ANDI	R25,0
    012E0 3080      CPI	R24,0
    012E1 0789      CPC	R24,R25
    012E2 F011      BEQ	0x12E5
    012E3 E00D      LDI	R16,0xD
    012E4 C36A      RJMP	0x164F
(2099) 
(2100) 	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    012E5 A1ED      LDD	R30,Y+37
    012E6 A1FE      LDD	R31,Y+38
    012E7 5BEF      SUBI	R30,0xBF
    012E8 4FFF      SBCI	R31,0xFF
    012E9 8020      LD	R2,Z
    012EA 54E1      SUBI	R30,0x41
    012EB 40F0      SBCI	R31,0
    012EC 2433      CLR	R3
    012ED 5BEE      SUBI	R30,0xBE
    012EE 4FFF      SBCI	R31,0xFF
    012EF 8040      LD	R4,Z
    012F0 2455      CLR	R5
    012F1 2C54      MOV	R5,R4
    012F2 2444      CLR	R4
    012F3 2842      OR	R4,R2
    012F4 2853      OR	R5,R3
    012F5 0112      MOVW	R2,R4
    012F6 2444      CLR	R4
    012F7 2455      CLR	R5
    012F8 862D      STD	Y+13,R2
    012F9 863E      STD	Y+14,R3
    012FA 864F      STD	Y+15,R4
    012FB 8A58      STD	Y+16,R5
(2101) 	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    012FC 842D      LDD	R2,Y+13
    012FD 843E      LDD	R3,Y+14
    012FE 844F      LDD	R4,Y+15
    012FF 8858      LDD	R5,Y+16
    01300 9488      BCLR	0
    01301 2022      TST	R2
    01302 0432      CPC	R3,R2
    01303 0442      CPC	R4,R2
    01304 0452      CPC	R5,R2
    01305 F009      BEQ	0x1307
    01306 C03C      RJMP	0x1343
    01307 E188      LDI	R24,0x18
    01308 E090      LDI	R25,0
    01309 A1ED      LDD	R30,Y+37
    0130A A1FE      LDD	R31,Y+38
    0130B 5AEF      SUBI	R30,0xAF
    0130C 4FFF      SBCI	R31,0xFF
    0130D 8100      LD	R16,Z
    0130E 2711      CLR	R17
    0130F 2722      CLR	R18
    01310 2733      CLR	R19
    01311 938A      ST	-Y,R24
    01312 940E 3FF6 CALL	lsl32
    01314 0118      MOVW	R2,R16
    01315 0129      MOVW	R4,R18
    01316 A1ED      LDD	R30,Y+37
    01317 A1FE      LDD	R31,Y+38
    01318 5BE0      SUBI	R30,0xB0
    01319 4FFF      SBCI	R31,0xFF
    0131A 8060      LD	R6,Z
    0131B 55E0      SUBI	R30,0x50
    0131C 40F0      SBCI	R31,0
    0131D 2477      CLR	R7
    0131E 2488      CLR	R8
    0131F 2499      CLR	R9
    01320 0143      MOVW	R8,R6
    01321 2466      CLR	R6
    01322 2477      CLR	R7
    01323 2826      OR	R2,R6
    01324 2837      OR	R3,R7
    01325 2848      OR	R4,R8
    01326 2859      OR	R5,R9
    01327 5BE1      SUBI	R30,0xB1
    01328 4FFF      SBCI	R31,0xFF
    01329 8060      LD	R6,Z
    0132A 54EF      SUBI	R30,0x4F
    0132B 40F0      SBCI	R31,0
    0132C 2477      CLR	R7
    0132D 2C76      MOV	R7,R6
    0132E 2466      CLR	R6
    0132F 2488      CLR	R8
    01330 2499      CLR	R9
    01331 2826      OR	R2,R6
    01332 2837      OR	R3,R7
    01333 2848      OR	R4,R8
    01334 2859      OR	R5,R9
    01335 5BE2      SUBI	R30,0xB2
    01336 4FFF      SBCI	R31,0xFF
    01337 8060      LD	R6,Z
    01338 2477      CLR	R7
    01339 2488      CLR	R8
    0133A 2499      CLR	R9
    0133B 2826      OR	R2,R6
    0133C 2837      OR	R3,R7
    0133D 2848      OR	R4,R8
    0133E 2859      OR	R5,R9
    0133F 862D      STD	Y+13,R2
    01340 863E      STD	Y+14,R3
    01341 864F      STD	Y+15,R4
    01342 8A58      STD	Y+16,R5
(2102) 
(2103) 	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    01343 A1ED      LDD	R30,Y+37
    01344 A1FE      LDD	R31,Y+38
    01345 AC24      LDD	R2,Z+60
    01346 2433      CLR	R3
    01347 ACE5      LDD	R14,Z+61
    01348 24FF      CLR	R15
    01349 2CFE      MOV	R15,R14
    0134A 24EE      CLR	R14
    0134B 28E2      OR	R14,R2
    0134C 28F3      OR	R15,R3
(2104) 	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    0134D 20EE      TST	R14
    0134E F421      BNE	0x1353
    0134F 20FF      TST	R15
    01350 F411      BNE	0x1353
    01351 E00D      LDI	R16,0xD
    01352 C2FC      RJMP	0x164F
(2105) 
(2106) 	/* Determine the FAT sub type */
(2107) 	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    01353 802D      LDD	R2,Y+5
    01354 803E      LDD	R3,Y+6
    01355 804F      LDD	R4,Y+7
    01356 8458      LDD	R5,Y+8
    01357 0137      MOVW	R6,R14
    01358 2488      CLR	R8
    01359 2499      CLR	R9
    0135A 0C62      ADD	R6,R2
    0135B 1C73      ADC	R7,R3
    0135C 1C84      ADC	R8,R4
    0135D 1C95      ADC	R9,R5
    0135E A1ED      LDD	R30,Y+37
    0135F A1FE      LDD	R31,Y+38
    01360 9638      ADIW	R30,0x8
    01361 8020      LD	R2,Z
    01362 8031      LDD	R3,Z+1
    01363 9436      LSR	R3
    01364 9427      ROR	R2
    01365 9436      LSR	R3
    01366 9427      ROR	R2
    01367 9436      LSR	R3
    01368 9427      ROR	R2
    01369 9436      LSR	R3
    0136A 9427      ROR	R2
    0136B 2444      CLR	R4
    0136C 2455      CLR	R5
    0136D 0C62      ADD	R6,R2
    0136E 1C73      ADC	R7,R3
    0136F 1C84      ADC	R8,R4
    01370 1C95      ADC	R9,R5
    01371 8A6D      STD	Y+21,R6
    01372 8A7E      STD	Y+22,R7
    01373 8A8F      STD	Y+23,R8
    01374 8E98      STD	Y+24,R9
(2108) 	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    01375 882D      LDD	R2,Y+21
    01376 883E      LDD	R3,Y+22
    01377 884F      LDD	R4,Y+23
    01378 8C58      LDD	R5,Y+24
    01379 846D      LDD	R6,Y+13
    0137A 847E      LDD	R7,Y+14
    0137B 848F      LDD	R8,Y+15
    0137C 8898      LDD	R9,Y+16
    0137D 1462      CP	R6,R2
    0137E 0473      CPC	R7,R3
    0137F 0484      CPC	R8,R4
    01380 0495      CPC	R9,R5
    01381 F410      BCC	0x1384
    01382 E00D      LDI	R16,0xD
    01383 C2CB      RJMP	0x164F
(2109) 	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    01384 882D      LDD	R2,Y+21
    01385 883E      LDD	R3,Y+22
    01386 884F      LDD	R4,Y+23
    01387 8C58      LDD	R5,Y+24
    01388 850D      LDD	R16,Y+13
    01389 851E      LDD	R17,Y+14
    0138A 852F      LDD	R18,Y+15
    0138B 8938      LDD	R19,Y+16
    0138C 1902      SUB	R16,R2
    0138D 0913      SBC	R17,R3
    0138E 0924      SBC	R18,R4
    0138F 0935      SBC	R19,R5
    01390 A1ED      LDD	R30,Y+37
    01391 A1FE      LDD	R31,Y+38
    01392 9632      ADIW	R30,2
    01393 8020      LD	R2,Z
    01394 2433      CLR	R3
    01395 2444      CLR	R4
    01396 2455      CLR	R5
    01397 925A      ST	-Y,R5
    01398 924A      ST	-Y,R4
    01399 923A      ST	-Y,R3
    0139A 922A      ST	-Y,R2
    0139B 940E 3E7A CALL	div32u
    0139D 8709      STD	Y+9,R16
    0139E 871A      STD	Y+10,R17
    0139F 872B      STD	Y+11,R18
    013A0 873C      STD	Y+12,R19
(2110) 	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    013A1 8429      LDD	R2,Y+9
    013A2 843A      LDD	R3,Y+10
    013A3 844B      LDD	R4,Y+11
    013A4 845C      LDD	R5,Y+12
    013A5 9488      BCLR	0
    013A6 2022      TST	R2
    013A7 0432      CPC	R3,R2
    013A8 0442      CPC	R4,R2
    013A9 0452      CPC	R5,R2
    013AA F411      BNE	0x13AD
    013AB E00D      LDI	R16,0xD
    013AC C2A2      RJMP	0x164F
(2111) 	fmt = FS_FAT12;
    013AD 24CC      CLR	R12
    013AE 94C3      INC	R12
(2112) 	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    013AF EF46      LDI	R20,0xF6
    013B0 E05F      LDI	R21,0xF
    013B1 E060      LDI	R22,0
    013B2 E070      LDI	R23,0
    013B3 8429      LDD	R2,Y+9
    013B4 843A      LDD	R3,Y+10
    013B5 844B      LDD	R4,Y+11
    013B6 845C      LDD	R5,Y+12
    013B7 1624      CP	R2,R20
    013B8 0635      CPC	R3,R21
    013B9 0646      CPC	R4,R22
    013BA 0657      CPC	R5,R23
    013BB F010      BCS	0x13BE
    013BC E082      LDI	R24,2
    013BD 2EC8      MOV	R12,R24
(2113) 	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    013BE EF46      LDI	R20,0xF6
    013BF EF5F      LDI	R21,0xFF
    013C0 E060      LDI	R22,0
    013C1 E070      LDI	R23,0
    013C2 8429      LDD	R2,Y+9
    013C3 843A      LDD	R3,Y+10
    013C4 844B      LDD	R4,Y+11
    013C5 845C      LDD	R5,Y+12
    013C6 1624      CP	R2,R20
    013C7 0635      CPC	R3,R21
    013C8 0646      CPC	R4,R22
    013C9 0657      CPC	R5,R23
    013CA F010      BCS	0x13CD
    013CB E083      LDI	R24,3
    013CC 2EC8      MOV	R12,R24
(2114) 
(2115) 	/* Boundaries and Limits */
(2116) 	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    013CD E042      LDI	R20,2
    013CE E050      LDI	R21,0
    013CF E060      LDI	R22,0
    013D0 E070      LDI	R23,0
    013D1 8429      LDD	R2,Y+9
    013D2 843A      LDD	R3,Y+10
    013D3 844B      LDD	R4,Y+11
    013D4 845C      LDD	R5,Y+12
    013D5 0E24      ADD	R2,R20
    013D6 1E35      ADC	R3,R21
    013D7 1E46      ADC	R4,R22
    013D8 1E57      ADC	R5,R23
    013D9 A1ED      LDD	R30,Y+37
    013DA A1FE      LDD	R31,Y+38
    013DB 9676      ADIW	R30,0x16
    013DC 8220      ST	Z,R2
    013DD 8231      STD	Z+1,R3
    013DE 8242      STD	Z+2,R4
    013DF 8253      STD	Z+3,R5
(2117) 	fs->database = bsect + sysect;						/* Data start sector */
    013E0 882D      LDD	R2,Y+21
    013E1 883E      LDD	R3,Y+22
    013E2 884F      LDD	R4,Y+23
    013E3 8C58      LDD	R5,Y+24
    013E4 8869      LDD	R6,Y+17
    013E5 887A      LDD	R7,Y+18
    013E6 888B      LDD	R8,Y+19
    013E7 889C      LDD	R9,Y+20
    013E8 0C62      ADD	R6,R2
    013E9 1C73      ADC	R7,R3
    013EA 1C84      ADC	R8,R4
    013EB 1C95      ADC	R9,R5
    013EC A1ED      LDD	R30,Y+37
    013ED A1FE      LDD	R31,Y+38
    013EE 96B6      ADIW	R30,0x26
    013EF 8260      ST	Z,R6
    013F0 8271      STD	Z+1,R7
    013F1 8282      STD	Z+2,R8
    013F2 8293      STD	Z+3,R9
(2118) 	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    013F3 0117      MOVW	R2,R14
    013F4 2444      CLR	R4
    013F5 2455      CLR	R5
    013F6 8869      LDD	R6,Y+17
    013F7 887A      LDD	R7,Y+18
    013F8 888B      LDD	R8,Y+19
    013F9 889C      LDD	R9,Y+20
    013FA 0C62      ADD	R6,R2
    013FB 1C73      ADC	R7,R3
    013FC 1C84      ADC	R8,R4
    013FD 1C95      ADC	R9,R5
    013FE A1ED      LDD	R30,Y+37
    013FF A1FE      LDD	R31,Y+38
    01400 8E66      STD	Z+30,R6
    01401 8E77      STD	Z+31,R7
    01402 A280      STD	Z+32,R8
    01403 A291      STD	Z+33,R9
(2119) 	if (fmt == FS_FAT32) {
    01404 2D8C      MOV	R24,R12
    01405 3083      CPI	R24,3
    01406 F009      BEQ	0x1408
    01407 C055      RJMP	0x145D
(2120) 		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    01408 8420      LDD	R2,Z+8
    01409 8431      LDD	R3,Z+9
    0140A 2022      TST	R2
    0140B F411      BNE	0x140E
    0140C 2033      TST	R3
    0140D F011      BEQ	0x1410
    0140E E00D      LDI	R16,0xD
    0140F C23F      RJMP	0x164F
(2121) 		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    01410 E188      LDI	R24,0x18
    01411 E090      LDI	R25,0
    01412 A1ED      LDD	R30,Y+37
    01413 A1FE      LDD	R31,Y+38
    01414 5AE3      SUBI	R30,0xA3
    01415 4FFF      SBCI	R31,0xFF
    01416 8100      LD	R16,Z
    01417 2711      CLR	R17
    01418 2722      CLR	R18
    01419 2733      CLR	R19
    0141A 938A      ST	-Y,R24
    0141B 940E 3FF6 CALL	lsl32
    0141D 0118      MOVW	R2,R16
    0141E 0129      MOVW	R4,R18
    0141F A1ED      LDD	R30,Y+37
    01420 A1FE      LDD	R31,Y+38
    01421 5AE4      SUBI	R30,0xA4
    01422 4FFF      SBCI	R31,0xFF
    01423 8060      LD	R6,Z
    01424 55EC      SUBI	R30,0x5C
    01425 40F0      SBCI	R31,0
    01426 2477      CLR	R7
    01427 2488      CLR	R8
    01428 2499      CLR	R9
    01429 0143      MOVW	R8,R6
    0142A 2466      CLR	R6
    0142B 2477      CLR	R7
    0142C 2826      OR	R2,R6
    0142D 2837      OR	R3,R7
    0142E 2848      OR	R4,R8
    0142F 2859      OR	R5,R9
    01430 5AE5      SUBI	R30,0xA5
    01431 4FFF      SBCI	R31,0xFF
    01432 8060      LD	R6,Z
    01433 55EB      SUBI	R30,0x5B
    01434 40F0      SBCI	R31,0
    01435 2477      CLR	R7
    01436 2C76      MOV	R7,R6
    01437 2466      CLR	R6
    01438 2488      CLR	R8
    01439 2499      CLR	R9
    0143A 2826      OR	R2,R6
    0143B 2837      OR	R3,R7
    0143C 2848      OR	R4,R8
    0143D 2859      OR	R5,R9
    0143E 5AE6      SUBI	R30,0xA6
    0143F 4FFF      SBCI	R31,0xFF
    01440 8060      LD	R6,Z
    01441 55EA      SUBI	R30,0x5A
    01442 40F0      SBCI	R31,0
    01443 2477      CLR	R7
    01444 2488      CLR	R8
    01445 2499      CLR	R9
    01446 2826      OR	R2,R6
    01447 2837      OR	R3,R7
    01448 2848      OR	R4,R8
    01449 2859      OR	R5,R9
    0144A A222      STD	Z+34,R2
    0144B A233      STD	Z+35,R3
    0144C A244      STD	Z+36,R4
    0144D A255      STD	Z+37,R5
(2122) 		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    0144E E082      LDI	R24,2
    0144F E090      LDI	R25,0
    01450 9676      ADIW	R30,0x16
    01451 8100      LD	R16,Z
    01452 8111      LDD	R17,Z+1
    01453 8122      LDD	R18,Z+2
    01454 8133      LDD	R19,Z+3
    01455 938A      ST	-Y,R24
    01456 940E 3FF6 CALL	lsl32
    01458 8F09      STD	Y+25,R16
    01459 8F1A      STD	Y+26,R17
    0145A 8F2B      STD	Y+27,R18
    0145B 8F3C      STD	Y+28,R19
(2123) 	} else {
    0145C C06A      RJMP	0x14C7
(2124) 		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    0145D A1ED      LDD	R30,Y+37
    0145E A1FE      LDD	R31,Y+38
    0145F 8420      LDD	R2,Z+8
    01460 8431      LDD	R3,Z+9
    01461 2022      TST	R2
    01462 F421      BNE	0x1467
    01463 2033      TST	R3
    01464 F411      BNE	0x1467
    01465 E00D      LDI	R16,0xD
    01466 C1E8      RJMP	0x164F
(2125) 		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    01467 802D      LDD	R2,Y+5
    01468 803E      LDD	R3,Y+6
    01469 804F      LDD	R4,Y+7
    0146A 8458      LDD	R5,Y+8
    0146B A1ED      LDD	R30,Y+37
    0146C A1FE      LDD	R31,Y+38
    0146D 8C66      LDD	R6,Z+30
    0146E 8C77      LDD	R7,Z+31
    0146F A080      LDD	R8,Z+32
    01470 A091      LDD	R9,Z+33
    01471 0C62      ADD	R6,R2
    01472 1C73      ADC	R7,R3
    01473 1C84      ADC	R8,R4
    01474 1C95      ADC	R9,R5
    01475 A262      STD	Z+34,R6
    01476 A273      STD	Z+35,R7
    01477 A284      STD	Z+36,R8
    01478 A295      STD	Z+37,R9
(2126) 		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
    01479 2D8C      MOV	R24,R12
    0147A 3082      CPI	R24,2
    0147B F471      BNE	0x148A
    0147C 9676      ADIW	R30,0x16
    0147D 8020      LD	R2,Z
    0147E 8031      LDD	R3,Z+1
    0147F 8042      LDD	R4,Z+2
    01480 8053      LDD	R5,Z+3
    01481 0C22      LSL	R2
    01482 1C33      ROL	R3
    01483 1C44      ROL	R4
    01484 1C55      ROL	R5
    01485 8E2D      STD	Y+29,R2
    01486 8E3E      STD	Y+30,R3
    01487 8E4F      STD	Y+31,R4
    01488 A258      STD	Y+32,R5
    01489 C035      RJMP	0x14BF
    0148A A1ED      LDD	R30,Y+37
    0148B A1FE      LDD	R31,Y+38
    0148C 9676      ADIW	R30,0x16
    0148D 8020      LD	R2,Z
    0148E 8031      LDD	R3,Z+1
    0148F 8042      LDD	R4,Z+2
    01490 8053      LDD	R5,Z+3
    01491 A229      STD	Y+33,R2
    01492 A23A      STD	Y+34,R3
    01493 A24B      STD	Y+35,R4
    01494 A25C      STD	Y+36,R5
    01495 E041      LDI	R20,1
    01496 E050      LDI	R21,0
    01497 E060      LDI	R22,0
    01498 E070      LDI	R23,0
    01499 A029      LDD	R2,Y+33
    0149A A03A      LDD	R3,Y+34
    0149B A04B      LDD	R4,Y+35
    0149C A05C      LDD	R5,Y+36
    0149D 2224      AND	R2,R20
    0149E 2235      AND	R3,R21
    0149F 2246      AND	R4,R22
    014A0 2257      AND	R5,R23
    014A1 A069      LDD	R6,Y+33
    014A2 A07A      LDD	R7,Y+34
    014A3 A08B      LDD	R8,Y+35
    014A4 A09C      LDD	R9,Y+36
    014A5 E043      LDI	R20,3
    014A6 E050      LDI	R21,0
    014A7 E060      LDI	R22,0
    014A8 E070      LDI	R23,0
    014A9 929A      ST	-Y,R9
    014AA 928A      ST	-Y,R8
    014AB 927A      ST	-Y,R7
    014AC 926A      ST	-Y,R6
    014AD 018A      MOVW	R16,R20
    014AE 019B      MOVW	R18,R22
    014AF 940E 3F20 CALL	empy32u|empy32s
    014B1 0138      MOVW	R6,R16
    014B2 0149      MOVW	R8,R18
    014B3 9496      LSR	R9
    014B4 9487      ROR	R8
    014B5 9477      ROR	R7
    014B6 9467      ROR	R6
    014B7 0C62      ADD	R6,R2
    014B8 1C73      ADC	R7,R3
    014B9 1C84      ADC	R8,R4
    014BA 1C95      ADC	R9,R5
    014BB 8E6D      STD	Y+29,R6
    014BC 8E7E      STD	Y+30,R7
    014BD 8E8F      STD	Y+31,R8
    014BE A298      STD	Y+32,R9
    014BF 8C2D      LDD	R2,Y+29
    014C0 8C3E      LDD	R3,Y+30
    014C1 8C4F      LDD	R4,Y+31
    014C2 A058      LDD	R5,Y+32
    014C3 8E29      STD	Y+25,R2
    014C4 8E3A      STD	Y+26,R3
    014C5 8E4B      STD	Y+27,R4
    014C6 8E5C      STD	Y+28,R5
(2127) 			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
(2128) 	}
(2129) 	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    014C7 EF4F      LDI	R20,0xFF
    014C8 E051      LDI	R21,1
    014C9 E060      LDI	R22,0
    014CA E070      LDI	R23,0
    014CB 8D09      LDD	R16,Y+25
    014CC 8D1A      LDD	R17,Y+26
    014CD 8D2B      LDD	R18,Y+27
    014CE 8D3C      LDD	R19,Y+28
    014CF 0F04      ADD	R16,R20
    014D0 1F15      ADC	R17,R21
    014D1 1F26      ADC	R18,R22
    014D2 1F37      ADC	R19,R23
    014D3 E089      LDI	R24,0x9
    014D4 E090      LDI	R25,0
    014D5 938A      ST	-Y,R24
    014D6 940E 400F CALL	lsr32
    014D8 A1ED      LDD	R30,Y+37
    014D9 A1FE      LDD	R31,Y+38
    014DA 8C22      LDD	R2,Z+26
    014DB 8C33      LDD	R3,Z+27
    014DC 8C44      LDD	R4,Z+28
    014DD 8C55      LDD	R5,Z+29
    014DE 1620      CP	R2,R16
    014DF 0631      CPC	R3,R17
    014E0 0642      CPC	R4,R18
    014E1 0653      CPC	R5,R19
    014E2 F410      BCC	0x14E5
(2130) 		return FR_NO_FILESYSTEM;
    014E3 E00D      LDI	R16,0xD
    014E4 C16A      RJMP	0x164F
(2131) 
(2132) #if !_FS_READONLY
(2133) 	/* Initialize cluster allocation information */
(2134) 	fs->free_clust = 0xFFFFFFFF;
    014E5 A1ED      LDD	R30,Y+37
    014E6 A1FE      LDD	R31,Y+38
    014E7 963E      ADIW	R30,0xE
    014E8 EF8F      LDI	R24,0xFF
    014E9 8380      ST	Z,R24
    014EA 8381      STD	Z+1,R24
    014EB 8382      STD	Z+2,R24
    014EC 8383      STD	Z+3,R24
(2135) 	fs->last_clust = 0;
    014ED A1ED      LDD	R30,Y+37
    014EE A1FE      LDD	R31,Y+38
    014EF 963A      ADIW	R30,0xA
    014F0 E080      LDI	R24,0
    014F1 8380      ST	Z,R24
    014F2 8381      STD	Z+1,R24
    014F3 8382      STD	Z+2,R24
    014F4 8383      STD	Z+3,R24
(2136) 
(2137) 	/* Get fsinfo if available */
(2138) 	if (fmt == FS_FAT32) {
    014F5 2D8C      MOV	R24,R12
    014F6 3083      CPI	R24,3
    014F7 F009      BEQ	0x14F9
    014F8 C13C      RJMP	0x1635
(2139) 	 	fs->fsi_flag = 0;
    014F9 2422      CLR	R2
    014FA A1ED      LDD	R30,Y+37
    014FB A1FE      LDD	R31,Y+38
    014FC 8225      STD	Z+5,R2
(2140) 		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
    014FD 5AE2      SUBI	R30,0xA2
    014FE 4FFF      SBCI	R31,0xFF
    014FF 8020      LD	R2,Z
    01500 55EE      SUBI	R30,0x5E
    01501 40F0      SBCI	R31,0
    01502 2433      CLR	R3
    01503 5AE1      SUBI	R30,0xA1
    01504 4FFF      SBCI	R31,0xFF
    01505 8040      LD	R4,Z
    01506 2455      CLR	R5
    01507 2C54      MOV	R5,R4
    01508 2444      CLR	R4
    01509 2842      OR	R4,R2
    0150A 2853      OR	R5,R3
    0150B 0112      MOVW	R2,R4
    0150C 2444      CLR	R4
    0150D 2455      CLR	R5
    0150E 8869      LDD	R6,Y+17
    0150F 887A      LDD	R7,Y+18
    01510 888B      LDD	R8,Y+19
    01511 889C      LDD	R9,Y+20
    01512 0C62      ADD	R6,R2
    01513 1C73      ADC	R7,R3
    01514 1C84      ADC	R8,R4
    01515 1C95      ADC	R9,R5
    01516 A1ED      LDD	R30,Y+37
    01517 A1FE      LDD	R31,Y+38
    01518 8A62      STD	Z+18,R6
    01519 8A73      STD	Z+19,R7
    0151A 8A84      STD	Z+20,R8
    0151B 8A95      STD	Z+21,R9
(2141) 		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
    0151C E081      LDI	R24,1
    0151D 838C      STD	Y+4,R24
    0151E 8822      LDD	R2,Z+18
    0151F 8833      LDD	R3,Z+19
    01520 8844      LDD	R4,Z+20
    01521 8855      LDD	R5,Z+21
    01522 8228      ST	Y,R2
    01523 8239      STD	Y+1,R3
    01524 824A      STD	Y+2,R4
    01525 825B      STD	Y+3,R5
    01526 019F      MOVW	R18,R30
    01527 5D22      SUBI	R18,0xD2
    01528 4F3F      SBCI	R19,0xFF
    01529 8101      LDD	R16,Z+1
    0152A 940E 02A1 CALL	_disk_read
    0152C 2EE0      MOV	R14,R16
    0152D 2300      TST	R16
    0152E F009      BEQ	0x1530
    0152F C105      RJMP	0x1635
    01530 A1ED      LDD	R30,Y+37
    01531 A1FE      LDD	R31,Y+38
    01532 5DE4      SUBI	R30,0xD4
    01533 4FFD      SBCI	R31,0xFD
    01534 8020      LD	R2,Z
    01535 52EC      SUBI	R30,0x2C
    01536 40F2      SBCI	R31,2
    01537 2433      CLR	R3
    01538 5DE3      SUBI	R30,0xD3
    01539 4FFD      SBCI	R31,0xFD
    0153A 8180      LD	R24,Z
    0153B 52ED      SUBI	R30,0x2D
    0153C 40F2      SBCI	R31,2
    0153D 2799      CLR	R25
    0153E 2F98      MOV	R25,R24
    0153F 2788      CLR	R24
    01540 2982      OR	R24,R2
    01541 2993      OR	R25,R3
    01542 3585      CPI	R24,0x55
    01543 EAAA      LDI	R26,0xAA
    01544 079A      CPC	R25,R26
    01545 F009      BEQ	0x1547
    01546 C0EE      RJMP	0x1635
    01547 E188      LDI	R24,0x18
    01548 E090      LDI	R25,0
    01549 A901      LDD	R16,Z+49
    0154A 2711      CLR	R17
    0154B 2722      CLR	R18
    0154C 2733      CLR	R19
    0154D 938A      ST	-Y,R24
    0154E 940E 3FF6 CALL	lsl32
    01550 0118      MOVW	R2,R16
    01551 0129      MOVW	R4,R18
    01552 A1ED      LDD	R30,Y+37
    01553 A1FE      LDD	R31,Y+38
    01554 A860      LDD	R6,Z+48
    01555 2477      CLR	R7
    01556 2488      CLR	R8
    01557 2499      CLR	R9
    01558 0143      MOVW	R8,R6
    01559 2466      CLR	R6
    0155A 2477      CLR	R7
    0155B 2826      OR	R2,R6
    0155C 2837      OR	R3,R7
    0155D 2848      OR	R4,R8
    0155E 2859      OR	R5,R9
    0155F A467      LDD	R6,Z+47
    01560 2477      CLR	R7
    01561 2C76      MOV	R7,R6
    01562 2466      CLR	R6
    01563 2488      CLR	R8
    01564 2499      CLR	R9
    01565 2826      OR	R2,R6
    01566 2837      OR	R3,R7
    01567 2848      OR	R4,R8
    01568 2859      OR	R5,R9
    01569 A466      LDD	R6,Z+46
    0156A 2477      CLR	R7
    0156B 2488      CLR	R8
    0156C 2499      CLR	R9
    0156D 2826      OR	R2,R6
    0156E 2837      OR	R3,R7
    0156F 2848      OR	R4,R8
    01570 2859      OR	R5,R9
    01571 E542      LDI	R20,0x52
    01572 E552      LDI	R21,0x52
    01573 E661      LDI	R22,0x61
    01574 E471      LDI	R23,0x41
    01575 1624      CP	R2,R20
    01576 0635      CPC	R3,R21
    01577 0646      CPC	R4,R22
    01578 0657      CPC	R5,R23
    01579 F009      BEQ	0x157B
    0157A C0BA      RJMP	0x1635
    0157B E188      LDI	R24,0x18
    0157C E090      LDI	R25,0
    0157D 5EEB      SUBI	R30,0xEB
    0157E 4FFD      SBCI	R31,0xFD
    0157F 8100      LD	R16,Z
    01580 2711      CLR	R17
    01581 2722      CLR	R18
    01582 2733      CLR	R19
    01583 938A      ST	-Y,R24
    01584 940E 3FF6 CALL	lsl32
    01586 0118      MOVW	R2,R16
    01587 0129      MOVW	R4,R18
    01588 A1ED      LDD	R30,Y+37
    01589 A1FE      LDD	R31,Y+38
    0158A 5EEC      SUBI	R30,0xEC
    0158B 4FFD      SBCI	R31,0xFD
    0158C 8060      LD	R6,Z
    0158D 51E4      SUBI	R30,0x14
    0158E 40F2      SBCI	R31,2
    0158F 2477      CLR	R7
    01590 2488      CLR	R8
    01591 2499      CLR	R9
    01592 0143      MOVW	R8,R6
    01593 2466      CLR	R6
    01594 2477      CLR	R7
    01595 2826      OR	R2,R6
    01596 2837      OR	R3,R7
    01597 2848      OR	R4,R8
    01598 2859      OR	R5,R9
    01599 5EED      SUBI	R30,0xED
    0159A 4FFD      SBCI	R31,0xFD
    0159B 8060      LD	R6,Z
    0159C 51E3      SUBI	R30,0x13
    0159D 40F2      SBCI	R31,2
    0159E 2477      CLR	R7
    0159F 2C76      MOV	R7,R6
    015A0 2466      CLR	R6
    015A1 2488      CLR	R8
    015A2 2499      CLR	R9
    015A3 2826      OR	R2,R6
    015A4 2837      OR	R3,R7
    015A5 2848      OR	R4,R8
    015A6 2859      OR	R5,R9
    015A7 5EEE      SUBI	R30,0xEE
    015A8 4FFD      SBCI	R31,0xFD
    015A9 8060      LD	R6,Z
    015AA 51E2      SUBI	R30,0x12
    015AB 40F2      SBCI	R31,2
    015AC 2477      CLR	R7
    015AD 2488      CLR	R8
    015AE 2499      CLR	R9
    015AF 2826      OR	R2,R6
    015B0 2837      OR	R3,R7
    015B1 2848      OR	R4,R8
    015B2 2859      OR	R5,R9
    015B3 E742      LDI	R20,0x72
    015B4 E752      LDI	R21,0x72
    015B5 E461      LDI	R22,0x41
    015B6 E671      LDI	R23,0x61
    015B7 1624      CP	R2,R20
    015B8 0635      CPC	R3,R21
    015B9 0646      CPC	R4,R22
    015BA 0657      CPC	R5,R23
    015BB F009      BEQ	0x15BD
    015BC C078      RJMP	0x1635
(2142) 			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
(2143) 			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
(2144) 			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
(2145) 				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
    015BD E188      LDI	R24,0x18
    015BE E090      LDI	R25,0
    015BF 5EE3      SUBI	R30,0xE3
    015C0 4FFD      SBCI	R31,0xFD
    015C1 8100      LD	R16,Z
    015C2 2711      CLR	R17
    015C3 2722      CLR	R18
    015C4 2733      CLR	R19
    015C5 938A      ST	-Y,R24
    015C6 940E 3FF6 CALL	lsl32
    015C8 0118      MOVW	R2,R16
    015C9 0129      MOVW	R4,R18
    015CA A1ED      LDD	R30,Y+37
    015CB A1FE      LDD	R31,Y+38
    015CC 5EE4      SUBI	R30,0xE4
    015CD 4FFD      SBCI	R31,0xFD
    015CE 8060      LD	R6,Z
    015CF 51EC      SUBI	R30,0x1C
    015D0 40F2      SBCI	R31,2
    015D1 2477      CLR	R7
    015D2 2488      CLR	R8
    015D3 2499      CLR	R9
    015D4 0143      MOVW	R8,R6
    015D5 2466      CLR	R6
    015D6 2477      CLR	R7
    015D7 2826      OR	R2,R6
    015D8 2837      OR	R3,R7
    015D9 2848      OR	R4,R8
    015DA 2859      OR	R5,R9
    015DB 5EE5      SUBI	R30,0xE5
    015DC 4FFD      SBCI	R31,0xFD
    015DD 8060      LD	R6,Z
    015DE 51EB      SUBI	R30,0x1B
    015DF 40F2      SBCI	R31,2
    015E0 2477      CLR	R7
    015E1 2C76      MOV	R7,R6
    015E2 2466      CLR	R6
    015E3 2488      CLR	R8
    015E4 2499      CLR	R9
    015E5 2826      OR	R2,R6
    015E6 2837      OR	R3,R7
    015E7 2848      OR	R4,R8
    015E8 2859      OR	R5,R9
    015E9 5EE6      SUBI	R30,0xE6
    015EA 4FFD      SBCI	R31,0xFD
    015EB 8060      LD	R6,Z
    015EC 51EA      SUBI	R30,0x1A
    015ED 40F2      SBCI	R31,2
    015EE 2477      CLR	R7
    015EF 2488      CLR	R8
    015F0 2499      CLR	R9
    015F1 2826      OR	R2,R6
    015F2 2837      OR	R3,R7
    015F3 2848      OR	R4,R8
    015F4 2859      OR	R5,R9
    015F5 8622      STD	Z+10,R2
    015F6 8633      STD	Z+11,R3
    015F7 8644      STD	Z+12,R4
    015F8 8655      STD	Z+13,R5
(2146) 				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
    015F9 E188      LDI	R24,0x18
    015FA E090      LDI	R25,0
    015FB 5EE7      SUBI	R30,0xE7
    015FC 4FFD      SBCI	R31,0xFD
    015FD 8100      LD	R16,Z
    015FE 2711      CLR	R17
    015FF 2722      CLR	R18
    01600 2733      CLR	R19
    01601 938A      ST	-Y,R24
    01602 940E 3FF6 CALL	lsl32
    01604 0118      MOVW	R2,R16
    01605 0129      MOVW	R4,R18
    01606 A1ED      LDD	R30,Y+37
    01607 A1FE      LDD	R31,Y+38
    01608 5EE8      SUBI	R30,0xE8
    01609 4FFD      SBCI	R31,0xFD
    0160A 8060      LD	R6,Z
    0160B 51E8      SUBI	R30,0x18
    0160C 40F2      SBCI	R31,2
    0160D 2477      CLR	R7
    0160E 2488      CLR	R8
    0160F 2499      CLR	R9
    01610 0143      MOVW	R8,R6
    01611 2466      CLR	R6
    01612 2477      CLR	R7
    01613 2826      OR	R2,R6
    01614 2837      OR	R3,R7
    01615 2848      OR	R4,R8
    01616 2859      OR	R5,R9
    01617 5EE9      SUBI	R30,0xE9
    01618 4FFD      SBCI	R31,0xFD
    01619 8060      LD	R6,Z
    0161A 51E7      SUBI	R30,0x17
    0161B 40F2      SBCI	R31,2
    0161C 2477      CLR	R7
    0161D 2C76      MOV	R7,R6
    0161E 2466      CLR	R6
    0161F 2488      CLR	R8
    01620 2499      CLR	R9
    01621 2826      OR	R2,R6
    01622 2837      OR	R3,R7
    01623 2848      OR	R4,R8
    01624 2859      OR	R5,R9
    01625 5EEA      SUBI	R30,0xEA
    01626 4FFD      SBCI	R31,0xFD
    01627 8060      LD	R6,Z
    01628 51E6      SUBI	R30,0x16
    01629 40F2      SBCI	R31,2
    0162A 2477      CLR	R7
    0162B 2488      CLR	R8
    0162C 2499      CLR	R9
    0162D 2826      OR	R2,R6
    0162E 2837      OR	R3,R7
    0162F 2848      OR	R4,R8
    01630 2859      OR	R5,R9
    01631 8626      STD	Z+14,R2
    01632 8637      STD	Z+15,R3
    01633 8A40      STD	Z+16,R4
    01634 8A51      STD	Z+17,R5
(2147) 		}
(2148) 	}
(2149) #endif
(2150) 	fs->fs_type = fmt;		/* FAT sub-type */
    01635 A1ED      LDD	R30,Y+37
    01636 A1FE      LDD	R31,Y+38
    01637 82C0      ST	Z,R12
(2151) 	fs->id = ++Fsid;		/* File system mount ID */
    01638 9180 04F4 LDS	R24,ff.c:Fsid
    0163A 9190 04F5 LDS	R25,ff.c:Fsid+1
    0163C 9601      ADIW	R24,1
    0163D 016C      MOVW	R12,R24
    0163E 92D0 04F5 STS	ff.c:Fsid+1,R13
    01640 92C0 04F4 STS	ff.c:Fsid,R12
    01642 82D7      STD	Z+7,R13
    01643 82C6      STD	Z+6,R12
(2152) 	fs->winsect = 0;		/* Invalidate sector cache */
    01644 96BA      ADIW	R30,0x2A
    01645 E080      LDI	R24,0
    01646 8380      ST	Z,R24
    01647 8381      STD	Z+1,R24
    01648 8382      STD	Z+2,R24
    01649 8383      STD	Z+3,R24
(2153) 	fs->wflag = 0;
    0164A 2422      CLR	R2
    0164B A1ED      LDD	R30,Y+37
    0164C A1FE      LDD	R31,Y+38
    0164D 8224      STD	Z+4,R2
(2154) #if _FS_RPATH
(2155) 	fs->cdir = 0;			/* Current directory (root dir) */
(2156) #endif
(2157) #if _FS_SHARE				/* Clear file lock semaphores */
(2158) 	clear_lock(fs);
(2159) #endif
(2160) 
(2161) 	return FR_OK;
    0164E 2700      CLR	R16
    0164F 96A7      ADIW	R28,0x27
    01650 940E 3F69 CALL	pop_xgsetF0FC
    01652 9622      ADIW	R28,2
    01653 9508      RET
ff.c:validate:
  id                   --> R10
  fs                   --> R20
    01654 940E 3F7F CALL	push_xgset300C
    01656 0159      MOVW	R10,R18
    01657 01A8      MOVW	R20,R16
(2162) }
(2163) 
(2164) 
(2165) 
(2166) 
(2167) /*-----------------------------------------------------------------------*/
(2168) /* Check if the file/dir object is valid or not                          */
(2169) /*-----------------------------------------------------------------------*/
(2170) 
(2171) static
(2172) FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
(2173) 	FATFS *fs,		/* Pointer to the file system object */
(2174) 	WORD id			/* Member id of the target object to be checked */
(2175) )
(2176) {
(2177) 	if (!fs || !fs->fs_type || fs->id != id)
    01658 3040      CPI	R20,0
    01659 0745      CPC	R20,R21
    0165A F049      BEQ	0x1664
    0165B 01FA      MOVW	R30,R20
    0165C 8020      LD	R2,Z
    0165D 2022      TST	R2
    0165E F029      BEQ	0x1664
    0165F 8026      LDD	R2,Z+6
    01660 8037      LDD	R3,Z+7
    01661 142A      CP	R2,R10
    01662 043B      CPC	R3,R11
    01663 F011      BEQ	0x1666
(2178) 		return FR_INVALID_OBJECT;
    01664 E009      LDI	R16,0x9
    01665 C009      RJMP	0x166F
(2179) 
(2180) 	ENTER_FF(fs);		/* Lock file system */
(2181) 
(2182) 	if (disk_status(fs->drv) & STA_NOINIT)
    01666 01FA      MOVW	R30,R20
    01667 8101      LDD	R16,Z+1
    01668 940E 029B CALL	_disk_status
    0166A FF00      SBRS	R16,0
    0166B C002      RJMP	0x166E
(2183) 		return FR_NOT_READY;
    0166C E003      LDI	R16,3
    0166D C001      RJMP	0x166F
(2184) 
(2185) 	return FR_OK;
    0166E 2700      CLR	R16
    0166F 940C 3F84 JMP	pop_xgset300C
_f_mount:
  rfs                  --> R10
  fs                   --> R18
  vol                  --> R16
    01671 92AA      ST	-Y,R10
    01672 92BA      ST	-Y,R11
(2186) }
(2187) 
(2188) 
(2189) 
(2190) 
(2191) /*--------------------------------------------------------------------------
(2192) 
(2193)    Public Functions
(2194) 
(2195) --------------------------------------------------------------------------*/
(2196) 
(2197) 
(2198) 
(2199) /*-----------------------------------------------------------------------*/
(2200) /* Mount/Unmount a Logical Drive                                         */
(2201) /*-----------------------------------------------------------------------*/
(2202) 
(2203) FRESULT f_mount (
(2204) 	BYTE vol,		/* Logical drive number to be mounted/unmounted */
(2205) 	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
(2206) )
(2207) {
(2208) 	FATFS *rfs;
(2209) 
(2210) 
(2211) 	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    01673 3001      CPI	R16,1
    01674 F010      BCS	0x1677
(2212) 		return FR_INVALID_DRIVE;
    01675 E00B      LDI	R16,0xB
    01676 C022      RJMP	0x1699
(2213) 	rfs = FatFs[vol];			/* Get current fs object */
    01677 EF86      LDI	R24,0xF6
    01678 E094      LDI	R25,4
    01679 2FE0      MOV	R30,R16
    0167A 27FF      CLR	R31
    0167B 0FEE      LSL	R30
    0167C 1FFF      ROL	R31
    0167D 0FE8      ADD	R30,R24
    0167E 1FF9      ADC	R31,R25
    0167F 80A0      LD	R10,Z
    01680 80B1      LDD	R11,Z+1
(2214) 
(2215) 	if (rfs) {
    01681 20AA      TST	R10
    01682 F411      BNE	0x1685
    01683 20BB      TST	R11
    01684 F019      BEQ	0x1688
(2216) #if _FS_SHARE
(2217) 		clear_lock(rfs);
(2218) #endif
(2219) #if _FS_REENTRANT				/* Discard sync object of the current volume */
(2220) 		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
(2221) #endif
(2222) 		rfs->fs_type = 0;		/* Clear old fs object */
    01685 2422      CLR	R2
    01686 01F5      MOVW	R30,R10
    01687 8220      ST	Z,R2
(2223) 	}
(2224) 
(2225) 	if (fs) {
    01688 3020      CPI	R18,0
    01689 0723      CPC	R18,R19
    0168A F019      BEQ	0x168E
(2226) 		fs->fs_type = 0;		/* Clear new fs object */
    0168B 2422      CLR	R2
    0168C 01F9      MOVW	R30,R18
    0168D 8220      ST	Z,R2
(2227) #if _FS_REENTRANT				/* Create sync object for the new volume */
(2228) 		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
(2229) #endif
(2230) 	}
(2231) 	FatFs[vol] = fs;			/* Register new fs object */
    0168E EF86      LDI	R24,0xF6
    0168F E094      LDI	R25,4
    01690 2FE0      MOV	R30,R16
    01691 27FF      CLR	R31
    01692 0FEE      LSL	R30
    01693 1FFF      ROL	R31
    01694 0FE8      ADD	R30,R24
    01695 1FF9      ADC	R31,R25
    01696 8331      STD	Z+1,R19
    01697 8320      ST	Z,R18
(2232) 
(2233) 	return FR_OK;
    01698 2700      CLR	R16
    01699 90B9      LD	R11,Y+
    0169A 90A9      LD	R10,Y+
    0169B 9508      RET
_f_open:
  cl                   --> Y,+40
  dw                   --> Y,+36
  sfn                  --> Y,+24
  dj                   --> Y,+2
  res                  --> R10
  dir                  --> R14
  mode                 --> Y,+58
  path                 --> Y,+56
  fp                   --> Y,+54
    0169C 940E 3E2F CALL	push_arg4
    0169E 940E 3F74 CALL	push_xgsetF0FC
    016A0 97AC      SBIW	R28,0x2C
(2234) }
(2235) 
(2236) 
(2237) 
(2238) 
(2239) /*-----------------------------------------------------------------------*/
(2240) /* Open or Create a File                                                 */
(2241) /*-----------------------------------------------------------------------*/
(2242) 
(2243) FRESULT f_open (
(2244) 	FIL *fp,			/* Pointer to the blank file object */
(2245) 	const TCHAR *path,	/* Pointer to the file name */
(2246) 	BYTE mode			/* Access mode and file open mode flags */
(2247) )
(2248) {
(2249) 	FRESULT res;
(2250) 	DIR dj;
(2251) 	BYTE *dir;
(2252) 	DEF_NAMEBUF;
(2253) 
(2254) 
(2255) 	fp->fs = 0;			/* Clear file object */
    016A1 2422      CLR	R2
    016A2 2433      CLR	R3
    016A3 A9EE      LDD	R30,Y+54
    016A4 A9FF      LDD	R31,Y+55
    016A5 8231      STD	Z+1,R3
    016A6 8220      ST	Z,R2
(2256) 
(2257) #if !_FS_READONLY
(2258) 	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
    016A7 AD8A      LDD	R24,Y+58
    016A8 718F      ANDI	R24,0x1F
    016A9 AF8A      STD	Y+58,R24
(2259) 	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
    016AA 2799      CLR	R25
    016AB 7F8E      ANDI	R24,0xFE
    016AC 8388      ST	Y,R24
    016AD 019E      MOVW	R18,R28
    016AE 5F2E      SUBI	R18,0xFE
    016AF 4F3F      SBCI	R19,0xFF
    016B0 018E      MOVW	R16,R28
    016B1 5C08      SUBI	R16,0xC8
    016B2 4F1F      SBCI	R17,0xFF
    016B3 DAA6      RCALL	ff.c:chk_mounted
    016B4 2EA0      MOV	R10,R16
(2260) #else
(2261) 	mode &= FA_READ;
(2262) 	res = chk_mounted(&path, &dj.fs, 0);
(2263) #endif
(2264) 	INIT_BUF(dj);
    016B5 01CE      MOVW	R24,R28
    016B6 9648      ADIW	R24,0x18
    016B7 8B9F      STD	Y+23,R25
    016B8 8B8E      STD	Y+22,R24
(2265) 	if (res == FR_OK)
    016B9 2300      TST	R16
    016BA F439      BNE	0x16C2
(2266) 		res = follow_path(&dj, path);	/* Follow the file path */
    016BB AD28      LDD	R18,Y+56
    016BC AD39      LDD	R19,Y+57
    016BD 018E      MOVW	R16,R28
    016BE 5F0E      SUBI	R16,0xFE
    016BF 4F1F      SBCI	R17,0xFF
    016C0 D94D      RCALL	ff.c:follow_path
    016C1 2EA0      MOV	R10,R16
(2267) 	dir = dj.dir;
    016C2 88EC      LDD	R14,Y+20
    016C3 88FD      LDD	R15,Y+21
(2268) 
(2269) #if !_FS_READONLY	/* R/W configuration */
(2270) 	if (res == FR_OK) {
    016C4 20AA      TST	R10
    016C5 F431      BNE	0x16CC
(2271) 		if (!dir)	/* Current dir itself */
    016C6 20EE      TST	R14
    016C7 F421      BNE	0x16CC
    016C8 20FF      TST	R15
    016C9 F411      BNE	0x16CC
(2272) 			res = FR_INVALID_NAME;
    016CA E086      LDI	R24,6
    016CB 2EA8      MOV	R10,R24
(2273) #if _FS_SHARE
(2274) 		else
(2275) 			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2276) #endif
(2277) 	}
(2278) 	/* Create or Open a file */
(2279) 	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
    016CC AD8A      LDD	R24,Y+58
    016CD 718C      ANDI	R24,0x1C
    016CE F409      BNE	0x16D0
    016CF C0C0      RJMP	0x1790
(2280) 		DWORD dw, cl;
(2281) 
(2282) 		if (res != FR_OK) {					/* No file, create new */
    016D0 20AA      TST	R10
    016D1 F081      BEQ	0x16E2
(2283) 			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
    016D2 2D8A      MOV	R24,R10
    016D3 3084      CPI	R24,4
    016D4 F439      BNE	0x16DC
(2284) #if _FS_SHARE
(2285) 				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
(2286) #else
(2287) 				res = dir_register(&dj);
    016D5 018E      MOVW	R16,R28
    016D6 5F0E      SUBI	R16,0xFE
    016D7 4F1F      SBCI	R17,0xFF
    016D8 940E 0E00 CALL	ff.c:dir_register
    016DA 2EC0      MOV	R12,R16
    016DB 2CAC      MOV	R10,R12
(2288) #endif
(2289) 			mode |= FA_CREATE_ALWAYS;		/* File is created */
    016DC AD8A      LDD	R24,Y+58
    016DD 6088      ORI	R24,0x8
    016DE AF8A      STD	Y+58,R24
(2290) 			dir = dj.dir;					/* New entry */
    016DF 88EC      LDD	R14,Y+20
    016E0 88FD      LDD	R15,Y+21
(2291) 		}
    016E1 C00C      RJMP	0x16EE
(2292) 		else {								/* Any object is already existing */
(2293) 			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
    016E2 01F7      MOVW	R30,R14
    016E3 8583      LDD	R24,Z+11
    016E4 7181      ANDI	R24,0x11
    016E5 F019      BEQ	0x16E9
(2294) 				res = FR_DENIED;
    016E6 E087      LDI	R24,7
    016E7 2EA8      MOV	R10,R24
(2295) 			} else {
    016E8 C005      RJMP	0x16EE
(2296) 				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
    016E9 AC0A      LDD	R0,Y+58
    016EA FE02      SBRS	R0,2
    016EB C002      RJMP	0x16EE
(2297) 					res = FR_EXIST;
    016EC E088      LDI	R24,0x8
    016ED 2EA8      MOV	R10,R24
(2298) 			}
(2299) 		}
(2300) 		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
    016EE 20AA      TST	R10
    016EF F009      BEQ	0x16F1
    016F0 C0B1      RJMP	0x17A2
    016F1 AC0A      LDD	R0,Y+58
    016F2 FE03      SBRS	R0,3
    016F3 C0AE      RJMP	0x17A2
(2301) 			dw = get_fattime();					/* Created time */
    016F4 940E 02DE CALL	_get_fattime
    016F6 A30C      STD	Y+36,R16
    016F7 A31D      STD	Y+37,R17
    016F8 A32E      STD	Y+38,R18
    016F9 A33F      STD	Y+39,R19
(2302) 			ST_DWORD(dir+DIR_CrtTime, dw);
    016FA A02C      LDD	R2,Y+36
    016FB A03D      LDD	R3,Y+37
    016FC A04E      LDD	R4,Y+38
    016FD A05F      LDD	R5,Y+39
    016FE 01F7      MOVW	R30,R14
    016FF 8626      STD	Z+14,R2
    01700 2C23      MOV	R2,R3
    01701 2433      CLR	R3
    01702 963F      ADIW	R30,0xF
    01703 8220      ST	Z,R2
    01704 A02C      LDD	R2,Y+36
    01705 A03D      LDD	R3,Y+37
    01706 A04E      LDD	R4,Y+38
    01707 A05F      LDD	R5,Y+39
    01708 0112      MOVW	R2,R4
    01709 2444      CLR	R4
    0170A 2455      CLR	R5
    0170B 01F7      MOVW	R30,R14
    0170C 9670      ADIW	R30,0x10
    0170D 8220      ST	Z,R2
    0170E E188      LDI	R24,0x18
    0170F E090      LDI	R25,0
    01710 A10C      LDD	R16,Y+36
    01711 A11D      LDD	R17,Y+37
    01712 A12E      LDD	R18,Y+38
    01713 A13F      LDD	R19,Y+39
    01714 938A      ST	-Y,R24
    01715 940E 400F CALL	lsr32
    01717 01F7      MOVW	R30,R14
    01718 8B01      STD	Z+17,R16
(2303) 			dir[DIR_Attr] = 0;					/* Reset attribute */
    01719 2422      CLR	R2
    0171A 8623      STD	Z+11,R2
(2304) 			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
    0171B 8E24      STD	Z+28,R2
    0171C 8E25      STD	Z+29,R2
    0171D 8E26      STD	Z+30,R2
    0171E 8E27      STD	Z+31,R2
(2305) 			cl = LD_CLUST(dir);					/* Get start cluster */
    0171F 8C22      LDD	R2,Z+26
    01720 2433      CLR	R3
    01721 8C43      LDD	R4,Z+27
    01722 2455      CLR	R5
    01723 2C54      MOV	R5,R4
    01724 2444      CLR	R4
    01725 2842      OR	R4,R2
    01726 2853      OR	R5,R3
    01727 0112      MOVW	R2,R4
    01728 2444      CLR	R4
    01729 2455      CLR	R5
    0172A 8864      LDD	R6,Z+20
    0172B 2477      CLR	R7
    0172C 9675      ADIW	R30,0x15
    0172D 8080      LD	R8,Z
    0172E 2499      CLR	R9
    0172F 2C98      MOV	R9,R8
    01730 2488      CLR	R8
    01731 2886      OR	R8,R6
    01732 2897      OR	R9,R7
    01733 0134      MOVW	R6,R8
    01734 2488      CLR	R8
    01735 2499      CLR	R9
    01736 0143      MOVW	R8,R6
    01737 2466      CLR	R6
    01738 2477      CLR	R7
    01739 2862      OR	R6,R2
    0173A 2873      OR	R7,R3
    0173B 2884      OR	R8,R4
    0173C 2895      OR	R9,R5
    0173D A668      STD	Y+40,R6
    0173E A679      STD	Y+41,R7
    0173F A68A      STD	Y+42,R8
    01740 A69B      STD	Y+43,R9
(2306) 			ST_CLUST(dir, 0);					/* cluster = 0 */
    01741 2422      CLR	R2
    01742 01F7      MOVW	R30,R14
    01743 8E22      STD	Z+26,R2
    01744 8E23      STD	Z+27,R2
    01745 8A24      STD	Z+20,R2
    01746 8A25      STD	Z+21,R2
(2307) 			dj.fs->wflag = 1;
    01747 E081      LDI	R24,1
    01748 81EA      LDD	R30,Y+2
    01749 81FB      LDD	R31,Y+3
    0174A 9634      ADIW	R30,4
    0174B 8380      ST	Z,R24
(2308) 			if (cl) {							/* Remove the cluster chain if exist */
    0174C A428      LDD	R2,Y+40
    0174D A439      LDD	R3,Y+41
    0174E A44A      LDD	R4,Y+42
    0174F A45B      LDD	R5,Y+43
    01750 9488      BCLR	0
    01751 2022      TST	R2
    01752 0432      CPC	R3,R2
    01753 0442      CPC	R4,R2
    01754 0452      CPC	R5,R2
    01755 F409      BNE	0x1757
    01756 C04B      RJMP	0x17A2
(2309) 				dw = dj.fs->winsect;
    01757 81EA      LDD	R30,Y+2
    01758 81FB      LDD	R31,Y+3
    01759 A422      LDD	R2,Z+42
    0175A A433      LDD	R3,Z+43
    0175B A444      LDD	R4,Z+44
    0175C A455      LDD	R5,Z+45
    0175D A22C      STD	Y+36,R2
    0175E A23D      STD	Y+37,R3
    0175F A24E      STD	Y+38,R4
    01760 A25F      STD	Y+39,R5
(2310) 				res = remove_chain(dj.fs, cl);
    01761 A428      LDD	R2,Y+40
    01762 A439      LDD	R3,Y+41
    01763 A44A      LDD	R4,Y+42
    01764 A45B      LDD	R5,Y+43
    01765 8248      ST	Y,R4
    01766 8259      STD	Y+1,R5
    01767 0191      MOVW	R18,R2
    01768 810A      LDD	R16,Y+2
    01769 811B      LDD	R17,Y+3
    0176A 940E 0814 CALL	ff.c:remove_chain
    0176C 2EC0      MOV	R12,R16
    0176D 2CAC      MOV	R10,R12
(2311) 				if (res == FR_OK) {
    0176E 2300      TST	R16
    0176F F591      BNE	0x17A2
(2312) 					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
    01770 E041      LDI	R20,1
    01771 E050      LDI	R21,0
    01772 E060      LDI	R22,0
    01773 E070      LDI	R23,0
    01774 A428      LDD	R2,Y+40
    01775 A439      LDD	R3,Y+41
    01776 A44A      LDD	R4,Y+42
    01777 A45B      LDD	R5,Y+43
    01778 1A24      SUB	R2,R20
    01779 0A35      SBC	R3,R21
    0177A 0A46      SBC	R4,R22
    0177B 0A57      SBC	R5,R23
    0177C 81EA      LDD	R30,Y+2
    0177D 81FB      LDD	R31,Y+3
    0177E 8622      STD	Z+10,R2
    0177F 8633      STD	Z+11,R3
    01780 8644      STD	Z+12,R4
    01781 8655      STD	Z+13,R5
(2313) 					res = move_window(dj.fs, dw);
    01782 A02C      LDD	R2,Y+36
    01783 A03D      LDD	R3,Y+37
    01784 A04E      LDD	R4,Y+38
    01785 A05F      LDD	R5,Y+39
    01786 8248      ST	Y,R4
    01787 8259      STD	Y+1,R5
    01788 0191      MOVW	R18,R2
    01789 810A      LDD	R16,Y+2
    0178A 811B      LDD	R17,Y+3
    0178B 940E 033C CALL	ff.c:move_window
    0178D 2EC0      MOV	R12,R16
    0178E 2CAC      MOV	R10,R12
(2314) 				}
(2315) 			}
(2316) 		}
(2317) 	}
    0178F C012      RJMP	0x17A2
(2318) 	else {	/* Open an existing file */
(2319) 		if (res == FR_OK) {						/* Follow succeeded */
    01790 20AA      TST	R10
    01791 F481      BNE	0x17A2
(2320) 			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
    01792 01F7      MOVW	R30,R14
    01793 8423      LDD	R2,Z+11
    01794 FE24      SBRS	R2,4
    01795 C003      RJMP	0x1799
(2321) 				res = FR_NO_FILE;
    01796 E084      LDI	R24,4
    01797 2EA8      MOV	R10,R24
(2322) 			} else {
    01798 C009      RJMP	0x17A2
(2323) 				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
    01799 AC0A      LDD	R0,Y+58
    0179A FE01      SBRS	R0,1
    0179B C006      RJMP	0x17A2
    0179C 01F7      MOVW	R30,R14
    0179D 8423      LDD	R2,Z+11
    0179E FE20      SBRS	R2,0
    0179F C002      RJMP	0x17A2
(2324) 					res = FR_DENIED;
    017A0 E087      LDI	R24,7
    017A1 2EA8      MOV	R10,R24
(2325) 			}
(2326) 		}
(2327) 	}
(2328) 	if (res == FR_OK) {
    017A2 20AA      TST	R10
    017A3 F4A1      BNE	0x17B8
(2329) 		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
    017A4 AC0A      LDD	R0,Y+58
    017A5 FE03      SBRS	R0,3
    017A6 C003      RJMP	0x17AA
(2330) 			mode |= FA__WRITTEN;
    017A7 2D80      MOV	R24,R0
    017A8 6280      ORI	R24,0x20
    017A9 AF8A      STD	Y+58,R24
(2331) 		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
    017AA 81EA      LDD	R30,Y+2
    017AB 81FB      LDD	R31,Y+3
    017AC A422      LDD	R2,Z+42
    017AD A433      LDD	R3,Z+43
    017AE A444      LDD	R4,Z+44
    017AF A455      LDD	R5,Z+45
    017B0 A9EE      LDD	R30,Y+54
    017B1 A9FF      LDD	R31,Y+55
    017B2 8E22      STD	Z+26,R2
    017B3 8E33      STD	Z+27,R3
    017B4 8E44      STD	Z+28,R4
    017B5 8E55      STD	Z+29,R5
(2332) 		fp->dir_ptr = dir;
    017B6 8EF7      STD	Z+31,R15
    017B7 8EE6      STD	Z+30,R14
(2333) #if _FS_SHARE
(2334) 		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
(2335) 		if (!fp->lockid) res = FR_INT_ERR;
(2336) #endif
(2337) 	}
(2338) 
(2339) #else				/* R/O configuration */
(2340) 	if (res == FR_OK) {					/* Follow succeeded */
(2341) 		if (!dir) {						/* Current dir itself */
(2342) 			res = FR_INVALID_NAME;
(2343) 		} else {
(2344) 			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
(2345) 				res = FR_NO_FILE;
(2346) 		}
(2347) 	}
(2348) #endif
(2349) 	FREE_BUF();
(2350) 
(2351) 	if (res == FR_OK) {
    017B8 20AA      TST	R10
    017B9 F009      BEQ	0x17BB
    017BA C077      RJMP	0x1832
(2352) 		fp->flag = mode;					/* File access mode */
    017BB A9EE      LDD	R30,Y+54
    017BC A9FF      LDD	R31,Y+55
    017BD AC0A      LDD	R0,Y+58
    017BE 8204      STD	Z+4,R0
(2353) 		fp->sclust = LD_CLUST(dir);			/* File start cluster */
    017BF 01F7      MOVW	R30,R14
    017C0 8C22      LDD	R2,Z+26
    017C1 2433      CLR	R3
    017C2 8C43      LDD	R4,Z+27
    017C3 2455      CLR	R5
    017C4 2C54      MOV	R5,R4
    017C5 2444      CLR	R4
    017C6 2842      OR	R4,R2
    017C7 2853      OR	R5,R3
    017C8 0112      MOVW	R2,R4
    017C9 2444      CLR	R4
    017CA 2455      CLR	R5
    017CB 8864      LDD	R6,Z+20
    017CC 2477      CLR	R7
    017CD 8885      LDD	R8,Z+21
    017CE 2499      CLR	R9
    017CF 2C98      MOV	R9,R8
    017D0 2488      CLR	R8
    017D1 2886      OR	R8,R6
    017D2 2897      OR	R9,R7
    017D3 0134      MOVW	R6,R8
    017D4 2488      CLR	R8
    017D5 2499      CLR	R9
    017D6 0143      MOVW	R8,R6
    017D7 2466      CLR	R6
    017D8 2477      CLR	R7
    017D9 2862      OR	R6,R2
    017DA 2873      OR	R7,R3
    017DB 2884      OR	R8,R4
    017DC 2895      OR	R9,R5
    017DD A9EE      LDD	R30,Y+54
    017DE A9FF      LDD	R31,Y+55
    017DF 8666      STD	Z+14,R6
    017E0 8677      STD	Z+15,R7
    017E1 8A80      STD	Z+16,R8
    017E2 8A91      STD	Z+17,R9
(2354) 		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    017E3 E188      LDI	R24,0x18
    017E4 E090      LDI	R25,0
    017E5 01F7      MOVW	R30,R14
    017E6 8D07      LDD	R16,Z+31
    017E7 2711      CLR	R17
    017E8 2722      CLR	R18
    017E9 2733      CLR	R19
    017EA 938A      ST	-Y,R24
    017EB 940E 3FF6 CALL	lsl32
    017ED 0118      MOVW	R2,R16
    017EE 0129      MOVW	R4,R18
    017EF 01F7      MOVW	R30,R14
    017F0 8C66      LDD	R6,Z+30
    017F1 2477      CLR	R7
    017F2 2488      CLR	R8
    017F3 2499      CLR	R9
    017F4 0143      MOVW	R8,R6
    017F5 2466      CLR	R6
    017F6 2477      CLR	R7
    017F7 2826      OR	R2,R6
    017F8 2837      OR	R3,R7
    017F9 2848      OR	R4,R8
    017FA 2859      OR	R5,R9
    017FB 8C65      LDD	R6,Z+29
    017FC 2477      CLR	R7
    017FD 2C76      MOV	R7,R6
    017FE 2466      CLR	R6
    017FF 2488      CLR	R8
    01800 2499      CLR	R9
    01801 2826      OR	R2,R6
    01802 2837      OR	R3,R7
    01803 2848      OR	R4,R8
    01804 2859      OR	R5,R9
    01805 8C64      LDD	R6,Z+28
    01806 2477      CLR	R7
    01807 2488      CLR	R8
    01808 2499      CLR	R9
    01809 2826      OR	R2,R6
    0180A 2837      OR	R3,R7
    0180B 2848      OR	R4,R8
    0180C 2859      OR	R5,R9
    0180D A9EE      LDD	R30,Y+54
    0180E A9FF      LDD	R31,Y+55
    0180F 8622      STD	Z+10,R2
    01810 8633      STD	Z+11,R3
    01811 8644      STD	Z+12,R4
    01812 8655      STD	Z+13,R5
(2355) 		fp->fptr = 0;						/* File pointer */
    01813 9636      ADIW	R30,6
    01814 E080      LDI	R24,0
    01815 8380      ST	Z,R24
    01816 8381      STD	Z+1,R24
    01817 8382      STD	Z+2,R24
    01818 8383      STD	Z+3,R24
(2356) 		fp->dsect = 0;
    01819 A9EE      LDD	R30,Y+54
    0181A A9FF      LDD	R31,Y+55
    0181B 9676      ADIW	R30,0x16
    0181C E080      LDI	R24,0
    0181D 8380      ST	Z,R24
    0181E 8381      STD	Z+1,R24
    0181F 8382      STD	Z+2,R24
    01820 8383      STD	Z+3,R24
(2357) #if _USE_FASTSEEK
(2358) 		fp->cltbl = 0;						/* Normal seek mode */
    01821 2422      CLR	R2
    01822 2433      CLR	R3
    01823 A9EE      LDD	R30,Y+54
    01824 A9FF      LDD	R31,Y+55
    01825 A231      STD	Z+33,R3
    01826 A220      STD	Z+32,R2
(2359) #endif
(2360) 		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    01827 802A      LDD	R2,Y+2
    01828 803B      LDD	R3,Y+3
    01829 8231      STD	Z+1,R3
    0182A 8220      ST	Z,R2
    0182B 01F1      MOVW	R30,R2
    0182C 8026      LDD	R2,Z+6
    0182D 8037      LDD	R3,Z+7
    0182E A9EE      LDD	R30,Y+54
    0182F A9FF      LDD	R31,Y+55
    01830 8233      STD	Z+3,R3
    01831 8222      STD	Z+2,R2
(2361) 	}
(2362) 
(2363) 	LEAVE_FF(dj.fs, res);
    01832 2D0A      MOV	R16,R10
    01833 96AC      ADIW	R28,0x2C
    01834 940E 3F69 CALL	pop_xgsetF0FC
    01836 9624      ADIW	R28,4
    01837 9508      RET
_f_read:
  remain               --> Y,+13
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  rbuff                --> R14
  sect                 --> Y,+5
  rcnt                 --> R12
  br                   --> Y,+33
  btr                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01838 940E 3E2F CALL	push_arg4
    0183A 940E 3F74 CALL	push_xgsetF0FC
    0183C 0159      MOVW	R10,R18
    0183D 9761      SBIW	R28,0x11
(2364) }
(2365) 
(2366) 
(2367) 
(2368) 
(2369) /*-----------------------------------------------------------------------*/
(2370) /* Read File                                                             */
(2371) /*-----------------------------------------------------------------------*/
(2372) 
(2373) FRESULT f_read (
(2374) 	FIL *fp, 		/* Pointer to the file object */
(2375) 	void *buff,		/* Pointer to data buffer */
(2376) 	UINT btr,		/* Number of bytes to read */
(2377) 	UINT *br		/* Pointer to number of bytes read */
(2378) )
(2379) {
(2380) 	FRESULT res;
(2381) 	DWORD clst, sect, remain;
(2382) 	UINT rcnt, cc;
(2383) 	BYTE csect, *rbuff = buff;
    0183E 0175      MOVW	R14,R10
(2384) 
(2385) 	memset(buff,0,512);
    0183F E080      LDI	R24,0
    01840 E092      LDI	R25,2
    01841 8399      STD	Y+1,R25
    01842 8388      ST	Y,R24
    01843 2722      CLR	R18
    01844 2733      CLR	R19
    01845 0185      MOVW	R16,R10
    01846 940E 3E0B CALL	_memset
(2386) 
(2387) 	*br = 0;	/* Initialize byte counter */
    01848 2422      CLR	R2
    01849 2433      CLR	R3
    0184A A1E9      LDD	R30,Y+33
    0184B A1FA      LDD	R31,Y+34
    0184C 8231      STD	Z+1,R3
    0184D 8220      ST	Z,R2
(2388) 
(2389) 	res = validate(fp->fs, fp->id);				/* Check validity */
    0184E 8DEB      LDD	R30,Y+27
    0184F 8DFC      LDD	R31,Y+28
    01850 8122      LDD	R18,Z+2
    01851 8133      LDD	R19,Z+3
    01852 8100      LD	R16,Z
    01853 8111      LDD	R17,Z+1
    01854 DDFF      RCALL	ff.c:validate
    01855 2EA0      MOV	R10,R16
(2390) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01856 2300      TST	R16
    01857 F009      BEQ	0x1859
    01858 C245      RJMP	0x1A9E
(2391) 	if (fp->flag & FA__ERROR)					/* Aborted file? */
    01859 8DEB      LDD	R30,Y+27
    0185A 8DFC      LDD	R31,Y+28
    0185B 8024      LDD	R2,Z+4
    0185C FE27      SBRS	R2,7
    0185D C002      RJMP	0x1860
(2392) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    0185E E002      LDI	R16,2
    0185F C23E      RJMP	0x1A9E
(2393) 	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    01860 8DEB      LDD	R30,Y+27
    01861 8DFC      LDD	R31,Y+28
    01862 8024      LDD	R2,Z+4
    01863 FC20      SBRC	R2,0
    01864 C002      RJMP	0x1867
(2394) 		LEAVE_FF(fp->fs, FR_DENIED);
    01865 E007      LDI	R16,7
    01866 C237      RJMP	0x1A9E
(2395) 	remain = fp->fsize - fp->fptr;
    01867 8DEB      LDD	R30,Y+27
    01868 8DFC      LDD	R31,Y+28
    01869 8026      LDD	R2,Z+6
    0186A 8037      LDD	R3,Z+7
    0186B 8440      LDD	R4,Z+8
    0186C 8451      LDD	R5,Z+9
    0186D 963A      ADIW	R30,0xA
    0186E 8060      LD	R6,Z
    0186F 8071      LDD	R7,Z+1
    01870 8082      LDD	R8,Z+2
    01871 8093      LDD	R9,Z+3
    01872 1862      SUB	R6,R2
    01873 0873      SBC	R7,R3
    01874 0884      SBC	R8,R4
    01875 0895      SBC	R9,R5
    01876 866D      STD	Y+13,R6
    01877 867E      STD	Y+14,R7
    01878 868F      STD	Y+15,R8
    01879 8A98      STD	Y+16,R9
(2396) 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    0187A 842D      LDD	R2,Y+13
    0187B 843E      LDD	R3,Y+14
    0187C 844F      LDD	R4,Y+15
    0187D 8858      LDD	R5,Y+16
    0187E 8C6F      LDD	R6,Y+31
    0187F A078      LDD	R7,Y+32
    01880 2488      CLR	R8
    01881 2499      CLR	R9
    01882 1426      CP	R2,R6
    01883 0437      CPC	R3,R7
    01884 0448      CPC	R4,R8
    01885 0459      CPC	R5,R9
    01886 F008      BCS	0x1888
    01887 C20D      RJMP	0x1A95
    01888 A238      STD	Y+32,R3
    01889 8E2F      STD	Y+31,R2
(2397) 
(2398) 	for ( ;  btr;								/* Repeat until all data read */
    0188A C20A      RJMP	0x1A95
(2399) 		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
(2400) 		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    0188B EF4F      LDI	R20,0xFF
    0188C E051      LDI	R21,1
    0188D E060      LDI	R22,0
    0188E E070      LDI	R23,0
    0188F 8DEB      LDD	R30,Y+27
    01890 8DFC      LDD	R31,Y+28
    01891 9636      ADIW	R30,6
    01892 8020      LD	R2,Z
    01893 8031      LDD	R3,Z+1
    01894 8042      LDD	R4,Z+2
    01895 8053      LDD	R5,Z+3
    01896 2224      AND	R2,R20
    01897 2235      AND	R3,R21
    01898 2246      AND	R4,R22
    01899 2257      AND	R5,R23
    0189A 9488      BCLR	0
    0189B 2022      TST	R2
    0189C 0432      CPC	R3,R2
    0189D 0442      CPC	R4,R2
    0189E 0452      CPC	R5,R2
    0189F F009      BEQ	0x18A1
    018A0 C180      RJMP	0x1A21
(2401) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    018A1 E089      LDI	R24,0x9
    018A2 E090      LDI	R25,0
    018A3 8DEB      LDD	R30,Y+27
    018A4 8DFC      LDD	R31,Y+28
    018A5 8106      LDD	R16,Z+6
    018A6 8117      LDD	R17,Z+7
    018A7 8520      LDD	R18,Z+8
    018A8 8531      LDD	R19,Z+9
    018A9 938A      ST	-Y,R24
    018AA 940E 400F CALL	lsr32
    018AC 0118      MOVW	R2,R16
    018AD 0129      MOVW	R4,R18
    018AE 8DEB      LDD	R30,Y+27
    018AF 8DFC      LDD	R31,Y+28
    018B0 93AF      PUSH	R26
    018B1 93BF      PUSH	R27
    018B2 81A0      LD	R26,Z
    018B3 81B1      LDD	R27,Z+1
    018B4 01FD      MOVW	R30,R26
    018B5 91BF      POP	R27
    018B6 91AF      POP	R26
    018B7 8182      LDD	R24,Z+2
    018B8 2799      CLR	R25
    018B9 9701      SBIW	R24,1
    018BA 013C      MOVW	R6,R24
    018BB 2488      CLR	R8
    018BC FC77      SBRC	R7,7
    018BD 9480      COM	R8
    018BE 2499      CLR	R9
    018BF FC87      SBRC	R8,7
    018C0 9490      COM	R9
    018C1 2026      AND	R2,R6
    018C2 2037      AND	R3,R7
    018C3 2048      AND	R4,R8
    018C4 2059      AND	R5,R9
    018C5 2CC2      MOV	R12,R2
(2402) 			if (!csect) {						/* On the cluster boundary? */
    018C6 2022      TST	R2
    018C7 F009      BEQ	0x18C9
    018C8 C078      RJMP	0x1941
(2403) 				if (fp->fptr == 0) {			/* On the top of the file? */
    018C9 8DEB      LDD	R30,Y+27
    018CA 8DFC      LDD	R31,Y+28
    018CB 9636      ADIW	R30,6
    018CC 8020      LD	R2,Z
    018CD 8031      LDD	R3,Z+1
    018CE 8042      LDD	R4,Z+2
    018CF 8053      LDD	R5,Z+3
    018D0 9488      BCLR	0
    018D1 2022      TST	R2
    018D2 0432      CPC	R3,R2
    018D3 0442      CPC	R4,R2
    018D4 0452      CPC	R5,R2
    018D5 F461      BNE	0x18E2
(2404) 					clst = fp->sclust;			/* Follow from the origin */
    018D6 8DEB      LDD	R30,Y+27
    018D7 8DFC      LDD	R31,Y+28
    018D8 963E      ADIW	R30,0xE
    018D9 8020      LD	R2,Z
    018DA 8031      LDD	R3,Z+1
    018DB 8042      LDD	R4,Z+2
    018DC 8053      LDD	R5,Z+3
    018DD 8629      STD	Y+9,R2
    018DE 863A      STD	Y+10,R3
    018DF 864B      STD	Y+11,R4
    018E0 865C      STD	Y+12,R5
(2405) 				} else {						/* Middle or end of the file */
    018E1 C028      RJMP	0x190A
(2406) #if _USE_FASTSEEK
(2407) 					if (fp->cltbl)
    018E2 8DEB      LDD	R30,Y+27
    018E3 8DFC      LDD	R31,Y+28
    018E4 A020      LDD	R2,Z+32
    018E5 A031      LDD	R3,Z+33
    018E6 2022      TST	R2
    018E7 F411      BNE	0x18EA
    018E8 2033      TST	R3
    018E9 F079      BEQ	0x18F9
(2408) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    018EA 8026      LDD	R2,Z+6
    018EB 8037      LDD	R3,Z+7
    018EC 8440      LDD	R4,Z+8
    018ED 8451      LDD	R5,Z+9
    018EE 8248      ST	Y,R4
    018EF 8259      STD	Y+1,R5
    018F0 0191      MOVW	R18,R2
    018F1 018F      MOVW	R16,R30
    018F2 940E 0A3F CALL	ff.c:clmt_clust
    018F4 8709      STD	Y+9,R16
    018F5 871A      STD	Y+10,R17
    018F6 872B      STD	Y+11,R18
    018F7 873C      STD	Y+12,R19
    018F8 C011      RJMP	0x190A
(2409) 					else
(2410) #endif
(2411) 						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    018F9 8DEB      LDD	R30,Y+27
    018FA 8DFC      LDD	R31,Y+28
    018FB 8822      LDD	R2,Z+18
    018FC 8833      LDD	R3,Z+19
    018FD 8844      LDD	R4,Z+20
    018FE 8855      LDD	R5,Z+21
    018FF 8248      ST	Y,R4
    01900 8259      STD	Y+1,R5
    01901 0191      MOVW	R18,R2
    01902 8100      LD	R16,Z
    01903 8111      LDD	R17,Z+1
    01904 940E 0505 CALL	_get_fat
    01906 8709      STD	Y+9,R16
    01907 871A      STD	Y+10,R17
    01908 872B      STD	Y+11,R18
    01909 873C      STD	Y+12,R19
(2412) 				}
(2413) 				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    0190A E042      LDI	R20,2
    0190B E050      LDI	R21,0
    0190C E060      LDI	R22,0
    0190D E070      LDI	R23,0
    0190E 8429      LDD	R2,Y+9
    0190F 843A      LDD	R3,Y+10
    01910 844B      LDD	R4,Y+11
    01911 845C      LDD	R5,Y+12
    01912 1624      CP	R2,R20
    01913 0635      CPC	R3,R21
    01914 0646      CPC	R4,R22
    01915 0657      CPC	R5,R23
    01916 F448      BCC	0x1920
    01917 8D8B      LDD	R24,Y+27
    01918 8D9C      LDD	R25,Y+28
    01919 9604      ADIW	R24,4
    0191A 01FC      MOVW	R30,R24
    0191B 8180      LD	R24,Z
    0191C 6880      ORI	R24,0x80
    0191D 8380      ST	Z,R24
    0191E E002      LDI	R16,2
    0191F C17E      RJMP	0x1A9E
(2414) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01920 EF4F      LDI	R20,0xFF
    01921 EF5F      LDI	R21,0xFF
    01922 EF6F      LDI	R22,0xFF
    01923 EF7F      LDI	R23,0xFF
    01924 8429      LDD	R2,Y+9
    01925 843A      LDD	R3,Y+10
    01926 844B      LDD	R4,Y+11
    01927 845C      LDD	R5,Y+12
    01928 1624      CP	R2,R20
    01929 0635      CPC	R3,R21
    0192A 0646      CPC	R4,R22
    0192B 0657      CPC	R5,R23
    0192C F451      BNE	0x1937
    0192D 8D8B      LDD	R24,Y+27
    0192E 8D9C      LDD	R25,Y+28
    0192F 9604      ADIW	R24,4
    01930 015C      MOVW	R10,R24
    01931 01FC      MOVW	R30,R24
    01932 8180      LD	R24,Z
    01933 6880      ORI	R24,0x80
    01934 8380      ST	Z,R24
    01935 E001      LDI	R16,1
    01936 C167      RJMP	0x1A9E
(2415) 				fp->clust = clst;				/* Update current cluster */
    01937 8429      LDD	R2,Y+9
    01938 843A      LDD	R3,Y+10
    01939 844B      LDD	R4,Y+11
    0193A 845C      LDD	R5,Y+12
    0193B 8DEB      LDD	R30,Y+27
    0193C 8DFC      LDD	R31,Y+28
    0193D 8A22      STD	Z+18,R2
    0193E 8A33      STD	Z+19,R3
    0193F 8A44      STD	Z+20,R4
    01940 8A55      STD	Z+21,R5
(2416) 			}
(2417) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01941 8DEB      LDD	R30,Y+27
    01942 8DFC      LDD	R31,Y+28
    01943 8822      LDD	R2,Z+18
    01944 8833      LDD	R3,Z+19
    01945 8844      LDD	R4,Z+20
    01946 8855      LDD	R5,Z+21
    01947 8248      ST	Y,R4
    01948 8259      STD	Y+1,R5
    01949 0191      MOVW	R18,R2
    0194A 8100      LD	R16,Z
    0194B 8111      LDD	R17,Z+1
    0194C 940E 04B3 CALL	_clust2sect
    0194E 830D      STD	Y+5,R16
    0194F 831E      STD	Y+6,R17
    01950 832F      STD	Y+7,R18
    01951 8738      STD	Y+8,R19
(2418) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01952 802D      LDD	R2,Y+5
    01953 803E      LDD	R3,Y+6
    01954 804F      LDD	R4,Y+7
    01955 8458      LDD	R5,Y+8
    01956 9488      BCLR	0
    01957 2022      TST	R2
    01958 0432      CPC	R3,R2
    01959 0442      CPC	R4,R2
    0195A 0452      CPC	R5,R2
    0195B F451      BNE	0x1966
    0195C 8D8B      LDD	R24,Y+27
    0195D 8D9C      LDD	R25,Y+28
    0195E 9604      ADIW	R24,4
    0195F 015C      MOVW	R10,R24
    01960 01FC      MOVW	R30,R24
    01961 8180      LD	R24,Z
    01962 6880      ORI	R24,0x80
    01963 8380      ST	Z,R24
    01964 E002      LDI	R16,2
    01965 C138      RJMP	0x1A9E
(2419) 			sect += csect;
    01966 2C2C      MOV	R2,R12
    01967 2433      CLR	R3
    01968 2444      CLR	R4
    01969 2455      CLR	R5
    0196A 806D      LDD	R6,Y+5
    0196B 807E      LDD	R7,Y+6
    0196C 808F      LDD	R8,Y+7
    0196D 8498      LDD	R9,Y+8
    0196E 0C62      ADD	R6,R2
    0196F 1C73      ADC	R7,R3
    01970 1C84      ADC	R8,R4
    01971 1C95      ADC	R9,R5
    01972 826D      STD	Y+5,R6
    01973 827E      STD	Y+6,R7
    01974 828F      STD	Y+7,R8
    01975 8698      STD	Y+8,R9
(2420) 			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    01976 E029      LDI	R18,0x9
    01977 E030      LDI	R19,0
    01978 8D0F      LDD	R16,Y+31
    01979 A118      LDD	R17,Y+32
    0197A 940E 4008 CALL	lsr16
    0197C 0158      MOVW	R10,R16
(2421) 			if (cc) {							/* Read maximum contiguous sectors directly */
    0197D 3000      CPI	R16,0
    0197E 0701      CPC	R16,R17
    0197F F409      BNE	0x1981
    01980 C096      RJMP	0x1A17
(2422) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01981 2C2C      MOV	R2,R12
    01982 2433      CLR	R3
    01983 0E20      ADD	R2,R16
    01984 1E31      ADC	R3,R17
    01985 8DEB      LDD	R30,Y+27
    01986 8DFC      LDD	R31,Y+28
    01987 93AF      PUSH	R26
    01988 93BF      PUSH	R27
    01989 81A0      LD	R26,Z
    0198A 81B1      LDD	R27,Z+1
    0198B 01FD      MOVW	R30,R26
    0198C 91BF      POP	R27
    0198D 91AF      POP	R26
    0198E 8042      LDD	R4,Z+2
    0198F 2455      CLR	R5
    01990 1442      CP	R4,R2
    01991 0453      CPC	R5,R3
    01992 F478      BCC	0x19A2
(2423) 					cc = fp->fs->csize - csect;
    01993 2C2C      MOV	R2,R12
    01994 2433      CLR	R3
    01995 8DEB      LDD	R30,Y+27
    01996 8DFC      LDD	R31,Y+28
    01997 93AF      PUSH	R26
    01998 93BF      PUSH	R27
    01999 81A0      LD	R26,Z
    0199A 81B1      LDD	R27,Z+1
    0199B 01FD      MOVW	R30,R26
    0199C 91BF      POP	R27
    0199D 91AF      POP	R26
    0199E 80A2      LDD	R10,Z+2
    0199F 24BB      CLR	R11
    019A0 18A2      SUB	R10,R2
    019A1 08B3      SBC	R11,R3
(2424) 				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    019A2 82AC      STD	Y+4,R10
    019A3 802D      LDD	R2,Y+5
    019A4 803E      LDD	R3,Y+6
    019A5 804F      LDD	R4,Y+7
    019A6 8458      LDD	R5,Y+8
    019A7 8228      ST	Y,R2
    019A8 8239      STD	Y+1,R3
    019A9 824A      STD	Y+2,R4
    019AA 825B      STD	Y+3,R5
    019AB 0197      MOVW	R18,R14
    019AC 8DEB      LDD	R30,Y+27
    019AD 8DFC      LDD	R31,Y+28
    019AE 93AF      PUSH	R26
    019AF 93BF      PUSH	R27
    019B0 81A0      LD	R26,Z
    019B1 81B1      LDD	R27,Z+1
    019B2 01FD      MOVW	R30,R26
    019B3 91BF      POP	R27
    019B4 91AF      POP	R26
    019B5 8101      LDD	R16,Z+1
    019B6 940E 02A1 CALL	_disk_read
    019B8 2EC0      MOV	R12,R16
    019B9 2300      TST	R16
    019BA F051      BEQ	0x19C5
(2425) 					ABORT(fp->fs, FR_DISK_ERR);
    019BB 8D8B      LDD	R24,Y+27
    019BC 8D9C      LDD	R25,Y+28
    019BD 9604      ADIW	R24,4
    019BE 016C      MOVW	R12,R24
    019BF 01FC      MOVW	R30,R24
    019C0 8180      LD	R24,Z
    019C1 6880      ORI	R24,0x80
    019C2 8380      ST	Z,R24
    019C3 E001      LDI	R16,1
    019C4 C0D9      RJMP	0x1A9E
(2426) #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
(2427) #if _FS_TINY
(2428) 				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
    019C5 8DEB      LDD	R30,Y+27
    019C6 8DFC      LDD	R31,Y+28
    019C7 80C0      LD	R12,Z
    019C8 80D1      LDD	R13,Z+1
    019C9 01F6      MOVW	R30,R12
    019CA 9634      ADIW	R30,4
    019CB 8020      LD	R2,Z
    019CC 2022      TST	R2
    019CD F409      BNE	0x19CF
    019CE C041      RJMP	0x1A10
    019CF 802D      LDD	R2,Y+5
    019D0 803E      LDD	R3,Y+6
    019D1 804F      LDD	R4,Y+7
    019D2 8458      LDD	R5,Y+8
    019D3 01F6      MOVW	R30,R12
    019D4 A462      LDD	R6,Z+42
    019D5 A473      LDD	R7,Z+43
    019D6 A484      LDD	R8,Z+44
    019D7 A495      LDD	R9,Z+45
    019D8 1862      SUB	R6,R2
    019D9 0873      SBC	R7,R3
    019DA 0884      SBC	R8,R4
    019DB 0895      SBC	R9,R5
    019DC 0115      MOVW	R2,R10
    019DD 2444      CLR	R4
    019DE 2455      CLR	R5
    019DF 1462      CP	R6,R2
    019E0 0473      CPC	R7,R3
    019E1 0484      CPC	R8,R4
    019E2 0495      CPC	R9,R5
    019E3 F560      BCC	0x1A10
(2429) 					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
    019E4 E080      LDI	R24,0
    019E5 E092      LDI	R25,2
    019E6 8399      STD	Y+1,R25
    019E7 8388      ST	Y,R24
    019E8 8DEB      LDD	R30,Y+27
    019E9 8DFC      LDD	R31,Y+28
    019EA 80C0      LD	R12,Z
    019EB 80D1      LDD	R13,Z+1
    019EC 0196      MOVW	R18,R12
    019ED 5D22      SUBI	R18,0xD2
    019EE 4F3F      SBCI	R19,0xFF
    019EF 802D      LDD	R2,Y+5
    019F0 803E      LDD	R3,Y+6
    019F1 804F      LDD	R4,Y+7
    019F2 8458      LDD	R5,Y+8
    019F3 01F6      MOVW	R30,R12
    019F4 A462      LDD	R6,Z+42
    019F5 A473      LDD	R7,Z+43
    019F6 A484      LDD	R8,Z+44
    019F7 A495      LDD	R9,Z+45
    019F8 1862      SUB	R6,R2
    019F9 0873      SBC	R7,R3
    019FA 0884      SBC	R8,R4
    019FB 0895      SBC	R9,R5
    019FC E040      LDI	R20,0
    019FD E052      LDI	R21,2
    019FE E060      LDI	R22,0
    019FF E070      LDI	R23,0
    01A00 932F      PUSH	R18
    01A01 933F      PUSH	R19
    01A02 929A      ST	-Y,R9
    01A03 928A      ST	-Y,R8
    01A04 927A      ST	-Y,R7
    01A05 926A      ST	-Y,R6
    01A06 018A      MOVW	R16,R20
    01A07 019B      MOVW	R18,R22
    01A08 940E 3F20 CALL	empy32u|empy32s
    01A0A 913F      POP	R19
    01A0B 912F      POP	R18
    01A0C 0D0E      ADD	R16,R14
    01A0D 1D1F      ADC	R17,R15
    01A0E 940E 02E3 CALL	ff.c:mem_cpy
(2430) #else
(2431) 				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
(2432) 					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
(2433) #endif
(2434) #endif
(2435) 				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    01A10 E000      LDI	R16,0
    01A11 E012      LDI	R17,2
    01A12 0195      MOVW	R18,R10
    01A13 940E 3F10 CALL	empy16s
    01A15 0168      MOVW	R12,R16
(2436) 				continue;
    01A16 C05A      RJMP	0x1A71
(2437) 			}
(2438) #if !_FS_TINY
(2439) 			if (fp->dsect != sect) {			/* Load data sector if not in cache */
(2440) #if !_FS_READONLY
(2441) 				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2442) 					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2443) 						ABORT(fp->fs, FR_DISK_ERR);
(2444) 					fp->flag &= ~FA__DIRTY;
(2445) 				}
(2446) #endif
(2447) 				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
(2448) 					ABORT(fp->fs, FR_DISK_ERR);
(2449) 			}
(2450) #endif
(2451) 			fp->dsect = sect;
    01A17 802D      LDD	R2,Y+5
    01A18 803E      LDD	R3,Y+6
    01A19 804F      LDD	R4,Y+7
    01A1A 8458      LDD	R5,Y+8
    01A1B 8DEB      LDD	R30,Y+27
    01A1C 8DFC      LDD	R31,Y+28
    01A1D 8A26      STD	Z+22,R2
    01A1E 8A37      STD	Z+23,R3
    01A1F 8E40      STD	Z+24,R4
    01A20 8E51      STD	Z+25,R5
(2452) 		}
(2453) 		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    01A21 EF4F      LDI	R20,0xFF
    01A22 E051      LDI	R21,1
    01A23 E060      LDI	R22,0
    01A24 E070      LDI	R23,0
    01A25 8DEB      LDD	R30,Y+27
    01A26 8DFC      LDD	R31,Y+28
    01A27 8026      LDD	R2,Z+6
    01A28 8037      LDD	R3,Z+7
    01A29 8440      LDD	R4,Z+8
    01A2A 8451      LDD	R5,Z+9
    01A2B 2224      AND	R2,R20
    01A2C 2235      AND	R3,R21
    01A2D 2246      AND	R4,R22
    01A2E 2257      AND	R5,R23
    01A2F E040      LDI	R20,0
    01A30 E052      LDI	R21,2
    01A31 E060      LDI	R22,0
    01A32 E070      LDI	R23,0
    01A33 1942      SUB	R20,R2
    01A34 0953      SBC	R21,R3
    01A35 0964      SBC	R22,R4
    01A36 0975      SBC	R23,R5
    01A37 016A      MOVW	R12,R20
(2454) 		if (rcnt > btr) rcnt = btr;
    01A38 8C0F      LDD	R0,Y+31
    01A39 A018      LDD	R1,Y+32
    01A3A 1604      CP	R0,R20
    01A3B 0615      CPC	R1,R21
    01A3C F408      BCC	0x1A3E
    01A3D 0160      MOVW	R12,R0
(2455) #if _FS_TINY
(2456) 		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    01A3E 8DEB      LDD	R30,Y+27
    01A3F 8DFC      LDD	R31,Y+28
    01A40 8826      LDD	R2,Z+22
    01A41 8837      LDD	R3,Z+23
    01A42 8C40      LDD	R4,Z+24
    01A43 8C51      LDD	R5,Z+25
    01A44 8248      ST	Y,R4
    01A45 8259      STD	Y+1,R5
    01A46 0191      MOVW	R18,R2
    01A47 8100      LD	R16,Z
    01A48 8111      LDD	R17,Z+1
    01A49 940E 033C CALL	ff.c:move_window
    01A4B 2EA0      MOV	R10,R16
    01A4C 2300      TST	R16
    01A4D F051      BEQ	0x1A58
(2457) 			ABORT(fp->fs, FR_DISK_ERR);
    01A4E 8D8B      LDD	R24,Y+27
    01A4F 8D9C      LDD	R25,Y+28
    01A50 9604      ADIW	R24,4
    01A51 015C      MOVW	R10,R24
    01A52 01FC      MOVW	R30,R24
    01A53 8180      LD	R24,Z
    01A54 6880      ORI	R24,0x80
    01A55 8380      ST	Z,R24
    01A56 E001      LDI	R16,1
    01A57 C046      RJMP	0x1A9E
(2458) 		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    01A58 82D9      STD	Y+1,R13
    01A59 82C8      ST	Y,R12
    01A5A EF4F      LDI	R20,0xFF
    01A5B E051      LDI	R21,1
    01A5C E060      LDI	R22,0
    01A5D E070      LDI	R23,0
    01A5E 8DEB      LDD	R30,Y+27
    01A5F 8DFC      LDD	R31,Y+28
    01A60 8026      LDD	R2,Z+6
    01A61 8037      LDD	R3,Z+7
    01A62 8440      LDD	R4,Z+8
    01A63 8451      LDD	R5,Z+9
    01A64 2224      AND	R2,R20
    01A65 2235      AND	R3,R21
    01A66 2246      AND	R4,R22
    01A67 2257      AND	R5,R23
    01A68 0191      MOVW	R18,R2
    01A69 8180      LD	R24,Z
    01A6A 8191      LDD	R25,Z+1
    01A6B 968E      ADIW	R24,0x2E
    01A6C 0F28      ADD	R18,R24
    01A6D 1F39      ADC	R19,R25
    01A6E 0187      MOVW	R16,R14
    01A6F 940E 02E3 CALL	ff.c:mem_cpy
    01A71 0CEC      ADD	R14,R12
    01A72 1CFD      ADC	R15,R13
    01A73 8D8B      LDD	R24,Y+27
    01A74 8D9C      LDD	R25,Y+28
    01A75 9606      ADIW	R24,6
    01A76 015C      MOVW	R10,R24
    01A77 0116      MOVW	R2,R12
    01A78 2444      CLR	R4
    01A79 2455      CLR	R5
    01A7A 01FC      MOVW	R30,R24
    01A7B 8060      LD	R6,Z
    01A7C 8071      LDD	R7,Z+1
    01A7D 8082      LDD	R8,Z+2
    01A7E 8093      LDD	R9,Z+3
    01A7F 0C62      ADD	R6,R2
    01A80 1C73      ADC	R7,R3
    01A81 1C84      ADC	R8,R4
    01A82 1C95      ADC	R9,R5
    01A83 8260      ST	Z,R6
    01A84 8271      STD	Z+1,R7
    01A85 8282      STD	Z+2,R8
    01A86 8293      STD	Z+3,R9
    01A87 A1E9      LDD	R30,Y+33
    01A88 A1FA      LDD	R31,Y+34
    01A89 8020      LD	R2,Z
    01A8A 8031      LDD	R3,Z+1
    01A8B 0C2C      ADD	R2,R12
    01A8C 1C3D      ADC	R3,R13
    01A8D 8231      STD	Z+1,R3
    01A8E 8220      ST	Z,R2
    01A8F 8C0F      LDD	R0,Y+31
    01A90 A018      LDD	R1,Y+32
    01A91 180C      SUB	R0,R12
    01A92 081D      SBC	R1,R13
    01A93 A218      STD	Y+32,R1
    01A94 8E0F      STD	Y+31,R0
    01A95 8C0F      LDD	R0,Y+31
    01A96 A018      LDD	R1,Y+32
    01A97 2000      TST	R0
    01A98 F009      BEQ	0x1A9A
    01A99 CDF1      RJMP	0x188B
    01A9A 2011      TST	R1
    01A9B F009      BEQ	0x1A9D
    01A9C CDEE      RJMP	0x188B
(2459) #else
(2460) 		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
(2461) #endif
(2462) 	}
(2463) 
(2464) 	LEAVE_FF(fp->fs, FR_OK);
    01A9D 2700      CLR	R16
    01A9E 9661      ADIW	R28,0x11
    01A9F 940E 3F69 CALL	pop_xgsetF0FC
    01AA1 9624      ADIW	R28,4
    01AA2 9508      RET
_f_write:
  res                  --> R10
  clst                 --> Y,+9
  csect                --> R12
  cc                   --> R10
  wbuff                --> R14
  sect                 --> Y,+5
  wcnt                 --> R12
  bw                   --> Y,+33
  btw                  --> Y,+31
  buff                 --> R10
  fp                   --> Y,+27
    01AA3 940E 3E2F CALL	push_arg4
    01AA5 940E 3F74 CALL	push_xgsetF0FC
    01AA7 0159      MOVW	R10,R18
    01AA8 9761      SBIW	R28,0x11
(2465) }
(2466) 
(2467) 
(2468) 
(2469) 
(2470) #if !_FS_READONLY
(2471) /*-----------------------------------------------------------------------*/
(2472) /* Write File                                                            */
(2473) /*-----------------------------------------------------------------------*/
(2474) 
(2475) FRESULT f_write (
(2476) 	FIL *fp,			/* Pointer to the file object */
(2477) 	const void *buff,	/* Pointer to the data to be written */
(2478) 	UINT btw,			/* Number of bytes to write */
(2479) 	UINT *bw			/* Pointer to number of bytes written */
(2480) )
(2481) {
(2482) 	FRESULT res;
(2483) 	DWORD clst, sect;
(2484) 	UINT wcnt, cc;
(2485) 	const BYTE *wbuff = buff;
    01AA9 0175      MOVW	R14,R10
(2486) 	BYTE csect;
(2487) 
(2488) 
(2489) 	*bw = 0;	/* Initialize byte counter */
    01AAA 2422      CLR	R2
    01AAB 2433      CLR	R3
    01AAC A1E9      LDD	R30,Y+33
    01AAD A1FA      LDD	R31,Y+34
    01AAE 8231      STD	Z+1,R3
    01AAF 8220      ST	Z,R2
(2490) 
(2491) 	res = validate(fp->fs, fp->id);			/* Check validity */
    01AB0 8DEB      LDD	R30,Y+27
    01AB1 8DFC      LDD	R31,Y+28
    01AB2 8122      LDD	R18,Z+2
    01AB3 8133      LDD	R19,Z+3
    01AB4 8100      LD	R16,Z
    01AB5 8111      LDD	R17,Z+1
    01AB6 DB9D      RCALL	ff.c:validate
    01AB7 2EA0      MOV	R10,R16
(2492) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01AB8 2300      TST	R16
    01AB9 F009      BEQ	0x1ABB
    01ABA C2FC      RJMP	0x1DB7
(2493) 	if (fp->flag & FA__ERROR)				/* Aborted file? */
    01ABB 8DEB      LDD	R30,Y+27
    01ABC 8DFC      LDD	R31,Y+28
    01ABD 8024      LDD	R2,Z+4
    01ABE FE27      SBRS	R2,7
    01ABF C002      RJMP	0x1AC2
(2494) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01AC0 E002      LDI	R16,2
    01AC1 C2F5      RJMP	0x1DB7
(2495) 	if (!(fp->flag & FA_WRITE))				/* Check access mode */
    01AC2 8DEB      LDD	R30,Y+27
    01AC3 8DFC      LDD	R31,Y+28
    01AC4 8024      LDD	R2,Z+4
    01AC5 FC21      SBRC	R2,1
    01AC6 C002      RJMP	0x1AC9
(2496) 		LEAVE_FF(fp->fs, FR_DENIED);
    01AC7 E007      LDI	R16,7
    01AC8 C2EE      RJMP	0x1DB7
(2497) 	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
    01AC9 8DEB      LDD	R30,Y+27
    01ACA 8DFC      LDD	R31,Y+28
    01ACB 963A      ADIW	R30,0xA
    01ACC 8020      LD	R2,Z
    01ACD 8031      LDD	R3,Z+1
    01ACE 8042      LDD	R4,Z+2
    01ACF 8053      LDD	R5,Z+3
    01AD0 862D      STD	Y+13,R2
    01AD1 863E      STD	Y+14,R3
    01AD2 864F      STD	Y+15,R4
    01AD3 8A58      STD	Y+16,R5
    01AD4 8C2F      LDD	R2,Y+31
    01AD5 A038      LDD	R3,Y+32
    01AD6 2444      CLR	R4
    01AD7 2455      CLR	R5
    01AD8 846D      LDD	R6,Y+13
    01AD9 847E      LDD	R7,Y+14
    01ADA 848F      LDD	R8,Y+15
    01ADB 8898      LDD	R9,Y+16
    01ADC 0C62      ADD	R6,R2
    01ADD 1C73      ADC	R7,R3
    01ADE 1C84      ADC	R8,R4
    01ADF 1C95      ADC	R9,R5
    01AE0 842D      LDD	R2,Y+13
    01AE1 843E      LDD	R3,Y+14
    01AE2 844F      LDD	R4,Y+15
    01AE3 8858      LDD	R5,Y+16
    01AE4 1462      CP	R6,R2
    01AE5 0473      CPC	R7,R3
    01AE6 0484      CPC	R8,R4
    01AE7 0495      CPC	R9,R5
    01AE8 F008      BCS	0x1AEA
    01AE9 C2A5      RJMP	0x1D8F
    01AEA 2400      CLR	R0
    01AEB 2411      CLR	R1
    01AEC A218      STD	Y+32,R1
    01AED 8E0F      STD	Y+31,R0
(2498) 
(2499) 	for ( ;  btw;							/* Repeat until all data written */
    01AEE C2A0      RJMP	0x1D8F
(2500) 		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
(2501) 		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
    01AEF EF4F      LDI	R20,0xFF
    01AF0 E051      LDI	R21,1
    01AF1 E060      LDI	R22,0
    01AF2 E070      LDI	R23,0
    01AF3 8DEB      LDD	R30,Y+27
    01AF4 8DFC      LDD	R31,Y+28
    01AF5 9636      ADIW	R30,6
    01AF6 8020      LD	R2,Z
    01AF7 8031      LDD	R3,Z+1
    01AF8 8042      LDD	R4,Z+2
    01AF9 8053      LDD	R5,Z+3
    01AFA 2224      AND	R2,R20
    01AFB 2235      AND	R3,R21
    01AFC 2246      AND	R4,R22
    01AFD 2257      AND	R5,R23
    01AFE 9488      BCLR	0
    01AFF 2022      TST	R2
    01B00 0432      CPC	R3,R2
    01B01 0442      CPC	R4,R2
    01B02 0452      CPC	R5,R2
    01B03 F009      BEQ	0x1B05
    01B04 C20B      RJMP	0x1D10
(2502) 			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    01B05 E089      LDI	R24,0x9
    01B06 E090      LDI	R25,0
    01B07 8DEB      LDD	R30,Y+27
    01B08 8DFC      LDD	R31,Y+28
    01B09 8106      LDD	R16,Z+6
    01B0A 8117      LDD	R17,Z+7
    01B0B 8520      LDD	R18,Z+8
    01B0C 8531      LDD	R19,Z+9
    01B0D 938A      ST	-Y,R24
    01B0E 940E 400F CALL	lsr32
    01B10 0118      MOVW	R2,R16
    01B11 0129      MOVW	R4,R18
    01B12 8DEB      LDD	R30,Y+27
    01B13 8DFC      LDD	R31,Y+28
    01B14 93AF      PUSH	R26
    01B15 93BF      PUSH	R27
    01B16 81A0      LD	R26,Z
    01B17 81B1      LDD	R27,Z+1
    01B18 01FD      MOVW	R30,R26
    01B19 91BF      POP	R27
    01B1A 91AF      POP	R26
    01B1B 8182      LDD	R24,Z+2
    01B1C 2799      CLR	R25
    01B1D 9701      SBIW	R24,1
    01B1E 013C      MOVW	R6,R24
    01B1F 2488      CLR	R8
    01B20 FC77      SBRC	R7,7
    01B21 9480      COM	R8
    01B22 2499      CLR	R9
    01B23 FC87      SBRC	R8,7
    01B24 9490      COM	R9
    01B25 2026      AND	R2,R6
    01B26 2037      AND	R3,R7
    01B27 2048      AND	R4,R8
    01B28 2059      AND	R5,R9
    01B29 2CC2      MOV	R12,R2
(2503) 			if (!csect) {					/* On the cluster boundary? */
    01B2A 2022      TST	R2
    01B2B F009      BEQ	0x1B2D
    01B2C C0A5      RJMP	0x1BD2
(2504) 				if (fp->fptr == 0) {		/* On the top of the file? */
    01B2D 8DEB      LDD	R30,Y+27
    01B2E 8DFC      LDD	R31,Y+28
    01B2F 9636      ADIW	R30,6
    01B30 8020      LD	R2,Z
    01B31 8031      LDD	R3,Z+1
    01B32 8042      LDD	R4,Z+2
    01B33 8053      LDD	R5,Z+3
    01B34 9488      BCLR	0
    01B35 2022      TST	R2
    01B36 0432      CPC	R3,R2
    01B37 0442      CPC	R4,R2
    01B38 0452      CPC	R5,R2
    01B39 F571      BNE	0x1B68
(2505) 					clst = fp->sclust;		/* Follow from the origin */
    01B3A 8DEB      LDD	R30,Y+27
    01B3B 8DFC      LDD	R31,Y+28
    01B3C 963E      ADIW	R30,0xE
    01B3D 8020      LD	R2,Z
    01B3E 8031      LDD	R3,Z+1
    01B3F 8042      LDD	R4,Z+2
    01B40 8053      LDD	R5,Z+3
    01B41 8629      STD	Y+9,R2
    01B42 863A      STD	Y+10,R3
    01B43 864B      STD	Y+11,R4
    01B44 865C      STD	Y+12,R5
(2506) 					if (clst == 0)			/* When no cluster is allocated, */
    01B45 8429      LDD	R2,Y+9
    01B46 843A      LDD	R3,Y+10
    01B47 844B      LDD	R4,Y+11
    01B48 845C      LDD	R5,Y+12
    01B49 9488      BCLR	0
    01B4A 2022      TST	R2
    01B4B 0432      CPC	R3,R2
    01B4C 0442      CPC	R4,R2
    01B4D 0452      CPC	R5,R2
    01B4E F009      BEQ	0x1B50
    01B4F C040      RJMP	0x1B90
(2507) 						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
    01B50 E040      LDI	R20,0
    01B51 E050      LDI	R21,0
    01B52 E060      LDI	R22,0
    01B53 E070      LDI	R23,0
    01B54 8368      ST	Y,R22
    01B55 8379      STD	Y+1,R23
    01B56 019A      MOVW	R18,R20
    01B57 8DEB      LDD	R30,Y+27
    01B58 8DFC      LDD	R31,Y+28
    01B59 8100      LD	R16,Z
    01B5A 8111      LDD	R17,Z+1
    01B5B 940E 08C7 CALL	ff.c:create_chain
    01B5D 8709      STD	Y+9,R16
    01B5E 871A      STD	Y+10,R17
    01B5F 872B      STD	Y+11,R18
    01B60 873C      STD	Y+12,R19
    01B61 8DEB      LDD	R30,Y+27
    01B62 8DFC      LDD	R31,Y+28
    01B63 8706      STD	Z+14,R16
    01B64 8717      STD	Z+15,R17
    01B65 8B20      STD	Z+16,R18
    01B66 8B31      STD	Z+17,R19
(2508) 				} else {					/* Middle or end of the file */
    01B67 C028      RJMP	0x1B90
(2509) #if _USE_FASTSEEK
(2510) 					if (fp->cltbl)
    01B68 8DEB      LDD	R30,Y+27
    01B69 8DFC      LDD	R31,Y+28
    01B6A A020      LDD	R2,Z+32
    01B6B A031      LDD	R3,Z+33
    01B6C 2022      TST	R2
    01B6D F411      BNE	0x1B70
    01B6E 2033      TST	R3
    01B6F F079      BEQ	0x1B7F
(2511) 						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
    01B70 8026      LDD	R2,Z+6
    01B71 8037      LDD	R3,Z+7
    01B72 8440      LDD	R4,Z+8
    01B73 8451      LDD	R5,Z+9
    01B74 8248      ST	Y,R4
    01B75 8259      STD	Y+1,R5
    01B76 0191      MOVW	R18,R2
    01B77 018F      MOVW	R16,R30
    01B78 940E 0A3F CALL	ff.c:clmt_clust
    01B7A 8709      STD	Y+9,R16
    01B7B 871A      STD	Y+10,R17
    01B7C 872B      STD	Y+11,R18
    01B7D 873C      STD	Y+12,R19
    01B7E C011      RJMP	0x1B90
(2512) 					else
(2513) #endif
(2514) 						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
    01B7F 8DEB      LDD	R30,Y+27
    01B80 8DFC      LDD	R31,Y+28
    01B81 8822      LDD	R2,Z+18
    01B82 8833      LDD	R3,Z+19
    01B83 8844      LDD	R4,Z+20
    01B84 8855      LDD	R5,Z+21
    01B85 8248      ST	Y,R4
    01B86 8259      STD	Y+1,R5
    01B87 0191      MOVW	R18,R2
    01B88 8100      LD	R16,Z
    01B89 8111      LDD	R17,Z+1
    01B8A 940E 08C7 CALL	ff.c:create_chain
    01B8C 8709      STD	Y+9,R16
    01B8D 871A      STD	Y+10,R17
    01B8E 872B      STD	Y+11,R18
    01B8F 873C      STD	Y+12,R19
(2515) 				}
(2516) 				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
    01B90 8429      LDD	R2,Y+9
    01B91 843A      LDD	R3,Y+10
    01B92 844B      LDD	R4,Y+11
    01B93 845C      LDD	R5,Y+12
    01B94 9488      BCLR	0
    01B95 2022      TST	R2
    01B96 0432      CPC	R3,R2
    01B97 0442      CPC	R4,R2
    01B98 0452      CPC	R5,R2
    01B99 F409      BNE	0x1B9B
    01B9A C1FC      RJMP	0x1D97
(2517) 				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    01B9B E041      LDI	R20,1
    01B9C E050      LDI	R21,0
    01B9D E060      LDI	R22,0
    01B9E E070      LDI	R23,0
    01B9F 8429      LDD	R2,Y+9
    01BA0 843A      LDD	R3,Y+10
    01BA1 844B      LDD	R4,Y+11
    01BA2 845C      LDD	R5,Y+12
    01BA3 1624      CP	R2,R20
    01BA4 0635      CPC	R3,R21
    01BA5 0646      CPC	R4,R22
    01BA6 0657      CPC	R5,R23
    01BA7 F449      BNE	0x1BB1
    01BA8 8D8B      LDD	R24,Y+27
    01BA9 8D9C      LDD	R25,Y+28
    01BAA 9604      ADIW	R24,4
    01BAB 01FC      MOVW	R30,R24
    01BAC 8180      LD	R24,Z
    01BAD 6880      ORI	R24,0x80
    01BAE 8380      ST	Z,R24
    01BAF E002      LDI	R16,2
    01BB0 C206      RJMP	0x1DB7
(2518) 				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01BB1 EF4F      LDI	R20,0xFF
    01BB2 EF5F      LDI	R21,0xFF
    01BB3 EF6F      LDI	R22,0xFF
    01BB4 EF7F      LDI	R23,0xFF
    01BB5 8429      LDD	R2,Y+9
    01BB6 843A      LDD	R3,Y+10
    01BB7 844B      LDD	R4,Y+11
    01BB8 845C      LDD	R5,Y+12
    01BB9 1624      CP	R2,R20
    01BBA 0635      CPC	R3,R21
    01BBB 0646      CPC	R4,R22
    01BBC 0657      CPC	R5,R23
    01BBD F451      BNE	0x1BC8
    01BBE 8D8B      LDD	R24,Y+27
    01BBF 8D9C      LDD	R25,Y+28
    01BC0 9604      ADIW	R24,4
    01BC1 015C      MOVW	R10,R24
    01BC2 01FC      MOVW	R30,R24
    01BC3 8180      LD	R24,Z
    01BC4 6880      ORI	R24,0x80
    01BC5 8380      ST	Z,R24
    01BC6 E001      LDI	R16,1
    01BC7 C1EF      RJMP	0x1DB7
(2519) 				fp->clust = clst;			/* Update current cluster */
    01BC8 8429      LDD	R2,Y+9
    01BC9 843A      LDD	R3,Y+10
    01BCA 844B      LDD	R4,Y+11
    01BCB 845C      LDD	R5,Y+12
    01BCC 8DEB      LDD	R30,Y+27
    01BCD 8DFC      LDD	R31,Y+28
    01BCE 8A22      STD	Z+18,R2
    01BCF 8A33      STD	Z+19,R3
    01BD0 8A44      STD	Z+20,R4
    01BD1 8A55      STD	Z+21,R5
(2520) 			}
(2521) #if _FS_TINY
(2522) 			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
    01BD2 8DEB      LDD	R30,Y+27
    01BD3 8DFC      LDD	R31,Y+28
    01BD4 80A0      LD	R10,Z
    01BD5 80B1      LDD	R11,Z+1
    01BD6 8826      LDD	R2,Z+22
    01BD7 8837      LDD	R3,Z+23
    01BD8 8C40      LDD	R4,Z+24
    01BD9 8C51      LDD	R5,Z+25
    01BDA 01F5      MOVW	R30,R10
    01BDB A462      LDD	R6,Z+42
    01BDC A473      LDD	R7,Z+43
    01BDD A484      LDD	R8,Z+44
    01BDE A495      LDD	R9,Z+45
    01BDF 1462      CP	R6,R2
    01BE0 0473      CPC	R7,R3
    01BE1 0484      CPC	R8,R4
    01BE2 0495      CPC	R9,R5
    01BE3 F4B9      BNE	0x1BFB
    01BE4 E040      LDI	R20,0
    01BE5 E050      LDI	R21,0
    01BE6 E060      LDI	R22,0
    01BE7 E070      LDI	R23,0
    01BE8 8368      ST	Y,R22
    01BE9 8379      STD	Y+1,R23
    01BEA 019A      MOVW	R18,R20
    01BEB 018F      MOVW	R16,R30
    01BEC 940E 033C CALL	ff.c:move_window
    01BEE 2EA0      MOV	R10,R16
    01BEF 2300      TST	R16
    01BF0 F051      BEQ	0x1BFB
(2523) 				ABORT(fp->fs, FR_DISK_ERR);
    01BF1 8D8B      LDD	R24,Y+27
    01BF2 8D9C      LDD	R25,Y+28
    01BF3 9604      ADIW	R24,4
    01BF4 015C      MOVW	R10,R24
    01BF5 01FC      MOVW	R30,R24
    01BF6 8180      LD	R24,Z
    01BF7 6880      ORI	R24,0x80
    01BF8 8380      ST	Z,R24
    01BF9 E001      LDI	R16,1
    01BFA C1BC      RJMP	0x1DB7
(2524) #else
(2525) 			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
(2526) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2527) 					ABORT(fp->fs, FR_DISK_ERR);
(2528) 				fp->flag &= ~FA__DIRTY;
(2529) 			}
(2530) #endif
(2531) 			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    01BFB 8DEB      LDD	R30,Y+27
    01BFC 8DFC      LDD	R31,Y+28
    01BFD 8822      LDD	R2,Z+18
    01BFE 8833      LDD	R3,Z+19
    01BFF 8844      LDD	R4,Z+20
    01C00 8855      LDD	R5,Z+21
    01C01 8248      ST	Y,R4
    01C02 8259      STD	Y+1,R5
    01C03 0191      MOVW	R18,R2
    01C04 8100      LD	R16,Z
    01C05 8111      LDD	R17,Z+1
    01C06 940E 04B3 CALL	_clust2sect
    01C08 830D      STD	Y+5,R16
    01C09 831E      STD	Y+6,R17
    01C0A 832F      STD	Y+7,R18
    01C0B 8738      STD	Y+8,R19
(2532) 			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    01C0C 802D      LDD	R2,Y+5
    01C0D 803E      LDD	R3,Y+6
    01C0E 804F      LDD	R4,Y+7
    01C0F 8458      LDD	R5,Y+8
    01C10 9488      BCLR	0
    01C11 2022      TST	R2
    01C12 0432      CPC	R3,R2
    01C13 0442      CPC	R4,R2
    01C14 0452      CPC	R5,R2
    01C15 F451      BNE	0x1C20
    01C16 8D8B      LDD	R24,Y+27
    01C17 8D9C      LDD	R25,Y+28
    01C18 9604      ADIW	R24,4
    01C19 015C      MOVW	R10,R24
    01C1A 01FC      MOVW	R30,R24
    01C1B 8180      LD	R24,Z
    01C1C 6880      ORI	R24,0x80
    01C1D 8380      ST	Z,R24
    01C1E E002      LDI	R16,2
    01C1F C197      RJMP	0x1DB7
(2533) 			sect += csect;
    01C20 2C2C      MOV	R2,R12
    01C21 2433      CLR	R3
    01C22 2444      CLR	R4
    01C23 2455      CLR	R5
    01C24 806D      LDD	R6,Y+5
    01C25 807E      LDD	R7,Y+6
    01C26 808F      LDD	R8,Y+7
    01C27 8498      LDD	R9,Y+8
    01C28 0C62      ADD	R6,R2
    01C29 1C73      ADC	R7,R3
    01C2A 1C84      ADC	R8,R4
    01C2B 1C95      ADC	R9,R5
    01C2C 826D      STD	Y+5,R6
    01C2D 827E      STD	Y+6,R7
    01C2E 828F      STD	Y+7,R8
    01C2F 8698      STD	Y+8,R9
(2534) 			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
    01C30 E029      LDI	R18,0x9
    01C31 E030      LDI	R19,0
    01C32 8D0F      LDD	R16,Y+31
    01C33 A118      LDD	R17,Y+32
    01C34 940E 4008 CALL	lsr16
    01C36 0158      MOVW	R10,R16
(2535) 			if (cc) {						/* Write maximum contiguous sectors directly */
    01C37 3000      CPI	R16,0
    01C38 0701      CPC	R16,R17
    01C39 F409      BNE	0x1C3B
    01C3A C097      RJMP	0x1CD2
(2536) 				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    01C3B 2C2C      MOV	R2,R12
    01C3C 2433      CLR	R3
    01C3D 0E20      ADD	R2,R16
    01C3E 1E31      ADC	R3,R17
    01C3F 8DEB      LDD	R30,Y+27
    01C40 8DFC      LDD	R31,Y+28
    01C41 93AF      PUSH	R26
    01C42 93BF      PUSH	R27
    01C43 81A0      LD	R26,Z
    01C44 81B1      LDD	R27,Z+1
    01C45 01FD      MOVW	R30,R26
    01C46 91BF      POP	R27
    01C47 91AF      POP	R26
    01C48 8042      LDD	R4,Z+2
    01C49 2455      CLR	R5
    01C4A 1442      CP	R4,R2
    01C4B 0453      CPC	R5,R3
    01C4C F478      BCC	0x1C5C
(2537) 					cc = fp->fs->csize - csect;
    01C4D 2C2C      MOV	R2,R12
    01C4E 2433      CLR	R3
    01C4F 8DEB      LDD	R30,Y+27
    01C50 8DFC      LDD	R31,Y+28
    01C51 93AF      PUSH	R26
    01C52 93BF      PUSH	R27
    01C53 81A0      LD	R26,Z
    01C54 81B1      LDD	R27,Z+1
    01C55 01FD      MOVW	R30,R26
    01C56 91BF      POP	R27
    01C57 91AF      POP	R26
    01C58 80A2      LDD	R10,Z+2
    01C59 24BB      CLR	R11
    01C5A 18A2      SUB	R10,R2
    01C5B 08B3      SBC	R11,R3
(2538) 				if (disk_write(fp->fs->drv,(char*)wbuff, sect, (BYTE)cc) != RES_OK)
    01C5C 82AC      STD	Y+4,R10
    01C5D 802D      LDD	R2,Y+5
    01C5E 803E      LDD	R3,Y+6
    01C5F 804F      LDD	R4,Y+7
    01C60 8458      LDD	R5,Y+8
    01C61 8228      ST	Y,R2
    01C62 8239      STD	Y+1,R3
    01C63 824A      STD	Y+2,R4
    01C64 825B      STD	Y+3,R5
    01C65 0197      MOVW	R18,R14
    01C66 8DEB      LDD	R30,Y+27
    01C67 8DFC      LDD	R31,Y+28
    01C68 93AF      PUSH	R26
    01C69 93BF      PUSH	R27
    01C6A 81A0      LD	R26,Z
    01C6B 81B1      LDD	R27,Z+1
    01C6C 01FD      MOVW	R30,R26
    01C6D 91BF      POP	R27
    01C6E 91AF      POP	R26
    01C6F 8101      LDD	R16,Z+1
    01C70 940E 02C1 CALL	_disk_write
    01C72 2EC0      MOV	R12,R16
    01C73 2300      TST	R16
    01C74 F051      BEQ	0x1C7F
(2539) 					ABORT(fp->fs, FR_DISK_ERR);
    01C75 8D8B      LDD	R24,Y+27
    01C76 8D9C      LDD	R25,Y+28
    01C77 9604      ADIW	R24,4
    01C78 016C      MOVW	R12,R24
    01C79 01FC      MOVW	R30,R24
    01C7A 8180      LD	R24,Z
    01C7B 6880      ORI	R24,0x80
    01C7C 8380      ST	Z,R24
    01C7D E001      LDI	R16,1
    01C7E C138      RJMP	0x1DB7
(2540) #if _FS_TINY
(2541) 				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
    01C7F 802D      LDD	R2,Y+5
    01C80 803E      LDD	R3,Y+6
    01C81 804F      LDD	R4,Y+7
    01C82 8458      LDD	R5,Y+8
    01C83 8DEB      LDD	R30,Y+27
    01C84 8DFC      LDD	R31,Y+28
    01C85 81A0      LD	R26,Z
    01C86 81B1      LDD	R27,Z+1
    01C87 969A      ADIW	R26,0x2A
    01C88 906D      LD	R6,X+
    01C89 907D      LD	R7,X+
    01C8A 908D      LD	R8,X+
    01C8B 909C      LD	R9,X
    01C8C 1862      SUB	R6,R2
    01C8D 0873      SBC	R7,R3
    01C8E 0884      SBC	R8,R4
    01C8F 0895      SBC	R9,R5
    01C90 0115      MOVW	R2,R10
    01C91 2444      CLR	R4
    01C92 2455      CLR	R5
    01C93 1462      CP	R6,R2
    01C94 0473      CPC	R7,R3
    01C95 0484      CPC	R8,R4
    01C96 0495      CPC	R9,R5
    01C97 F008      BCS	0x1C99
    01C98 C032      RJMP	0x1CCB
(2542) 					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
    01C99 E080      LDI	R24,0
    01C9A E092      LDI	R25,2
    01C9B 8399      STD	Y+1,R25
    01C9C 8388      ST	Y,R24
    01C9D 80C0      LD	R12,Z
    01C9E 80D1      LDD	R13,Z+1
    01C9F 802D      LDD	R2,Y+5
    01CA0 803E      LDD	R3,Y+6
    01CA1 804F      LDD	R4,Y+7
    01CA2 8458      LDD	R5,Y+8
    01CA3 01F6      MOVW	R30,R12
    01CA4 A462      LDD	R6,Z+42
    01CA5 A473      LDD	R7,Z+43
    01CA6 A484      LDD	R8,Z+44
    01CA7 A495      LDD	R9,Z+45
    01CA8 1862      SUB	R6,R2
    01CA9 0873      SBC	R7,R3
    01CAA 0884      SBC	R8,R4
    01CAB 0895      SBC	R9,R5
    01CAC E040      LDI	R20,0
    01CAD E052      LDI	R21,2
    01CAE E060      LDI	R22,0
    01CAF E070      LDI	R23,0
    01CB0 929A      ST	-Y,R9
    01CB1 928A      ST	-Y,R8
    01CB2 927A      ST	-Y,R7
    01CB3 926A      ST	-Y,R6
    01CB4 018A      MOVW	R16,R20
    01CB5 019B      MOVW	R18,R22
    01CB6 940E 3F20 CALL	empy32u|empy32s
    01CB8 0198      MOVW	R18,R16
    01CB9 0D2E      ADD	R18,R14
    01CBA 1D3F      ADC	R19,R15
    01CBB 0186      MOVW	R16,R12
    01CBC 5D02      SUBI	R16,0xD2
    01CBD 4F1F      SBCI	R17,0xFF
    01CBE 940E 02E3 CALL	ff.c:mem_cpy
(2543) 					fp->fs->wflag = 0;
    01CC0 2422      CLR	R2
    01CC1 8DEB      LDD	R30,Y+27
    01CC2 8DFC      LDD	R31,Y+28
    01CC3 93AF      PUSH	R26
    01CC4 93BF      PUSH	R27
    01CC5 81A0      LD	R26,Z
    01CC6 81B1      LDD	R27,Z+1
    01CC7 01FD      MOVW	R30,R26
    01CC8 91BF      POP	R27
    01CC9 91AF      POP	R26
    01CCA 8224      STD	Z+4,R2
(2544) 				}
(2545) #else
(2546) 				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
(2547) 					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
(2548) 					fp->flag &= ~FA__DIRTY;
(2549) 				}
(2550) #endif
(2551) 				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
    01CCB E000      LDI	R16,0
    01CCC E012      LDI	R17,2
    01CCD 0195      MOVW	R18,R10
    01CCE 940E 3F10 CALL	empy16s
    01CD0 0168      MOVW	R12,R16
(2552) 				continue;
    01CD1 C099      RJMP	0x1D6B
(2553) 			}
(2554) #if _FS_TINY
(2555) 			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
    01CD2 8DEB      LDD	R30,Y+27
    01CD3 8DFC      LDD	R31,Y+28
    01CD4 8422      LDD	R2,Z+10
    01CD5 8433      LDD	R3,Z+11
    01CD6 8444      LDD	R4,Z+12
    01CD7 8455      LDD	R5,Z+13
    01CD8 8066      LDD	R6,Z+6
    01CD9 8077      LDD	R7,Z+7
    01CDA 8480      LDD	R8,Z+8
    01CDB 8491      LDD	R9,Z+9
    01CDC 1462      CP	R6,R2
    01CDD 0473      CPC	R7,R3
    01CDE 0484      CPC	R8,R4
    01CDF 0495      CPC	R9,R5
    01CE0 F128      BCS	0x1D06
(2556) 				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
    01CE1 E040      LDI	R20,0
    01CE2 E050      LDI	R21,0
    01CE3 E060      LDI	R22,0
    01CE4 E070      LDI	R23,0
    01CE5 8368      ST	Y,R22
    01CE6 8379      STD	Y+1,R23
    01CE7 019A      MOVW	R18,R20
    01CE8 8100      LD	R16,Z
    01CE9 8111      LDD	R17,Z+1
    01CEA 940E 033C CALL	ff.c:move_window
    01CEC 2EA0      MOV	R10,R16
    01CED 2300      TST	R16
    01CEE F051      BEQ	0x1CF9
    01CEF 8D8B      LDD	R24,Y+27
    01CF0 8D9C      LDD	R25,Y+28
    01CF1 9604      ADIW	R24,4
    01CF2 015C      MOVW	R10,R24
    01CF3 01FC      MOVW	R30,R24
    01CF4 8180      LD	R24,Z
    01CF5 6880      ORI	R24,0x80
    01CF6 8380      ST	Z,R24
    01CF7 E001      LDI	R16,1
    01CF8 C0BE      RJMP	0x1DB7
(2557) 				fp->fs->winsect = sect;
    01CF9 802D      LDD	R2,Y+5
    01CFA 803E      LDD	R3,Y+6
    01CFB 804F      LDD	R4,Y+7
    01CFC 8458      LDD	R5,Y+8
    01CFD 8DEB      LDD	R30,Y+27
    01CFE 8DFC      LDD	R31,Y+28
    01CFF 81A0      LD	R26,Z
    01D00 81B1      LDD	R27,Z+1
    01D01 969A      ADIW	R26,0x2A
    01D02 922D      ST	X+,R2
    01D03 923D      ST	X+,R3
    01D04 924D      ST	X+,R4
    01D05 925C      ST	X,R5
(2558) 			}
(2559) #else
(2560) 			if (fp->dsect != sect) {		/* Fill sector cache with file data */
(2561) 				if (fp->fptr < fp->fsize &&
(2562) 					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
(2563) 						ABORT(fp->fs, FR_DISK_ERR);
(2564) 			}
(2565) #endif
(2566) 			fp->dsect = sect;
    01D06 802D      LDD	R2,Y+5
    01D07 803E      LDD	R3,Y+6
    01D08 804F      LDD	R4,Y+7
    01D09 8458      LDD	R5,Y+8
    01D0A 8DEB      LDD	R30,Y+27
    01D0B 8DFC      LDD	R31,Y+28
    01D0C 8A26      STD	Z+22,R2
    01D0D 8A37      STD	Z+23,R3
    01D0E 8E40      STD	Z+24,R4
    01D0F 8E51      STD	Z+25,R5
(2567) 		}
(2568) 		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
    01D10 EF4F      LDI	R20,0xFF
    01D11 E051      LDI	R21,1
    01D12 E060      LDI	R22,0
    01D13 E070      LDI	R23,0
    01D14 8DEB      LDD	R30,Y+27
    01D15 8DFC      LDD	R31,Y+28
    01D16 8026      LDD	R2,Z+6
    01D17 8037      LDD	R3,Z+7
    01D18 8440      LDD	R4,Z+8
    01D19 8451      LDD	R5,Z+9
    01D1A 2224      AND	R2,R20
    01D1B 2235      AND	R3,R21
    01D1C 2246      AND	R4,R22
    01D1D 2257      AND	R5,R23
    01D1E E040      LDI	R20,0
    01D1F E052      LDI	R21,2
    01D20 E060      LDI	R22,0
    01D21 E070      LDI	R23,0
    01D22 1942      SUB	R20,R2
    01D23 0953      SBC	R21,R3
    01D24 0964      SBC	R22,R4
    01D25 0975      SBC	R23,R5
    01D26 016A      MOVW	R12,R20
(2569) 		if (wcnt > btw) wcnt = btw;
    01D27 8C0F      LDD	R0,Y+31
    01D28 A018      LDD	R1,Y+32
    01D29 1604      CP	R0,R20
    01D2A 0615      CPC	R1,R21
    01D2B F408      BCC	0x1D2D
    01D2C 0160      MOVW	R12,R0
(2570) #if _FS_TINY
(2571) 		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
    01D2D 8DEB      LDD	R30,Y+27
    01D2E 8DFC      LDD	R31,Y+28
    01D2F 8826      LDD	R2,Z+22
    01D30 8837      LDD	R3,Z+23
    01D31 8C40      LDD	R4,Z+24
    01D32 8C51      LDD	R5,Z+25
    01D33 8248      ST	Y,R4
    01D34 8259      STD	Y+1,R5
    01D35 0191      MOVW	R18,R2
    01D36 8100      LD	R16,Z
    01D37 8111      LDD	R17,Z+1
    01D38 940E 033C CALL	ff.c:move_window
    01D3A 2EA0      MOV	R10,R16
    01D3B 2300      TST	R16
    01D3C F051      BEQ	0x1D47
(2572) 			ABORT(fp->fs, FR_DISK_ERR);
    01D3D 8D8B      LDD	R24,Y+27
    01D3E 8D9C      LDD	R25,Y+28
    01D3F 9604      ADIW	R24,4
    01D40 015C      MOVW	R10,R24
    01D41 01FC      MOVW	R30,R24
    01D42 8180      LD	R24,Z
    01D43 6880      ORI	R24,0x80
    01D44 8380      ST	Z,R24
    01D45 E001      LDI	R16,1
    01D46 C070      RJMP	0x1DB7
(2573) 		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
    01D47 82D9      STD	Y+1,R13
    01D48 82C8      ST	Y,R12
    01D49 0197      MOVW	R18,R14
    01D4A EF4F      LDI	R20,0xFF
    01D4B E051      LDI	R21,1
    01D4C E060      LDI	R22,0
    01D4D E070      LDI	R23,0
    01D4E 8DEB      LDD	R30,Y+27
    01D4F 8DFC      LDD	R31,Y+28
    01D50 8026      LDD	R2,Z+6
    01D51 8037      LDD	R3,Z+7
    01D52 8440      LDD	R4,Z+8
    01D53 8451      LDD	R5,Z+9
    01D54 2224      AND	R2,R20
    01D55 2235      AND	R3,R21
    01D56 2246      AND	R4,R22
    01D57 2257      AND	R5,R23
    01D58 0181      MOVW	R16,R2
    01D59 8180      LD	R24,Z
    01D5A 8191      LDD	R25,Z+1
    01D5B 968E      ADIW	R24,0x2E
    01D5C 0F08      ADD	R16,R24
    01D5D 1F19      ADC	R17,R25
    01D5E 940E 02E3 CALL	ff.c:mem_cpy
(2574) 		fp->fs->wflag = 1;
    01D60 E081      LDI	R24,1
    01D61 8DEB      LDD	R30,Y+27
    01D62 8DFC      LDD	R31,Y+28
    01D63 93AF      PUSH	R26
    01D64 93BF      PUSH	R27
    01D65 81A0      LD	R26,Z
    01D66 81B1      LDD	R27,Z+1
    01D67 01FD      MOVW	R30,R26
    01D68 91BF      POP	R27
    01D69 91AF      POP	R26
    01D6A 8384      STD	Z+4,R24
    01D6B 0CEC      ADD	R14,R12
    01D6C 1CFD      ADC	R15,R13
    01D6D 8D8B      LDD	R24,Y+27
    01D6E 8D9C      LDD	R25,Y+28
    01D6F 9606      ADIW	R24,6
    01D70 015C      MOVW	R10,R24
    01D71 0116      MOVW	R2,R12
    01D72 2444      CLR	R4
    01D73 2455      CLR	R5
    01D74 01FC      MOVW	R30,R24
    01D75 8060      LD	R6,Z
    01D76 8071      LDD	R7,Z+1
    01D77 8082      LDD	R8,Z+2
    01D78 8093      LDD	R9,Z+3
    01D79 0C62      ADD	R6,R2
    01D7A 1C73      ADC	R7,R3
    01D7B 1C84      ADC	R8,R4
    01D7C 1C95      ADC	R9,R5
    01D7D 8260      ST	Z,R6
    01D7E 8271      STD	Z+1,R7
    01D7F 8282      STD	Z+2,R8
    01D80 8293      STD	Z+3,R9
    01D81 A1E9      LDD	R30,Y+33
    01D82 A1FA      LDD	R31,Y+34
    01D83 8020      LD	R2,Z
    01D84 8031      LDD	R3,Z+1
    01D85 0C2C      ADD	R2,R12
    01D86 1C3D      ADC	R3,R13
    01D87 8231      STD	Z+1,R3
    01D88 8220      ST	Z,R2
    01D89 8C0F      LDD	R0,Y+31
    01D8A A018      LDD	R1,Y+32
    01D8B 180C      SUB	R0,R12
    01D8C 081D      SBC	R1,R13
    01D8D A218      STD	Y+32,R1
    01D8E 8E0F      STD	Y+31,R0
    01D8F 8C0F      LDD	R0,Y+31
    01D90 A018      LDD	R1,Y+32
    01D91 2000      TST	R0
    01D92 F009      BEQ	0x1D94
    01D93 CD5B      RJMP	0x1AEF
    01D94 2011      TST	R1
    01D95 F009      BEQ	0x1D97
    01D96 CD58      RJMP	0x1AEF
(2575) #else
(2576) 		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
(2577) 		fp->flag |= FA__DIRTY;
(2578) #endif
(2579) 	}
(2580) 
(2581) 	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
    01D97 8DEB      LDD	R30,Y+27
    01D98 8DFC      LDD	R31,Y+28
    01D99 8422      LDD	R2,Z+10
    01D9A 8433      LDD	R3,Z+11
    01D9B 8444      LDD	R4,Z+12
    01D9C 8455      LDD	R5,Z+13
    01D9D 8066      LDD	R6,Z+6
    01D9E 8077      LDD	R7,Z+7
    01D9F 8480      LDD	R8,Z+8
    01DA0 8491      LDD	R9,Z+9
    01DA1 1426      CP	R2,R6
    01DA2 0437      CPC	R3,R7
    01DA3 0448      CPC	R4,R8
    01DA4 0459      CPC	R5,R9
    01DA5 F440      BCC	0x1DAE
    01DA6 8026      LDD	R2,Z+6
    01DA7 8037      LDD	R3,Z+7
    01DA8 8440      LDD	R4,Z+8
    01DA9 8451      LDD	R5,Z+9
    01DAA 8622      STD	Z+10,R2
    01DAB 8633      STD	Z+11,R3
    01DAC 8644      STD	Z+12,R4
    01DAD 8655      STD	Z+13,R5
(2582) 	fp->flag |= FA__WRITTEN;						/* Set file change flag */
    01DAE 8D8B      LDD	R24,Y+27
    01DAF 8D9C      LDD	R25,Y+28
    01DB0 9604      ADIW	R24,4
    01DB1 015C      MOVW	R10,R24
    01DB2 01FC      MOVW	R30,R24
    01DB3 8180      LD	R24,Z
    01DB4 6280      ORI	R24,0x20
    01DB5 8380      ST	Z,R24
(2583) 
(2584) 	LEAVE_FF(fp->fs, FR_OK);
    01DB6 2700      CLR	R16
    01DB7 9661      ADIW	R28,0x11
    01DB8 940E 3F69 CALL	pop_xgsetF0FC
    01DBA 9624      ADIW	R28,4
    01DBB 9508      RET
_f_sync:
  tim                  --> Y,+2
  dir                  --> R22
  res                  --> R10
  fp                   --> R20
    01DBC 940E 3FAF CALL	push_xgsetF03C
    01DBE 01A8      MOVW	R20,R16
    01DBF 9726      SBIW	R28,6
(2585) }
(2586) 
(2587) 
(2588) 
(2589) 
(2590) /*-----------------------------------------------------------------------*/
(2591) /* Synchronize the File Object                                           */
(2592) /*-----------------------------------------------------------------------*/
(2593) 
(2594) FRESULT f_sync (
(2595) 	FIL *fp		/* Pointer to the file object */
(2596) )
(2597) {
(2598) 	FRESULT res;
(2599) 	DWORD tim;
(2600) 	BYTE *dir;
(2601) 
(2602) 
(2603) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01DC0 01FA      MOVW	R30,R20
    01DC1 8122      LDD	R18,Z+2
    01DC2 8133      LDD	R19,Z+3
    01DC3 8100      LD	R16,Z
    01DC4 8111      LDD	R17,Z+1
    01DC5 D88E      RCALL	ff.c:validate
    01DC6 2EA0      MOV	R10,R16
(2604) 	if (res == FR_OK) {
    01DC7 2300      TST	R16
    01DC8 F009      BEQ	0x1DCA
    01DC9 C09F      RJMP	0x1E69
(2605) 		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
    01DCA 01FA      MOVW	R30,R20
    01DCB 8024      LDD	R2,Z+4
    01DCC FE25      SBRS	R2,5
    01DCD C09B      RJMP	0x1E69
(2606) #if !_FS_TINY	/* Write-back dirty buffer */
(2607) 			if (fp->flag & FA__DIRTY) {
(2608) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2609) 					LEAVE_FF(fp->fs, FR_DISK_ERR);
(2610) 				fp->flag &= ~FA__DIRTY;
(2611) 			}
(2612) #endif
(2613) 			/* Update the directory entry */
(2614) 			res = move_window(fp->fs, fp->dir_sect);
    01DCE 8C22      LDD	R2,Z+26
    01DCF 8C33      LDD	R3,Z+27
    01DD0 8C44      LDD	R4,Z+28
    01DD1 8C55      LDD	R5,Z+29
    01DD2 8248      ST	Y,R4
    01DD3 8259      STD	Y+1,R5
    01DD4 0191      MOVW	R18,R2
    01DD5 8100      LD	R16,Z
    01DD6 8111      LDD	R17,Z+1
    01DD7 940E 033C CALL	ff.c:move_window
    01DD9 2EA0      MOV	R10,R16
(2615) 			if (res == FR_OK) {
    01DDA 2300      TST	R16
    01DDB F009      BEQ	0x1DDD
    01DDC C08C      RJMP	0x1E69
(2616) 				dir = fp->dir_ptr;
    01DDD 01FA      MOVW	R30,R20
    01DDE 8D66      LDD	R22,Z+30
    01DDF 8D77      LDD	R23,Z+31
(2617) 				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
    01DE0 01CB      MOVW	R24,R22
    01DE1 960B      ADIW	R24,0xB
    01DE2 01FC      MOVW	R30,R24
    01DE3 8180      LD	R24,Z
    01DE4 6280      ORI	R24,0x20
    01DE5 8380      ST	Z,R24
(2618) 				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
    01DE6 01FA      MOVW	R30,R20
    01DE7 8422      LDD	R2,Z+10
    01DE8 8433      LDD	R3,Z+11
    01DE9 8444      LDD	R4,Z+12
    01DEA 8455      LDD	R5,Z+13
    01DEB 01FB      MOVW	R30,R22
    01DEC 8E24      STD	Z+28,R2
    01DED 01FA      MOVW	R30,R20
    01DEE 8422      LDD	R2,Z+10
    01DEF 8433      LDD	R3,Z+11
    01DF0 2C23      MOV	R2,R3
    01DF1 2433      CLR	R3
    01DF2 01FB      MOVW	R30,R22
    01DF3 8E25      STD	Z+29,R2
    01DF4 01FA      MOVW	R30,R20
    01DF5 8422      LDD	R2,Z+10
    01DF6 8433      LDD	R3,Z+11
    01DF7 8444      LDD	R4,Z+12
    01DF8 8455      LDD	R5,Z+13
    01DF9 0112      MOVW	R2,R4
    01DFA 2444      CLR	R4
    01DFB 2455      CLR	R5
    01DFC 01FB      MOVW	R30,R22
    01DFD 8E26      STD	Z+30,R2
    01DFE E188      LDI	R24,0x18
    01DFF E090      LDI	R25,0
    01E00 01FA      MOVW	R30,R20
    01E01 8502      LDD	R16,Z+10
    01E02 8513      LDD	R17,Z+11
    01E03 8524      LDD	R18,Z+12
    01E04 8535      LDD	R19,Z+13
    01E05 938A      ST	-Y,R24
    01E06 940E 400F CALL	lsr32
    01E08 01FB      MOVW	R30,R22
    01E09 8F07      STD	Z+31,R16
(2619) 				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
    01E0A 01FA      MOVW	R30,R20
    01E0B 8426      LDD	R2,Z+14
    01E0C 8437      LDD	R3,Z+15
    01E0D 8840      LDD	R4,Z+16
    01E0E 8851      LDD	R5,Z+17
    01E0F 01FB      MOVW	R30,R22
    01E10 8E22      STD	Z+26,R2
    01E11 01FA      MOVW	R30,R20
    01E12 8426      LDD	R2,Z+14
    01E13 8437      LDD	R3,Z+15
    01E14 2C23      MOV	R2,R3
    01E15 2433      CLR	R3
    01E16 01FB      MOVW	R30,R22
    01E17 8E23      STD	Z+27,R2
    01E18 01FA      MOVW	R30,R20
    01E19 8426      LDD	R2,Z+14
    01E1A 8437      LDD	R3,Z+15
    01E1B 8840      LDD	R4,Z+16
    01E1C 8851      LDD	R5,Z+17
    01E1D 0112      MOVW	R2,R4
    01E1E 2444      CLR	R4
    01E1F 2455      CLR	R5
    01E20 01FB      MOVW	R30,R22
    01E21 8A24      STD	Z+20,R2
    01E22 01FA      MOVW	R30,R20
    01E23 8426      LDD	R2,Z+14
    01E24 8437      LDD	R3,Z+15
    01E25 8840      LDD	R4,Z+16
    01E26 8851      LDD	R5,Z+17
    01E27 0112      MOVW	R2,R4
    01E28 2C23      MOV	R2,R3
    01E29 2433      CLR	R3
    01E2A 01FB      MOVW	R30,R22
    01E2B 8A25      STD	Z+21,R2
(2620) 				tim = get_fattime();						/* Update updated time */
    01E2C 940E 02DE CALL	_get_fattime
    01E2E 830A      STD	Y+2,R16
    01E2F 831B      STD	Y+3,R17
    01E30 832C      STD	Y+4,R18
    01E31 833D      STD	Y+5,R19
(2621) 				ST_DWORD(dir+DIR_WrtTime, tim);
    01E32 802A      LDD	R2,Y+2
    01E33 803B      LDD	R3,Y+3
    01E34 804C      LDD	R4,Y+4
    01E35 805D      LDD	R5,Y+5
    01E36 01FB      MOVW	R30,R22
    01E37 8A26      STD	Z+22,R2
    01E38 2C23      MOV	R2,R3
    01E39 2433      CLR	R3
    01E3A 9677      ADIW	R30,0x17
    01E3B 8220      ST	Z,R2
    01E3C 802A      LDD	R2,Y+2
    01E3D 803B      LDD	R3,Y+3
    01E3E 804C      LDD	R4,Y+4
    01E3F 805D      LDD	R5,Y+5
    01E40 0112      MOVW	R2,R4
    01E41 2444      CLR	R4
    01E42 2455      CLR	R5
    01E43 01FB      MOVW	R30,R22
    01E44 9678      ADIW	R30,0x18
    01E45 8220      ST	Z,R2
    01E46 E188      LDI	R24,0x18
    01E47 E090      LDI	R25,0
    01E48 810A      LDD	R16,Y+2
    01E49 811B      LDD	R17,Y+3
    01E4A 812C      LDD	R18,Y+4
    01E4B 813D      LDD	R19,Y+5
    01E4C 938A      ST	-Y,R24
    01E4D 940E 400F CALL	lsr32
    01E4F 01FB      MOVW	R30,R22
    01E50 8F01      STD	Z+25,R16
(2622) 				fp->flag &= ~FA__WRITTEN;
    01E51 01BA      MOVW	R22,R20
    01E52 5F6C      SUBI	R22,0xFC
    01E53 4F7F      SBCI	R23,0xFF
    01E54 01FB      MOVW	R30,R22
    01E55 8180      LD	R24,Z
    01E56 7D8F      ANDI	R24,0xDF
    01E57 8380      ST	Z,R24
(2623) 				fp->fs->wflag = 1;
    01E58 E081      LDI	R24,1
    01E59 01FA      MOVW	R30,R20
    01E5A 93AF      PUSH	R26
    01E5B 93BF      PUSH	R27
    01E5C 81A0      LD	R26,Z
    01E5D 81B1      LDD	R27,Z+1
    01E5E 01FD      MOVW	R30,R26
    01E5F 91BF      POP	R27
    01E60 91AF      POP	R26
    01E61 8384      STD	Z+4,R24
(2624) 				res = sync(fp->fs);
    01E62 01FA      MOVW	R30,R20
    01E63 8100      LD	R16,Z
    01E64 8111      LDD	R17,Z+1
    01E65 940E 03DE CALL	ff.c:sync
    01E67 2EC0      MOV	R12,R16
    01E68 2CAC      MOV	R10,R12
(2625) 			}
(2626) 		}
(2627) 	}
(2628) 
(2629) 	LEAVE_FF(fp->fs, res);
    01E69 2D0A      MOV	R16,R10
    01E6A 9626      ADIW	R28,6
    01E6B 940C 3FB8 JMP	pop_xgsetF03C
_f_close:
  res                  --> R10
  fp                   --> R12
    01E6D 940E 3F7A CALL	push_xgset003C
    01E6F 0168      MOVW	R12,R16
(2630) }
(2631) 
(2632) #endif /* !_FS_READONLY */
(2633) 
(2634) 
(2635) 
(2636) 
(2637) /*-----------------------------------------------------------------------*/
(2638) /* Close File                                                            */
(2639) /*-----------------------------------------------------------------------*/
(2640) 
(2641) FRESULT f_close (
(2642) 	FIL *fp		/* Pointer to the file object to be closed */
(2643) )
(2644) {
(2645) 	FRESULT res;
(2646) 
(2647) #if _FS_READONLY
(2648) 	FATFS *fs = fp->fs;
(2649) 	res = validate(fs, fp->id);
(2650) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
(2651) 	LEAVE_FF(fs, res);
(2652) 
(2653) #else
(2654) 	res = f_sync(fp);		/* Flush cached data */
    01E70 0186      MOVW	R16,R12
    01E71 DF4A      RCALL	_f_sync
    01E72 2EA0      MOV	R10,R16
(2655) #if _FS_SHARE
(2656) 	if (res == FR_OK) {		/* Decrement open counter */
(2657) #if _FS_REENTRANT
(2658) 		res = validate(fp->fs, fp->id);
(2659) 		if (res == FR_OK) {
(2660) 			res = dec_lock(fp->lockid);	
(2661) 			unlock_fs(fp->fs, FR_OK);
(2662) 		}
(2663) #else
(2664) 		res = dec_lock(fp->lockid);
(2665) #endif
(2666) 	}
(2667) #endif
(2668) 	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    01E73 2300      TST	R16
    01E74 F429      BNE	0x1E7A
    01E75 2422      CLR	R2
    01E76 2433      CLR	R3
    01E77 01F6      MOVW	R30,R12
    01E78 8231      STD	Z+1,R3
    01E79 8220      ST	Z,R2
(2669) 	return res;
    01E7A 2D0A      MOV	R16,R10
    01E7B 940C 3F54 JMP	pop_xgset003C
_f_lseek:
  ifptr                --> Y,+14
  nsect                --> Y,+10
  bcs                  --> Y,+6
  clst                 --> Y,+2
  dsc                  --> Y,+26
  tlen                 --> Y,+22
  tbl                  --> R14
  tcl                  --> Y,+18
  ulen                 --> Y,+14
  ncl                  --> Y,+10
  pcl                  --> Y,+6
  cl                   --> Y,+2
  res                  --> R10
  ofs                  --> Y,+42
  fp                   --> Y,+40
    01E7D 940E 3E2F CALL	push_arg4
    01E7F 940E 3F74 CALL	push_xgsetF0FC
    01E81 976E      SBIW	R28,0x1E
(2670) #endif
(2671) }
(2672) 
(2673) 
(2674) 
(2675) 
(2676) /*-----------------------------------------------------------------------*/
(2677) /* Current Drive/Directory Handlings                                     */
(2678) /*-----------------------------------------------------------------------*/
(2679) 
(2680) #if _FS_RPATH >= 1
(2681) 
(2682) FRESULT f_chdrive (
(2683) 	BYTE drv		/* Drive number */
(2684) )
(2685) {
(2686) 	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
(2687) 
(2688) 	CurrVol = drv;
(2689) 
(2690) 	return FR_OK;
(2691) }
(2692) 
(2693) 
(2694) 
(2695) FRESULT f_chdir (
(2696) 	const TCHAR *path	/* Pointer to the directory path */
(2697) )
(2698) {
(2699) 	FRESULT res;
(2700) 	DIR dj;
(2701) 	DEF_NAMEBUF;
(2702) 
(2703) 
(2704) 	res = chk_mounted(&path, &dj.fs, 0);
(2705) 	if (res == FR_OK) {
(2706) 		INIT_BUF(dj);
(2707) 		res = follow_path(&dj, path);		/* Follow the path */
(2708) 		FREE_BUF();
(2709) 		if (res == FR_OK) {					/* Follow completed */
(2710) 			if (!dj.dir) {
(2711) 				dj.fs->cdir = dj.sclust;	/* Start directory itself */
(2712) 			} else {
(2713) 				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
(2714) 					dj.fs->cdir = LD_CLUST(dj.dir);
(2715) 				else
(2716) 					res = FR_NO_PATH;		/* Reached but a file */
(2717) 			}
(2718) 		}
(2719) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
(2720) 	}
(2721) 
(2722) 	LEAVE_FF(dj.fs, res);
(2723) }
(2724) 
(2725) 
(2726) #if _FS_RPATH >= 2
(2727) FRESULT f_getcwd (
(2728) 	TCHAR *path,	/* Pointer to the directory path */
(2729) 	UINT sz_path	/* Size of path */
(2730) )
(2731) {
(2732) 	FRESULT res;
(2733) 	DIR dj;
(2734) 	UINT i, n;
(2735) 	DWORD ccl;
(2736) 	TCHAR *tp;
(2737) 	FILINFO fno;
(2738) 	DEF_NAMEBUF;
(2739) 
(2740) 
(2741) 	*path = 0;
(2742) 	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
(2743) 	if (res == FR_OK) {
(2744) 		INIT_BUF(dj);
(2745) 		i = sz_path;		/* Bottom of buffer (dir stack base) */
(2746) 		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
(2747) 		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
(2748) 			res = dir_sdi(&dj, 1);			/* Get parent dir */
(2749) 			if (res != FR_OK) break;
(2750) 			res = dir_read(&dj);
(2751) 			if (res != FR_OK) break;
(2752) 			dj.sclust = LD_CLUST(dj.dir);	/* Goto parent dir */
(2753) 			res = dir_sdi(&dj, 0);
(2754) 			if (res != FR_OK) break;
(2755) 			do {							/* Find the entry links to the child dir */
(2756) 				res = dir_read(&dj);
(2757) 				if (res != FR_OK) break;
(2758) 				if (ccl == LD_CLUST(dj.dir)) break;	/* Found the entry */
(2759) 				res = dir_next(&dj, 0);	
(2760) 			} while (res == FR_OK);
(2761) 			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
(2762) 			if (res != FR_OK) break;
(2763) #if _USE_LFN
(2764) 			fno.lfname = path;
(2765) 			fno.lfsize = i;
(2766) #endif
(2767) 			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
(2768) 			tp = fno.fname;
(2769) 			if (_USE_LFN && *path) tp = path;
(2770) 			for (n = 0; tp[n]; n++) ;
(2771) 			if (i < n + 3) {
(2772) 				res = FR_NOT_ENOUGH_CORE; break;
(2773) 			}
(2774) 			while (n) path[--i] = tp[--n];
(2775) 			path[--i] = '/';
(2776) 		}
(2777) 		tp = path;
(2778) 		if (res == FR_OK) {
(2779) 			*tp++ = '0' + CurrVol;			/* Put drive number */
(2780) 			*tp++ = ':';
(2781) 			if (i == sz_path) {				/* Root-dir */
(2782) 				*tp++ = '/';
(2783) 			} else {						/* Sub-dir */
(2784) 				do		/* Add stacked path str */
(2785) 					*tp++ = path[i++];
(2786) 				while (i < sz_path);
(2787) 			}
(2788) 		}
(2789) 		*tp = 0;
(2790) 		FREE_BUF();
(2791) 	}
(2792) 
(2793) 	LEAVE_FF(dj.fs, res);
(2794) }
(2795) #endif /* _FS_RPATH >= 2 */
(2796) #endif /* _FS_RPATH >= 1 */
(2797) 
(2798) 
(2799) 
(2800) #if _FS_MINIMIZE <= 2
(2801) /*-----------------------------------------------------------------------*/
(2802) /* Seek File R/W Pointer                                                 */
(2803) /*-----------------------------------------------------------------------*/
(2804) 
(2805) FRESULT f_lseek (
(2806) 	FIL *fp,		/* Pointer to the file object */
(2807) 	DWORD ofs		/* File pointer from top of file */
(2808) )
(2809) {
(2810) 	FRESULT res;
(2811) 
(2812) 
(2813) 	res = validate(fp->fs, fp->id);		/* Check validity of the object */
    01E82 A5E8      LDD	R30,Y+40
    01E83 A5F9      LDD	R31,Y+41
    01E84 8122      LDD	R18,Z+2
    01E85 8133      LDD	R19,Z+3
    01E86 8100      LD	R16,Z
    01E87 8111      LDD	R17,Z+1
    01E88 940E 1654 CALL	ff.c:validate
    01E8A 2EA0      MOV	R10,R16
(2814) 	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    01E8B 2300      TST	R16
    01E8C F009      BEQ	0x1E8E
    01E8D C4A7      RJMP	0x2335
(2815) 	if (fp->flag & FA__ERROR)			/* Check abort flag */
    01E8E A5E8      LDD	R30,Y+40
    01E8F A5F9      LDD	R31,Y+41
    01E90 8024      LDD	R2,Z+4
    01E91 FE27      SBRS	R2,7
    01E92 C002      RJMP	0x1E95
(2816) 		LEAVE_FF(fp->fs, FR_INT_ERR);
    01E93 E002      LDI	R16,2
    01E94 C4A0      RJMP	0x2335
(2817) 
(2818) #if _USE_FASTSEEK
(2819) 	if (fp->cltbl) {	/* Fast seek */
    01E95 A5E8      LDD	R30,Y+40
    01E96 A5F9      LDD	R31,Y+41
    01E97 96B0      ADIW	R30,0x20
    01E98 8020      LD	R2,Z
    01E99 8031      LDD	R3,Z+1
    01E9A 2022      TST	R2
    01E9B F419      BNE	0x1E9F
    01E9C 2033      TST	R3
    01E9D F409      BNE	0x1E9F
    01E9E C1E3      RJMP	0x2082
(2820) 		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
(2821) 
(2822) 		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
    01E9F EF4F      LDI	R20,0xFF
    01EA0 EF5F      LDI	R21,0xFF
    01EA1 EF6F      LDI	R22,0xFF
    01EA2 EF7F      LDI	R23,0xFF
    01EA3 A42A      LDD	R2,Y+42
    01EA4 A43B      LDD	R3,Y+43
    01EA5 A44C      LDD	R4,Y+44
    01EA6 A45D      LDD	R5,Y+45
    01EA7 1624      CP	R2,R20
    01EA8 0635      CPC	R3,R21
    01EA9 0646      CPC	R4,R22
    01EAA 0657      CPC	R5,R23
    01EAB F009      BEQ	0x1EAD
    01EAC C109      RJMP	0x1FB6
(2823) 			tbl = fp->cltbl;
    01EAD A5E8      LDD	R30,Y+40
    01EAE A5F9      LDD	R31,Y+41
    01EAF A0E0      LDD	R14,Z+32
    01EB0 A0F1      LDD	R15,Z+33
(2824) 			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
    01EB1 01F7      MOVW	R30,R14
    01EB2 9021      LD	R2,Z+
    01EB3 9031      LD	R3,Z+
    01EB4 9041      LD	R4,Z+
    01EB5 9051      LD	R5,Z+
    01EB6 017F      MOVW	R14,R30
    01EB7 8A2E      STD	Y+22,R2
    01EB8 8A3F      STD	Y+23,R3
    01EB9 8E48      STD	Y+24,R4
    01EBA 8E59      STD	Y+25,R5
    01EBB E082      LDI	R24,2
    01EBC 878E      STD	Y+14,R24
    01EBD E080      LDI	R24,0
    01EBE 878F      STD	Y+15,R24
    01EBF 8B88      STD	Y+16,R24
    01EC0 8B89      STD	Y+17,R24
(2825) 			cl = fp->sclust;			/* Top of the chain */
    01EC1 A5E8      LDD	R30,Y+40
    01EC2 A5F9      LDD	R31,Y+41
    01EC3 963E      ADIW	R30,0xE
    01EC4 8020      LD	R2,Z
    01EC5 8031      LDD	R3,Z+1
    01EC6 8042      LDD	R4,Z+2
    01EC7 8053      LDD	R5,Z+3
    01EC8 822A      STD	Y+2,R2
    01EC9 823B      STD	Y+3,R3
    01ECA 824C      STD	Y+4,R4
    01ECB 825D      STD	Y+5,R5
(2826) 			if (cl) {
    01ECC 802A      LDD	R2,Y+2
    01ECD 803B      LDD	R3,Y+3
    01ECE 804C      LDD	R4,Y+4
    01ECF 805D      LDD	R5,Y+5
    01ED0 9488      BCLR	0
    01ED1 2022      TST	R2
    01ED2 0432      CPC	R3,R2
    01ED3 0442      CPC	R4,R2
    01ED4 0452      CPC	R5,R2
    01ED5 F409      BNE	0x1ED7
    01ED6 C0BB      RJMP	0x1F92
(2827) 				do {
(2828) 					/* Get a fragment */
(2829) 					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
    01ED7 802A      LDD	R2,Y+2
    01ED8 803B      LDD	R3,Y+3
    01ED9 804C      LDD	R4,Y+4
    01EDA 805D      LDD	R5,Y+5
    01EDB 8A2A      STD	Y+18,R2
    01EDC 8A3B      STD	Y+19,R3
    01EDD 8A4C      STD	Y+20,R4
    01EDE 8A5D      STD	Y+21,R5
    01EDF E080      LDI	R24,0
    01EE0 878A      STD	Y+10,R24
    01EE1 878B      STD	Y+11,R24
    01EE2 878C      STD	Y+12,R24
    01EE3 878D      STD	Y+13,R24
    01EE4 E042      LDI	R20,2
    01EE5 E050      LDI	R21,0
    01EE6 E060      LDI	R22,0
    01EE7 E070      LDI	R23,0
    01EE8 842E      LDD	R2,Y+14
    01EE9 843F      LDD	R3,Y+15
    01EEA 8848      LDD	R4,Y+16
    01EEB 8859      LDD	R5,Y+17
    01EEC 0E24      ADD	R2,R20
    01EED 1E35      ADC	R3,R21
    01EEE 1E46      ADC	R4,R22
    01EEF 1E57      ADC	R5,R23
    01EF0 862E      STD	Y+14,R2
    01EF1 863F      STD	Y+15,R3
    01EF2 8A48      STD	Y+16,R4
    01EF3 8A59      STD	Y+17,R5
(2830) 					do {
(2831) 						pcl = cl; ncl++;
    01EF4 802A      LDD	R2,Y+2
    01EF5 803B      LDD	R3,Y+3
    01EF6 804C      LDD	R4,Y+4
    01EF7 805D      LDD	R5,Y+5
    01EF8 822E      STD	Y+6,R2
    01EF9 823F      STD	Y+7,R3
    01EFA 8648      STD	Y+8,R4
    01EFB 8659      STD	Y+9,R5
    01EFC E041      LDI	R20,1
    01EFD E050      LDI	R21,0
    01EFE E060      LDI	R22,0
    01EFF E070      LDI	R23,0
    01F00 842A      LDD	R2,Y+10
    01F01 843B      LDD	R3,Y+11
    01F02 844C      LDD	R4,Y+12
    01F03 845D      LDD	R5,Y+13
    01F04 0E24      ADD	R2,R20
    01F05 1E35      ADC	R3,R21
    01F06 1E46      ADC	R4,R22
    01F07 1E57      ADC	R5,R23
    01F08 862A      STD	Y+10,R2
    01F09 863B      STD	Y+11,R3
    01F0A 864C      STD	Y+12,R4
    01F0B 865D      STD	Y+13,R5
(2832) 						cl = get_fat(fp->fs, cl);
    01F0C 802A      LDD	R2,Y+2
    01F0D 803B      LDD	R3,Y+3
    01F0E 804C      LDD	R4,Y+4
    01F0F 805D      LDD	R5,Y+5
    01F10 8248      ST	Y,R4
    01F11 8259      STD	Y+1,R5
    01F12 0191      MOVW	R18,R2
    01F13 A5E8      LDD	R30,Y+40
    01F14 A5F9      LDD	R31,Y+41
    01F15 8100      LD	R16,Z
    01F16 8111      LDD	R17,Z+1
    01F17 940E 0505 CALL	_get_fat
    01F19 830A      STD	Y+2,R16
    01F1A 831B      STD	Y+3,R17
    01F1B 832C      STD	Y+4,R18
    01F1C 833D      STD	Y+5,R19
(2833) 						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
    01F1D E041      LDI	R20,1
    01F1E E050      LDI	R21,0
    01F1F E060      LDI	R22,0
    01F20 E070      LDI	R23,0
    01F21 802A      LDD	R2,Y+2
    01F22 803B      LDD	R3,Y+3
    01F23 804C      LDD	R4,Y+4
    01F24 805D      LDD	R5,Y+5
    01F25 1542      CP	R20,R2
    01F26 0553      CPC	R21,R3
    01F27 0564      CPC	R22,R4
    01F28 0575      CPC	R23,R5
    01F29 F048      BCS	0x1F33
    01F2A A588      LDD	R24,Y+40
    01F2B A599      LDD	R25,Y+41
    01F2C 9604      ADIW	R24,4
    01F2D 01FC      MOVW	R30,R24
    01F2E 8180      LD	R24,Z
    01F2F 6880      ORI	R24,0x80
    01F30 8380      ST	Z,R24
    01F31 E002      LDI	R16,2
    01F32 C402      RJMP	0x2335
(2834) 						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    01F33 EF4F      LDI	R20,0xFF
    01F34 EF5F      LDI	R21,0xFF
    01F35 EF6F      LDI	R22,0xFF
    01F36 EF7F      LDI	R23,0xFF
    01F37 802A      LDD	R2,Y+2
    01F38 803B      LDD	R3,Y+3
    01F39 804C      LDD	R4,Y+4
    01F3A 805D      LDD	R5,Y+5
    01F3B 1624      CP	R2,R20
    01F3C 0635      CPC	R3,R21
    01F3D 0646      CPC	R4,R22
    01F3E 0657      CPC	R5,R23
    01F3F F451      BNE	0x1F4A
    01F40 A588      LDD	R24,Y+40
    01F41 A599      LDD	R25,Y+41
    01F42 9604      ADIW	R24,4
    01F43 016C      MOVW	R12,R24
    01F44 01FC      MOVW	R30,R24
    01F45 8180      LD	R24,Z
    01F46 6880      ORI	R24,0x80
    01F47 8380      ST	Z,R24
    01F48 E001      LDI	R16,1
    01F49 C3EB      RJMP	0x2335
(2835) 					} while (cl == pcl + 1);
    01F4A E041      LDI	R20,1
    01F4B E050      LDI	R21,0
    01F4C E060      LDI	R22,0
    01F4D E070      LDI	R23,0
    01F4E 802E      LDD	R2,Y+6
    01F4F 803F      LDD	R3,Y+7
    01F50 8448      LDD	R4,Y+8
    01F51 8459      LDD	R5,Y+9
    01F52 0E24      ADD	R2,R20
    01F53 1E35      ADC	R3,R21
    01F54 1E46      ADC	R4,R22
    01F55 1E57      ADC	R5,R23
    01F56 806A      LDD	R6,Y+2
    01F57 807B      LDD	R7,Y+3
    01F58 808C      LDD	R8,Y+4
    01F59 809D      LDD	R9,Y+5
    01F5A 1462      CP	R6,R2
    01F5B 0473      CPC	R7,R3
    01F5C 0484      CPC	R8,R4
    01F5D 0495      CPC	R9,R5
    01F5E F409      BNE	0x1F60
    01F5F CF94      RJMP	0x1EF4
(2836) 					if (ulen <= tlen) {		/* Store the length and top of the fragment */
    01F60 882E      LDD	R2,Y+22
    01F61 883F      LDD	R3,Y+23
    01F62 8C48      LDD	R4,Y+24
    01F63 8C59      LDD	R5,Y+25
    01F64 846E      LDD	R6,Y+14
    01F65 847F      LDD	R7,Y+15
    01F66 8888      LDD	R8,Y+16
    01F67 8899      LDD	R9,Y+17
    01F68 1426      CP	R2,R6
    01F69 0437      CPC	R3,R7
    01F6A 0448      CPC	R4,R8
    01F6B 0459      CPC	R5,R9
    01F6C F090      BCS	0x1F7F
(2837) 						*tbl++ = ncl; *tbl++ = tcl;
    01F6D 842A      LDD	R2,Y+10
    01F6E 843B      LDD	R3,Y+11
    01F6F 844C      LDD	R4,Y+12
    01F70 845D      LDD	R5,Y+13
    01F71 01F7      MOVW	R30,R14
    01F72 9221      ST	Z+,R2
    01F73 9231      ST	Z+,R3
    01F74 9241      ST	Z+,R4
    01F75 9251      ST	Z+,R5
    01F76 882A      LDD	R2,Y+18
    01F77 883B      LDD	R3,Y+19
    01F78 884C      LDD	R4,Y+20
    01F79 885D      LDD	R5,Y+21
    01F7A 9221      ST	Z+,R2
    01F7B 9231      ST	Z+,R3
    01F7C 9241      ST	Z+,R4
    01F7D 9251      ST	Z+,R5
    01F7E 017F      MOVW	R14,R30
(2838) 					}
(2839) 				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
    01F7F A5E8      LDD	R30,Y+40
    01F80 A5F9      LDD	R31,Y+41
    01F81 81A0      LD	R26,Z
    01F82 81B1      LDD	R27,Z+1
    01F83 9656      ADIW	R26,0x16
    01F84 902D      LD	R2,X+
    01F85 903D      LD	R3,X+
    01F86 904D      LD	R4,X+
    01F87 905C      LD	R5,X
    01F88 806A      LDD	R6,Y+2
    01F89 807B      LDD	R7,Y+3
    01F8A 808C      LDD	R8,Y+4
    01F8B 809D      LDD	R9,Y+5
    01F8C 1462      CP	R6,R2
    01F8D 0473      CPC	R7,R3
    01F8E 0484      CPC	R8,R4
    01F8F 0495      CPC	R9,R5
    01F90 F408      BCC	0x1F92
    01F91 CF45      RJMP	0x1ED7
(2840) 			}
(2841) 			*fp->cltbl = ulen;	/* Number of items used */
    01F92 842E      LDD	R2,Y+14
    01F93 843F      LDD	R3,Y+15
    01F94 8848      LDD	R4,Y+16
    01F95 8859      LDD	R5,Y+17
    01F96 A5E8      LDD	R30,Y+40
    01F97 A5F9      LDD	R31,Y+41
    01F98 96B0      ADIW	R30,0x20
    01F99 81A0      LD	R26,Z
    01F9A 81B1      LDD	R27,Z+1
    01F9B 922D      ST	X+,R2
    01F9C 923D      ST	X+,R3
    01F9D 924D      ST	X+,R4
    01F9E 925C      ST	X,R5
(2842) 			if (ulen <= tlen)
    01F9F 882E      LDD	R2,Y+22
    01FA0 883F      LDD	R3,Y+23
    01FA1 8C48      LDD	R4,Y+24
    01FA2 8C59      LDD	R5,Y+25
    01FA3 846E      LDD	R6,Y+14
    01FA4 847F      LDD	R7,Y+15
    01FA5 8888      LDD	R8,Y+16
    01FA6 8899      LDD	R9,Y+17
    01FA7 1426      CP	R2,R6
    01FA8 0437      CPC	R3,R7
    01FA9 0448      CPC	R4,R8
    01FAA 0459      CPC	R5,R9
    01FAB F038      BCS	0x1FB3
(2843) 				*tbl = 0;		/* Terminate table */
    01FAC 01F7      MOVW	R30,R14
    01FAD E080      LDI	R24,0
    01FAE 8380      ST	Z,R24
    01FAF 8381      STD	Z+1,R24
    01FB0 8382      STD	Z+2,R24
    01FB1 8383      STD	Z+3,R24
    01FB2 C381      RJMP	0x2334
(2844) 			else
(2845) 				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
    01FB3 E181      LDI	R24,0x11
    01FB4 2EA8      MOV	R10,R24
(2846) 
(2847) 		} else {						/* Fast seek */
    01FB5 C37E      RJMP	0x2334
(2848) 			if (ofs > fp->fsize)		/* Clip offset at the file size */
    01FB6 A5E8      LDD	R30,Y+40
    01FB7 A5F9      LDD	R31,Y+41
    01FB8 963A      ADIW	R30,0xA
    01FB9 8020      LD	R2,Z
    01FBA 8031      LDD	R3,Z+1
    01FBB 8042      LDD	R4,Z+2
    01FBC 8053      LDD	R5,Z+3
    01FBD A46A      LDD	R6,Y+42
    01FBE A47B      LDD	R7,Y+43
    01FBF A48C      LDD	R8,Y+44
    01FC0 A49D      LDD	R9,Y+45
    01FC1 1426      CP	R2,R6
    01FC2 0437      CPC	R3,R7
    01FC3 0448      CPC	R4,R8
    01FC4 0459      CPC	R5,R9
    01FC5 F458      BCC	0x1FD1
(2849) 				ofs = fp->fsize;
    01FC6 A5E8      LDD	R30,Y+40
    01FC7 A5F9      LDD	R31,Y+41
    01FC8 963A      ADIW	R30,0xA
    01FC9 8020      LD	R2,Z
    01FCA 8031      LDD	R3,Z+1
    01FCB 8042      LDD	R4,Z+2
    01FCC 8053      LDD	R5,Z+3
    01FCD A62A      STD	Y+42,R2
    01FCE A63B      STD	Y+43,R3
    01FCF A64C      STD	Y+44,R4
    01FD0 A65D      STD	Y+45,R5
(2850) 			fp->fptr = ofs;				/* Set file pointer */
    01FD1 A42A      LDD	R2,Y+42
    01FD2 A43B      LDD	R3,Y+43
    01FD3 A44C      LDD	R4,Y+44
    01FD4 A45D      LDD	R5,Y+45
    01FD5 A5E8      LDD	R30,Y+40
    01FD6 A5F9      LDD	R31,Y+41
    01FD7 9636      ADIW	R30,6
    01FD8 8220      ST	Z,R2
    01FD9 8231      STD	Z+1,R3
    01FDA 8242      STD	Z+2,R4
    01FDB 8253      STD	Z+3,R5
(2851) 			if (ofs) {
    01FDC 9488      BCLR	0
    01FDD 2022      TST	R2
    01FDE 0432      CPC	R3,R2
    01FDF 0442      CPC	R4,R2
    01FE0 0452      CPC	R5,R2
    01FE1 F409      BNE	0x1FE3
    01FE2 C351      RJMP	0x2334
(2852) 				fp->clust = clmt_clust(fp, ofs - 1);
    01FE3 E041      LDI	R20,1
    01FE4 E050      LDI	R21,0
    01FE5 E060      LDI	R22,0
    01FE6 E070      LDI	R23,0
    01FE7 1A24      SUB	R2,R20
    01FE8 0A35      SBC	R3,R21
    01FE9 0A46      SBC	R4,R22
    01FEA 0A57      SBC	R5,R23
    01FEB 8248      ST	Y,R4
    01FEC 8259      STD	Y+1,R5
    01FED 0191      MOVW	R18,R2
    01FEE A508      LDD	R16,Y+40
    01FEF A519      LDD	R17,Y+41
    01FF0 940E 0A3F CALL	ff.c:clmt_clust
    01FF2 A5E8      LDD	R30,Y+40
    01FF3 A5F9      LDD	R31,Y+41
    01FF4 8B02      STD	Z+18,R16
    01FF5 8B13      STD	Z+19,R17
    01FF6 8B24      STD	Z+20,R18
    01FF7 8B35      STD	Z+21,R19
(2853) 				dsc = clust2sect(fp->fs, fp->clust);
    01FF8 8822      LDD	R2,Z+18
    01FF9 8833      LDD	R3,Z+19
    01FFA 8844      LDD	R4,Z+20
    01FFB 8855      LDD	R5,Z+21
    01FFC 8248      ST	Y,R4
    01FFD 8259      STD	Y+1,R5
    01FFE 0191      MOVW	R18,R2
    01FFF 8100      LD	R16,Z
    02000 8111      LDD	R17,Z+1
    02001 940E 04B3 CALL	_clust2sect
    02003 8F0A      STD	Y+26,R16
    02004 8F1B      STD	Y+27,R17
    02005 8F2C      STD	Y+28,R18
    02006 8F3D      STD	Y+29,R19
(2854) 				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
    02007 8C2A      LDD	R2,Y+26
    02008 8C3B      LDD	R3,Y+27
    02009 8C4C      LDD	R4,Y+28
    0200A 8C5D      LDD	R5,Y+29
    0200B 9488      BCLR	0
    0200C 2022      TST	R2
    0200D 0432      CPC	R3,R2
    0200E 0442      CPC	R4,R2
    0200F 0452      CPC	R5,R2
    02010 F451      BNE	0x201B
    02011 A588      LDD	R24,Y+40
    02012 A599      LDD	R25,Y+41
    02013 9604      ADIW	R24,4
    02014 017C      MOVW	R14,R24
    02015 01FC      MOVW	R30,R24
    02016 8180      LD	R24,Z
    02017 6880      ORI	R24,0x80
    02018 8380      ST	Z,R24
    02019 E002      LDI	R16,2
    0201A C31A      RJMP	0x2335
(2855) 				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
    0201B E041      LDI	R20,1
    0201C E050      LDI	R21,0
    0201D E060      LDI	R22,0
    0201E E070      LDI	R23,0
    0201F A50A      LDD	R16,Y+42
    02020 A51B      LDD	R17,Y+43
    02021 A52C      LDD	R18,Y+44
    02022 A53D      LDD	R19,Y+45
    02023 1B04      SUB	R16,R20
    02024 0B15      SBC	R17,R21
    02025 0B26      SBC	R18,R22
    02026 0B37      SBC	R19,R23
    02027 E089      LDI	R24,0x9
    02028 E090      LDI	R25,0
    02029 938A      ST	-Y,R24
    0202A 940E 400F CALL	lsr32
    0202C 0118      MOVW	R2,R16
    0202D 0129      MOVW	R4,R18
    0202E A5E8      LDD	R30,Y+40
    0202F A5F9      LDD	R31,Y+41
    02030 93AF      PUSH	R26
    02031 93BF      PUSH	R27
    02032 81A0      LD	R26,Z
    02033 81B1      LDD	R27,Z+1
    02034 01FD      MOVW	R30,R26
    02035 91BF      POP	R27
    02036 91AF      POP	R26
    02037 9632      ADIW	R30,2
    02038 8180      LD	R24,Z
    02039 2799      CLR	R25
    0203A 9701      SBIW	R24,1
    0203B 013C      MOVW	R6,R24
    0203C 2488      CLR	R8
    0203D FC77      SBRC	R7,7
    0203E 9480      COM	R8
    0203F 2499      CLR	R9
    02040 FC87      SBRC	R8,7
    02041 9490      COM	R9
    02042 2026      AND	R2,R6
    02043 2037      AND	R3,R7
    02044 2048      AND	R4,R8
    02045 2059      AND	R5,R9
    02046 8C6A      LDD	R6,Y+26
    02047 8C7B      LDD	R7,Y+27
    02048 8C8C      LDD	R8,Y+28
    02049 8C9D      LDD	R9,Y+29
    0204A 0C62      ADD	R6,R2
    0204B 1C73      ADC	R7,R3
    0204C 1C84      ADC	R8,R4
    0204D 1C95      ADC	R9,R5
    0204E 8E6A      STD	Y+26,R6
    0204F 8E7B      STD	Y+27,R7
    02050 8E8C      STD	Y+28,R8
    02051 8E9D      STD	Y+29,R9
(2856) 				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
    02052 EF4F      LDI	R20,0xFF
    02053 E051      LDI	R21,1
    02054 E060      LDI	R22,0
    02055 E070      LDI	R23,0
    02056 A5E8      LDD	R30,Y+40
    02057 A5F9      LDD	R31,Y+41
    02058 9636      ADIW	R30,6
    02059 8020      LD	R2,Z
    0205A 8031      LDD	R3,Z+1
    0205B 8042      LDD	R4,Z+2
    0205C 8053      LDD	R5,Z+3
    0205D 2224      AND	R2,R20
    0205E 2235      AND	R3,R21
    0205F 2246      AND	R4,R22
    02060 2257      AND	R5,R23
    02061 9488      BCLR	0
    02062 2022      TST	R2
    02063 0432      CPC	R3,R2
    02064 0442      CPC	R4,R2
    02065 0452      CPC	R5,R2
    02066 F409      BNE	0x2068
    02067 C2CC      RJMP	0x2334
    02068 A5E8      LDD	R30,Y+40
    02069 A5F9      LDD	R31,Y+41
    0206A 9676      ADIW	R30,0x16
    0206B 8020      LD	R2,Z
    0206C 8031      LDD	R3,Z+1
    0206D 8042      LDD	R4,Z+2
    0206E 8053      LDD	R5,Z+3
    0206F 8C6A      LDD	R6,Y+26
    02070 8C7B      LDD	R7,Y+27
    02071 8C8C      LDD	R8,Y+28
    02072 8C9D      LDD	R9,Y+29
    02073 1462      CP	R6,R2
    02074 0473      CPC	R7,R3
    02075 0484      CPC	R8,R4
    02076 0495      CPC	R9,R5
    02077 F409      BNE	0x2079
    02078 C2BB      RJMP	0x2334
(2857) #if !_FS_TINY
(2858) #if !_FS_READONLY
(2859) 					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
(2860) 						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2861) 							ABORT(fp->fs, FR_DISK_ERR);
(2862) 						fp->flag &= ~FA__DIRTY;
(2863) 					}
(2864) #endif
(2865) 					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
(2866) 						ABORT(fp->fs, FR_DISK_ERR);
(2867) #endif
(2868) 					fp->dsect = dsc;
    02079 0113      MOVW	R2,R6
    0207A 0124      MOVW	R4,R8
    0207B A5E8      LDD	R30,Y+40
    0207C A5F9      LDD	R31,Y+41
    0207D 8A26      STD	Z+22,R2
    0207E 8A37      STD	Z+23,R3
    0207F 8E40      STD	Z+24,R4
    02080 8E51      STD	Z+25,R5
(2869) 				}
(2870) 			}
(2871) 		}
(2872) 	} else
    02081 C2B2      RJMP	0x2334
(2873) #endif
(2874) 
(2875) 	/* Normal Seek */
(2876) 	{
(2877) 		DWORD clst, bcs, nsect, ifptr;
(2878) 
(2879) 		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
    02082 A5E8      LDD	R30,Y+40
    02083 A5F9      LDD	R31,Y+41
    02084 963A      ADIW	R30,0xA
    02085 8020      LD	R2,Z
    02086 8031      LDD	R3,Z+1
    02087 8042      LDD	R4,Z+2
    02088 8053      LDD	R5,Z+3
    02089 A46A      LDD	R6,Y+42
    0208A A47B      LDD	R7,Y+43
    0208B A48C      LDD	R8,Y+44
    0208C A49D      LDD	R9,Y+45
    0208D 1426      CP	R2,R6
    0208E 0437      CPC	R3,R7
    0208F 0448      CPC	R4,R8
    02090 0459      CPC	R5,R9
    02091 F470      BCC	0x20A0
    02092 A5E8      LDD	R30,Y+40
    02093 A5F9      LDD	R31,Y+41
    02094 8024      LDD	R2,Z+4
    02095 FC21      SBRC	R2,1
    02096 C009      RJMP	0x20A0
(2880) #if !_FS_READONLY
(2881) 			 && !(fp->flag & FA_WRITE)
(2882) #endif
(2883) 			) ofs = fp->fsize;
    02097 963A      ADIW	R30,0xA
    02098 8020      LD	R2,Z
    02099 8031      LDD	R3,Z+1
    0209A 8042      LDD	R4,Z+2
    0209B 8053      LDD	R5,Z+3
    0209C A62A      STD	Y+42,R2
    0209D A63B      STD	Y+43,R3
    0209E A64C      STD	Y+44,R4
    0209F A65D      STD	Y+45,R5
(2884) 
(2885) 		ifptr = fp->fptr;
    020A0 A5E8      LDD	R30,Y+40
    020A1 A5F9      LDD	R31,Y+41
    020A2 9636      ADIW	R30,6
    020A3 8020      LD	R2,Z
    020A4 8031      LDD	R3,Z+1
    020A5 8042      LDD	R4,Z+2
    020A6 8053      LDD	R5,Z+3
    020A7 862E      STD	Y+14,R2
    020A8 863F      STD	Y+15,R3
    020A9 8A48      STD	Y+16,R4
    020AA 8A59      STD	Y+17,R5
(2886) 		fp->fptr = nsect = 0;
    020AB E080      LDI	R24,0
    020AC 878A      STD	Y+10,R24
    020AD 878B      STD	Y+11,R24
    020AE 878C      STD	Y+12,R24
    020AF 878D      STD	Y+13,R24
    020B0 A5E8      LDD	R30,Y+40
    020B1 A5F9      LDD	R31,Y+41
    020B2 9636      ADIW	R30,6
    020B3 E080      LDI	R24,0
    020B4 8380      ST	Z,R24
    020B5 8381      STD	Z+1,R24
    020B6 8382      STD	Z+2,R24
    020B7 8383      STD	Z+3,R24
(2887) 		if (ofs) {
    020B8 A42A      LDD	R2,Y+42
    020B9 A43B      LDD	R3,Y+43
    020BA A44C      LDD	R4,Y+44
    020BB A45D      LDD	R5,Y+45
    020BC 9488      BCLR	0
    020BD 2022      TST	R2
    020BE 0432      CPC	R3,R2
    020BF 0442      CPC	R4,R2
    020C0 0452      CPC	R5,R2
    020C1 F409      BNE	0x20C3
    020C2 C226      RJMP	0x22E9
(2888) 			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    020C3 A5E8      LDD	R30,Y+40
    020C4 A5F9      LDD	R31,Y+41
    020C5 93AF      PUSH	R26
    020C6 93BF      PUSH	R27
    020C7 81A0      LD	R26,Z
    020C8 81B1      LDD	R27,Z+1
    020C9 01FD      MOVW	R30,R26
    020CA 91BF      POP	R27
    020CB 91AF      POP	R26
    020CC 9632      ADIW	R30,2
    020CD 8020      LD	R2,Z
    020CE 2433      CLR	R3
    020CF 2444      CLR	R4
    020D0 2455      CLR	R5
    020D1 E040      LDI	R20,0
    020D2 E052      LDI	R21,2
    020D3 E060      LDI	R22,0
    020D4 E070      LDI	R23,0
    020D5 925A      ST	-Y,R5
    020D6 924A      ST	-Y,R4
    020D7 923A      ST	-Y,R3
    020D8 922A      ST	-Y,R2
    020D9 018A      MOVW	R16,R20
    020DA 019B      MOVW	R18,R22
    020DB 940E 3F20 CALL	empy32u|empy32s
    020DD 830E      STD	Y+6,R16
    020DE 831F      STD	Y+7,R17
    020DF 8728      STD	Y+8,R18
    020E0 8739      STD	Y+9,R19
(2889) 			if (ifptr > 0 &&
    020E1 842E      LDD	R2,Y+14
    020E2 843F      LDD	R3,Y+15
    020E3 8848      LDD	R4,Y+16
    020E4 8859      LDD	R5,Y+17
    020E5 9488      BCLR	0
    020E6 2022      TST	R2
    020E7 0432      CPC	R3,R2
    020E8 0442      CPC	R4,R2
    020E9 0452      CPC	R5,R2
    020EA F409      BNE	0x20EC
    020EB C075      RJMP	0x2161
    020EC E041      LDI	R20,1
    020ED E050      LDI	R21,0
    020EE E060      LDI	R22,0
    020EF E070      LDI	R23,0
    020F0 0181      MOVW	R16,R2
    020F1 0192      MOVW	R18,R4
    020F2 1B04      SUB	R16,R20
    020F3 0B15      SBC	R17,R21
    020F4 0B26      SBC	R18,R22
    020F5 0B37      SBC	R19,R23
    020F6 802E      LDD	R2,Y+6
    020F7 803F      LDD	R3,Y+7
    020F8 8448      LDD	R4,Y+8
    020F9 8459      LDD	R5,Y+9
    020FA 925A      ST	-Y,R5
    020FB 924A      ST	-Y,R4
    020FC 923A      ST	-Y,R3
    020FD 922A      ST	-Y,R2
    020FE 940E 3E7A CALL	div32u
    02100 0118      MOVW	R2,R16
    02101 0129      MOVW	R4,R18
    02102 E041      LDI	R20,1
    02103 E050      LDI	R21,0
    02104 E060      LDI	R22,0
    02105 E070      LDI	R23,0
    02106 A50A      LDD	R16,Y+42
    02107 A51B      LDD	R17,Y+43
    02108 A52C      LDD	R18,Y+44
    02109 A53D      LDD	R19,Y+45
    0210A 1B04      SUB	R16,R20
    0210B 0B15      SBC	R17,R21
    0210C 0B26      SBC	R18,R22
    0210D 0B37      SBC	R19,R23
    0210E 806E      LDD	R6,Y+6
    0210F 807F      LDD	R7,Y+7
    02110 8488      LDD	R8,Y+8
    02111 8499      LDD	R9,Y+9
    02112 929A      ST	-Y,R9
    02113 928A      ST	-Y,R8
    02114 927A      ST	-Y,R7
    02115 926A      ST	-Y,R6
    02116 940E 3E7A CALL	div32u
    02118 1502      CP	R16,R2
    02119 0513      CPC	R17,R3
    0211A 0524      CPC	R18,R4
    0211B 0535      CPC	R19,R5
    0211C F408      BCC	0x211E
    0211D C043      RJMP	0x2161
(2890) 				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
(2891) 				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    0211E E041      LDI	R20,1
    0211F E050      LDI	R21,0
    02120 E060      LDI	R22,0
    02121 E070      LDI	R23,0
    02122 802E      LDD	R2,Y+6
    02123 803F      LDD	R3,Y+7
    02124 8448      LDD	R4,Y+8
    02125 8459      LDD	R5,Y+9
    02126 1A24      SUB	R2,R20
    02127 0A35      SBC	R3,R21
    02128 0A46      SBC	R4,R22
    02129 0A57      SBC	R5,R23
    0212A 9420      COM	R2
    0212B 9430      COM	R3
    0212C 9440      COM	R4
    0212D 9450      COM	R5
    0212E E041      LDI	R20,1
    0212F E050      LDI	R21,0
    02130 E060      LDI	R22,0
    02131 E070      LDI	R23,0
    02132 846E      LDD	R6,Y+14
    02133 847F      LDD	R7,Y+15
    02134 8888      LDD	R8,Y+16
    02135 8899      LDD	R9,Y+17
    02136 1A64      SUB	R6,R20
    02137 0A75      SBC	R7,R21
    02138 0A86      SBC	R8,R22
    02139 0A97      SBC	R9,R23
    0213A 2062      AND	R6,R2
    0213B 2073      AND	R7,R3
    0213C 2084      AND	R8,R4
    0213D 2095      AND	R9,R5
    0213E A5E8      LDD	R30,Y+40
    0213F A5F9      LDD	R31,Y+41
    02140 8266      STD	Z+6,R6
    02141 8277      STD	Z+7,R7
    02142 8680      STD	Z+8,R8
    02143 8691      STD	Z+9,R9
(2892) 				ofs -= fp->fptr;
    02144 9636      ADIW	R30,6
    02145 8020      LD	R2,Z
    02146 8031      LDD	R3,Z+1
    02147 8042      LDD	R4,Z+2
    02148 8053      LDD	R5,Z+3
    02149 A46A      LDD	R6,Y+42
    0214A A47B      LDD	R7,Y+43
    0214B A48C      LDD	R8,Y+44
    0214C A49D      LDD	R9,Y+45
    0214D 1862      SUB	R6,R2
    0214E 0873      SBC	R7,R3
    0214F 0884      SBC	R8,R4
    02150 0895      SBC	R9,R5
    02151 A66A      STD	Y+42,R6
    02152 A67B      STD	Y+43,R7
    02153 A68C      STD	Y+44,R8
    02154 A69D      STD	Y+45,R9
(2893) 				clst = fp->clust;
    02155 A5E8      LDD	R30,Y+40
    02156 A5F9      LDD	R31,Y+41
    02157 9672      ADIW	R30,0x12
    02158 8020      LD	R2,Z
    02159 8031      LDD	R3,Z+1
    0215A 8042      LDD	R4,Z+2
    0215B 8053      LDD	R5,Z+3
    0215C 822A      STD	Y+2,R2
    0215D 823B      STD	Y+3,R3
    0215E 824C      STD	Y+4,R4
    0215F 825D      STD	Y+5,R5
(2894) 			} else {									/* When seek to back cluster, */
    02160 C069      RJMP	0x21CA
(2895) 				clst = fp->sclust;						/* start from the first cluster */
    02161 A5E8      LDD	R30,Y+40
    02162 A5F9      LDD	R31,Y+41
    02163 963E      ADIW	R30,0xE
    02164 8020      LD	R2,Z
    02165 8031      LDD	R3,Z+1
    02166 8042      LDD	R4,Z+2
    02167 8053      LDD	R5,Z+3
    02168 822A      STD	Y+2,R2
    02169 823B      STD	Y+3,R3
    0216A 824C      STD	Y+4,R4
    0216B 825D      STD	Y+5,R5
(2896) #if !_FS_READONLY
(2897) 				if (clst == 0) {						/* If no cluster chain, create a new chain */
    0216C 802A      LDD	R2,Y+2
    0216D 803B      LDD	R3,Y+3
    0216E 804C      LDD	R4,Y+4
    0216F 805D      LDD	R5,Y+5
    02170 9488      BCLR	0
    02171 2022      TST	R2
    02172 0432      CPC	R3,R2
    02173 0442      CPC	R4,R2
    02174 0452      CPC	R5,R2
    02175 F009      BEQ	0x2177
    02176 C049      RJMP	0x21C0
(2898) 					clst = create_chain(fp->fs, 0);
    02177 E040      LDI	R20,0
    02178 E050      LDI	R21,0
    02179 E060      LDI	R22,0
    0217A E070      LDI	R23,0
    0217B 8368      ST	Y,R22
    0217C 8379      STD	Y+1,R23
    0217D 019A      MOVW	R18,R20
    0217E A5E8      LDD	R30,Y+40
    0217F A5F9      LDD	R31,Y+41
    02180 8100      LD	R16,Z
    02181 8111      LDD	R17,Z+1
    02182 940E 08C7 CALL	ff.c:create_chain
    02184 830A      STD	Y+2,R16
    02185 831B      STD	Y+3,R17
    02186 832C      STD	Y+4,R18
    02187 833D      STD	Y+5,R19
(2899) 					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
    02188 E041      LDI	R20,1
    02189 E050      LDI	R21,0
    0218A E060      LDI	R22,0
    0218B E070      LDI	R23,0
    0218C 802A      LDD	R2,Y+2
    0218D 803B      LDD	R3,Y+3
    0218E 804C      LDD	R4,Y+4
    0218F 805D      LDD	R5,Y+5
    02190 1624      CP	R2,R20
    02191 0635      CPC	R3,R21
    02192 0646      CPC	R4,R22
    02193 0657      CPC	R5,R23
    02194 F451      BNE	0x219F
    02195 A588      LDD	R24,Y+40
    02196 A599      LDD	R25,Y+41
    02197 9604      ADIW	R24,4
    02198 017C      MOVW	R14,R24
    02199 01FC      MOVW	R30,R24
    0219A 8180      LD	R24,Z
    0219B 6880      ORI	R24,0x80
    0219C 8380      ST	Z,R24
    0219D E002      LDI	R16,2
    0219E C196      RJMP	0x2335
(2900) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    0219F EF4F      LDI	R20,0xFF
    021A0 EF5F      LDI	R21,0xFF
    021A1 EF6F      LDI	R22,0xFF
    021A2 EF7F      LDI	R23,0xFF
    021A3 802A      LDD	R2,Y+2
    021A4 803B      LDD	R3,Y+3
    021A5 804C      LDD	R4,Y+4
    021A6 805D      LDD	R5,Y+5
    021A7 1624      CP	R2,R20
    021A8 0635      CPC	R3,R21
    021A9 0646      CPC	R4,R22
    021AA 0657      CPC	R5,R23
    021AB F451      BNE	0x21B6
    021AC A588      LDD	R24,Y+40
    021AD A599      LDD	R25,Y+41
    021AE 9604      ADIW	R24,4
    021AF 017C      MOVW	R14,R24
    021B0 01FC      MOVW	R30,R24
    021B1 8180      LD	R24,Z
    021B2 6880      ORI	R24,0x80
    021B3 8380      ST	Z,R24
    021B4 E001      LDI	R16,1
    021B5 C17F      RJMP	0x2335
(2901) 					fp->sclust = clst;
    021B6 802A      LDD	R2,Y+2
    021B7 803B      LDD	R3,Y+3
    021B8 804C      LDD	R4,Y+4
    021B9 805D      LDD	R5,Y+5
    021BA A5E8      LDD	R30,Y+40
    021BB A5F9      LDD	R31,Y+41
    021BC 8626      STD	Z+14,R2
    021BD 8637      STD	Z+15,R3
    021BE 8A40      STD	Z+16,R4
    021BF 8A51      STD	Z+17,R5
(2902) 				}
(2903) #endif
(2904) 				fp->clust = clst;
    021C0 802A      LDD	R2,Y+2
    021C1 803B      LDD	R3,Y+3
    021C2 804C      LDD	R4,Y+4
    021C3 805D      LDD	R5,Y+5
    021C4 A5E8      LDD	R30,Y+40
    021C5 A5F9      LDD	R31,Y+41
    021C6 8A22      STD	Z+18,R2
    021C7 8A33      STD	Z+19,R3
    021C8 8A44      STD	Z+20,R4
    021C9 8A55      STD	Z+21,R5
(2905) 			}
(2906) 			if (clst != 0) {
    021CA 802A      LDD	R2,Y+2
    021CB 803B      LDD	R3,Y+3
    021CC 804C      LDD	R4,Y+4
    021CD 805D      LDD	R5,Y+5
    021CE 9488      BCLR	0
    021CF 2022      TST	R2
    021D0 0432      CPC	R3,R2
    021D1 0442      CPC	R4,R2
    021D2 0452      CPC	R5,R2
    021D3 F409      BNE	0x21D5
    021D4 C114      RJMP	0x22E9
    021D5 C0A7      RJMP	0x227D
(2907) 				while (ofs > bcs) {						/* Cluster following loop */
(2908) #if !_FS_READONLY
(2909) 					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
    021D6 A5E8      LDD	R30,Y+40
    021D7 A5F9      LDD	R31,Y+41
    021D8 9634      ADIW	R30,4
    021D9 8020      LD	R2,Z
    021DA FE21      SBRS	R2,1
    021DB C024      RJMP	0x2200
(2910) 						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
    021DC 802A      LDD	R2,Y+2
    021DD 803B      LDD	R3,Y+3
    021DE 804C      LDD	R4,Y+4
    021DF 805D      LDD	R5,Y+5
    021E0 8248      ST	Y,R4
    021E1 8259      STD	Y+1,R5
    021E2 0191      MOVW	R18,R2
    021E3 A5E8      LDD	R30,Y+40
    021E4 A5F9      LDD	R31,Y+41
    021E5 8100      LD	R16,Z
    021E6 8111      LDD	R17,Z+1
    021E7 940E 08C7 CALL	ff.c:create_chain
    021E9 830A      STD	Y+2,R16
    021EA 831B      STD	Y+3,R17
    021EB 832C      STD	Y+4,R18
    021EC 833D      STD	Y+5,R19
(2911) 						if (clst == 0) {				/* When disk gets full, clip file size */
    021ED 802A      LDD	R2,Y+2
    021EE 803B      LDD	R3,Y+3
    021EF 804C      LDD	R4,Y+4
    021F0 805D      LDD	R5,Y+5
    021F1 9488      BCLR	0
    021F2 2022      TST	R2
    021F3 0432      CPC	R3,R2
    021F4 0442      CPC	R4,R2
    021F5 0452      CPC	R5,R2
    021F6 F4D1      BNE	0x2211
(2912) 							ofs = bcs; break;
    021F7 802E      LDD	R2,Y+6
    021F8 803F      LDD	R3,Y+7
    021F9 8448      LDD	R4,Y+8
    021FA 8459      LDD	R5,Y+9
    021FB A62A      STD	Y+42,R2
    021FC A63B      STD	Y+43,R3
    021FD A64C      STD	Y+44,R4
    021FE A65D      STD	Y+45,R5
    021FF C08B      RJMP	0x228B
(2913) 						}
(2914) 					} else
(2915) #endif
(2916) 						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    02200 802A      LDD	R2,Y+2
    02201 803B      LDD	R3,Y+3
    02202 804C      LDD	R4,Y+4
    02203 805D      LDD	R5,Y+5
    02204 8248      ST	Y,R4
    02205 8259      STD	Y+1,R5
    02206 0191      MOVW	R18,R2
    02207 A5E8      LDD	R30,Y+40
    02208 A5F9      LDD	R31,Y+41
    02209 8100      LD	R16,Z
    0220A 8111      LDD	R17,Z+1
    0220B 940E 0505 CALL	_get_fat
    0220D 830A      STD	Y+2,R16
    0220E 831B      STD	Y+3,R17
    0220F 832C      STD	Y+4,R18
    02210 833D      STD	Y+5,R19
(2917) 					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    02211 EF4F      LDI	R20,0xFF
    02212 EF5F      LDI	R21,0xFF
    02213 EF6F      LDI	R22,0xFF
    02214 EF7F      LDI	R23,0xFF
    02215 802A      LDD	R2,Y+2
    02216 803B      LDD	R3,Y+3
    02217 804C      LDD	R4,Y+4
    02218 805D      LDD	R5,Y+5
    02219 1624      CP	R2,R20
    0221A 0635      CPC	R3,R21
    0221B 0646      CPC	R4,R22
    0221C 0657      CPC	R5,R23
    0221D F451      BNE	0x2228
    0221E A588      LDD	R24,Y+40
    0221F A599      LDD	R25,Y+41
    02220 9604      ADIW	R24,4
    02221 017C      MOVW	R14,R24
    02222 01FC      MOVW	R30,R24
    02223 8180      LD	R24,Z
    02224 6880      ORI	R24,0x80
    02225 8380      ST	Z,R24
    02226 E001      LDI	R16,1
    02227 C10D      RJMP	0x2335
(2918) 					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    02228 E041      LDI	R20,1
    02229 E050      LDI	R21,0
    0222A E060      LDI	R22,0
    0222B E070      LDI	R23,0
    0222C 802A      LDD	R2,Y+2
    0222D 803B      LDD	R3,Y+3
    0222E 804C      LDD	R4,Y+4
    0222F 805D      LDD	R5,Y+5
    02230 1542      CP	R20,R2
    02231 0553      CPC	R21,R3
    02232 0564      CPC	R22,R4
    02233 0575      CPC	R23,R5
    02234 F490      BCC	0x2247
    02235 A5E8      LDD	R30,Y+40
    02236 A5F9      LDD	R31,Y+41
    02237 81A0      LD	R26,Z
    02238 81B1      LDD	R27,Z+1
    02239 9656      ADIW	R26,0x16
    0223A 902D      LD	R2,X+
    0223B 903D      LD	R3,X+
    0223C 904D      LD	R4,X+
    0223D 905C      LD	R5,X
    0223E 806A      LDD	R6,Y+2
    0223F 807B      LDD	R7,Y+3
    02240 808C      LDD	R8,Y+4
    02241 809D      LDD	R9,Y+5
    02242 1462      CP	R6,R2
    02243 0473      CPC	R7,R3
    02244 0484      CPC	R8,R4
    02245 0495      CPC	R9,R5
    02246 F050      BCS	0x2251
    02247 A588      LDD	R24,Y+40
    02248 A599      LDD	R25,Y+41
    02249 9604      ADIW	R24,4
    0224A 017C      MOVW	R14,R24
    0224B 01FC      MOVW	R30,R24
    0224C 8180      LD	R24,Z
    0224D 6880      ORI	R24,0x80
    0224E 8380      ST	Z,R24
    0224F E002      LDI	R16,2
    02250 C0E4      RJMP	0x2335
(2919) 					fp->clust = clst;
    02251 802A      LDD	R2,Y+2
    02252 803B      LDD	R3,Y+3
    02253 804C      LDD	R4,Y+4
    02254 805D      LDD	R5,Y+5
    02255 A5E8      LDD	R30,Y+40
    02256 A5F9      LDD	R31,Y+41
    02257 9672      ADIW	R30,0x12
    02258 8220      ST	Z,R2
    02259 8231      STD	Z+1,R3
    0225A 8242      STD	Z+2,R4
    0225B 8253      STD	Z+3,R5
(2920) 					fp->fptr += bcs;
    0225C A588      LDD	R24,Y+40
    0225D A599      LDD	R25,Y+41
    0225E 9606      ADIW	R24,6
    0225F 017C      MOVW	R14,R24
    02260 802E      LDD	R2,Y+6
    02261 803F      LDD	R3,Y+7
    02262 8448      LDD	R4,Y+8
    02263 8459      LDD	R5,Y+9
    02264 01FC      MOVW	R30,R24
    02265 8060      LD	R6,Z
    02266 8071      LDD	R7,Z+1
    02267 8082      LDD	R8,Z+2
    02268 8093      LDD	R9,Z+3
    02269 0C62      ADD	R6,R2
    0226A 1C73      ADC	R7,R3
    0226B 1C84      ADC	R8,R4
    0226C 1C95      ADC	R9,R5
    0226D 8260      ST	Z,R6
    0226E 8271      STD	Z+1,R7
    0226F 8282      STD	Z+2,R8
    02270 8293      STD	Z+3,R9
(2921) 					ofs -= bcs;
    02271 A46A      LDD	R6,Y+42
    02272 A47B      LDD	R7,Y+43
    02273 A48C      LDD	R8,Y+44
    02274 A49D      LDD	R9,Y+45
    02275 1862      SUB	R6,R2
    02276 0873      SBC	R7,R3
    02277 0884      SBC	R8,R4
    02278 0895      SBC	R9,R5
    02279 A66A      STD	Y+42,R6
    0227A A67B      STD	Y+43,R7
    0227B A68C      STD	Y+44,R8
    0227C A69D      STD	Y+45,R9
    0227D 802E      LDD	R2,Y+6
    0227E 803F      LDD	R3,Y+7
    0227F 8448      LDD	R4,Y+8
    02280 8459      LDD	R5,Y+9
    02281 A46A      LDD	R6,Y+42
    02282 A47B      LDD	R7,Y+43
    02283 A48C      LDD	R8,Y+44
    02284 A49D      LDD	R9,Y+45
    02285 1426      CP	R2,R6
    02286 0437      CPC	R3,R7
    02287 0448      CPC	R4,R8
    02288 0459      CPC	R5,R9
    02289 F408      BCC	0x228B
    0228A CF4B      RJMP	0x21D6
(2922) 				}
(2923) 				fp->fptr += ofs;
    0228B A588      LDD	R24,Y+40
    0228C A599      LDD	R25,Y+41
    0228D 9606      ADIW	R24,6
    0228E 017C      MOVW	R14,R24
    0228F A42A      LDD	R2,Y+42
    02290 A43B      LDD	R3,Y+43
    02291 A44C      LDD	R4,Y+44
    02292 A45D      LDD	R5,Y+45
    02293 01FC      MOVW	R30,R24
    02294 8060      LD	R6,Z
    02295 8071      LDD	R7,Z+1
    02296 8082      LDD	R8,Z+2
    02297 8093      LDD	R9,Z+3
    02298 0C62      ADD	R6,R2
    02299 1C73      ADC	R7,R3
    0229A 1C84      ADC	R8,R4
    0229B 1C95      ADC	R9,R5
    0229C 8260      ST	Z,R6
    0229D 8271      STD	Z+1,R7
    0229E 8282      STD	Z+2,R8
    0229F 8293      STD	Z+3,R9
(2924) 				if (ofs % SS(fp->fs)) {
    022A0 EF4F      LDI	R20,0xFF
    022A1 E051      LDI	R21,1
    022A2 E060      LDI	R22,0
    022A3 E070      LDI	R23,0
    022A4 2224      AND	R2,R20
    022A5 2235      AND	R3,R21
    022A6 2246      AND	R4,R22
    022A7 2257      AND	R5,R23
    022A8 9488      BCLR	0
    022A9 2022      TST	R2
    022AA 0432      CPC	R3,R2
    022AB 0442      CPC	R4,R2
    022AC 0452      CPC	R5,R2
    022AD F409      BNE	0x22AF
    022AE C03A      RJMP	0x22E9
(2925) 					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    022AF 802A      LDD	R2,Y+2
    022B0 803B      LDD	R3,Y+3
    022B1 804C      LDD	R4,Y+4
    022B2 805D      LDD	R5,Y+5
    022B3 8248      ST	Y,R4
    022B4 8259      STD	Y+1,R5
    022B5 0191      MOVW	R18,R2
    022B6 A5E8      LDD	R30,Y+40
    022B7 A5F9      LDD	R31,Y+41
    022B8 8100      LD	R16,Z
    022B9 8111      LDD	R17,Z+1
    022BA 940E 04B3 CALL	_clust2sect
    022BC 870A      STD	Y+10,R16
    022BD 871B      STD	Y+11,R17
    022BE 872C      STD	Y+12,R18
    022BF 873D      STD	Y+13,R19
(2926) 					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    022C0 842A      LDD	R2,Y+10
    022C1 843B      LDD	R3,Y+11
    022C2 844C      LDD	R4,Y+12
    022C3 845D      LDD	R5,Y+13
    022C4 9488      BCLR	0
    022C5 2022      TST	R2
    022C6 0432      CPC	R3,R2
    022C7 0442      CPC	R4,R2
    022C8 0452      CPC	R5,R2
    022C9 F451      BNE	0x22D4
    022CA A588      LDD	R24,Y+40
    022CB A599      LDD	R25,Y+41
    022CC 9604      ADIW	R24,4
    022CD 017C      MOVW	R14,R24
    022CE 01FC      MOVW	R30,R24
    022CF 8180      LD	R24,Z
    022D0 6880      ORI	R24,0x80
    022D1 8380      ST	Z,R24
    022D2 E002      LDI	R16,2
    022D3 C061      RJMP	0x2335
(2927) 					nsect += ofs / SS(fp->fs);
    022D4 E089      LDI	R24,0x9
    022D5 E090      LDI	R25,0
    022D6 A50A      LDD	R16,Y+42
    022D7 A51B      LDD	R17,Y+43
    022D8 A52C      LDD	R18,Y+44
    022D9 A53D      LDD	R19,Y+45
    022DA 938A      ST	-Y,R24
    022DB 940E 400F CALL	lsr32
    022DD 842A      LDD	R2,Y+10
    022DE 843B      LDD	R3,Y+11
    022DF 844C      LDD	R4,Y+12
    022E0 845D      LDD	R5,Y+13
    022E1 0E20      ADD	R2,R16
    022E2 1E31      ADC	R3,R17
    022E3 1E42      ADC	R4,R18
    022E4 1E53      ADC	R5,R19
    022E5 862A      STD	Y+10,R2
    022E6 863B      STD	Y+11,R3
    022E7 864C      STD	Y+12,R4
    022E8 865D      STD	Y+13,R5
(2928) 				}
(2929) 			}
(2930) 		}
(2931) 		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    022E9 EF4F      LDI	R20,0xFF
    022EA E051      LDI	R21,1
    022EB E060      LDI	R22,0
    022EC E070      LDI	R23,0
    022ED A5E8      LDD	R30,Y+40
    022EE A5F9      LDD	R31,Y+41
    022EF 9636      ADIW	R30,6
    022F0 8020      LD	R2,Z
    022F1 8031      LDD	R3,Z+1
    022F2 8042      LDD	R4,Z+2
    022F3 8053      LDD	R5,Z+3
    022F4 2224      AND	R2,R20
    022F5 2235      AND	R3,R21
    022F6 2246      AND	R4,R22
    022F7 2257      AND	R5,R23
    022F8 9488      BCLR	0
    022F9 2022      TST	R2
    022FA 0432      CPC	R3,R2
    022FB 0442      CPC	R4,R2
    022FC 0452      CPC	R5,R2
    022FD F0C1      BEQ	0x2316
    022FE A5E8      LDD	R30,Y+40
    022FF A5F9      LDD	R31,Y+41
    02300 9676      ADIW	R30,0x16
    02301 8020      LD	R2,Z
    02302 8031      LDD	R3,Z+1
    02303 8042      LDD	R4,Z+2
    02304 8053      LDD	R5,Z+3
    02305 846A      LDD	R6,Y+10
    02306 847B      LDD	R7,Y+11
    02307 848C      LDD	R8,Y+12
    02308 849D      LDD	R9,Y+13
    02309 1462      CP	R6,R2
    0230A 0473      CPC	R7,R3
    0230B 0484      CPC	R8,R4
    0230C 0495      CPC	R9,R5
    0230D F041      BEQ	0x2316
(2932) #if !_FS_TINY
(2933) #if !_FS_READONLY
(2934) 			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
(2935) 				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
(2936) 					ABORT(fp->fs, FR_DISK_ERR);
(2937) 				fp->flag &= ~FA__DIRTY;
(2938) 			}
(2939) #endif
(2940) 			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
(2941) 				ABORT(fp->fs, FR_DISK_ERR);
(2942) #endif
(2943) 			fp->dsect = nsect;
    0230E 0113      MOVW	R2,R6
    0230F 0124      MOVW	R4,R8
    02310 A5E8      LDD	R30,Y+40
    02311 A5F9      LDD	R31,Y+41
    02312 8A26      STD	Z+22,R2
    02313 8A37      STD	Z+23,R3
    02314 8E40      STD	Z+24,R4
    02315 8E51      STD	Z+25,R5
(2944) 		}
(2945) #if !_FS_READONLY
(2946) 		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
    02316 A5E8      LDD	R30,Y+40
    02317 A5F9      LDD	R31,Y+41
    02318 8422      LDD	R2,Z+10
    02319 8433      LDD	R3,Z+11
    0231A 8444      LDD	R4,Z+12
    0231B 8455      LDD	R5,Z+13
    0231C 8066      LDD	R6,Z+6
    0231D 8077      LDD	R7,Z+7
    0231E 8480      LDD	R8,Z+8
    0231F 8491      LDD	R9,Z+9
    02320 1426      CP	R2,R6
    02321 0437      CPC	R3,R7
    02322 0448      CPC	R4,R8
    02323 0459      CPC	R5,R9
    02324 F478      BCC	0x2334
(2947) 			fp->fsize = fp->fptr;
    02325 8026      LDD	R2,Z+6
    02326 8037      LDD	R3,Z+7
    02327 8440      LDD	R4,Z+8
    02328 8451      LDD	R5,Z+9
    02329 8622      STD	Z+10,R2
    0232A 8633      STD	Z+11,R3
    0232B 8644      STD	Z+12,R4
    0232C 8655      STD	Z+13,R5
(2948) 			fp->flag |= FA__WRITTEN;
    0232D 01CF      MOVW	R24,R30
    0232E 9604      ADIW	R24,4
    0232F 016C      MOVW	R12,R24
    02330 01FC      MOVW	R30,R24
    02331 8180      LD	R24,Z
    02332 6280      ORI	R24,0x20
    02333 8380      ST	Z,R24
(2949) 		}
(2950) #endif
(2951) 	}
(2952) 
(2953) 	LEAVE_FF(fp->fs, res);
    02334 2D0A      MOV	R16,R10
    02335 966E      ADIW	R28,0x1E
    02336 940E 3F69 CALL	pop_xgsetF0FC
    02338 9624      ADIW	R28,4
    02339 9508      RET
_f_opendir:
  sfn                  --> Y,+1
  res                  --> R20
  path                 --> Y,+19
  dj                   --> R22
    0233A 933A      ST	-Y,R19
    0233B 932A      ST	-Y,R18
    0233C 940E 3F93 CALL	push_xgsetF00C
    0233E 01B8      MOVW	R22,R16
    0233F 972D      SBIW	R28,0xD
(2954) }
(2955) 
(2956) 
(2957) 
(2958) #if _FS_MINIMIZE <= 1
(2959) /*-----------------------------------------------------------------------*/
(2960) /* Create a Directroy Object                                             */
(2961) /*-----------------------------------------------------------------------*/
(2962) 
(2963) FRESULT f_opendir (
(2964) 	DIR *dj,			/* Pointer to directory object to create */
(2965) 	const TCHAR *path	/* Pointer to the directory path */
(2966) )
(2967) {
(2968) 	FRESULT res;
(2969) 	DEF_NAMEBUF;
(2970) 
(2971) 
(2972) 	res = chk_mounted(&path, &dj->fs, 0);
    02340 2422      CLR	R2
    02341 8228      ST	Y,R2
    02342 019B      MOVW	R18,R22
    02343 018E      MOVW	R16,R28
    02344 5E0D      SUBI	R16,0xED
    02345 4F1F      SBCI	R17,0xFF
    02346 940E 115A CALL	ff.c:chk_mounted
    02348 2F40      MOV	R20,R16
(2973) 	if (res == FR_OK) {
    02349 2300      TST	R16
    0234A F009      BEQ	0x234C
    0234B C05C      RJMP	0x23A8
(2974) 		INIT_BUF(*dj);
    0234C 01CE      MOVW	R24,R28
    0234D 9601      ADIW	R24,1
    0234E 01FB      MOVW	R30,R22
    0234F 8B95      STD	Z+21,R25
    02350 8B84      STD	Z+20,R24
(2975) 		res = follow_path(dj, path);			/* Follow the path to the directory */
    02351 892B      LDD	R18,Y+19
    02352 893C      LDD	R19,Y+20
    02353 018F      MOVW	R16,R30
    02354 940E 100E CALL	ff.c:follow_path
    02356 2F40      MOV	R20,R16
(2976) 		FREE_BUF();
(2977) 		if (res == FR_OK) {						/* Follow completed */
    02357 2300      TST	R16
    02358 F009      BEQ	0x235A
    02359 C04B      RJMP	0x23A5
(2978) 			if (dj->dir) {						/* It is not the root dir */
    0235A 01FB      MOVW	R30,R22
    0235B 8822      LDD	R2,Z+18
    0235C 8833      LDD	R3,Z+19
    0235D 2022      TST	R2
    0235E F419      BNE	0x2362
    0235F 2033      TST	R3
    02360 F409      BNE	0x2362
    02361 C032      RJMP	0x2394
(2979) 				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
    02362 93AF      PUSH	R26
    02363 93BF      PUSH	R27
    02364 89A2      LDD	R26,Z+18
    02365 89B3      LDD	R27,Z+19
    02366 01FD      MOVW	R30,R26
    02367 91BF      POP	R27
    02368 91AF      POP	R26
    02369 8423      LDD	R2,Z+11
    0236A FE24      SBRS	R2,4
    0236B C027      RJMP	0x2393
(2980) 					dj->sclust = LD_CLUST(dj->dir);
    0236C 01FB      MOVW	R30,R22
    0236D 88A2      LDD	R10,Z+18
    0236E 88B3      LDD	R11,Z+19
    0236F 01F5      MOVW	R30,R10
    02370 8C22      LDD	R2,Z+26
    02371 2433      CLR	R3
    02372 8C43      LDD	R4,Z+27
    02373 2455      CLR	R5
    02374 2C54      MOV	R5,R4
    02375 2444      CLR	R4
    02376 2842      OR	R4,R2
    02377 2853      OR	R5,R3
    02378 0112      MOVW	R2,R4
    02379 2444      CLR	R4
    0237A 2455      CLR	R5
    0237B 8864      LDD	R6,Z+20
    0237C 2477      CLR	R7
    0237D 8885      LDD	R8,Z+21
    0237E 2499      CLR	R9
    0237F 2C98      MOV	R9,R8
    02380 2488      CLR	R8
    02381 2886      OR	R8,R6
    02382 2897      OR	R9,R7
    02383 0134      MOVW	R6,R8
    02384 2488      CLR	R8
    02385 2499      CLR	R9
    02386 0143      MOVW	R8,R6
    02387 2466      CLR	R6
    02388 2477      CLR	R7
    02389 2862      OR	R6,R2
    0238A 2873      OR	R7,R3
    0238B 2884      OR	R8,R4
    0238C 2895      OR	R9,R5
    0238D 01FB      MOVW	R30,R22
    0238E 8266      STD	Z+6,R6
    0238F 8277      STD	Z+7,R7
    02390 8680      STD	Z+8,R8
    02391 8691      STD	Z+9,R9
(2981) 				} else {						/* The object is not a directory */
    02392 C001      RJMP	0x2394
(2982) 					res = FR_NO_PATH;
    02393 E045      LDI	R20,5
(2983) 				}
(2984) 			}
(2985) 			if (res == FR_OK) {
    02394 2344      TST	R20
    02395 F479      BNE	0x23A5
(2986) 				dj->id = dj->fs->id;
    02396 01FB      MOVW	R30,R22
    02397 81A0      LD	R26,Z
    02398 81B1      LDD	R27,Z+1
    02399 9616      ADIW	R26,6
    0239A 902D      LD	R2,X+
    0239B 903C      LD	R3,X
    0239C 8233      STD	Z+3,R3
    0239D 8222      STD	Z+2,R2
(2987) 				res = dir_sdi(dj, 0);			/* Rewind dir */
    0239E 2722      CLR	R18
    0239F 2733      CLR	R19
    023A0 018F      MOVW	R16,R30
    023A1 940E 0AB8 CALL	ff.c:dir_sdi
    023A3 2EA0      MOV	R10,R16
    023A4 2D4A      MOV	R20,R10
(2988) 			}
(2989) 		}
(2990) 		if (res == FR_NO_FILE) res = FR_NO_PATH;
    023A5 3044      CPI	R20,4
    023A6 F409      BNE	0x23A8
    023A7 E045      LDI	R20,5
(2991) 	}
(2992) 
(2993) 	LEAVE_FF(dj->fs, res);
    023A8 2F04      MOV	R16,R20
    023A9 962D      ADIW	R28,0xD
    023AA 940E 3F9A CALL	pop_xgsetF00C
    023AC 9622      ADIW	R28,2
    023AD 9508      RET
_f_readdir:
  sfn                  --> Y,+0
  res                  --> R20
  fno                  --> R10
  dj                   --> R22
    023AE 940E 3FAF CALL	push_xgsetF03C
    023B0 0159      MOVW	R10,R18
    023B1 01B8      MOVW	R22,R16
    023B2 972C      SBIW	R28,0xC
(2994) }
(2995) 
(2996) 
(2997) 
(2998) 
(2999) /*-----------------------------------------------------------------------*/
(3000) /* Read Directory Entry in Sequense                                      */
(3001) /*-----------------------------------------------------------------------*/
(3002) 
(3003) FRESULT f_readdir (
(3004) 	DIR *dj,			/* Pointer to the open directory object */
(3005) 	FILINFO *fno		/* Pointer to file information to return */
(3006) )
(3007) {
(3008) 	FRESULT res;
(3009) 	DEF_NAMEBUF;
(3010) 
(3011) 
(3012) 	res = validate(dj->fs, dj->id);			/* Check validity of the object */
    023B3 01FB      MOVW	R30,R22
    023B4 8122      LDD	R18,Z+2
    023B5 8133      LDD	R19,Z+3
    023B6 8100      LD	R16,Z
    023B7 8111      LDD	R17,Z+1
    023B8 940E 1654 CALL	ff.c:validate
    023BA 2F40      MOV	R20,R16
(3013) 	if (res == FR_OK) {
    023BB 2300      TST	R16
    023BC F009      BEQ	0x23BE
    023BD C035      RJMP	0x23F3
(3014) 		if (!fno) {
    023BE 20AA      TST	R10
    023BF F449      BNE	0x23C9
    023C0 20BB      TST	R11
    023C1 F439      BNE	0x23C9
(3015) 			res = dir_sdi(dj, 0);			/* Rewind the directory object */
    023C2 2722      CLR	R18
    023C3 2733      CLR	R19
    023C4 018B      MOVW	R16,R22
    023C5 940E 0AB8 CALL	ff.c:dir_sdi
    023C7 2F40      MOV	R20,R16
(3016) 		} else {
    023C8 C02A      RJMP	0x23F3
(3017) 			INIT_BUF(*dj);
    023C9 01CE      MOVW	R24,R28
    023CA 01FB      MOVW	R30,R22
    023CB 8B95      STD	Z+21,R25
    023CC 8B84      STD	Z+20,R24
(3018) 			res = dir_read(dj);				/* Read an directory item */
    023CD 018F      MOVW	R16,R30
    023CE 940E 0DB5 CALL	ff.c:dir_read
    023D0 2EC0      MOV	R12,R16
    023D1 2D4C      MOV	R20,R12
(3019) 			if (res == FR_NO_FILE) {		/* Reached end of dir */
    023D2 3004      CPI	R16,4
    023D3 F441      BNE	0x23DC
(3020) 				dj->sect = 0;
    023D4 01FB      MOVW	R30,R22
    023D5 963E      ADIW	R30,0xE
    023D6 E080      LDI	R24,0
    023D7 8380      ST	Z,R24
    023D8 8381      STD	Z+1,R24
    023D9 8382      STD	Z+2,R24
    023DA 8383      STD	Z+3,R24
(3021) 				res = FR_OK;
    023DB 2744      CLR	R20
(3022) 			}
(3023) 			if (res == FR_OK) {				/* A valid entry is found */
    023DC 2344      TST	R20
    023DD F4A9      BNE	0x23F3
(3024) 				get_fileinfo(dj, fno);		/* Get the object information */
    023DE 0195      MOVW	R18,R10
    023DF 018B      MOVW	R16,R22
    023E0 940E 0F6B CALL	ff.c:get_fileinfo
(3025) 				res = dir_next(dj, 0);		/* Increment index for next */
    023E2 2722      CLR	R18
    023E3 2733      CLR	R19
    023E4 018B      MOVW	R16,R22
    023E5 940E 0BC2 CALL	ff.c:dir_next
    023E7 2EA0      MOV	R10,R16
    023E8 2D4A      MOV	R20,R10
(3026) 				if (res == FR_NO_FILE) {
    023E9 3004      CPI	R16,4
    023EA F441      BNE	0x23F3
(3027) 					dj->sect = 0;
    023EB 01FB      MOVW	R30,R22
    023EC 963E      ADIW	R30,0xE
    023ED E080      LDI	R24,0
    023EE 8380      ST	Z,R24
    023EF 8381      STD	Z+1,R24
    023F0 8382      STD	Z+2,R24
    023F1 8383      STD	Z+3,R24
(3028) 					res = FR_OK;
    023F2 2744      CLR	R20
(3029) 				}
(3030) 			}
(3031) 			FREE_BUF();
(3032) 		}
(3033) 	}
(3034) 
(3035) 	LEAVE_FF(dj->fs, res);
    023F3 2F04      MOV	R16,R20
    023F4 962C      ADIW	R28,0xC
    023F5 940C 3FB8 JMP	pop_xgsetF03C
FILE: D:\LQD\software\master\software_src\delay.c
(0001) /*******************************
(0002)  function ：延时函数
(0003) Clock F  :7.3728M 
(0004) Software : ICCAVR7.14C
(0005) ********************************/
(0006) /*---------------------------------------------------------------------------------
(0007)      延时程序计算方法
(0008)      计数个数j = 延时时间/6*晶振频率 - 1
(0009) ---------------------------------------------------------------------------------*/
(0010) void delayus(unsigned int tttt)   // 1.2us 延时子函数   
(0011) { 
(0012)    do
(0013)    {
(0014)        tttt--;
_delayus:
  tttt                 --> R16
    023F7 5001      SUBI	R16,1
    023F8 4010      SBCI	R17,0
(0015)    }
(0016)    while(tttt>1);
    023F9 E081      LDI	R24,1
    023FA E090      LDI	R25,0
    023FB 1780      CP	R24,R16
    023FC 0791      CPC	R25,R17
    023FD F3C8      BCS	0x23F7
    023FE 9508      RET
_delayms:
  j                    --> R20
  i                    --> R16
    023FF 934A      ST	-Y,R20
    02400 935A      ST	-Y,R21
(0017) }
(0018) void delayms(unsigned int i)                 //1ms延时
(0019)    {
    02401 C00A      RJMP	0x240C
(0020)     while(i--)
(0021)     {                          
(0022) 	    unsigned int j;                
(0023)         for(j=1;j<=1227;j++)   
    02402 E041      LDI	R20,1
    02403 E050      LDI	R21,0
    02404 C002      RJMP	0x2407
    02405 5F4F      SUBI	R20,0xFF
    02406 4F5F      SBCI	R21,0xFF
    02407 EC8B      LDI	R24,0xCB
    02408 E094      LDI	R25,4
    02409 1784      CP	R24,R20
    0240A 0795      CPC	R25,R21
    0240B F7C8      BCC	0x2405
    0240C 0118      MOVW	R2,R16
    0240D 5001      SUBI	R16,1
    0240E 4010      SBCI	R17,0
    0240F 2022      TST	R2
    02410 F789      BNE	0x2402
    02411 2033      TST	R3
    02412 F779      BNE	0x2402
    02413 9159      LD	R21,Y+
    02414 9149      LD	R20,Y+
    02415 9508      RET
_initDevices:
    02416 940E 3F7A CALL	push_xgset003C
FILE: D:\LQD\software\master\software_src\main.c
(0001) #include "config.h"
(0002) #define  N_per_Second  (2.72*60)
(0003) const char tab[]="\t\0";
(0004) const char enter[]="\n\0";
(0005) char buffer[512];
(0006) char TempChar[80]; //存放临时字串
(0007) struct DATA Result;
(0008) struct tm t;
(0009) unsigned long now =0; 
(0010) void debug(UINT8 *str,UINT8 val);
(0011) void WriteSDFile(void);
(0012) struct CONFIG config;
(0013) void initDevices(void){
(0014)      CLI();
    02418 94F8      BCLR	7
(0015) 	 DDRA=0XFF;
    02419 EF8F      LDI	R24,0xFF
    0241A BB8A      OUT	0x1A,R24
(0016) 	 PORTA=0XFF;
    0241B BB8B      OUT	0x1B,R24
(0017) 	 DDRB=0XFF;
    0241C BB87      OUT	0x17,R24
(0018) 	 PORTB=0XFF; 	 
    0241D BB88      OUT	0x18,R24
(0019) 	 DDRC=0XFF;
    0241E BB84      OUT	0x14,R24
(0020) 	 PORTC=0XFF;
    0241F BB85      OUT	0x15,R24
(0021) 	 DDRG=0XFF;
    02420 9380 0064 STS	0x64,R24
(0022) 	 PORTG=0XFF;	 
    02422 9380 0065 STS	0x65,R24
(0023) 	 SPI_IO_Init(); 
    02424 940E 378F CALL	_SPI_IO_Init
(0024) 	 SD_Init();
    02426 940E 2B50 CALL	_SD_Init
(0025) 	 uart1_init();
    02428 940E 35B9 CALL	_uart1_init
(0026) 	 LCD_INT();delayms(50);LCD_INT();
    0242A 940E 37AD CALL	_LCD_INT
    0242C E302      LDI	R16,0x32
    0242D E010      LDI	R17,0
    0242E 940E 23FF CALL	_delayms
    02430 940E 37AD CALL	_LCD_INT
(0027) 	 LCD_SW(1);
    02432 E001      LDI	R16,1
    02433 940E 37A3 CALL	_LCD_SW
(0028) 	 config.THRESHOLD_delta_sec=10; //一次检测用时
    02435 E08A      LDI	R24,0xA
    02436 9380 07BC STS	config+4,R24
    02438 E080      LDI	R24,0
    02439 9380 07BD STS	config+5,R24
    0243B 9380 07BE STS	config+6,R24
    0243D 9380 07BF STS	config+7,R24
(0029) 	 config.autocheck=0;
    0243F 2422      CLR	R2
    02440 9220 07C8 STS	config+16,R2
(0030) 	 config.checkDeltaTime=20;  //自动检测模式 时间间隔
    02442 E184      LDI	R24,0x14
    02443 E090      LDI	R25,0
    02444 9390 07CA STS	config+18,R25
    02446 9380 07C9 STS	config+17,R24
(0031) 	 SEI();
    02448 9478      BSET	7
    02449 940C 3F54 JMP	pop_xgset003C
_main:
  keycode              --> Y,+1
  i                    --> R10
  buf512               --> Y,+14
  filename             --> Y,+0
  tmp                  --> R10
    0244B 97EF      SBIW	R28,0x3F
    0244C 97EF      SBIW	R28,0x3F
    0244D 97EF      SBIW	R28,0x3F
    0244E 97EF      SBIW	R28,0x3F
    0244F 97EF      SBIW	R28,0x3F
    02450 97EF      SBIW	R28,0x3F
    02451 97EF      SBIW	R28,0x3F
    02452 97EF      SBIW	R28,0x3F
    02453 9767      SBIW	R28,0x17
(0032) }
(0033) 
(0034) ////////////////////////////////////////////////////////////////
(0035) void main(void){
(0036) 	 UINT8 tmp,keycode;
(0037) 	 UINT8 buf512[513];
(0038) 	 char filename[]="201302.xls\0\0\0";
    02454 E189      LDI	R24,0x19
    02455 E091      LDI	R25,1
    02456 01FE      MOVW	R30,R28
    02457 E00E      LDI	R16,0xE
    02458 E010      LDI	R17,0
    02459 93FA      ST	-Y,R31
    0245A 93EA      ST	-Y,R30
    0245B 939A      ST	-Y,R25
    0245C 938A      ST	-Y,R24
    0245D 940E 401B CALL	asgnblk
(0039) 	 int i=0;
    0245F 24AA      CLR	R10
    02460 24BB      CLR	R11
(0040) 	 initDevices();
    02461 DFB4      RCALL	_initDevices
(0041) 	 dateRefresh(1);
    02462 E001      LDI	R16,1
    02463 940E 346D CALL	_dateRefresh
(0042) 	 WriteFileHead();
    02465 D0F5      RCALL	_WriteFileHead
(0043)      Result.Index=findIndex(get_name(filename),buf512);
    02466 018E      MOVW	R16,R28
    02467 D5BE      RCALL	_get_name
    02468 019E      MOVW	R18,R28
    02469 5F22      SUBI	R18,0xF2
    0246A 4F3F      SBCI	R19,0xFF
    0246B D232      RCALL	_findIndex
    0246C 0118      MOVW	R2,R16
    0246D 2444      CLR	R4
    0246E 2455      CLR	R5
    0246F 9230 0553 STS	Result+11,R3
    02471 9220 0552 STS	Result+10,R2
    02473 9250 0555 STS	Result+13,R5
    02475 9240 0554 STS	Result+12,R4
(0044) 	 //selfTest();
(0045) 	 GUI_welcome();
    02477 940E 3450 CALL	_GUI_welcome
    02479 C01D      RJMP	0x2497
(0046) 	 while(1){
(0047) 	    tmp=GUI_mainmeu();
    0247A 940E 2D29 CALL	_GUI_mainmeu
    0247C 2EA0      MOV	R10,R16
(0048) 		switch(tmp){
    0247D 2D4A      MOV	R20,R10
    0247E 2755      CLR	R21
    0247F 3043      CPI	R20,3
    02480 E0E0      LDI	R30,0
    02481 075E      CPC	R21,R30
    02482 F049      BEQ	0x248C
    02483 3044      CPI	R20,4
    02484 E0E0      LDI	R30,0
    02485 075E      CPC	R21,R30
    02486 F041      BEQ	0x248F
    02487 3047      CPI	R20,7
    02488 E0E0      LDI	R30,0
    02489 075E      CPC	R21,R30
    0248A F039      BEQ	0x2492
    0248B C007      RJMP	0x2493
(0049) 		    case 3 : GUI_check(); break; 
    0248C 940E 2E0D CALL	_GUI_check
    0248E C004      RJMP	0x2493
(0050) 			case 4 : GUI_set_time(); break ;
    0248F 940E 3208 CALL	_GUI_set_time
    02491 C001      RJMP	0x2493
(0051) 			//case 5 : GUI_read_back(); break;
(0052) 			//case 6 : GUI_send_date();
(0053) 			case 7 : selfTest(); break ;
    02492 D00F      RCALL	_selfTest
(0054) 			default : break;
(0055) 	   }
(0056) 	   delayms(100);
    02493 E604      LDI	R16,0x64
    02494 E010      LDI	R17,0
    02495 940E 23FF CALL	_delayms
    02497 CFE2      RJMP	0x247A
    02498 96EF      ADIW	R28,0x3F
    02499 96EF      ADIW	R28,0x3F
    0249A 96EF      ADIW	R28,0x3F
    0249B 96EF      ADIW	R28,0x3F
    0249C 96EF      ADIW	R28,0x3F
    0249D 96EF      ADIW	R28,0x3F
    0249E 96EF      ADIW	R28,0x3F
    0249F 96EF      ADIW	R28,0x3F
    024A0 9667      ADIW	R28,0x17
    024A1 9508      RET
_selfTest:
  str2                 --> Y,+12
  str1                 --> Y,+6
  tmp                  --> Y,+2
    024A2 9762      SBIW	R28,0x12
(0057) 	 }
(0058) 
(0059) }
(0060) void selfTest(void){
(0061) 	float tmp=0;                                                                
    024A3 EB04      LDI	R16,0xB4
    024A4 E010      LDI	R17,0
    024A5 940E 3EFC CALL	elpm32
    024A7 830A      STD	Y+2,R16
    024A8 831B      STD	Y+3,R17
    024A9 832C      STD	Y+4,R18
    024AA 833D      STD	Y+5,R19
(0062) 	char str1[6],str2[6];
(0063) 	
(0064) 	 //自检程序
(0065) 	lp("自检程序");delayms(500);
    024AB E401      LDI	R16,0x41
    024AC E012      LDI	R17,2
    024AD 940E 3ADC CALL	_lp
    024AF EF04      LDI	R16,0xF4
    024B0 E011      LDI	R17,1
    024B1 940E 23FF CALL	_delayms
(0066) 	lp("外部温度 ");
    024B3 E307      LDI	R16,0x37
    024B4 E012      LDI	R17,2
    024B5 940E 3ADC CALL	_lp
(0067) 	tmp=read_T_NUM(0);
    024B7 2700      CLR	R16
    024B8 940E 3D0F CALL	_read_T_NUM
    024BA 830A      STD	Y+2,R16
    024BB 831B      STD	Y+3,R17
    024BC 832C      STD	Y+4,R18
    024BD 833D      STD	Y+5,R19
(0068) 	ftochr(tmp,str1);
    024BE 01CE      MOVW	R24,R28
    024BF 9606      ADIW	R24,6
    024C0 8399      STD	Y+1,R25
    024C1 8388      ST	Y,R24
    024C2 810A      LDD	R16,Y+2
    024C3 811B      LDD	R17,Y+3
    024C4 812C      LDD	R18,Y+4
    024C5 813D      LDD	R19,Y+5
    024C6 D465      RCALL	_ftochr
(0069) 	str1[6]=0;
    024C7 2422      CLR	R2
    024C8 862C      STD	Y+12,R2
(0070) 	lp(str1);
    024C9 018E      MOVW	R16,R28
    024CA 5F0A      SUBI	R16,0xFA
    024CB 4F1F      SBCI	R17,0xFF
    024CC 940E 3ADC CALL	_lp
(0071) 	delayms(500);
    024CE EF04      LDI	R16,0xF4
    024CF E011      LDI	R17,1
    024D0 940E 23FF CALL	_delayms
(0072) 	lp("内部温度");
    024D2 E20E      LDI	R16,0x2E
    024D3 E012      LDI	R17,2
    024D4 940E 3ADC CALL	_lp
(0073) 	tmp=read_T_NUM(1);
    024D6 E001      LDI	R16,1
    024D7 940E 3D0F CALL	_read_T_NUM
    024D9 830A      STD	Y+2,R16
    024DA 831B      STD	Y+3,R17
    024DB 832C      STD	Y+4,R18
    024DC 833D      STD	Y+5,R19
(0074) 	ftochr(tmp,str2);
    024DD 01CE      MOVW	R24,R28
    024DE 960C      ADIW	R24,0xC
    024DF 8399      STD	Y+1,R25
    024E0 8388      ST	Y,R24
    024E1 810A      LDD	R16,Y+2
    024E2 811B      LDD	R17,Y+3
    024E3 812C      LDD	R18,Y+4
    024E4 813D      LDD	R19,Y+5
    024E5 D446      RCALL	_ftochr
(0075) 	str2[6]=0;
    024E6 2422      CLR	R2
    024E7 8A2A      STD	Y+18,R2
(0076) 	lp(str2);
    024E8 018E      MOVW	R16,R28
    024E9 5F04      SUBI	R16,0xF4
    024EA 4F1F      SBCI	R17,0xFF
    024EB 940E 3ADC CALL	_lp
(0077) 	delayms(500);
    024ED EF04      LDI	R16,0xF4
    024EE E011      LDI	R17,1
    024EF 940E 23FF CALL	_delayms
(0078) 	lp("风速脉冲：");delayms(500);
    024F1 E203      LDI	R16,0x23
    024F2 E012      LDI	R17,2
    024F3 940E 3ADC CALL	_lp
    024F5 EF04      LDI	R16,0xF4
    024F6 E011      LDI	R17,1
    024F7 940E 23FF CALL	_delayms
(0079) 	lp("蜂鸣器"); beep(2,2);delayms(500);
    024F9 E10C      LDI	R16,0x1C
    024FA E012      LDI	R17,2
    024FB 940E 3ADC CALL	_lp
    024FD E022      LDI	R18,2
    024FE E002      LDI	R16,2
    024FF 940E 3B52 CALL	_beep
    02501 EF04      LDI	R16,0xF4
    02502 E011      LDI	R17,1
    02503 940E 23FF CALL	_delayms
(0080) 	lp("power 指示灯");
    02505 E00F      LDI	R16,0xF
    02506 E012      LDI	R17,2
    02507 940E 3ADC CALL	_lp
(0081) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02509 9AA7      SBI	0x14,7
    0250A 98AF      CBI	0x15,7
    0250B E604      LDI	R16,0x64
    0250C E010      LDI	R17,0
    0250D 940E 23FF CALL	_delayms
    0250F 9AA7      SBI	0x14,7
    02510 9AAF      SBI	0x15,7
    02511 E604      LDI	R16,0x64
    02512 E010      LDI	R17,0
    02513 940E 23FF CALL	_delayms
(0082) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02515 9AA7      SBI	0x14,7
    02516 98AF      CBI	0x15,7
    02517 E604      LDI	R16,0x64
    02518 E010      LDI	R17,0
    02519 940E 23FF CALL	_delayms
    0251B 9AA7      SBI	0x14,7
    0251C 9AAF      SBI	0x15,7
    0251D E604      LDI	R16,0x64
    0251E E010      LDI	R17,0
    0251F 940E 23FF CALL	_delayms
(0083) 	LED_OFF();delayms(100);LED_ON();delayms(100);
    02521 9AA7      SBI	0x14,7
    02522 98AF      CBI	0x15,7
    02523 E604      LDI	R16,0x64
    02524 E010      LDI	R17,0
    02525 940E 23FF CALL	_delayms
    02527 9AA7      SBI	0x14,7
    02528 9AAF      SBI	0x15,7
    02529 E604      LDI	R16,0x64
    0252A E010      LDI	R17,0
    0252B 940E 23FF CALL	_delayms
(0084) 	delayms(500);
    0252D EF04      LDI	R16,0xF4
    0252E E011      LDI	R17,1
    0252F 940E 23FF CALL	_delayms
(0085) 	lp("加热开关");
    02531 E006      LDI	R16,6
    02532 E012      LDI	R17,2
    02533 940E 3ADC CALL	_lp
(0086) 	RELAY_ON();delayms(100);  
    02535 9AAD      SBI	0x15,5
    02536 E604      LDI	R16,0x64
    02537 E010      LDI	R17,0
    02538 940E 23FF CALL	_delayms
(0087) 	RELAY_OFF();delayms(100);
    0253A 98AD      CBI	0x15,5
    0253B E604      LDI	R16,0x64
    0253C E010      LDI	R17,0
    0253D 940E 23FF CALL	_delayms
(0088) 	RELAY_ON();delayms(100);
    0253F 9AAD      SBI	0x15,5
    02540 E604      LDI	R16,0x64
    02541 E010      LDI	R17,0
    02542 940E 23FF CALL	_delayms
(0089) 	RELAY_OFF();delayms(100);
    02544 98AD      CBI	0x15,5
    02545 E604      LDI	R16,0x64
    02546 E010      LDI	R17,0
    02547 940E 23FF CALL	_delayms
(0090) 	lp("  ");delayms(500);
    02549 E003      LDI	R16,3
    0254A E012      LDI	R17,2
    0254B 940E 3ADC CALL	_lp
    0254D EF04      LDI	R16,0xF4
    0254E E011      LDI	R17,1
    0254F 940E 23FF CALL	_delayms
(0091) 	lp("完成自检");delayms(500);
    02551 EF0A      LDI	R16,0xFA
    02552 E011      LDI	R17,1
    02553 940E 3ADC CALL	_lp
    02555 EF04      LDI	R16,0xF4
    02556 E011      LDI	R17,1
    02557 940E 23FF CALL	_delayms
    02559 9662      ADIW	R28,0x12
    0255A 9508      RET
_WriteFileHead:
  fs                   --> Y,+177
  bw                   --> Y,+175
  fnamep               --> Y,+161
  itam                 --> Y,+38
  file                 --> Y,+4
  res                  --> R10
    0255B 940E 3F7A CALL	push_xgset003C
    0255D 97EF      SBIW	R28,0x3F
    0255E 97EF      SBIW	R28,0x3F
    0255F 97EF      SBIW	R28,0x3F
    02560 97EF      SBIW	R28,0x3F
    02561 97EF      SBIW	R28,0x3F
    02562 97EF      SBIW	R28,0x3F
    02563 97EF      SBIW	R28,0x3F
    02564 97EF      SBIW	R28,0x3F
    02565 97EF      SBIW	R28,0x3F
    02566 97EF      SBIW	R28,0x3F
    02567 97EF      SBIW	R28,0x3F
    02568 97AA      SBIW	R28,0x2A
(0092) 	  
(0093) }
(0094) void WriteFileHead(void)   
(0095) {
(0096)  	 unsigned int bw;
(0097) 	 FRESULT res;
(0098) 	 FATFS fs;
(0099) 	 FIL file;
(0100) 	 char fnamep[]="201201.xls\0\0\0"; 
    02569 E287      LDI	R24,0x27
    0256A E091      LDI	R25,1
    0256B 01FE      MOVW	R30,R28
    0256C 55EF      SUBI	R30,0x5F
    0256D 4FFF      SBCI	R31,0xFF
    0256E E00E      LDI	R16,0xE
    0256F E010      LDI	R17,0
    02570 93FA      ST	-Y,R31
    02571 93EA      ST	-Y,R30
    02572 939A      ST	-Y,R25
    02573 938A      ST	-Y,R24
    02574 940E 401B CALL	asgnblk
(0101) 	 UINT8 itam[]="DEV000001\t\t\t\t\t\t\t\t\t\t\r\n序号\t日期\t时分\t温度\t风速\t风冷指数\t等价制冷温度\t相当温度\t冻伤危害性\t安静作业\t中等强度作业\t高强度作业\n\0";
    02576 E385      LDI	R24,0x35
    02577 E091      LDI	R25,1
    02578 01FE      MOVW	R30,R28
    02579 96B6      ADIW	R30,0x26
    0257A E70B      LDI	R16,0x7B
    0257B E010      LDI	R17,0
    0257C 93FA      ST	-Y,R31
    0257D 93EA      ST	-Y,R30
    0257E 939A      ST	-Y,R25
    0257F 938A      ST	-Y,R24
    02580 940E 401B CALL	asgnblk
(0102) 	 res=disk_initialize(0);
    02582 2700      CLR	R16
    02583 940E 0285 CALL	_disk_initialize
    02585 2EA0      MOV	R10,R16
(0103) 	 #ifdef _DEBUG
(0104) 	 debug("dinit",res);
    02586 2D2A      MOV	R18,R10
    02587 EF04      LDI	R16,0xF4
    02588 E011      LDI	R17,1
    02589 D577      RCALL	_debug
(0105) 	 #endif
(0106) 	 res = f_mount(0, &fs);
    0258A 019E      MOVW	R18,R28
    0258B 542F      SUBI	R18,0x4F
    0258C 4F3F      SBCI	R19,0xFF
    0258D 2700      CLR	R16
    0258E 940E 1671 CALL	_f_mount
    02590 2EA0      MOV	R10,R16
(0107) 	 #ifdef _DEBUG
(0108)  	 debug("dmnt",res);
    02591 2D2A      MOV	R18,R10
    02592 EE0F      LDI	R16,0xEF
    02593 E011      LDI	R17,1
    02594 D56C      RCALL	_debug
(0109) 	 #endif
(0110) 	 //get_name(fnamep)
(0111) 	 res = f_open(&file, get_name(fnamep) , FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    02595 018E      MOVW	R16,R28
    02596 550F      SUBI	R16,0x5F
    02597 4F1F      SBCI	R17,0xFF
    02598 D48D      RCALL	_get_name
    02599 0168      MOVW	R12,R16
    0259A E182      LDI	R24,0x12
    0259B 8388      ST	Y,R24
    0259C 0196      MOVW	R18,R12
    0259D 018E      MOVW	R16,R28
    0259E 5F0C      SUBI	R16,0xFC
    0259F 4F1F      SBCI	R17,0xFF
    025A0 940E 169C CALL	_f_open
    025A2 2EC0      MOV	R12,R16
    025A3 2CAC      MOV	R10,R12
(0112) 	 #ifdef _DEBUG
(0113) 	 debug("fopen",res);
    025A4 2D2A      MOV	R18,R10
    025A5 EE09      LDI	R16,0xE9
    025A6 E011      LDI	R17,1
    025A7 D559      RCALL	_debug
(0114) 	 #endif
(0115) 	 res = f_write(&file,itam,sizeof(itam),&bw);   //bw 已写入字节数
    025A8 01CE      MOVW	R24,R28
    025A9 5581      SUBI	R24,0x51
    025AA 4F9F      SBCI	R25,0xFF
    025AB 839B      STD	Y+3,R25
    025AC 838A      STD	Y+2,R24
    025AD E78B      LDI	R24,0x7B
    025AE E090      LDI	R25,0
    025AF 8399      STD	Y+1,R25
    025B0 8388      ST	Y,R24
    025B1 019E      MOVW	R18,R28
    025B2 5D2A      SUBI	R18,0xDA
    025B3 4F3F      SBCI	R19,0xFF
    025B4 018E      MOVW	R16,R28
    025B5 5F0C      SUBI	R16,0xFC
    025B6 4F1F      SBCI	R17,0xFF
    025B7 940E 1AA3 CALL	_f_write
    025B9 2EC0      MOV	R12,R16
    025BA 2CAC      MOV	R10,R12
(0116) 	 #ifdef _DEBUG
(0117) 	 debug("fwrite",res);
    025BB 2D2A      MOV	R18,R10
    025BC EE02      LDI	R16,0xE2
    025BD E011      LDI	R17,1
    025BE D542      RCALL	_debug
(0118) 	 #endif
(0119) 	 f_close(&file);
    025BF 018E      MOVW	R16,R28
    025C0 5F0C      SUBI	R16,0xFC
    025C1 4F1F      SBCI	R17,0xFF
    025C2 940E 1E6D CALL	_f_close
(0120) 	 f_mount(0, NULL);
    025C4 2722      CLR	R18
    025C5 2733      CLR	R19
    025C6 2700      CLR	R16
    025C7 940E 1671 CALL	_f_mount
    025C9 96EF      ADIW	R28,0x3F
    025CA 96EF      ADIW	R28,0x3F
    025CB 96EF      ADIW	R28,0x3F
    025CC 96EF      ADIW	R28,0x3F
    025CD 96EF      ADIW	R28,0x3F
    025CE 96EF      ADIW	R28,0x3F
    025CF 96EF      ADIW	R28,0x3F
    025D0 96EF      ADIW	R28,0x3F
    025D1 96EF      ADIW	R28,0x3F
    025D2 96EF      ADIW	R28,0x3F
    025D3 96EF      ADIW	R28,0x3F
    025D4 96AA      ADIW	R28,0x2A
    025D5 940C 3F54 JMP	pop_xgset003C
_WriteSDFile:
  fnamep               --> Y,+602
  fs                   --> Y,+44
  bw                   --> Y,+42
  lenth                --> Y,+38
  res                  --> R10
  file                 --> Y,+4
    025D7 92AA      ST	-Y,R10
    025D8 92CA      ST	-Y,R12
    025D9 97EF      SBIW	R28,0x3F
    025DA 97EF      SBIW	R28,0x3F
    025DB 97EF      SBIW	R28,0x3F
    025DC 97EF      SBIW	R28,0x3F
    025DD 97EF      SBIW	R28,0x3F
    025DE 97EF      SBIW	R28,0x3F
    025DF 97EF      SBIW	R28,0x3F
    025E0 97EF      SBIW	R28,0x3F
    025E1 97EF      SBIW	R28,0x3F
    025E2 97E0      SBIW	R28,0x30
(0121) } /////////////////////////////////////////////////
(0122) //       写入文件函数 
(0123) //(创建)打开文件 
(0124) // data 指向欲写入的的字符串 64byt 
(0125) //////////////////////////////////////////////// 
(0126) void WriteSDFile(void)   
(0127) {
(0128)     unsigned int bw;
(0129) 	FRESULT res;
(0130) 	FATFS fs;
(0131)     FIL file;
(0132) 	char fnamep[13];
(0133) 	long lenth=0;
    025E3 E080      LDI	R24,0
    025E4 A38E      STD	Y+38,R24
    025E5 A38F      STD	Y+39,R24
    025E6 A788      STD	Y+40,R24
    025E7 A789      STD	Y+41,R24
(0134) 	disk_initialize(0);
    025E8 2700      CLR	R16
    025E9 940E 0285 CALL	_disk_initialize
(0135) 	res = f_mount(0, &fs);
    025EB 019E      MOVW	R18,R28
    025EC 5D24      SUBI	R18,0xD4
    025ED 4F3F      SBCI	R19,0xFF
    025EE 2700      CLR	R16
    025EF 940E 1671 CALL	_f_mount
(0136) 	res = f_open(&file,get_name(fnamep), FA_OPEN_ALWAYS | FA_WRITE );  //创建一个新的文件
    025F1 018E      MOVW	R16,R28
    025F2 5A06      SUBI	R16,0xA6
    025F3 4F1D      SBCI	R17,0xFD
    025F4 D431      RCALL	_get_name
    025F5 E182      LDI	R24,0x12
    025F6 8388      ST	Y,R24
    025F7 0198      MOVW	R18,R16
    025F8 018E      MOVW	R16,R28
    025F9 5F0C      SUBI	R16,0xFC
    025FA 4F1F      SBCI	R17,0xFF
    025FB 940E 169C CALL	_f_open
(0137) 	lenth=file.fsize;   
    025FD 842E      LDD	R2,Y+14
    025FE 843F      LDD	R3,Y+15
    025FF 8848      LDD	R4,Y+16
    02600 8859      LDD	R5,Y+17
    02601 A22E      STD	Y+38,R2
    02602 A23F      STD	Y+39,R3
    02603 A648      STD	Y+40,R4
    02604 A659      STD	Y+41,R5
(0138) 	res = f_lseek (&file,lenth);	 
    02605 A02E      LDD	R2,Y+38
    02606 A03F      LDD	R3,Y+39
    02607 A448      LDD	R4,Y+40
    02608 A459      LDD	R5,Y+41
    02609 8248      ST	Y,R4
    0260A 8259      STD	Y+1,R5
    0260B 0191      MOVW	R18,R2
    0260C 018E      MOVW	R16,R28
    0260D 5F0C      SUBI	R16,0xFC
    0260E 4F1F      SBCI	R17,0xFF
    0260F 940E 1E7D CALL	_f_lseek
(0139) 	res = f_write(&file,TempChar,64,&bw);   //bw 已写入字节数
    02611 01CE      MOVW	R24,R28
    02612 968A      ADIW	R24,0x2A
    02613 839B      STD	Y+3,R25
    02614 838A      STD	Y+2,R24
    02615 E480      LDI	R24,0x40
    02616 E090      LDI	R25,0
    02617 8399      STD	Y+1,R25
    02618 8388      ST	Y,R24
    02619 EF28      LDI	R18,0xF8
    0261A E034      LDI	R19,4
    0261B 018E      MOVW	R16,R28
    0261C 5F0C      SUBI	R16,0xFC
    0261D 4F1F      SBCI	R17,0xFF
    0261E 940E 1AA3 CALL	_f_write
    02620 2EC0      MOV	R12,R16
    02621 2CAC      MOV	R10,R12
(0140) 	f_close(&file);
    02622 018E      MOVW	R16,R28
    02623 5F0C      SUBI	R16,0xFC
    02624 4F1F      SBCI	R17,0xFF
    02625 940E 1E6D CALL	_f_close
(0141) 	f_mount(0, NULL);
    02627 2722      CLR	R18
    02628 2733      CLR	R19
    02629 2700      CLR	R16
    0262A 940E 1671 CALL	_f_mount
    0262C 96EF      ADIW	R28,0x3F
    0262D 96EF      ADIW	R28,0x3F
    0262E 96EF      ADIW	R28,0x3F
    0262F 96EF      ADIW	R28,0x3F
    02630 96EF      ADIW	R28,0x3F
    02631 96EF      ADIW	R28,0x3F
    02632 96EF      ADIW	R28,0x3F
    02633 96EF      ADIW	R28,0x3F
    02634 96EF      ADIW	R28,0x3F
    02635 96E0      ADIW	R28,0x30
    02636 90C9      LD	R12,Y+
    02637 90A9      LD	R10,Y+
    02638 9508      RET
_ReadSDFile:
  fs                   --> Y,+53
  bw                   --> Y,+51
  fnamep               --> Y,+38
  file                 --> Y,+4
  res                  --> R20
  data                 --> R10
  index                --> R22
    02639 940E 3FAF CALL	push_xgsetF03C
    0263B 0159      MOVW	R10,R18
    0263C 01B8      MOVW	R22,R16
    0263D 97EF      SBIW	R28,0x3F
    0263E 97EF      SBIW	R28,0x3F
    0263F 97EF      SBIW	R28,0x3F
    02640 97EF      SBIW	R28,0x3F
    02641 97EF      SBIW	R28,0x3F
    02642 97EF      SBIW	R28,0x3F
    02643 97EF      SBIW	R28,0x3F
    02644 97EF      SBIW	R28,0x3F
    02645 97EF      SBIW	R28,0x3F
    02646 97AC      SBIW	R28,0x2C
(0142) }
(0143) /////////////////////////////////////////////////
(0144) //       读取文件函数
(0145) //以64byte为一块 读取
(0146) //index数据偏移量   data读出后存放地
(0147) //////////////////////////////////////////////// 
(0148) char ReadSDFile(unsigned int index,char *data)
(0149) {
(0150)  	unsigned int bw;
(0151) 	char res;
(0152) 	FATFS fs;
(0153)     FIL file;
(0154) 	char fnamep[13];
(0155)     get_name(fnamep); 
    02647 018E      MOVW	R16,R28
    02648 5D0A      SUBI	R16,0xDA
    02649 4F1F      SBCI	R17,0xFF
    0264A D3DB      RCALL	_get_name
(0156)     disk_initialize(0);
    0264B 2700      CLR	R16
    0264C 940E 0285 CALL	_disk_initialize
(0157)     res = f_mount(0, &fs);
    0264E 019E      MOVW	R18,R28
    0264F 5C2B      SUBI	R18,0xCB
    02650 4F3F      SBCI	R19,0xFF
    02651 2700      CLR	R16
    02652 940E 1671 CALL	_f_mount
(0158)     res = f_open(&file,fnamep,FA_READ);  
    02654 E081      LDI	R24,1
    02655 8388      ST	Y,R24
    02656 019E      MOVW	R18,R28
    02657 5D2A      SUBI	R18,0xDA
    02658 4F3F      SBCI	R19,0xFF
    02659 018E      MOVW	R16,R28
    0265A 5F0C      SUBI	R16,0xFC
    0265B 4F1F      SBCI	R17,0xFF
    0265C 940E 169C CALL	_f_open
    0265E 2F40      MOV	R20,R16
(0159)     if(res==FR_NO_FILE) {data=NULL;
    0265F 3004      CPI	R16,4
    02660 F419      BNE	0x2664
    02661 24AA      CLR	R10
    02662 24BB      CLR	R11
(0160)     #if _debug >= 1 
(0161)     debug_out("now file",255);
(0162) 	debug_out(filename,res);
(0163) 	debug_out("file is no exist....",255);
(0164)     #endif 
(0165)     return res;
    02663 C02E      RJMP	0x2692
(0166)     }   
(0167)     res = f_lseek (&file,(index+2)*64);	 //前两个字节数据为文件头空间 所以从第三块读/写起
    02664 019B      MOVW	R18,R22
    02665 5F2E      SUBI	R18,0xFE
    02666 4F3F      SBCI	R19,0xFF
    02667 E400      LDI	R16,0x40
    02668 E010      LDI	R17,0
    02669 940E 3F10 CALL	empy16s
    0266B 0118      MOVW	R2,R16
    0266C 2444      CLR	R4
    0266D 2455      CLR	R5
    0266E 8248      ST	Y,R4
    0266F 8259      STD	Y+1,R5
    02670 0191      MOVW	R18,R2
    02671 018E      MOVW	R16,R28
    02672 5F0C      SUBI	R16,0xFC
    02673 4F1F      SBCI	R17,0xFF
    02674 940E 1E7D CALL	_f_lseek
    02676 2EC0      MOV	R12,R16
(0168)     res = f_read(&file,data,64,&bw);
    02677 01CE      MOVW	R24,R28
    02678 96C3      ADIW	R24,0x33
    02679 839B      STD	Y+3,R25
    0267A 838A      STD	Y+2,R24
    0267B E480      LDI	R24,0x40
    0267C E090      LDI	R25,0
    0267D 8399      STD	Y+1,R25
    0267E 8388      ST	Y,R24
    0267F 0195      MOVW	R18,R10
    02680 018E      MOVW	R16,R28
    02681 5F0C      SUBI	R16,0xFC
    02682 4F1F      SBCI	R17,0xFF
    02683 940E 1838 CALL	_f_read
    02685 2EA0      MOV	R10,R16
    02686 2D4A      MOV	R20,R10
(0169)     f_close(&file);
    02687 018E      MOVW	R16,R28
    02688 5F0C      SUBI	R16,0xFC
    02689 4F1F      SBCI	R17,0xFF
    0268A 940E 1E6D CALL	_f_close
(0170) 	f_mount(0, NULL);
    0268C 2722      CLR	R18
    0268D 2733      CLR	R19
    0268E 2700      CLR	R16
    0268F 940E 1671 CALL	_f_mount
(0171) 	return res;
    02691 2F04      MOV	R16,R20
    02692 96EF      ADIW	R28,0x3F
    02693 96EF      ADIW	R28,0x3F
    02694 96EF      ADIW	R28,0x3F
    02695 96EF      ADIW	R28,0x3F
    02696 96EF      ADIW	R28,0x3F
    02697 96EF      ADIW	R28,0x3F
    02698 96EF      ADIW	R28,0x3F
    02699 96EF      ADIW	R28,0x3F
    0269A 96EF      ADIW	R28,0x3F
    0269B 96AC      ADIW	R28,0x2C
    0269C 940C 3FB8 JMP	pop_xgsetF03C
_findIndex:
  fs                   --> Y,+48
  bw                   --> Y,+46
  fnamep               --> R14
  readsize             --> R10
  res                  --> R12
  file                 --> Y,+12
  lenth                --> Y,+8
  index                --> Y,+4
  is_first_end         --> Y,+606
  tmp                  --> R10
  buf                  --> Y,+617
  filename             --> R10
    0269E 933A      ST	-Y,R19
    0269F 932A      ST	-Y,R18
    026A0 940E 3F74 CALL	push_xgsetF0FC
    026A2 0158      MOVW	R10,R16
    026A3 97EF      SBIW	R28,0x3F
    026A4 97EF      SBIW	R28,0x3F
    026A5 97EF      SBIW	R28,0x3F
    026A6 97EF      SBIW	R28,0x3F
    026A7 97EF      SBIW	R28,0x3F
    026A8 97EF      SBIW	R28,0x3F
    026A9 97EF      SBIW	R28,0x3F
    026AA 97EF      SBIW	R28,0x3F
    026AB 97EF      SBIW	R28,0x3F
    026AC 97A8      SBIW	R28,0x28
(0172) } 
(0173) //////////////////////////////////
(0174) //   find index
(0175) // 检查当前文件尺寸，根据倒数第二个
(0176) //'\n'及其后面的index确定当前index值
(0177) //////////////////////////////////
(0178) unsigned int findIndex(char *filename,char *buf){
(0179)     unsigned int bw,tmp;
(0180) 	long index =0;
    026AD E080      LDI	R24,0
    026AE 838C      STD	Y+4,R24
    026AF 838D      STD	Y+5,R24
    026B0 838E      STD	Y+6,R24
    026B1 838F      STD	Y+7,R24
(0181) 	unsigned char is_first_end=0;
    026B2 2400      CLR	R0
    026B3 01DE      MOVW	R26,R28
    026B4 5AA2      SUBI	R26,0xA2
    026B5 4FBD      SBCI	R27,0xFD
    026B6 920C      ST	X,R0
(0182) 	char *fnamep=filename;
    026B7 0175      MOVW	R14,R10
(0183) 	FRESULT res;
(0184) 	FATFS fs;
(0185) 	FIL file;
(0186) 	long lenth=0;
    026B8 E080      LDI	R24,0
    026B9 8788      STD	Y+8,R24
    026BA 8789      STD	Y+9,R24
    026BB 878A      STD	Y+10,R24
    026BC 878B      STD	Y+11,R24
(0187) 	int readsize=0;
    026BD 24AA      CLR	R10
    026BE 24BB      CLR	R11
(0188) 	//PrintString_n(fnamep);
(0189) 	res = f_mount(0, &fs);
    026BF 019E      MOVW	R18,R28
    026C0 5D20      SUBI	R18,0xD0
    026C1 4F3F      SBCI	R19,0xFF
    026C2 2700      CLR	R16
    026C3 940E 1671 CALL	_f_mount
(0190) 	res = f_open(&file,fnamep, FA_OPEN_ALWAYS | FA_READ );  //创建一个新的文件
    026C5 E181      LDI	R24,0x11
    026C6 8388      ST	Y,R24
    026C7 0197      MOVW	R18,R14
    026C8 018E      MOVW	R16,R28
    026C9 5F04      SUBI	R16,0xF4
    026CA 4F1F      SBCI	R17,0xFF
    026CB 940E 169C CALL	_f_open
    026CD 2EC0      MOV	R12,R16
(0191) 	if(res !=  FR_OK){ //openerror
    026CE 2300      TST	R16
    026CF F011      BEQ	0x26D2
(0192) 	    return res;}
    026D0 2711      CLR	R17
    026D1 C11E      RJMP	0x27F0
(0193) 	lenth=file.fsize;   //文件尾部为 file.size 
    026D2 882E      LDD	R2,Y+22
    026D3 883F      LDD	R3,Y+23
    026D4 8C48      LDD	R4,Y+24
    026D5 8C59      LDD	R5,Y+25
    026D6 8628      STD	Y+8,R2
    026D7 8639      STD	Y+9,R3
    026D8 864A      STD	Y+10,R4
    026D9 865B      STD	Y+11,R5
(0194) 	//debug("size=",0xff);
(0195) 	//PrintLong(lenth);
(0196) 	if(lenth > 512) {
    026DA E040      LDI	R20,0
    026DB E052      LDI	R21,2
    026DC E060      LDI	R22,0
    026DD E070      LDI	R23,0
    026DE 8428      LDD	R2,Y+8
    026DF 8439      LDD	R3,Y+9
    026E0 844A      LDD	R4,Y+10
    026E1 845B      LDD	R5,Y+11
    026E2 1542      CP	R20,R2
    026E3 0553      CPC	R21,R3
    026E4 0564      CPC	R22,R4
    026E5 0575      CPC	R23,R5
    026E6 F464      BGE	0x26F3
(0197) 	    readsize=512;
    026E7 E080      LDI	R24,0
    026E8 E092      LDI	R25,2
    026E9 015C      MOVW	R10,R24
(0198) 		lenth=file.fsize;
    026EA 882E      LDD	R2,Y+22
    026EB 883F      LDD	R3,Y+23
    026EC 8C48      LDD	R4,Y+24
    026ED 8C59      LDD	R5,Y+25
    026EE 8628      STD	Y+8,R2
    026EF 8639      STD	Y+9,R3
    026F0 864A      STD	Y+10,R4
    026F1 865B      STD	Y+11,R5
(0199) 	}
    026F2 C007      RJMP	0x26FA
(0200) 	else {
(0201) 	    readsize =file.fsize;
    026F3 88AE      LDD	R10,Y+22
    026F4 88BF      LDD	R11,Y+23
(0202) 		lenth=0;
    026F5 E080      LDI	R24,0
    026F6 8788      STD	Y+8,R24
    026F7 8789      STD	Y+9,R24
    026F8 878A      STD	Y+10,R24
    026F9 878B      STD	Y+11,R24
(0203) 	}
(0204) 	res = f_lseek (&file,file.fsize-readsize);
    026FA 0115      MOVW	R2,R10
    026FB 2444      CLR	R4
    026FC FC37      SBRC	R3,7
    026FD 9440      COM	R4
    026FE 2455      CLR	R5
    026FF FC47      SBRC	R4,7
    02700 9450      COM	R5
    02701 886E      LDD	R6,Y+22
    02702 887F      LDD	R7,Y+23
    02703 8C88      LDD	R8,Y+24
    02704 8C99      LDD	R9,Y+25
    02705 1862      SUB	R6,R2
    02706 0873      SBC	R7,R3
    02707 0884      SBC	R8,R4
    02708 0895      SBC	R9,R5
    02709 8288      ST	Y,R8
    0270A 8299      STD	Y+1,R9
    0270B 0193      MOVW	R18,R6
    0270C 018E      MOVW	R16,R28
    0270D 5F04      SUBI	R16,0xF4
    0270E 4F1F      SBCI	R17,0xFF
    0270F 940E 1E7D CALL	_f_lseek
(0205) 	//debug("readSIZE=",0x00);
(0206) 	//PrintLong((file.fsize-readsize));
(0207) 	res = f_read(&file,buf,readsize,&bw);
    02711 01CE      MOVW	R24,R28
    02712 968E      ADIW	R24,0x2E
    02713 839B      STD	Y+3,R25
    02714 838A      STD	Y+2,R24
    02715 82B9      STD	Y+1,R11
    02716 82A8      ST	Y,R10
    02717 01FE      MOVW	R30,R28
    02718 59E7      SUBI	R30,0x97
    02719 4FFD      SBCI	R31,0xFD
    0271A 8120      LD	R18,Z
    0271B 8131      LDD	R19,Z+1
    0271C 018E      MOVW	R16,R28
    0271D 5F04      SUBI	R16,0xF4
    0271E 4F1F      SBCI	R17,0xFF
    0271F 940E 1838 CALL	_f_read
    02721 2EE0      MOV	R14,R16
    02722 2CCE      MOV	R12,R14
(0208) 	f_close(&file);
    02723 018E      MOVW	R16,R28
    02724 5F04      SUBI	R16,0xF4
    02725 4F1F      SBCI	R17,0xFF
    02726 940E 1E6D CALL	_f_close
(0209) 	//debug("readRES=",res);
(0210) 	//debug("readbw=",0X00);
(0211) 	//PrintLong(bw);
(0212) 	//PrintString_n(buf);
(0213) 	for(tmp=readsize;tmp>0;tmp--){
    02728 C04E      RJMP	0x2777
(0214) 		//debug("buf index",buf[tmp]);
(0215) 		//PrintLong(tmp);
(0216) 		if(buf[tmp] == '\n') Usart_Transmit('@');						  
    02729 01F5      MOVW	R30,R10
    0272A 01DE      MOVW	R26,R28
    0272B 59A7      SUBI	R26,0x97
    0272C 4FBD      SBCI	R27,0xFD
    0272D 900D      LD	R0,X+
    0272E 901C      LD	R1,X
    0272F 0DE0      ADD	R30,R0
    02730 1DF1      ADC	R31,R1
    02731 8180      LD	R24,Z
    02732 308A      CPI	R24,0xA
    02733 F419      BNE	0x2737
    02734 E400      LDI	R16,0x40
    02735 940E 35D3 CALL	_Usart_Transmit
(0217) 		if(buf[tmp] == '\n' && is_first_end== 0){
    02737 01F5      MOVW	R30,R10
    02738 01DE      MOVW	R26,R28
    02739 59A7      SUBI	R26,0x97
    0273A 4FBD      SBCI	R27,0xFD
    0273B 900D      LD	R0,X+
    0273C 901C      LD	R1,X
    0273D 0DE0      ADD	R30,R0
    0273E 1DF1      ADC	R31,R1
    0273F 8180      LD	R24,Z
    02740 308A      CPI	R24,0xA
    02741 F469      BNE	0x274F
    02742 01FE      MOVW	R30,R28
    02743 5AE2      SUBI	R30,0xA2
    02744 4FFD      SBCI	R31,0xFD
    02745 8000      LD	R0,Z
    02746 2000      TST	R0
    02747 F439      BNE	0x274F
(0218) 		    is_first_end=1; 	
    02748 2400      CLR	R0
    02749 9403      INC	R0
    0274A 01FE      MOVW	R30,R28
    0274B 5AE2      SUBI	R30,0xA2
    0274C 4FFD      SBCI	R31,0xFD
    0274D 8200      ST	Z,R0
(0219) 			//debug("first=",0xf0);					      
(0220) 		}
    0274E C025      RJMP	0x2774
(0221) 		else if(buf[tmp] == '\n' && is_first_end== 1){
    0274F 01F5      MOVW	R30,R10
    02750 01DE      MOVW	R26,R28
    02751 59A7      SUBI	R26,0x97
    02752 4FBD      SBCI	R27,0xFD
    02753 900D      LD	R0,X+
    02754 901C      LD	R1,X
    02755 0DE0      ADD	R30,R0
    02756 1DF1      ADC	R31,R1
    02757 8180      LD	R24,Z
    02758 308A      CPI	R24,0xA
    02759 F4D1      BNE	0x2774
    0275A 01DE      MOVW	R26,R28
    0275B 5AA2      SUBI	R26,0xA2
    0275C 4FBD      SBCI	R27,0xFD
    0275D 918C      LD	R24,X
    0275E 3081      CPI	R24,1
    0275F F4A1      BNE	0x2774
(0222) 		    lenth -= (512-tmp);
    02760 E080      LDI	R24,0
    02761 E092      LDI	R25,2
    02762 011C      MOVW	R2,R24
    02763 182A      SUB	R2,R10
    02764 083B      SBC	R3,R11
    02765 2444      CLR	R4
    02766 2455      CLR	R5
    02767 8468      LDD	R6,Y+8
    02768 8479      LDD	R7,Y+9
    02769 848A      LDD	R8,Y+10
    0276A 849B      LDD	R9,Y+11
    0276B 1862      SUB	R6,R2
    0276C 0873      SBC	R7,R3
    0276D 0884      SBC	R8,R4
    0276E 0895      SBC	R9,R5
    0276F 8668      STD	Y+8,R6
    02770 8679      STD	Y+9,R7
    02771 868A      STD	Y+10,R8
    02772 869B      STD	Y+11,R9
(0223) 			break;
    02773 C009      RJMP	0x277D
    02774 01C5      MOVW	R24,R10
    02775 9701      SBIW	R24,1
    02776 015C      MOVW	R10,R24
    02777 20AA      TST	R10
    02778 F009      BEQ	0x277A
    02779 CFAF      RJMP	0x2729
    0277A 20BB      TST	R11
    0277B F009      BEQ	0x277D
    0277C CFAC      RJMP	0x2729
(0224) 		} 						
(0225) 	}
(0226) 	//debug("start=",0X00); PrintLong(lenth);
(0227) 	if(lenth < 118 ){ 
    0277D E746      LDI	R20,0x76
    0277E E050      LDI	R21,0
    0277F E060      LDI	R22,0
    02780 E070      LDI	R23,0
    02781 8428      LDD	R2,Y+8
    02782 8439      LDD	R3,Y+9
    02783 844A      LDD	R4,Y+10
    02784 845B      LDD	R5,Y+11
    02785 1624      CP	R2,R20
    02786 0635      CPC	R3,R21
    02787 0646      CPC	R4,R22
    02788 0657      CPC	R5,R23
    02789 F434      BGE	0x2790
(0228)  		return 1;
    0278A E001      LDI	R16,1
    0278B E010      LDI	R17,0
    0278C C063      RJMP	0x27F0
(0229) 	}
(0230) 	else {
(0231) 		 //debug(">128 ",0X00);
(0232) 		 while(buf[tmp] <= '0' || buf[tmp] >= '9') tmp++;
    0278D 01C5      MOVW	R24,R10
    0278E 9601      ADIW	R24,1
    0278F 015C      MOVW	R10,R24
    02790 01F5      MOVW	R30,R10
    02791 01DE      MOVW	R26,R28
    02792 59A7      SUBI	R26,0x97
    02793 4FBD      SBCI	R27,0xFD
    02794 900D      LD	R0,X+
    02795 901C      LD	R1,X
    02796 0DE0      ADD	R30,R0
    02797 1DF1      ADC	R31,R1
    02798 80E0      LD	R14,Z
    02799 24FF      CLR	R15
    0279A E380      LDI	R24,0x30
    0279B 158E      CP	R24,R14
    0279C F780      BCC	0x278D
    0279D 2D8E      MOV	R24,R14
    0279E 3389      CPI	R24,0x39
    0279F F768      BCC	0x278D
    027A0 C02F      RJMP	0x27D0
(0233) 		 //debug("nozero ",bw); PrintLong(tmp);
(0234) 		 while(buf[tmp] != 't' && buf[tmp] >= '0' && buf[tmp] <= '9'){
(0235) 		     index=index*10+(buf[tmp]-'0');
    027A1 01F5      MOVW	R30,R10
    027A2 01DE      MOVW	R26,R28
    027A3 59A7      SUBI	R26,0x97
    027A4 4FBD      SBCI	R27,0xFD
    027A5 900D      LD	R0,X+
    027A6 901C      LD	R1,X
    027A7 0DE0      ADD	R30,R0
    027A8 1DF1      ADC	R31,R1
    027A9 8180      LD	R24,Z
    027AA 2799      CLR	R25
    027AB 97C0      SBIW	R24,0x30
    027AC 011C      MOVW	R2,R24
    027AD 2444      CLR	R4
    027AE FC37      SBRC	R3,7
    027AF 9440      COM	R4
    027B0 2455      CLR	R5
    027B1 FC47      SBRC	R4,7
    027B2 9450      COM	R5
    027B3 806C      LDD	R6,Y+4
    027B4 807D      LDD	R7,Y+5
    027B5 808E      LDD	R8,Y+6
    027B6 809F      LDD	R9,Y+7
    027B7 E04A      LDI	R20,0xA
    027B8 E050      LDI	R21,0
    027B9 E060      LDI	R22,0
    027BA E070      LDI	R23,0
    027BB 929A      ST	-Y,R9
    027BC 928A      ST	-Y,R8
    027BD 927A      ST	-Y,R7
    027BE 926A      ST	-Y,R6
    027BF 018A      MOVW	R16,R20
    027C0 019B      MOVW	R18,R22
    027C1 940E 3F20 CALL	empy32u|empy32s
    027C3 0138      MOVW	R6,R16
    027C4 0149      MOVW	R8,R18
    027C5 0C62      ADD	R6,R2
    027C6 1C73      ADC	R7,R3
    027C7 1C84      ADC	R8,R4
    027C8 1C95      ADC	R9,R5
    027C9 826C      STD	Y+4,R6
    027CA 827D      STD	Y+5,R7
    027CB 828E      STD	Y+6,R8
    027CC 829F      STD	Y+7,R9
(0236) 		 	 //Usart_Transmit(buf[tmp]);	
(0237) 		 	 tmp++;
    027CD 01C5      MOVW	R24,R10
    027CE 9601      ADIW	R24,1
    027CF 015C      MOVW	R10,R24
    027D0 01F5      MOVW	R30,R10
    027D1 01DE      MOVW	R26,R28
    027D2 59A7      SUBI	R26,0x97
    027D3 4FBD      SBCI	R27,0xFD
    027D4 900D      LD	R0,X+
    027D5 901C      LD	R1,X
    027D6 0DE0      ADD	R30,R0
    027D7 1DF1      ADC	R31,R1
    027D8 80E0      LD	R14,Z
    027D9 24FF      CLR	R15
    027DA 2D8E      MOV	R24,R14
    027DB 3784      CPI	R24,0x74
    027DC F031      BEQ	0x27E3
    027DD 3380      CPI	R24,0x30
    027DE F020      BCS	0x27E3
    027DF E389      LDI	R24,0x39
    027E0 158E      CP	R24,R14
    027E1 F008      BCS	0x27E3
    027E2 CFBE      RJMP	0x27A1
(0238) 		 }
(0239) 	}
(0240) 	//debug("index=",0X00);
(0241) 	//PrintLong(index+1);
(0242) 	return index+1;
    027E3 E041      LDI	R20,1
    027E4 E050      LDI	R21,0
    027E5 E060      LDI	R22,0
    027E6 E070      LDI	R23,0
    027E7 802C      LDD	R2,Y+4
    027E8 803D      LDD	R3,Y+5
    027E9 804E      LDD	R4,Y+6
    027EA 805F      LDD	R5,Y+7
    027EB 0E24      ADD	R2,R20
    027EC 1E35      ADC	R3,R21
    027ED 1E46      ADC	R4,R22
    027EE 1E57      ADC	R5,R23
    027EF 0181      MOVW	R16,R2
    027F0 96EF      ADIW	R28,0x3F
    027F1 96EF      ADIW	R28,0x3F
    027F2 96EF      ADIW	R28,0x3F
    027F3 96EF      ADIW	R28,0x3F
    027F4 96EF      ADIW	R28,0x3F
    027F5 96EF      ADIW	R28,0x3F
    027F6 96EF      ADIW	R28,0x3F
    027F7 96EF      ADIW	R28,0x3F
    027F8 96EF      ADIW	R28,0x3F
    027F9 96A8      ADIW	R28,0x28
    027FA 940E 3F69 CALL	pop_xgsetF0FC
    027FC 9622      ADIW	R28,2
    027FD 9508      RET
_check:
  WScounter            --> R10
  tmp                  --> R12
    027FE 940E 3F7A CALL	push_xgset003C
    02800 9722      SBIW	R28,2
(0243) }
(0244) void check( void )
(0245) {
(0246)  unsigned char tmp;
(0247)  unsigned int WScounter;
(0248)  //检测风速
(0249)  //读计数器1 此步需严格按手册进行。
(0250)  tmp=SREG;
    02801 B6CF      IN	R12,0x3F
(0251)  CLI();
    02802 94F8      BCLR	7
(0252)  WScounter=TCNT1H*256+TCNT1L;
    02803 B52D      IN	R18,0x2D
    02804 2733      CLR	R19
    02805 E000      LDI	R16,0
    02806 E011      LDI	R17,1
    02807 940E 3F10 CALL	empy16s
    02809 0158      MOVW	R10,R16
    0280A B42C      IN	R2,0x2C
    0280B 2433      CLR	R3
    0280C 0CA2      ADD	R10,R2
    0280D 1CB3      ADC	R11,R3
(0253)  SREG=tmp;
    0280E BECF      OUT	0x3F,R12
(0254)  SEI();
    0280F 9478      BSET	7
(0255)  //计算风速
(0256)  Result.WindSpeed=WScounter/N_per_Second;
    02810 0185      MOVW	R16,R10
    02811 940E 40CE CALL	uint2fp
    02813 0118      MOVW	R2,R16
    02814 0129      MOVW	R4,R18
    02815 EB00      LDI	R16,0xB0
    02816 E010      LDI	R17,0
    02817 940E 3EFC CALL	elpm32
    02819 933A      ST	-Y,R19
    0281A 932A      ST	-Y,R18
    0281B 931A      ST	-Y,R17
    0281C 930A      ST	-Y,R16
    0281D 0181      MOVW	R16,R2
    0281E 0192      MOVW	R18,R4
    0281F 940E 40FB CALL	fpdiv2
    02821 9310 057C STS	Result+52,R17
    02823 9300 057B STS	Result+51,R16
    02825 9330 057E STS	Result+54,R19
    02827 9320 057D STS	Result+53,R18
(0257)  //温度
(0258)  Result.Temperature=read_T_NUM(1);
    02829 E001      LDI	R16,1
    0282A 940E 3D0F CALL	_read_T_NUM
    0282C 9310 0572 STS	Result+42,R17
    0282E 9300 0571 STS	Result+41,R16
    02830 9330 0574 STS	Result+44,R19
    02832 9320 0573 STS	Result+43,R18
(0259)  //WCI风冷指数
(0260)   Result.WCI = 4.18 *(10*SquareRootFloat(Result.WindSpeed) + 10.45 -  Result.WindSpeed  ) *( 33 - Result.Temperature );
    02834 9120 057D LDS	R18,Result+53
    02836 9130 057E LDS	R19,Result+54
    02838 9100 057B LDS	R16,Result+51
    0283A 9110 057C LDS	R17,Result+52
    0283C D228      RCALL	_SquareRootFloat
    0283D 0118      MOVW	R2,R16
    0283E 0129      MOVW	R4,R18
    0283F EA0C      LDI	R16,0xAC
    02840 E010      LDI	R17,0
    02841 940E 3EFC CALL	elpm32
    02843 0138      MOVW	R6,R16
    02844 0149      MOVW	R8,R18
    02845 EA08      LDI	R16,0xA8
    02846 E010      LDI	R17,0
    02847 940E 3EFC CALL	elpm32
    02849 925A      ST	-Y,R5
    0284A 924A      ST	-Y,R4
    0284B 923A      ST	-Y,R3
    0284C 922A      ST	-Y,R2
    0284D 940E 4275 CALL	fpmule2
    0284F 0118      MOVW	R2,R16
    02850 0129      MOVW	R4,R18
    02851 EA04      LDI	R16,0xA4
    02852 E010      LDI	R17,0
    02853 940E 3EFC CALL	elpm32
    02855 933A      ST	-Y,R19
    02856 932A      ST	-Y,R18
    02857 931A      ST	-Y,R17
    02858 930A      ST	-Y,R16
    02859 0181      MOVW	R16,R2
    0285A 0192      MOVW	R18,R4
    0285B 940E 409D CALL	fpadd2
    0285D E78B      LDI	R24,0x7B
    0285E E095      LDI	R25,5
    0285F 939A      ST	-Y,R25
    02860 938A      ST	-Y,R24
    02861 940E 40B3 CALL	fpsub1x
    02863 0183      MOVW	R16,R6
    02864 0194      MOVW	R18,R8
    02865 940E 4275 CALL	fpmule2
    02867 0118      MOVW	R2,R16
    02868 0129      MOVW	R4,R18
    02869 EA00      LDI	R16,0xA0
    0286A E010      LDI	R17,0
    0286B 940E 3EFC CALL	elpm32
    0286D E781      LDI	R24,0x71
    0286E E095      LDI	R25,5
    0286F 939A      ST	-Y,R25
    02870 938A      ST	-Y,R24
    02871 940E 40B3 CALL	fpsub1x
    02873 0181      MOVW	R16,R2
    02874 0192      MOVW	R18,R4
    02875 940E 4275 CALL	fpmule2
    02877 9310 0585 STS	Result+61,R17
    02879 9300 0584 STS	Result+60,R16
    0287B 9330 0587 STS	Result+63,R19
    0287D 9320 0586 STS	Result+62,R18
(0261)  //ECT等价制冷温度
(0262)  Result.ECT = 33 - 0.01085 * Result.WCI;
    0287F E90C      LDI	R16,0x9C
    02880 E010      LDI	R17,0
    02881 940E 3EFC CALL	elpm32
    02883 0118      MOVW	R2,R16
    02884 0129      MOVW	R4,R18
    02885 E908      LDI	R16,0x98
    02886 E010      LDI	R17,0
    02887 940E 3EFC CALL	elpm32
    02889 E884      LDI	R24,0x84
    0288A E095      LDI	R25,5
    0288B 939A      ST	-Y,R25
    0288C 938A      ST	-Y,R24
    0288D 940E 4280 CALL	fpmule1x
    0288F 0181      MOVW	R16,R2
    02890 0192      MOVW	R18,R4
    02891 940E 40A8 CALL	fpsub2
    02893 9310 058F STS	Result+71,R17
    02895 9300 058E STS	Result+70,R16
    02897 9330 0591 STS	Result+73,R19
    02899 9320 0590 STS	Result+72,R18
(0263)  //TEQ 相当温度
(0264)  Result.Teq = Result.Temperature +( (Result.Temperature -36)/10 ) * Result.WindSpeed ;
    0289B 9040 0573 LDS	R4,Result+43
    0289D 9050 0574 LDS	R5,Result+44
    0289F 9020 0571 LDS	R2,Result+41
    028A1 9030 0572 LDS	R3,Result+42
    028A3 0131      MOVW	R6,R2
    028A4 0142      MOVW	R8,R4
    028A5 E904      LDI	R16,0x94
    028A6 E010      LDI	R17,0
    028A7 940E 3EFC CALL	elpm32
    028A9 933A      ST	-Y,R19
    028AA 932A      ST	-Y,R18
    028AB 931A      ST	-Y,R17
    028AC 930A      ST	-Y,R16
    028AD 0183      MOVW	R16,R6
    028AE 0194      MOVW	R18,R8
    028AF 940E 40A8 CALL	fpsub2
    028B1 0138      MOVW	R6,R16
    028B2 0149      MOVW	R8,R18
    028B3 EA08      LDI	R16,0xA8
    028B4 E010      LDI	R17,0
    028B5 940E 3EFC CALL	elpm32
    028B7 933A      ST	-Y,R19
    028B8 932A      ST	-Y,R18
    028B9 931A      ST	-Y,R17
    028BA 930A      ST	-Y,R16
    028BB 0183      MOVW	R16,R6
    028BC 0194      MOVW	R18,R8
    028BD 940E 40FB CALL	fpdiv2
    028BF E78B      LDI	R24,0x7B
    028C0 E095      LDI	R25,5
    028C1 939A      ST	-Y,R25
    028C2 938A      ST	-Y,R24
    028C3 940E 4280 CALL	fpmule1x
    028C5 0181      MOVW	R16,R2
    028C6 0192      MOVW	R18,R4
    028C7 940E 409D CALL	fpadd2
    028C9 9310 0599 STS	Result+81,R17
    028CB 9300 0598 STS	Result+80,R16
    028CD 9330 059B STS	Result+83,R19
    028CF 9320 059A STS	Result+82,R18
(0265) //将数据转换成字符串
(0266)  
(0267) ftochr(Result.WindSpeed,Result.WSChar);
    028D1 E78F      LDI	R24,0x7F
    028D2 E095      LDI	R25,5
    028D3 8399      STD	Y+1,R25
    028D4 8388      ST	Y,R24
    028D5 9120 057D LDS	R18,Result+53
    028D7 9130 057E LDS	R19,Result+54
    028D9 9100 057B LDS	R16,Result+51
    028DB 9110 057C LDS	R17,Result+52
    028DD D04E      RCALL	_ftochr
(0268) ftochr(Result.Temperature,Result.TempChar);
    028DE E785      LDI	R24,0x75
    028DF E095      LDI	R25,5
    028E0 8399      STD	Y+1,R25
    028E1 8388      ST	Y,R24
    028E2 9120 0573 LDS	R18,Result+43
    028E4 9130 0574 LDS	R19,Result+44
    028E6 9100 0571 LDS	R16,Result+41
    028E8 9110 0572 LDS	R17,Result+42
    028EA D041      RCALL	_ftochr
(0269) ftochr(Result.WCI,Result.WCIChar);
    028EB E888      LDI	R24,0x88
    028EC E095      LDI	R25,5
    028ED 8399      STD	Y+1,R25
    028EE 8388      ST	Y,R24
    028EF 9120 0586 LDS	R18,Result+62
    028F1 9130 0587 LDS	R19,Result+63
    028F3 9100 0584 LDS	R16,Result+60
    028F5 9110 0585 LDS	R17,Result+61
    028F7 D034      RCALL	_ftochr
(0270) ftochr(Result.ECT,Result.ECTChar);
    028F8 E982      LDI	R24,0x92
    028F9 E095      LDI	R25,5
    028FA 8399      STD	Y+1,R25
    028FB 8388      ST	Y,R24
    028FC 9120 0590 LDS	R18,Result+72
    028FE 9130 0591 LDS	R19,Result+73
    02900 9100 058E LDS	R16,Result+70
    02902 9110 058F LDS	R17,Result+71
    02904 D027      RCALL	_ftochr
(0271) ftochr(Result.Teq,Result.TeqChar);
    02905 E98C      LDI	R24,0x9C
    02906 E095      LDI	R25,5
    02907 8399      STD	Y+1,R25
    02908 8388      ST	Y,R24
    02909 9120 059A LDS	R18,Result+82
    0290B 9130 059B LDS	R19,Result+83
    0290D 9100 0598 LDS	R16,Result+80
    0290F 9110 0599 LDS	R17,Result+81
    02911 D01A      RCALL	_ftochr
(0272) itoa(Result.IndexChar,Result.Index,10);
    02912 E08A      LDI	R24,0xA
    02913 E090      LDI	R25,0
    02914 8399      STD	Y+1,R25
    02915 8388      ST	Y,R24
    02916 9120 0552 LDS	R18,Result+10
    02918 9130 0553 LDS	R19,Result+11
    0291A E506      LDI	R16,0x56
    0291B E015      LDI	R17,5
    0291C 940E 42A6 CALL	_itoa
(0273) Result.TempChar[6]='\0';
    0291E 2422      CLR	R2
    0291F 9220 057B STS	Result+51,R2
(0274) Result.WSChar[5]='\0';
    02921 9220 0584 STS	Result+60,R2
(0275) Result.WCIChar[6]='\0';
    02923 9220 058E STS	Result+70,R2
(0276) Result.ECTChar[6]='\0';
    02925 9220 0598 STS	Result+80,R2
(0277) Result.TeqChar[6]='\0';
    02927 9220 05A2 STS	Result+90,R2
(0278)  return ;
    02929 9622      ADIW	R28,2
    0292A 940C 3F54 JMP	pop_xgset003C
_ftochr:
  status               --> Y,+2
  j                    --> R12
  lenth                --> R20
  res                  --> R12
  i                    --> R10
  dest                 --> R14
  a                    --> Y,+12
    0292C 940E 3E2F CALL	push_arg4
    0292E 940E 3F76 CALL	push_xgset30FC
    02930 9724      SBIW	R28,4
    02931 88E8      LDD	R14,Y+16
    02932 88F9      LDD	R15,Y+17
(0279) }
(0280) ////////////////////////////////////////////
(0281) //				字符串转换函数
(0282) //   浮点 到  字符串
(0283) ////////////////////////////////////////////
(0284) void ftochr(float a,char * dest){//float
(0285) char i=0,j=0,lenth;
(0286) int status;
(0287) char *res;
(0288)  res=ftoa(a,&status);  //float to ascii
    02933 01CE      MOVW	R24,R28
    02934 9602      ADIW	R24,2
    02935 8399      STD	Y+1,R25
    02936 8388      ST	Y,R24
    02937 850C      LDD	R16,Y+12
    02938 851D      LDD	R17,Y+13
    02939 852E      LDD	R18,Y+14
    0293A 853F      LDD	R19,Y+15
    0293B 940E 43C9 CALL	_ftoa
    0293D 0168      MOVW	R12,R16
(0289) lenth=strlen(res);
    0293E 940E 3E23 CALL	_strlen
    02940 2F40      MOV	R20,R16
(0290) 
(0291) for(i=0;i <lenth;i++) 
    02941 24AA      CLR	R10
    02942 C023      RJMP	0x2966
(0292)        {
(0293) 	   	dest[i]=res[i];
    02943 2DEA      MOV	R30,R10
    02944 27FF      CLR	R31
    02945 0DEC      ADD	R30,R12
    02946 1DFD      ADC	R31,R13
    02947 8020      LD	R2,Z
    02948 2DEA      MOV	R30,R10
    02949 27FF      CLR	R31
    0294A 0DEE      ADD	R30,R14
    0294B 1DFF      ADC	R31,R15
    0294C 8220      ST	Z,R2
(0294) 
(0295) 		if( res[i]=='.'  ) 
    0294D 2DEA      MOV	R30,R10
    0294E 27FF      CLR	R31
    0294F 0DEC      ADD	R30,R12
    02950 1DFD      ADC	R31,R13
    02951 8180      LD	R24,Z
    02952 328E      CPI	R24,0x2E
    02953 F489      BNE	0x2965
(0296) 			{
(0297) 				dest[i+1]=res[i+1];
    02954 2DEA      MOV	R30,R10
    02955 27FF      CLR	R31
    02956 0DEC      ADD	R30,R12
    02957 1DFD      ADC	R31,R13
    02958 8021      LDD	R2,Z+1
    02959 2DEA      MOV	R30,R10
    0295A 27FF      CLR	R31
    0295B 0DEE      ADD	R30,R14
    0295C 1DFF      ADC	R31,R15
    0295D 8221      STD	Z+1,R2
(0298) 					dest[i+2]='\0';
    0295E 2DEA      MOV	R30,R10
    0295F 27FF      CLR	R31
    02960 0DEE      ADD	R30,R14
    02961 1DFF      ADC	R31,R15
    02962 2422      CLR	R2
    02963 8222      STD	Z+2,R2
(0299) 						return ;    
    02964 C003      RJMP	0x2968
    02965 94A3      INC	R10
    02966 16A4      CP	R10,R20
    02967 F2D8      BCS	0x2943
    02968 9624      ADIW	R28,4
    02969 940E 3F60 CALL	pop_xgset30FC
    0296B 9624      ADIW	R28,4
    0296C 9508      RET
_itochr:
  dest                 --> R10
  a                    --> R12
    0296D 940E 3F7A CALL	push_xgset003C
    0296F 0159      MOVW	R10,R18
    02970 0168      MOVW	R12,R16
    02971 9722      SBIW	R28,2
(0300) 		    }
(0301)  
(0302)  		}
(0303) }
(0304) //////////////////////////////////////////////////////
(0305) //              整型数据变字符串
(0306) //    a  到  dest
(0307) ///////////////////////////////////////////////////////
(0308) void itochr(int a,char * dest){ //int to ascii
(0309) 	 itoa(dest,a,10); 
    02972 E08A      LDI	R24,0xA
    02973 E090      LDI	R25,0
    02974 8399      STD	Y+1,R25
    02975 8388      ST	Y,R24
    02976 0196      MOVW	R18,R12
    02977 0185      MOVW	R16,R10
    02978 940E 42A6 CALL	_itoa
    0297A 9622      ADIW	R28,2
    0297B 940C 3F54 JMP	pop_xgset003C
_StructToChar:
  otherbyte            --> Y,+16
  ary                  --> Y,+0
  i                    --> R10
    0297D 92AA      ST	-Y,R10
    0297E 9768      SBIW	R28,0x18
(0310) }
(0311) //////////////////////////////////////////////////////
(0312) //                  结构体 变字符串
(0313) // 将目前存于结构体的数据转换到Temp_Char中。
(0314) ///////////////////////////////////////////////////////
(0315) void  StructToChar(void)
(0316) { 
(0317)   unsigned char i;
(0318)   char otherbyte[]="0\t0\t0\t0";
    0297F EB80      LDI	R24,0xB0
    02980 E091      LDI	R25,1
    02981 01FE      MOVW	R30,R28
    02982 9670      ADIW	R30,0x10
    02983 E008      LDI	R16,0x8
    02984 E010      LDI	R17,0
    02985 93FA      ST	-Y,R31
    02986 93EA      ST	-Y,R30
    02987 939A      ST	-Y,R25
    02988 938A      ST	-Y,R24
    02989 940E 401B CALL	asgnblk
(0319)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    0298B EB88      LDI	R24,0xB8
    0298C E091      LDI	R25,1
    0298D 01FE      MOVW	R30,R28
    0298E E100      LDI	R16,0x10
    0298F E010      LDI	R17,0
    02990 93FA      ST	-Y,R31
    02991 93EA      ST	-Y,R30
    02992 939A      ST	-Y,R25
    02993 938A      ST	-Y,R24
    02994 940E 401B CALL	asgnblk
(0320)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0321) 				Result.TeqChar
(0322) 			   };  //指向数组首地址的指针
(0323)   //strcat(Temp_Char,Result.Name);
(0324)   for(i=0;i<=80;i++) TempChar[i]='\0';  //清空数组
    02996 24AA      CLR	R10
    02997 C009      RJMP	0x29A1
    02998 EF88      LDI	R24,0xF8
    02999 E094      LDI	R25,4
    0299A 2DEA      MOV	R30,R10
    0299B 27FF      CLR	R31
    0299C 0FE8      ADD	R30,R24
    0299D 1FF9      ADC	R31,R25
    0299E 2422      CLR	R2
    0299F 8220      ST	Z,R2
    029A0 94A3      INC	R10
    029A1 E580      LDI	R24,0x50
    029A2 158A      CP	R24,R10
    029A3 F7A0      BCC	0x2998
(0325)     for(i=0;i<=7;i++){
    029A4 24AA      CLR	R10
    029A5 C014      RJMP	0x29BA
(0326) 		strcat(TempChar,ary[i]);  // 按顺序复制字符串
    029A6 01CE      MOVW	R24,R28
    029A7 2DEA      MOV	R30,R10
    029A8 27FF      CLR	R31
    029A9 0FEE      LSL	R30
    029AA 1FFF      ROL	R31
    029AB 0FE8      ADD	R30,R24
    029AC 1FF9      ADC	R31,R25
    029AD 8120      LD	R18,Z
    029AE 8131      LDD	R19,Z+1
    029AF EF08      LDI	R16,0xF8
    029B0 E014      LDI	R17,4
    029B1 940E 3E16 CALL	_strcat
(0327) 		strcat(TempChar,tab);     // 字串结尾加上制表符
    029B3 E02F      LDI	R18,0xF
    029B4 E031      LDI	R19,1
    029B5 EF08      LDI	R16,0xF8
    029B6 E014      LDI	R17,4
    029B7 940E 3E16 CALL	_strcat
    029B9 94A3      INC	R10
    029BA E087      LDI	R24,7
    029BB 158A      CP	R24,R10
    029BC F748      BCC	0x29A6
(0328)     }
(0329) 				 
(0330) 				 otherbyte[0]=otherbyte[0]+Result.WeiHai;
    029BD 9020 05A2 LDS	R2,Result+90
    029BF 8838      LDD	R3,Y+16
    029C0 0C32      ADD	R3,R2
    029C1 8A38      STD	Y+16,R3
(0331) 				 otherbyte[2]=otherbyte[0]+Result.LowLabor;
    029C2 9020 05A3 LDS	R2,Result+91
    029C4 0C32      ADD	R3,R2
    029C5 8A3A      STD	Y+18,R3
(0332) 				 otherbyte[4]=otherbyte[0]+Result.MidLabor;
    029C6 9020 05A4 LDS	R2,Result+92
    029C8 8838      LDD	R3,Y+16
    029C9 0C32      ADD	R3,R2
    029CA 8A3C      STD	Y+20,R3
(0333) 				 otherbyte[6]=otherbyte[0]+Result.HighLabor;
    029CB 9020 05A5 LDS	R2,Result+93
    029CD 8838      LDD	R3,Y+16
    029CE 0C32      ADD	R3,R2
    029CF 8A3E      STD	Y+22,R3
(0334)  
(0335)   strcat(TempChar,otherbyte);  
    029D0 019E      MOVW	R18,R28
    029D1 5F20      SUBI	R18,0xF0
    029D2 4F3F      SBCI	R19,0xFF
    029D3 EF08      LDI	R16,0xF8
    029D4 E014      LDI	R17,4
    029D5 940E 3E16 CALL	_strcat
(0336)   strcat(TempChar,enter);  
    029D7 E122      LDI	R18,0x12
    029D8 E031      LDI	R19,1
    029D9 EF08      LDI	R16,0xF8
    029DA E014      LDI	R17,4
    029DB 940E 3E16 CALL	_strcat
(0337)   strcat(TempChar,"\0\0");
    029DD ED2F      LDI	R18,0xDF
    029DE E031      LDI	R19,1
    029DF EF08      LDI	R16,0xF8
    029E0 E014      LDI	R17,4
    029E1 940E 3E16 CALL	_strcat
    029E3 9668      ADIW	R28,0x18
    029E4 90A9      LD	R10,Y+
    029E5 9508      RET
_CharToStruct:
  Temp_Char            --> Y,+16
  i                    --> R20
  ary                  --> Y,+0
  j                    --> R14
  p                    --> R10
  q                    --> R12
    029E6 940E 3F76 CALL	push_xgset30FC
    029E8 97EF      SBIW	R28,0x3F
    029E9 97A1      SBIW	R28,0x21
(0338) }
(0339) 
(0340) //////////////////////////////////////////////////////
(0341) //               字符串  变  结构体
(0342) // 
(0343) ///////////////////////////////////////////////////////
(0344) void CharToStruct(void)
(0345) {
(0346)   unsigned char i=0,j=0;
    029EA 2744      CLR	R20
    029EB 24EE      CLR	R14
(0347)   unsigned char *p,*q;
(0348)   char *(ary[])={Result.IndexChar,Result.Date,Result.Time,
    029EC EC88      LDI	R24,0xC8
    029ED E091      LDI	R25,1
    029EE 01FE      MOVW	R30,R28
    029EF E100      LDI	R16,0x10
    029F0 E010      LDI	R17,0
    029F1 93FA      ST	-Y,R31
    029F2 93EA      ST	-Y,R30
    029F3 939A      ST	-Y,R25
    029F4 938A      ST	-Y,R24
    029F5 940E 401B CALL	asgnblk
(0349)  	  			Result.TempChar,Result.WSChar,Result.WCIChar,Result.ECTChar,
(0350) 				Result.TeqChar
(0351) 			   };  //指向数组首地址的指针
(0352)   char Temp_Char[80];
(0353)     p=ary[j];
    029F7 01CE      MOVW	R24,R28
    029F8 2DEE      MOV	R30,R14
    029F9 27FF      CLR	R31
    029FA 0FEE      LSL	R30
    029FB 1FFF      ROL	R31
    029FC 0FE8      ADD	R30,R24
    029FD 1FF9      ADC	R31,R25
    029FE 80A0      LD	R10,Z
    029FF 80B1      LDD	R11,Z+1
(0354) 	q=Temp_Char;
    02A00 01CE      MOVW	R24,R28
    02A01 9640      ADIW	R24,0x10
    02A02 016C      MOVW	R12,R24
    02A03 C01D      RJMP	0x2A21
(0355) 	while(1){
(0356)     if(*q =='\n') {*p='\0'; return;} ;
    02A04 01F6      MOVW	R30,R12
    02A05 8180      LD	R24,Z
    02A06 308A      CPI	R24,0xA
    02A07 F421      BNE	0x2A0C
    02A08 2422      CLR	R2
    02A09 01F5      MOVW	R30,R10
    02A0A 8220      ST	Z,R2
    02A0B C016      RJMP	0x2A22
(0357) 	if(*q =='\t') {j++;p=ary[j];i=0;}
    02A0C 01F6      MOVW	R30,R12
    02A0D 8180      LD	R24,Z
    02A0E 3089      CPI	R24,0x9
    02A0F F459      BNE	0x2A1B
    02A10 94E3      INC	R14
    02A11 01CE      MOVW	R24,R28
    02A12 2DEE      MOV	R30,R14
    02A13 27FF      CLR	R31
    02A14 0FEE      LSL	R30
    02A15 1FFF      ROL	R31
    02A16 0FE8      ADD	R30,R24
    02A17 1FF9      ADC	R31,R25
    02A18 80A0      LD	R10,Z
    02A19 80B1      LDD	R11,Z+1
    02A1A 2744      CLR	R20
(0358)     *p++=*q++;
    02A1B 01F6      MOVW	R30,R12
    02A1C 01D5      MOVW	R26,R10
    02A1D 9001      LD	R0,Z+
    02A1E 016F      MOVW	R12,R30
    02A1F 920D      ST	X+,R0
    02A20 015D      MOVW	R10,R26
    02A21 CFE2      RJMP	0x2A04
    02A22 96EF      ADIW	R28,0x3F
    02A23 96A1      ADIW	R28,0x21
    02A24 940C 3F60 JMP	pop_xgset30FC
_get_name:
  i                    --> R20
  filenamep            --> R16
    02A26 940E 3F89 CALL	push_xgsetF000
(0359) 	}
(0360)   }
(0361)  
(0362)  ////////////////////////////////////////////
(0363) //				根据当前日期获取文件名
(0364) //   
(0365) ////////////////////////////////////////////
(0366) char *get_name( char filenamep[] ){     
(0367) 	  unsigned char i=0;
(0368)  	  for(i=0;i<6;i++) {
    02A28 2744      CLR	R20
    02A29 C00D      RJMP	0x2A37
(0369) 	  				    *(filenamep+i)=Result.Date[i];
    02A2A E58E      LDI	R24,0x5E
    02A2B E095      LDI	R25,5
    02A2C 2FE4      MOV	R30,R20
    02A2D 27FF      CLR	R31
    02A2E 0FE8      ADD	R30,R24
    02A2F 1FF9      ADC	R31,R25
    02A30 8020      LD	R2,Z
    02A31 2FE4      MOV	R30,R20
    02A32 27FF      CLR	R31
    02A33 0FE0      ADD	R30,R16
    02A34 1FF1      ADC	R31,R17
    02A35 8220      ST	Z,R2
    02A36 9543      INC	R20
    02A37 3046      CPI	R20,6
    02A38 F388      BCS	0x2A2A
(0370) 	  				   } 
(0371) 	 	*(filenamep+(i++))='.';
    02A39 2E24      MOV	R2,R20
    02A3A 2433      CLR	R3
    02A3B 5F4F      SUBI	R20,0xFF
    02A3C 2DE2      MOV	R30,R2
    02A3D 27FF      CLR	R31
    02A3E 0FE0      ADD	R30,R16
    02A3F 1FF1      ADC	R31,R17
    02A40 E28E      LDI	R24,0x2E
    02A41 8380      ST	Z,R24
(0372) 		*(filenamep+(i++))='x';
    02A42 2E24      MOV	R2,R20
    02A43 2433      CLR	R3
    02A44 5F4F      SUBI	R20,0xFF
    02A45 2DE2      MOV	R30,R2
    02A46 27FF      CLR	R31
    02A47 0FE0      ADD	R30,R16
    02A48 1FF1      ADC	R31,R17
    02A49 E788      LDI	R24,0x78
    02A4A 8380      ST	Z,R24
(0373) 		*(filenamep+(i++))='l';
    02A4B 2F64      MOV	R22,R20
    02A4C 2777      CLR	R23
    02A4D 5F4F      SUBI	R20,0xFF
    02A4E 2FE6      MOV	R30,R22
    02A4F 27FF      CLR	R31
    02A50 0FE0      ADD	R30,R16
    02A51 1FF1      ADC	R31,R17
    02A52 E68C      LDI	R24,0x6C
    02A53 8380      ST	Z,R24
(0374) 		*(filenamep+(i++))='s';
    02A54 2F64      MOV	R22,R20
    02A55 2777      CLR	R23
    02A56 5F4F      SUBI	R20,0xFF
    02A57 2FE6      MOV	R30,R22
    02A58 27FF      CLR	R31
    02A59 0FE0      ADD	R30,R16
    02A5A 1FF1      ADC	R31,R17
    02A5B E783      LDI	R24,0x73
    02A5C 8380      ST	Z,R24
(0375) 		*(filenamep+(i))='\0';
    02A5D 2FE4      MOV	R30,R20
    02A5E 27FF      CLR	R31
    02A5F 0FE0      ADD	R30,R16
    02A60 1FF1      ADC	R31,R17
    02A61 2422      CLR	R2
    02A62 8220      ST	Z,R2
(0376) 					   
(0377)       return filenamep;
    02A63 940C 3F8E JMP	pop_xgsetF000
_SquareRootFloat:
  f                    --> Y,+12
  x                    --> Y,+8
  i                    --> Y,+4
  y                    --> Y,+0
  number               --> Y,+20
    02A65 940E 3E2F CALL	push_arg4
    02A67 940E 3F89 CALL	push_xgsetF000
    02A69 9760      SBIW	R28,0x10
(0378) } 
(0379) float SquareRootFloat(float number)
(0380) {
(0381)     long i;
(0382)     float x, y;
(0383)     const float f = 1.5F;
    02A6A E900      LDI	R16,0x90
    02A6B E010      LDI	R17,0
    02A6C 940E 3EFC CALL	elpm32
    02A6E 870C      STD	Y+12,R16
    02A6F 871D      STD	Y+13,R17
    02A70 872E      STD	Y+14,R18
    02A71 873F      STD	Y+15,R19
(0384)     x = number * 0.5F;
    02A72 E80C      LDI	R16,0x8C
    02A73 E010      LDI	R17,0
    02A74 940E 3EFC CALL	elpm32
    02A76 01CE      MOVW	R24,R28
    02A77 9644      ADIW	R24,0x14
    02A78 939A      ST	-Y,R25
    02A79 938A      ST	-Y,R24
    02A7A 940E 426B CALL	fpmule1
    02A7C 8708      STD	Y+8,R16
    02A7D 8719      STD	Y+9,R17
    02A7E 872A      STD	Y+10,R18
    02A7F 873B      STD	Y+11,R19
(0385)     y  = number;
    02A80 882C      LDD	R2,Y+20
    02A81 883D      LDD	R3,Y+21
    02A82 884E      LDD	R4,Y+22
    02A83 885F      LDD	R5,Y+23
    02A84 8228      ST	Y,R2
    02A85 8239      STD	Y+1,R3
    02A86 824A      STD	Y+2,R4
    02A87 825B      STD	Y+3,R5
(0386)     i  = * ( long * ) &y;
    02A88 01FE      MOVW	R30,R28
    02A89 8020      LD	R2,Z
    02A8A 8031      LDD	R3,Z+1
    02A8B 8042      LDD	R4,Z+2
    02A8C 8053      LDD	R5,Z+3
    02A8D 822C      STD	Y+4,R2
    02A8E 823D      STD	Y+5,R3
    02A8F 824E      STD	Y+6,R4
    02A90 825F      STD	Y+7,R5
(0387)     i  = 0x5f3759df - ( i >> 1 );  //卡马克
    02A91 802C      LDD	R2,Y+4
    02A92 803D      LDD	R3,Y+5
    02A93 804E      LDD	R4,Y+6
    02A94 805F      LDD	R5,Y+7
    02A95 9455      ASR	R5
    02A96 9447      ROR	R4
    02A97 9437      ROR	R3
    02A98 9427      ROR	R2
    02A99 ED4F      LDI	R20,0xDF
    02A9A E559      LDI	R21,0x59
    02A9B E367      LDI	R22,0x37
    02A9C E57F      LDI	R23,0x5F
    02A9D 1942      SUB	R20,R2
    02A9E 0953      SBC	R21,R3
    02A9F 0964      SBC	R22,R4
    02AA0 0975      SBC	R23,R5
    02AA1 834C      STD	Y+4,R20
    02AA2 835D      STD	Y+5,R21
    02AA3 836E      STD	Y+6,R22
    02AA4 837F      STD	Y+7,R23
(0388)   //i  = 0x5f375a86 - ( i >> 1 );  //Lomont
(0389)     y  = * ( float * ) &i;
    02AA5 01FE      MOVW	R30,R28
    02AA6 9634      ADIW	R30,4
    02AA7 8020      LD	R2,Z
    02AA8 8031      LDD	R3,Z+1
    02AA9 8042      LDD	R4,Z+2
    02AAA 8053      LDD	R5,Z+3
    02AAB 8228      ST	Y,R2
    02AAC 8239      STD	Y+1,R3
    02AAD 824A      STD	Y+2,R4
    02AAE 825B      STD	Y+3,R5
(0390)     y  = y * ( f - ( x * y * y ) );
    02AAF 8028      LD	R2,Y
    02AB0 8039      LDD	R3,Y+1
    02AB1 804A      LDD	R4,Y+2
    02AB2 805B      LDD	R5,Y+3
    02AB3 846C      LDD	R6,Y+12
    02AB4 847D      LDD	R7,Y+13
    02AB5 848E      LDD	R8,Y+14
    02AB6 849F      LDD	R9,Y+15
    02AB7 8508      LDD	R16,Y+8
    02AB8 8519      LDD	R17,Y+9
    02AB9 852A      LDD	R18,Y+10
    02ABA 853B      LDD	R19,Y+11
    02ABB 01CE      MOVW	R24,R28
    02ABC 939A      ST	-Y,R25
    02ABD 938A      ST	-Y,R24
    02ABE 940E 426B CALL	fpmule1
    02AC0 01CE      MOVW	R24,R28
    02AC1 939A      ST	-Y,R25
    02AC2 938A      ST	-Y,R24
    02AC3 940E 4280 CALL	fpmule1x
    02AC5 0183      MOVW	R16,R6
    02AC6 0194      MOVW	R18,R8
    02AC7 940E 40C0 CALL	fpsub2x
    02AC9 0181      MOVW	R16,R2
    02ACA 0192      MOVW	R18,R4
    02ACB 940E 4275 CALL	fpmule2
    02ACD 8308      ST	Y,R16
    02ACE 8319      STD	Y+1,R17
    02ACF 832A      STD	Y+2,R18
    02AD0 833B      STD	Y+3,R19
(0391)     y  = y * ( f - ( x * y * y ) );
    02AD1 8028      LD	R2,Y
    02AD2 8039      LDD	R3,Y+1
    02AD3 804A      LDD	R4,Y+2
    02AD4 805B      LDD	R5,Y+3
    02AD5 846C      LDD	R6,Y+12
    02AD6 847D      LDD	R7,Y+13
    02AD7 848E      LDD	R8,Y+14
    02AD8 849F      LDD	R9,Y+15
    02AD9 8508      LDD	R16,Y+8
    02ADA 8519      LDD	R17,Y+9
    02ADB 852A      LDD	R18,Y+10
    02ADC 853B      LDD	R19,Y+11
    02ADD 01CE      MOVW	R24,R28
    02ADE 939A      ST	-Y,R25
    02ADF 938A      ST	-Y,R24
    02AE0 940E 426B CALL	fpmule1
    02AE2 01CE      MOVW	R24,R28
    02AE3 939A      ST	-Y,R25
    02AE4 938A      ST	-Y,R24
    02AE5 940E 4280 CALL	fpmule1x
    02AE7 0183      MOVW	R16,R6
    02AE8 0194      MOVW	R18,R8
    02AE9 940E 40C0 CALL	fpsub2x
    02AEB 0181      MOVW	R16,R2
    02AEC 0192      MOVW	R18,R4
    02AED 940E 4275 CALL	fpmule2
    02AEF 8308      ST	Y,R16
    02AF0 8319      STD	Y+1,R17
    02AF1 832A      STD	Y+2,R18
    02AF2 833B      STD	Y+3,R19
(0392)     return number * y;
    02AF3 890C      LDD	R16,Y+20
    02AF4 891D      LDD	R17,Y+21
    02AF5 892E      LDD	R18,Y+22
    02AF6 893F      LDD	R19,Y+23
    02AF7 01CE      MOVW	R24,R28
    02AF8 939A      ST	-Y,R25
    02AF9 938A      ST	-Y,R24
    02AFA 940E 426B CALL	fpmule1
    02AFC 9660      ADIW	R28,0x10
    02AFD 940E 3F8E CALL	pop_xgsetF000
    02AFF 9624      ADIW	R28,4
    02B00 9508      RET
_debug:
  str2                 --> Y,+0
  val                  --> R10
  str                  --> R12
    02B01 940E 3F7A CALL	push_xgset003C
    02B03 2EA2      MOV	R10,R18
    02B04 0168      MOVW	R12,R16
    02B05 9724      SBIW	R28,4
(0393) } 
(0394) //
(0395) //###############################################################//
(0396) //debug
(0397) void debug(UINT8 *str,UINT8 val)
(0398) {
(0399)  UINT8 str2[4]={0,0,0,0};
    02B06 ED88      LDI	R24,0xD8
    02B07 E091      LDI	R25,1
    02B08 01FE      MOVW	R30,R28
    02B09 E004      LDI	R16,4
    02B0A E010      LDI	R17,0
    02B0B 93FA      ST	-Y,R31
    02B0C 93EA      ST	-Y,R30
    02B0D 939A      ST	-Y,R25
    02B0E 938A      ST	-Y,R24
    02B0F 940E 401B CALL	asgnblk
(0400)  str=str;
(0401)  val=val;
(0402)  #ifdef _UARTDEBUG
(0403)  PrintString("\r\n");
    02B11 ED0C      LDI	R16,0xDC
    02B12 E011      LDI	R17,1
    02B13 940E 3605 CALL	_PrintString
(0404)  PrintString(str);
    02B15 0186      MOVW	R16,R12
    02B16 940E 3605 CALL	_PrintString
(0405)  PrintChar(val);
    02B18 2D0A      MOV	R16,R10
    02B19 940E 376F CALL	_PrintChar
    02B1B 9624      ADIW	R28,4
    02B1C 940C 3F54 JMP	pop_xgset003C
_SD_Write_cmd:
  k                    --> R22
  temp                 --> R20
  p                    --> R20
    02B1E 940E 3F89 CALL	push_xgsetF000
    02B20 01A8      MOVW	R20,R16
FILE: D:\LQD\software\master\software_src\sd.c
(0001) //*****************************************************************************//
(0002) //*								数码相框
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SD卡控制
(0006) //*修改者：  桃子
(0007) //*****************************************************************************//
(0008) #include "sd.h"
(0009) 
(0010) //****************************************************************
(0011) //*隶属模块：SD卡控制
(0012) //*函数功能：写6字节数据
(0013) //****************************************************************
(0014) UINT8 SD_Write_cmd(UINT8 *p)
(0015) {	
(0016) 	UINT16 temp,k=0;
    02B21 2766      CLR	R22
    02B22 2777      CLR	R23
(0017) 	SD_CS_DIS();//禁止SPI
    02B23 9AC0      SBI	0x18,0
(0018) 	SPI_Read();//空读一字节
    02B24 940E 379D CALL	_SPI_Read
(0019) 	SD_CS_EN();//使能SPI
    02B26 98C0      CBI	0x18,0
(0020) 
(0021) 	SPI_Write(p[0]);
    02B27 01FA      MOVW	R30,R20
    02B28 8100      LD	R16,Z
    02B29 940E 3799 CALL	_SPI_Write
(0022) 	SPI_Write(p[1]);
    02B2B 01FA      MOVW	R30,R20
    02B2C 8101      LDD	R16,Z+1
    02B2D 940E 3799 CALL	_SPI_Write
(0023) 	SPI_Write(p[2]);
    02B2F 01FA      MOVW	R30,R20
    02B30 8102      LDD	R16,Z+2
    02B31 940E 3799 CALL	_SPI_Write
(0024) 	SPI_Write(p[3]);
    02B33 01FA      MOVW	R30,R20
    02B34 8103      LDD	R16,Z+3
    02B35 940E 3799 CALL	_SPI_Write
(0025) 	SPI_Write(p[4]);
    02B37 01FA      MOVW	R30,R20
    02B38 8104      LDD	R16,Z+4
    02B39 940E 3799 CALL	_SPI_Write
(0026) 	SPI_Write(p[5]);
    02B3B 01FA      MOVW	R30,R20
    02B3C 8105      LDD	R16,Z+5
    02B3D 940E 3799 CALL	_SPI_Write
(0027) 
(0028) 	do 
(0029)  	{  
(0030)   		temp = SPI_Read();//一直读，直到读到的不是0xff或超时
    02B3F 940E 379D CALL	_SPI_Read
    02B41 2F40      MOV	R20,R16
    02B42 2755      CLR	R21
(0031)  		k++;
    02B43 5F6F      SUBI	R22,0xFF
    02B44 4F7F      SBCI	R23,0xFF
(0032)  	}while((temp==0xff)&&(k<TRY_TIME)); 
    02B45 3F4F      CPI	R20,0xFF
    02B46 E0E0      LDI	R30,0
    02B47 075E      CPC	R21,R30
    02B48 F421      BNE	0x2B4D
    02B49 3164      CPI	R22,0x14
    02B4A E0E0      LDI	R30,0
    02B4B 077E      CPC	R23,R30
    02B4C F390      BCS	0x2B3F
(0033) 
(0034) 	return temp;
    02B4D 2F04      MOV	R16,R20
    02B4E 940C 3F8E JMP	pop_xgsetF000
_SD_Init:
  pcmd                 --> Y,+0
  temp                 --> R22
  time                 --> R20
    02B50 940E 3F93 CALL	push_xgsetF00C
    02B52 9726      SBIW	R28,6
(0035) }
(0036) //****************************************************************
(0037) //*隶属模块：SD卡控制
(0038) //*函数功能：初始化
(0039) //****************************************************************
(0040) UINT8 SD_Init(void)	
(0041) {  
(0042) 	UINT8 time=0,temp=0;
    02B53 2744      CLR	R20
    02B54 2766      CLR	R22
(0043) 	UINT8 pcmd[] = {0x40,0x00,0x00,0x00,0x00,0x95}; //命令0的字节序列
    02B55 E48A      LDI	R24,0x4A
    02B56 E092      LDI	R25,2
    02B57 01FE      MOVW	R30,R28
    02B58 E006      LDI	R16,6
    02B59 E010      LDI	R17,0
    02B5A 93FA      ST	-Y,R31
    02B5B 93EA      ST	-Y,R30
    02B5C 939A      ST	-Y,R25
    02B5D 938A      ST	-Y,R24
    02B5E 940E 401B CALL	asgnblk
(0044) 	if(SD_DET()==0) return 0x02; //no disk
    02B60 B181      IN	R24,0x01
    02B61 9586      LSR	R24
    02B62 9586      LSR	R24
    02B63 9586      LSR	R24
    02B64 9586      LSR	R24
    02B65 9586      LSR	R24
    02B66 7081      ANDI	R24,1
    02B67 F421      BNE	0x2B6C
    02B68 E081      LDI	R24,1
    02B69 E090      LDI	R25,0
    02B6A 015C      MOVW	R10,R24
    02B6B C002      RJMP	0x2B6E
    02B6C 24AA      CLR	R10
    02B6D 24BB      CLR	R11
    02B6E 20AA      TST	R10
    02B6F F421      BNE	0x2B74
    02B70 20BB      TST	R11
    02B71 F411      BNE	0x2B74
    02B72 E002      LDI	R16,2
    02B73 C039      RJMP	0x2BAD
(0045) 	SD_PORT |= (1<<SD_CS);
    02B74 9AC0      SBI	0x18,0
(0046) 	SD_DDR |= (1<<SD_CS);
    02B75 9AB8      SBI	0x17,0
(0047) 
(0048) 	SPI_IO_Init();
    02B76 940E 378F CALL	_SPI_IO_Init
(0049) 	SPI_Low();
    02B78 E582      LDI	R24,0x52
    02B79 B98D      OUT	0x0D,R24
    02B7A B18E      IN	R24,0x0E
    02B7B 7F8F      ANDI	R24,0xFF
    02B7C B98E      OUT	0x0E,R24
(0050) 
(0051) 	SD_CS_DIS();  //关闭片选 
    02B7D 9AC0      SBI	0x18,0
(0052) 	for(time=0;time<10;time++) //初始时，首先要发送最少74个时钟信号，这是必须的！！！
    02B7E 2744      CLR	R20
    02B7F C003      RJMP	0x2B83
(0053) 	{
(0054)   		SPI_Read(); 
    02B80 940E 379D CALL	_SPI_Read
    02B82 9543      INC	R20
    02B83 304A      CPI	R20,0xA
    02B84 F3D8      BCS	0x2B80
(0055) 	}
(0056) 	SD_CS_EN(); //打开片选
    02B85 98C0      CBI	0x18,0
(0057) 	time = 0;
    02B86 2744      CLR	R20
(0058) 	do
(0059) 	{ 
(0060) 		temp=SD_Write_cmd(pcmd);//写入CMD0
    02B87 018E      MOVW	R16,R28
    02B88 DF95      RCALL	_SD_Write_cmd
    02B89 2F60      MOV	R22,R16
(0061) 	 	time++;
    02B8A 9543      INC	R20
(0062) 	 	if(time==TRY_TIME) 
    02B8B 3144      CPI	R20,0x14
    02B8C F419      BNE	0x2B90
(0063) 	 	{ 
(0064) 	  		SD_CS_DIS(); //关闭片选
    02B8D 9AC0      SBI	0x18,0
(0065) 	  		return(INIT_CMD0_ERROR);//CMD0写入失败
    02B8E E001      LDI	R16,1
    02B8F C01D      RJMP	0x2BAD
(0066) 	 	}
(0067) 	 }while(temp!=0x01);
    02B90 3061      CPI	R22,1
    02B91 F7A9      BNE	0x2B87
(0068) 
(0069) 	SD_CS_DIS(); //关闭片选
    02B92 9AC0      SBI	0x18,0
(0070) 	SPI_Read(); //按照SD卡的操作时序在这里补8个时钟 
    02B93 940E 379D CALL	_SPI_Read
(0071) 	SD_CS_EN(); //打开片选
    02B95 98C0      CBI	0x18,0
(0072) 
(0073) 	pcmd[0]=0x41,pcmd[5]=0xff;
    02B96 E481      LDI	R24,0x41
    02B97 8388      ST	Y,R24
    02B98 EF8F      LDI	R24,0xFF
    02B99 838D      STD	Y+5,R24
(0074) 	time = 0;
    02B9A 2744      CLR	R20
(0075) 	do
(0076) 	{ 
(0077) 		temp=SD_Write_cmd(pcmd);
    02B9B 018E      MOVW	R16,R28
    02B9C DF81      RCALL	_SD_Write_cmd
    02B9D 2F60      MOV	R22,R16
(0078) 		time++;
    02B9E 9543      INC	R20
(0079) 		if(time==TRY_TIME) 
    02B9F 3144      CPI	R20,0x14
    02BA0 F419      BNE	0x2BA4
(0080) 		{ 
(0081) 		 	SD_CS_DIS(); //关闭片选
    02BA1 9AC0      SBI	0x18,0
(0082) 			 return(INIT_CMD1_ERROR);//CMD1写入失败
    02BA2 E002      LDI	R16,2
    02BA3 C009      RJMP	0x2BAD
(0083) 		 }
(0084) 	 }while(temp!=0);
    02BA4 2366      TST	R22
    02BA5 F7A9      BNE	0x2B9B
(0085)   
(0086) 	 SPI_High();  
    02BA6 E580      LDI	R24,0x50
    02BA7 B98D      OUT	0x0D,R24
    02BA8 9A70      SBI	0x0E,0
(0087) 	 SD_CS_DIS();  //关闭片选 
    02BA9 9AC0      SBI	0x18,0
(0088) 	 SPI_Read(); //按照SD卡的操作时序在这里补8个时钟
    02BAA 940E 379D CALL	_SPI_Read
(0089) 	 return SD_TURE; //返回0,说明初始化操作成功
    02BAC 2700      CLR	R16
    02BAD 9626      ADIW	R28,6
    02BAE 940C 3F9A JMP	pop_xgsetF00C
_SD_Write_Sector:
  pcmd                 --> Y,+0
  time                 --> R12
  temp                 --> R20
  i                    --> R22
  buffer               --> R10
  addr                 --> Y,+14
    02BB0 940E 3E2F CALL	push_arg4
    02BB2 940E 3FAF CALL	push_xgsetF03C
    02BB4 9726      SBIW	R28,6
    02BB5 88AA      LDD	R10,Y+18
    02BB6 88BB      LDD	R11,Y+19
(0090) } 
(0091) //****************************************************************
(0092) //*隶属模块：SD卡控制
(0093) //*函数功能：写512字节数据（一扇区字节）
(0094) //****************************************************************
(0095) UINT16 SD_Write_Sector(UINT32 addr,UINT8 *buffer)
(0096) {  
(0097) 	UINT8 temp=0,time=0;
    02BB7 2744      CLR	R20
    02BB8 24CC      CLR	R12
(0098) 	UINT16 i=0;
    02BB9 2766      CLR	R22
    02BBA 2777      CLR	R23
(0099) 	UINT8 pcmd[] = {0x58,0x00,0x00,0x00,0x00,0xff}; //向SD卡中单个块（512字节，一个扇区）写入数据，用CMD24
    02BBB E580      LDI	R24,0x50
    02BBC E092      LDI	R25,2
    02BBD 01FE      MOVW	R30,R28
    02BBE E006      LDI	R16,6
    02BBF E010      LDI	R17,0
    02BC0 93FA      ST	-Y,R31
    02BC1 93EA      ST	-Y,R30
    02BC2 939A      ST	-Y,R25
    02BC3 938A      ST	-Y,R24
    02BC4 940E 401B CALL	asgnblk
(0100) 
(0101) 	 addr<<=9; //将块地址（扇区地址）转为字节地址 ［这里就限制了SD卡的最大容量为4G］
    02BC6 E089      LDI	R24,0x9
    02BC7 E090      LDI	R25,0
    02BC8 850E      LDD	R16,Y+14
    02BC9 851F      LDD	R17,Y+15
    02BCA 8928      LDD	R18,Y+16
    02BCB 8939      LDD	R19,Y+17
    02BCC 938A      ST	-Y,R24
    02BCD 940E 3FF6 CALL	lsl32
    02BCF 870E      STD	Y+14,R16
    02BD0 871F      STD	Y+15,R17
    02BD1 8B28      STD	Y+16,R18
    02BD2 8B39      STD	Y+17,R19
(0102) 
(0103) 	 pcmd[1]=(addr>>24); //将字节地址写入到CMD24字节序列中
    02BD3 E188      LDI	R24,0x18
    02BD4 E090      LDI	R25,0
    02BD5 850E      LDD	R16,Y+14
    02BD6 851F      LDD	R17,Y+15
    02BD7 8928      LDD	R18,Y+16
    02BD8 8939      LDD	R19,Y+17
    02BD9 938A      ST	-Y,R24
    02BDA 940E 400F CALL	lsr32
    02BDC 8309      STD	Y+1,R16
(0104) 	 pcmd[2]=(addr>>16);
    02BDD 842E      LDD	R2,Y+14
    02BDE 843F      LDD	R3,Y+15
    02BDF 8848      LDD	R4,Y+16
    02BE0 8859      LDD	R5,Y+17
    02BE1 0112      MOVW	R2,R4
    02BE2 2444      CLR	R4
    02BE3 2455      CLR	R5
    02BE4 822A      STD	Y+2,R2
(0105) 	 pcmd[3]=(addr>>8);
    02BE5 E088      LDI	R24,0x8
    02BE6 E090      LDI	R25,0
    02BE7 850E      LDD	R16,Y+14
    02BE8 851F      LDD	R17,Y+15
    02BE9 8928      LDD	R18,Y+16
    02BEA 8939      LDD	R19,Y+17
    02BEB 938A      ST	-Y,R24
    02BEC 940E 400F CALL	lsr32
    02BEE 830B      STD	Y+3,R16
(0106) 	// pcmd[4]=offset;	
(0107) 	 SD_CS_EN();//打开SD卡片选
    02BEF 98C0      CBI	0x18,0
(0108) 
(0109) 	 do
(0110) 	 {  
(0111) 		temp=SD_Write_cmd(pcmd);
    02BF0 018E      MOVW	R16,R28
    02BF1 DF2C      RCALL	_SD_Write_cmd
    02BF2 2F40      MOV	R20,R16
(0112)   		time++;
    02BF3 94C3      INC	R12
(0113)   		if(time==TRY_TIME) 
    02BF4 2D8C      MOV	R24,R12
    02BF5 3184      CPI	R24,0x14
    02BF6 F419      BNE	0x2BFA
(0114)   		{ 
(0115)    			SD_CS_DIS(); //关闭片选
    02BF7 9AC0      SBI	0x18,0
(0116)    			return(temp); //命令写入失败
    02BF8 2711      CLR	R17
    02BF9 C037      RJMP	0x2C31
(0117)   		}
(0118) 	}while(temp!=0); 
    02BFA 2344      TST	R20
    02BFB F7A1      BNE	0x2BF0
(0119) 
(0120) 	for(i=0;i<100;i++) //这里要插入若干时钟信号
    02BFC 2766      CLR	R22
    02BFD 2777      CLR	R23
    02BFE C004      RJMP	0x2C03
(0121)   		SPI_Read();
    02BFF 940E 379D CALL	_SPI_Read
    02C01 5F6F      SUBI	R22,0xFF
    02C02 4F7F      SBCI	R23,0xFF
    02C03 3664      CPI	R22,0x64
    02C04 E0E0      LDI	R30,0
    02C05 077E      CPC	R23,R30
    02C06 F3C0      BCS	0x2BFF
(0122) 	
(0123) 	SPI_Write(0xfe);//写入开始字节 0xfe，后面就是要写入的512个字节的数据	
    02C07 EF0E      LDI	R16,0xFE
    02C08 940E 3799 CALL	_SPI_Write
(0124) 	
(0125) 	for(i=0;i<512;i++) //将缓冲区中要写入的512个字节写入SD卡
    02C0A 2766      CLR	R22
    02C0B 2777      CLR	R23
    02C0C C007      RJMP	0x2C14
(0126) 		SPI_Write(*buffer++);
    02C0D 01F5      MOVW	R30,R10
    02C0E 9101      LD	R16,Z+
    02C0F 015F      MOVW	R10,R30
    02C10 940E 3799 CALL	_SPI_Write
    02C12 5F6F      SUBI	R22,0xFF
    02C13 4F7F      SBCI	R23,0xFF
    02C14 3060      CPI	R22,0
    02C15 E0E2      LDI	R30,2
    02C16 077E      CPC	R23,R30
    02C17 F3A8      BCS	0x2C0D
(0127)   
(0128) 	SPI_Read(); 
    02C18 940E 379D CALL	_SPI_Read
(0129) 	SPI_Read(); //两个字节的CRC校验码，不用关心
    02C1A 940E 379D CALL	_SPI_Read
(0130)    
(0131)     
(0132) 	temp=SPI_Read();   //读取返回值
    02C1C 940E 379D CALL	_SPI_Read
    02C1E 2F40      MOV	R20,R16
(0133) 	if((temp&0x1F)!=0x05) //如果返回值是 XXX00101说明数据已经被SD卡接受了
    02C1F 2F84      MOV	R24,R20
    02C20 718F      ANDI	R24,0x1F
    02C21 3085      CPI	R24,5
    02C22 F021      BEQ	0x2C27
(0134) 	{
(0135)  		SD_CS_DIS();
    02C23 9AC0      SBI	0x18,0
(0136)  		return(WRITE_BLOCK_ERROR); //写块数据失败
    02C24 E003      LDI	R16,3
    02C25 E010      LDI	R17,0
    02C26 C00A      RJMP	0x2C31
(0137) 	}
(0138)  
(0139) 	while(SPI_Read()!=0xff);//等到SD卡不忙（数据被接受以后，SD卡要将这些数据写入到自身的FLASH中，需要一个时间）
    02C27 940E 379D CALL	_SPI_Read
    02C29 2F40      MOV	R20,R16
    02C2A 3F0F      CPI	R16,0xFF
    02C2B F7D9      BNE	0x2C27
(0140) 						    //忙时，读回来的值为0x00,不忙时，为0xff
(0141) 
(0142) 	SD_CS_DIS(); //关闭片选
    02C2C 9AC0      SBI	0x18,0
(0143) 
(0144) 	SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02C2D 940E 379D CALL	_SPI_Read
(0145) 	return SD_TURE;		 //返回0,说明写扇区操作成功
    02C2F 2700      CLR	R16
    02C30 2711      CLR	R17
    02C31 9626      ADIW	R28,6
    02C32 940E 3FB8 CALL	pop_xgsetF03C
    02C34 9624      ADIW	R28,4
    02C35 9508      RET
_SD_Read_Sector:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  buffer               --> R10
  addr                 --> Y,+14
    02C36 940E 3E2F CALL	push_arg4
    02C38 940E 3FAF CALL	push_xgsetF03C
    02C3A 9726      SBIW	R28,6
    02C3B 88AA      LDD	R10,Y+18
    02C3C 88BB      LDD	R11,Y+19
(0146) } 
(0147) //****************************************************************
(0148) //*隶属模块：SD卡控制
(0149) //*函数功能：读512字节数据（一扇区字节）
(0150) //****************************************************************
(0151) UINT16 SD_Read_Sector(UINT32 addr,UINT8 *buffer)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0152) {
(0153) 
(0154) 	 UINT16 j=0;
    02C3D 2744      CLR	R20
    02C3E 2755      CLR	R21
(0155) 	 UINT8 time=0,temp=0;
    02C3F 2766      CLR	R22
    02C40 24CC      CLR	R12
(0156) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02C41 E586      LDI	R24,0x56
    02C42 E092      LDI	R25,2
    02C43 01FE      MOVW	R30,R28
    02C44 E006      LDI	R16,6
    02C45 E010      LDI	R17,0
    02C46 93FA      ST	-Y,R31
    02C47 93EA      ST	-Y,R30
    02C48 939A      ST	-Y,R25
    02C49 938A      ST	-Y,R24
    02C4A 940E 401B CALL	asgnblk
(0157) 
(0158) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02C4C E089      LDI	R24,0x9
    02C4D E090      LDI	R25,0
    02C4E 850E      LDD	R16,Y+14
    02C4F 851F      LDD	R17,Y+15
    02C50 8928      LDD	R18,Y+16
    02C51 8939      LDD	R19,Y+17
    02C52 938A      ST	-Y,R24
    02C53 940E 3FF6 CALL	lsl32
    02C55 870E      STD	Y+14,R16
    02C56 871F      STD	Y+15,R17
    02C57 8B28      STD	Y+16,R18
    02C58 8B39      STD	Y+17,R19
(0159) 
(0160) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02C59 E188      LDI	R24,0x18
    02C5A E090      LDI	R25,0
    02C5B 850E      LDD	R16,Y+14
    02C5C 851F      LDD	R17,Y+15
    02C5D 8928      LDD	R18,Y+16
    02C5E 8939      LDD	R19,Y+17
    02C5F 938A      ST	-Y,R24
    02C60 940E 400F CALL	lsr32
    02C62 8309      STD	Y+1,R16
(0161) 	 pcmd[2] = (addr>>16);
    02C63 842E      LDD	R2,Y+14
    02C64 843F      LDD	R3,Y+15
    02C65 8848      LDD	R4,Y+16
    02C66 8859      LDD	R5,Y+17
    02C67 0112      MOVW	R2,R4
    02C68 2444      CLR	R4
    02C69 2455      CLR	R5
    02C6A 822A      STD	Y+2,R2
(0162) 	 pcmd[3] =(addr>>8);
    02C6B E088      LDI	R24,0x8
    02C6C E090      LDI	R25,0
    02C6D 850E      LDD	R16,Y+14
    02C6E 851F      LDD	R17,Y+15
    02C6F 8928      LDD	R18,Y+16
    02C70 8939      LDD	R19,Y+17
    02C71 938A      ST	-Y,R24
    02C72 940E 400F CALL	lsr32
    02C74 830B      STD	Y+3,R16
(0163) 	// pcmd[4] = offset;
(0164) 
(0165) 	 SD_CS_EN();//打开片选 
    02C75 98C0      CBI	0x18,0
(0166) 
(0167) 	 do
(0168) 	 {  
(0169) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02C76 018E      MOVW	R16,R28
    02C77 DEA6      RCALL	_SD_Write_cmd
    02C78 2EC0      MOV	R12,R16
(0170) 		  time++;
    02C79 9563      INC	R22
(0171) 		  if(time==TRY_TIME) 
    02C7A 3164      CPI	R22,0x14
    02C7B F421      BNE	0x2C80
(0172) 		  {
(0173) 		   SD_CS_DIS();
    02C7C 9AC0      SBI	0x18,0
(0174) 		   return(READ_BLOCK_ERROR); //读块失败
    02C7D E004      LDI	R16,4
    02C7E E010      LDI	R17,0
    02C7F C01F      RJMP	0x2C9F
(0175) 		  }
(0176) 	 }while(temp!=0); 
    02C80 20CC      TST	R12
    02C81 F7A1      BNE	0x2C76
(0177)    			
(0178) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02C82 940E 379D CALL	_SPI_Read
    02C84 3F0E      CPI	R16,0xFE
    02C85 F7E1      BNE	0x2C82
(0179)  		   	   	
(0180) 	 for(j=0;j<512;j++)	 //将数据写入到数据缓冲区中
    02C86 2744      CLR	R20
    02C87 2755      CLR	R21
    02C88 C009      RJMP	0x2C92
(0181) 	 {	
(0182) 	    buffer[j]=SPI_Read();
    02C89 940E 379D CALL	_SPI_Read
    02C8B 2EC0      MOV	R12,R16
    02C8C 01FA      MOVW	R30,R20
    02C8D 0DEA      ADD	R30,R10
    02C8E 1DFB      ADC	R31,R11
    02C8F 82C0      ST	Z,R12
    02C90 5F4F      SUBI	R20,0xFF
    02C91 4F5F      SBCI	R21,0xFF
    02C92 3040      CPI	R20,0
    02C93 E0E2      LDI	R30,2
    02C94 075E      CPC	R21,R30
    02C95 F398      BCS	0x2C89
(0183) 	 }
(0184) 
(0185) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02C96 940E 379D CALL	_SPI_Read
(0186) 	 SPI_Read();
    02C98 940E 379D CALL	_SPI_Read
(0187) 
(0188) 	 SD_CS_DIS();  //SD卡关闭片选 
    02C9A 9AC0      SBI	0x18,0
(0189) 
(0190) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02C9B 940E 379D CALL	_SPI_Read
(0191) 
(0192) 	 return SD_TURE;
    02C9D 2700      CLR	R16
    02C9E 2711      CLR	R17
    02C9F 9626      ADIW	R28,6
    02CA0 940E 3FB8 CALL	pop_xgsetF03C
    02CA2 9624      ADIW	R28,4
    02CA3 9508      RET
_SD_Read_Sector_ndata:
  pcmd                 --> Y,+0
  temp                 --> R12
  time                 --> R22
  j                    --> R20
  len                  --> R14
  offset               --> R10
  buffer               --> Y,+20
  addr                 --> Y,+16
    02CA4 940E 3E2F CALL	push_arg4
    02CA6 940E 3F74 CALL	push_xgsetF0FC
    02CA8 9726      SBIW	R28,6
    02CA9 88AE      LDD	R10,Y+22
    02CAA 88BF      LDD	R11,Y+23
    02CAB 8CE8      LDD	R14,Y+24
    02CAC 8CF9      LDD	R15,Y+25
(0193) }
(0194) //****************************************************************
(0195) //*隶属模块：SD卡控制
(0196) //*函数功能：写多扇区数据（多扇区字节）
(0197) //****************************************************************
(0198) UINT16 SD_Read_Sector_ndata(UINT32 addr,UINT8 *buffer,UINT16 offset,UINT16 len)//从SD卡的指定扇区中读出512个字节，使用CMD17（17号命令）
(0199) {
(0200) 
(0201) 	 UINT16 j=0;
    02CAD 2744      CLR	R20
    02CAE 2755      CLR	R21
(0202) 	 UINT8 time=0,temp=0;
    02CAF 2766      CLR	R22
    02CB0 24CC      CLR	R12
(0203) 	 UINT8 pcmd[]={0x51,0x00,0x00,0x00,0x00,0xff}; //CMD17的字节序列
    02CB1 E58C      LDI	R24,0x5C
    02CB2 E092      LDI	R25,2
    02CB3 01FE      MOVW	R30,R28
    02CB4 E006      LDI	R16,6
    02CB5 E010      LDI	R17,0
    02CB6 93FA      ST	-Y,R31
    02CB7 93EA      ST	-Y,R30
    02CB8 939A      ST	-Y,R25
    02CB9 938A      ST	-Y,R24
    02CBA 940E 401B CALL	asgnblk
(0204) 
(0205) 	 addr <<= 9; //将块地址（扇区地址）转为字节地址
    02CBC E089      LDI	R24,0x9
    02CBD E090      LDI	R25,0
    02CBE 8908      LDD	R16,Y+16
    02CBF 8919      LDD	R17,Y+17
    02CC0 892A      LDD	R18,Y+18
    02CC1 893B      LDD	R19,Y+19
    02CC2 938A      ST	-Y,R24
    02CC3 940E 3FF6 CALL	lsl32
    02CC5 8B08      STD	Y+16,R16
    02CC6 8B19      STD	Y+17,R17
    02CC7 8B2A      STD	Y+18,R18
    02CC8 8B3B      STD	Y+19,R19
(0206) 
(0207) 	 pcmd[1] = (addr>>24);//将字节地址写入到CMD17字节序列中
    02CC9 E188      LDI	R24,0x18
    02CCA E090      LDI	R25,0
    02CCB 8908      LDD	R16,Y+16
    02CCC 8919      LDD	R17,Y+17
    02CCD 892A      LDD	R18,Y+18
    02CCE 893B      LDD	R19,Y+19
    02CCF 938A      ST	-Y,R24
    02CD0 940E 400F CALL	lsr32
    02CD2 8309      STD	Y+1,R16
(0208) 	 pcmd[2] = (addr>>16);
    02CD3 8828      LDD	R2,Y+16
    02CD4 8839      LDD	R3,Y+17
    02CD5 884A      LDD	R4,Y+18
    02CD6 885B      LDD	R5,Y+19
    02CD7 0112      MOVW	R2,R4
    02CD8 2444      CLR	R4
    02CD9 2455      CLR	R5
    02CDA 822A      STD	Y+2,R2
(0209) 	 pcmd[3] =(addr>>8);
    02CDB E088      LDI	R24,0x8
    02CDC E090      LDI	R25,0
    02CDD 8908      LDD	R16,Y+16
    02CDE 8919      LDD	R17,Y+17
    02CDF 892A      LDD	R18,Y+18
    02CE0 893B      LDD	R19,Y+19
    02CE1 938A      ST	-Y,R24
    02CE2 940E 400F CALL	lsr32
    02CE4 830B      STD	Y+3,R16
(0210) 	// pcmd[4] = offset;
(0211) 
(0212) 	 SD_CS_EN();//打开片选 
    02CE5 98C0      CBI	0x18,0
(0213) 
(0214) 	 do
(0215) 	 {  
(0216) 		  temp=SD_Write_cmd(pcmd); //写入CMD17
    02CE6 018E      MOVW	R16,R28
    02CE7 DE36      RCALL	_SD_Write_cmd
    02CE8 2EC0      MOV	R12,R16
(0217) 		  time++;
    02CE9 9563      INC	R22
(0218) 		  if(time==TRY_TIME) 
    02CEA 3164      CPI	R22,0x14
    02CEB F421      BNE	0x2CF0
(0219) 		  {
(0220) 		   SD_CS_DIS();
    02CEC 9AC0      SBI	0x18,0
(0221) 		   return(READ_BLOCK_ERROR); //读块失败
    02CED E004      LDI	R16,4
    02CEE E010      LDI	R17,0
    02CEF C034      RJMP	0x2D24
(0222) 		  }
(0223) 	 }while(temp!=0); 
    02CF0 20CC      TST	R12
    02CF1 F7A1      BNE	0x2CE6
(0224)    			
(0225) 	 while(SPI_Read()!= 0xfe); //一直读，当读到0xfe时，说明后面的是512字节的数据了
    02CF2 940E 379D CALL	_SPI_Read
    02CF4 3F0E      CPI	R16,0xFE
    02CF5 F7E1      BNE	0x2CF2
(0226)  		   	   	
(0227) 	 for(j=0;j<offset;j++)	 //将数据写入到数据缓冲区中
    02CF6 2744      CLR	R20
    02CF7 2755      CLR	R21
    02CF8 C004      RJMP	0x2CFD
(0228) 	    SPI_Read();
    02CF9 940E 379D CALL	_SPI_Read
    02CFB 5F4F      SUBI	R20,0xFF
    02CFC 4F5F      SBCI	R21,0xFF
    02CFD 154A      CP	R20,R10
    02CFE 055B      CPC	R21,R11
    02CFF F3C8      BCS	0x2CF9
(0229) 	 for(;j<offset+len;j++)	 
    02D00 C00B      RJMP	0x2D0C
(0230) 		buffer[j]=SPI_Read();
    02D01 940E 379D CALL	_SPI_Read
    02D03 2F60      MOV	R22,R16
    02D04 01FA      MOVW	R30,R20
    02D05 880C      LDD	R0,Y+20
    02D06 881D      LDD	R1,Y+21
    02D07 0DE0      ADD	R30,R0
    02D08 1DF1      ADC	R31,R1
    02D09 8360      ST	Z,R22
    02D0A 5F4F      SUBI	R20,0xFF
    02D0B 4F5F      SBCI	R21,0xFF
    02D0C 0115      MOVW	R2,R10
    02D0D 0C2E      ADD	R2,R14
    02D0E 1C3F      ADC	R3,R15
    02D0F 1542      CP	R20,R2
    02D10 0553      CPC	R21,R3
    02D11 F378      BCS	0x2D01
(0231) 	 for(;j<512;j++)	 
    02D12 C004      RJMP	0x2D17
(0232) 		SPI_Read();
    02D13 940E 379D CALL	_SPI_Read
    02D15 5F4F      SUBI	R20,0xFF
    02D16 4F5F      SBCI	R21,0xFF
    02D17 3040      CPI	R20,0
    02D18 E0E2      LDI	R30,2
    02D19 075E      CPC	R21,R30
    02D1A F3C0      BCS	0x2D13
(0233) 
(0234) 	 SPI_Read();//读取两个字节的CRC校验码，不用关心它们
    02D1B 940E 379D CALL	_SPI_Read
(0235) 	 SPI_Read();
    02D1D 940E 379D CALL	_SPI_Read
(0236) 
(0237) 	 SD_CS_DIS();  //SD卡关闭片选 
    02D1F 9AC0      SBI	0x18,0
(0238) 
(0239) 	 SPI_Read();//按照SD卡的操作时序在这里补8个时钟
    02D20 940E 379D CALL	_SPI_Read
(0240) 
(0241) 	 return SD_TURE;
    02D22 2700      CLR	R16
    02D23 2711      CLR	R17
    02D24 9626      ADIW	R28,6
    02D25 940E 3F69 CALL	pop_xgsetF0FC
    02D27 9624      ADIW	R28,4
    02D28 9508      RET
_GUI_mainmeu:
  key                  --> R22
  select               --> R20
    02D29 934A      ST	-Y,R20
    02D2A 936A      ST	-Y,R22
    02D2B 9723      SBIW	R28,3
FILE: D:\LQD\software\master\software_src\gui.c
(0001) #include "config.h"
(0002) const char labelH[]="高强度作业：\0";
(0003) const char labelM[]="中等强度作业：\0";
(0004) const char labelL[]="低强度作业：\0";
(0005) const char H01[]="加强劳动监督；\0";
(0006) const char H02[]="增加饮水;\0" ;
(0007) const char H03[]="保持干燥禁裸露。\0";
(0008) #define M01 H01
(0009) #define M02 H03
(0010) const char M03[]="戴面罩。\0";
(0011) const char M04[]="禁油彩。\0";
(0012) #define L01 M03
(0013) #define L02 M04
(0014) const char L03[]="缩短作业时间。";
(0015) //-----//
(0016) #define H11 M04
(0017) #define H12 H03
(0018) const char H13[]="休息注意保暖。\0";
(0019) #define M11 H01
(0020) const char M12[]="减少非必须作业；\0";
(0021) const char M13[]="劳动时间<30min。\0";
(0022) const char L11[]="取消非必须的作业\0";
(0023) const char L12[]="劳动时间<15min；\0";
(0024) #define L13 H03
(0025) //-----//
(0026) #define H21 L11
(0027) #define H22 L12
(0028) #define H23 H03
(0029) const char M21[]="取消户外作业。"; 
(0030) #define L21 M21
(0031) 
(0032) //#define LEDON   PORTC&=~(1<<7)					   
(0033) //#define LEDOFF  PINC|=(1<<7)
(0034) char GUI_date[17]="09月19日18:00:00\0";
(0035) 
(0036) // 主菜单
(0037) unsigned char GUI_mainmeu( void ){
(0038)  	unsigned char key=0; //init= nokey
    02D2C 2766      CLR	R22
(0039) 	unsigned char select=3;
    02D2D E043      LDI	R20,3
(0040) 	LCD_CLR();
    02D2E 940E 387D CALL	_LCD_CLR
(0041)  	Set_White(1,1,8,1);
    02D30 E081      LDI	R24,1
    02D31 838A      STD	Y+2,R24
    02D32 E088      LDI	R24,0x8
    02D33 8388      ST	Y,R24
    02D34 E021      LDI	R18,1
    02D35 E001      LDI	R16,1
    02D36 940E 3907 CALL	_Set_White
(0042) 	Set_White(1,2,8,1);
    02D38 E081      LDI	R24,1
    02D39 838A      STD	Y+2,R24
    02D3A E088      LDI	R24,0x8
    02D3B 8388      ST	Y,R24
    02D3C E022      LDI	R18,2
    02D3D E001      LDI	R16,1
    02D3E 940E 3907 CALL	_Set_White
(0043) 	Set_White(1,3,8,1);
    02D40 E081      LDI	R24,1
    02D41 838A      STD	Y+2,R24
    02D42 E088      LDI	R24,0x8
    02D43 8388      ST	Y,R24
    02D44 E023      LDI	R18,3
    02D45 E001      LDI	R16,1
    02D46 940E 3907 CALL	_Set_White
(0044) 	Set_White(1,4,8,1);
    02D48 E081      LDI	R24,1
    02D49 838A      STD	Y+2,R24
    02D4A E088      LDI	R24,0x8
    02D4B 8388      ST	Y,R24
    02D4C E024      LDI	R18,4
    02D4D E001      LDI	R16,1
    02D4E 940E 3907 CALL	_Set_White
(0045) 	LCD_const_disp(2,1,"  检测  时钟调整");
    02D50 EB8F      LDI	R24,0xBF
    02D51 E094      LDI	R25,4
    02D52 8399      STD	Y+1,R25
    02D53 8388      ST	Y,R24
    02D54 E021      LDI	R18,1
    02D55 E002      LDI	R16,2
    02D56 940E 37D7 CALL	_LCD_const_disp
(0046) 	LCD_const_disp(3,1,"  查询  数据传输");
    02D58 EA8E      LDI	R24,0xAE
    02D59 E094      LDI	R25,4
    02D5A 8399      STD	Y+1,R25
    02D5B 8388      ST	Y,R24
    02D5C E021      LDI	R18,1
    02D5D E003      LDI	R16,3
    02D5E 940E 37D7 CALL	_LCD_const_disp
(0047) 	LCD_const_disp(4,1,"  初始化");
    02D60 EA85      LDI	R24,0xA5
    02D61 E094      LDI	R25,4
    02D62 8399      STD	Y+1,R25
    02D63 8388      ST	Y,R24
    02D64 E021      LDI	R18,1
    02D65 E004      LDI	R16,4
    02D66 940E 37D7 CALL	_LCD_const_disp
(0048) 	Set_White(1,1,8,1);
    02D68 E081      LDI	R24,1
    02D69 838A      STD	Y+2,R24
    02D6A E088      LDI	R24,0x8
    02D6B 8388      ST	Y,R24
    02D6C E021      LDI	R18,1
    02D6D E001      LDI	R16,1
    02D6E 940E 3907 CALL	_Set_White
(0049) 	Set_White(1,2,8,1);
    02D70 E081      LDI	R24,1
    02D71 838A      STD	Y+2,R24
    02D72 E088      LDI	R24,0x8
    02D73 8388      ST	Y,R24
    02D74 E022      LDI	R18,2
    02D75 E001      LDI	R16,1
    02D76 940E 3907 CALL	_Set_White
(0050) 	Set_White(1,3,8,1);
    02D78 E081      LDI	R24,1
    02D79 838A      STD	Y+2,R24
    02D7A E088      LDI	R24,0x8
    02D7B 8388      ST	Y,R24
    02D7C E023      LDI	R18,3
    02D7D E001      LDI	R16,1
    02D7E 940E 3907 CALL	_Set_White
(0051) 	Set_White(1,4,8,1);
    02D80 E081      LDI	R24,1
    02D81 838A      STD	Y+2,R24
    02D82 E088      LDI	R24,0x8
    02D83 8388      ST	Y,R24
    02D84 E024      LDI	R18,4
    02D85 E001      LDI	R16,1
    02D86 940E 3907 CALL	_Set_White
(0052) 	set_white_n(select,0);
    02D88 2722      CLR	R18
    02D89 2F04      MOV	R16,R20
    02D8A 940E 3999 CALL	_set_white_n
    02D8C C07B      RJMP	0x2E08
(0053) 	while(1)
(0054) 	{
(0055) 	 	key=kbscan();
    02D8D 940E 3DC6 CALL	_kbscan
    02D8F 2F60      MOV	R22,R16
(0056) 		dateRefresh(1); //更新系统时间
    02D90 E001      LDI	R16,1
    02D91 D6DB      RCALL	_dateRefresh
(0057) 		LCD_const_disp(1,1,GUI_get_date()); //显示时间
    02D92 D447      RCALL	_GUI_get_date
    02D93 8319      STD	Y+1,R17
    02D94 8308      ST	Y,R16
    02D95 E021      LDI	R18,1
    02D96 E001      LDI	R16,1
    02D97 940E 37D7 CALL	_LCD_const_disp
(0058) 		if((select>3) && ( key==up ) ){
    02D99 E083      LDI	R24,3
    02D9A 1784      CP	R24,R20
    02D9B F4F8      BCC	0x2DBB
    02D9C 316E      CPI	R22,0x1E
    02D9D F4E9      BNE	0x2DBB
(0059) 		 Set_White(1,2,8,1);
    02D9E E081      LDI	R24,1
    02D9F 838A      STD	Y+2,R24
    02DA0 E088      LDI	R24,0x8
    02DA1 8388      ST	Y,R24
    02DA2 E022      LDI	R18,2
    02DA3 E001      LDI	R16,1
    02DA4 940E 3907 CALL	_Set_White
(0060) 		 Set_White(1,3,8,1);
    02DA6 E081      LDI	R24,1
    02DA7 838A      STD	Y+2,R24
    02DA8 E088      LDI	R24,0x8
    02DA9 8388      ST	Y,R24
    02DAA E023      LDI	R18,3
    02DAB E001      LDI	R16,1
    02DAC 940E 3907 CALL	_Set_White
(0061) 		 Set_White(1,4,8,1);
    02DAE E081      LDI	R24,1
    02DAF 838A      STD	Y+2,R24
    02DB0 E088      LDI	R24,0x8
    02DB1 8388      ST	Y,R24
    02DB2 E024      LDI	R18,4
    02DB3 E001      LDI	R16,1
    02DB4 940E 3907 CALL	_Set_White
(0062) 		 select--;
    02DB6 954A      DEC	R20
(0063) 		 set_white_n(select,0);
    02DB7 2722      CLR	R18
    02DB8 2F04      MOV	R16,R20
    02DB9 940E 3999 CALL	_set_white_n
(0064) 		}
(0065) 		if((select<7) && ( key==down ) ){
    02DBB 3047      CPI	R20,7
    02DBC F538      BCC	0x2DE4
    02DBD 316D      CPI	R22,0x1D
    02DBE F529      BNE	0x2DE4
(0066) 		 Set_White(1,1,8,1);
    02DBF E081      LDI	R24,1
    02DC0 838A      STD	Y+2,R24
    02DC1 E088      LDI	R24,0x8
    02DC2 8388      ST	Y,R24
    02DC3 E021      LDI	R18,1
    02DC4 E001      LDI	R16,1
    02DC5 940E 3907 CALL	_Set_White
(0067) 		 Set_White(1,2,8,1);
    02DC7 E081      LDI	R24,1
    02DC8 838A      STD	Y+2,R24
    02DC9 E088      LDI	R24,0x8
    02DCA 8388      ST	Y,R24
    02DCB E022      LDI	R18,2
    02DCC E001      LDI	R16,1
    02DCD 940E 3907 CALL	_Set_White
(0068) 		 Set_White(1,3,8,1);
    02DCF E081      LDI	R24,1
    02DD0 838A      STD	Y+2,R24
    02DD1 E088      LDI	R24,0x8
    02DD2 8388      ST	Y,R24
    02DD3 E023      LDI	R18,3
    02DD4 E001      LDI	R16,1
    02DD5 940E 3907 CALL	_Set_White
(0069) 		 Set_White(1,4,8,1);
    02DD7 E081      LDI	R24,1
    02DD8 838A      STD	Y+2,R24
    02DD9 E088      LDI	R24,0x8
    02DDA 8388      ST	Y,R24
    02DDB E024      LDI	R18,4
    02DDC E001      LDI	R16,1
    02DDD 940E 3907 CALL	_Set_White
(0070) 		 select++;
    02DDF 9543      INC	R20
(0071) 		 set_white_n(select,0);
    02DE0 2722      CLR	R18
    02DE1 2F04      MOV	R16,R20
    02DE2 940E 3999 CALL	_set_white_n
(0072) 		}
(0073) 		if(key == left ){
    02DE4 316B      CPI	R22,0x1B
    02DE5 F511      BNE	0x2E08
(0074) 		 Set_White(1,1,8,1);
    02DE6 E081      LDI	R24,1
    02DE7 838A      STD	Y+2,R24
    02DE8 E088      LDI	R24,0x8
    02DE9 8388      ST	Y,R24
    02DEA E021      LDI	R18,1
    02DEB E001      LDI	R16,1
    02DEC 940E 3907 CALL	_Set_White
(0075) 		 Set_White(1,2,8,1);
    02DEE E081      LDI	R24,1
    02DEF 838A      STD	Y+2,R24
    02DF0 E088      LDI	R24,0x8
    02DF1 8388      ST	Y,R24
    02DF2 E022      LDI	R18,2
    02DF3 E001      LDI	R16,1
    02DF4 940E 3907 CALL	_Set_White
(0076) 		 Set_White(1,3,8,1);
    02DF6 E081      LDI	R24,1
    02DF7 838A      STD	Y+2,R24
    02DF8 E088      LDI	R24,0x8
    02DF9 8388      ST	Y,R24
    02DFA E023      LDI	R18,3
    02DFB E001      LDI	R16,1
    02DFC 940E 3907 CALL	_Set_White
(0077) 		 Set_White(1,4,8,1);
    02DFE E081      LDI	R24,1
    02DFF 838A      STD	Y+2,R24
    02E00 E088      LDI	R24,0x8
    02E01 8388      ST	Y,R24
    02E02 E024      LDI	R18,4
    02E03 E001      LDI	R16,1
    02E04 940E 3907 CALL	_Set_White
(0078) 		 //beep(3,select);
(0079) 		 return select;
    02E06 2F04      MOV	R16,R20
    02E07 C001      RJMP	0x2E09
    02E08 CF84      RJMP	0x2D8D
    02E09 9623      ADIW	R28,3
    02E0A 9169      LD	R22,Y+
    02E0B 9149      LD	R20,Y+
    02E0C 9508      RET
_GUI_check:
  next_step_time       --> Y,+3
  selectCheckMode      --> R10
  page                 --> Y,+7
  is_on                --> R12
  key                  --> R14
    02E0D 940E 3F74 CALL	push_xgsetF0FC
    02E0F 9728      SBIW	R28,0x8
(0080) 		}
(0081)     }
(0082) 	return 0xff; //error
(0083) 	
(0084) }
(0085) 
(0086) //”检测 “菜单
(0087) void GUI_check(void)
(0088) {
(0089)     char key;
(0090) 	char page=0,is_on=0;
    02E10 2400      CLR	R0
    02E11 820F      STD	Y+7,R0
    02E12 24CC      CLR	R12
(0091) 	long next_step_time=0;
    02E13 E080      LDI	R24,0
    02E14 838B      STD	Y+3,R24
    02E15 838C      STD	Y+4,R24
    02E16 838D      STD	Y+5,R24
    02E17 838E      STD	Y+6,R24
(0092) 	char selectCheckMode=config.autocheck; //自动检测开关
    02E18 90A0 07C8 LDS	R10,config+16
(0093) 	LCD_CLR();
    02E1A 940E 387D CALL	_LCD_CLR
(0094) 	LCD_const_disp(1,1,"菜单/ 检测");
    02E1C E98A      LDI	R24,0x9A
    02E1D E094      LDI	R25,4
    02E1E 8399      STD	Y+1,R25
    02E1F 8388      ST	Y,R24
    02E20 E021      LDI	R18,1
    02E21 E001      LDI	R16,1
    02E22 940E 37D7 CALL	_LCD_const_disp
(0095) 	LCD_const_disp(2,3,"自动");		 
    02E24 E985      LDI	R24,0x95
    02E25 E094      LDI	R25,4
    02E26 8399      STD	Y+1,R25
    02E27 8388      ST	Y,R24
    02E28 E023      LDI	R18,3
    02E29 E002      LDI	R16,2
    02E2A 940E 37D7 CALL	_LCD_const_disp
(0096) 	LCD_const_disp(3,3,"手动");
    02E2C E980      LDI	R24,0x90
    02E2D E094      LDI	R25,4
    02E2E 8399      STD	Y+1,R25
    02E2F 8388      ST	Y,R24
    02E30 E023      LDI	R18,3
    02E31 E003      LDI	R16,3
    02E32 940E 37D7 CALL	_LCD_const_disp
(0097) 	if(selectCheckMode==1) {
    02E34 2D8A      MOV	R24,R10
    02E35 3081      CPI	R24,1
    02E36 F489      BNE	0x2E48
(0098) 	    Set_White(1,2,8,0);
    02E37 2422      CLR	R2
    02E38 822A      STD	Y+2,R2
    02E39 E088      LDI	R24,0x8
    02E3A 8388      ST	Y,R24
    02E3B E022      LDI	R18,2
    02E3C E001      LDI	R16,1
    02E3D 940E 3907 CALL	_Set_White
(0099) 		Set_White(1,3,8,1);
    02E3F E081      LDI	R24,1
    02E40 838A      STD	Y+2,R24
    02E41 E088      LDI	R24,0x8
    02E42 8388      ST	Y,R24
    02E43 E023      LDI	R18,3
    02E44 E001      LDI	R16,1
    02E45 940E 3907 CALL	_Set_White
(0100) 	}
    02E47 C05F      RJMP	0x2EA7
(0101) 	else {
(0102) 		 Set_White(1,2,8,1);
    02E48 E081      LDI	R24,1
    02E49 838A      STD	Y+2,R24
    02E4A E088      LDI	R24,0x8
    02E4B 8388      ST	Y,R24
    02E4C E022      LDI	R18,2
    02E4D E001      LDI	R16,1
    02E4E 940E 3907 CALL	_Set_White
(0103) 		 Set_White(1,3,8,0);
    02E50 2422      CLR	R2
    02E51 822A      STD	Y+2,R2
    02E52 E088      LDI	R24,0x8
    02E53 8388      ST	Y,R24
    02E54 E023      LDI	R18,3
    02E55 E001      LDI	R16,1
    02E56 940E 3907 CALL	_Set_White
(0104) 	}
    02E58 C04E      RJMP	0x2EA7
(0105) //<<菜单/检测/手（自）动>>
(0106) while(1){
(0107)  	key=kbscan();
    02E59 940E 3DC6 CALL	_kbscan
    02E5B 2EE0      MOV	R14,R16
(0108) 	//上键短按 选择
(0109) 	if(key==up || key ==down){
    02E5C 2D8E      MOV	R24,R14
    02E5D 310E      CPI	R16,0x1E
    02E5E F011      BEQ	0x2E61
    02E5F 310D      CPI	R16,0x1D
    02E60 F539      BNE	0x2E88
(0110) 	    if(selectCheckMode == 1){
    02E61 2D8A      MOV	R24,R10
    02E62 3081      CPI	R24,1
    02E63 F491      BNE	0x2E76
(0111) 		    selectCheckMode=0;
    02E64 24AA      CLR	R10
(0112) 			Set_White(1,2,8,0);
    02E65 2422      CLR	R2
    02E66 822A      STD	Y+2,R2
    02E67 E088      LDI	R24,0x8
    02E68 8388      ST	Y,R24
    02E69 E022      LDI	R18,2
    02E6A E001      LDI	R16,1
    02E6B 940E 3907 CALL	_Set_White
(0113)  			Set_White(1,3,8,1);
    02E6D E081      LDI	R24,1
    02E6E 838A      STD	Y+2,R24
    02E6F E088      LDI	R24,0x8
    02E70 8388      ST	Y,R24
    02E71 E023      LDI	R18,3
    02E72 E001      LDI	R16,1
    02E73 940E 3907 CALL	_Set_White
(0114) 		}
    02E75 C012      RJMP	0x2E88
(0115) 		else {
(0116) 		    selectCheckMode=1;
    02E76 24AA      CLR	R10
    02E77 94A3      INC	R10
(0117) 			Set_White(1,2,8,1);
    02E78 E081      LDI	R24,1
    02E79 838A      STD	Y+2,R24
    02E7A E088      LDI	R24,0x8
    02E7B 8388      ST	Y,R24
    02E7C E022      LDI	R18,2
    02E7D E001      LDI	R16,1
    02E7E 940E 3907 CALL	_Set_White
(0118)  			Set_White(1,3,8,0);
    02E80 2422      CLR	R2
    02E81 822A      STD	Y+2,R2
    02E82 E088      LDI	R24,0x8
    02E83 8388      ST	Y,R24
    02E84 E023      LDI	R18,3
    02E85 E001      LDI	R16,1
    02E86 940E 3907 CALL	_Set_White
(0119) 		}
(0120) 		
(0121) 	}
(0122) 	//左键短按  进入
(0123) 	if(key == left) {
    02E88 2D8E      MOV	R24,R14
    02E89 318B      CPI	R24,0x1B
    02E8A F4B9      BNE	0x2EA2
(0124) 		config.autocheck=selectCheckMode; 
    02E8B 92A0 07C8 STS	config+16,R10
(0125) 		Set_White(1,2,8,1);
    02E8D E081      LDI	R24,1
    02E8E 838A      STD	Y+2,R24
    02E8F E088      LDI	R24,0x8
    02E90 8388      ST	Y,R24
    02E91 E022      LDI	R18,2
    02E92 E001      LDI	R16,1
    02E93 940E 3907 CALL	_Set_White
(0126)  		Set_White(1,3,8,1);
    02E95 E081      LDI	R24,1
    02E96 838A      STD	Y+2,R24
    02E97 E088      LDI	R24,0x8
    02E98 8388      ST	Y,R24
    02E99 E023      LDI	R18,3
    02E9A E001      LDI	R16,1
    02E9B 940E 3907 CALL	_Set_White
(0127) 		delayms(300);
    02E9D E20C      LDI	R16,0x2C
    02E9E E011      LDI	R17,1
    02E9F 940E 23FF CALL	_delayms
(0128) 		break ;		
    02EA1 C006      RJMP	0x2EA8
(0129) 	}
(0130) 	//右键短按  返回
(0131) 	if(key == right) {
    02EA2 2D8E      MOV	R24,R14
    02EA3 3187      CPI	R24,0x17
    02EA4 F409      BNE	0x2EA6
(0132) 		return ;		
    02EA5 C120      RJMP	0x2FC6
(0133) 	}
(0134) 	key=0;
    02EA6 24EE      CLR	R14
    02EA7 CFB1      RJMP	0x2E59
(0135) } //end of while
(0136) if(config.autocheck == 1) {
    02EA8 9180 07C8 LDS	R24,config+16
    02EAA 3081      CPI	R24,1
    02EAB F009      BEQ	0x2EAD
    02EAC C118      RJMP	0x2FC5
(0137)     next_step_time=now;
    02EAD 9040 0117 LDS	R4,now+2
    02EAF 9050 0118 LDS	R5,now+3
    02EB1 9020 0115 LDS	R2,now
    02EB3 9030 0116 LDS	R3,now+1
    02EB5 822B      STD	Y+3,R2
    02EB6 823C      STD	Y+4,R3
    02EB7 824D      STD	Y+5,R4
    02EB8 825E      STD	Y+6,R5
(0138) }
    02EB9 C10B      RJMP	0x2FC5
(0139) while(1){
(0140) 	key=kbscan();
    02EBA 940E 3DC6 CALL	_kbscan
    02EBC 2EE0      MOV	R14,R16
(0141) 	if(key != 0) beep(0,1);
    02EBD 2300      TST	R16
    02EBE F021      BEQ	0x2EC3
    02EBF E021      LDI	R18,1
    02EC0 2700      CLR	R16
    02EC1 940E 3B52 CALL	_beep
(0142) 	_GUI_datashow(1,page);
    02EC3 812F      LDD	R18,Y+7
    02EC4 E001      LDI	R16,1
    02EC5 D103      RCALL	__GUI_datashow
(0143) 	if(config.autocheck == 1 && now > next_step_time ){
    02EC6 9180 07C8 LDS	R24,config+16
    02EC8 3081      CPI	R24,1
    02EC9 F571      BNE	0x2EF8
    02ECA 802B      LDD	R2,Y+3
    02ECB 803C      LDD	R3,Y+4
    02ECC 804D      LDD	R4,Y+5
    02ECD 805E      LDD	R5,Y+6
    02ECE 9080 0117 LDS	R8,now+2
    02ED0 9090 0118 LDS	R9,now+3
    02ED2 9060 0115 LDS	R6,now
    02ED4 9070 0116 LDS	R7,now+1
    02ED6 1426      CP	R2,R6
    02ED7 0437      CPC	R3,R7
    02ED8 0448      CPC	R4,R8
    02ED9 0459      CPC	R5,R9
    02EDA F4E8      BCC	0x2EF8
(0144) 	    next_step_time=now+config.checkDeltaTime; //更新下一步操作时间
    02EDB 9020 07C9 LDS	R2,config+17
    02EDD 9030 07CA LDS	R3,config+18
    02EDF 2444      CLR	R4
    02EE0 FC37      SBRC	R3,7
    02EE1 9440      COM	R4
    02EE2 2455      CLR	R5
    02EE3 FC47      SBRC	R4,7
    02EE4 9450      COM	R5
    02EE5 0C62      ADD	R6,R2
    02EE6 1C73      ADC	R7,R3
    02EE7 1C84      ADC	R8,R4
    02EE8 1C95      ADC	R9,R5
    02EE9 826B      STD	Y+3,R6
    02EEA 827C      STD	Y+4,R7
    02EEB 828D      STD	Y+5,R8
    02EEC 829E      STD	Y+6,R9
(0145) 		if(page < 5) page++ ;
    02EED 818F      LDD	R24,Y+7
    02EEE 3085      CPI	R24,5
    02EEF F420      BCC	0x2EF4
    02EF0 2E08      MOV	R0,R24
    02EF1 9403      INC	R0
    02EF2 820F      STD	Y+7,R0
    02EF3 C004      RJMP	0x2EF8
(0146) 		else {
(0147) 			page=0; //返回起始页面
    02EF4 2400      CLR	R0
    02EF5 820F      STD	Y+7,R0
(0148) 			key=left; //模拟开始检测按键
    02EF6 E18B      LDI	R24,0x1B
    02EF7 2EE8      MOV	R14,R24
(0149) 		}
(0150) 	}
(0151) 	//LCD_print2num(4,4,is_on);
(0152) 	if(key==left && is_on==0){ //按left键开始测量
    02EF8 2D8E      MOV	R24,R14
    02EF9 318B      CPI	R24,0x1B
    02EFA F521      BNE	0x2F1F
    02EFB 20CC      TST	R12
    02EFC F511      BNE	0x2F1F
(0153) 	  			 beep(1,0);
    02EFD 2722      CLR	R18
    02EFE E001      LDI	R16,1
    02EFF 940E 3B52 CALL	_beep
(0154) 	  			 //fwrite; 
(0155) 				 config.time1=config.now+config.THRESHOLD_delta_sec;
    02F01 9040 07BE LDS	R4,config+6
    02F03 9050 07BF LDS	R5,config+7
    02F05 9020 07BC LDS	R2,config+4
    02F07 9030 07BD LDS	R3,config+5
    02F09 9080 07C6 LDS	R8,config+14
    02F0B 9090 07C7 LDS	R9,config+15
    02F0D 9060 07C4 LDS	R6,config+12
    02F0F 9070 07C5 LDS	R7,config+13
    02F11 0C62      ADD	R6,R2
    02F12 1C73      ADC	R7,R3
    02F13 1C84      ADC	R8,R4
    02F14 1C95      ADC	R9,R5
    02F15 9270 07C1 STS	config+9,R7
    02F17 9260 07C0 STS	config+8,R6
    02F19 9290 07C3 STS	config+11,R9
    02F1B 9280 07C2 STS	config+10,R8
(0156) 				 is_on=1; //start count
    02F1D 24CC      CLR	R12
    02F1E 94C3      INC	R12
(0157) 	 //			 timer1_init(); //计数
(0158) 				}
(0159) 	if(is_on == 1 && page == 0){
    02F1F 2D8C      MOV	R24,R12
    02F20 3081      CPI	R24,1
    02F21 F4D9      BNE	0x2F3D
    02F22 800F      LDD	R0,Y+7
    02F23 2000      TST	R0
    02F24 F4C1      BNE	0x2F3D
(0160) 	    LCD_const_disp(4,1,"倒计时: ");
    02F25 E887      LDI	R24,0x87
    02F26 E094      LDI	R25,4
    02F27 8399      STD	Y+1,R25
    02F28 8388      ST	Y,R24
    02F29 E021      LDI	R18,1
    02F2A E004      LDI	R16,4
    02F2B 940E 37D7 CALL	_LCD_const_disp
(0161) 	    LCD_print4num(4,5,config.time1-config.now);
    02F2D 9020 07C4 LDS	R2,config+12
    02F2F 9030 07C5 LDS	R3,config+13
    02F31 9040 07C0 LDS	R4,config+8
    02F33 9050 07C1 LDS	R5,config+9
    02F35 1842      SUB	R4,R2
    02F36 0853      SBC	R5,R3
    02F37 8259      STD	Y+1,R5
    02F38 8248      ST	Y,R4
    02F39 E025      LDI	R18,5
    02F3A E004      LDI	R16,4
    02F3B 940E 3A99 CALL	_LCD_print4num
(0162) 	}
(0163) 						
(0164) 	if(is_on == 1 && config.now>=config.time1 ){
    02F3D 2D8C      MOV	R24,R12
    02F3E 3081      CPI	R24,1
    02F3F F5A1      BNE	0x2F74
    02F40 9040 07C2 LDS	R4,config+10
    02F42 9050 07C3 LDS	R5,config+11
    02F44 9020 07C0 LDS	R2,config+8
    02F46 9030 07C1 LDS	R3,config+9
    02F48 9080 07C6 LDS	R8,config+14
    02F4A 9090 07C7 LDS	R9,config+15
    02F4C 9060 07C4 LDS	R6,config+12
    02F4E 9070 07C5 LDS	R7,config+13
    02F50 1462      CP	R6,R2
    02F51 0473      CPC	R7,R3
    02F52 0484      CPC	R8,R4
    02F53 0495      CPC	R9,R5
    02F54 F0FC      BLT	0x2F74
(0165) 	    is_on=0;
    02F55 24CC      CLR	R12
(0166) 	 	check(); //检测
    02F56 940E 27FE CALL	_check
(0167) 		StructToChar(); //转成字符串
    02F58 940E 297D CALL	_StructToChar
(0168) 		WriteSDFile();  //写入sd卡
    02F5A 940E 25D7 CALL	_WriteSDFile
(0169) 		//zigbee_send(); //发送
(0170) 	 	Result.Index++; //索引自增一
    02F5C E041      LDI	R20,1
    02F5D E050      LDI	R21,0
    02F5E E060      LDI	R22,0
    02F5F E070      LDI	R23,0
    02F60 9040 0554 LDS	R4,Result+12
    02F62 9050 0555 LDS	R5,Result+13
    02F64 9020 0552 LDS	R2,Result+10
    02F66 9030 0553 LDS	R3,Result+11
    02F68 0E24      ADD	R2,R20
    02F69 1E35      ADC	R3,R21
    02F6A 1E46      ADC	R4,R22
    02F6B 1E57      ADC	R5,R23
    02F6C 9230 0553 STS	Result+11,R3
    02F6E 9220 0552 STS	Result+10,R2
    02F70 9250 0555 STS	Result+13,R5
    02F72 9240 0554 STS	Result+12,R4
(0171)  	} 	
(0172)     if(key==up){ //上键 : 页面减 
    02F74 2D8E      MOV	R24,R14
    02F75 318E      CPI	R24,0x1E
    02F76 F451      BNE	0x2F81
(0173) 	    if(page>0) page--;
    02F77 E080      LDI	R24,0
    02F78 800F      LDD	R0,Y+7
    02F79 1580      CP	R24,R0
    02F7A F410      BCC	0x2F7D
    02F7B 940A      DEC	R0
    02F7C 820F      STD	Y+7,R0
(0174) 	    LCD_CLR();
    02F7D 940E 387D CALL	_LCD_CLR
(0175) 	    LCD_Init();
    02F7F 940E 384B CALL	_LCD_Init
(0176) 	}
(0177) 	if(key==down){ //下键 ： 页面加
    02F81 2D8E      MOV	R24,R14
    02F82 318D      CPI	R24,0x1D
    02F83 F469      BNE	0x2F91
(0178) 	    if(page<5) page++;
    02F84 818F      LDD	R24,Y+7
    02F85 3085      CPI	R24,5
    02F86 F420      BCC	0x2F8B
    02F87 2E08      MOV	R0,R24
    02F88 9403      INC	R0
    02F89 820F      STD	Y+7,R0
    02F8A C002      RJMP	0x2F8D
(0179) 	  	else page = 0;
    02F8B 2400      CLR	R0
    02F8C 820F      STD	Y+7,R0
(0180) 	    LCD_CLR();
    02F8D 940E 387D CALL	_LCD_CLR
(0181) 	    LCD_Init();
    02F8F 940E 384B CALL	_LCD_Init
(0182) 	}
(0183) 	if(key==right && is_on==0){	//右键 退出
    02F91 2D8E      MOV	R24,R14
    02F92 3187      CPI	R24,0x17
    02F93 F569      BNE	0x2FC1
    02F94 20CC      TST	R12
    02F95 F559      BNE	0x2FC1
(0184) 	    LCD_CLR();
    02F96 940E 387D CALL	_LCD_CLR
(0185) 	 	LCD_Init();	  
    02F98 940E 384B CALL	_LCD_Init
(0186)  	 	LCD_const_disp(4,5,"退出    "); 
    02F9A E78E      LDI	R24,0x7E
    02F9B E094      LDI	R25,4
    02F9C 8399      STD	Y+1,R25
    02F9D 8388      ST	Y,R24
    02F9E E025      LDI	R18,5
    02F9F E004      LDI	R16,4
    02FA0 940E 37D7 CALL	_LCD_const_disp
(0187) 	 	delayms(200);
    02FA2 EC08      LDI	R16,0xC8
    02FA3 E010      LDI	R17,0
    02FA4 940E 23FF CALL	_delayms
(0188) 	 	LCD_const_disp(4,7,".."); 
    02FA6 E78B      LDI	R24,0x7B
    02FA7 E094      LDI	R25,4
    02FA8 8399      STD	Y+1,R25
    02FA9 8388      ST	Y,R24
    02FAA E027      LDI	R18,7
    02FAB E004      LDI	R16,4
    02FAC 940E 37D7 CALL	_LCD_const_disp
(0189) 	 	delayms(200);
    02FAE EC08      LDI	R16,0xC8
    02FAF E010      LDI	R17,0
    02FB0 940E 23FF CALL	_delayms
(0190) 	 	LCD_const_disp(4,8,".."); 	
    02FB2 E78B      LDI	R24,0x7B
    02FB3 E094      LDI	R25,4
    02FB4 8399      STD	Y+1,R25
    02FB5 8388      ST	Y,R24
    02FB6 E028      LDI	R18,0x8
    02FB7 E004      LDI	R16,4
    02FB8 940E 37D7 CALL	_LCD_const_disp
(0191) 	 	delayms(500);
    02FBA EF04      LDI	R16,0xF4
    02FBB E011      LDI	R17,1
    02FBC 940E 23FF CALL	_delayms
(0192) 	 	LCD_CLR();
    02FBE 940E 387D CALL	_LCD_CLR
(0193) 	 	return ;
    02FC0 C005      RJMP	0x2FC6
(0194) 	}
(0195)     delayms(30); 
    02FC1 E10E      LDI	R16,0x1E
    02FC2 E010      LDI	R17,0
    02FC3 940E 23FF CALL	_delayms
    02FC5 CEF4      RJMP	0x2EBA
    02FC6 9628      ADIW	R28,0x8
    02FC7 940C 3F69 JMP	pop_xgsetF0FC
__GUI_datashow:
  page                 --> R20
  clockfresh           --> R10
    02FC9 940E 3F93 CALL	push_xgsetF00C
    02FCB 2F42      MOV	R20,R18
    02FCC 2EA0      MOV	R10,R16
    02FCD 9722      SBIW	R28,2
(0196) }//end while
(0197) }//end function
(0198) void _GUI_datashow(unsigned char clockfresh,char page){
(0199) 	if( clockfresh ) dateRefresh(clockfresh); //时钟刷新
    02FCE 20AA      TST	R10
    02FCF F011      BEQ	0x2FD2
    02FD0 2D0A      MOV	R16,R10
    02FD1 D49B      RCALL	_dateRefresh
(0200) 	if(page == 0){
    02FD2 2344      TST	R20
    02FD3 F539      BNE	0x2FFB
(0201)  	//显示日期时间
(0202) 	    LCD_var_disp(1,1,GUI_get_date());
    02FD4 D205      RCALL	_GUI_get_date
    02FD5 8319      STD	Y+1,R17
    02FD6 8308      ST	Y,R16
    02FD7 E021      LDI	R18,1
    02FD8 E001      LDI	R16,1
    02FD9 940E 3804 CALL	_LCD_var_disp
(0203) 	//显示温度
(0204) 	 	LCD_const_disp(2,1,"温度 (℃):");
    02FDB E780      LDI	R24,0x70
    02FDC E094      LDI	R25,4
    02FDD 8399      STD	Y+1,R25
    02FDE 8388      ST	Y,R24
    02FDF E021      LDI	R18,1
    02FE0 E002      LDI	R16,2
    02FE1 940E 37D7 CALL	_LCD_const_disp
(0205) 	 	LCD_var_disp(2,6,Result.TempChar);
    02FE3 E785      LDI	R24,0x75
    02FE4 E095      LDI	R25,5
    02FE5 8399      STD	Y+1,R25
    02FE6 8388      ST	Y,R24
    02FE7 E026      LDI	R18,6
    02FE8 E002      LDI	R16,2
    02FE9 940E 3804 CALL	_LCD_var_disp
(0206) 	//显示风速
(0207) 	    LCD_const_disp(3,1,"风速(m/s): ");
    02FEB E684      LDI	R24,0x64
    02FEC E094      LDI	R25,4
    02FED 8399      STD	Y+1,R25
    02FEE 8388      ST	Y,R24
    02FEF E021      LDI	R18,1
    02FF0 E003      LDI	R16,3
    02FF1 940E 37D7 CALL	_LCD_const_disp
(0208) 	 	LCD_const_disp(3,6,Result.WSChar);
    02FF3 E78F      LDI	R24,0x7F
    02FF4 E095      LDI	R25,5
    02FF5 8399      STD	Y+1,R25
    02FF6 8388      ST	Y,R24
    02FF7 E026      LDI	R18,6
    02FF8 E003      LDI	R16,3
    02FF9 940E 37D7 CALL	_LCD_const_disp
(0209) 
(0210) 	 } 
(0211) 	 if(page == 1){
    02FFB 3041      CPI	R20,1
    02FFC F5B9      BNE	0x3034
(0212) 	     LCD_var_disp(1,1,GUI_get_date());
    02FFD D1DC      RCALL	_GUI_get_date
    02FFE 8319      STD	Y+1,R17
    02FFF 8308      ST	Y,R16
    03000 E021      LDI	R18,1
    03001 E001      LDI	R16,1
    03002 940E 3804 CALL	_LCD_var_disp
(0213) 		 LCD_const_disp(2,1,"风冷指数: ");
    03004 E589      LDI	R24,0x59
    03005 E094      LDI	R25,4
    03006 8399      STD	Y+1,R25
    03007 8388      ST	Y,R24
    03008 E021      LDI	R18,1
    03009 E002      LDI	R16,2
    0300A 940E 37D7 CALL	_LCD_const_disp
(0214) 		 LCD_var_disp(2,6,Result.WCIChar);						
    0300C E888      LDI	R24,0x88
    0300D E095      LDI	R25,5
    0300E 8399      STD	Y+1,R25
    0300F 8388      ST	Y,R24
    03010 E026      LDI	R18,6
    03011 E002      LDI	R16,2
    03012 940E 3804 CALL	_LCD_var_disp
(0215) 		 LCD_const_disp(3,1,"等价温度: ");
    03014 E48E      LDI	R24,0x4E
    03015 E094      LDI	R25,4
    03016 8399      STD	Y+1,R25
    03017 8388      ST	Y,R24
    03018 E021      LDI	R18,1
    03019 E003      LDI	R16,3
    0301A 940E 37D7 CALL	_LCD_const_disp
(0216) 		 LCD_var_disp(3,6,Result.ECTChar);	 
    0301C E982      LDI	R24,0x92
    0301D E095      LDI	R25,5
    0301E 8399      STD	Y+1,R25
    0301F 8388      ST	Y,R24
    03020 E026      LDI	R18,6
    03021 E003      LDI	R16,3
    03022 940E 3804 CALL	_LCD_var_disp
(0217) 		 LCD_const_disp(4,1,"相当温度: ");
    03024 E483      LDI	R24,0x43
    03025 E094      LDI	R25,4
    03026 8399      STD	Y+1,R25
    03027 8388      ST	Y,R24
    03028 E021      LDI	R18,1
    03029 E004      LDI	R16,4
    0302A 940E 37D7 CALL	_LCD_const_disp
(0218) 		 LCD_var_disp(4,6,Result.TeqChar);	
    0302C E98C      LDI	R24,0x9C
    0302D E095      LDI	R25,5
    0302E 8399      STD	Y+1,R25
    0302F 8388      ST	Y,R24
    03030 E026      LDI	R18,6
    03031 E004      LDI	R16,4
    03032 940E 3804 CALL	_LCD_var_disp
(0219) 	 }
(0220) 	 if(page == 2){
    03034 3042      CPI	R20,2
    03035 F009      BEQ	0x3037
    03036 C03F      RJMP	0x3076
(0221) 	     LCD_var_disp(1,1,GUI_get_date());
    03037 D1A2      RCALL	_GUI_get_date
    03038 0158      MOVW	R10,R16
    03039 82B9      STD	Y+1,R11
    0303A 82A8      ST	Y,R10
    0303B E021      LDI	R18,1
    0303C E001      LDI	R16,1
    0303D 940E 3804 CALL	_LCD_var_disp
(0222) 		 LCD_const_disp(2,1,"冻伤危害性:");
    0303F E387      LDI	R24,0x37
    03040 E094      LDI	R25,4
    03041 8399      STD	Y+1,R25
    03042 8388      ST	Y,R24
    03043 E021      LDI	R18,1
    03044 E002      LDI	R16,2
    03045 940E 37D7 CALL	_LCD_const_disp
(0223) 	 if(Result.WeiHai==0){LCD_const_disp(3,1,"  冻伤危害性小");			 }
    03047 9020 05A2 LDS	R2,Result+90
    03049 2022      TST	R2
    0304A F449      BNE	0x3054
    0304B E288      LDI	R24,0x28
    0304C E094      LDI	R25,4
    0304D 8399      STD	Y+1,R25
    0304E 8388      ST	Y,R24
    0304F E021      LDI	R18,1
    03050 E003      LDI	R16,3
    03051 940E 37D7 CALL	_LCD_const_disp
    03053 C022      RJMP	0x3076
(0224) 	 else if(Result.WeiHai==1){	LCD_const_disp(3,1,"  冻伤危害性较大");	 }
    03054 9180 05A2 LDS	R24,Result+90
    03056 3081      CPI	R24,1
    03057 F449      BNE	0x3061
    03058 E187      LDI	R24,0x17
    03059 E094      LDI	R25,4
    0305A 8399      STD	Y+1,R25
    0305B 8388      ST	Y,R24
    0305C E021      LDI	R18,1
    0305D E003      LDI	R16,3
    0305E 940E 37D7 CALL	_LCD_const_disp
    03060 C015      RJMP	0x3076
(0225) 	 else if(Result.WeiHai==2){	LCD_const_disp(3,1,"  冻伤危害性很大");	 }
    03061 9180 05A2 LDS	R24,Result+90
    03063 3082      CPI	R24,2
    03064 F449      BNE	0x306E
    03065 E086      LDI	R24,6
    03066 E094      LDI	R25,4
    03067 8399      STD	Y+1,R25
    03068 8388      ST	Y,R24
    03069 E021      LDI	R18,1
    0306A E003      LDI	R16,3
    0306B 940E 37D7 CALL	_LCD_const_disp
    0306D C008      RJMP	0x3076
(0226) 	 else LCD_const_disp(3,1,"冻伤危害性小。");
    0306E EF87      LDI	R24,0xF7
    0306F E093      LDI	R25,3
    03070 8399      STD	Y+1,R25
    03071 8388      ST	Y,R24
    03072 E021      LDI	R18,1
    03073 E003      LDI	R16,3
    03074 940E 37D7 CALL	_LCD_const_disp
(0227) 	 }	  
(0228) 	 if(page==3){
    03076 3043      CPI	R20,3
    03077 F009      BEQ	0x3079
    03078 C061      RJMP	0x30DA
(0229) 	     LCD_const_disp(1,1,labelH);		
    03079 E682      LDI	R24,0x62
    0307A E092      LDI	R25,2
    0307B 8399      STD	Y+1,R25
    0307C 8388      ST	Y,R24
    0307D E021      LDI	R18,1
    0307E E001      LDI	R16,1
    0307F 940E 37D7 CALL	_LCD_const_disp
(0230) 	 	 switch( Result.WeiHai ){
    03081 9160 05A2 LDS	R22,Result+90
    03083 2777      CLR	R23
    03084 3060      CPI	R22,0
    03085 0767      CPC	R22,R23
    03086 F049      BEQ	0x3090
    03087 3061      CPI	R22,1
    03088 E0E0      LDI	R30,0
    03089 077E      CPC	R23,R30
    0308A F0F1      BEQ	0x30A9
    0308B 3062      CPI	R22,2
    0308C E0E0      LDI	R30,0
    0308D 077E      CPC	R23,R30
    0308E F199      BEQ	0x30C2
    0308F C04A      RJMP	0x30DA
(0231) 			case 0 :
(0232) 			LCD_const_disp(2,1,H01);
    03090 E88E      LDI	R24,0x8E
    03091 E092      LDI	R25,2
    03092 8399      STD	Y+1,R25
    03093 8388      ST	Y,R24
    03094 E021      LDI	R18,1
    03095 E002      LDI	R16,2
    03096 940E 37D7 CALL	_LCD_const_disp
(0233) 			LCD_const_disp(3,1,H02);
    03098 E98E      LDI	R24,0x9E
    03099 E092      LDI	R25,2
    0309A 8399      STD	Y+1,R25
    0309B 8388      ST	Y,R24
    0309C E021      LDI	R18,1
    0309D E003      LDI	R16,3
    0309E 940E 37D7 CALL	_LCD_const_disp
(0234) 			LCD_const_disp(4,1,H03);
    030A0 EA89      LDI	R24,0xA9
    030A1 E092      LDI	R25,2
    030A2 8399      STD	Y+1,R25
    030A3 8388      ST	Y,R24
    030A4 E021      LDI	R18,1
    030A5 E004      LDI	R16,4
    030A6 940E 37D7 CALL	_LCD_const_disp
(0235) 			break;
    030A8 C031      RJMP	0x30DA
(0236) 			case 1 : 
(0237) 			LCD_const_disp(2,1,H11);
    030A9 EC85      LDI	R24,0xC5
    030AA E092      LDI	R25,2
    030AB 8399      STD	Y+1,R25
    030AC 8388      ST	Y,R24
    030AD E021      LDI	R18,1
    030AE E002      LDI	R16,2
    030AF 940E 37D7 CALL	_LCD_const_disp
(0238) 			LCD_const_disp(3,1,H12);
    030B1 EA89      LDI	R24,0xA9
    030B2 E092      LDI	R25,2
    030B3 8399      STD	Y+1,R25
    030B4 8388      ST	Y,R24
    030B5 E021      LDI	R18,1
    030B6 E003      LDI	R16,3
    030B7 940E 37D7 CALL	_LCD_const_disp
(0239) 			LCD_const_disp(4,1,H13);
    030B9 ED8E      LDI	R24,0xDE
    030BA E092      LDI	R25,2
    030BB 8399      STD	Y+1,R25
    030BC 8388      ST	Y,R24
    030BD E021      LDI	R18,1
    030BE E004      LDI	R16,4
    030BF 940E 37D7 CALL	_LCD_const_disp
(0240) 			break ;	
    030C1 C018      RJMP	0x30DA
(0241) 			case 2 :
(0242) 			LCD_const_disp(2,1,H21);
    030C2 E182      LDI	R24,0x12
    030C3 E093      LDI	R25,3
    030C4 8399      STD	Y+1,R25
    030C5 8388      ST	Y,R24
    030C6 E021      LDI	R18,1
    030C7 E002      LDI	R16,2
    030C8 940E 37D7 CALL	_LCD_const_disp
(0243) 			LCD_const_disp(3,1,H22);
    030CA E284      LDI	R24,0x24
    030CB E093      LDI	R25,3
    030CC 8399      STD	Y+1,R25
    030CD 8388      ST	Y,R24
    030CE E021      LDI	R18,1
    030CF E003      LDI	R16,3
    030D0 940E 37D7 CALL	_LCD_const_disp
(0244) 			LCD_const_disp(4,1,H23);
    030D2 EA89      LDI	R24,0xA9
    030D3 E092      LDI	R25,2
    030D4 8399      STD	Y+1,R25
    030D5 8388      ST	Y,R24
    030D6 E021      LDI	R18,1
    030D7 E004      LDI	R16,4
    030D8 940E 37D7 CALL	_LCD_const_disp
(0245) 			break;
(0246) 			default : ;
(0247) 		}
(0248) 	 } 
(0249) 	 if(page==4){
    030DA 3044      CPI	R20,4
    030DB F009      BEQ	0x30DD
    030DC C086      RJMP	0x3163
(0250) 	 		LCD_const_disp(1,1,labelM);		
    030DD E780      LDI	R24,0x70
    030DE E092      LDI	R25,2
    030DF 8399      STD	Y+1,R25
    030E0 8388      ST	Y,R24
    030E1 E021      LDI	R18,1
    030E2 E001      LDI	R16,1
    030E3 940E 37D7 CALL	_LCD_const_disp
(0251) 	 		switch( Result.WeiHai ){
    030E5 9160 05A2 LDS	R22,Result+90
    030E7 2777      CLR	R23
    030E8 3060      CPI	R22,0
    030E9 0767      CPC	R22,R23
    030EA F059      BEQ	0x30F6
    030EB 3061      CPI	R22,1
    030EC E0E0      LDI	R30,0
    030ED 077E      CPC	R23,R30
    030EE F409      BNE	0x30F0
    030EF C052      RJMP	0x3142
    030F0 3062      CPI	R22,2
    030F1 E0E0      LDI	R30,0
    030F2 077E      CPC	R23,R30
    030F3 F409      BNE	0x30F5
    030F4 C066      RJMP	0x315B
    030F5 C06D      RJMP	0x3163
(0252) 	 			case 0 :
(0253) 				LCD_const_disp(2,1,M01);
    030F6 E88E      LDI	R24,0x8E
    030F7 E092      LDI	R25,2
    030F8 8399      STD	Y+1,R25
    030F9 8388      ST	Y,R24
    030FA E021      LDI	R18,1
    030FB E002      LDI	R16,2
    030FC 940E 37D7 CALL	_LCD_const_disp
(0254) 				LCD_const_disp(3,1,M02);
    030FE EA89      LDI	R24,0xA9
    030FF E092      LDI	R25,2
    03100 8399      STD	Y+1,R25
    03101 8388      ST	Y,R24
    03102 E021      LDI	R18,1
    03103 E003      LDI	R16,3
    03104 940E 37D7 CALL	_LCD_const_disp
(0255) 				if(Result.Temperature < 17.7){
    03106 9040 0573 LDS	R4,Result+43
    03108 9050 0574 LDS	R5,Result+44
    0310A 9020 0571 LDS	R2,Result+41
    0310C 9030 0572 LDS	R3,Result+42
    0310E EC00      LDI	R16,0xC0
    0310F E010      LDI	R17,0
    03110 940E 3EFC CALL	elpm32
    03112 933A      ST	-Y,R19
    03113 932A      ST	-Y,R18
    03114 931A      ST	-Y,R17
    03115 930A      ST	-Y,R16
    03116 0181      MOVW	R16,R2
    03117 0192      MOVW	R18,R4
    03118 940E 429A CALL	fpcmp2
    0311A F44C      BGE	0x3124
(0256) 				    LCD_const_disp(4,1,"戴面罩；禁油彩。");
    0311B EE86      LDI	R24,0xE6
    0311C E093      LDI	R25,3
    0311D 8399      STD	Y+1,R25
    0311E 8388      ST	Y,R24
    0311F E021      LDI	R18,1
    03120 E004      LDI	R16,4
    03121 940E 37D7 CALL	_LCD_const_disp
(0257) 				}
    03123 C03F      RJMP	0x3163
(0258) 				else if(Result.Temperature < 12){
    03124 9040 0573 LDS	R4,Result+43
    03126 9050 0574 LDS	R5,Result+44
    03128 9020 0571 LDS	R2,Result+41
    0312A 9030 0572 LDS	R3,Result+42
    0312C EB0C      LDI	R16,0xBC
    0312D E010      LDI	R17,0
    0312E 940E 3EFC CALL	elpm32
    03130 933A      ST	-Y,R19
    03131 932A      ST	-Y,R18
    03132 931A      ST	-Y,R17
    03133 930A      ST	-Y,R16
    03134 0181      MOVW	R16,R2
    03135 0192      MOVW	R18,R4
    03136 940E 429A CALL	fpcmp2
    03138 F554      BGE	0x3163
(0259) 				    LCD_const_disp(4,1,"禁油彩。        \0");
    03139 ED84      LDI	R24,0xD4
    0313A E093      LDI	R25,3
    0313B 8399      STD	Y+1,R25
    0313C 8388      ST	Y,R24
    0313D E021      LDI	R18,1
    0313E E004      LDI	R16,4
    0313F 940E 37D7 CALL	_LCD_const_disp
(0260) 				}
(0261) 				break;
    03141 C021      RJMP	0x3163
(0262) 				case 1 : 
(0263) 			    LCD_const_disp(2,1,M11);
    03142 E88E      LDI	R24,0x8E
    03143 E092      LDI	R25,2
    03144 8399      STD	Y+1,R25
    03145 8388      ST	Y,R24
    03146 E021      LDI	R18,1
    03147 E002      LDI	R16,2
    03148 940E 37D7 CALL	_LCD_const_disp
(0264) 				LCD_const_disp(3,1,M12);
    0314A EE8E      LDI	R24,0xEE
    0314B E092      LDI	R25,2
    0314C 8399      STD	Y+1,R25
    0314D 8388      ST	Y,R24
    0314E E021      LDI	R18,1
    0314F E003      LDI	R16,3
    03150 940E 37D7 CALL	_LCD_const_disp
(0265) 				LCD_const_disp(4,1,M13);
    03152 E080      LDI	R24,0
    03153 E093      LDI	R25,3
    03154 8399      STD	Y+1,R25
    03155 8388      ST	Y,R24
    03156 E021      LDI	R18,1
    03157 E004      LDI	R16,4
    03158 940E 37D7 CALL	_LCD_const_disp
(0266) 				break ;
    0315A C008      RJMP	0x3163
(0267) 				case 2 :
(0268) 				LCD_const_disp(2,1,M21);
    0315B E386      LDI	R24,0x36
    0315C E093      LDI	R25,3
    0315D 8399      STD	Y+1,R25
    0315E 8388      ST	Y,R24
    0315F E021      LDI	R18,1
    03160 E002      LDI	R16,2
    03161 940E 37D7 CALL	_LCD_const_disp
(0269) 				break ;
(0270) 				default :;
(0271) 	 		}
(0272) 	 }
(0273) 	 if(page==5){
    03163 3045      CPI	R20,5
    03164 F009      BEQ	0x3166
    03165 C071      RJMP	0x31D7
(0274) 	     LCD_const_disp(1,1,labelL);		
    03166 E880      LDI	R24,0x80
    03167 E092      LDI	R25,2
    03168 8399      STD	Y+1,R25
    03169 8388      ST	Y,R24
    0316A E021      LDI	R18,1
    0316B E001      LDI	R16,1
    0316C 940E 37D7 CALL	_LCD_const_disp
(0275) 	 	 switch( Result.WeiHai ){	
    0316E 9140 05A2 LDS	R20,Result+90
    03170 2755      CLR	R21
    03171 3040      CPI	R20,0
    03172 0745      CPC	R20,R21
    03173 F059      BEQ	0x317F
    03174 3041      CPI	R20,1
    03175 E0E0      LDI	R30,0
    03176 075E      CPC	R21,R30
    03177 F409      BNE	0x3179
    03178 C03D      RJMP	0x31B6
    03179 3042      CPI	R20,2
    0317A E0E0      LDI	R30,0
    0317B 075E      CPC	R21,R30
    0317C F409      BNE	0x317E
    0317D C051      RJMP	0x31CF
    0317E C058      RJMP	0x31D7
(0276) 		     case 0 :
(0277) 			 LCD_const_disp(2,1,L01);
    0317F EB8B      LDI	R24,0xBB
    03180 E092      LDI	R25,2
    03181 8399      STD	Y+1,R25
    03182 8388      ST	Y,R24
    03183 E021      LDI	R18,1
    03184 E002      LDI	R16,2
    03185 940E 37D7 CALL	_LCD_const_disp
(0278) 			 if(Result.Temperature < -12) {
    03187 9040 0573 LDS	R4,Result+43
    03189 9050 0574 LDS	R5,Result+44
    0318B 9020 0571 LDS	R2,Result+41
    0318D 9030 0572 LDS	R3,Result+42
    0318F EB08      LDI	R16,0xB8
    03190 E010      LDI	R17,0
    03191 940E 3EFC CALL	elpm32
    03193 933A      ST	-Y,R19
    03194 932A      ST	-Y,R18
    03195 931A      ST	-Y,R17
    03196 930A      ST	-Y,R16
    03197 0181      MOVW	R16,R2
    03198 0192      MOVW	R18,R4
    03199 940E 429A CALL	fpcmp2
    0319B F48C      BGE	0x31AD
(0279) 			 LCD_const_disp(3,1,L02);
    0319C EC85      LDI	R24,0xC5
    0319D E092      LDI	R25,2
    0319E 8399      STD	Y+1,R25
    0319F 8388      ST	Y,R24
    031A0 E021      LDI	R18,1
    031A1 E003      LDI	R16,3
    031A2 940E 37D7 CALL	_LCD_const_disp
(0280) 			 LCD_const_disp(4,1,L03);
    031A4 EC8F      LDI	R24,0xCF
    031A5 E092      LDI	R25,2
    031A6 8399      STD	Y+1,R25
    031A7 8388      ST	Y,R24
    031A8 E021      LDI	R18,1
    031A9 E004      LDI	R16,4
    031AA 940E 37D7 CALL	_LCD_const_disp
(0281) 			 } 
    031AC C02A      RJMP	0x31D7
(0282) 			 else {
(0283) 			 LCD_const_disp(3,1,L03);
    031AD EC8F      LDI	R24,0xCF
    031AE E092      LDI	R25,2
    031AF 8399      STD	Y+1,R25
    031B0 8388      ST	Y,R24
    031B1 E021      LDI	R18,1
    031B2 E003      LDI	R16,3
    031B3 940E 37D7 CALL	_LCD_const_disp
(0284) 			 }
(0285) 			 break;
    031B5 C021      RJMP	0x31D7
(0286) 			 case 1: 
(0287) 			 LCD_const_disp(2,1,L11);
    031B6 E182      LDI	R24,0x12
    031B7 E093      LDI	R25,3
    031B8 8399      STD	Y+1,R25
    031B9 8388      ST	Y,R24
    031BA E021      LDI	R18,1
    031BB E002      LDI	R16,2
    031BC 940E 37D7 CALL	_LCD_const_disp
(0288) 			 LCD_const_disp(3,1,L12);
    031BE E284      LDI	R24,0x24
    031BF E093      LDI	R25,3
    031C0 8399      STD	Y+1,R25
    031C1 8388      ST	Y,R24
    031C2 E021      LDI	R18,1
    031C3 E003      LDI	R16,3
    031C4 940E 37D7 CALL	_LCD_const_disp
(0289) 			 LCD_const_disp(3,1,L13);
    031C6 EA89      LDI	R24,0xA9
    031C7 E092      LDI	R25,2
    031C8 8399      STD	Y+1,R25
    031C9 8388      ST	Y,R24
    031CA E021      LDI	R18,1
    031CB E003      LDI	R16,3
    031CC 940E 37D7 CALL	_LCD_const_disp
(0290) 			 break ;
    031CE C008      RJMP	0x31D7
(0291) 			 case 2 :
(0292) 			 LCD_const_disp(2,1,L21);
    031CF E386      LDI	R24,0x36
    031D0 E093      LDI	R25,3
    031D1 8399      STD	Y+1,R25
    031D2 8388      ST	Y,R24
    031D3 E021      LDI	R18,1
    031D4 E002      LDI	R16,2
    031D5 940E 37D7 CALL	_LCD_const_disp
(0293) 			 break;
(0294) 			 default : ;
(0295) 		} //end switch
(0296) 	}  //end if
    031D7 9622      ADIW	R28,2
    031D8 940C 3F9A JMP	pop_xgsetF00C
(0297) }
(0298) char * GUI_get_date(void) {  
(0299)   //格式：2012年12月11日19:00:00
(0300)     GUI_date[0]=Result.Date[4]; 
_GUI_get_date:
    031DA 9020 0562 LDS	R2,Result+26
    031DC 9220 0345 STS	GUI_date,R2
(0301)     GUI_date[1]=Result.Date[5];
    031DE 9020 0563 LDS	R2,Result+27
    031E0 9220 0346 STS	GUI_date+1,R2
(0302)     GUI_date[4]=Result.Date[6];
    031E2 9020 0564 LDS	R2,Result+28
    031E4 9220 0349 STS	GUI_date+4,R2
(0303)     GUI_date[5]=Result.Date[7];
    031E6 9020 0565 LDS	R2,Result+29
    031E8 9220 034A STS	GUI_date+5,R2
(0304)     GUI_date[8]=Result.Time[0];
    031EA 9020 0567 LDS	R2,Result+31
    031EC 9220 034D STS	GUI_date+8,R2
(0305)     GUI_date[9]=Result.Time[1];
    031EE 9020 0568 LDS	R2,Result+32
    031F0 9220 034E STS	GUI_date+9,R2
(0306)     GUI_date[11]=Result.Time[4];
    031F2 9020 056B LDS	R2,Result+35
    031F4 9220 0350 STS	GUI_date+11,R2
(0307)     GUI_date[12]=Result.Time[5];
    031F6 9020 056C LDS	R2,Result+36
    031F8 9220 0351 STS	GUI_date+12,R2
(0308)     GUI_date[14]=Result.Time[8];
    031FA 9020 056F LDS	R2,Result+39
    031FC 9220 0353 STS	GUI_date+14,R2
(0309)     GUI_date[15]=Result.Time[9];
    031FE 9020 0570 LDS	R2,Result+40
    03200 9220 0354 STS	GUI_date+15,R2
(0310)     GUI_date[16]='\0';
    03202 2422      CLR	R2
    03203 9220 0355 STS	GUI_date+16,R2
(0311)     return GUI_date;
    03205 E405      LDI	R16,0x45
    03206 E013      LDI	R17,3
    03207 9508      RET
_GUI_set_time:
  GUI_down             --> Y,+5
  GUI_up               --> Y,+2
  pT                   --> R14
  ary                  --> R12
  p                    --> Y,+10
  i                    --> R20
  keyc                 --> R22
  pD                   --> Y,+8
    03208 940E 3F74 CALL	push_xgsetF0FC
    0320A 972B      SBIW	R28,0xB
(0312) }
(0313) //设置时间 菜单 
(0314) void GUI_set_time(void){
(0315)     unsigned char p=2;
    0320B E082      LDI	R24,2
    0320C 878A      STD	Y+10,R24
(0316) 	char GUI_up[]= "↑";
    0320D E586      LDI	R24,0x56
    0320E E093      LDI	R25,3
    0320F 01FE      MOVW	R30,R28
    03210 9632      ADIW	R30,2
    03211 E003      LDI	R16,3
    03212 E010      LDI	R17,0
    03213 93FA      ST	-Y,R31
    03214 93EA      ST	-Y,R30
    03215 939A      ST	-Y,R25
    03216 938A      ST	-Y,R24
    03217 940E 401B CALL	asgnblk
(0317) 	char GUI_down[]= "↓";
    03219 E589      LDI	R24,0x59
    0321A E093      LDI	R25,3
    0321B 01FE      MOVW	R30,R28
    0321C 9635      ADIW	R30,5
    0321D E003      LDI	R16,3
    0321E E010      LDI	R17,0
    0321F 93FA      ST	-Y,R31
    03220 93EA      ST	-Y,R30
    03221 939A      ST	-Y,R25
    03222 938A      ST	-Y,R24
    03223 940E 401B CALL	asgnblk
(0318) 	char *pD=NULL,*pT=NULL;
    03225 2400      CLR	R0
    03226 2411      CLR	R1
    03227 8619      STD	Y+9,R1
    03228 8608      STD	Y+8,R0
(0319) 	char *ary=GUI_up;
    03229 01CE      MOVW	R24,R28
    0322A 9602      ADIW	R24,2
    0322B 016C      MOVW	R12,R24
(0320) 	unsigned char i=0,keyc=NO_KEY;
    0322C 2744      CLR	R20
    0322D 2766      CLR	R22
(0321) 	LCD_CLR(); //清屏
    0322E 940E 387D CALL	_LCD_CLR
(0322) 	pD="2012年12月31日\0";
    03230 EC84      LDI	R24,0xC4
    03231 E093      LDI	R25,3
    03232 8799      STD	Y+9,R25
    03233 8788      STD	Y+8,R24
(0323) 	pT=Result.Time;
    03234 E687      LDI	R24,0x67
    03235 E095      LDI	R25,5
    03236 017C      MOVW	R14,R24
(0324) 	LCD_const_disp(1,1,"时间设置:       ");
    03237 EB83      LDI	R24,0xB3
    03238 E093      LDI	R25,3
    03239 8399      STD	Y+1,R25
    0323A 8388      ST	Y,R24
    0323B E021      LDI	R18,1
    0323C E001      LDI	R16,1
    0323D 940E 37D7 CALL	_LCD_const_disp
(0325) 	LCD_const_disp(4,7,"保存");
    0323F EA8E      LDI	R24,0xAE
    03240 E093      LDI	R25,3
    03241 8399      STD	Y+1,R25
    03242 8388      ST	Y,R24
    03243 E027      LDI	R18,7
    03244 E004      LDI	R16,4
    03245 940E 37D7 CALL	_LCD_const_disp
(0326) 	LCD_var_disp(3,p,ary);
    03247 82D9      STD	Y+1,R13
    03248 82C8      ST	Y,R12
    03249 852A      LDD	R18,Y+10
    0324A E003      LDI	R16,3
    0324B 940E 3804 CALL	_LCD_var_disp
(0327) 	LCD_var_disp(2,1,pD);
    0324D 8408      LDD	R0,Y+8
    0324E 8419      LDD	R1,Y+9
    0324F 8219      STD	Y+1,R1
    03250 8208      ST	Y,R0
    03251 E021      LDI	R18,1
    03252 E002      LDI	R16,2
    03253 940E 3804 CALL	_LCD_var_disp
(0328) 	LCD_var_disp(4,1,pT);
    03255 82F9      STD	Y+1,R15
    03256 82E8      ST	Y,R14
    03257 E021      LDI	R18,1
    03258 E004      LDI	R16,4
    03259 940E 3804 CALL	_LCD_var_disp
(0329) 	delayms(250);
    0325B EF0A      LDI	R16,0xFA
    0325C E010      LDI	R17,0
    0325D 940E 23FF CALL	_delayms
    0325F C1EC      RJMP	0x344C
(0330) 	while(1){
(0331) 	    keyc=kbscan();
    03260 940E 3DC6 CALL	_kbscan
    03262 2F60      MOV	R22,R16
(0332) 		pD[2]=Result.Date[2];
    03263 9020 0560 LDS	R2,Result+24
    03265 85E8      LDD	R30,Y+8
    03266 85F9      LDD	R31,Y+9
    03267 8222      STD	Z+2,R2
(0333) 		pD[3]=Result.Date[3];
    03268 9020 0561 LDS	R2,Result+25
    0326A 8223      STD	Z+3,R2
(0334) 		pD[6]=Result.Date[4];
    0326B 9020 0562 LDS	R2,Result+26
    0326D 8226      STD	Z+6,R2
(0335) 		pD[7]=Result.Date[5];
    0326E 9020 0563 LDS	R2,Result+27
    03270 8227      STD	Z+7,R2
(0336) 		pD[10]=Result.Date[6];
    03271 9020 0564 LDS	R2,Result+28
    03273 8622      STD	Z+10,R2
(0337) 		pD[11]=Result.Date[7];  
    03274 9020 0565 LDS	R2,Result+29
    03276 8623      STD	Z+11,R2
(0338) 
(0339) 		switch(i){
    03277 2EA4      MOV	R10,R20
    03278 24BB      CLR	R11
    03279 20AA      TST	R10
    0327A F411      BNE	0x327D
    0327B 20BB      TST	R11
    0327C F0D9      BEQ	0x3298
    0327D 01C5      MOVW	R24,R10
    0327E 3081      CPI	R24,1
    0327F E0E0      LDI	R30,0
    03280 079E      CPC	R25,R30
    03281 F409      BNE	0x3283
    03282 C049      RJMP	0x32CC
    03283 3082      CPI	R24,2
    03284 E0E0      LDI	R30,0
    03285 079E      CPC	R25,R30
    03286 F409      BNE	0x3288
    03287 C07D      RJMP	0x3305
    03288 3083      CPI	R24,3
    03289 E0E0      LDI	R30,0
    0328A 079E      CPC	R25,R30
    0328B F409      BNE	0x328D
    0328C C0C1      RJMP	0x334E
    0328D 3084      CPI	R24,4
    0328E E0E0      LDI	R30,0
    0328F 079E      CPC	R25,R30
    03290 F409      BNE	0x3292
    03291 C0F6      RJMP	0x3388
    03292 3085      CPI	R24,5
    03293 E0E0      LDI	R30,0
    03294 079E      CPC	R25,R30
    03295 F409      BNE	0x3297
    03296 C12A      RJMP	0x33C1
    03297 C165      RJMP	0x33FD
(0340)             case 0: p=2;ary=GUI_up;  //年
    03298 E082      LDI	R24,2
    03299 878A      STD	Y+10,R24
    0329A 01CE      MOVW	R24,R28
    0329B 9602      ADIW	R24,2
    0329C 016C      MOVW	R12,R24
(0341) 		 	  	 if(keyc==up){
    0329D 316E      CPI	R22,0x1E
    0329E F491      BNE	0x32B1
(0342) 				     if(time_buf[1]<0x99){ 
    0329F 9180 04ED LDS	R24,time_buf+1
    032A1 3989      CPI	R24,0x99
    032A2 F008      BCS	0x32A4
    032A3 C159      RJMP	0x33FD
(0343) 					     time_buf[1]++;
    032A4 5F8F      SUBI	R24,0xFF
    032A5 9380 04ED STS	time_buf+1,R24
(0344) 						 if((time_buf[1]&0x0f)==0x0a) 
    032A7 708F      ANDI	R24,0xF
    032A8 308A      CPI	R24,0xA
    032A9 F009      BEQ	0x32AB
    032AA C152      RJMP	0x33FD
(0345) 						     time_buf[1]=time_buf[1]+6;
    032AB 9180 04ED LDS	R24,time_buf+1
    032AD 5F8A      SUBI	R24,0xFA
    032AE 9380 04ED STS	time_buf+1,R24
(0346) 					 }
(0347) 												     
(0348) 				}				  
    032B0 C14C      RJMP	0x33FD
(0349)  					        
(0350) 			    else if(keyc==down){ 
    032B1 316D      CPI	R22,0x1D
    032B2 F4A1      BNE	0x32C7
(0351) 				    if(time_buf[1]>0x00){
    032B3 E080      LDI	R24,0
    032B4 9020 04ED LDS	R2,time_buf+1
    032B6 1582      CP	R24,R2
    032B7 F008      BCS	0x32B9
    032B8 C144      RJMP	0x33FD
(0352) 				        time_buf[1]--;
    032B9 2D82      MOV	R24,R2
    032BA 5081      SUBI	R24,1
    032BB 9380 04ED STS	time_buf+1,R24
(0353) 						if((time_buf[1]&0x0f)==0x0f) 
    032BD 708F      ANDI	R24,0xF
    032BE 308F      CPI	R24,0xF
    032BF F009      BEQ	0x32C1
    032C0 C13C      RJMP	0x33FD
(0354) 						    time_buf[1]=time_buf[1]-6;
    032C1 9180 04ED LDS	R24,time_buf+1
    032C3 5086      SUBI	R24,6
    032C4 9380 04ED STS	time_buf+1,R24
(0355) 		 	  	 		 }
(0356) 												   
(0357) 					}			   		
    032C6 C136      RJMP	0x33FD
(0358) 				else if(keyc==right) {i=1;}
    032C7 3167      CPI	R22,0x17
    032C8 F009      BEQ	0x32CA
    032C9 C133      RJMP	0x33FD
    032CA E041      LDI	R20,1
(0359) 				break;
    032CB C131      RJMP	0x33FD
(0360) 		 case 1:p=4;ary=GUI_up;  //月
    032CC E084      LDI	R24,4
    032CD 878A      STD	Y+10,R24
    032CE 01CE      MOVW	R24,R28
    032CF 9602      ADIW	R24,2
    032D0 016C      MOVW	R12,R24
(0361) 		  	  	if(keyc==up){
    032D1 316E      CPI	R22,0x1E
    032D2 F499      BNE	0x32E6
(0362) 				    if(time_buf[2]<0x12){  
    032D3 9180 04EE LDS	R24,time_buf+2
    032D5 3182      CPI	R24,0x12
    032D6 F460      BCC	0x32E3
(0363) 					    time_buf[2]++;	
    032D7 5F8F      SUBI	R24,0xFF
    032D8 9380 04EE STS	time_buf+2,R24
(0364) 						if((time_buf[2]&0x0f)==0x0a) time_buf[2]+=6;
    032DA 708F      ANDI	R24,0xF
    032DB 308A      CPI	R24,0xA
    032DC F449      BNE	0x32E6
    032DD 9180 04EE LDS	R24,time_buf+2
    032DF 5F8A      SUBI	R24,0xFA
    032E0 9380 04EE STS	time_buf+2,R24
(0365) 					}
    032E2 C003      RJMP	0x32E6
(0366) 					else 
(0367) 					    time_buf[2]=0x01;
    032E3 E081      LDI	R24,1
    032E4 9380 04EE STS	time_buf+2,R24
(0368) 				}						 
(0369) 				if(keyc==down){ 
    032E6 316D      CPI	R22,0x1D
    032E7 F4A9      BNE	0x32FD
(0370) 				    if(time_buf[2]>0x01){  
    032E8 E081      LDI	R24,1
    032E9 9020 04EE LDS	R2,time_buf+2
    032EB 1582      CP	R24,R2
    032EC F468      BCC	0x32FA
(0371) 					    time_buf[2]--;	
    032ED 2D82      MOV	R24,R2
    032EE 5081      SUBI	R24,1
    032EF 9380 04EE STS	time_buf+2,R24
(0372) 						if((time_buf[2]&0x0f)==0x0f) 
    032F1 708F      ANDI	R24,0xF
    032F2 308F      CPI	R24,0xF
    032F3 F449      BNE	0x32FD
(0373) 						    time_buf[2]-=6;
    032F4 9180 04EE LDS	R24,time_buf+2
    032F6 5086      SUBI	R24,6
    032F7 9380 04EE STS	time_buf+2,R24
(0374) 			  		}
    032F9 C003      RJMP	0x32FD
(0375) 				    else 
(0376) 					    time_buf[2]=0x12;						
    032FA E182      LDI	R24,0x12
    032FB 9380 04EE STS	time_buf+2,R24
(0377) 				}						 							
(0378) 				if(keyc==left){
    032FD 316B      CPI	R22,0x1B
    032FE F409      BNE	0x3300
(0379) 				    i=0;   
    032FF 2744      CLR	R20
(0380) 				}									
(0381) 				if(keyc==right){
    03300 3167      CPI	R22,0x17
    03301 F009      BEQ	0x3303
    03302 C0FA      RJMP	0x33FD
(0382) 				    i=2;   
    03303 E042      LDI	R20,2
(0383) 				}  
(0384) 				break;
    03304 C0F8      RJMP	0x33FD
(0385) 	 	 case 2: p=6;ary=GUI_up;
    03305 E086      LDI	R24,6
    03306 878A      STD	Y+10,R24
    03307 01CE      MOVW	R24,R28
    03308 9602      ADIW	R24,2
    03309 016C      MOVW	R12,R24
(0386) 		 	  	 if(keyc==up){ 
    0330A 316E      CPI	R22,0x1E
    0330B F519      BNE	0x332F
(0387) 				     if(time_buf[3]<0x31){ 
    0330C 9180 04EF LDS	R24,time_buf+3
    0330E 3381      CPI	R24,0x31
    0330F F5B0      BCC	0x3346
(0388) 				         time_buf[3]++;
    03310 5F8F      SUBI	R24,0xFF
    03311 9380 04EF STS	time_buf+3,R24
(0389) 						 if ((time_buf[3]&0x0f)==0x0a) time_buf[3]=time_buf[3]+6;
    03313 708F      ANDI	R24,0xF
    03314 308A      CPI	R24,0xA
    03315 F429      BNE	0x331B
    03316 9180 04EF LDS	R24,time_buf+3
    03318 5F8A      SUBI	R24,0xFA
    03319 9380 04EF STS	time_buf+3,R24
(0390) 						 if(  //2 4 6 9 11 月最大30天
(0391) 						  ( ((time_buf[2]==0x02) || (time_buf[2]==0x04)|| (time_buf[2]==0x06)||
    0331B 9180 04EE LDS	R24,time_buf+2
    0331D 3082      CPI	R24,2
    0331E F041      BEQ	0x3327
    0331F 3084      CPI	R24,4
    03320 F031      BEQ	0x3327
    03321 3086      CPI	R24,6
    03322 F021      BEQ	0x3327
    03323 3089      CPI	R24,0x9
    03324 F011      BEQ	0x3327
    03325 3181      CPI	R24,0x11
    03326 F4F9      BNE	0x3346
    03327 9180 04EF LDS	R24,time_buf+3
    03329 3381      CPI	R24,0x31
    0332A F4D9      BNE	0x3346
(0392) 						  (time_buf[2]==0x09)||(time_buf[2]==0x11))&&(time_buf[3]==0x31))){
(0393) 						      time_buf[3]=0x30;
    0332B E380      LDI	R24,0x30
    0332C 9380 04EF STS	time_buf+3,R24
(0394) 						}
(0395) 				     }
(0396)  									  
(0397)  				 }
    0332E C017      RJMP	0x3346
(0398) 			     else if(keyc==down){ 
    0332F 316D      CPI	R22,0x1D
    03330 F4A9      BNE	0x3346
(0399) 				      if(time_buf[3]>0x01){  
    03331 E081      LDI	R24,1
    03332 9020 04EF LDS	R2,time_buf+3
    03334 1582      CP	R24,R2
    03335 F468      BCC	0x3343
(0400) 					     time_buf[3]--;
    03336 2D82      MOV	R24,R2
    03337 5081      SUBI	R24,1
    03338 9380 04EF STS	time_buf+3,R24
(0401) 				 	  	 if((time_buf[3]&0x0f)==0x0f) time_buf[3]=time_buf[3]-6;
    0333A 708F      ANDI	R24,0xF
    0333B 308F      CPI	R24,0xF
    0333C F449      BNE	0x3346
    0333D 9180 04EF LDS	R24,time_buf+3
    0333F 5086      SUBI	R24,6
    03340 9380 04EF STS	time_buf+3,R24
(0402) 		 	  	 	 }
    03342 C003      RJMP	0x3346
(0403) 					 else time_buf[3]=0x31;						
    03343 E381      LDI	R24,0x31
    03344 9380 04EF STS	time_buf+3,R24
(0404) 											   
(0405) 				}
(0406) 				if(keyc==left) {i=1;  }						 			   		
    03346 316B      CPI	R22,0x1B
    03347 F409      BNE	0x3349
    03348 E041      LDI	R20,1
(0407) 				if(keyc==right) {i=3;    }  	
    03349 3167      CPI	R22,0x17
    0334A F009      BEQ	0x334C
    0334B C0B1      RJMP	0x33FD
    0334C E043      LDI	R20,3
(0408) 				break;
    0334D C0AF      RJMP	0x33FD
(0409) 		case 3:p=1;ary=GUI_down;
    0334E 2400      CLR	R0
    0334F 9403      INC	R0
    03350 860A      STD	Y+10,R0
    03351 01CE      MOVW	R24,R28
    03352 9605      ADIW	R24,5
    03353 016C      MOVW	R12,R24
(0410)  	  	if(keyc==up){ if(time_buf[4]<0x23){  time_buf[4]++;	
    03354 316E      CPI	R22,0x1E
    03355 F499      BNE	0x3369
    03356 9180 04F0 LDS	R24,time_buf+4
    03358 3283      CPI	R24,0x23
    03359 F460      BCC	0x3366
    0335A 5F8F      SUBI	R24,0xFF
    0335B 9380 04F0 STS	time_buf+4,R24
(0411) 													if((time_buf[4]&0x0f)==0x0a) time_buf[4]+=6;
    0335D 708F      ANDI	R24,0xF
    0335E 308A      CPI	R24,0xA
    0335F F449      BNE	0x3369
    03360 9180 04F0 LDS	R24,time_buf+4
    03362 5F8A      SUBI	R24,0xFA
    03363 9380 04F0 STS	time_buf+4,R24
(0412) 													 
(0413) 													
(0414) 												 }
    03365 C003      RJMP	0x3369
(0415) 							else time_buf[4]=0x00;
    03366 2422      CLR	R2
    03367 9220 04F0 STS	time_buf+4,R2
(0416) 						  }						 
(0417) 				if(keyc==down){ if(time_buf[4]>0x00){  time_buf[4]--;	
    03369 316D      CPI	R22,0x1D
    0336A F4A9      BNE	0x3380
    0336B E080      LDI	R24,0
    0336C 9020 04F0 LDS	R2,time_buf+4
    0336E 1582      CP	R24,R2
    0336F F468      BCC	0x337D
    03370 2D82      MOV	R24,R2
    03371 5081      SUBI	R24,1
    03372 9380 04F0 STS	time_buf+4,R24
(0418) 													if((time_buf[4]&0x0f)==0x0f) time_buf[4]-=6;
    03374 708F      ANDI	R24,0xF
    03375 308F      CPI	R24,0xF
    03376 F449      BNE	0x3380
    03377 9180 04F0 LDS	R24,time_buf+4
    03379 5086      SUBI	R24,6
    0337A 9380 04F0 STS	time_buf+4,R24
(0419) 													
(0420) 												 }
    0337C C003      RJMP	0x3380
(0421) 							 else time_buf[4]=0x23;						
    0337D E283      LDI	R24,0x23
    0337E 9380 04F0 STS	time_buf+4,R24
(0422) 						  }	
(0423) 		if(keyc==left ) {i=2;   } 				  
    03380 316B      CPI	R22,0x1B
    03381 F409      BNE	0x3383
    03382 E042      LDI	R20,2
(0424) 		if(keyc==right) {i=4;    } 
    03383 3167      CPI	R22,0x17
    03384 F009      BEQ	0x3386
    03385 C077      RJMP	0x33FD
    03386 E044      LDI	R20,4
(0425) 		break;						  					 			
    03387 C075      RJMP	0x33FD
(0426)  case 4:p=3;ary=GUI_down;
    03388 E083      LDI	R24,3
    03389 878A      STD	Y+10,R24
    0338A 01CE      MOVW	R24,R28
    0338B 9605      ADIW	R24,5
    0338C 016C      MOVW	R12,R24
(0427)  	  	if(keyc==up){ if(time_buf[5]<0x59){  time_buf[5]++;	
    0338D 316E      CPI	R22,0x1E
    0338E F499      BNE	0x33A2
    0338F 9180 04F1 LDS	R24,time_buf+5
    03391 3589      CPI	R24,0x59
    03392 F460      BCC	0x339F
    03393 5F8F      SUBI	R24,0xFF
    03394 9380 04F1 STS	time_buf+5,R24
(0428) 											 if((time_buf[5]&0x0f)==0x0a) time_buf[5]+=6;
    03396 708F      ANDI	R24,0xF
    03397 308A      CPI	R24,0xA
    03398 F449      BNE	0x33A2
    03399 9180 04F1 LDS	R24,time_buf+5
    0339B 5F8A      SUBI	R24,0xFA
    0339C 9380 04F1 STS	time_buf+5,R24
(0429) 										  }
    0339E C003      RJMP	0x33A2
(0430) 					  else time_buf[5]=0x00;
    0339F 2422      CLR	R2
    033A0 9220 04F1 STS	time_buf+5,R2
(0431) 					}						 
(0432) 		if(keyc==down){ if(time_buf[5]>0x00){  time_buf[5]--;	
    033A2 316D      CPI	R22,0x1D
    033A3 F4A9      BNE	0x33B9
    033A4 E080      LDI	R24,0
    033A5 9020 04F1 LDS	R2,time_buf+5
    033A7 1582      CP	R24,R2
    033A8 F468      BCC	0x33B6
    033A9 2D82      MOV	R24,R2
    033AA 5081      SUBI	R24,1
    033AB 9380 04F1 STS	time_buf+5,R24
(0433) 												if((time_buf[5]&0x0f)==0x0f) time_buf[5]-=6;
    033AD 708F      ANDI	R24,0xF
    033AE 308F      CPI	R24,0xF
    033AF F449      BNE	0x33B9
    033B0 9180 04F1 LDS	R24,time_buf+5
    033B2 5086      SUBI	R24,6
    033B3 9380 04F1 STS	time_buf+5,R24
(0434) 											}
    033B5 C003      RJMP	0x33B9
(0435) 						else time_buf[5]=0x59;						
    033B6 E589      LDI	R24,0x59
    033B7 9380 04F1 STS	time_buf+5,R24
(0436) 					  }
(0437) 		if(keyc==left ) {i=3;    } 		  						 								  			
    033B9 316B      CPI	R22,0x1B
    033BA F409      BNE	0x33BC
    033BB E043      LDI	R20,3
(0438)  		if(keyc==right) {i=5;   }	
    033BC 3167      CPI	R22,0x17
    033BD F009      BEQ	0x33BF
    033BE C03E      RJMP	0x33FD
    033BF E045      LDI	R20,5
(0439) 		break;			   
    033C0 C03C      RJMP	0x33FD
(0440)  case 5:p=5;ary=GUI_down;
    033C1 E085      LDI	R24,5
    033C2 878A      STD	Y+10,R24
    033C3 01CE      MOVW	R24,R28
    033C4 9605      ADIW	R24,5
    033C5 016C      MOVW	R12,R24
(0441)  	  	if(keyc==up){ if(time_buf[6]<0x59){  time_buf[6]++;	
    033C6 316E      CPI	R22,0x1E
    033C7 F499      BNE	0x33DB
    033C8 9180 04F2 LDS	R24,time_buf+6
    033CA 3589      CPI	R24,0x59
    033CB F460      BCC	0x33D8
    033CC 5F8F      SUBI	R24,0xFF
    033CD 9380 04F2 STS	time_buf+6,R24
(0442) 											 if((time_buf[6]&0x0f)==0x0a) time_buf[6]+=6;
    033CF 708F      ANDI	R24,0xF
    033D0 308A      CPI	R24,0xA
    033D1 F449      BNE	0x33DB
    033D2 9180 04F2 LDS	R24,time_buf+6
    033D4 5F8A      SUBI	R24,0xFA
    033D5 9380 04F2 STS	time_buf+6,R24
(0443) 										 }
    033D7 C003      RJMP	0x33DB
(0444) 					  else time_buf[6]=0x00;
    033D8 2422      CLR	R2
    033D9 9220 04F2 STS	time_buf+6,R2
(0445) 					}						 
(0446) 		if(keyc==down){ if(time_buf[6]>0x00){  time_buf[6]--;	
    033DB 316D      CPI	R22,0x1D
    033DC F4A9      BNE	0x33F2
    033DD E080      LDI	R24,0
    033DE 9020 04F2 LDS	R2,time_buf+6
    033E0 1582      CP	R24,R2
    033E1 F468      BCC	0x33EF
    033E2 2D82      MOV	R24,R2
    033E3 5081      SUBI	R24,1
    033E4 9380 04F2 STS	time_buf+6,R24
(0447) 						if((time_buf[6]&0x0f)==0x0f) time_buf[6]-=6;
    033E6 708F      ANDI	R24,0xF
    033E7 308F      CPI	R24,0xF
    033E8 F449      BNE	0x33F2
    033E9 9180 04F2 LDS	R24,time_buf+6
    033EB 5086      SUBI	R24,6
    033EC 9380 04F2 STS	time_buf+6,R24
(0448) 					  }
    033EE C003      RJMP	0x33F2
(0449) 		else time_buf[6]=0x59;		}				
    033EF E589      LDI	R24,0x59
    033F0 9380 04F2 STS	time_buf+6,R24
(0450) 		if(keyc==left ) {i=4;    } 		  				 														   
    033F2 316B      CPI	R22,0x1B
    033F3 F409      BNE	0x33F5
    033F4 E044      LDI	R20,4
(0451) 		if(keyc==right) {i=6;p=1;ary=NULL;}  
    033F5 3167      CPI	R22,0x17
    033F6 F431      BNE	0x33FD
    033F7 E046      LDI	R20,6
    033F8 2400      CLR	R0
    033F9 9403      INC	R0
    033FA 860A      STD	Y+10,R0
    033FB 24CC      CLR	R12
    033FC 24DD      CLR	R13
(0452) 		break;           
(0453) 							 
(0454) 		 }//endcase
(0455)  		 dateRefresh(0);
    033FD 2700      CLR	R16
    033FE D06E      RCALL	_dateRefresh
(0456) 		 
(0457) 		 LCD_const_disp(3,1,"                "); //清空箭头 
    033FF E98D      LDI	R24,0x9D
    03400 E093      LDI	R25,3
    03401 8399      STD	Y+1,R25
    03402 8388      ST	Y,R24
    03403 E021      LDI	R18,1
    03404 E003      LDI	R16,3
    03405 940E 37D7 CALL	_LCD_const_disp
(0458)  		 LCD_var_disp(3,p,ary); //显示箭头 
    03407 82D9      STD	Y+1,R13
    03408 82C8      ST	Y,R12
    03409 852A      LDD	R18,Y+10
    0340A E003      LDI	R16,3
    0340B 940E 3804 CALL	_LCD_var_disp
(0459)  		 LCD_var_disp(2,1,pD);  //显示日期
    0340D 8408      LDD	R0,Y+8
    0340E 8419      LDD	R1,Y+9
    0340F 8219      STD	Y+1,R1
    03410 8208      ST	Y,R0
    03411 E021      LDI	R18,1
    03412 E002      LDI	R16,2
    03413 940E 3804 CALL	_LCD_var_disp
(0460)  		 LCD_var_disp(4,1,pT);  //显示时间
    03415 82F9      STD	Y+1,R15
    03416 82E8      ST	Y,R14
    03417 E021      LDI	R18,1
    03418 E004      LDI	R16,4
    03419 940E 3804 CALL	_LCD_var_disp
(0461)  if(keyc==lright) {		  
    0341B 3967      CPI	R22,0x97
    0341C F479      BNE	0x342C
(0462)  		  LCD_const_disp(3,1,"        放弃修改"); 
    0341D E88C      LDI	R24,0x8C
    0341E E093      LDI	R25,3
    0341F 8399      STD	Y+1,R25
    03420 8388      ST	Y,R24
    03421 E021      LDI	R18,1
    03422 E003      LDI	R16,3
    03423 940E 37D7 CALL	_LCD_const_disp
(0463) 		  delayms(500);
    03425 EF04      LDI	R16,0xF4
    03426 E011      LDI	R17,1
    03427 940E 23FF CALL	_delayms
(0464) 		  LCD_CLR(); //清屏
    03429 940E 387D CALL	_LCD_CLR
(0465) 		  return ;} 
    0342B C021      RJMP	0x344D
(0466)  keyc=NO_KEY;
    0342C 2766      CLR	R22
(0467)  if(i==6){    //各值改变完成后 显示已保存 清屏 返回
    0342D 3046      CPI	R20,6
    0342E F4C9      BNE	0x3448
(0468) 		  ds1302_write_time(); 
    0342F 940E 3D79 CALL	_ds1302_write_time
(0469)           LCD_const_disp(4,7,"    ");		  
    03431 E887      LDI	R24,0x87
    03432 E093      LDI	R25,3
    03433 8399      STD	Y+1,R25
    03434 8388      ST	Y,R24
    03435 E027      LDI	R18,7
    03436 E004      LDI	R16,4
    03437 940E 37D7 CALL	_LCD_const_disp
(0470) 		  LCD_const_disp(3,1,"          已保存"); 
    03439 E786      LDI	R24,0x76
    0343A E093      LDI	R25,3
    0343B 8399      STD	Y+1,R25
    0343C 8388      ST	Y,R24
    0343D E021      LDI	R18,1
    0343E E003      LDI	R16,3
    0343F 940E 37D7 CALL	_LCD_const_disp
(0471) 		  delayms(500);
    03441 EF04      LDI	R16,0xF4
    03442 E011      LDI	R17,1
    03443 940E 23FF CALL	_delayms
(0472) 		  LCD_CLR(); //清屏
    03445 940E 387D CALL	_LCD_CLR
(0473) 		  return ;
    03447 C005      RJMP	0x344D
(0474) 		  }
(0475)  delayms(2);	  
    03448 E002      LDI	R16,2
    03449 E010      LDI	R17,0
    0344A 940E 23FF CALL	_delayms
    0344C CE13      RJMP	0x3260
    0344D 962B      ADIW	R28,0xB
    0344E 940C 3F69 JMP	pop_xgsetF0FC
_GUI_welcome:
    03450 9722      SBIW	R28,2
(0476) }//endwhile(1)
(0477) }
(0478) 
(0479) void GUI_welcome(void){
(0480)     LCD_CLR(); //清屏
    03451 940E 387D CALL	_LCD_CLR
(0481) 	LCD_const_disp(2,3,"欢迎使用");
    03453 E68D      LDI	R24,0x6D
    03454 E093      LDI	R25,3
    03455 8399      STD	Y+1,R25
    03456 8388      ST	Y,R24
    03457 E023      LDI	R18,3
    03458 E002      LDI	R16,2
    03459 940E 37D7 CALL	_LCD_const_disp
(0482) 	LCD_const_disp(3,1,"环境冷强度检测仪");
    0345B E58C      LDI	R24,0x5C
    0345C E093      LDI	R25,3
    0345D 8399      STD	Y+1,R25
    0345E 8388      ST	Y,R24
    0345F E021      LDI	R18,1
    03460 E003      LDI	R16,3
    03461 940E 37D7 CALL	_LCD_const_disp
(0483) 	delayms(800);
    03463 E200      LDI	R16,0x20
    03464 E013      LDI	R17,3
    03465 940E 23FF CALL	_delayms
(0484) 	beep(0,1);
    03467 E021      LDI	R18,1
    03468 2700      CLR	R16
    03469 940E 3B52 CALL	_beep
    0346B 9622      ADIW	R28,2
    0346C 9508      RET
_dateRefresh:
  readhardware         --> R20
    0346D 934A      ST	-Y,R20
    0346E 2F40      MOV	R20,R16
(0485) 	
(0486) }
(0487) 
(0488) ////////////////////////////////////
(0489) //  函数作用
(0490) //   将ds1302中缓存的时钟数据转换进结构体中
(0491) ////////////////////////////////////
(0492) void dateRefresh(unsigned char readhardware)
(0493) {	
(0494) 	if( readhardware==1 ){
    0346F 3041      CPI	R20,1
    03470 F411      BNE	0x3473
(0495) 		ds1302_read_time();
    03471 940E 3D9E CALL	_ds1302_read_time
(0496) 	}
(0497) 	t.tm_sec=(((time_buf[6]&0x70)>>4)*10)+(time_buf[6]&0x0f);
    03473 9110 04F2 LDS	R17,time_buf+6
    03475 7710      ANDI	R17,0x70
    03476 9512      SWAP	R17
    03477 701F      ANDI	R17,0xF
    03478 E00A      LDI	R16,0xA
    03479 0301      MULSU	R16,R17
    0347A 0110      MOVW	R2,R0
    0347B 9180 04F2 LDS	R24,time_buf+6
    0347D 2799      CLR	R25
    0347E 708F      ANDI	R24,0xF
    0347F 7090      ANDI	R25,0
    03480 0E28      ADD	R2,R24
    03481 1E39      ADC	R3,R25
    03482 9230 07A7 STS	t+1,R3
    03484 9220 07A6 STS	t,R2
(0498) 	t.tm_min=  (((time_buf[5]&0x70)>>4)*10)+(time_buf[5]&0x0f);
    03486 9110 04F1 LDS	R17,time_buf+5
    03488 7710      ANDI	R17,0x70
    03489 9512      SWAP	R17
    0348A 701F      ANDI	R17,0xF
    0348B 0301      MULSU	R16,R17
    0348C 0110      MOVW	R2,R0
    0348D 9180 04F1 LDS	R24,time_buf+5
    0348F 2799      CLR	R25
    03490 708F      ANDI	R24,0xF
    03491 7090      ANDI	R25,0
    03492 0E28      ADD	R2,R24
    03493 1E39      ADC	R3,R25
    03494 9230 07A9 STS	t+3,R3
    03496 9220 07A8 STS	t+2,R2
(0499) 	t.tm_hour=  (((time_buf[4]&0x70)>>4)*10)+(time_buf[4]&0x0f);
    03498 9110 04F0 LDS	R17,time_buf+4
    0349A 7710      ANDI	R17,0x70
    0349B 9512      SWAP	R17
    0349C 701F      ANDI	R17,0xF
    0349D 0301      MULSU	R16,R17
    0349E 0110      MOVW	R2,R0
    0349F 9180 04F0 LDS	R24,time_buf+4
    034A1 2799      CLR	R25
    034A2 708F      ANDI	R24,0xF
    034A3 7090      ANDI	R25,0
    034A4 0E28      ADD	R2,R24
    034A5 1E39      ADC	R3,R25
    034A6 9230 07AB STS	t+5,R3
    034A8 9220 07AA STS	t+4,R2
(0500) 	t.tm_mday=	(((time_buf[3]&0x70)>>4)*10)+(time_buf[3]&0x0f);
    034AA 9110 04EF LDS	R17,time_buf+3
    034AC 7710      ANDI	R17,0x70
    034AD 9512      SWAP	R17
    034AE 701F      ANDI	R17,0xF
    034AF 0301      MULSU	R16,R17
    034B0 0110      MOVW	R2,R0
    034B1 9180 04EF LDS	R24,time_buf+3
    034B3 2799      CLR	R25
    034B4 708F      ANDI	R24,0xF
    034B5 7090      ANDI	R25,0
    034B6 0E28      ADD	R2,R24
    034B7 1E39      ADC	R3,R25
    034B8 9230 07AD STS	t+7,R3
    034BA 9220 07AC STS	t+6,R2
(0501) 	t.tm_mon= (((time_buf[2]&0x70)>>4)*10)+(time_buf[2]&0x0f);
    034BC 9110 04EE LDS	R17,time_buf+2
    034BE 7710      ANDI	R17,0x70
    034BF 9512      SWAP	R17
    034C0 701F      ANDI	R17,0xF
    034C1 0301      MULSU	R16,R17
    034C2 0110      MOVW	R2,R0
    034C3 9180 04EE LDS	R24,time_buf+2
    034C5 2799      CLR	R25
    034C6 708F      ANDI	R24,0xF
    034C7 7090      ANDI	R25,0
    034C8 0E28      ADD	R2,R24
    034C9 1E39      ADC	R3,R25
    034CA 9230 07AF STS	t+9,R3
    034CC 9220 07AE STS	t+8,R2
(0502) 	t.tm_wday=	(time_buf[7]&0x0f);
    034CE 9180 04F3 LDS	R24,time_buf+7
    034D0 2799      CLR	R25
    034D1 708F      ANDI	R24,0xF
    034D2 7090      ANDI	R25,0
    034D3 9390 07B3 STS	t+13,R25
    034D5 9380 07B2 STS	t+12,R24
(0503)     t.tm_year=	(((time_buf[1]&0x70)>>4)*10)+(time_buf[1]&0x0f);
    034D7 9110 04ED LDS	R17,time_buf+1
    034D9 7710      ANDI	R17,0x70
    034DA 9512      SWAP	R17
    034DB 701F      ANDI	R17,0xF
    034DC 0301      MULSU	R16,R17
    034DD 0110      MOVW	R2,R0
    034DE 9180 04ED LDS	R24,time_buf+1
    034E0 2799      CLR	R25
    034E1 708F      ANDI	R24,0xF
    034E2 7090      ANDI	R25,0
    034E3 0E28      ADD	R2,R24
    034E4 1E39      ADC	R3,R25
    034E5 9230 07B1 STS	t+11,R3
    034E7 9220 07B0 STS	t+10,R2
(0504) 	Result.Date[0]='2';
    034E9 E382      LDI	R24,0x32
    034EA 9380 055E STS	Result+22,R24
(0505) 	Result.Date[1]='0';
    034EC E380      LDI	R24,0x30
    034ED 9380 055F STS	Result+23,R24
(0506) 	Result.Date[2]=t.tm_year/10+'0';
    034EF E02A      LDI	R18,0xA
    034F0 E030      LDI	R19,0
    034F1 0181      MOVW	R16,R2
    034F2 940E 3E44 CALL	div16s
    034F4 01C8      MOVW	R24,R16
    034F5 96C0      ADIW	R24,0x30
    034F6 9380 0560 STS	Result+24,R24
(0507) 	Result.Date[3]=t.tm_year%10+'0';
    034F8 E02A      LDI	R18,0xA
    034F9 E030      LDI	R19,0
    034FA 9100 07B0 LDS	R16,t+10
    034FC 9110 07B1 LDS	R17,t+11
    034FE 940E 3E40 CALL	mod16s
    03500 01C8      MOVW	R24,R16
    03501 96C0      ADIW	R24,0x30
    03502 9380 0561 STS	Result+25,R24
(0508) 	Result.Date[4]=t.tm_mon/10+'0';
    03504 E02A      LDI	R18,0xA
    03505 E030      LDI	R19,0
    03506 9100 07AE LDS	R16,t+8
    03508 9110 07AF LDS	R17,t+9
    0350A 940E 3E44 CALL	div16s
    0350C 01C8      MOVW	R24,R16
    0350D 96C0      ADIW	R24,0x30
    0350E 9380 0562 STS	Result+26,R24
(0509) 	Result.Date[5]=t.tm_mon%10+'0';
    03510 E02A      LDI	R18,0xA
    03511 E030      LDI	R19,0
    03512 9100 07AE LDS	R16,t+8
    03514 9110 07AF LDS	R17,t+9
    03516 940E 3E40 CALL	mod16s
    03518 01C8      MOVW	R24,R16
    03519 96C0      ADIW	R24,0x30
    0351A 9380 0563 STS	Result+27,R24
(0510) 	Result.Date[6]=t.tm_mday/10+'0';
    0351C E02A      LDI	R18,0xA
    0351D E030      LDI	R19,0
    0351E 9100 07AC LDS	R16,t+6
    03520 9110 07AD LDS	R17,t+7
    03522 940E 3E44 CALL	div16s
    03524 01C8      MOVW	R24,R16
    03525 96C0      ADIW	R24,0x30
    03526 9380 0564 STS	Result+28,R24
(0511) 	Result.Date[7]=t.tm_mday%10+'0';
    03528 E02A      LDI	R18,0xA
    03529 E030      LDI	R19,0
    0352A 9100 07AC LDS	R16,t+6
    0352C 9110 07AD LDS	R17,t+7
    0352E 940E 3E40 CALL	mod16s
    03530 01C8      MOVW	R24,R16
    03531 96C0      ADIW	R24,0x30
    03532 9380 0565 STS	Result+29,R24
(0512)     Result.Date[8]='\0';
    03534 2422      CLR	R2
    03535 9220 0566 STS	Result+30,R2
(0513) 	Result.Time[0]=t.tm_hour/10+'0';
    03537 E02A      LDI	R18,0xA
    03538 E030      LDI	R19,0
    03539 9100 07AA LDS	R16,t+4
    0353B 9110 07AB LDS	R17,t+5
    0353D 940E 3E44 CALL	div16s
    0353F 01C8      MOVW	R24,R16
    03540 96C0      ADIW	R24,0x30
    03541 9380 0567 STS	Result+31,R24
(0514) 	Result.Time[1]=t.tm_hour%10+'0';
    03543 E02A      LDI	R18,0xA
    03544 E030      LDI	R19,0
    03545 9100 07AA LDS	R16,t+4
    03547 9110 07AB LDS	R17,t+5
    03549 940E 3E40 CALL	mod16s
    0354B 01C8      MOVW	R24,R16
    0354C 96C0      ADIW	R24,0x30
    0354D 9380 0568 STS	Result+32,R24
(0515) 	Result.Time[2]=':';
    0354F E38A      LDI	R24,0x3A
    03550 9380 0569 STS	Result+33,R24
(0516) 	Result.Time[3]=' ';
    03552 E280      LDI	R24,0x20
    03553 9380 056A STS	Result+34,R24
(0517) 	Result.Time[4]=t.tm_min/10+'0';
    03555 E02A      LDI	R18,0xA
    03556 E030      LDI	R19,0
    03557 9100 07A8 LDS	R16,t+2
    03559 9110 07A9 LDS	R17,t+3
    0355B 940E 3E44 CALL	div16s
    0355D 01C8      MOVW	R24,R16
    0355E 96C0      ADIW	R24,0x30
    0355F 9380 056B STS	Result+35,R24
(0518) 	Result.Time[5]=t.tm_min%10+'0';
    03561 E02A      LDI	R18,0xA
    03562 E030      LDI	R19,0
    03563 9100 07A8 LDS	R16,t+2
    03565 9110 07A9 LDS	R17,t+3
    03567 940E 3E40 CALL	mod16s
    03569 01C8      MOVW	R24,R16
    0356A 96C0      ADIW	R24,0x30
    0356B 9380 056C STS	Result+36,R24
(0519) 	Result.Time[6]=':';
    0356D E38A      LDI	R24,0x3A
    0356E 9380 056D STS	Result+37,R24
(0520) 	Result.Time[7]=' ';
    03570 E280      LDI	R24,0x20
    03571 9380 056E STS	Result+38,R24
(0521) 	Result.Time[8]=t.tm_sec/10+'0';
    03573 E02A      LDI	R18,0xA
    03574 E030      LDI	R19,0
    03575 9100 07A6 LDS	R16,t
    03577 9110 07A7 LDS	R17,t+1
    03579 940E 3E44 CALL	div16s
    0357B 01C8      MOVW	R24,R16
    0357C 96C0      ADIW	R24,0x30
    0357D 9380 056F STS	Result+39,R24
(0522) 	Result.Time[9]=t.tm_sec%10+'0';
    0357F E02A      LDI	R18,0xA
    03580 E030      LDI	R19,0
    03581 9100 07A6 LDS	R16,t
    03583 9110 07A7 LDS	R17,t+1
    03585 940E 3E40 CALL	mod16s
    03587 01C8      MOVW	R24,R16
    03588 96C0      ADIW	R24,0x30
    03589 9380 0570 STS	Result+40,R24
(0523) 	Result.Time[10]='\0'; 
    0358B 2422      CLR	R2
    0358C 9220 0571 STS	Result+41,R2
(0524) 	//
(0525) 	config.now =t.tm_hour*3600 + t.tm_min*60 + t.tm_sec;
    0358E 9120 07A8 LDS	R18,t+2
    03590 9130 07A9 LDS	R19,t+3
    03592 E30C      LDI	R16,0x3C
    03593 E010      LDI	R17,0
    03594 940E 3F10 CALL	empy16s
    03596 0118      MOVW	R2,R16
    03597 9120 07AA LDS	R18,t+4
    03599 9130 07AB LDS	R19,t+5
    0359B E100      LDI	R16,0x10
    0359C E01E      LDI	R17,0xE
    0359D 940E 3F10 CALL	empy16s
    0359F 0128      MOVW	R4,R16
    035A0 0C42      ADD	R4,R2
    035A1 1C53      ADC	R5,R3
    035A2 9020 07A6 LDS	R2,t
    035A4 9030 07A7 LDS	R3,t+1
    035A6 0C42      ADD	R4,R2
    035A7 1C53      ADC	R5,R3
    035A8 0112      MOVW	R2,R4
    035A9 2444      CLR	R4
    035AA FC37      SBRC	R3,7
    035AB 9440      COM	R4
    035AC 2455      CLR	R5
    035AD FC47      SBRC	R4,7
    035AE 9450      COM	R5
    035AF 9230 07C5 STS	config+13,R3
    035B1 9220 07C4 STS	config+12,R2
    035B3 9250 07C7 STS	config+15,R5
    035B5 9240 07C6 STS	config+14,R4
    035B7 9149      LD	R20,Y+
    035B8 9508      RET
FILE: D:\LQD\software\master\software_src\usart.c
(0001) #include "config.h"
(0002) 
(0003) 
(0004) #define fosc 7372800UL //晶振7.3728MHZ
(0005) #define baud 38400  //波特率
(0006) //串口通信初始化  MEGA128
(0007) //UART1 initialize
(0008) // desired baud rate:38400
(0009) // actual baud rate:38400 (0.0%)
(0010) // char size: 8 bit
(0011) // parity: Disabled
(0012) void uart1_init(void)
(0013) {
(0014)  	 UCSR1B = 0x00; //disable while setting baud rate
_uart1_init:
    035B9 2422      CLR	R2
    035BA 9220 009A STS	0x9A,R2
(0015)      UCSR1A = 0x00;
    035BC 9220 009B STS	0x9B,R2
(0016)      UCSR1C = (1<<UCSZ11)|(1<<UCSZ10);//8bit+1bit stop
    035BE E086      LDI	R24,6
    035BF 9380 009D STS	0x9D,R24
(0017)      UBRR1L=(fosc/16/(baud+1))%256;
    035C1 E08B      LDI	R24,0xB
    035C2 9380 0099 STS	0x99,R24
(0018)      UBRR1H=(fosc/16/(baud+1))/256;
    035C4 9220 0098 STS	0x98,R2
(0019)      UCSR1B =(1<<RXEN1)|(1<<TXEN1);//RXCEN TXCEN
    035C6 E188      LDI	R24,0x18
    035C7 9380 009A STS	0x9A,R24
    035C9 9508      RET
_uart1_rx_isr:
  tmp                  --> R16
    035CA 930A      ST	-Y,R16
    035CB B70F      IN	R16,0x3F
    035CC 930A      ST	-Y,R16
(0020) }
(0021) 
(0022) #pragma interrupt_handler uart1_rx_isr:iv_USART1_RXC
(0023) void uart1_rx_isr(void){   
(0024) 	 char tmp;
(0025) 	 tmp=UDR1;
    035CD 9100 009C LDS	R16,0x9C
    035CF 9109      LD	R16,Y+
    035D0 BF0F      OUT	0x3F,R16
    035D1 9109      LD	R16,Y+
    035D2 9518      RETI
(0026) }
(0027) 
(0028) void Usart_Transmit(char c)
(0029) {
(0030)  	 while (!(UCSR1A&(1<<UDRE1)));//表明发送器一准备就绪
_Usart_Transmit:
  c                    --> R16
    035D3 9020 009B LDS	R2,0x9B
    035D5 FE25      SBRS	R2,5
    035D6 CFFC      RJMP	_Usart_Transmit
(0031) 	 UDR1=c;
    035D7 9300 009C STS	0x9C,R16
    035D9 9508      RET
_Puts:
  s                    --> R20
    035DA 934A      ST	-Y,R20
    035DB 935A      ST	-Y,R21
    035DC 01A8      MOVW	R20,R16
(0032) }
(0033) 
(0034) //串口输出字符串
(0035) void Puts( unsigned char *s)
(0036) { 
    035DD C00B      RJMP	0x35E9
(0037) 	 while (*s) 
(0038)       { 
(0039) 	  //为数据间的隔断创造一个串口能显示的隔断字符 即'/t'  ->  ' '
(0040) 	  if(*s==0x09)  
    035DE 01FA      MOVW	R30,R20
    035DF 8180      LD	R24,Z
    035E0 3089      CPI	R24,0x9
    035E1 F411      BNE	0x35E4
(0041) 	  {   Usart_Transmit(' ');    }
    035E2 E200      LDI	R16,0x20
    035E3 DFEF      RCALL	_Usart_Transmit
(0042) 	 Usart_Transmit(*s);
    035E4 01FA      MOVW	R30,R20
    035E5 8100      LD	R16,Z
    035E6 DFEC      RCALL	_Usart_Transmit
(0043) 	 s++;
    035E7 5F4F      SUBI	R20,0xFF
    035E8 4F5F      SBCI	R21,0xFF
    035E9 01FA      MOVW	R30,R20
    035EA 8020      LD	R2,Z
    035EB 2022      TST	R2
    035EC F789      BNE	0x35DE
    035ED 9159      LD	R21,Y+
    035EE 9149      LD	R20,Y+
    035EF 9508      RET
_Send_nByte:
  i                    --> R20
  len                  --> R10
  p                    --> R12
    035F0 940E 3FA1 CALL	push_xgset303C
    035F2 2EA2      MOV	R10,R18
    035F3 0168      MOVW	R12,R16
(0044) 	
(0045) 	
(0046)       }
(0047) }
(0048) 
(0049) 
(0050) 
(0051) void Send_nByte(unsigned char *p, unsigned char len)
(0052) { 
(0053)   int i = 0;
(0054)   for(i=0;i<len;i++)
    035F4 2744      CLR	R20
    035F5 2755      CLR	R21
    035F6 C007      RJMP	0x35FE
(0055)   {
(0056)    	Usart_Transmit(*(p+i));
    035F7 01FA      MOVW	R30,R20
    035F8 0DEC      ADD	R30,R12
    035F9 1DFD      ADC	R31,R13
    035FA 8100      LD	R16,Z
    035FB DFD7      RCALL	_Usart_Transmit
    035FC 5F4F      SUBI	R20,0xFF
    035FD 4F5F      SBCI	R21,0xFF
    035FE 2C2A      MOV	R2,R10
    035FF 2433      CLR	R3
    03600 1542      CP	R20,R2
    03601 0553      CPC	R21,R3
    03602 F3A4      BLT	0x35F7
    03603 940C 3FA8 JMP	pop_xgset303C
_PrintString:
  str                  --> R10
    03605 92AA      ST	-Y,R10
    03606 92BA      ST	-Y,R11
    03607 0158      MOVW	R10,R16
(0057)   }
(0058) }
(0059) 
(0060) void  PrintString(const unsigned char *str)
(0061) {    
    03608 C004      RJMP	0x360D
(0062) 	while(*str!=0)	Usart_Transmit(*str++);
    03609 01F5      MOVW	R30,R10
    0360A 9101      LD	R16,Z+
    0360B 015F      MOVW	R10,R30
    0360C DFC6      RCALL	_Usart_Transmit
    0360D 01F5      MOVW	R30,R10
    0360E 8020      LD	R2,Z
    0360F 2022      TST	R2
    03610 F7C1      BNE	0x3609
    03611 90B9      LD	R11,Y+
    03612 90A9      LD	R10,Y+
    03613 9508      RET
_PrintString_n:
  str                  --> R10
    03614 92AA      ST	-Y,R10
    03615 92BA      ST	-Y,R11
    03616 0158      MOVW	R10,R16
(0063) }
(0064) void  PrintString_n(const unsigned char *str)
(0065) {   
(0066) 	Usart_Transmit('\r');
    03617 E00D      LDI	R16,0xD
    03618 DFBA      RCALL	_Usart_Transmit
(0067) 	Usart_Transmit('\n'); 
    03619 E00A      LDI	R16,0xA
    0361A DFB8      RCALL	_Usart_Transmit
    0361B C004      RJMP	0x3620
(0068) 	while(*str!=0)	Usart_Transmit(*str++);
    0361C 01F5      MOVW	R30,R10
    0361D 9101      LD	R16,Z+
    0361E 015F      MOVW	R10,R30
    0361F DFB3      RCALL	_Usart_Transmit
    03620 01F5      MOVW	R30,R10
    03621 8020      LD	R2,Z
    03622 2022      TST	R2
    03623 F7C1      BNE	0x361C
    03624 90B9      LD	R11,Y+
    03625 90A9      LD	R10,Y+
    03626 9508      RET
_PrintLong:
  i                    --> R20
  da                   --> Y,+0
  data                 --> Y,+9
    03627 940E 3E2F CALL	push_arg4
    03629 934A      ST	-Y,R20
    0362A 9728      SBIW	R28,0x8
(0069) 
(0070) } 
(0071)  
(0072) void PrintLong(unsigned long data)
(0073) {
(0074)  
(0075) 	unsigned char da[8];
(0076) 	unsigned char i;
(0077) 	for(i=0;i<8;i++)	da[i]=0;
    0362B 2744      CLR	R20
    0362C C008      RJMP	0x3635
    0362D 01CE      MOVW	R24,R28
    0362E 2FE4      MOV	R30,R20
    0362F 27FF      CLR	R31
    03630 0FE8      ADD	R30,R24
    03631 1FF9      ADC	R31,R25
    03632 2422      CLR	R2
    03633 8220      ST	Z,R2
    03634 9543      INC	R20
    03635 3048      CPI	R20,0x8
    03636 F3B0      BCS	0x362D
    03637 C013      RJMP	0x364B
(0078) 	while(data>=10000000L){ ++da[7];data-=10000000L;}
    03638 818F      LDD	R24,Y+7
    03639 5F8F      SUBI	R24,0xFF
    0363A 838F      STD	Y+7,R24
    0363B E880      LDI	R24,0x80
    0363C E996      LDI	R25,0x96
    0363D E9A8      LDI	R26,0x98
    0363E E0B0      LDI	R27,0
    0363F 8429      LDD	R2,Y+9
    03640 843A      LDD	R3,Y+10
    03641 844B      LDD	R4,Y+11
    03642 845C      LDD	R5,Y+12
    03643 1A28      SUB	R2,R24
    03644 0A39      SBC	R3,R25
    03645 0A4A      SBC	R4,R26
    03646 0A5B      SBC	R5,R27
    03647 8629      STD	Y+9,R2
    03648 863A      STD	Y+10,R3
    03649 864B      STD	Y+11,R4
    0364A 865C      STD	Y+12,R5
    0364B E880      LDI	R24,0x80
    0364C E996      LDI	R25,0x96
    0364D E9A8      LDI	R26,0x98
    0364E E0B0      LDI	R27,0
    0364F 8429      LDD	R2,Y+9
    03650 843A      LDD	R3,Y+10
    03651 844B      LDD	R4,Y+11
    03652 845C      LDD	R5,Y+12
    03653 1628      CP	R2,R24
    03654 0639      CPC	R3,R25
    03655 064A      CPC	R4,R26
    03656 065B      CPC	R5,R27
    03657 F700      BCC	0x3638
(0079) 	if(da[7])	i=0;
    03658 802F      LDD	R2,Y+7
    03659 2022      TST	R2
    0365A F009      BEQ	0x365C
    0365B 2744      CLR	R20
(0080) 	if(i==0)	Usart_Transmit('0'+da[7]);
    0365C 2344      TST	R20
    0365D F4B9      BNE	0x3675
    0365E 810F      LDD	R16,Y+7
    0365F 5D00      SUBI	R16,0xD0
    03660 DF72      RCALL	_Usart_Transmit
    03661 C013      RJMP	0x3675
(0081) 	while(data>=1000000L) { ++da[6];data-=1000000L;}
    03662 818E      LDD	R24,Y+6
    03663 5F8F      SUBI	R24,0xFF
    03664 838E      STD	Y+6,R24
    03665 E480      LDI	R24,0x40
    03666 E492      LDI	R25,0x42
    03667 E0AF      LDI	R26,0xF
    03668 E0B0      LDI	R27,0
    03669 8429      LDD	R2,Y+9
    0366A 843A      LDD	R3,Y+10
    0366B 844B      LDD	R4,Y+11
    0366C 845C      LDD	R5,Y+12
    0366D 1A28      SUB	R2,R24
    0366E 0A39      SBC	R3,R25
    0366F 0A4A      SBC	R4,R26
    03670 0A5B      SBC	R5,R27
    03671 8629      STD	Y+9,R2
    03672 863A      STD	Y+10,R3
    03673 864B      STD	Y+11,R4
    03674 865C      STD	Y+12,R5
    03675 E480      LDI	R24,0x40
    03676 E492      LDI	R25,0x42
    03677 E0AF      LDI	R26,0xF
    03678 E0B0      LDI	R27,0
    03679 8429      LDD	R2,Y+9
    0367A 843A      LDD	R3,Y+10
    0367B 844B      LDD	R4,Y+11
    0367C 845C      LDD	R5,Y+12
    0367D 1628      CP	R2,R24
    0367E 0639      CPC	R3,R25
    0367F 064A      CPC	R4,R26
    03680 065B      CPC	R5,R27
    03681 F700      BCC	0x3662
(0082) 	if(da[6])	i=0;
    03682 802E      LDD	R2,Y+6
    03683 2022      TST	R2
    03684 F009      BEQ	0x3686
    03685 2744      CLR	R20
(0083) 	if(i==0)	Usart_Transmit('0'+da[6]);
    03686 2344      TST	R20
    03687 F4B9      BNE	0x369F
    03688 810E      LDD	R16,Y+6
    03689 5D00      SUBI	R16,0xD0
    0368A DF48      RCALL	_Usart_Transmit
    0368B C013      RJMP	0x369F
(0084) 	while(data>=100000L)  { ++da[5];data-=100000L;}
    0368C 818D      LDD	R24,Y+5
    0368D 5F8F      SUBI	R24,0xFF
    0368E 838D      STD	Y+5,R24
    0368F EA80      LDI	R24,0xA0
    03690 E896      LDI	R25,0x86
    03691 E0A1      LDI	R26,1
    03692 E0B0      LDI	R27,0
    03693 8429      LDD	R2,Y+9
    03694 843A      LDD	R3,Y+10
    03695 844B      LDD	R4,Y+11
    03696 845C      LDD	R5,Y+12
    03697 1A28      SUB	R2,R24
    03698 0A39      SBC	R3,R25
    03699 0A4A      SBC	R4,R26
    0369A 0A5B      SBC	R5,R27
    0369B 8629      STD	Y+9,R2
    0369C 863A      STD	Y+10,R3
    0369D 864B      STD	Y+11,R4
    0369E 865C      STD	Y+12,R5
    0369F EA80      LDI	R24,0xA0
    036A0 E896      LDI	R25,0x86
    036A1 E0A1      LDI	R26,1
    036A2 E0B0      LDI	R27,0
    036A3 8429      LDD	R2,Y+9
    036A4 843A      LDD	R3,Y+10
    036A5 844B      LDD	R4,Y+11
    036A6 845C      LDD	R5,Y+12
    036A7 1628      CP	R2,R24
    036A8 0639      CPC	R3,R25
    036A9 064A      CPC	R4,R26
    036AA 065B      CPC	R5,R27
    036AB F700      BCC	0x368C
(0085) 	if(da[5])	i=0;
    036AC 802D      LDD	R2,Y+5
    036AD 2022      TST	R2
    036AE F009      BEQ	0x36B0
    036AF 2744      CLR	R20
(0086) 	if(i==0)	Usart_Transmit('0'+da[5]);
    036B0 2344      TST	R20
    036B1 F4B9      BNE	0x36C9
    036B2 810D      LDD	R16,Y+5
    036B3 5D00      SUBI	R16,0xD0
    036B4 DF1E      RCALL	_Usart_Transmit
    036B5 C013      RJMP	0x36C9
(0087) 	while(data>=10000L)   { ++da[4];data-=10000L;}
    036B6 818C      LDD	R24,Y+4
    036B7 5F8F      SUBI	R24,0xFF
    036B8 838C      STD	Y+4,R24
    036B9 E180      LDI	R24,0x10
    036BA E297      LDI	R25,0x27
    036BB E0A0      LDI	R26,0
    036BC E0B0      LDI	R27,0
    036BD 8429      LDD	R2,Y+9
    036BE 843A      LDD	R3,Y+10
    036BF 844B      LDD	R4,Y+11
    036C0 845C      LDD	R5,Y+12
    036C1 1A28      SUB	R2,R24
    036C2 0A39      SBC	R3,R25
    036C3 0A4A      SBC	R4,R26
    036C4 0A5B      SBC	R5,R27
    036C5 8629      STD	Y+9,R2
    036C6 863A      STD	Y+10,R3
    036C7 864B      STD	Y+11,R4
    036C8 865C      STD	Y+12,R5
    036C9 E180      LDI	R24,0x10
    036CA E297      LDI	R25,0x27
    036CB E0A0      LDI	R26,0
    036CC E0B0      LDI	R27,0
    036CD 8429      LDD	R2,Y+9
    036CE 843A      LDD	R3,Y+10
    036CF 844B      LDD	R4,Y+11
    036D0 845C      LDD	R5,Y+12
    036D1 1628      CP	R2,R24
    036D2 0639      CPC	R3,R25
    036D3 064A      CPC	R4,R26
    036D4 065B      CPC	R5,R27
    036D5 F700      BCC	0x36B6
(0088) 	if(da[4])	i=0;
    036D6 802C      LDD	R2,Y+4
    036D7 2022      TST	R2
    036D8 F009      BEQ	0x36DA
    036D9 2744      CLR	R20
(0089) 	if(i==0)	Usart_Transmit('0'+da[4]);
    036DA 2344      TST	R20
    036DB F4B9      BNE	0x36F3
    036DC 810C      LDD	R16,Y+4
    036DD 5D00      SUBI	R16,0xD0
    036DE DEF4      RCALL	_Usart_Transmit
    036DF C013      RJMP	0x36F3
(0090) 	while(data>=1000L)    { ++da[3];data-=1000L;}
    036E0 818B      LDD	R24,Y+3
    036E1 5F8F      SUBI	R24,0xFF
    036E2 838B      STD	Y+3,R24
    036E3 EE88      LDI	R24,0xE8
    036E4 E093      LDI	R25,3
    036E5 E0A0      LDI	R26,0
    036E6 E0B0      LDI	R27,0
    036E7 8429      LDD	R2,Y+9
    036E8 843A      LDD	R3,Y+10
    036E9 844B      LDD	R4,Y+11
    036EA 845C      LDD	R5,Y+12
    036EB 1A28      SUB	R2,R24
    036EC 0A39      SBC	R3,R25
    036ED 0A4A      SBC	R4,R26
    036EE 0A5B      SBC	R5,R27
    036EF 8629      STD	Y+9,R2
    036F0 863A      STD	Y+10,R3
    036F1 864B      STD	Y+11,R4
    036F2 865C      STD	Y+12,R5
    036F3 EE88      LDI	R24,0xE8
    036F4 E093      LDI	R25,3
    036F5 E0A0      LDI	R26,0
    036F6 E0B0      LDI	R27,0
    036F7 8429      LDD	R2,Y+9
    036F8 843A      LDD	R3,Y+10
    036F9 844B      LDD	R4,Y+11
    036FA 845C      LDD	R5,Y+12
    036FB 1628      CP	R2,R24
    036FC 0639      CPC	R3,R25
    036FD 064A      CPC	R4,R26
    036FE 065B      CPC	R5,R27
    036FF F700      BCC	0x36E0
(0091) 	if(da[3])	i=0;
    03700 802B      LDD	R2,Y+3
    03701 2022      TST	R2
    03702 F009      BEQ	0x3704
    03703 2744      CLR	R20
(0092) 	if(i==0)	Usart_Transmit('0'+da[3]);
    03704 2344      TST	R20
    03705 F4B9      BNE	0x371D
    03706 810B      LDD	R16,Y+3
    03707 5D00      SUBI	R16,0xD0
    03708 DECA      RCALL	_Usart_Transmit
    03709 C013      RJMP	0x371D
(0093) 	while(data>=100L)     { ++da[2];data-=100L;}
    0370A 818A      LDD	R24,Y+2
    0370B 5F8F      SUBI	R24,0xFF
    0370C 838A      STD	Y+2,R24
    0370D E684      LDI	R24,0x64
    0370E E090      LDI	R25,0
    0370F E0A0      LDI	R26,0
    03710 E0B0      LDI	R27,0
    03711 8429      LDD	R2,Y+9
    03712 843A      LDD	R3,Y+10
    03713 844B      LDD	R4,Y+11
    03714 845C      LDD	R5,Y+12
    03715 1A28      SUB	R2,R24
    03716 0A39      SBC	R3,R25
    03717 0A4A      SBC	R4,R26
    03718 0A5B      SBC	R5,R27
    03719 8629      STD	Y+9,R2
    0371A 863A      STD	Y+10,R3
    0371B 864B      STD	Y+11,R4
    0371C 865C      STD	Y+12,R5
    0371D E684      LDI	R24,0x64
    0371E E090      LDI	R25,0
    0371F E0A0      LDI	R26,0
    03720 E0B0      LDI	R27,0
    03721 8429      LDD	R2,Y+9
    03722 843A      LDD	R3,Y+10
    03723 844B      LDD	R4,Y+11
    03724 845C      LDD	R5,Y+12
    03725 1628      CP	R2,R24
    03726 0639      CPC	R3,R25
    03727 064A      CPC	R4,R26
    03728 065B      CPC	R5,R27
    03729 F700      BCC	0x370A
(0094) 	if(da[2])	i=0;
    0372A 802A      LDD	R2,Y+2
    0372B 2022      TST	R2
    0372C F009      BEQ	0x372E
    0372D 2744      CLR	R20
(0095) 	if(i==0)	Usart_Transmit('0'+da[2]);
    0372E 2344      TST	R20
    0372F F4B9      BNE	0x3747
    03730 810A      LDD	R16,Y+2
    03731 5D00      SUBI	R16,0xD0
    03732 DEA0      RCALL	_Usart_Transmit
    03733 C013      RJMP	0x3747
(0096) 	while(data>=10L)      { ++da[1];data-=10L;}
    03734 8189      LDD	R24,Y+1
    03735 5F8F      SUBI	R24,0xFF
    03736 8389      STD	Y+1,R24
    03737 E08A      LDI	R24,0xA
    03738 E090      LDI	R25,0
    03739 E0A0      LDI	R26,0
    0373A E0B0      LDI	R27,0
    0373B 8429      LDD	R2,Y+9
    0373C 843A      LDD	R3,Y+10
    0373D 844B      LDD	R4,Y+11
    0373E 845C      LDD	R5,Y+12
    0373F 1A28      SUB	R2,R24
    03740 0A39      SBC	R3,R25
    03741 0A4A      SBC	R4,R26
    03742 0A5B      SBC	R5,R27
    03743 8629      STD	Y+9,R2
    03744 863A      STD	Y+10,R3
    03745 864B      STD	Y+11,R4
    03746 865C      STD	Y+12,R5
    03747 E08A      LDI	R24,0xA
    03748 E090      LDI	R25,0
    03749 E0A0      LDI	R26,0
    0374A E0B0      LDI	R27,0
    0374B 8429      LDD	R2,Y+9
    0374C 843A      LDD	R3,Y+10
    0374D 844B      LDD	R4,Y+11
    0374E 845C      LDD	R5,Y+12
    0374F 1628      CP	R2,R24
    03750 0639      CPC	R3,R25
    03751 064A      CPC	R4,R26
    03752 065B      CPC	R5,R27
    03753 F700      BCC	0x3734
(0097) 	if(da[1])	i=0;
    03754 8029      LDD	R2,Y+1
    03755 2022      TST	R2
    03756 F009      BEQ	0x3758
    03757 2744      CLR	R20
(0098) 	if(i==0)	Usart_Transmit('0'+da[1]);
    03758 2344      TST	R20
    03759 F419      BNE	0x375D
    0375A 8109      LDD	R16,Y+1
    0375B 5D00      SUBI	R16,0xD0
    0375C DE76      RCALL	_Usart_Transmit
(0099) 	Usart_Transmit('0'+data);
    0375D E380      LDI	R24,0x30
    0375E E090      LDI	R25,0
    0375F E0A0      LDI	R26,0
    03760 E0B0      LDI	R27,0
    03761 8429      LDD	R2,Y+9
    03762 843A      LDD	R3,Y+10
    03763 844B      LDD	R4,Y+11
    03764 845C      LDD	R5,Y+12
    03765 0E28      ADD	R2,R24
    03766 1E39      ADC	R3,R25
    03767 1E4A      ADC	R4,R26
    03768 1E5B      ADC	R5,R27
    03769 2D02      MOV	R16,R2
    0376A DE68      RCALL	_Usart_Transmit
    0376B 9628      ADIW	R28,0x8
    0376C 9149      LD	R20,Y+
    0376D 9624      ADIW	R28,4
    0376E 9508      RET
_PrintChar:
  h                    --> R20
  d                    --> R22
    0376F 934A      ST	-Y,R20
    03770 936A      ST	-Y,R22
    03771 2F60      MOV	R22,R16
(0100)  
(0101) }
(0102)  
(0103) void PrintChar(unsigned char d)
(0104) {
(0105) 	unsigned char h=(d&0xF0)>>4;
    03772 2F46      MOV	R20,R22
    03773 7F40      ANDI	R20,0xF0
    03774 9542      SWAP	R20
    03775 704F      ANDI	R20,0xF
(0106) 	if(h<10)	Usart_Transmit('0'+h);
    03776 304A      CPI	R20,0xA
    03777 F420      BCC	0x377C
    03778 2F04      MOV	R16,R20
    03779 5D00      SUBI	R16,0xD0
    0377A DE58      RCALL	_Usart_Transmit
    0377B C003      RJMP	0x377F
(0107) 	else		Usart_Transmit('A'-10+h);
    0377C 2F04      MOV	R16,R20
    0377D 5C09      SUBI	R16,0xC9
    0377E DE54      RCALL	_Usart_Transmit
(0108) 	h=d&0x0f;
    0377F 2F46      MOV	R20,R22
    03780 704F      ANDI	R20,0xF
(0109) 	if(h<10)	Usart_Transmit('0'+h);
    03781 304A      CPI	R20,0xA
    03782 F420      BCC	0x3787
    03783 2F04      MOV	R16,R20
    03784 5D00      SUBI	R16,0xD0
    03785 DE4D      RCALL	_Usart_Transmit
    03786 C003      RJMP	0x378A
(0110) 	else		Usart_Transmit('A'-10+h);
    03787 2F04      MOV	R16,R20
    03788 5C09      SUBI	R16,0xC9
    03789 DE49      RCALL	_Usart_Transmit
(0111) 	Usart_Transmit(' ');
    0378A E200      LDI	R16,0x20
    0378B DE47      RCALL	_Usart_Transmit
    0378C 9169      LD	R22,Y+
    0378D 9149      LD	R20,Y+
    0378E 9508      RET
FILE: D:\LQD\software\master\software_src\SPI.c
(0001) //*****************************************************************************//
(0002) //*								 
(0003) //*控制芯片：ATmgea128
(0004) //*开发环境：AVR Studio+GCC
(0005) //*隶属模块：SPI接口控制
(0006) //*****************************************************************************//
(0007) #include "SPI.h"
(0008) 
(0009) /******************************************************************
(0010) SPI接口函数初始化
(0011) ******************************************************************/
(0012) void SPI_IO_Init(void)
(0013) {
(0014) 	SPI_PORT |= (1<<SS);////拉高CS
_SPI_IO_Init:
    0378F 9AC0      SBI	0x18,0
(0015) 	SPI_DDR |= (1<<SCLK)|(1<<MOSI)|(1<<SS);////CS,CLK,MOSI设为输出
    03790 B387      IN	R24,0x17
    03791 6087      ORI	R24,7
    03792 BB87      OUT	0x17,R24
(0016) 	SPI_DDR &=~(1<<MISO);//MISO设为输入
    03793 98BB      CBI	0x17,3
(0017) 	SPI_PORT |= (1<<SCLK);//拉高CLK
    03794 9AC1      SBI	0x18,1
(0018) 	SPI_High();//SPI高通
    03795 E580      LDI	R24,0x50
    03796 B98D      OUT	0x0D,R24
    03797 9A70      SBI	0x0E,0
    03798 9508      RET
(0019) }
(0020) /******************************************************************
(0021) SPI写一个字节
(0022) ******************************************************************/
(0023) void SPI_Write(UINT8 data)
(0024) {
(0025) 	SPDR = data;
_SPI_Write:
  data                 --> R16
    03799 B90F      OUT	0x0F,R16
(0026) 	while ((SPSR&(1<<SPIF))==0);
    0379A 9B77      SBIS	0x0E,7
    0379B CFFE      RJMP	0x379A
    0379C 9508      RET
(0027) 	//loop_until_bit_is_set(SPSR,SPIF);
(0028) }
(0029) /******************************************************************
(0030) SPI读一个字节
(0031) ******************************************************************/
(0032) unsigned char SPI_Read(void)
(0033) {
(0034) 	SPDR = 0xFF;//写0xFF启动SPI
_SPI_Read:
    0379D EF8F      LDI	R24,0xFF
    0379E B98F      OUT	0x0F,R24
(0035) 	while ((SPSR&(1<<SPIF))==0);
    0379F 9B77      SBIS	0x0E,7
    037A0 CFFE      RJMP	0x379F
(0036) 	//loop_until_bit_is_set(SPSR,SPIF);//等待SPIF为高电平
(0037) 	return  SPDR;//返回读取值
    037A1 B10F      IN	R16,0x0F
    037A2 9508      RET
FILE: D:\LQD\software\master\software_src\lcd.c
(0001) #include "config.h"
(0002) 
(0003) //此硬件引脚适合冷强度检测仪第2版电路  mega128
(0004) #define LCD_PIN_CS   4
(0005) #define LCD_PIN_SID  3
(0006) #define LCD_PIN_SCLK 2
(0007) #define LCD_PIN_RST  1
(0008) #define LCD_BACKLIGHT_SW		0
(0009) #define LCD_PORT PORTC
(0010) #define LCD_PIN_DDR DDRC
(0011) #define Set_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT |= (1<<LCD_PIN_CS) 
(0012) #define Set_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT |= (1<<LCD_PIN_SID) 
(0013) #define Set_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT |= (1<<LCD_PIN_SCLK) 
(0014) #define LCD_LIGHT_ON()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT |= (1<<LCD_BACKLIGHT_SW) 
(0015) #define Set_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT |= (1<<LCD_PIN_RST) 
(0016) 
(0017) #define Clr_CS()     LCD_PIN_DDR |= (1<<LCD_PIN_CS)  ;LCD_PORT &=~(1<<LCD_PIN_CS) 
(0018) #define Clr_SID()    LCD_PIN_DDR |= (1<<LCD_PIN_SID) ;LCD_PORT &=~(1<<LCD_PIN_SID) 
(0019) #define Clr_SCLK()   LCD_PIN_DDR |= (1<<LCD_PIN_SCLK);LCD_PORT &=~(1<<LCD_PIN_SCLK) 
(0020) #define LCD_LIGHT_OFF()   LCD_PIN_DDR |= (1<<LCD_BACKLIGHT_SW);LCD_PORT &=~(1<<LCD_BACKLIGHT_SW) 
(0021) #define Clr_RST()   LCD_PIN_DDR |= (1<<LCD_PIN_RST);LCD_PORT &=~(1<<LCD_PIN_RST) 
(0022)  
(0023) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data); 
(0024) void Write_8bits(unsigned int W_bits); 
(0025) void LCD_Init(void); 
(0026) unsigned char LCD_INT(void); 
(0027) 
(0028) unsigned char LCD_SW(unsigned char i)
(0029) {
(0030)  if(i==0){
_LCD_SW:
  i                    --> R16
    037A3 2300      TST	R16
    037A4 F421      BNE	0x37A9
(0031)  LCD_LIGHT_OFF();
    037A5 9AA0      SBI	0x14,0
    037A6 98A8      CBI	0x15,0
(0032)  return 0;
    037A7 2700      CLR	R16
    037A8 C003      RJMP	0x37AC
(0033)  }
(0034)  else{
(0035)  LCD_LIGHT_ON();
    037A9 9AA0      SBI	0x14,0
    037AA 9AA8      SBI	0x15,0
(0036)  return 1;
    037AB E001      LDI	R16,1
    037AC 9508      RET
(0037)  }
(0038)  
(0039) }
(0040)  
(0041) unsigned char LCD_INT(void) 
(0042) { 
(0043)   Clr_CS(); 
_LCD_INT:
    037AD 9AA4      SBI	0x14,4
    037AE 98AC      CBI	0x15,4
(0044)   Clr_SID(); 
    037AF 9AA3      SBI	0x14,3
    037B0 98AB      CBI	0x15,3
(0045)   Clr_SCLK(); 
    037B1 9AA2      SBI	0x14,2
    037B2 98AA      CBI	0x15,2
(0046)   LCD_Init(); 
    037B3 D097      RCALL	_LCD_Init
(0047)   return (0);
    037B4 2700      CLR	R16
    037B5 9508      RET
_address:
  a                    --> R20
  y                    --> R18
  x                    --> R16
    037B6 940E 3F89 CALL	push_xgsetF000
(0048) } 
(0049)   
(0050) /******************************************************************** 
(0051) 函数 名：address
(0052) 入口参数：地址转换
(0053) 出口参数：无 
(0054) 函数作用： 
(0055) 说        明： 
(0056) ********************************************************************/ 
(0057) unsigned char address(unsigned char x,unsigned char y)
(0058) {  
(0059)  unsigned char a;
(0060) 
(0061) switch(x) 
    037B8 2F60      MOV	R22,R16
    037B9 2777      CLR	R23
    037BA 3061      CPI	R22,1
    037BB E0E0      LDI	R30,0
    037BC 077E      CPC	R23,R30
    037BD F069      BEQ	0x37CB
    037BE 3062      CPI	R22,2
    037BF E0E0      LDI	R30,0
    037C0 077E      CPC	R23,R30
    037C1 F059      BEQ	0x37CD
    037C2 3063      CPI	R22,3
    037C3 E0E0      LDI	R30,0
    037C4 077E      CPC	R23,R30
    037C5 F049      BEQ	0x37CF
    037C6 3064      CPI	R22,4
    037C7 E0E0      LDI	R30,0
    037C8 077E      CPC	R23,R30
    037C9 F039      BEQ	0x37D1
    037CA C007      RJMP	0x37D2
(0062) { 
(0063) case 1: 
(0064) {a=0x80;break;} 
    037CB E840      LDI	R20,0x80
    037CC C005      RJMP	0x37D2
(0065) case 2: 
(0066) {a=0x90;break;} 
    037CD E940      LDI	R20,0x90
    037CE C003      RJMP	0x37D2
(0067)   case 3: 
(0068) {a=0x88;break;} 
    037CF E848      LDI	R20,0x88
    037D0 C001      RJMP	0x37D2
(0069)   case 4: 
(0070) {a=0x98;break;} 
    037D1 E948      LDI	R20,0x98
(0071) } 
(0072) a=a+y-1;
    037D2 0F42      ADD	R20,R18
    037D3 5041      SUBI	R20,1
(0073) 
(0074) return a;
    037D4 2F04      MOV	R16,R20
    037D5 940C 3F8E JMP	pop_xgsetF000
_LCD_const_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    037D7 940E 3F76 CALL	push_xgset30FC
    037D9 2EE2      MOV	R14,R18
    037DA 2EC0      MOV	R12,R16
    037DB 9721      SBIW	R28,1
    037DC 84A9      LDD	R10,Y+9
    037DD 84BA      LDD	R11,Y+10
(0075) }
(0076)  
(0077) //////////////////////////////////////////////////////////////
(0078) 
(0079) /******************************************************************** 
(0080) 函数 名：LCD_const_disp
(0081) 入口参数：x y  *single_data
(0082) 出口参数：无 
(0083) 函数作用：负责 显示一串常量
(0084) 说        明： 
(0085) ********************************************************************/ 
(0086) void LCD_const_disp(unsigned char x, unsigned char y, const unsigned char *single_data) 
(0087) { 
(0088) unsigned char  a,i; 
(0089) a=address(x,y);
    037DE 2D2E      MOV	R18,R14
    037DF 2D0C      MOV	R16,R12
    037E0 DFD5      RCALL	_address
    037E1 2EC0      MOV	R12,R16
(0090) W_1byte(0,0,a);     //显示的地址 
    037E2 82C8      ST	Y,R12
    037E3 2722      CLR	R18
    037E4 2700      CLR	R16
    037E5 D0B7      RCALL	_W_1byte
(0091)    for(i=0; single_data[i]!='\0';i++) 
    037E6 2744      CLR	R20
    037E7 C00D      RJMP	0x37F5
(0092)    {
(0093)     if(i>=16) break; 
    037E8 3140      CPI	R20,0x10
    037E9 F008      BCS	0x37EB
    037EA C011      RJMP	0x37FC
(0094)     W_1byte(0,1,single_data[i]); 
    037EB 2FE4      MOV	R30,R20
    037EC 27FF      CLR	R31
    037ED 0DEA      ADD	R30,R10
    037EE 1DFB      ADC	R31,R11
    037EF 8020      LD	R2,Z
    037F0 8228      ST	Y,R2
    037F1 E021      LDI	R18,1
    037F2 2700      CLR	R16
    037F3 D0A9      RCALL	_W_1byte
    037F4 9543      INC	R20
    037F5 2FE4      MOV	R30,R20
    037F6 27FF      CLR	R31
    037F7 0DEA      ADD	R30,R10
    037F8 1DFB      ADC	R31,R11
    037F9 8020      LD	R2,Z
    037FA 2022      TST	R2
    037FB F761      BNE	0x37E8
(0095)     
(0096)    } 
(0097)    W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    037FC EF8F      LDI	R24,0xFF
    037FD 8388      ST	Y,R24
    037FE 2722      CLR	R18
    037FF 2700      CLR	R16
    03800 D09C      RCALL	_W_1byte
    03801 9621      ADIW	R28,1
    03802 940C 3F60 JMP	pop_xgset30FC
_LCD_var_disp:
  a                    --> R12
  i                    --> R20
  single_data          --> R10
  y                    --> R14
  x                    --> R12
    03804 940E 3F76 CALL	push_xgset30FC
    03806 2EE2      MOV	R14,R18
    03807 2EC0      MOV	R12,R16
    03808 9721      SBIW	R28,1
    03809 84A9      LDD	R10,Y+9
    0380A 84BA      LDD	R11,Y+10
(0098)  
(0099) } 
(0100) 
(0101) /******************************************************************** 
(0102) 函数 名：LCD_var_disp
(0103) 入口参数：single_row single_line  *single_data
(0104) 出口参数：无 
(0105) 函数作用：负责 显示一串变量
(0106) 说        明： 
(0107) ********************************************************************/ 
(0108) 
(0109) void LCD_var_disp(unsigned char x, unsigned char y, unsigned char *single_data) 
(0110) { 
(0111) unsigned char  a,i; 
(0112) 
(0113) #if _debug == 1 
(0114) 	PrintString_n(single_data);
(0115) #endif 
(0116) 
(0117) a=address( x,y);
    0380B 2D2E      MOV	R18,R14
    0380C 2D0C      MOV	R16,R12
    0380D DFA8      RCALL	_address
    0380E 2EC0      MOV	R12,R16
(0118) W_1byte(0,0,a);     //显示的地址0x88 
    0380F 82C8      ST	Y,R12
    03810 2722      CLR	R18
    03811 2700      CLR	R16
    03812 D08A      RCALL	_W_1byte
(0119) 
(0120) for(i=0; single_data[i]!='\0';i++) 
    03813 2744      CLR	R20
    03814 C00D      RJMP	0x3822
(0121)    { 
(0122)     if(i>=16) break;
    03815 3140      CPI	R20,0x10
    03816 F008      BCS	0x3818
    03817 C011      RJMP	0x3829
(0123)     W_1byte(0,1,single_data[i]); 
    03818 2FE4      MOV	R30,R20
    03819 27FF      CLR	R31
    0381A 0DEA      ADD	R30,R10
    0381B 1DFB      ADC	R31,R11
    0381C 8020      LD	R2,Z
    0381D 8228      ST	Y,R2
    0381E E021      LDI	R18,1
    0381F 2700      CLR	R16
    03820 D07C      RCALL	_W_1byte
    03821 9543      INC	R20
    03822 2FE4      MOV	R30,R20
    03823 27FF      CLR	R31
    03824 0DEA      ADD	R30,R10
    03825 1DFB      ADC	R31,R11
    03826 8020      LD	R2,Z
    03827 2022      TST	R2
    03828 F761      BNE	0x3815
(0124) 	} 
(0125)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03829 EF8F      LDI	R24,0xFF
    0382A 8388      ST	Y,R24
    0382B 2722      CLR	R18
    0382C 2700      CLR	R16
    0382D D06F      RCALL	_W_1byte
    0382E 9621      ADIW	R28,1
    0382F 940C 3F60 JMP	pop_xgset30FC
_LCD_char_disp:
  a                    --> R12
  data                 --> R10
  y                    --> R14
  x                    --> R12
    03831 940E 3F78 CALL	push_xgset00FC
    03833 2EE2      MOV	R14,R18
    03834 2EC0      MOV	R12,R16
    03835 9721      SBIW	R28,1
    03836 80AF      LDD	R10,Y+7
(0126) } 
(0127) /******************************************************************** 
(0128) 函数 名：LCD_char_disp
(0129) 入口参数：single_row single_line  data
(0130) 出口参数：无 
(0131) 函数作用：负责 显示一个 变量
(0132) 说        明： 
(0133) ********************************************************************/ 
(0134) 
(0135) void LCD_char_disp(unsigned char x, unsigned char y, unsigned char data) 
(0136) { 
(0137) unsigned char a; 
(0138) a=address(x,y);
    03837 2D2E      MOV	R18,R14
    03838 2D0C      MOV	R16,R12
    03839 DF7C      RCALL	_address
    0383A 2EC0      MOV	R12,R16
(0139) W_1byte(0,0,a);     //显示的地址 
    0383B 82C8      ST	Y,R12
    0383C 2722      CLR	R18
    0383D 2700      CLR	R16
    0383E D05E      RCALL	_W_1byte
(0140) W_1byte(0,1,data);  //显示内容
    0383F 82A8      ST	Y,R10
    03840 E021      LDI	R18,1
    03841 2700      CLR	R16
    03842 D05A      RCALL	_W_1byte
(0141)  
(0142)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03843 EF8F      LDI	R24,0xFF
    03844 8388      ST	Y,R24
    03845 2722      CLR	R18
    03846 2700      CLR	R16
    03847 D055      RCALL	_W_1byte
    03848 9621      ADIW	R28,1
    03849 940C 3F59 JMP	pop_xgset00FC
_LCD_Init:
  cmd                  --> R20
    0384B 934A      ST	-Y,R20
    0384C 9721      SBIW	R28,1
(0143) } 
(0144) 
(0145) /******************************************************************** 
(0146) 函数 名：LCD_Init
(0147) 入口参数：无
(0148) 出口参数：unsigned char  0/1
(0149) 函数作用：负责 清空液晶显示
(0150) 说        明： 
(0151) ********************************************************************/ 
(0152) void LCD_Init(void) 
(0153) { 
(0154)    unsigned char cmd; 
(0155)    cmd=0x30;      //功能设置 8 位数据，基本指令 
    0384D E340      LDI	R20,0x30
(0156)   W_1byte(0,0,cmd); 
    0384E 8348      ST	Y,R20
    0384F 2722      CLR	R18
    03850 2700      CLR	R16
    03851 D04B      RCALL	_W_1byte
(0157)   delayms(2); 
    03852 E002      LDI	R16,2
    03853 E010      LDI	R17,0
    03854 940E 23FF CALL	_delayms
(0158)   cmd=0x0C;      //显示状态 ON，游标OFF，反白OFF 
    03856 E04C      LDI	R20,0xC
(0159)   W_1byte(0,0,cmd); //写指令 
    03857 8348      ST	Y,R20
    03858 2722      CLR	R18
    03859 2700      CLR	R16
    0385A D042      RCALL	_W_1byte
(0160)   delayms(2); 
    0385B E002      LDI	R16,2
    0385C E010      LDI	R17,0
    0385D 940E 23FF CALL	_delayms
(0161)   cmd=0x01;      //清除显示 
    0385F E041      LDI	R20,1
(0162)   W_1byte(0,0,cmd); //写指令 
    03860 8348      ST	Y,R20
    03861 2722      CLR	R18
    03862 2700      CLR	R16
    03863 D039      RCALL	_W_1byte
(0163)   delayms(2); 
    03864 E002      LDI	R16,2
    03865 E010      LDI	R17,0
    03866 940E 23FF CALL	_delayms
(0164)   cmd=0x02;      //地址归位 
    03868 E042      LDI	R20,2
(0165)   W_1byte(0,0,cmd); //写指令 
    03869 8348      ST	Y,R20
    0386A 2722      CLR	R18
    0386B 2700      CLR	R16
    0386C D030      RCALL	_W_1byte
(0166)   delayms(2); 
    0386D E002      LDI	R16,2
    0386E E010      LDI	R17,0
    0386F 940E 23FF CALL	_delayms
(0167)   cmd=0x80;      //设置DDRAM 地址 
    03871 E840      LDI	R20,0x80
(0168)   W_1byte(0,0,cmd); //写指令 
    03872 8348      ST	Y,R20
    03873 2722      CLR	R18
    03874 2700      CLR	R16
    03875 D027      RCALL	_W_1byte
(0169)   delayms(2);     //延时 
    03876 E002      LDI	R16,2
    03877 E010      LDI	R17,0
    03878 940E 23FF CALL	_delayms
    0387A 9621      ADIW	R28,1
    0387B 9149      LD	R20,Y+
    0387C 9508      RET
_LCD_CLR:
  cmd                  --> R20
    0387D 934A      ST	-Y,R20
    0387E 9721      SBIW	R28,1
(0170) } 
(0171) 
(0172) void LCD_CLR(void)
(0173) {
(0174) unsigned char cmd;
(0175)   cmd=0x01;      //清除显示 
    0387F E041      LDI	R20,1
(0176)   W_1byte(0,0,cmd); //写指令 
    03880 8348      ST	Y,R20
    03881 2722      CLR	R18
    03882 2700      CLR	R16
    03883 D019      RCALL	_W_1byte
(0177)   delayms(1); 
    03884 E001      LDI	R16,1
    03885 E010      LDI	R17,0
    03886 940E 23FF CALL	_delayms
(0178)   cmd=0x02;      //地址归位 
    03888 E042      LDI	R20,2
(0179)   W_1byte(0,0,cmd); //写指令 
    03889 8348      ST	Y,R20
    0388A 2722      CLR	R18
    0388B 2700      CLR	R16
    0388C D010      RCALL	_W_1byte
(0180)   delayms(1); 
    0388D E001      LDI	R16,1
    0388E E010      LDI	R17,0
    0388F 940E 23FF CALL	_delayms
(0181)   cmd=0x80;      //设置DDRAM 地址 
    03891 E840      LDI	R20,0x80
(0182)   W_1byte(0,0,cmd); //写指令 
    03892 8348      ST	Y,R20
    03893 2722      CLR	R18
    03894 2700      CLR	R16
    03895 D007      RCALL	_W_1byte
(0183)   delayms(1);     //延时
    03896 E001      LDI	R16,1
    03897 E010      LDI	R17,0
    03898 940E 23FF CALL	_delayms
    0389A 9621      ADIW	R28,1
    0389B 9149      LD	R20,Y+
    0389C 9508      RET
_W_1byte:
  H_data               --> R22
  S_ID                 --> R10
  L_data               --> R20
  W_data               --> R12
  RS                   --> R14
  RW                   --> R20
    0389D 940E 3F74 CALL	push_xgsetF0FC
    0389F 2EE2      MOV	R14,R18
    038A0 2F40      MOV	R20,R16
    038A1 84CA      LDD	R12,Y+10
(0184) 
(0185) }
(0186)  
(0187) /*******************************************************************
(0188) 函 数 名：W_1byte
(0189) 入口参数：RW、RS、W_data
(0190) 出口参数：无
(0191) 建立日期：2007年3月3日
(0192) 修改日期：
(0193) 函数作用：写一个字节的数据到12864液晶，包括指令和数据
(0194) 说    明：RW=1，从液晶读数据到MCU；RW=0，写一个数据到液晶；
(0195) 		 （一般RW都设为0，即只向液晶写数据，不读数据）
(0196)           RS=1，写入的是数据；RS=0，写入的是指令；
(0197) 		  一般模式：RW=0，RS=1;写数据
(0198) 		  			RW=0，RS=0;写指令
(0199) ********************************************************************/
(0200) void W_1byte(unsigned char RW, unsigned char RS, unsigned char W_data)
(0201) {
(0202) 	unsigned int H_data,L_data,S_ID = 0xf8;	 //11111RWRS0
    038A2 EF88      LDI	R24,0xF8
    038A3 E090      LDI	R25,0
    038A4 015C      MOVW	R10,R24
(0203) 	if(RW == 0)
    038A5 2344      TST	R20
    038A6 F419      BNE	0x38AA
(0204) 	{
(0205) 	 	S_ID &=~ 0x04;
    038A7 7F8B      ANDI	R24,0xFB
    038A8 015C      MOVW	R10,R24
(0206) 	}
    038A9 C003      RJMP	0x38AD
(0207) 	else					//if(RW==1)
(0208) 	{
(0209) 	 	S_ID |= 0X04;
    038AA 01C5      MOVW	R24,R10
    038AB 6084      ORI	R24,4
    038AC 015C      MOVW	R10,R24
(0210) 	}
(0211) 	if(RS == 0)
    038AD 20EE      TST	R14
    038AE F421      BNE	0x38B3
(0212) 	{
(0213) 	 	S_ID &=~ 0x02;
    038AF 01C5      MOVW	R24,R10
    038B0 7F8D      ANDI	R24,0xFD
    038B1 015C      MOVW	R10,R24
(0214) 	}
    038B2 C003      RJMP	0x38B6
(0215) 	else					//if(RS==1)
(0216) 	{
(0217) 	 	S_ID |= 0X02;
    038B3 01C5      MOVW	R24,R10
    038B4 6082      ORI	R24,2
    038B5 015C      MOVW	R10,R24
(0218) 	}
(0219) 	H_data = W_data;
    038B6 2D6C      MOV	R22,R12
    038B7 2777      CLR	R23
(0220) 	H_data &= 0xf0;			//屏蔽低4位的数据
    038B8 7F60      ANDI	R22,0xF0
    038B9 7070      ANDI	R23,0
(0221) 	L_data = W_data;	   	//xxxx0000格式
    038BA 2D4C      MOV	R20,R12
    038BB 2755      CLR	R21
(0222) 	L_data &= 0x0f;			//屏蔽高4位的数据
    038BC 704F      ANDI	R20,0xF
    038BD 7050      ANDI	R21,0
(0223) 	L_data <<= 4;			//xxxx0000格式
    038BE 0F44      LSL	R20
    038BF 1F55      ROL	R21
    038C0 0F44      LSL	R20
    038C1 1F55      ROL	R21
    038C2 0F44      LSL	R20
    038C3 1F55      ROL	R21
    038C4 0F44      LSL	R20
    038C5 1F55      ROL	R21
(0224) 	Set_CS();
    038C6 9AA4      SBI	0x14,4
    038C7 9AAC      SBI	0x15,4
(0225) 	Write_8bits(S_ID); 		//发送S_ID
    038C8 0185      MOVW	R16,R10
    038C9 D00C      RCALL	_Write_8bits
(0226) 	Write_8bits(H_data);	//发送H_data
    038CA 018B      MOVW	R16,R22
    038CB D00A      RCALL	_Write_8bits
(0227) 	Write_8bits(L_data);	//发送L_data
    038CC 018A      MOVW	R16,R20
    038CD D008      RCALL	_Write_8bits
(0228) 	Clr_CS();	Clr_CS();	Clr_CS();	
    038CE 9AA4      SBI	0x14,4
    038CF 98AC      CBI	0x15,4
    038D0 9AA4      SBI	0x14,4
    038D1 98AC      CBI	0x15,4
    038D2 9AA4      SBI	0x14,4
    038D3 98AC      CBI	0x15,4
    038D4 940C 3F69 JMP	pop_xgsetF0FC
_Write_8bits:
  Temp_data            --> R12
  i                    --> R20
  W_bits               --> R10
    038D6 940E 3FA1 CALL	push_xgset303C
    038D8 0158      MOVW	R10,R16
(0229) 	 
(0230) 
(0231) }
(0232) /********************************************************************
(0233) 函 数 名：Write_8bits
(0234) 入口参数：W_bits
(0235) 出口参数：无
(0236) 建立日期：2007年3月3日
(0237) 修改日期：
(0238) 函数作用：负责串行输出8个bit位
(0239) 说    明：
(0240) ********************************************************************/
(0241) void Write_8bits(unsigned int W_bits)
(0242) {
(0243) 	unsigned int i,Temp_data;
(0244) 	for(i=0; i<8; i++)
    038D9 2744      CLR	R20
    038DA 2755      CLR	R21
    038DB C019      RJMP	0x38F5
(0245) 	{
(0246) 		Temp_data = W_bits;
    038DC 0165      MOVW	R12,R10
(0247) 		Temp_data <<= i;
    038DD 019A      MOVW	R18,R20
    038DE 0186      MOVW	R16,R12
    038DF 940E 3FEF CALL	lsl16
    038E1 0168      MOVW	R12,R16
(0248) 		if((Temp_data&0x80)==0) 
    038E2 FD07      SBRC	R16,7
    038E3 C003      RJMP	0x38E7
(0249) 		{
(0250) 		 	Clr_SID();
    038E4 9AA3      SBI	0x14,3
    038E5 98AB      CBI	0x15,3
(0251) 		}
    038E6 C002      RJMP	0x38E9
(0252) 		else
(0253) 		{
(0254) 		 	Set_SID();
    038E7 9AA3      SBI	0x14,3
    038E8 9AAB      SBI	0x15,3
(0255) 		} 
(0256) 		NOP();
    038E9 0000      NOP
(0257) 		Set_SCLK();
    038EA 9AA2      SBI	0x14,2
    038EB 9AAA      SBI	0x15,2
(0258) 		NOP();
    038EC 0000      NOP
(0259) 		NOP();
    038ED 0000      NOP
(0260) 		Clr_SCLK();
    038EE 9AA2      SBI	0x14,2
    038EF 98AA      CBI	0x15,2
(0261) 		NOP();
    038F0 0000      NOP
(0262) 		Clr_SID();
    038F1 9AA3      SBI	0x14,3
    038F2 98AB      CBI	0x15,3
    038F3 5F4F      SUBI	R20,0xFF
    038F4 4F5F      SBCI	R21,0xFF
    038F5 3048      CPI	R20,0x8
    038F6 E0E0      LDI	R30,0
    038F7 075E      CPC	R21,R30
    038F8 F318      BCS	0x38DC
    038F9 940C 3FA8 JMP	pop_xgset303C
_Set_Draw:
    038FB 9721      SBIW	R28,1
(0263) 	}
(0264) }
(0265)  
(0266) /********************************************************************
(0267) 函 数 名：Set_Draw(
(0268) 入口参数：无
(0269) 出口参数：无
(0270) 函数作用：设置为绘图模式
(0271) 说    明：
(0272) ********************************************************************/
(0273) void Set_Draw(void)
(0274) {  	
(0275) 	//W_1byte(0,0,0x34);			//8BIT控制界面，扩充指令集,，绘图显示OFF
(0276) 	W_1byte(0,0,0x36);
    038FC E386      LDI	R24,0x36
    038FD 8388      ST	Y,R24
    038FE 2722      CLR	R18
    038FF 2700      CLR	R16
    03900 DF9C      RCALL	_W_1byte
(0277) 	delayms(1);					//延时
    03901 E001      LDI	R16,1
    03902 E010      LDI	R17,0
    03903 940E 23FF CALL	_delayms
    03905 9621      ADIW	R28,1
    03906 9508      RET
_Set_White:
  clr_y                --> R10
  clr_x                --> R20
  white_y              --> Y,+2
  white_x              --> Y,+1
  i                    --> R22
  white_end_x          --> R12
  j                    --> R14
  clear                --> Y,+15
  end_x                --> R12
  y                    --> R14
  x                    --> R22
    03907 940E 3F74 CALL	push_xgsetF0FC
    03909 2EE2      MOV	R14,R18
    0390A 2F60      MOV	R22,R16
    0390B 9723      SBIW	R28,3
    0390C 84CD      LDD	R12,Y+13
(0278) } 
(0279)  
(0280) 
(0281) /******************************************************************** 
(0282) 函数 名：Set_White 
(0283) 入口参数：  x,   y,  end_x,  clear
(0284) 出口参数：无 
(0285) 函数作用： 设置反显
(0286) 说        明： 
(0287) ********************************************************************/ 
(0288) void Set_White(unsigned char x,unsigned char y,unsigned char end_x,unsigned char clear)
(0289) {
(0290)  
(0291) 	unsigned char i, j, white_x, white_y,white_end_x,clr_x,clr_y ;		//
(0292)   
(0293) 	W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    0390D E386      LDI	R24,0x36
    0390E 8388      ST	Y,R24
    0390F 2722      CLR	R18
    03910 2700      CLR	R16
    03911 DF8B      RCALL	_W_1byte
(0294) 	delayus(20);					//延时
    03912 E104      LDI	R16,0x14
    03913 E010      LDI	R17,0
    03914 940E 23F7 CALL	_delayus
(0295)  
(0296) 	white_end_x = (end_x-x+1);
    03916 2D8C      MOV	R24,R12
    03917 1B86      SUB	R24,R22
    03918 5F8F      SUBI	R24,0xFF
    03919 2EC8      MOV	R12,R24
(0297) 	white_end_x <<= 1;
    0391A 0CCC      LSL	R12
(0298) 	if(y==1)   //x,1  a=80+x-1                   
    0391B 2D8E      MOV	R24,R14
    0391C 3081      CPI	R24,1
    0391D F449      BNE	0x3927
(0299) 	{
(0300) 	 	white_x = (0x80+x-1); 
    0391E 2F86      MOV	R24,R22
    0391F 5880      SUBI	R24,0x80
    03920 5081      SUBI	R24,1
    03921 8389      STD	Y+1,R24
(0301) 		white_y = 0x80;
    03922 E880      LDI	R24,0x80
    03923 838A      STD	Y+2,R24
(0302) 		clr_x = 0x80;
    03924 E840      LDI	R20,0x80
(0303) 		clr_y = 0x80;
    03925 2EA8      MOV	R10,R24
(0304) 	}
    03926 C023      RJMP	0x394A
(0305) 	else if(y==2)
    03927 2D8E      MOV	R24,R14
    03928 3082      CPI	R24,2
    03929 F449      BNE	0x3933
(0306) 	{
(0307) 	 	white_x = (0x80+x-1);
    0392A 2F86      MOV	R24,R22
    0392B 5880      SUBI	R24,0x80
    0392C 5081      SUBI	R24,1
    0392D 8389      STD	Y+1,R24
(0308) 		white_y = 0x90;
    0392E E980      LDI	R24,0x90
    0392F 838A      STD	Y+2,R24
(0309) 		clr_x = 0x80;
    03930 E840      LDI	R20,0x80
(0310) 		clr_y = 0x90;
    03931 2EA8      MOV	R10,R24
(0311) 	}
    03932 C017      RJMP	0x394A
(0312) 	else if(y==3)
    03933 2D8E      MOV	R24,R14
    03934 3083      CPI	R24,3
    03935 F449      BNE	0x393F
(0313) 	{
(0314) 	 	white_x = (0x88+x-1);
    03936 2F86      MOV	R24,R22
    03937 5788      SUBI	R24,0x78
    03938 5081      SUBI	R24,1
    03939 8389      STD	Y+1,R24
(0315) 		white_y = 0x80;
    0393A E880      LDI	R24,0x80
    0393B 838A      STD	Y+2,R24
(0316) 		clr_x = 0x88;
    0393C E848      LDI	R20,0x88
(0317) 		clr_y = 0x80;
    0393D 2EA8      MOV	R10,R24
(0318) 	}
    0393E C00B      RJMP	0x394A
(0319) 	else if(y==4)
    0393F 2D8E      MOV	R24,R14
    03940 3084      CPI	R24,4
    03941 F441      BNE	0x394A
(0320) 	{
(0321) 	 	white_x = (0x88+x-1);
    03942 2F86      MOV	R24,R22
    03943 5788      SUBI	R24,0x78
    03944 5081      SUBI	R24,1
    03945 8389      STD	Y+1,R24
(0322) 		white_y = 0x90;
    03946 E980      LDI	R24,0x90
    03947 838A      STD	Y+2,R24
(0323) 		clr_x = 0x88;
    03948 E848      LDI	R20,0x88
(0324) 		clr_y = 0x90;
    03949 2EA8      MOV	R10,R24
(0325) 	}
(0326)   if(clear==0)//要反白时，先将整行的液晶全部清成不反白（此处行指y）
    0394A 840F      LDD	R0,Y+15
    0394B 2000      TST	R0
    0394C F4E9      BNE	0x396A
(0327) 	{
(0328) 	 	for(i=0;i<16;i++ )			//16行
    0394D 2766      CLR	R22
    0394E C019      RJMP	0x3968
(0329) 		{
(0330) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    0394F 2C2A      MOV	R2,R10
    03950 2D82      MOV	R24,R2
    03951 5F8F      SUBI	R24,0xFF
    03952 2EA8      MOV	R10,R24
    03953 8228      ST	Y,R2
    03954 2722      CLR	R18
    03955 2700      CLR	R16
    03956 DF46      RCALL	_W_1byte
(0331) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03957 8348      ST	Y,R20
    03958 2722      CLR	R18
    03959 2700      CLR	R16
    0395A DF42      RCALL	_W_1byte
(0332) 			for(j=0;j<16;j++)		//
    0395B 24EE      CLR	R14
    0395C C007      RJMP	0x3964
(0333) 			{
(0334) 			 	W_1byte(0,1,0x00);	//清成不反白
    0395D 2422      CLR	R2
    0395E 8228      ST	Y,R2
    0395F E021      LDI	R18,1
    03960 2700      CLR	R16
    03961 DF3B      RCALL	_W_1byte
(0335) 			 	nop();
    03962 0000      NOP
    03963 94E3      INC	R14
    03964 2D8E      MOV	R24,R14
    03965 3180      CPI	R24,0x10
    03966 F3B0      BCS	0x395D
    03967 9563      INC	R22
    03968 3160      CPI	R22,0x10
    03969 F328      BCS	0x394F
(0336) 			}
(0337) 		}
(0338) 	}
(0339) 	nop();
    0396A 0000      NOP
(0340) //	
(0341) 	for(i=0;i<16;i++ )				//16行，因为是16*16汉字
    0396B 2766      CLR	R22
    0396C C022      RJMP	0x398F
(0342) 	{
(0343) 		W_1byte(0,0,white_y++);		//设置绘图区的Y地址坐标0
    0396D 802A      LDD	R2,Y+2
    0396E 2D82      MOV	R24,R2
    0396F 5F8F      SUBI	R24,0xFF
    03970 838A      STD	Y+2,R24
    03971 8228      ST	Y,R2
    03972 2722      CLR	R18
    03973 2700      CLR	R16
    03974 DF28      RCALL	_W_1byte
(0344) 		W_1byte(0,0,white_x);		//设置绘图区的X地址坐标0
    03975 8009      LDD	R0,Y+1
    03976 8208      ST	Y,R0
    03977 2722      CLR	R18
    03978 2700      CLR	R16
    03979 DF23      RCALL	_W_1byte
(0345) 		for(j=0;j<white_end_x;j++)	//
    0397A 24EE      CLR	R14
    0397B C010      RJMP	0x398C
(0346) 		{
(0347) 			 if(clear==1)
    0397C 858F      LDD	R24,Y+15
    0397D 3081      CPI	R24,1
    0397E F431      BNE	0x3985
(0348) 			 {
(0349) 			  	W_1byte(0,1,0x00); //取消这一行的8个点的反白，液晶地址自动加1
    0397F 2422      CLR	R2
    03980 8228      ST	Y,R2
    03981 E021      LDI	R18,1
    03982 2700      CLR	R16
    03983 DF19      RCALL	_W_1byte
(0350) 								   //（此处行指一个一个液晶点所组成的行）
(0351) 			 }
    03984 C005      RJMP	0x398A
(0352) 			 else
(0353) 			 {
(0354) 				W_1byte(0,1,0xff); //反白这一行的8个点，液晶地址自动加1
    03985 EF8F      LDI	R24,0xFF
    03986 8388      ST	Y,R24
    03987 E021      LDI	R18,1
    03988 2700      CLR	R16
    03989 DF13      RCALL	_W_1byte
(0355) 								   //（此处行指一个一个液晶点所组成的行）
(0356) 			 }
(0357) 			nop();
    0398A 0000      NOP
    0398B 94E3      INC	R14
    0398C 14EC      CP	R14,R12
    0398D F370      BCS	0x397C
    0398E 9563      INC	R22
    0398F 3160      CPI	R22,0x10
    03990 F2E0      BCS	0x396D
(0358) 		}
(0359) 	}
(0360) 	W_1byte(0,0,0x30);		//基本指令集,，绘图显示OFF
    03991 E380      LDI	R24,0x30
    03992 8388      ST	Y,R24
    03993 2722      CLR	R18
    03994 2700      CLR	R16
    03995 DF07      RCALL	_W_1byte
    03996 9623      ADIW	R28,3
    03997 940C 3F69 JMP	pop_xgsetF0FC
_set_white_n:
  tempendx             --> R10
  tempy                --> R22
  tempx                --> R20
  clear                --> R12
  n                    --> R14
    03999 940E 3F74 CALL	push_xgsetF0FC
    0399B 2EC2      MOV	R12,R18
    0399C 2EE0      MOV	R14,R16
    0399D 9723      SBIW	R28,3
(0361)  }
(0362) 
(0363) /******************************************************************** 
(0364) 函数 名：set_white_n
(0365) 入口参数： n ,  clear
(0366) 出口参数：无 
(0367) 函数作用：   将四行分成八个位置。n代表位置1-8。本函数用于反显或取消反显
(0368)           某一位置的文字。
(0369) 说        明： 例如 set_white_n(1,0); 表示反显第一行前四个字
(0370) ********************************************************************/ 
(0371) void set_white_n(unsigned char n,unsigned char clear)
(0372) {
(0373) unsigned char tempx,tempy,tempendx;
(0374) if(n==1) {tempx=1;tempy=1;tempendx=4;}
    0399E 2D8E      MOV	R24,R14
    0399F 3081      CPI	R24,1
    039A0 F429      BNE	0x39A6
    039A1 E041      LDI	R20,1
    039A2 E061      LDI	R22,1
    039A3 E084      LDI	R24,4
    039A4 2EA8      MOV	R10,R24
    039A5 C037      RJMP	0x39DD
(0375) else if(n==2) {tempx=5;tempy=1;tempendx=8;}
    039A6 2D8E      MOV	R24,R14
    039A7 3082      CPI	R24,2
    039A8 F429      BNE	0x39AE
    039A9 E045      LDI	R20,5
    039AA E061      LDI	R22,1
    039AB E088      LDI	R24,0x8
    039AC 2EA8      MOV	R10,R24
    039AD C02F      RJMP	0x39DD
(0376) else if(n==3) {tempx=1;tempy=2;tempendx=4;}
    039AE 2D8E      MOV	R24,R14
    039AF 3083      CPI	R24,3
    039B0 F429      BNE	0x39B6
    039B1 E041      LDI	R20,1
    039B2 E062      LDI	R22,2
    039B3 E084      LDI	R24,4
    039B4 2EA8      MOV	R10,R24
    039B5 C027      RJMP	0x39DD
(0377) else if(n==4) {tempx=5;tempy=2;tempendx=8;}
    039B6 2D8E      MOV	R24,R14
    039B7 3084      CPI	R24,4
    039B8 F429      BNE	0x39BE
    039B9 E045      LDI	R20,5
    039BA E062      LDI	R22,2
    039BB E088      LDI	R24,0x8
    039BC 2EA8      MOV	R10,R24
    039BD C01F      RJMP	0x39DD
(0378) else if(n==5) {tempx=1;tempy=3;tempendx=4;}
    039BE 2D8E      MOV	R24,R14
    039BF 3085      CPI	R24,5
    039C0 F429      BNE	0x39C6
    039C1 E041      LDI	R20,1
    039C2 E063      LDI	R22,3
    039C3 E084      LDI	R24,4
    039C4 2EA8      MOV	R10,R24
    039C5 C017      RJMP	0x39DD
(0379) else if(n==6) {tempx=5;tempy=3;tempendx=8;}
    039C6 2D8E      MOV	R24,R14
    039C7 3086      CPI	R24,6
    039C8 F429      BNE	0x39CE
    039C9 E045      LDI	R20,5
    039CA E063      LDI	R22,3
    039CB E088      LDI	R24,0x8
    039CC 2EA8      MOV	R10,R24
    039CD C00F      RJMP	0x39DD
(0380) else if(n==7) {tempx=1;tempy=4;tempendx=4;}
    039CE 2D8E      MOV	R24,R14
    039CF 3087      CPI	R24,7
    039D0 F429      BNE	0x39D6
    039D1 E041      LDI	R20,1
    039D2 E064      LDI	R22,4
    039D3 E084      LDI	R24,4
    039D4 2EA8      MOV	R10,R24
    039D5 C007      RJMP	0x39DD
(0381) else if(n==8) {tempx=5;tempy=4;tempendx=8;}
    039D6 2D8E      MOV	R24,R14
    039D7 3088      CPI	R24,0x8
    039D8 F421      BNE	0x39DD
    039D9 E045      LDI	R20,5
    039DA E064      LDI	R22,4
    039DB E088      LDI	R24,0x8
    039DC 2EA8      MOV	R10,R24
(0382) Set_White(tempx,tempy,tempendx,clear);
    039DD 82CA      STD	Y+2,R12
    039DE 82A8      ST	Y,R10
    039DF 2F26      MOV	R18,R22
    039E0 2F04      MOV	R16,R20
    039E1 DF25      RCALL	_Set_White
    039E2 9623      ADIW	R28,3
    039E3 940C 3F69 JMP	pop_xgsetF0FC
_clr_white:
  clr_x                --> R10
  clr_y                --> R20
  i                    --> R22
  j                    --> R12
    039E5 940E 3F74 CALL	push_xgsetF0FC
    039E7 9721      SBIW	R28,1
(0383) 
(0384) }
(0385)  
(0386) /******************************************************************** 
(0387) 函数 名：clr_white
(0388) 入口参数： 清所有 反白
(0389) 出口参数：无 
(0390) 函数作用： 
(0391) 说        明： 
(0392) ********************************************************************/ 
(0393) void clr_white(void)
(0394) {      unsigned char i,j;
(0395) 
(0396)        unsigned char  clr_y=0x80;
    039E8 E840      LDI	R20,0x80
(0397) 	   unsigned char  clr_x=0x80;
    039E9 E880      LDI	R24,0x80
    039EA 2EA8      MOV	R10,R24
(0398) 	   W_1byte(0,0,0x36);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    039EB E386      LDI	R24,0x36
    039EC 8388      ST	Y,R24
    039ED 2722      CLR	R18
    039EE 2700      CLR	R16
    039EF DEAD      RCALL	_W_1byte
(0399) 	 	for(i=0;i<16;i++ )			//16行
    039F0 2766      CLR	R22
    039F1 C017      RJMP	0x3A09
(0400) 		{
(0401) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    039F2 2E24      MOV	R2,R20
    039F3 5F4F      SUBI	R20,0xFF
    039F4 8228      ST	Y,R2
    039F5 2722      CLR	R18
    039F6 2700      CLR	R16
    039F7 DEA5      RCALL	_W_1byte
(0402) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    039F8 82A8      ST	Y,R10
    039F9 2722      CLR	R18
    039FA 2700      CLR	R16
    039FB DEA1      RCALL	_W_1byte
(0403) 			for(j=0;j<16;j++)		//
    039FC 24CC      CLR	R12
    039FD C007      RJMP	0x3A05
(0404) 			{
(0405) 			 	W_1byte(0,1,0x00);	//清成不反白
    039FE 2422      CLR	R2
    039FF 8228      ST	Y,R2
    03A00 E021      LDI	R18,1
    03A01 2700      CLR	R16
    03A02 DE9A      RCALL	_W_1byte
(0406) 			 	nop();
    03A03 0000      NOP
    03A04 94C3      INC	R12
    03A05 2D8C      MOV	R24,R12
    03A06 3180      CPI	R24,0x10
    03A07 F3B0      BCS	0x39FE
    03A08 9563      INC	R22
    03A09 3160      CPI	R22,0x10
    03A0A F338      BCS	0x39F2
(0407) 			}
(0408) 		}
(0409) 	
(0410) 	    clr_y=0x80;
    03A0B E840      LDI	R20,0x80
(0411) 	    clr_x=0x90;
    03A0C E980      LDI	R24,0x90
    03A0D 2EA8      MOV	R10,R24
(0412) 		 	for(i=0;i<16;i++ )			//16行
    03A0E 2766      CLR	R22
    03A0F C017      RJMP	0x3A27
(0413) 		{
(0414) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03A10 2E24      MOV	R2,R20
    03A11 5F4F      SUBI	R20,0xFF
    03A12 8228      ST	Y,R2
    03A13 2722      CLR	R18
    03A14 2700      CLR	R16
    03A15 DE87      RCALL	_W_1byte
(0415) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03A16 82A8      ST	Y,R10
    03A17 2722      CLR	R18
    03A18 2700      CLR	R16
    03A19 DE83      RCALL	_W_1byte
(0416) 			for(j=0;j<16;j++)		//
    03A1A 24CC      CLR	R12
    03A1B C007      RJMP	0x3A23
(0417) 			{
(0418) 			 	W_1byte(0,1,0x00);	//清成不反白
    03A1C 2422      CLR	R2
    03A1D 8228      ST	Y,R2
    03A1E E021      LDI	R18,1
    03A1F 2700      CLR	R16
    03A20 DE7C      RCALL	_W_1byte
(0419) 			 	nop();
    03A21 0000      NOP
    03A22 94C3      INC	R12
    03A23 2D8C      MOV	R24,R12
    03A24 3180      CPI	R24,0x10
    03A25 F3B0      BCS	0x3A1C
    03A26 9563      INC	R22
    03A27 3160      CPI	R22,0x10
    03A28 F338      BCS	0x3A10
(0420) 			}
(0421) 		}   
(0422) 	   
(0423) 	     clr_y=0x88;
    03A29 E848      LDI	R20,0x88
(0424) 	     clr_x=0x80;
    03A2A E880      LDI	R24,0x80
    03A2B 2EA8      MOV	R10,R24
(0425) 		 	for(i=0;i<16;i++ )			//16行
    03A2C 2766      CLR	R22
    03A2D C017      RJMP	0x3A45
(0426) 		{
(0427) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03A2E 2EE4      MOV	R14,R20
    03A2F 5F4F      SUBI	R20,0xFF
    03A30 82E8      ST	Y,R14
    03A31 2722      CLR	R18
    03A32 2700      CLR	R16
    03A33 DE69      RCALL	_W_1byte
(0428) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03A34 82A8      ST	Y,R10
    03A35 2722      CLR	R18
    03A36 2700      CLR	R16
    03A37 DE65      RCALL	_W_1byte
(0429) 			for(j=0;j<16;j++)		//
    03A38 24CC      CLR	R12
    03A39 C007      RJMP	0x3A41
(0430) 			{
(0431) 			 	W_1byte(0,1,0x00);	//清成不反白
    03A3A 2422      CLR	R2
    03A3B 8228      ST	Y,R2
    03A3C E021      LDI	R18,1
    03A3D 2700      CLR	R16
    03A3E DE5E      RCALL	_W_1byte
(0432) 			 	nop();
    03A3F 0000      NOP
    03A40 94C3      INC	R12
    03A41 2D8C      MOV	R24,R12
    03A42 3180      CPI	R24,0x10
    03A43 F3B0      BCS	0x3A3A
    03A44 9563      INC	R22
    03A45 3160      CPI	R22,0x10
    03A46 F338      BCS	0x3A2E
(0433) 			}
(0434) 		} 
(0435) 	     clr_y=0x88;
    03A47 E848      LDI	R20,0x88
(0436) 	     clr_x=0x90;
    03A48 E980      LDI	R24,0x90
    03A49 2EA8      MOV	R10,R24
(0437) 		 	for(i=0;i<16;i++ )			//16行
    03A4A 2766      CLR	R22
    03A4B C017      RJMP	0x3A63
(0438) 		{
(0439) 		 	W_1byte(0,0,clr_y++);	//设置绘图区的Y地址坐标0
    03A4C 2EE4      MOV	R14,R20
    03A4D 5F4F      SUBI	R20,0xFF
    03A4E 82E8      ST	Y,R14
    03A4F 2722      CLR	R18
    03A50 2700      CLR	R16
    03A51 DE4B      RCALL	_W_1byte
(0440) 			W_1byte(0,0,clr_x);		//设置绘图区的X地址坐标0
    03A52 82A8      ST	Y,R10
    03A53 2722      CLR	R18
    03A54 2700      CLR	R16
    03A55 DE47      RCALL	_W_1byte
(0441) 			for(j=0;j<16;j++)		//
    03A56 24CC      CLR	R12
    03A57 C007      RJMP	0x3A5F
(0442) 			{
(0443) 			 	W_1byte(0,1,0x00);	//清成不反白
    03A58 2422      CLR	R2
    03A59 8228      ST	Y,R2
    03A5A E021      LDI	R18,1
    03A5B 2700      CLR	R16
    03A5C DE40      RCALL	_W_1byte
(0444) 			 	nop();
    03A5D 0000      NOP
    03A5E 94C3      INC	R12
    03A5F 2D8C      MOV	R24,R12
    03A60 3180      CPI	R24,0x10
    03A61 F3B0      BCS	0x3A58
    03A62 9563      INC	R22
    03A63 3160      CPI	R22,0x10
    03A64 F338      BCS	0x3A4C
(0445) 			}
(0446) 		} 		
(0447)   W_1byte(0,0,0x30);	  //8BIT控制界面，扩充指令集,，绘图显示ON
    03A65 E380      LDI	R24,0x30
    03A66 8388      ST	Y,R24
    03A67 2722      CLR	R18
    03A68 2700      CLR	R16
    03A69 DE33      RCALL	_W_1byte
    03A6A 9621      ADIW	R28,1
    03A6B 940C 3F69 JMP	pop_xgsetF0FC
_LCD_print2num:
  a                    --> R12
  tem                  --> R20
  num                  --> R10
  y                    --> R14
  x                    --> R12
    03A6D 940E 3F76 CALL	push_xgset30FC
    03A6F 2EE2      MOV	R14,R18
    03A70 2EC0      MOV	R12,R16
    03A71 9721      SBIW	R28,1
    03A72 84A9      LDD	R10,Y+9
(0448) 	}
(0449) /******************************************************************** 
(0450) 函数 名：LCD_print2num
(0451) 入口参数： 显示2数字
(0452) 出口参数：无 
(0453) 函数作用： 
(0454) 说        明： 
(0455) ********************************************************************/ 
(0456) void LCD_print2num(unsigned char x,unsigned char y,unsigned char num){
(0457) unsigned char tem;
(0458) unsigned char a; 
(0459) 
(0460) a=address(x,y);
    03A73 2D2E      MOV	R18,R14
    03A74 2D0C      MOV	R16,R12
    03A75 DD40      RCALL	_address
    03A76 2EC0      MOV	R12,R16
(0461) W_1byte(0,0,a);     //显示的地址 
    03A77 82C8      ST	Y,R12
    03A78 2722      CLR	R18
    03A79 2700      CLR	R16
    03A7A DE22      RCALL	_W_1byte
(0462) tem=num/10;
    03A7B E01A      LDI	R17,0xA
    03A7C 2D0A      MOV	R16,R10
    03A7D 940E 3EE6 CALL	div8u
    03A7F 2F40      MOV	R20,R16
(0463) W_1byte(0,1,tem+0x30);
    03A80 2F84      MOV	R24,R20
    03A81 5D80      SUBI	R24,0xD0
    03A82 8388      ST	Y,R24
    03A83 E021      LDI	R18,1
    03A84 2700      CLR	R16
    03A85 DE17      RCALL	_W_1byte
(0464) tem=num%10;
    03A86 E01A      LDI	R17,0xA
    03A87 2D0A      MOV	R16,R10
    03A88 940E 3EE4 CALL	mod8u
    03A8A 2F40      MOV	R20,R16
(0465) W_1byte(0,1,tem+0x30); 
    03A8B 2F84      MOV	R24,R20
    03A8C 5D80      SUBI	R24,0xD0
    03A8D 8388      ST	Y,R24
    03A8E E021      LDI	R18,1
    03A8F 2700      CLR	R16
    03A90 DE0C      RCALL	_W_1byte
(0466) W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03A91 EF8F      LDI	R24,0xFF
    03A92 8388      ST	Y,R24
    03A93 2722      CLR	R18
    03A94 2700      CLR	R16
    03A95 DE07      RCALL	_W_1byte
    03A96 9621      ADIW	R28,1
    03A97 940C 3F60 JMP	pop_xgset30FC
_LCD_print4num:
  tem                  --> R12
  num                  --> R14
  y                    --> R20
  x                    --> R10
    03A99 940E 3F76 CALL	push_xgset30FC
    03A9B 2F42      MOV	R20,R18
    03A9C 2EA0      MOV	R10,R16
    03A9D 9721      SBIW	R28,1
    03A9E 84E9      LDD	R14,Y+9
    03A9F 84FA      LDD	R15,Y+10
(0467) }
(0468)  
(0469) /******************************************************************** 
(0470) 函数 名：LCD_print4num
(0471) 入口参数： 显示4数字
(0472) 出口参数：无 
(0473) 函数作用： 
(0474) 说        明： 
(0475) ********************************************************************/ 
(0476) void LCD_print4num(unsigned char x,unsigned char y,unsigned int num){
(0477) unsigned char tem;
(0478) tem=num/100;
    03AA0 E624      LDI	R18,0x64
    03AA1 E030      LDI	R19,0
    03AA2 0187      MOVW	R16,R14
    03AA3 940E 3E60 CALL	div16u
    03AA5 2EC0      MOV	R12,R16
(0479) LCD_print2num(x,y,tem);
    03AA6 82C8      ST	Y,R12
    03AA7 2F24      MOV	R18,R20
    03AA8 2D0A      MOV	R16,R10
    03AA9 DFC3      RCALL	_LCD_print2num
(0480) 
(0481) tem=num%100;   
    03AAA E624      LDI	R18,0x64
    03AAB E030      LDI	R19,0
    03AAC 0187      MOVW	R16,R14
    03AAD 940E 3E5E CALL	mod16u
    03AAF 2EC0      MOV	R12,R16
(0482) LCD_print2num(x,y+1,tem);
    03AB0 82C8      ST	Y,R12
    03AB1 2F24      MOV	R18,R20
    03AB2 5F2F      SUBI	R18,0xFF
    03AB3 2D0A      MOV	R16,R10
    03AB4 DFB8      RCALL	_LCD_print2num
(0483) 
(0484) 
(0485)   W_1byte(0,0,0XFF); // 移走地址指针 防止下一输入内容的干扰
    03AB5 EF8F      LDI	R24,0xFF
    03AB6 8388      ST	Y,R24
    03AB7 2722      CLR	R18
    03AB8 2700      CLR	R16
    03AB9 DDE3      RCALL	_W_1byte
    03ABA 9621      ADIW	R28,1
    03ABB 940C 3F60 JMP	pop_xgset30FC
_LCD_print:
  a                    --> R12
  ch                   --> R10
  y                    --> R14
  x                    --> R12
    03ABD 940E 3F78 CALL	push_xgset00FC
    03ABF 2EE2      MOV	R14,R18
    03AC0 2EC0      MOV	R12,R16
    03AC1 9721      SBIW	R28,1
    03AC2 80AF      LDD	R10,Y+7
(0486) }
(0487)  
(0488) //////////////////////////////////////////////////////////////
(0489) 
(0490) /******************************************************************** 
(0491) 函数 名：LCD_print 
(0492) 入口参数： 显示1 ascii
(0493) 出口参数：无 
(0494) 函数作用： 
(0495) 说        明： 
(0496) ********************************************************************/ 
(0497) void LCD_print(unsigned char x,unsigned char y,unsigned char ch)
(0498) {  
(0499) unsigned char a; 
(0500) a=address(x,y);
    03AC3 2D2E      MOV	R18,R14
    03AC4 2D0C      MOV	R16,R12
    03AC5 DCF0      RCALL	_address
    03AC6 2EC0      MOV	R12,R16
(0501) W_1byte(0,0,a);     //显示的地址 
    03AC7 82C8      ST	Y,R12
    03AC8 2722      CLR	R18
    03AC9 2700      CLR	R16
    03ACA DDD2      RCALL	_W_1byte
(0502) W_1byte(0,1,ch); 
    03ACB 82A8      ST	Y,R10
    03ACC E021      LDI	R18,1
    03ACD 2700      CLR	R16
    03ACE DDCE      RCALL	_W_1byte
    03ACF 9621      ADIW	R28,1
    03AD0 940C 3F59 JMP	pop_xgset00FC
_LCD_print1:
  ch                   --> R10
    03AD2 92AA      ST	-Y,R10
    03AD3 2EA0      MOV	R10,R16
    03AD4 9721      SBIW	R28,1
(0503) 
(0504) 
(0505) 
(0506) }
(0507) /******************************************************************** 
(0508) 函数 名：LCD_print1 
(0509) 入口参数： 显示1 ascii
(0510) 出口参数：无 
(0511) 函数作用：接着上文地址显示，不重设地址 
(0512) 说        明： 
(0513) ********************************************************************/ 
(0514) void LCD_print1(char ch)
(0515) {  
(0516) W_1byte(0,1,ch); 
    03AD5 82A8      ST	Y,R10
    03AD6 E021      LDI	R18,1
    03AD7 2700      CLR	R16
    03AD8 DDC4      RCALL	_W_1byte
    03AD9 9621      ADIW	R28,1
    03ADA 90A9      LD	R10,Y+
    03ADB 9508      RET
_lp:
  p                    --> R10
    03ADC 92AA      ST	-Y,R10
    03ADD 92BA      ST	-Y,R11
    03ADE 0158      MOVW	R10,R16
    03ADF 9722      SBIW	R28,2
(0517) }
(0518) //////////////////////////////////////////////////////////////
(0519) 
(0520) 
(0521) 
(0522)  void lp(unsigned char *p)
(0523)  {
(0524)  static unsigned char *p1=" ",*p2=" ",*p3=" ",*p4=" ";
(0525)  p4=p3;
    03AE0 9020 04D4 LDS	R2,lcd.c:p3
    03AE2 9030 04D5 LDS	R3,lcd.c:p3+1
    03AE4 9230 04D7 STS	lcd.c:p4+1,R3
    03AE6 9220 04D6 STS	lcd.c:p4,R2
(0526)  p3=p2;
    03AE8 9020 04D2 LDS	R2,lcd.c:p2
    03AEA 9030 04D3 LDS	R3,lcd.c:p2+1
    03AEC 9230 04D5 STS	lcd.c:p3+1,R3
    03AEE 9220 04D4 STS	lcd.c:p3,R2
(0527)  p2=p1;
    03AF0 9020 04D0 LDS	R2,lcd.c:p1
    03AF2 9030 04D1 LDS	R3,lcd.c:p1+1
    03AF4 9230 04D3 STS	lcd.c:p2+1,R3
    03AF6 9220 04D2 STS	lcd.c:p2,R2
(0528)  p1=p;
    03AF8 92B0 04D1 STS	lcd.c:p1+1,R11
    03AFA 92A0 04D0 STS	lcd.c:p1,R10
(0529)   LCD_const_disp(1,1,"                ");
    03AFC ED88      LDI	R24,0xD8
    03AFD E094      LDI	R25,4
    03AFE 8399      STD	Y+1,R25
    03AFF 8388      ST	Y,R24
    03B00 E021      LDI	R18,1
    03B01 E001      LDI	R16,1
    03B02 DCD4      RCALL	_LCD_const_disp
(0530)   LCD_const_disp(2,1,"                ");
    03B03 ED88      LDI	R24,0xD8
    03B04 E094      LDI	R25,4
    03B05 8399      STD	Y+1,R25
    03B06 8388      ST	Y,R24
    03B07 E021      LDI	R18,1
    03B08 E002      LDI	R16,2
    03B09 DCCD      RCALL	_LCD_const_disp
(0531)   LCD_const_disp(3,1,"                ");
    03B0A ED88      LDI	R24,0xD8
    03B0B E094      LDI	R25,4
    03B0C 8399      STD	Y+1,R25
    03B0D 8388      ST	Y,R24
    03B0E E021      LDI	R18,1
    03B0F E003      LDI	R16,3
    03B10 DCC6      RCALL	_LCD_const_disp
(0532)   LCD_const_disp(4,1,"                ");
    03B11 ED88      LDI	R24,0xD8
    03B12 E094      LDI	R25,4
    03B13 8399      STD	Y+1,R25
    03B14 8388      ST	Y,R24
    03B15 E021      LDI	R18,1
    03B16 E004      LDI	R16,4
    03B17 DCBF      RCALL	_LCD_const_disp
(0533)   LCD_var_disp(1,1,p4);
    03B18 9020 04D6 LDS	R2,lcd.c:p4
    03B1A 9030 04D7 LDS	R3,lcd.c:p4+1
    03B1C 8239      STD	Y+1,R3
    03B1D 8228      ST	Y,R2
    03B1E E021      LDI	R18,1
    03B1F E001      LDI	R16,1
    03B20 DCE3      RCALL	_LCD_var_disp
(0534)   LCD_var_disp(2,1,p3);
    03B21 9020 04D4 LDS	R2,lcd.c:p3
    03B23 9030 04D5 LDS	R3,lcd.c:p3+1
    03B25 8239      STD	Y+1,R3
    03B26 8228      ST	Y,R2
    03B27 E021      LDI	R18,1
    03B28 E002      LDI	R16,2
    03B29 DCDA      RCALL	_LCD_var_disp
(0535)   LCD_var_disp(3,1,p2);
    03B2A 9020 04D2 LDS	R2,lcd.c:p2
    03B2C 9030 04D3 LDS	R3,lcd.c:p2+1
    03B2E 8239      STD	Y+1,R3
    03B2F 8228      ST	Y,R2
    03B30 E021      LDI	R18,1
    03B31 E003      LDI	R16,3
    03B32 DCD1      RCALL	_LCD_var_disp
(0536)   LCD_var_disp(4,1,p1);
    03B33 9020 04D0 LDS	R2,lcd.c:p1
    03B35 9030 04D1 LDS	R3,lcd.c:p1+1
    03B37 8239      STD	Y+1,R3
    03B38 8228      ST	Y,R2
    03B39 E021      LDI	R18,1
    03B3A E004      LDI	R16,4
    03B3B DCC8      RCALL	_LCD_var_disp
(0537)   delayms(300);
    03B3C E20C      LDI	R16,0x2C
    03B3D E011      LDI	R17,1
    03B3E 940E 23FF CALL	_delayms
    03B40 9622      ADIW	R28,2
    03B41 90B9      LD	R11,Y+
    03B42 90A9      LD	R10,Y+
    03B43 9508      RET
FILE: D:\LQD\software\master\software_src\relay.c
(0001) #include "config.h"
(0002) /*继电器初始化
(0003) *设置端口
(0004) *初始化关闭
(0005) */
(0006) void relay_init(void){
(0007) 	
(0008) 		RELAY_DDR_SET() ;
_relay_init:
    03B44 9AA5      SBI	0x14,5
(0009) 		RELAY_OFF();
    03B45 98AD      CBI	0x15,5
    03B46 9508      RET
(0010) 		//state.Relay = 0;
(0011) 	}	
(0012) 
(0013) /*继电器控制
(0014) *传入 ： 温度
(0015) *传出 ： 当前继电器状态
(0016) *
(0017) */
(0018) unsigned char  relay(int temp)
(0019) {
(0020) 	if(temp<HEAT_THRESHOLD)
_relay:
  temp                 --> R16
    03B47 3005      CPI	R16,5
    03B48 E0E0      LDI	R30,0
    03B49 071E      CPC	R17,R30
    03B4A F41C      BGE	0x3B4E
(0021) 	{
(0022) 	 		RELAY_DDR_SET();
    03B4B 9AA5      SBI	0x14,5
(0023) 			RELAY_ON();
    03B4C 9AAD      SBI	0x15,5
(0024) 			//state.Relay = 1 ;
(0025) 	}
    03B4D C002      RJMP	0x3B50
(0026) 	else
(0027) 	{
(0028) 	 	RELAY_DDR_SET();
    03B4E 9AA5      SBI	0x14,5
(0029) 		RELAY_OFF();
    03B4F 98AD      CBI	0x15,5
(0030) 		//state.Relay = 0 ;
(0031) 	}		
(0032) 	//return state.Relay;
(0033) 	return 0;
    03B50 2700      CLR	R16
    03B51 9508      RET
_beep:
  i                    --> R10
  short_beep           --> R12
  long_beep            --> R14
    03B52 940E 3F78 CALL	push_xgset00FC
    03B54 2EC2      MOV	R12,R18
    03B55 2EE0      MOV	R14,R16
FILE: D:\LQD\software\master\software_src\beep.c
(0001) #include "config.h"
(0002) 
(0003) #define BEEP_PORT	PORTC
(0004) #define BEEP_PIN	6
(0005) #define BEEP_OFF() BEEP_PORT|=(1<<BEEP_PIN)
(0006) #define BEEP_ON()  BEEP_PORT&=~(1<<BEEP_PIN)
(0007) //楦ｅ
(0008) void beep(unsigned char long_beep,unsigned char short_beep)
(0009) { 
(0010) unsigned char i;
(0011) DDRB|=(1<<0);
    03B56 9AB8      SBI	0x17,0
(0012) for(i=0;i<long_beep;i++)
    03B57 24AA      CLR	R10
    03B58 C00B      RJMP	0x3B64
(0013) {
(0014) BEEP_ON();  delayms(200);
    03B59 98AE      CBI	0x15,6
    03B5A EC08      LDI	R16,0xC8
    03B5B E010      LDI	R17,0
    03B5C 940E 23FF CALL	_delayms
(0015) BEEP_OFF(); delayms(50);
    03B5E 9AAE      SBI	0x15,6
    03B5F E302      LDI	R16,0x32
    03B60 E010      LDI	R17,0
    03B61 940E 23FF CALL	_delayms
    03B63 94A3      INC	R10
    03B64 14AE      CP	R10,R14
    03B65 F398      BCS	0x3B59
(0016) }
(0017) delayms(100);
    03B66 E604      LDI	R16,0x64
    03B67 E010      LDI	R17,0
    03B68 940E 23FF CALL	_delayms
(0018) for(i=0;i<short_beep;i++)
    03B6A 24AA      CLR	R10
    03B6B C00B      RJMP	0x3B77
(0019) {
(0020) BEEP_ON();  delayms(80);
    03B6C 98AE      CBI	0x15,6
    03B6D E500      LDI	R16,0x50
    03B6E E010      LDI	R17,0
    03B6F 940E 23FF CALL	_delayms
(0021) BEEP_OFF(); delayms(50);
    03B71 9AAE      SBI	0x15,6
    03B72 E302      LDI	R16,0x32
    03B73 E010      LDI	R17,0
    03B74 940E 23FF CALL	_delayms
    03B76 94A3      INC	R10
    03B77 14AC      CP	R10,R12
    03B78 F398      BCS	0x3B6C
    03B79 940C 3F59 JMP	pop_xgset00FC
_Delay_nus:
  i                    --> R20
  n                    --> R16
    03B7B 934A      ST	-Y,R20
    03B7C 935A      ST	-Y,R21
FILE: D:\LQD\software\master\software_src\DS18B20_driver.c
(0001) //------------------------------------------------------------------------------
(0002) // 文件名：DS18B20_driver.c
(0003) // 说明：  DS18B20驱动头文件
(0004) // 功能：  实现1-wire器件的读写
(0005) // 使用方法：   void Delay_nus(unsigned int n);             //延时n微秒函数
(0006) //              unsigned char reset_18B20(void);            //18B20复位
(0007) //              void write_bit_18B20(char bitval);          //写一位到18B20
(0008) //              unsigned char read_bit_18B20(void);         //读一位从18B20
(0009) //              void write_byte_18B20(unsigned char data);  //写一字节到18B20
(0010) //              unsigned char read_18B20(void);             //读一字节到18B20
(0011) //
(0012) // 运行平台：   AVR 8bit (M16已验证)
(0013) // 依存关系：   DS18B20_driver.h    DS18B20基本驱动头文件（函数声明）
(0014) // 移植人：     
(0015) // 最后修改：   
(0016) //------------------------------------------------------------------------------
(0017) 
(0018) #include "config.h"
(0019) #define DS18B20_PORT PORTG
(0020) #define DS18B20_PIN  PING
(0021) #define DS18B20_DDR  DDRG
(0022) #define CL_DQ   DS18B20_PORT&=~(1<<T_NUM)					   
(0023) #define SET_DQ  DS18B20_PORT|=(1<<T_NUM)			   
(0024) #define SET_OUT DS18B20_DDR|=(1<<T_NUM)				   
(0025) #define SET_IN  DS18B20_DDR&=~(1<<T_NUM)			   
(0026) #define IN_DQ   DS18B20_PIN&(1<<T_NUM)				  
(0027) unsigned char T_NUM=0;
(0028) 
(0029) 
(0030) //------------------------------------------------------------------------------
(0031) // 延时N微秒程序 供控制读写DS18B20时序使用
(0032) //------------------------------------------------------------------------------
(0033) void Delay_nus(unsigned int n)   
(0034) {  unsigned int i;
(0035) 	  for (i=0;i<n;i++) 
    03B7D 2744      CLR	R20
    03B7E 2755      CLR	R21
    03B7F C005      RJMP	0x3B85
(0036) 	  		{NOP();
    03B80 0000      NOP
(0037) 						NOP();
    03B81 0000      NOP
(0038) 						NOP();				        //20--300//比较接近
    03B82 0000      NOP
    03B83 5F4F      SUBI	R20,0xFF
    03B84 4F5F      SBCI	R21,0xFF
    03B85 1740      CP	R20,R16
    03B86 0751      CPC	R21,R17
    03B87 F3C0      BCS	0x3B80
    03B88 9159      LD	R21,Y+
    03B89 9149      LD	R20,Y+
    03B8A 9508      RET
_reset_18B20:
  bus_flag             --> R10
    03B8B 92AA      ST	-Y,R10
(0039) 					}
(0040) }
(0041) 
(0042) 
(0043) //------------------------------------------------------------------------------
(0044) // 1-wire总线复位
(0045) //------------------------------------------------------------------------------
(0046) unsigned char reset_18B20(void)
(0047) {
(0048) 	char bus_flag;
(0049) 	CLI();
    03B8C 94F8      BCLR	7
(0050) 	SET_DQ;
    03B8D 9110 04EB LDS	R17,T_NUM
    03B8F E001      LDI	R16,1
    03B90 940E 4002 CALL	lsl8
    03B92 9020 0065 LDS	R2,0x65
    03B94 2A20      OR	R2,R16
    03B95 9220 0065 STS	0x65,R2
(0051) 	SET_OUT;
    03B97 9110 04EB LDS	R17,T_NUM
    03B99 E001      LDI	R16,1
    03B9A 940E 4002 CALL	lsl8
    03B9C 9020 0064 LDS	R2,0x64
    03B9E 2A20      OR	R2,R16
    03B9F 9220 0064 STS	0x64,R2
(0052)  	
(0053)   	Delay_nus(1);
    03BA1 E001      LDI	R16,1
    03BA2 E010      LDI	R17,0
    03BA3 DFD7      RCALL	_Delay_nus
(0054)   	CL_DQ;
    03BA4 9110 04EB LDS	R17,T_NUM
    03BA6 E001      LDI	R16,1
    03BA7 940E 4002 CALL	lsl8
    03BA9 2E20      MOV	R2,R16
    03BAA 9420      COM	R2
    03BAB 9030 0065 LDS	R3,0x65
    03BAD 2032      AND	R3,R2
    03BAE 9230 0065 STS	0x65,R3
(0055)   	Delay_nus(550);		//拉低至少480us时间
    03BB0 E206      LDI	R16,0x26
    03BB1 E012      LDI	R17,2
    03BB2 DFC8      RCALL	_Delay_nus
(0056)   	SET_DQ;				//释放
    03BB3 9110 04EB LDS	R17,T_NUM
    03BB5 E001      LDI	R16,1
    03BB6 940E 4002 CALL	lsl8
    03BB8 9020 0065 LDS	R2,0x65
    03BBA 2A20      OR	R2,R16
    03BBB 9220 0065 STS	0x65,R2
(0057) 					NOP();
    03BBD 0000      NOP
(0058) 					NOP();
    03BBE 0000      NOP
(0059)   	SET_IN;				//输入
    03BBF 9110 04EB LDS	R17,T_NUM
    03BC1 E001      LDI	R16,1
    03BC2 940E 4002 CALL	lsl8
    03BC4 2E20      MOV	R2,R16
    03BC5 9420      COM	R2
    03BC6 9030 0064 LDS	R3,0x64
    03BC8 2032      AND	R3,R2
    03BC9 9230 0064 STS	0x64,R3
(0060)   	Delay_nus(60);
    03BCB E30C      LDI	R16,0x3C
    03BCC E010      LDI	R17,0
    03BCD DFAD      RCALL	_Delay_nus
(0061)   	
(0062) 						//等待回复
(0063)   	bus_flag = IN_DQ;
    03BCE 9110 04EB LDS	R17,T_NUM
    03BD0 E001      LDI	R16,1
    03BD1 940E 4002 CALL	lsl8
    03BD3 90A0 0063 LDS	R10,0x63
    03BD5 22A0      AND	R10,R16
(0064)   	
(0065)   	Delay_nus(240);		//回复的低电平在60到240US
    03BD6 EF00      LDI	R16,0xF0
    03BD7 E010      LDI	R17,0
    03BD8 DFA2      RCALL	_Delay_nus
(0066)   	SET_OUT;
    03BD9 9110 04EB LDS	R17,T_NUM
    03BDB E001      LDI	R16,1
    03BDC 940E 4002 CALL	lsl8
    03BDE 9020 0064 LDS	R2,0x64
    03BE0 2A20      OR	R2,R16
    03BE1 9220 0064 STS	0x64,R2
(0067) 					NOP();
    03BE3 0000      NOP
(0068) 					NOP();
    03BE4 0000      NOP
(0069)   	SET_DQ;				//回到初始DQ=1；
    03BE5 9110 04EB LDS	R17,T_NUM
    03BE7 E001      LDI	R16,1
    03BE8 940E 4002 CALL	lsl8
    03BEA 9020 0065 LDS	R2,0x65
    03BEC 2A20      OR	R2,R16
    03BED 9220 0065 STS	0x65,R2
(0070) 
(0071)   	SEI();
    03BEF 9478      BSET	7
(0072) 	if(bus_flag){
    03BF0 20AA      TST	R10
    03BF1 F011      BEQ	0x3BF4
(0073) 		return FALSE;
    03BF2 2700      CLR	R16
    03BF3 C001      RJMP	0x3BF5
(0074) 	}else{
(0075) 		return TRUE;
    03BF4 E001      LDI	R16,1
    03BF5 90A9      LD	R10,Y+
    03BF6 9508      RET
_write_bit_18B20:
  bitval               --> R10
    03BF7 92AA      ST	-Y,R10
    03BF8 2EA0      MOV	R10,R16
(0076) 	}
(0077) 
(0078) }
(0079) 
(0080) //------------------------------------------------------------------------------
(0081) // 写一位到总线
(0082) //------------------------------------------------------------------------------
(0083) void write_bit_18B20(char bitval)
(0084) {
(0085)     SET_OUT;
    03BF9 9110 04EB LDS	R17,T_NUM
    03BFB E001      LDI	R16,1
    03BFC 940E 4002 CALL	lsl8
    03BFE 9020 0064 LDS	R2,0x64
    03C00 2A20      OR	R2,R16
    03C01 9220 0064 STS	0x64,R2
(0086) 					NOP();
    03C03 0000      NOP
(0087) 					NOP();
    03C04 0000      NOP
(0088) 			 CL_DQ;
    03C05 9110 04EB LDS	R17,T_NUM
    03C07 E001      LDI	R16,1
    03C08 940E 4002 CALL	lsl8
    03C0A 2E20      MOV	R2,R16
    03C0B 9420      COM	R2
    03C0C 9030 0065 LDS	R3,0x65
    03C0E 2032      AND	R3,R2
    03C0F 9230 0065 STS	0x65,R3
(0089) 	   Delay_nus(1);
    03C11 E001      LDI	R16,1
    03C12 E010      LDI	R17,0
    03C13 DF67      RCALL	_Delay_nus
(0090) 	   if(bitval){    //写数据，从低位开始
    03C14 20AA      TST	R10
    03C15 F059      BEQ	0x3C21
(0091) 		     SET_DQ;
    03C16 9110 04EB LDS	R17,T_NUM
    03C18 E001      LDI	R16,1
    03C19 940E 4002 CALL	lsl8
    03C1B 9020 0065 LDS	R2,0x65
    03C1D 2A20      OR	R2,R16
    03C1E 9220 0065 STS	0x65,R2
(0092) 	  }else{
    03C20 C00C      RJMP	0x3C2D
(0093) 		     CL_DQ;
    03C21 9110 04EB LDS	R17,T_NUM
    03C23 E001      LDI	R16,1
    03C24 940E 4002 CALL	lsl8
    03C26 2E20      MOV	R2,R16
    03C27 9420      COM	R2
    03C28 9030 0065 LDS	R3,0x65
    03C2A 2032      AND	R3,R2
    03C2B 9230 0065 STS	0x65,R3
(0094) 	  }
(0095) 	Delay_nus(40);		//15~60us
    03C2D E208      LDI	R16,0x28
    03C2E E010      LDI	R17,0
    03C2F DF4B      RCALL	_Delay_nus
(0096) 	SET_DQ;
    03C30 9110 04EB LDS	R17,T_NUM
    03C32 E001      LDI	R16,1
    03C33 940E 4002 CALL	lsl8
    03C35 9020 0065 LDS	R2,0x65
    03C37 2A20      OR	R2,R16
    03C38 9220 0065 STS	0x65,R2
(0097) 	Delay_nus(10);
    03C3A E00A      LDI	R16,0xA
    03C3B E010      LDI	R17,0
    03C3C DF3E      RCALL	_Delay_nus
    03C3D 90A9      LD	R10,Y+
    03C3E 9508      RET
_read_bit_18B20:
  k                    --> R10
    03C3F 92AA      ST	-Y,R10
(0098) }
(0099) 
(0100) //------------------------------------------------------------------------------
(0101) // 读一位从总线
(0102) //------------------------------------------------------------------------------
(0103) unsigned char read_bit_18B20(void)
(0104) {
(0105) 	unsigned char k;
(0106) 	SET_OUT;
    03C40 9110 04EB LDS	R17,T_NUM
    03C42 E001      LDI	R16,1
    03C43 940E 4002 CALL	lsl8
    03C45 9020 0064 LDS	R2,0x64
    03C47 2A20      OR	R2,R16
    03C48 9220 0064 STS	0x64,R2
(0107) 	CL_DQ;			//读时间片开始，拉低总线至少1us
    03C4A 9110 04EB LDS	R17,T_NUM
    03C4C E001      LDI	R16,1
    03C4D 940E 4002 CALL	lsl8
    03C4F 2E20      MOV	R2,R16
    03C50 9420      COM	R2
    03C51 9030 0065 LDS	R3,0x65
    03C53 2032      AND	R3,R2
    03C54 9230 0065 STS	0x65,R3
(0108) 	Delay_nus(1);
    03C56 E001      LDI	R16,1
    03C57 E010      LDI	R17,0
    03C58 DF22      RCALL	_Delay_nus
(0109) 	
(0110) 					//SET_DQ;	
(0111) 	SET_IN;
    03C59 9110 04EB LDS	R17,T_NUM
    03C5B E001      LDI	R16,1
    03C5C 940E 4002 CALL	lsl8
    03C5E 2E20      MOV	R2,R16
    03C5F 9420      COM	R2
    03C60 9030 0064 LDS	R3,0x64
    03C62 2032      AND	R3,R2
    03C63 9230 0064 STS	0x64,R3
(0112) 	Delay_nus(4);
    03C65 E004      LDI	R16,4
    03C66 E010      LDI	R17,0
    03C67 DF13      RCALL	_Delay_nus
(0113) 	k=IN_DQ;    	//读数据,从低位开始
    03C68 9110 04EB LDS	R17,T_NUM
    03C6A E001      LDI	R16,1
    03C6B 940E 4002 CALL	lsl8
    03C6D 90A0 0063 LDS	R10,0x63
    03C6F 22A0      AND	R10,R16
(0114) 	Delay_nus(10);
    03C70 E00A      LDI	R16,0xA
    03C71 E010      LDI	R17,0
    03C72 DF08      RCALL	_Delay_nus
(0115) 	SET_DQ;	
    03C73 9110 04EB LDS	R17,T_NUM
    03C75 E001      LDI	R16,1
    03C76 940E 4002 CALL	lsl8
    03C78 9020 0065 LDS	R2,0x65
    03C7A 2A20      OR	R2,R16
    03C7B 9220 0065 STS	0x65,R2
(0116) 				NOP();
    03C7D 0000      NOP
(0117) 				NOP();
    03C7E 0000      NOP
(0118) 	SET_OUT;
    03C7F 9110 04EB LDS	R17,T_NUM
    03C81 E001      LDI	R16,1
    03C82 940E 4002 CALL	lsl8
    03C84 9020 0064 LDS	R2,0x64
    03C86 2A20      OR	R2,R16
    03C87 9220 0064 STS	0x64,R2
(0119) 	    NOP();
    03C89 0000      NOP
(0120) 					NOP();
    03C8A 0000      NOP
(0121) 	if(k){
    03C8B 20AA      TST	R10
    03C8C F011      BEQ	0x3C8F
(0122) 	    return 1;
    03C8D E001      LDI	R16,1
    03C8E C001      RJMP	0x3C90
(0123) 	}else{
(0124) 	    return 0;
    03C8F 2700      CLR	R16
    03C90 90A9      LD	R10,Y+
    03C91 9508      RET
_write_byte_18B20:
  i                    --> R20
  data                 --> R10
    03C92 92AA      ST	-Y,R10
    03C93 934A      ST	-Y,R20
    03C94 2EA0      MOV	R10,R16
(0125) 	}
(0126) 	
(0127) }
(0128) 
(0129) //------------------------------------------------------------------------------
(0130) // 写一个字节到总线
(0131) //------------------------------------------------------------------------------
(0132) void write_byte_18B20(unsigned char data)
(0133) {
(0134) 	unsigned char i;
(0135)    CLI();
    03C95 94F8      BCLR	7
(0136)     for(i=0;i<8;i++)
    03C96 2744      CLR	R20
    03C97 C009      RJMP	0x3CA1
(0137)     {
(0138)         write_bit_18B20(data&(1<<i));
    03C98 E001      LDI	R16,1
    03C99 2F14      MOV	R17,R20
    03C9A 940E 4002 CALL	lsl8
    03C9C 2E20      MOV	R2,R16
    03C9D 2D0A      MOV	R16,R10
    03C9E 2102      AND	R16,R2
    03C9F DF57      RCALL	_write_bit_18B20
    03CA0 9543      INC	R20
    03CA1 3048      CPI	R20,0x8
    03CA2 F3A8      BCS	0x3C98
(0139)         
(0140)     }
(0141)     SET_DQ;
    03CA3 9110 04EB LDS	R17,T_NUM
    03CA5 E001      LDI	R16,1
    03CA6 940E 4002 CALL	lsl8
    03CA8 9020 0065 LDS	R2,0x65
    03CAA 2A20      OR	R2,R16
    03CAB 9220 0065 STS	0x65,R2
(0142) 				  NOP();
    03CAD 0000      NOP
(0143) 					 NOP();
    03CAE 0000      NOP
(0144)     SEI();
    03CAF 9478      BSET	7
    03CB0 9149      LD	R20,Y+
    03CB1 90A9      LD	R10,Y+
    03CB2 9508      RET
_read_byte_18B20:
  temp                 --> R10
  n                    --> R20
    03CB3 92AA      ST	-Y,R10
    03CB4 934A      ST	-Y,R20
(0145)     
(0146)     //return;
(0147) }
(0148) 
(0149) //------------------------------------------------------------------------------
(0150) // 读一个字节
(0151) //------------------------------------------------------------------------------
(0152) unsigned char read_byte_18B20(void)
(0153) {
(0154) 	unsigned char temp,n;
(0155)     CLI();
    03CB5 94F8      BCLR	7
(0156)   	temp=0;
    03CB6 24AA      CLR	R10
(0157)     for(n=0;n<8;n++)
    03CB7 2744      CLR	R20
    03CB8 C014      RJMP	0x3CCD
(0158)     {
(0159)       	if(read_bit_18B20()){
    03CB9 DF85      RCALL	_read_bit_18B20
    03CBA 2300      TST	R16
    03CBB F031      BEQ	0x3CC2
(0160)       		temp|=(1<<n);
    03CBC E001      LDI	R16,1
    03CBD 2F14      MOV	R17,R20
    03CBE 940E 4002 CALL	lsl8
    03CC0 2AA0      OR	R10,R16
(0161)       	}else{
    03CC1 C007      RJMP	0x3CC9
(0162)       		temp&=~(1<<n);
    03CC2 E001      LDI	R16,1
    03CC3 2F14      MOV	R17,R20
    03CC4 940E 4002 CALL	lsl8
    03CC6 2E20      MOV	R2,R16
    03CC7 9420      COM	R2
    03CC8 20A2      AND	R10,R2
(0163)       	}
(0164)       	Delay_nus(70); //60~120us
    03CC9 E406      LDI	R16,0x46
    03CCA E010      LDI	R17,0
    03CCB DEAF      RCALL	_Delay_nus
    03CCC 9543      INC	R20
    03CCD 3048      CPI	R20,0x8
    03CCE F350      BCS	0x3CB9
(0165)       	
(0166)    }
(0167)    SEI();
    03CCF 9478      BSET	7
(0168) 
(0169)    return temp;
    03CD0 2D0A      MOV	R16,R10
    03CD1 9149      LD	R20,Y+
    03CD2 90A9      LD	R10,Y+
    03CD3 9508      RET
(0170) }
(0171) 
(0172) 
(0173) 
(0174) //------------------------------------------------------------------------------
(0175) // 应用函数部分！ 供外部调用
(0176) //------------------------------------------------------------------------------
(0177) //------------------------------------------------------------------------------
(0178) // 单器件/多器件：开始转换
(0179) //------------------------------------------------------------------------------
(0180) void convert_T(void)
(0181) {
(0182) 					if(reset_18B20()){
_convert_T:
    03CD4 DEB6      RCALL	_reset_18B20
    03CD5 2300      TST	R16
    03CD6 F021      BEQ	0x3CDB
(0183) 					write_byte_18B20(0xcc);
    03CD7 EC0C      LDI	R16,0xCC
    03CD8 DFB9      RCALL	_write_byte_18B20
(0184) 					write_byte_18B20(0x44);
    03CD9 E404      LDI	R16,0x44
    03CDA DFB7      RCALL	_write_byte_18B20
(0185) 					}
    03CDB 9508      RET
_read_T:
  sign                 --> Y,+1
  tmp                  --> Y,+0
  value                --> R10
    03CDC 940E 3F7A CALL	push_xgset003C
    03CDE 9724      SBIW	R28,4
(0186) }
(0187) 
(0188) //------------------------------------------------------------------------------
(0189) // 单器件：读温度，返回INIT8U型温度数据（原始数据）
(0190) //------------------------------------------------------------------------------
(0191) float read_T(void)
(0192) {
(0193)     unsigned int value=0;
    03CDF 24AA      CLR	R10
    03CE0 24BB      CLR	R11
(0194) 	unsigned char sign;
(0195) 	
(0196) 	float tmp;
(0197)     
(0198)     if(reset_18B20()){
    03CE1 DEA9      RCALL	_reset_18B20
    03CE2 2300      TST	R16
    03CE3 F021      BEQ	0x3CE8
(0199)     	write_byte_18B20(0xcc);
    03CE4 EC0C      LDI	R16,0xCC
    03CE5 DFAC      RCALL	_write_byte_18B20
(0200)     	write_byte_18B20(0xbe);
    03CE6 EB0E      LDI	R16,0xBE
    03CE7 DFAA      RCALL	_write_byte_18B20
(0201)     }
(0202)     
(0203)     value = (unsigned int)read_byte_18B20();
    03CE8 DFCA      RCALL	_read_byte_18B20
    03CE9 2EA0      MOV	R10,R16
    03CEA 24BB      CLR	R11
(0204)     value += ((unsigned int)(read_byte_18B20()))<<8;
    03CEB DFC7      RCALL	_read_byte_18B20
    03CEC 2EC0      MOV	R12,R16
    03CED 2C2C      MOV	R2,R12
    03CEE 2433      CLR	R3
    03CEF 2C32      MOV	R3,R2
    03CF0 2422      CLR	R2
    03CF1 0CA2      ADD	R10,R2
    03CF2 1CB3      ADC	R11,R3
(0205) 	/*   if((value&0x8000)==0x8000) //负温度
(0206) 					{
(0207) 					 sign=0;
(0208) 					 data=(~data)+1;       //补码形式，取反加一
(0209) 					}
(0210) 		elae 
(0211) 					{
(0212) 					 sign=1;
(0213) 					}
(0214) 		 xiaoshu1=(unsigned char) ((data&0x000f)*10/16);
(0215) 		 zhengshu=(unsigned char) (data>>4); 
(0216) 		*/
(0217) 	tmp= ((float)value)*0.0625;
    03CF3 EC08      LDI	R16,0xC8
    03CF4 E010      LDI	R17,0
    03CF5 940E 3EFC CALL	elpm32
    03CF7 0118      MOVW	R2,R16
    03CF8 0129      MOVW	R4,R18
    03CF9 0185      MOVW	R16,R10
    03CFA 940E 40CE CALL	uint2fp
    03CFC 933A      ST	-Y,R19
    03CFD 932A      ST	-Y,R18
    03CFE 931A      ST	-Y,R17
    03CFF 930A      ST	-Y,R16
    03D00 0181      MOVW	R16,R2
    03D01 0192      MOVW	R18,R4
    03D02 940E 4275 CALL	fpmule2
    03D04 8308      ST	Y,R16
    03D05 8319      STD	Y+1,R17
    03D06 832A      STD	Y+2,R18
    03D07 833B      STD	Y+3,R19
(0218) 	
(0219)     return( tmp);
    03D08 8108      LD	R16,Y
    03D09 8119      LDD	R17,Y+1
    03D0A 812A      LDD	R18,Y+2
    03D0B 813B      LDD	R19,Y+3
    03D0C 9624      ADIW	R28,4
    03D0D 940C 3F54 JMP	pop_xgset003C
_read_T_NUM:
  ttemp                --> Y,+0
  NUM                  --> R10
    03D0F 92AA      ST	-Y,R10
    03D10 2EA0      MOV	R10,R16
    03D11 9724      SBIW	R28,4
(0220) }
(0221) 
(0222) float read_T_NUM(unsigned char NUM){
(0223) float ttemp;
(0224) if ( NUM >1) return 123.45;
    03D12 E081      LDI	R24,1
    03D13 158A      CP	R24,R10
    03D14 F428      BCC	0x3D1A
    03D15 EC04      LDI	R16,0xC4
    03D16 E010      LDI	R17,0
    03D17 940E 3EFC CALL	elpm32
    03D19 C010      RJMP	0x3D2A
(0225) T_NUM=NUM;//设置访问器件
    03D1A 92A0 04EB STS	T_NUM,R10
(0226) convert_T();//温度转换
    03D1C DFB7      RCALL	_convert_T
(0227) delayms(800);
    03D1D E200      LDI	R16,0x20
    03D1E E013      LDI	R17,3
    03D1F 940E 23FF CALL	_delayms
(0228) ttemp=read_T();
    03D21 DFBA      RCALL	_read_T
    03D22 8308      ST	Y,R16
    03D23 8319      STD	Y+1,R17
    03D24 832A      STD	Y+2,R18
    03D25 833B      STD	Y+3,R19
(0229) return ttemp;
    03D26 8108      LD	R16,Y
    03D27 8119      LDD	R17,Y+1
    03D28 812A      LDD	R18,Y+2
    03D29 813B      LDD	R19,Y+3
    03D2A 9624      ADIW	R28,4
    03D2B 90A9      LD	R10,Y+
    03D2C 9508      RET
FILE: D:\LQD\software\master\software_src\ds1302.c
(0001) #include "config.h"
(0002) 
(0003) #define TPORT PORTB
(0004) #define TDDR DDRB
(0005) #define TPIN PINB
(0006) #define PIN_RST	 4
(0007) #define PIN_IO	 5
(0008) #define PIN_SCK	 6
(0009) /******************复位脚*********************/
(0010) #define RST_CLR	TPORT &= ~(1 << PIN_RST)   /*电平置低*/
(0011) #define RST_SET	TPORT |= (1 << PIN_RST)    /*电平置高*/
(0012) #define RST_IN	TDDR &= ~(1 << PIN_RST)    /*方向输入*/
(0013) #define RST_OUT	TDDR |= (1 << PIN_RST)     /*方向输出*/
(0014) 
(0015) /*****************双向数据********************/
(0016) #define IO_CLR	TPORT &= ~(1 << PIN_IO)  /*电平置低*/
(0017) #define IO_SET	TPORT |= (1 << PIN_IO)   /*电平置高*/
(0018) #define IO_R	TPIN & (1 << PIN_IO)     /*电平读取*/
(0019) #define IO_IN	TDDR &= ~(1 << PIN_IO)   /*方向输入*/
(0020) #define IO_OUT	TDDR |= (1 << PIN_IO)    /*方向输出*/
(0021) 
(0022) /*****************时钟信号*******************/
(0023) #define SCK_CLR	TPORT &= ~(1 << PIN_SCK)  /*时钟信号*/
(0024) #define SCK_SET	TPORT |= (1 << PIN_SCK)   /*电平置高*/
(0025) #define SCK_IN	TDDR &= ~(1 << PIN_SCK)   /*方向输入*/
(0026) #define SCK_OUT	TDDR |= (1 << PIN_SCK)    /*方向输出*/
(0027) 
(0028) #define ds1302_sec_add			0x80		//秒数据地址
(0029) #define ds1302_min_add			0x82		//分数据地址
(0030) #define ds1302_hr_add			0x84		//时数据地址
(0031) #define ds1302_date_add			0x86		//日数据地址
(0032) #define ds1302_month_add		0x88		//月数据地址
(0033) #define ds1302_day_add			0x8a		//星期数据地址
(0034) #define ds1302_year_add			0x8c		//年数据地址
(0035) #define ds1302_control_add		0x8e		//控制数据地址
(0036) #define ds1302_charger_add		0x90 					 
(0037) #define ds1302_clkburst_add		0xbe
(0038) 
(0039) unsigned char time_buf[8] = {0x20,0x0c,0x0A,0x1c,0x22,0x46,0x00,0x06};
(0040) /*
(0041)  struct tm {
(0042)    	int tm_sec;   // 秒 seconds after the minute, 0 to 60
(0043)    	int tm_min;   // 分 minutes after the hour, 0 to 59
(0044) 	int tm_hour;  // 时 hours since midnight, 0 to 23*
(0045) 	int tm_mday;  // 日 day of the month, 1 to 31
(0046) 	int tm_mon;   // 月 months since January, 0 to 11
(0047) 	int tm_year;  // 年 years since 1900
(0048) 	int tm_wday;  // 星期 days since Sunday, 0 to 6
(0049) 	int tm_yday;  // 从元旦起的天数 days since January 1, 0 to 365
(0050)  	int tm_isdst; // 夏令时？？Daylight Savings Time flag
(0051)  	};	
(0052) 	*/
(0053) 
(0054) //DS1302初始化函数
(0055) void ds1302_init(void) 
(0056) {
(0057) 	RST_CLR;			/*RST脚置低*/
_ds1302_init:
    03D2D 98C4      CBI	0x18,4
(0058) 	SCK_CLR;			/*SCK脚置低*/
    03D2E 98C6      CBI	0x18,6
(0059) 	RST_OUT;			/*RST脚设置为输出*/
    03D2F 9ABC      SBI	0x17,4
(0060) 	SCK_OUT;			/*SCK脚设置为输出*/
    03D30 9ABE      SBI	0x17,6
    03D31 9508      RET
_ds1302_write_byte:
  i                    --> R20
  d                    --> R18
  addr                 --> R16
    03D32 934A      ST	-Y,R20
(0061) }
(0062) 
(0063) //向DS1302写入一字节数据
(0064) void ds1302_write_byte(unsigned char addr, unsigned char d) {
(0065) 
(0066) 	unsigned char i;
(0067) 	RST_SET;					/*启动DS1302总线*/
    03D33 9AC4      SBI	0x18,4
(0068) 	
(0069) 	/*写入目标地址：addr*/
(0070) 	IO_OUT;
    03D34 9ABD      SBI	0x17,5
(0071) 	addr = addr & 0xFE;   //最低位置零，寄存器0位为0时写，为1时读
    03D35 7F0E      ANDI	R16,0xFE
(0072) 	for (i = 0; i < 8; i ++) {
    03D36 2744      CLR	R20
    03D37 C009      RJMP	0x3D41
(0073) 		if (addr & 0x01) {
    03D38 FF00      SBRS	R16,0
    03D39 C002      RJMP	0x3D3C
(0074) 			IO_SET;
    03D3A 9AC5      SBI	0x18,5
(0075) 			}
    03D3B C001      RJMP	0x3D3D
(0076) 		else {
(0077) 			IO_CLR;
    03D3C 98C5      CBI	0x18,5
(0078) 			}
(0079) 		SCK_SET;      //产生时钟
    03D3D 9AC6      SBI	0x18,6
(0080) 		SCK_CLR;
    03D3E 98C6      CBI	0x18,6
(0081) 		addr = addr >> 1;
    03D3F 9506      LSR	R16
    03D40 9543      INC	R20
    03D41 3048      CPI	R20,0x8
    03D42 F3A8      BCS	0x3D38
(0082) 		}
(0083) 	
(0084) 	/*写入数据：d*/
(0085) 	IO_OUT;
    03D43 9ABD      SBI	0x17,5
(0086) 	for (i = 0; i < 8; i ++) {
    03D44 2744      CLR	R20
    03D45 C009      RJMP	0x3D4F
(0087) 		if (d & 0x01) {
    03D46 FF20      SBRS	R18,0
    03D47 C002      RJMP	0x3D4A
(0088) 			IO_SET;
    03D48 9AC5      SBI	0x18,5
(0089) 			}
    03D49 C001      RJMP	0x3D4B
(0090) 		else {
(0091) 			IO_CLR;
    03D4A 98C5      CBI	0x18,5
(0092) 			}
(0093) 		SCK_SET;    //产生时钟
    03D4B 9AC6      SBI	0x18,6
(0094) 		SCK_CLR;
    03D4C 98C6      CBI	0x18,6
(0095) 		d = d >> 1;
    03D4D 9526      LSR	R18
    03D4E 9543      INC	R20
    03D4F 3048      CPI	R20,0x8
    03D50 F3A8      BCS	0x3D46
(0096) 		}
(0097) 	RST_CLR;		//停止DS1302总线
    03D51 98C4      CBI	0x18,4
    03D52 9149      LD	R20,Y+
    03D53 9508      RET
_ds1302_read_byte:
  temp                 --> R20
  i                    --> R22
  addr                 --> R16
    03D54 934A      ST	-Y,R20
    03D55 936A      ST	-Y,R22
(0098) 	
(0099) }
(0100) 
(0101) //从DS1302读出一字节数据
(0102) unsigned char ds1302_read_byte(unsigned char addr) {
(0103) 
(0104) 	unsigned char i;
(0105) 	unsigned char temp;
(0106) 	RST_SET;					/*启动DS1302总线*/
    03D56 9AC4      SBI	0x18,4
(0107) 
(0108) 	/*写入目标地址：addr*/
(0109) 	IO_OUT;
    03D57 9ABD      SBI	0x17,5
(0110) 	addr = addr | 0x01;    //最低位置高，寄存器0位为0时写，为1时读
    03D58 6001      ORI	R16,1
(0111) 	for (i = 0; i < 8; i ++) {
    03D59 2766      CLR	R22
    03D5A C009      RJMP	0x3D64
(0112) 		if (addr & 0x01) {
    03D5B FF00      SBRS	R16,0
    03D5C C002      RJMP	0x3D5F
(0113) 			IO_SET;
    03D5D 9AC5      SBI	0x18,5
(0114) 			}
    03D5E C001      RJMP	0x3D60
(0115) 		else {
(0116) 			IO_CLR;
    03D5F 98C5      CBI	0x18,5
(0117) 			}
(0118) 		SCK_SET;
    03D60 9AC6      SBI	0x18,6
(0119) 		SCK_CLR;
    03D61 98C6      CBI	0x18,6
(0120) 		addr = addr >> 1;
    03D62 9506      LSR	R16
    03D63 9563      INC	R22
    03D64 3068      CPI	R22,0x8
    03D65 F3A8      BCS	0x3D5B
(0121) 		}
(0122) 	
(0123) 	/*输出数据：temp*/
(0124) 	IO_IN;
    03D66 98BD      CBI	0x17,5
(0125) 	for (i = 0; i < 8; i ++) {
    03D67 2766      CLR	R22
    03D68 C009      RJMP	0x3D72
(0126) 		temp = temp >> 1;
    03D69 9546      LSR	R20
(0127) 		if (IO_R) {
    03D6A 9BB5      SBIS	0x16,5
    03D6B C002      RJMP	0x3D6E
(0128) 			temp |= 0x80;
    03D6C 6840      ORI	R20,0x80
(0129) 			}
    03D6D C001      RJMP	0x3D6F
(0130) 		else {
(0131) 			temp &= 0x7F;
    03D6E 774F      ANDI	R20,0x7F
(0132) 			}
(0133) 		SCK_SET;
    03D6F 9AC6      SBI	0x18,6
(0134) 		SCK_CLR;
    03D70 98C6      CBI	0x18,6
    03D71 9563      INC	R22
    03D72 3068      CPI	R22,0x8
    03D73 F3A8      BCS	0x3D69
(0135) 		}
(0136) 	
(0137) 	RST_CLR;					/*停止DS1302总线*/
    03D74 98C4      CBI	0x18,4
(0138) 	return temp;
    03D75 2F04      MOV	R16,R20
    03D76 9169      LD	R22,Y+
    03D77 9149      LD	R20,Y+
    03D78 9508      RET
(0139) }
(0140) 
(0141) //向DS302写入时钟数据
(0142) void ds1302_write_time(void) {
(0143) 
(0144) 	ds1302_write_byte(ds1302_control_add,0x00);			//关闭写保护 
_ds1302_write_time:
    03D79 2722      CLR	R18
    03D7A E80E      LDI	R16,0x8E
    03D7B DFB6      RCALL	_ds1302_write_byte
(0145) 	ds1302_write_byte(ds1302_sec_add,0x80);				//暂停时钟 
    03D7C E820      LDI	R18,0x80
    03D7D E800      LDI	R16,0x80
    03D7E DFB3      RCALL	_ds1302_write_byte
(0146) 	//ds1302_write_byte(ds1302_charger_add,0xa9);	    //涓流充电 
(0147) 	ds1302_write_byte(ds1302_year_add,time_buf[1]);		//年 
    03D7F 9120 04ED LDS	R18,time_buf+1
    03D81 E80C      LDI	R16,0x8C
    03D82 DFAF      RCALL	_ds1302_write_byte
(0148) 	ds1302_write_byte(ds1302_month_add,time_buf[2]);	//月 
    03D83 9120 04EE LDS	R18,time_buf+2
    03D85 E808      LDI	R16,0x88
    03D86 DFAB      RCALL	_ds1302_write_byte
(0149) 	ds1302_write_byte(ds1302_date_add,time_buf[3]);		//日 
    03D87 9120 04EF LDS	R18,time_buf+3
    03D89 E806      LDI	R16,0x86
    03D8A DFA7      RCALL	_ds1302_write_byte
(0150) 	ds1302_write_byte(ds1302_hr_add,time_buf[4]);		//时 
    03D8B 9120 04F0 LDS	R18,time_buf+4
    03D8D E804      LDI	R16,0x84
    03D8E DFA3      RCALL	_ds1302_write_byte
(0151) 	ds1302_write_byte(ds1302_min_add,time_buf[5]);		//分
    03D8F 9120 04F1 LDS	R18,time_buf+5
    03D91 E802      LDI	R16,0x82
    03D92 DF9F      RCALL	_ds1302_write_byte
(0152) 	ds1302_write_byte(ds1302_sec_add,time_buf[6]);		//秒
    03D93 9120 04F2 LDS	R18,time_buf+6
    03D95 E800      LDI	R16,0x80
    03D96 DF9B      RCALL	_ds1302_write_byte
(0153) 	ds1302_write_byte(ds1302_day_add,time_buf[7]);		//周 
    03D97 9120 04F3 LDS	R18,time_buf+7
    03D99 E80A      LDI	R16,0x8A
    03D9A DF97      RCALL	_ds1302_write_byte
(0154) 	ds1302_write_byte(ds1302_control_add,0x80);			//打开写保护 
    03D9B E820      LDI	R18,0x80
    03D9C E80E      LDI	R16,0x8E
    03D9D CF94      RJMP	_ds1302_write_byte
_ds1302_read_time:
    03D9E 92AA      ST	-Y,R10
    03D9F 934A      ST	-Y,R20
(0155) }
(0156) 
(0157) //从DS302读出时钟数据
(0158) void ds1302_read_time(void)  { 
(0159) 	time_buf[1]=ds1302_read_byte(ds1302_year_add);		//年 
    03DA0 E80C      LDI	R16,0x8C
    03DA1 DFB2      RCALL	_ds1302_read_byte
    03DA2 9300 04ED STS	time_buf+1,R16
(0160) 	time_buf[2]=ds1302_read_byte(ds1302_month_add);		//月 
    03DA4 E808      LDI	R16,0x88
    03DA5 DFAE      RCALL	_ds1302_read_byte
    03DA6 9300 04EE STS	time_buf+2,R16
(0161) 	time_buf[3]=ds1302_read_byte(ds1302_date_add);		//日 
    03DA8 E806      LDI	R16,0x86
    03DA9 DFAA      RCALL	_ds1302_read_byte
    03DAA 2EA0      MOV	R10,R16
    03DAB 92A0 04EF STS	time_buf+3,R10
(0162) 	time_buf[4]=ds1302_read_byte(ds1302_hr_add);		//时 
    03DAD E804      LDI	R16,0x84
    03DAE DFA5      RCALL	_ds1302_read_byte
    03DAF 2EA0      MOV	R10,R16
    03DB0 92A0 04F0 STS	time_buf+4,R10
(0163) 	time_buf[5]=ds1302_read_byte(ds1302_min_add);		//分 
    03DB2 E802      LDI	R16,0x82
    03DB3 DFA0      RCALL	_ds1302_read_byte
    03DB4 2EA0      MOV	R10,R16
    03DB5 92A0 04F1 STS	time_buf+5,R10
(0164) 	time_buf[6]=(ds1302_read_byte(ds1302_sec_add))&0x7F;//秒，屏蔽秒的第7位，避免超出59
    03DB7 E800      LDI	R16,0x80
    03DB8 DF9B      RCALL	_ds1302_read_byte
    03DB9 2F40      MOV	R20,R16
    03DBA 2F84      MOV	R24,R20
    03DBB 778F      ANDI	R24,0x7F
    03DBC 9380 04F2 STS	time_buf+6,R24
(0165) 	time_buf[7]=ds1302_read_byte(ds1302_day_add);		//周 
    03DBE E80A      LDI	R16,0x8A
    03DBF DF94      RCALL	_ds1302_read_byte
    03DC0 2EA0      MOV	R10,R16
    03DC1 92A0 04F3 STS	time_buf+7,R10
    03DC3 9149      LD	R20,Y+
    03DC4 90A9      LD	R10,Y+
    03DC5 9508      RET
_kbscan:
  key                  --> R20
  temp                 --> Y,+0
    03DC6 934A      ST	-Y,R20
    03DC7 9724      SBIW	R28,4
FILE: D:\LQD\software\master\software_src\key.c
(0001) #include "config.h"
(0002) //键盘扫描函数
(0003) unsigned char kbscan(void)
(0004)   {
(0005)    unsigned char key;
(0006)    unsigned long temp=0;
    03DC8 E080      LDI	R24,0
    03DC9 8388      ST	Y,R24
    03DCA 8389      STD	Y+1,R24
    03DCB 838A      STD	Y+2,R24
    03DCC 838B      STD	Y+3,R24
(0007)    DDR_SET;
    03DCD B38A      IN	R24,0x1A
    03DCE 7087      ANDI	R24,7
    03DCF BB8A      OUT	0x1A,R24
(0008)    
(0009)    if((KEY_PIN) != KEY_MASK)         //检测A口按键引脚电平，如果全是高电平则退出
    03DD0 B389      IN	R24,0x19
    03DD1 718F      ANDI	R24,0x1F
    03DD2 318F      CPI	R24,0x1F
    03DD3 F189      BEQ	0x3E05
(0010)     {
(0011)      delayms(20);           //防抖
    03DD4 E104      LDI	R16,0x14
    03DD5 E010      LDI	R17,0
    03DD6 940E 23FF CALL	_delayms
(0012)      if((KEY_PIN) != KEY_MASK )      //再次检测A口电平，如果不全是高电平则继续执行程序
    03DD8 B389      IN	R24,0x19
    03DD9 718F      ANDI	R24,0x1F
    03DDA 318F      CPI	R24,0x1F
    03DDB F159      BEQ	0x3E07
(0013)       {
(0014)        key = KEY_PIN ;          //读取PINA，将其存放在key中
    03DDC B349      IN	R20,0x19
    03DDD 714F      ANDI	R20,0x1F
    03DDE C020      RJMP	0x3DFF
(0015)         while((KEY_PIN) != KEY_MASK)
(0016) 		{
(0017) 		 temp++ ;
    03DDF E081      LDI	R24,1
    03DE0 E090      LDI	R25,0
    03DE1 E0A0      LDI	R26,0
    03DE2 E0B0      LDI	R27,0
    03DE3 8028      LD	R2,Y
    03DE4 8039      LDD	R3,Y+1
    03DE5 804A      LDD	R4,Y+2
    03DE6 805B      LDD	R5,Y+3
    03DE7 0E28      ADD	R2,R24
    03DE8 1E39      ADC	R3,R25
    03DE9 1E4A      ADC	R4,R26
    03DEA 1E5B      ADC	R5,R27
    03DEB 8228      ST	Y,R2
    03DEC 8239      STD	Y+1,R3
    03DED 824A      STD	Y+2,R4
    03DEE 825B      STD	Y+3,R5
(0018) 		 if(temp>LONGKEY) 
    03DEF E880      LDI	R24,0x80
    03DF0 E398      LDI	R25,0x38
    03DF1 E0A1      LDI	R26,1
    03DF2 E0B0      LDI	R27,0
    03DF3 8028      LD	R2,Y
    03DF4 8039      LDD	R3,Y+1
    03DF5 804A      LDD	R4,Y+2
    03DF6 805B      LDD	R5,Y+3
    03DF7 1582      CP	R24,R2
    03DF8 0593      CPC	R25,R3
    03DF9 05A4      CPC	R26,R4
    03DFA 05B5      CPC	R27,R5
    03DFB F418      BCC	0x3DFF
(0019) 		 {  return key+0x80;  };
    03DFC 2F04      MOV	R16,R20
    03DFD 5800      SUBI	R16,0x80
    03DFE C009      RJMP	0x3E08
    03DFF B389      IN	R24,0x19
    03E00 718F      ANDI	R24,0x1F
    03E01 318F      CPI	R24,0x1F
    03E02 F6E1      BNE	0x3DDF
(0020) 		}
(0021) 		; //当前有按键处于按下状态，再按其他按键时程序维持当前状态 
(0022)       	
(0023) 		return key;
    03E03 2F04      MOV	R16,R20
    03E04 C003      RJMP	0x3E08
(0024) 	  
(0025) 	  }
(0026)     }
(0027) 	else return NO_KEY;
    03E05 2700      CLR	R16
    03E06 C001      RJMP	0x3E08
(0028) 	
(0029) 	return NO_KEY;
FILE: <library>
    03E07 2700      CLR	R16
    03E08 9624      ADIW	R28,4
    03E09 9149      LD	R20,Y+
    03E0A 9508      RET
_memset:
    03E0B 8188      LD	R24,Y
    03E0C 8199      LDD	R25,Y+1
    03E0D 3080      CPI	R24,0
    03E0E 0789      CPC	R24,R25
    03E0F F029      BEQ	0x3E15
    03E10 2FE0      MOV	R30,R16
    03E11 2FF1      MOV	R31,R17
    03E12 9321      ST	Z+,R18
    03E13 9701      SBIW	R24,1
    03E14 F7E9      BNE	0x3E12
    03E15 9508      RET
_strcat:
    03E16 2FA0      MOV	R26,R16
    03E17 2FB1      MOV	R27,R17
    03E18 2FE2      MOV	R30,R18
    03E19 2FF3      MOV	R31,R19
    03E1A 912D      LD	R18,X+
    03E1B 2322      TST	R18
    03E1C F7E9      BNE	0x3E1A
    03E1D 9711      SBIW	R26,1
    03E1E 9121      LD	R18,Z+
    03E1F 932D      ST	X+,R18
    03E20 2322      TST	R18
    03E21 F7E1      BNE	0x3E1E
    03E22 9508      RET
_strlen:
    03E23 2FE0      MOV	R30,R16
    03E24 2FF1      MOV	R31,R17
    03E25 27AA      CLR	R26
    03E26 27BB      CLR	R27
    03E27 9001      LD	R0,Z+
    03E28 2000      TST	R0
    03E29 F011      BEQ	0x3E2C
    03E2A 9611      ADIW	R26,1
    03E2B CFFB      RJMP	0x3E27
    03E2C 2F0A      MOV	R16,R26
    03E2D 2F1B      MOV	R17,R27
    03E2E 9508      RET
push_arg4:
    03E2F 933A      ST	-Y,R19
    03E30 932A      ST	-Y,R18
push_arg2:
    03E31 931A      ST	-Y,R17
    03E32 930A      ST	-Y,R16
    03E33 9508      RET
asr32:
    03E34 920F      PUSH	R0
    03E35 9009      LD	R0,Y+
    03E36 2000      TST	R0
    03E37 F031      BEQ	0x3E3E
    03E38 9535      ASR	R19
    03E39 9527      ROR	R18
    03E3A 9517      ROR	R17
    03E3B 9507      ROR	R16
    03E3C 940A      DEC	R0
    03E3D CFF8      RJMP	0x3E36
    03E3E 900F      POP	R0
    03E3F 9508      RET
mod16s:
    03E40 9468      BSET	6
    03E41 92DA      ST	-Y,R13
    03E42 2ED1      MOV	R13,R17
    03E43 C004      RJMP	0x3E48
div16s:
    03E44 94E8      BCLR	6
    03E45 92DA      ST	-Y,R13
    03E46 2ED1      MOV	R13,R17
    03E47 26D3      EOR	R13,R19
    03E48 FF17      SBRS	R17,7
    03E49 C004      RJMP	0x3E4E
    03E4A 9510      COM	R17
    03E4B 9500      COM	R16
    03E4C 5F0F      SUBI	R16,0xFF
    03E4D 4F1F      SBCI	R17,0xFF
    03E4E FF37      SBRS	R19,7
    03E4F C004      RJMP	0x3E54
    03E50 9530      COM	R19
    03E51 9520      COM	R18
    03E52 5F2F      SUBI	R18,0xFF
    03E53 4F3F      SBCI	R19,0xFF
    03E54 940E 3E61 CALL	xdiv16u
    03E56 FED7      SBRS	R13,7
    03E57 C004      RJMP	0x3E5C
    03E58 9510      COM	R17
    03E59 9500      COM	R16
    03E5A 5F0F      SUBI	R16,0xFF
    03E5B 4F1F      SBCI	R17,0xFF
    03E5C 90D9      LD	R13,Y+
    03E5D 9508      RET
mod16u:
    03E5E 9468      BSET	6
    03E5F C001      RJMP	xdiv16u
div16u:
    03E60 94E8      BCLR	6
xdiv16u:
    03E61 92EA      ST	-Y,R14
    03E62 92FA      ST	-Y,R15
    03E63 938A      ST	-Y,R24
    03E64 24EE      CLR	R14
    03E65 24FF      CLR	R15
    03E66 E180      LDI	R24,0x10
    03E67 0F00      LSL	R16
    03E68 1F11      ROL	R17
    03E69 1CEE      ROL	R14
    03E6A 1CFF      ROL	R15
    03E6B 16E2      CP	R14,R18
    03E6C 06F3      CPC	R15,R19
    03E6D F018      BCS	0x3E71
    03E6E 1AE2      SUB	R14,R18
    03E6F 0AF3      SBC	R15,R19
    03E70 9503      INC	R16
    03E71 958A      DEC	R24
    03E72 F7A1      BNE	0x3E67
    03E73 F416      BRTC	0x3E76
    03E74 2D0E      MOV	R16,R14
    03E75 2D1F      MOV	R17,R15
    03E76 9189      LD	R24,Y+
    03E77 90F9      LD	R15,Y+
    03E78 90E9      LD	R14,Y+
    03E79 9508      RET
div32u:
    03E7A 94E8      BCLR	6
    03E7B C001      RJMP	0x3E7D
mod32u:
    03E7C 9468      BSET	6
    03E7D D030      RCALL	long_div_prolog
    03E7E 24CC      CLR	R12
    03E7F C009      RJMP	0x3E89
div32s:
    03E80 94E8      BCLR	6
    03E81 C001      RJMP	0x3E83
mod32s:
    03E82 9468      BSET	6
    03E83 D02A      RCALL	long_div_prolog
    03E84 FD37      SBRC	R19,7
    03E85 940E 3FC1 CALL	neg32
    03E87 FDB7      SBRC	R27,7
    03E88 D052      RCALL	neg_R24_R27
    03E89 2477      CLR	R7
    03E8A 2488      CLR	R8
    03E8B 2499      CLR	R9
    03E8C 24AA      CLR	R10
    03E8D 24BB      CLR	R11
    03E8E D042      RCALL	tst_R16_R19
    03E8F F0C1      BEQ	0x3EA8
    03E90 D045      RCALL	tst_R24_R27
    03E91 F0B1      BEQ	0x3EA8
    03E92 E2E8      LDI	R30,0x28
    03E93 0F00      LSL	R16
    03E94 1F11      ROL	R17
    03E95 1F22      ROL	R18
    03E96 1F33      ROL	R19
    03E97 1C77      ROL	R7
    03E98 1C88      ROL	R8
    03E99 1C99      ROL	R9
    03E9A 1CAA      ROL	R10
    03E9B 1CBB      ROL	R11
    03E9C 1688      CP	R8,R24
    03E9D 0699      CPC	R9,R25
    03E9E 06AA      CPC	R10,R26
    03E9F 06BB      CPC	R11,R27
    03EA0 F028      BCS	0x3EA6
    03EA1 1A88      SUB	R8,R24
    03EA2 0A99      SBC	R9,R25
    03EA3 0AAA      SBC	R10,R26
    03EA4 0ABB      SBC	R11,R27
    03EA5 9503      INC	R16
    03EA6 95EA      DEC	R30
    03EA7 F759      BNE	0x3E93
    03EA8 F426      BRTC	0x3EAD
    03EA9 2D08      MOV	R16,R8
    03EAA 2D19      MOV	R17,R9
    03EAB 2D2A      MOV	R18,R10
    03EAC 2D3B      MOV	R19,R11
    03EAD C013      RJMP	long_div_epilog
long_div_prolog:
    03EAE 927A      ST	-Y,R7
    03EAF 928A      ST	-Y,R8
    03EB0 929A      ST	-Y,R9
    03EB1 92AA      ST	-Y,R10
    03EB2 92BA      ST	-Y,R11
    03EB3 92CA      ST	-Y,R12
    03EB4 93EA      ST	-Y,R30
    03EB5 938A      ST	-Y,R24
    03EB6 939A      ST	-Y,R25
    03EB7 93AA      ST	-Y,R26
    03EB8 93BA      ST	-Y,R27
    03EB9 858B      LDD	R24,Y+11
    03EBA 859C      LDD	R25,Y+12
    03EBB 85AD      LDD	R26,Y+13
    03EBC 85BE      LDD	R27,Y+14
    03EBD 2EC3      MOV	R12,R19
    03EBE F00E      BRTS	0x3EC0
    03EBF 26CB      EOR	R12,R27
    03EC0 9508      RET
long_div_epilog:
    03EC1 FCC7      SBRC	R12,7
    03EC2 940E 3FC1 CALL	neg32
    03EC4 91B9      LD	R27,Y+
    03EC5 91A9      LD	R26,Y+
    03EC6 9199      LD	R25,Y+
    03EC7 9189      LD	R24,Y+
    03EC8 91E9      LD	R30,Y+
    03EC9 90C9      LD	R12,Y+
    03ECA 90B9      LD	R11,Y+
    03ECB 90A9      LD	R10,Y+
    03ECC 9099      LD	R9,Y+
    03ECD 9089      LD	R8,Y+
    03ECE 9079      LD	R7,Y+
    03ECF 9624      ADIW	R28,4
    03ED0 9508      RET
tst_R16_R19:
    03ED1 2FE0      MOV	R30,R16
    03ED2 2BE1      OR	R30,R17
    03ED3 2BE2      OR	R30,R18
    03ED4 2BE3      OR	R30,R19
    03ED5 9508      RET
tst_R24_R27:
    03ED6 2FE8      MOV	R30,R24
    03ED7 2BE9      OR	R30,R25
    03ED8 2BEA      OR	R30,R26
    03ED9 2BEB      OR	R30,R27
    03EDA 9508      RET
neg_R24_R27:
    03EDB 9580      COM	R24
    03EDC 9590      COM	R25
    03EDD 95A0      COM	R26
    03EDE 95B0      COM	R27
    03EDF 5F8F      SUBI	R24,0xFF
    03EE0 4F9F      SBCI	R25,0xFF
    03EE1 4FAF      SBCI	R26,0xFF
    03EE2 4FBF      SBCI	R27,0xFF
    03EE3 9508      RET
mod8u:
    03EE4 9468      BSET	6
    03EE5 C001      RJMP	xdiv8u
div8u:
    03EE6 94E8      BCLR	6
xdiv8u:
    03EE7 932A      ST	-Y,R18
    03EE8 92FA      ST	-Y,R15
    03EE9 92EA      ST	-Y,R14
    03EEA 24FF      CLR	R15
    03EEB 24EE      CLR	R14
    03EEC E120      LDI	R18,0x10
    03EED 0F00      LSL	R16
    03EEE 1CFF      ROL	R15
    03EEF 1CEE      ROL	R14
    03EF0 16E1      CP	R14,R17
    03EF1 F010      BCS	0x3EF4
    03EF2 1AE1      SUB	R14,R17
    03EF3 9503      INC	R16
    03EF4 952A      DEC	R18
    03EF5 F7B9      BNE	0x3EED
    03EF6 F40E      BRTC	0x3EF8
    03EF7 2D0E      MOV	R16,R14
    03EF8 90E9      LD	R14,Y+
    03EF9 90F9      LD	R15,Y+
    03EFA 9129      LD	R18,Y+
    03EFB 9508      RET
elpm32:
    03EFC 93EA      ST	-Y,R30
    03EFD 93FA      ST	-Y,R31
    03EFE 920A      ST	-Y,R0
    03EFF 2FE0      MOV	R30,R16
    03F00 2FF1      MOV	R31,R17
    03F01 95D8      ELPM
    03F02 2D00      MOV	R16,R0
    03F03 9631      ADIW	R30,1
    03F04 95D8      ELPM
    03F05 2D10      MOV	R17,R0
    03F06 9631      ADIW	R30,1
    03F07 95D8      ELPM
    03F08 2D20      MOV	R18,R0
    03F09 9631      ADIW	R30,1
    03F0A 95D8      ELPM
    03F0B 2D30      MOV	R19,R0
    03F0C 9009      LD	R0,Y+
    03F0D 91F9      LD	R31,Y+
    03F0E 91E9      LD	R30,Y+
    03F0F 9508      RET
empy16s:
    03F10 920A      ST	-Y,R0
    03F11 921A      ST	-Y,R1
    03F12 938A      ST	-Y,R24
    03F13 939A      ST	-Y,R25
    03F14 9F02      MUL	R16,R18
    03F15 01C0      MOVW	R24,R0
    03F16 9F12      MUL	R17,R18
    03F17 0D90      ADD	R25,R0
    03F18 9F03      MUL	R16,R19
    03F19 0D90      ADD	R25,R0
    03F1A 018C      MOVW	R16,R24
    03F1B 9199      LD	R25,Y+
    03F1C 9189      LD	R24,Y+
    03F1D 9019      LD	R1,Y+
    03F1E 9009      LD	R0,Y+
    03F1F 9508      RET
empy32u|empy32s:
    03F20 940E 3FCA CALL	long_prolog
    03F22 927A      ST	-Y,R7
    03F23 940E 3FE3 CALL	tstzero1
    03F25 F159      BEQ	0x3F51
    03F26 2477      CLR	R7
    03F27 940E 3FE9 CALL	tstzero2
    03F29 F419      BNE	0x3F2D
    03F2A 018C      MOVW	R16,R24
    03F2B 019D      MOVW	R18,R26
    03F2C C024      RJMP	0x3F51
    03F2D 920A      ST	-Y,R0
    03F2E 921A      ST	-Y,R1
    03F2F 9F08      MUL	R16,R24
    03F30 2CB0      MOV	R11,R0
    03F31 2CA1      MOV	R10,R1
    03F32 9F28      MUL	R18,R24
    03F33 2C90      MOV	R9,R0
    03F34 2C81      MOV	R8,R1
    03F35 9F18      MUL	R17,R24
    03F36 0CA0      ADD	R10,R0
    03F37 1C91      ADC	R9,R1
    03F38 1C87      ADC	R8,R7
    03F39 9F09      MUL	R16,R25
    03F3A 0CA0      ADD	R10,R0
    03F3B 1C91      ADC	R9,R1
    03F3C 1C87      ADC	R8,R7
    03F3D 9F19      MUL	R17,R25
    03F3E 0C90      ADD	R9,R0
    03F3F 1C81      ADC	R8,R1
    03F40 9F0A      MUL	R16,R26
    03F41 0C90      ADD	R9,R0
    03F42 1C81      ADC	R8,R1
    03F43 9F38      MUL	R19,R24
    03F44 0C80      ADD	R8,R0
    03F45 9F29      MUL	R18,R25
    03F46 0C80      ADD	R8,R0
    03F47 9F1A      MUL	R17,R26
    03F48 0C80      ADD	R8,R0
    03F49 9F0B      MUL	R16,R27
    03F4A 0C80      ADD	R8,R0
    03F4B 9019      LD	R1,Y+
    03F4C 9009      LD	R0,Y+
    03F4D 2D0B      MOV	R16,R11
    03F4E 2D1A      MOV	R17,R10
    03F4F 2D29      MOV	R18,R9
    03F50 2D38      MOV	R19,R8
    03F51 9079      LD	R7,Y+
    03F52 940C 3FD8 JMP	long_epilog
pop_xgset003C:
    03F54 90A9      LD	R10,Y+
    03F55 90B9      LD	R11,Y+
    03F56 90C9      LD	R12,Y+
    03F57 90D9      LD	R13,Y+
    03F58 9508      RET
pop_xgset00FC:
    03F59 90A9      LD	R10,Y+
    03F5A 90B9      LD	R11,Y+
    03F5B 90C9      LD	R12,Y+
    03F5C 90D9      LD	R13,Y+
    03F5D 90E9      LD	R14,Y+
    03F5E 90F9      LD	R15,Y+
    03F5F 9508      RET
pop_xgset30FC:
    03F60 90A9      LD	R10,Y+
    03F61 90B9      LD	R11,Y+
    03F62 90C9      LD	R12,Y+
    03F63 90D9      LD	R13,Y+
    03F64 90E9      LD	R14,Y+
    03F65 90F9      LD	R15,Y+
    03F66 9149      LD	R20,Y+
    03F67 9159      LD	R21,Y+
    03F68 9508      RET
pop_xgsetF0FC:
    03F69 90A9      LD	R10,Y+
    03F6A 90B9      LD	R11,Y+
    03F6B 90C9      LD	R12,Y+
    03F6C 90D9      LD	R13,Y+
    03F6D 90E9      LD	R14,Y+
    03F6E 90F9      LD	R15,Y+
    03F6F 9149      LD	R20,Y+
    03F70 9159      LD	R21,Y+
    03F71 9169      LD	R22,Y+
    03F72 9179      LD	R23,Y+
    03F73 9508      RET
push_xgsetF0FC:
    03F74 937A      ST	-Y,R23
    03F75 936A      ST	-Y,R22
push_xgset30FC:
    03F76 935A      ST	-Y,R21
    03F77 934A      ST	-Y,R20
push_xgset00FC:
    03F78 92FA      ST	-Y,R15
    03F79 92EA      ST	-Y,R14
push_xgset003C:
    03F7A 92DA      ST	-Y,R13
    03F7B 92CA      ST	-Y,R12
    03F7C 92BA      ST	-Y,R11
    03F7D 92AA      ST	-Y,R10
    03F7E 9508      RET
push_xgset300C:
    03F7F 935A      ST	-Y,R21
    03F80 934A      ST	-Y,R20
    03F81 92BA      ST	-Y,R11
    03F82 92AA      ST	-Y,R10
    03F83 9508      RET
pop_xgset300C:
    03F84 90A9      LD	R10,Y+
    03F85 90B9      LD	R11,Y+
    03F86 9149      LD	R20,Y+
    03F87 9159      LD	R21,Y+
    03F88 9508      RET
push_xgsetF000:
    03F89 937A      ST	-Y,R23
    03F8A 936A      ST	-Y,R22
    03F8B 935A      ST	-Y,R21
    03F8C 934A      ST	-Y,R20
    03F8D 9508      RET
pop_xgsetF000:
    03F8E 9149      LD	R20,Y+
    03F8F 9159      LD	R21,Y+
    03F90 9169      LD	R22,Y+
    03F91 9179      LD	R23,Y+
    03F92 9508      RET
push_xgsetF00C:
    03F93 937A      ST	-Y,R23
    03F94 936A      ST	-Y,R22
    03F95 935A      ST	-Y,R21
    03F96 934A      ST	-Y,R20
    03F97 92BA      ST	-Y,R11
    03F98 92AA      ST	-Y,R10
    03F99 9508      RET
pop_xgsetF00C:
    03F9A 90A9      LD	R10,Y+
    03F9B 90B9      LD	R11,Y+
    03F9C 9149      LD	R20,Y+
    03F9D 9159      LD	R21,Y+
    03F9E 9169      LD	R22,Y+
    03F9F 9179      LD	R23,Y+
    03FA0 9508      RET
push_xgset303C:
    03FA1 935A      ST	-Y,R21
    03FA2 934A      ST	-Y,R20
    03FA3 92DA      ST	-Y,R13
    03FA4 92CA      ST	-Y,R12
    03FA5 92BA      ST	-Y,R11
    03FA6 92AA      ST	-Y,R10
    03FA7 9508      RET
pop_xgset303C:
    03FA8 90A9      LD	R10,Y+
    03FA9 90B9      LD	R11,Y+
    03FAA 90C9      LD	R12,Y+
    03FAB 90D9      LD	R13,Y+
    03FAC 9149      LD	R20,Y+
    03FAD 9159      LD	R21,Y+
    03FAE 9508      RET
push_xgsetF03C:
    03FAF 937A      ST	-Y,R23
    03FB0 936A      ST	-Y,R22
    03FB1 935A      ST	-Y,R21
    03FB2 934A      ST	-Y,R20
    03FB3 92DA      ST	-Y,R13
    03FB4 92CA      ST	-Y,R12
    03FB5 92BA      ST	-Y,R11
    03FB6 92AA      ST	-Y,R10
    03FB7 9508      RET
pop_xgsetF03C:
    03FB8 90A9      LD	R10,Y+
    03FB9 90B9      LD	R11,Y+
    03FBA 90C9      LD	R12,Y+
    03FBB 90D9      LD	R13,Y+
    03FBC 9149      LD	R20,Y+
    03FBD 9159      LD	R21,Y+
    03FBE 9169      LD	R22,Y+
    03FBF 9179      LD	R23,Y+
    03FC0 9508      RET
neg32:
    03FC1 9500      COM	R16
    03FC2 9510      COM	R17
    03FC3 9520      COM	R18
    03FC4 9530      COM	R19
    03FC5 5F0F      SUBI	R16,0xFF
    03FC6 4F1F      SBCI	R17,0xFF
    03FC7 4F2F      SBCI	R18,0xFF
    03FC8 4F3F      SBCI	R19,0xFF
    03FC9 9508      RET
long_prolog:
    03FCA 928A      ST	-Y,R8
    03FCB 929A      ST	-Y,R9
    03FCC 92AA      ST	-Y,R10
    03FCD 92BA      ST	-Y,R11
    03FCE 93EA      ST	-Y,R30
    03FCF 938A      ST	-Y,R24
    03FD0 939A      ST	-Y,R25
    03FD1 93AA      ST	-Y,R26
    03FD2 93BA      ST	-Y,R27
    03FD3 8589      LDD	R24,Y+9
    03FD4 859A      LDD	R25,Y+10
    03FD5 85AB      LDD	R26,Y+11
    03FD6 85BC      LDD	R27,Y+12
    03FD7 9508      RET
long_epilog:
    03FD8 91B9      LD	R27,Y+
    03FD9 91A9      LD	R26,Y+
    03FDA 9199      LD	R25,Y+
    03FDB 9189      LD	R24,Y+
    03FDC 91E9      LD	R30,Y+
    03FDD 90B9      LD	R11,Y+
    03FDE 90A9      LD	R10,Y+
    03FDF 9099      LD	R9,Y+
    03FE0 9089      LD	R8,Y+
    03FE1 9624      ADIW	R28,4
    03FE2 9508      RET
tstzero1:
    03FE3 27EE      CLR	R30
    03FE4 2BE0      OR	R30,R16
    03FE5 2BE1      OR	R30,R17
    03FE6 2BE2      OR	R30,R18
    03FE7 2BE3      OR	R30,R19
    03FE8 9508      RET
tstzero2:
    03FE9 27EE      CLR	R30
    03FEA 2BE8      OR	R30,R24
    03FEB 2BE9      OR	R30,R25
    03FEC 2BEA      OR	R30,R26
    03FED 2BEB      OR	R30,R27
    03FEE 9508      RET
lsl16:
    03FEF 2322      TST	R18
    03FF0 F021      BEQ	0x3FF5
    03FF1 0F00      LSL	R16
    03FF2 1F11      ROL	R17
    03FF3 952A      DEC	R18
    03FF4 CFFA      RJMP	lsl16
    03FF5 9508      RET
lsl32:
    03FF6 920F      PUSH	R0
    03FF7 9009      LD	R0,Y+
    03FF8 2000      TST	R0
    03FF9 F031      BEQ	0x4000
    03FFA 0F00      LSL	R16
    03FFB 1F11      ROL	R17
    03FFC 1F22      ROL	R18
    03FFD 1F33      ROL	R19
    03FFE 940A      DEC	R0
    03FFF CFF8      RJMP	0x3FF8
    04000 900F      POP	R0
    04001 9508      RET
lsl8:
    04002 2311      TST	R17
    04003 F019      BEQ	0x4007
    04004 0F00      LSL	R16
    04005 951A      DEC	R17
    04006 CFFB      RJMP	lsl8
    04007 9508      RET
lsr16:
    04008 2322      TST	R18
    04009 F021      BEQ	0x400E
    0400A 9516      LSR	R17
    0400B 9507      ROR	R16
    0400C 952A      DEC	R18
    0400D CFFA      RJMP	lsr16
    0400E 9508      RET
lsr32:
    0400F 920F      PUSH	R0
    04010 9009      LD	R0,Y+
    04011 2000      TST	R0
    04012 F031      BEQ	0x4019
    04013 9536      LSR	R19
    04014 9527      ROR	R18
    04015 9517      ROR	R17
    04016 9507      ROR	R16
    04017 940A      DEC	R0
    04018 CFF8      RJMP	0x4011
    04019 900F      POP	R0
    0401A 9508      RET
asgnblk:
    0401B 93AA      ST	-Y,R26
    0401C 93BA      ST	-Y,R27
    0401D 93EA      ST	-Y,R30
    0401E 93FA      ST	-Y,R31
    0401F 920A      ST	-Y,R0
    04020 81AF      LDD	R26,Y+7
    04021 85B8      LDD	R27,Y+8
    04022 81ED      LDD	R30,Y+5
    04023 81FE      LDD	R31,Y+6
    04024 3000      CPI	R16,0
    04025 0701      CPC	R16,R17
    04026 F029      BEQ	0x402C
    04027 9001      LD	R0,Z+
    04028 920D      ST	X+,R0
    04029 5001      SUBI	R16,1
    0402A 4010      SBCI	R17,0
    0402B CFF8      RJMP	0x4024
    0402C 9009      LD	R0,Y+
    0402D 91F9      LD	R31,Y+
    0402E 91E9      LD	R30,Y+
    0402F 91B9      LD	R27,Y+
    04030 91A9      LD	R26,Y+
    04031 9624      ADIW	R28,4
    04032 9508      RET
fpsub:
    04033 9468      BSET	6
    04034 C001      RJMP	fpadd_alt
fpadd:
    04035 94E8      BCLR	6
fpadd_alt:
    04036 940E 41FA CALL	saveFPRegs
    04038 940E 418C CALL	unpacks
    0403A F409      BNE	0x403C
    0403B C048      RJMP	0x4084
    0403C 2CE6      MOV	R14,R6
    0403D 2CD5      MOV	R13,R5
    0403E 2CC4      MOV	R12,R4
    0403F 2EB3      MOV	R11,R19
    04040 2EA2      MOV	R10,R18
    04041 2E91      MOV	R9,R17
    04042 2E80      MOV	R8,R16
    04043 8100      LD	R16,Z
    04044 8111      LDD	R17,Z+1
    04045 8122      LDD	R18,Z+2
    04046 8133      LDD	R19,Z+3
    04047 940E 418C CALL	unpacks
    04049 F409      BNE	0x404B
    0404A C044      RJMP	0x408F
    0404B 2D84      MOV	R24,R4
    0404C 2D95      MOV	R25,R5
    0404D 198C      SUB	R24,R12
    0404E 099D      SBC	R25,R13
    0404F F0B9      BEQ	0x4067
    04050 F472      BPL	0x405F
    04051 9590      COM	R25
    04052 9580      COM	R24
    04053 9601      ADIW	R24,1
    04054 2C4C      MOV	R4,R12
    04055 2C5D      MOV	R5,R13
    04056 3188      CPI	R24,0x18
    04057 F5B8      BCC	0x408F
    04058 9535      ASR	R19
    04059 9527      ROR	R18
    0405A 9517      ROR	R17
    0405B 9507      ROR	R16
    0405C 9701      SBIW	R24,1
    0405D F7D1      BNE	0x4058
    0405E C008      RJMP	0x4067
    0405F 3188      CPI	R24,0x18
    04060 F518      BCC	0x4084
    04061 94B5      ASR	R11
    04062 94A7      ROR	R10
    04063 9497      ROR	R9
    04064 9487      ROR	R8
    04065 9701      SBIW	R24,1
    04066 F7D1      BNE	0x4061
    04067 2466      CLR	R6
    04068 F02E      BRTS	0x406E
    04069 0D08      ADD	R16,R8
    0406A 1D19      ADC	R17,R9
    0406B 1D2A      ADC	R18,R10
    0406C 1D3B      ADC	R19,R11
    0406D C009      RJMP	0x4077
    0406E 1A80      SUB	R8,R16
    0406F 0A91      SBC	R9,R17
    04070 0AA2      SBC	R10,R18
    04071 0AB3      SBC	R11,R19
    04072 2D08      MOV	R16,R8
    04073 2D19      MOV	R17,R9
    04074 2D2A      MOV	R18,R10
    04075 2D3B      MOV	R19,R11
    04076 2333      TST	R19
    04077 F422      BPL	0x407C
    04078 940E 3FC1 CALL	neg32
    0407A E880      LDI	R24,0x80
    0407B 2E68      MOV	R6,R24
    0407C 940E 41B5 CALL	normalize_and_pack
    0407E C002      RJMP	0x4081
    0407F 940E 41EA CALL	pack
    04081 940E 4209 CALL	restoreFPRegs
    04083 9508      RET
    04084 8100      LD	R16,Z
    04085 8111      LDD	R17,Z+1
    04086 8122      LDD	R18,Z+2
    04087 8133      LDD	R19,Z+3
    04088 F7C6      BRTC	0x4081
    04089 940E 4194 CALL	tstR16_R19
    0408B F3A9      BEQ	0x4081
    0408C E880      LDI	R24,0x80
    0408D 2738      EOR	R19,R24
    0408E CFF2      RJMP	0x4081
    0408F 2D08      MOV	R16,R8
    04090 2D19      MOV	R17,R9
    04091 2D2A      MOV	R18,R10
    04092 2D3B      MOV	R19,R11
    04093 2C4C      MOV	R4,R12
    04094 2C5D      MOV	R5,R13
    04095 2C6E      MOV	R6,R14
    04096 2333      TST	R19
    04097 F73A      BPL	0x407F
    04098 940E 3FC1 CALL	neg32
    0409A E880      LDI	R24,0x80
    0409B 2E68      MOV	R6,R24
    0409C CFE2      RJMP	0x407F
fpadd2:
    0409D 93FA      ST	-Y,R31
    0409E 93EA      ST	-Y,R30
    0409F 2FEC      MOV	R30,R28
    040A0 2FFD      MOV	R31,R29
    040A1 9632      ADIW	R30,2
    040A2 940E 4035 CALL	fpadd
    040A4 91E9      LD	R30,Y+
    040A5 91F9      LD	R31,Y+
    040A6 9624      ADIW	R28,4
    040A7 9508      RET
fpsub2:
    040A8 93FA      ST	-Y,R31
    040A9 93EA      ST	-Y,R30
    040AA 2FEC      MOV	R30,R28
    040AB 2FFD      MOV	R31,R29
    040AC 9632      ADIW	R30,2
    040AD 940E 4033 CALL	fpsub
    040AF 91E9      LD	R30,Y+
    040B0 91F9      LD	R31,Y+
    040B1 9624      ADIW	R28,4
    040B2 9508      RET
fpsub1x:
    040B3 93FA      ST	-Y,R31
    040B4 93EA      ST	-Y,R30
    040B5 81EA      LDD	R30,Y+2
    040B6 81FB      LDD	R31,Y+3
    040B7 940E 4033 CALL	fpsub
    040B9 91E9      LD	R30,Y+
    040BA 91F9      LD	R31,Y+
    040BB 8339      STD	Y+1,R19
    040BC 8328      ST	Y,R18
    040BD 931A      ST	-Y,R17
    040BE 930A      ST	-Y,R16
    040BF 9508      RET
fpsub2x:
    040C0 93FA      ST	-Y,R31
    040C1 93EA      ST	-Y,R30
    040C2 2FEC      MOV	R30,R28
    040C3 2FFD      MOV	R31,R29
    040C4 9632      ADIW	R30,2
    040C5 940E 4033 CALL	fpsub
    040C7 91E9      LD	R30,Y+
    040C8 91F9      LD	R31,Y+
    040C9 833B      STD	Y+3,R19
    040CA 832A      STD	Y+2,R18
    040CB 8319      STD	Y+1,R17
    040CC 8308      ST	Y,R16
    040CD 9508      RET
uint2fp:
    040CE 9468      BSET	6
    040CF C001      RJMP	0x40D1
int2fp:
    040D0 94E8      BCLR	6
    040D1 2722      CLR	R18
    040D2 2733      CLR	R19
    040D3 F046      BRTS	0x40DC
    040D4 FD17      SBRC	R17,7
    040D5 9520      COM	R18
    040D6 FD17      SBRC	R17,7
    040D7 9530      COM	R19
    040D8 C003      RJMP	0x40DC
ulong2fp:
    040D9 9468      BSET	6
    040DA C001      RJMP	0x40DC
long2fp:
    040DB 94E8      BCLR	6
    040DC 924A      ST	-Y,R4
    040DD 925A      ST	-Y,R5
    040DE 926A      ST	-Y,R6
    040DF 938A      ST	-Y,R24
    040E0 E187      LDI	R24,0x17
    040E1 2E48      MOV	R4,R24
    040E2 2455      CLR	R5
    040E3 2466      CLR	R6
    040E4 F036      BRTS	0x40EB
    040E5 2333      TST	R19
    040E6 F422      BPL	0x40EB
    040E7 940E 3FC1 CALL	neg32
    040E9 E880      LDI	R24,0x80
    040EA 2E68      MOV	R6,R24
    040EB 940E 41B5 CALL	normalize_and_pack
    040ED 9189      LD	R24,Y+
    040EE 9069      LD	R6,Y+
    040EF 9059      LD	R5,Y+
    040F0 9049      LD	R4,Y+
    040F1 9508      RET
fpdiv1:
    040F2 93FA      ST	-Y,R31
    040F3 93EA      ST	-Y,R30
    040F4 81EA      LDD	R30,Y+2
    040F5 81FB      LDD	R31,Y+3
    040F6 D027      RCALL	0x411E
    040F7 91E9      LD	R30,Y+
    040F8 91F9      LD	R31,Y+
    040F9 9622      ADIW	R28,2
    040FA 9508      RET
fpdiv2:
    040FB 93FA      ST	-Y,R31
    040FC 93EA      ST	-Y,R30
    040FD 2FEC      MOV	R30,R28
    040FE 2FFD      MOV	R31,R29
    040FF 9632      ADIW	R30,2
    04100 D01D      RCALL	0x411E
    04101 91E9      LD	R30,Y+
    04102 91F9      LD	R31,Y+
    04103 9624      ADIW	R28,4
    04104 9508      RET
fpdiv1x:
    04105 93FA      ST	-Y,R31
    04106 93EA      ST	-Y,R30
    04107 81EA      LDD	R30,Y+2
    04108 81FB      LDD	R31,Y+3
    04109 D014      RCALL	0x411E
    0410A 91E9      LD	R30,Y+
    0410B 91F9      LD	R31,Y+
    0410C 8339      STD	Y+1,R19
    0410D 8328      ST	Y,R18
    0410E 931A      ST	-Y,R17
    0410F 930A      ST	-Y,R16
    04110 9508      RET
fpdiv2x:
    04111 93FA      ST	-Y,R31
    04112 93EA      ST	-Y,R30
    04113 2FEC      MOV	R30,R28
    04114 2FFD      MOV	R31,R29
    04115 9632      ADIW	R30,2
    04116 D007      RCALL	0x411E
    04117 91E9      LD	R30,Y+
    04118 91F9      LD	R31,Y+
    04119 833B      STD	Y+3,R19
    0411A 832A      STD	Y+2,R18
    0411B 8319      STD	Y+1,R17
    0411C 8308      ST	Y,R16
    0411D 9508      RET
    0411E 920A      ST	-Y,R0
    0411F 921A      ST	-Y,R1
    04120 922A      ST	-Y,R2
    04121 923A      ST	-Y,R3
    04122 940E 41FA CALL	saveFPRegs
    04124 933A      ST	-Y,R19
    04125 932A      ST	-Y,R18
    04126 931A      ST	-Y,R17
    04127 930A      ST	-Y,R16
    04128 8100      LD	R16,Z
    04129 8111      LDD	R17,Z+1
    0412A 8122      LDD	R18,Z+2
    0412B 8133      LDD	R19,Z+3
    0412C 940E 419C CALL	unpacku
    0412E F409      BNE	0x4130
    0412F C057      RJMP	0x4187
    04130 2CE6      MOV	R14,R6
    04131 2CD5      MOV	R13,R5
    04132 2CC4      MOV	R12,R4
    04133 2EB3      MOV	R11,R19
    04134 2EA2      MOV	R10,R18
    04135 2E91      MOV	R9,R17
    04136 2E80      MOV	R8,R16
    04137 9109      LD	R16,Y+
    04138 9119      LD	R17,Y+
    04139 9129      LD	R18,Y+
    0413A 9139      LD	R19,Y+
    0413B 940E 419C CALL	unpacku
    0413D F1A1      BEQ	0x4172
    0413E 246E      EOR	R6,R14
    0413F 184C      SUB	R4,R12
    04140 085D      SBC	R5,R13
    04141 E880      LDI	R24,0x80
    04142 1648      CP	R4,R24
    04143 0653      CPC	R5,R19
    04144 F00C      BLT	0x4146
    04145 C033      RJMP	0x4179
    04146 E881      LDI	R24,0x81
    04147 1648      CP	R4,R24
    04148 EF8F      LDI	R24,0xFF
    04149 0658      CPC	R5,R24
    0414A F40C      BGE	0x414C
    0414B C036      RJMP	0x4182
    0414C E280      LDI	R24,0x20
    0414D 2433      CLR	R3
    0414E 2E23      MOV	R2,R19
    0414F 2E12      MOV	R1,R18
    04150 2E01      MOV	R0,R17
    04151 2F30      MOV	R19,R16
    04152 2722      CLR	R18
    04153 2711      CLR	R17
    04154 2700      CLR	R16
    04155 9426      LSR	R2
    04156 9417      ROR	R1
    04157 9407      ROR	R0
    04158 9537      ROR	R19
    04159 9527      ROR	R18
    0415A 0F00      LSL	R16
    0415B 1F11      ROL	R17
    0415C 1F22      ROL	R18
    0415D 1F33      ROL	R19
    0415E 1C00      ROL	R0
    0415F 1C11      ROL	R1
    04160 1C22      ROL	R2
    04161 1C33      ROL	R3
    04162 F028      BCS	0x4168
    04163 1808      SUB	R0,R8
    04164 0819      SBC	R1,R9
    04165 082A      SBC	R2,R10
    04166 083B      SBC	R3,R11
    04167 C004      RJMP	0x416C
    04168 0C08      ADD	R0,R8
    04169 1C19      ADC	R1,R9
    0416A 1C2A      ADC	R2,R10
    0416B 1C3B      ADC	R3,R11
    0416C F00A      BMI	0x416E
    0416D 6001      ORI	R16,1
    0416E 958A      DEC	R24
    0416F F751      BNE	0x415A
    04170 940E 41B5 CALL	normalize_and_pack
    04172 940E 4209 CALL	restoreFPRegs
    04174 9039      LD	R3,Y+
    04175 9029      LD	R2,Y+
    04176 9019      LD	R1,Y+
    04177 9009      LD	R0,Y+
    04178 9508      RET
    04179 EF0F      LDI	R16,0xFF
    0417A 2F10      MOV	R17,R16
    0417B E72F      LDI	R18,0x7F
    0417C E73F      LDI	R19,0x7F
    0417D 2066      TST	R6
    0417E F399      BEQ	0x4172
    0417F 940E 3FC1 CALL	neg32
    04181 CFF0      RJMP	0x4172
    04182 2700      CLR	R16
    04183 2F10      MOV	R17,R16
    04184 2F20      MOV	R18,R16
    04185 2F30      MOV	R19,R16
    04186 CFEB      RJMP	0x4172
    04187 9109      LD	R16,Y+
    04188 9119      LD	R17,Y+
    04189 9129      LD	R18,Y+
    0418A 9139      LD	R19,Y+
    0418B CFED      RJMP	0x4179
unpacks:
    0418C D00F      RCALL	unpacku
    0418D F029      BEQ	0x4193
    0418E 2066      TST	R6
    0418F F011      BEQ	0x4192
    04190 940E 3FC1 CALL	neg32
    04192 9498      BCLR	1
    04193 9508      RET
tstR16_R19:
    04194 2300      TST	R16
    04195 F429      BNE	0x419B
    04196 2311      TST	R17
    04197 F419      BNE	0x419B
    04198 2322      TST	R18
    04199 F409      BNE	0x419B
    0419A 2333      TST	R19
    0419B 9508      RET
unpacku:
    0419C DFF7      RCALL	tstR16_R19
    0419D F099      BEQ	0x41B1
    0419E 938A      ST	-Y,R24
    0419F 2E63      MOV	R6,R19
    041A0 E880      LDI	R24,0x80
    041A1 2268      AND	R6,R24
    041A2 0F22      LSL	R18
    041A3 1F33      ROL	R19
    041A4 2E43      MOV	R4,R19
    041A5 E78F      LDI	R24,0x7F
    041A6 1A48      SUB	R4,R24
    041A7 2455      CLR	R5
    041A8 2788      CLR	R24
    041A9 0A58      SBC	R5,R24
    041AA 9526      LSR	R18
    041AB E830      LDI	R19,0x80
    041AC 2B23      OR	R18,R19
    041AD 2733      CLR	R19
    041AE 9189      LD	R24,Y+
    041AF 9498      BCLR	1
    041B0 9508      RET
    041B1 2444      CLR	R4
    041B2 2455      CLR	R5
    041B3 2466      CLR	R6
    041B4 9508      RET
normalize_and_pack:
    041B5 DFDE      RCALL	tstR16_R19
    041B6 F409      BNE	0x41B8
    041B7 9508      RET
    041B8 93AA      ST	-Y,R26
    041B9 93BA      ST	-Y,R27
    041BA 01D2      MOVW	R26,R4
    041BB 939A      ST	-Y,R25
    041BC 938A      ST	-Y,R24
    041BD E78E      LDI	R24,0x7E
    041BE E090      LDI	R25,0
    041BF 2333      TST	R19
    041C0 F049      BEQ	0x41CA
    041C1 9536      LSR	R19
    041C2 9527      ROR	R18
    041C3 9517      ROR	R17
    041C4 9507      ROR	R16
    041C5 17A8      CP	R26,R24
    041C6 07B9      CPC	R27,R25
    041C7 F4CC      BGE	0x41E1
    041C8 9611      ADIW	R26,1
    041C9 CFF5      RJMP	0x41BF
    041CA 9580      COM	R24
    041CB 9590      COM	R25
    041CC 9601      ADIW	R24,1
    041CD 2322      TST	R18
    041CE F0BA      BMI	0x41E6
    041CF 0F00      LSL	R16
    041D0 1F11      ROL	R17
    041D1 1F22      ROL	R18
    041D2 17A8      CP	R26,R24
    041D3 07B9      CPC	R27,R25
    041D4 F014      BLT	0x41D7
    041D5 9711      SBIW	R26,1
    041D6 CFF6      RJMP	0x41CD
    041D7 2700      CLR	R16
    041D8 2711      CLR	R17
    041D9 2722      CLR	R18
    041DA 2733      CLR	R19
    041DB 9189      LD	R24,Y+
    041DC 9199      LD	R25,Y+
    041DD 012D      MOVW	R4,R26
    041DE 91B9      LD	R27,Y+
    041DF 91A9      LD	R26,Y+
    041E0 9508      RET
    041E1 2733      CLR	R19
    041E2 EF0F      LDI	R16,0xFF
    041E3 2F10      MOV	R17,R16
    041E4 E72F      LDI	R18,0x7F
    041E5 2F32      MOV	R19,R18
    041E6 9189      LD	R24,Y+
    041E7 9199      LD	R25,Y+
    041E8 012D      MOVW	R4,R26
    041E9 C002      RJMP	0x41EC
pack:
    041EA 93AA      ST	-Y,R26
    041EB 93BA      ST	-Y,R27
    041EC DFA7      RCALL	tstR16_R19
    041ED F049      BEQ	0x41F7
    041EE 01D2      MOVW	R26,R4
    041EF 58A1      SUBI	R26,0x81
    041F0 4FBF      SBCI	R27,0xFF
    041F1 012D      MOVW	R4,R26
    041F2 2D34      MOV	R19,R4
    041F3 0F22      LSL	R18
    041F4 9536      LSR	R19
    041F5 9527      ROR	R18
    041F6 2936      OR	R19,R6
    041F7 91B9      LD	R27,Y+
    041F8 91A9      LD	R26,Y+
    041F9 9508      RET
saveFPRegs:
    041FA 924A      ST	-Y,R4
    041FB 925A      ST	-Y,R5
    041FC 926A      ST	-Y,R6
    041FD 927A      ST	-Y,R7
    041FE 928A      ST	-Y,R8
    041FF 929A      ST	-Y,R9
    04200 92AA      ST	-Y,R10
    04201 92BA      ST	-Y,R11
    04202 92CA      ST	-Y,R12
    04203 92DA      ST	-Y,R13
    04204 92EA      ST	-Y,R14
    04205 92FA      ST	-Y,R15
    04206 938A      ST	-Y,R24
    04207 939A      ST	-Y,R25
    04208 9508      RET
restoreFPRegs:
    04209 9199      LD	R25,Y+
    0420A 9189      LD	R24,Y+
    0420B 90F9      LD	R15,Y+
    0420C 90E9      LD	R14,Y+
    0420D 90D9      LD	R13,Y+
    0420E 90C9      LD	R12,Y+
    0420F 90B9      LD	R11,Y+
    04210 90A9      LD	R10,Y+
    04211 9099      LD	R9,Y+
    04212 9089      LD	R8,Y+
    04213 9079      LD	R7,Y+
    04214 9069      LD	R6,Y+
    04215 9059      LD	R5,Y+
    04216 9049      LD	R4,Y+
    04217 9508      RET
fpmule:
    04218 940E 41FA CALL	saveFPRegs
    0421A 93AA      ST	-Y,R26
    0421B 93BA      ST	-Y,R27
    0421C 940E 419C CALL	unpacku
    0421E F1E1      BEQ	0x425B
    0421F 2CE6      MOV	R14,R6
    04220 2CD5      MOV	R13,R5
    04221 2CC4      MOV	R12,R4
    04222 2EB3      MOV	R11,R19
    04223 2EA2      MOV	R10,R18
    04224 2E91      MOV	R9,R17
    04225 2E80      MOV	R8,R16
    04226 8100      LD	R16,Z
    04227 8111      LDD	R17,Z+1
    04228 8122      LDD	R18,Z+2
    04229 8133      LDD	R19,Z+3
    0422A 940E 419C CALL	unpacku
    0422C F171      BEQ	0x425B
    0422D 246E      EOR	R6,R14
    0422E 0C4C      ADD	R4,R12
    0422F 1C5D      ADC	R5,R13
    04230 E880      LDI	R24,0x80
    04231 1648      CP	R4,R24
    04232 0653      CPC	R5,R19
    04233 F564      BGE	0x4260
    04234 E881      LDI	R24,0x81
    04235 1648      CP	R4,R24
    04236 EF8F      LDI	R24,0xFF
    04237 0658      CPC	R5,R24
    04238 F16C      BLT	0x4266
    04239 9EA2      MUL	R10,R18
    0423A 2DB1      MOV	R27,R1
    0423B 2DA0      MOV	R26,R0
    0423C 9E91      MUL	R9,R17
    0423D 2D91      MOV	R25,R1
    0423E 2D80      MOV	R24,R0
    0423F 9EA0      MUL	R10,R16
    04240 0D80      ADD	R24,R0
    04241 1D91      ADC	R25,R1
    04242 1FA3      ADC	R26,R19
    04243 1FB3      ADC	R27,R19
    04244 9E82      MUL	R8,R18
    04245 0D80      ADD	R24,R0
    04246 1D91      ADC	R25,R1
    04247 1FA3      ADC	R26,R19
    04248 1FB3      ADC	R27,R19
    04249 9E92      MUL	R9,R18
    0424A 0D90      ADD	R25,R0
    0424B 1DA1      ADC	R26,R1
    0424C 1FB3      ADC	R27,R19
    0424D 9EA1      MUL	R10,R17
    0424E 0D90      ADD	R25,R0
    0424F 1DA1      ADC	R26,R1
    04250 1FB3      ADC	R27,R19
    04251 2F2B      MOV	R18,R27
    04252 2F1A      MOV	R17,R26
    04253 2F09      MOV	R16,R25
    04254 0F88      LSL	R24
    04255 1F00      ROL	R16
    04256 1F11      ROL	R17
    04257 1F22      ROL	R18
    04258 1F33      ROL	R19
    04259 940E 41B5 CALL	normalize_and_pack
    0425B 91B9      LD	R27,Y+
    0425C 91A9      LD	R26,Y+
    0425D 940E 4209 CALL	restoreFPRegs
    0425F 9508      RET
    04260 EF0F      LDI	R16,0xFF
    04261 2F10      MOV	R17,R16
    04262 E72F      LDI	R18,0x7F
    04263 E78F      LDI	R24,0x7F
    04264 2E48      MOV	R4,R24
    04265 CFF5      RJMP	0x425B
    04266 2700      CLR	R16
    04267 2F10      MOV	R17,R16
    04268 2F20      MOV	R18,R16
    04269 2F30      MOV	R19,R16
    0426A CFF0      RJMP	0x425B
fpmule1:
    0426B 93FA      ST	-Y,R31
    0426C 93EA      ST	-Y,R30
    0426D 81EA      LDD	R30,Y+2
    0426E 81FB      LDD	R31,Y+3
    0426F 940E 4218 CALL	fpmule
    04271 91E9      LD	R30,Y+
    04272 91F9      LD	R31,Y+
    04273 9622      ADIW	R28,2
    04274 9508      RET
fpmule2:
    04275 93FA      ST	-Y,R31
    04276 93EA      ST	-Y,R30
    04277 2FEC      MOV	R30,R28
    04278 2FFD      MOV	R31,R29
    04279 9632      ADIW	R30,2
    0427A 940E 4218 CALL	fpmule
    0427C 91E9      LD	R30,Y+
    0427D 91F9      LD	R31,Y+
    0427E 9624      ADIW	R28,4
    0427F 9508      RET
fpmule1x:
    04280 93FA      ST	-Y,R31
    04281 93EA      ST	-Y,R30
    04282 81EA      LDD	R30,Y+2
    04283 81FB      LDD	R31,Y+3
    04284 940E 4218 CALL	fpmule
    04286 91E9      LD	R30,Y+
    04287 91F9      LD	R31,Y+
    04288 8339      STD	Y+1,R19
    04289 8328      ST	Y,R18
    0428A 931A      ST	-Y,R17
    0428B 930A      ST	-Y,R16
    0428C 9508      RET
fpcmp:
    0428D 940E 4033 CALL	fpsub
    0428F 2333      TST	R19
    04290 F03A      BMI	0x4298
    04291 940E 4194 CALL	tstR16_R19
    04293 F011      BEQ	0x4296
    04294 E001      LDI	R16,1
    04295 9508      RET
    04296 2700      CLR	R16
    04297 9508      RET
    04298 EF0F      LDI	R16,0xFF
    04299 9508      RET
fpcmp2:
    0429A 93FA      ST	-Y,R31
    0429B 93EA      ST	-Y,R30
    0429C 2FEC      MOV	R30,R28
    0429D 2FFD      MOV	R31,R29
    0429E 9632      ADIW	R30,2
    0429F 940E 428D CALL	fpcmp
    042A1 91E9      LD	R30,Y+
    042A2 91F9      LD	R31,Y+
    042A3 9624      ADIW	R28,4
    042A4 2300      TST	R16
    042A5 9508      RET
_itoa:
    042A6 940E 3E2F CALL	push_arg4
    042A8 940E 3F74 CALL	push_xgsetF0FC
    042AA 01A9      MOVW	R20,R18
    042AB 84EE      LDD	R14,Y+14
    042AC 84FF      LDD	R15,Y+15
    042AD 015A      MOVW	R10,R20
    042AE 20AA      TST	R10
    042AF F451      BNE	0x42BA
    042B0 20BB      TST	R11
    042B1 F441      BNE	0x42BA
    042B2 E380      LDI	R24,0x30
    042B3 85EA      LDD	R30,Y+10
    042B4 85FB      LDD	R31,Y+11
    042B5 8380      ST	Z,R24
    042B6 2422      CLR	R2
    042B7 8221      STD	Z+1,R2
    042B8 018F      MOVW	R16,R30
    042B9 C053      RJMP	0x430D
    042BA 3040      CPI	R20,0
    042BB E0E0      LDI	R30,0
    042BC 075E      CPC	R21,R30
    042BD F46C      BGE	0x42CB
    042BE 01C7      MOVW	R24,R14
    042BF 308A      CPI	R24,0xA
    042C0 E0E0      LDI	R30,0
    042C1 079E      CPC	R25,R30
    042C2 F441      BNE	0x42CB
    042C3 24CC      CLR	R12
    042C4 94C3      INC	R12
    042C5 01C5      MOVW	R24,R10
    042C6 9580      COM	R24
    042C7 9590      COM	R25
    042C8 9601      ADIW	R24,1
    042C9 015C      MOVW	R10,R24
    042CA C001      RJMP	0x42CC
    042CB 24CC      CLR	R12
    042CC 856A      LDD	R22,Y+10
    042CD 857B      LDD	R23,Y+11
    042CE 0197      MOVW	R18,R14
    042CF 0185      MOVW	R16,R10
    042D0 940E 3E5E CALL	mod16u
    042D2 01A8      MOVW	R20,R16
    042D3 E089      LDI	R24,0x9
    042D4 E090      LDI	R25,0
    042D5 1780      CP	R24,R16
    042D6 0791      CPC	R25,R17
    042D7 F034      BLT	0x42DE
    042D8 01CA      MOVW	R24,R20
    042D9 96C0      ADIW	R24,0x30
    042DA 01FB      MOVW	R30,R22
    042DB 9381      ST	Z+,R24
    042DC 01BF      MOVW	R22,R30
    042DD C006      RJMP	0x42E4
    042DE 01CA      MOVW	R24,R20
    042DF 5A89      SUBI	R24,0xA9
    042E0 4F9F      SBCI	R25,0xFF
    042E1 01FB      MOVW	R30,R22
    042E2 9381      ST	Z+,R24
    042E3 01BF      MOVW	R22,R30
    042E4 0197      MOVW	R18,R14
    042E5 0185      MOVW	R16,R10
    042E6 940E 3E60 CALL	div16u
    042E8 0158      MOVW	R10,R16
    042E9 20AA      TST	R10
    042EA F719      BNE	0x42CE
    042EB 20BB      TST	R11
    042EC F709      BNE	0x42CE
    042ED 20CC      TST	R12
    042EE F021      BEQ	0x42F3
    042EF E28D      LDI	R24,0x2D
    042F0 01FB      MOVW	R30,R22
    042F1 9381      ST	Z+,R24
    042F2 01BF      MOVW	R22,R30
    042F3 012B      MOVW	R4,R22
    042F4 5061      SUBI	R22,1
    042F5 4070      SBCI	R23,0
    042F6 2422      CLR	R2
    042F7 01F2      MOVW	R30,R4
    042F8 8220      ST	Z,R2
    042F9 84AA      LDD	R10,Y+10
    042FA 84BB      LDD	R11,Y+11
    042FB C00C      RJMP	0x4308
    042FC 01F5      MOVW	R30,R10
    042FD 80C0      LD	R12,Z
    042FE 01FB      MOVW	R30,R22
    042FF 8020      LD	R2,Z
    04300 01F5      MOVW	R30,R10
    04301 9221      ST	Z+,R2
    04302 015F      MOVW	R10,R30
    04303 011B      MOVW	R2,R22
    04304 5061      SUBI	R22,1
    04305 4070      SBCI	R23,0
    04306 01F1      MOVW	R30,R2
    04307 82C0      ST	Z,R12
    04308 16A6      CP	R10,R22
    04309 06B7      CPC	R11,R23
    0430A F388      BCS	0x42FC
    0430B 850A      LDD	R16,Y+10
    0430C 851B      LDD	R17,Y+11
    0430D 940E 3F69 CALL	pop_xgsetF0FC
    0430F 9624      ADIW	R28,4
    04310 9508      RET
_ltoa:
    04311 940E 3E2F CALL	push_arg4
    04313 940E 3F74 CALL	push_xgsetF0FC
    04315 9724      SBIW	R28,4
    04316 8828      LDD	R2,Y+16
    04317 8839      LDD	R3,Y+17
    04318 884A      LDD	R4,Y+18
    04319 885B      LDD	R5,Y+19
    0431A 8228      ST	Y,R2
    0431B 8239      STD	Y+1,R3
    0431C 824A      STD	Y+2,R4
    0431D 825B      STD	Y+3,R5
    0431E 8828      LDD	R2,Y+16
    0431F 8839      LDD	R3,Y+17
    04320 884A      LDD	R4,Y+18
    04321 885B      LDD	R5,Y+19
    04322 9488      BCLR	0
    04323 2022      TST	R2
    04324 0432      CPC	R3,R2
    04325 0442      CPC	R4,R2
    04326 0452      CPC	R5,R2
    04327 F441      BNE	0x4330
    04328 E380      LDI	R24,0x30
    04329 85EE      LDD	R30,Y+14
    0432A 85FF      LDD	R31,Y+15
    0432B 8380      ST	Z,R24
    0432C 2422      CLR	R2
    0432D 8221      STD	Z+1,R2
    0432E 018F      MOVW	R16,R30
    0432F C094      RJMP	0x43C4
    04330 E040      LDI	R20,0
    04331 E050      LDI	R21,0
    04332 E060      LDI	R22,0
    04333 E070      LDI	R23,0
    04334 8828      LDD	R2,Y+16
    04335 8839      LDD	R3,Y+17
    04336 884A      LDD	R4,Y+18
    04337 885B      LDD	R5,Y+19
    04338 1624      CP	R2,R20
    04339 0635      CPC	R3,R21
    0433A 0646      CPC	R4,R22
    0433B 0657      CPC	R5,R23
    0433C F4EC      BGE	0x435A
    0433D 898C      LDD	R24,Y+20
    0433E 899D      LDD	R25,Y+21
    0433F 308A      CPI	R24,0xA
    04340 E0A0      LDI	R26,0
    04341 079A      CPC	R25,R26
    04342 F4B9      BNE	0x435A
    04343 24AA      CLR	R10
    04344 94A3      INC	R10
    04345 E041      LDI	R20,1
    04346 E050      LDI	R21,0
    04347 E060      LDI	R22,0
    04348 E070      LDI	R23,0
    04349 8028      LD	R2,Y
    0434A 8039      LDD	R3,Y+1
    0434B 804A      LDD	R4,Y+2
    0434C 805B      LDD	R5,Y+3
    0434D 9420      COM	R2
    0434E 9430      COM	R3
    0434F 9440      COM	R4
    04350 9450      COM	R5
    04351 0E24      ADD	R2,R20
    04352 1E35      ADC	R3,R21
    04353 1E46      ADC	R4,R22
    04354 1E57      ADC	R5,R23
    04355 8228      ST	Y,R2
    04356 8239      STD	Y+1,R3
    04357 824A      STD	Y+2,R4
    04358 825B      STD	Y+3,R5
    04359 C001      RJMP	0x435B
    0435A 24AA      CLR	R10
    0435B 84CE      LDD	R12,Y+14
    0435C 84DF      LDD	R13,Y+15
    0435D 882C      LDD	R2,Y+20
    0435E 883D      LDD	R3,Y+21
    0435F 2444      CLR	R4
    04360 FC37      SBRC	R3,7
    04361 9440      COM	R4
    04362 2455      CLR	R5
    04363 FC47      SBRC	R4,7
    04364 9450      COM	R5
    04365 8108      LD	R16,Y
    04366 8119      LDD	R17,Y+1
    04367 812A      LDD	R18,Y+2
    04368 813B      LDD	R19,Y+3
    04369 925A      ST	-Y,R5
    0436A 924A      ST	-Y,R4
    0436B 923A      ST	-Y,R3
    0436C 922A      ST	-Y,R2
    0436D 940E 3E7C CALL	mod32u
    0436F 0178      MOVW	R14,R16
    04370 E089      LDI	R24,0x9
    04371 E090      LDI	R25,0
    04372 1780      CP	R24,R16
    04373 0791      CPC	R25,R17
    04374 F034      BLT	0x437B
    04375 01C7      MOVW	R24,R14
    04376 96C0      ADIW	R24,0x30
    04377 01F6      MOVW	R30,R12
    04378 9381      ST	Z+,R24
    04379 016F      MOVW	R12,R30
    0437A C006      RJMP	0x4381
    0437B 01C7      MOVW	R24,R14
    0437C 5A89      SUBI	R24,0xA9
    0437D 4F9F      SBCI	R25,0xFF
    0437E 01F6      MOVW	R30,R12
    0437F 9381      ST	Z+,R24
    04380 016F      MOVW	R12,R30
    04381 882C      LDD	R2,Y+20
    04382 883D      LDD	R3,Y+21
    04383 2444      CLR	R4
    04384 FC37      SBRC	R3,7
    04385 9440      COM	R4
    04386 2455      CLR	R5
    04387 FC47      SBRC	R4,7
    04388 9450      COM	R5
    04389 8108      LD	R16,Y
    0438A 8119      LDD	R17,Y+1
    0438B 812A      LDD	R18,Y+2
    0438C 813B      LDD	R19,Y+3
    0438D 925A      ST	-Y,R5
    0438E 924A      ST	-Y,R4
    0438F 923A      ST	-Y,R3
    04390 922A      ST	-Y,R2
    04391 940E 3E7A CALL	div32u
    04393 8308      ST	Y,R16
    04394 8319      STD	Y+1,R17
    04395 832A      STD	Y+2,R18
    04396 833B      STD	Y+3,R19
    04397 8028      LD	R2,Y
    04398 8039      LDD	R3,Y+1
    04399 804A      LDD	R4,Y+2
    0439A 805B      LDD	R5,Y+3
    0439B 9488      BCLR	0
    0439C 2022      TST	R2
    0439D 0432      CPC	R3,R2
    0439E 0442      CPC	R4,R2
    0439F 0452      CPC	R5,R2
    043A0 F009      BEQ	0x43A2
    043A1 CFBB      RJMP	0x435D
    043A2 20AA      TST	R10
    043A3 F021      BEQ	0x43A8
    043A4 E28D      LDI	R24,0x2D
    043A5 01F6      MOVW	R30,R12
    043A6 9381      ST	Z+,R24
    043A7 016F      MOVW	R12,R30
    043A8 0126      MOVW	R4,R12
    043A9 01C2      MOVW	R24,R4
    043AA 9701      SBIW	R24,1
    043AB 016C      MOVW	R12,R24
    043AC 2422      CLR	R2
    043AD 01F2      MOVW	R30,R4
    043AE 8220      ST	Z,R2
    043AF 84EE      LDD	R14,Y+14
    043B0 84FF      LDD	R15,Y+15
    043B1 C00D      RJMP	0x43BF
    043B2 01F7      MOVW	R30,R14
    043B3 80A0      LD	R10,Z
    043B4 01F6      MOVW	R30,R12
    043B5 8020      LD	R2,Z
    043B6 01F7      MOVW	R30,R14
    043B7 9221      ST	Z+,R2
    043B8 017F      MOVW	R14,R30
    043B9 0116      MOVW	R2,R12
    043BA 01C1      MOVW	R24,R2
    043BB 9701      SBIW	R24,1
    043BC 016C      MOVW	R12,R24
    043BD 01F1      MOVW	R30,R2
    043BE 82A0      ST	Z,R10
    043BF 14EC      CP	R14,R12
    043C0 04FD      CPC	R15,R13
    043C1 F380      BCS	0x43B2
    043C2 850E      LDD	R16,Y+14
    043C3 851F      LDD	R17,Y+15
    043C4 9624      ADIW	R28,4
    043C5 940E 3F69 CALL	pop_xgsetF0FC
    043C7 9624      ADIW	R28,4
    043C8 9508      RET
_ftoa:
    043C9 940E 3E2F CALL	push_arg4
    043CB 940E 3F74 CALL	push_xgsetF0FC
    043CD 9764      SBIW	R28,0x14
    043CE A0CA      LDD	R12,Y+34
    043CF A0DB      LDD	R13,Y+35
    043D0 2422      CLR	R2
    043D1 2433      CLR	R3
    043D2 01F6      MOVW	R30,R12
    043D3 8231      STD	Z+1,R3
    043D4 8220      ST	Z,R2
    043D5 8C2E      LDD	R2,Y+30
    043D6 8C3F      LDD	R3,Y+31
    043D7 A048      LDD	R4,Y+32
    043D8 A059      LDD	R5,Y+33
    043D9 EC0C      LDI	R16,0xCC
    043DA E010      LDI	R17,0
    043DB 940E 3EFC CALL	elpm32
    043DD 933A      ST	-Y,R19
    043DE 932A      ST	-Y,R18
    043DF 931A      ST	-Y,R17
    043E0 930A      ST	-Y,R16
    043E1 0181      MOVW	R16,R2
    043E2 0192      MOVW	R18,R4
    043E3 940E 429A CALL	fpcmp2
    043E5 F479      BNE	0x43F5
    043E6 E380      LDI	R24,0x30
    043E7 9380 07CB STS	config+19,R24
    043E9 E28E      LDI	R24,0x2E
    043EA 9380 07CC STS	config+20,R24
    043EC E380      LDI	R24,0x30
    043ED 9380 07CD STS	config+21,R24
    043EF 2422      CLR	R2
    043F0 9220 07CE STS	config+22,R2
    043F2 EC0B      LDI	R16,0xCB
    043F3 E017      LDI	R17,7
    043F4 C15E      RJMP	0x4553
    043F5 8C2E      LDD	R2,Y+30
    043F6 8C3F      LDD	R3,Y+31
    043F7 A048      LDD	R4,Y+32
    043F8 A059      LDD	R5,Y+33
    043F9 8628      STD	Y+8,R2
    043FA 8639      STD	Y+9,R3
    043FB 864A      STD	Y+10,R4
    043FC 865B      STD	Y+11,R5
    043FD E187      LDI	R24,0x17
    043FE E090      LDI	R25,0
    043FF 8508      LDD	R16,Y+8
    04400 8519      LDD	R17,Y+9
    04401 852A      LDD	R18,Y+10
    04402 853B      LDD	R19,Y+11
    04403 938A      ST	-Y,R24
    04404 940E 3E34 CALL	asr32
    04406 2F80      MOV	R24,R16
    04407 2799      CLR	R25
    04408 578F      SUBI	R24,0x7F
    04409 4090      SBCI	R25,0
    0440A 015C      MOVW	R10,R24
    0440B EF4F      LDI	R20,0xFF
    0440C EF5F      LDI	R21,0xFF
    0440D EF6F      LDI	R22,0xFF
    0440E E070      LDI	R23,0
    0440F 8428      LDD	R2,Y+8
    04410 8439      LDD	R3,Y+9
    04411 844A      LDD	R4,Y+10
    04412 845B      LDD	R5,Y+11
    04413 2224      AND	R2,R20
    04414 2235      AND	R3,R21
    04415 2246      AND	R4,R22
    04416 2257      AND	R5,R23
    04417 93EF      PUSH	R30
    04418 2DE4      MOV	R30,R4
    04419 68E0      ORI	R30,0x80
    0441A 2E4E      MOV	R4,R30
    0441B 91EF      POP	R30
    0441C 8A28      STD	Y+16,R2
    0441D 8A39      STD	Y+17,R3
    0441E 8A4A      STD	Y+18,R4
    0441F 8A5B      STD	Y+19,R5
    04420 E080      LDI	R24,0
    04421 838C      STD	Y+4,R24
    04422 838D      STD	Y+5,R24
    04423 838E      STD	Y+6,R24
    04424 838F      STD	Y+7,R24
    04425 E080      LDI	R24,0
    04426 878C      STD	Y+12,R24
    04427 878D      STD	Y+13,R24
    04428 878E      STD	Y+14,R24
    04429 878F      STD	Y+15,R24
    0442A 01C5      MOVW	R24,R10
    0442B 318F      CPI	R24,0x1F
    0442C E0E0      LDI	R30,0
    0442D 079E      CPC	R25,R30
    0442E F044      BLT	0x4437
    0442F EF8E      LDI	R24,0xFE
    04430 EF9F      LDI	R25,0xFF
    04431 01F6      MOVW	R30,R12
    04432 8391      STD	Z+1,R25
    04433 8380      ST	Z,R24
    04434 2700      CLR	R16
    04435 2711      CLR	R17
    04436 C11C      RJMP	0x4553
    04437 01C5      MOVW	R24,R10
    04438 3E89      CPI	R24,0xE9
    04439 EFEF      LDI	R30,0xFF
    0443A 079E      CPC	R25,R30
    0443B F444      BGE	0x4444
    0443C EF8F      LDI	R24,0xFF
    0443D EF9F      LDI	R25,0xFF
    0443E 01F6      MOVW	R30,R12
    0443F 8391      STD	Z+1,R25
    04440 8380      ST	Z,R24
    04441 2700      CLR	R16
    04442 2711      CLR	R17
    04443 C10F      RJMP	0x4553
    04444 01C5      MOVW	R24,R10
    04445 3187      CPI	R24,0x17
    04446 E0A0      LDI	R26,0
    04447 079A      CPC	R25,R26
    04448 F06C      BLT	0x4456
    04449 9747      SBIW	R24,0x17
    0444A 8908      LDD	R16,Y+16
    0444B 8919      LDD	R17,Y+17
    0444C 892A      LDD	R18,Y+18
    0444D 893B      LDD	R19,Y+19
    0444E 938A      ST	-Y,R24
    0444F 940E 3FF6 CALL	lsl32
    04451 870C      STD	Y+12,R16
    04452 871D      STD	Y+13,R17
    04453 872E      STD	Y+14,R18
    04454 873F      STD	Y+15,R19
    04455 C045      RJMP	0x449B
    04456 01C5      MOVW	R24,R10
    04457 3080      CPI	R24,0
    04458 E0A0      LDI	R26,0
    04459 079A      CPC	R25,R26
    0445A F13C      BLT	0x4482
    0445B E187      LDI	R24,0x17
    0445C E090      LDI	R25,0
    0445D 198A      SUB	R24,R10
    0445E 099B      SBC	R25,R11
    0445F 8908      LDD	R16,Y+16
    04460 8919      LDD	R17,Y+17
    04461 892A      LDD	R18,Y+18
    04462 893B      LDD	R19,Y+19
    04463 938A      ST	-Y,R24
    04464 940E 3E34 CALL	asr32
    04466 870C      STD	Y+12,R16
    04467 871D      STD	Y+13,R17
    04468 872E      STD	Y+14,R18
    04469 873F      STD	Y+15,R19
    0446A 01C5      MOVW	R24,R10
    0446B 9601      ADIW	R24,1
    0446C 8908      LDD	R16,Y+16
    0446D 8919      LDD	R17,Y+17
    0446E 892A      LDD	R18,Y+18
    0446F 893B      LDD	R19,Y+19
    04470 938A      ST	-Y,R24
    04471 940E 3FF6 CALL	lsl32
    04473 0118      MOVW	R2,R16
    04474 0129      MOVW	R4,R18
    04475 EF4F      LDI	R20,0xFF
    04476 EF5F      LDI	R21,0xFF
    04477 EF6F      LDI	R22,0xFF
    04478 E070      LDI	R23,0
    04479 2224      AND	R2,R20
    0447A 2235      AND	R3,R21
    0447B 2246      AND	R4,R22
    0447C 2257      AND	R5,R23
    0447D 822C      STD	Y+4,R2
    0447E 823D      STD	Y+5,R3
    0447F 824E      STD	Y+6,R4
    04480 825F      STD	Y+7,R5
    04481 C019      RJMP	0x449B
    04482 EF4F      LDI	R20,0xFF
    04483 EF5F      LDI	R21,0xFF
    04484 EF6F      LDI	R22,0xFF
    04485 E070      LDI	R23,0
    04486 8908      LDD	R16,Y+16
    04487 8919      LDD	R17,Y+17
    04488 892A      LDD	R18,Y+18
    04489 893B      LDD	R19,Y+19
    0448A 2304      AND	R16,R20
    0448B 2315      AND	R17,R21
    0448C 2326      AND	R18,R22
    0448D 2337      AND	R19,R23
    0448E 01C5      MOVW	R24,R10
    0448F 9601      ADIW	R24,1
    04490 9580      COM	R24
    04491 9590      COM	R25
    04492 5F8F      SUBI	R24,0xFF
    04493 4F9F      SBCI	R25,0xFF
    04494 938A      ST	-Y,R24
    04495 940E 3E34 CALL	asr32
    04497 830C      STD	Y+4,R16
    04498 831D      STD	Y+5,R17
    04499 832E      STD	Y+6,R18
    0449A 833F      STD	Y+7,R19
    0449B EC8B      LDI	R24,0xCB
    0449C E097      LDI	R25,7
    0449D 015C      MOVW	R10,R24
    0449E E040      LDI	R20,0
    0449F E050      LDI	R21,0
    044A0 E060      LDI	R22,0
    044A1 E070      LDI	R23,0
    044A2 8428      LDD	R2,Y+8
    044A3 8439      LDD	R3,Y+9
    044A4 844A      LDD	R4,Y+10
    044A5 845B      LDD	R5,Y+11
    044A6 1624      CP	R2,R20
    044A7 0635      CPC	R3,R21
    044A8 0646      CPC	R4,R22
    044A9 0657      CPC	R5,R23
    044AA F424      BGE	0x44AF
    044AB E28D      LDI	R24,0x2D
    044AC 01F5      MOVW	R30,R10
    044AD 9381      ST	Z+,R24
    044AE 015F      MOVW	R10,R30
    044AF 842C      LDD	R2,Y+12
    044B0 843D      LDD	R3,Y+13
    044B1 844E      LDD	R4,Y+14
    044B2 845F      LDD	R5,Y+15
    044B3 9488      BCLR	0
    044B4 2022      TST	R2
    044B5 0432      CPC	R3,R2
    044B6 0442      CPC	R4,R2
    044B7 0452      CPC	R5,R2
    044B8 F429      BNE	0x44BE
    044B9 E380      LDI	R24,0x30
    044BA 01F5      MOVW	R30,R10
    044BB 9381      ST	Z+,R24
    044BC 015F      MOVW	R10,R30
    044BD C016      RJMP	0x44D4
    044BE E08A      LDI	R24,0xA
    044BF E090      LDI	R25,0
    044C0 839B      STD	Y+3,R25
    044C1 838A      STD	Y+2,R24
    044C2 842C      LDD	R2,Y+12
    044C3 843D      LDD	R3,Y+13
    044C4 844E      LDD	R4,Y+14
    044C5 845F      LDD	R5,Y+15
    044C6 8248      ST	Y,R4
    044C7 8259      STD	Y+1,R5
    044C8 0191      MOVW	R18,R2
    044C9 0185      MOVW	R16,R10
    044CA 940E 4311 CALL	_ltoa
    044CC C003      RJMP	0x44D0
    044CD 01C5      MOVW	R24,R10
    044CE 9601      ADIW	R24,1
    044CF 015C      MOVW	R10,R24
    044D0 01F5      MOVW	R30,R10
    044D1 8020      LD	R2,Z
    044D2 2022      TST	R2
    044D3 F7C9      BNE	0x44CD
    044D4 E28E      LDI	R24,0x2E
    044D5 01F5      MOVW	R30,R10
    044D6 9381      ST	Z+,R24
    044D7 015F      MOVW	R10,R30
    044D8 802C      LDD	R2,Y+4
    044D9 803D      LDD	R3,Y+5
    044DA 804E      LDD	R4,Y+6
    044DB 805F      LDD	R5,Y+7
    044DC 9488      BCLR	0
    044DD 2022      TST	R2
    044DE 0432      CPC	R3,R2
    044DF 0442      CPC	R4,R2
    044E0 0452      CPC	R5,R2
    044E1 F421      BNE	0x44E6
    044E2 E380      LDI	R24,0x30
    044E3 9381      ST	Z+,R24
    044E4 015F      MOVW	R10,R30
    044E5 C068      RJMP	0x454E
    044E6 EC8B      LDI	R24,0xCB
    044E7 E097      LDI	R25,7
    044E8 0115      MOVW	R2,R10
    044E9 1A28      SUB	R2,R24
    044EA 0A39      SBC	R3,R25
    044EB E08F      LDI	R24,0xF
    044EC E090      LDI	R25,0
    044ED 1982      SUB	R24,R2
    044EE 0993      SBC	R25,R3
    044EF 9701      SBIW	R24,1
    044F0 2EC8      MOV	R12,R24
    044F1 E087      LDI	R24,7
    044F2 158C      CP	R24,R12
    044F3 F408      BCC	0x44F5
    044F4 2EC8      MOV	R12,R24
    044F5 24EE      CLR	R14
    044F6 C042      RJMP	0x4539
    044F7 E083      LDI	R24,3
    044F8 E090      LDI	R25,0
    044F9 810C      LDD	R16,Y+4
    044FA 811D      LDD	R17,Y+5
    044FB 812E      LDD	R18,Y+6
    044FC 813F      LDD	R19,Y+7
    044FD 938A      ST	-Y,R24
    044FE 940E 3FF6 CALL	lsl32
    04500 0118      MOVW	R2,R16
    04501 0129      MOVW	R4,R18
    04502 806C      LDD	R6,Y+4
    04503 807D      LDD	R7,Y+5
    04504 808E      LDD	R8,Y+6
    04505 809F      LDD	R9,Y+7
    04506 0C66      LSL	R6
    04507 1C77      ROL	R7
    04508 1C88      ROL	R8
    04509 1C99      ROL	R9
    0450A 0C26      ADD	R2,R6
    0450B 1C37      ADC	R3,R7
    0450C 1C48      ADC	R4,R8
    0450D 1C59      ADC	R5,R9
    0450E 822C      STD	Y+4,R2
    0450F 823D      STD	Y+5,R3
    04510 824E      STD	Y+6,R4
    04511 825F      STD	Y+7,R5
    04512 E188      LDI	R24,0x18
    04513 E090      LDI	R25,0
    04514 810C      LDD	R16,Y+4
    04515 811D      LDD	R17,Y+5
    04516 812E      LDD	R18,Y+6
    04517 813F      LDD	R19,Y+7
    04518 938A      ST	-Y,R24
    04519 940E 3E34 CALL	asr32
    0451B 0118      MOVW	R2,R16
    0451C 0129      MOVW	R4,R18
    0451D E340      LDI	R20,0x30
    0451E E050      LDI	R21,0
    0451F E060      LDI	R22,0
    04520 E070      LDI	R23,0
    04521 0E24      ADD	R2,R20
    04522 1E35      ADC	R3,R21
    04523 1E46      ADC	R4,R22
    04524 1E57      ADC	R5,R23
    04525 01F5      MOVW	R30,R10
    04526 9221      ST	Z+,R2
    04527 015F      MOVW	R10,R30
    04528 EF4F      LDI	R20,0xFF
    04529 EF5F      LDI	R21,0xFF
    0452A EF6F      LDI	R22,0xFF
    0452B E070      LDI	R23,0
    0452C 802C      LDD	R2,Y+4
    0452D 803D      LDD	R3,Y+5
    0452E 804E      LDD	R4,Y+6
    0452F 805F      LDD	R5,Y+7
    04530 2224      AND	R2,R20
    04531 2235      AND	R3,R21
    04532 2246      AND	R4,R22
    04533 2257      AND	R5,R23
    04534 822C      STD	Y+4,R2
    04535 823D      STD	Y+5,R3
    04536 824E      STD	Y+6,R4
    04537 825F      STD	Y+7,R5
    04538 94E3      INC	R14
    04539 14EC      CP	R14,R12
    0453A F408      BCC	0x453C
    0453B CFBB      RJMP	0x44F7
    0453C 01C5      MOVW	R24,R10
    0453D 9701      SBIW	R24,1
    0453E 015C      MOVW	R10,R24
    0453F C003      RJMP	0x4543
    04540 01C5      MOVW	R24,R10
    04541 9701      SBIW	R24,1
    04542 015C      MOVW	R10,R24
    04543 01F5      MOVW	R30,R10
    04544 8180      LD	R24,Z
    04545 3380      CPI	R24,0x30
    04546 F421      BNE	0x454B
    04547 9731      SBIW	R30,1
    04548 8180      LD	R24,Z
    04549 328E      CPI	R24,0x2E
    0454A F7A9      BNE	0x4540
    0454B 01C5      MOVW	R24,R10
    0454C 9601      ADIW	R24,1
    0454D 015C      MOVW	R10,R24
    0454E 2422      CLR	R2
    0454F 01F5      MOVW	R30,R10
    04550 8220      ST	Z,R2
    04551 EC0B      LDI	R16,0xCB
    04552 E017      LDI	R17,7
    04553 9664      ADIW	R28,0x14
    04554 940E 3F69 CALL	pop_xgsetF0FC
    04556 9624      ADIW	R28,4
    04557 9508      RET
